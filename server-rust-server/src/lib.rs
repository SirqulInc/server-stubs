#![allow(missing_docs, trivial_casts, unused_variables, unused_mut, unused_imports, unused_extern_crates, unused_attributes, non_camel_case_types)]
#![allow(clippy::derive_partial_eq_without_eq, clippy::disallowed_names)]

use async_trait::async_trait;
use futures::Stream;
#[cfg(feature = "mock")]
use mockall::automock;
use std::error::Error;
use std::collections::BTreeSet;
use std::task::{Poll, Context};
use swagger::{ApiError, ContextWrapper, auth::Authorization};
use serde::{Serialize, Deserialize};

#[cfg(any(feature = "client", feature = "server"))]
type ServiceError = Box<dyn Error + Send + Sync + 'static>;

pub const BASE_PATH: &str = "";
pub const API_VERSION: &str = "3.16";

mod auth;
pub use auth::{AuthenticationApi, Claims};


#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum ConsumerCreateResponse {
    /// successful operation
    SuccessfulOperation
    (models::QueueResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum ConsumerUpdateResponse {
    /// successful operation
    SuccessfulOperation
    (models::QueueResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum QueueCreateResponse {
    /// successful operation
    SuccessfulOperation
    (models::QueueResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum QueueDeleteResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum QueueGetResponse {
    /// successful operation
    SuccessfulOperation
    (models::QueueResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum QueuePublishResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum QueueSearchResponse {
    /// successful operation
    SuccessfulOperation
    (models::QueueResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum QueueUpdateResponse {
    /// successful operation
    SuccessfulOperation
    (models::QueueResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum AccountLocationSearchResponse {
    /// successful operation
    SuccessfulOperation
    (models::UserLocationSearchResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum BlockAccountResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum CreateAccountResponse {
    /// successful operation
    SuccessfulOperation
    (models::AccountLoginResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum EditAccountResponse {
    /// successful operation
    SuccessfulOperation
    (models::ProfileInfoResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum EditUsernameResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetAccountResponse {
    /// successful operation
    SuccessfulOperation
    (models::ProfileResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetProfileAssetsResponse {
    /// successful operation
    SuccessfulOperation
    (models::AssetListResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetReferralListResponse {
    /// successful operation
    SuccessfulOperation
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetSettingsResponse {
    /// successful operation
    SuccessfulOperation
    (models::UserSettingsResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum LoginDelegateResponse {
    /// successful operation
    SuccessfulOperation
    (models::ProfileResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum LoginGeneralResponse {
    /// successful operation
    SuccessfulOperation
    (models::ProfileResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum LoginUsernameResponse {
    /// successful operation
    SuccessfulOperation
    (models::ProfileResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum LogoutResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum MergeAccountResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum PasswordChangeResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum PasswordResetResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum RequestPasswordResetResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum RequestValidateAccountResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum SearchAccountsResponse {
    /// successful operation
    SuccessfulOperation
    (Vec<models::ProfileResponse>)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum SecureLoginResponse {
    /// successful operation
    SuccessfulOperation
    (models::ProfileResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum SecureSignupResponse {
    /// successful operation
    SuccessfulOperation
    (models::ProfileInfoResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum SetMatchTokenResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum UpdateActveStatusResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum UpdateLocationResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum UpdateSettingsResponse {
    /// successful operation
    SuccessfulOperation
    (models::UserSettingsResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum ValidateAccountSignupResponse {
    /// successful operation
    SuccessfulOperation
    (models::AccountLoginResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum ValidatePasswordResetResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum ApiVersionAchievementTierSearchPostResponse {
    /// successful operation
    SuccessfulOperation
    (models::AchievementTierResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum CreateAchievementResponse {
    /// successful operation
    SuccessfulOperation
    (models::AchievementResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum CreateAchievementTierResponse {
    /// successful operation
    SuccessfulOperation
    (models::AchievementTierResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum DeleteAchievementResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum DeleteAchievementTierResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetAchievementResponse {
    /// successful operation
    SuccessfulOperation
    (models::AchievementTierResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetAchievementTierResponse {
    /// successful operation
    SuccessfulOperation
    (models::AchievementTierResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetUserAchievementsResponse {
    /// successful operation
    SuccessfulOperation
    (Vec<models::AchievementProgressResponse>)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum ListAchievementTagsResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum ListAchievementsResponse {
    /// successful operation
    SuccessfulOperation
    (Vec<models::AchievementShortResponse>)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum SearchAchievementsResponse {
    /// successful operation
    SuccessfulOperation
    (Vec<models::AchievementShortResponse>)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum UpdateAchievementResponse {
    /// successful operation
    SuccessfulOperation
    (models::AchievementResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum UpdateAchievementTierResponse {
    /// successful operation
    SuccessfulOperation
    (models::AchievementTierResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum UpdateUserAchievementResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum CreateEntityReferenceResponse {
    /// successful operation
    SuccessfulOperation
    (models::ActivityResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum AddAlbumCollectionResponse {
    /// successful operation
    SuccessfulOperation
    (models::SearchResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum AddAlbumUsersResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum ApproveAlbumResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetAlbumCollectionResponse {
    /// successful operation
    SuccessfulOperation
    (models::AlbumFullResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum LeaveAlbumResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum RemoveAlbumResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum RemoveAlbumUsersResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum SearchAlbumsResponse {
    /// successful operation
    SuccessfulOperation
    (Vec<models::AlbumFullResponse>)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum UpdateAlbumCollectionResponse {
    /// successful operation
    SuccessfulOperation
    (models::AlbumResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum ActivitiesResponse {
    /// successful operation
    SuccessfulOperation
    (Vec<models::UserActivityResponse>)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum AggregatedFilteredUsageResponse {
    /// successful operation
    SuccessfulOperation
    (models::ChartData)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum FilteredUsageResponse {
    /// successful operation
    SuccessfulOperation
    (models::ChartData)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum UsageResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum UsageBatchResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetAppDataResponse {
    /// successful operation
    SuccessfulOperation
    (models::AppResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum PostAppDataResponse {
    /// successful operation
    SuccessfulOperation
    (models::AppResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum RegenAppDataResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum CreateApplicationResponse {
    /// successful operation
    SuccessfulOperation
    (models::ApplicationResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum CreateApplicationPlacementResponse {
    /// successful operation
    SuccessfulOperation
    (models::PlacementResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum DeleteApplicationResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum DeleteApplicationPlacementResponse {
    /// successful operation
    SuccessfulOperation
    (models::PlacementResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetApplicationResponse {
    /// successful operation
    SuccessfulOperation
    (models::ApplicationResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetApplicationPlacementResponse {
    /// successful operation
    SuccessfulOperation
    (models::PlacementResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetApplicationVersionsResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetUniqueUsersByAppResponse {
    /// successful operation
    SuccessfulOperation
    (models::AccountListResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum ListApplicationsResponse {
    /// successful operation
    SuccessfulOperation
    (Vec<models::ApplicationShortResponse>)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum SearchApplicationPlacementResponse {
    /// successful operation
    SuccessfulOperation
    (Vec<models::PlacementResponse>)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum SearchApplicationSettingsResponse {
    /// successful operation
    SuccessfulOperation
    (models::ApplicationSettingsResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum SearchApplicationsResponse {
    /// successful operation
    SuccessfulOperation
    (Vec<models::ApplicationResponse>)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum UpdateApplicationResponse {
    /// successful operation
    SuccessfulOperation
    (models::ApplicationResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum UpdateApplicationActiveResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum UpdateApplicationPlacementResponse {
    /// successful operation
    SuccessfulOperation
    (models::PlacementResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum UploadApplicationCertificateResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum CreateApplicationConfigResponse {
    /// successful operation
    SuccessfulOperation
    (models::ApplicationConfigResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum DeleteApplicationConfigResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetApplicationConfigResponse {
    /// successful operation
    SuccessfulOperation
    (models::ApplicationConfigResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetApplicationConfigByConfigVersionResponse {
    /// successful operation
    SuccessfulOperation
    (models::ApplicationConfigResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum SearchApplicationConfigResponse {
    /// successful operation
    SuccessfulOperation
    (Vec<models::ApplicationConfigResponse>)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum UpdateApplicationConfigResponse {
    /// successful operation
    SuccessfulOperation
    (models::ApplicationConfigResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum AssetMorphResponse {
    /// successful operation
    SuccessfulOperation
    (models::AssetShortResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum CreateAssetResponse {
    /// successful operation
    SuccessfulOperation
    (models::AssetResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum DeleteAssetResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetAssetResponse {
    /// successful operation
    SuccessfulOperation
    (models::AssetFullResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum RemoveAssetResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum SearchAssetsResponse {
    /// successful operation
    SuccessfulOperation
    (Vec<models::AssetResponse>)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum UpdateAssetResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum AssetDownloadResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum AssigmentAssigneeAccountSearchResponse {
    /// successful operation
    SuccessfulOperation
    (Vec<models::AccountMiniResponse>)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum AssignmentCreateResponse {
    /// successful operation
    SuccessfulOperation
    (models::AssignmentResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum AssignmentDeleteResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum AssignmentGetResponse {
    /// successful operation
    SuccessfulOperation
    (models::AssignmentResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum AssignmentSearchResponse {
    /// successful operation
    SuccessfulOperation
    (Vec<models::AssignmentResponse>)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum AssignmentStatusCreateResponse {
    /// successful operation
    SuccessfulOperation
    (models::AssignmentStatusResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum AssignmentStatusDeleteResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum AssignmentStatusGetResponse {
    /// successful operation
    SuccessfulOperation
    (models::AssignmentStatusResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum AssignmentStatusSearchResponse {
    /// successful operation
    SuccessfulOperation
    (Vec<models::AssignmentStatusResponse>)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum AssignmentStatusUpdateResponse {
    /// successful operation
    SuccessfulOperation
    (models::AssignmentStatusResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum AssignmentUpdateResponse {
    /// successful operation
    SuccessfulOperation
    (models::AssignmentResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum CreateAudienceResponse {
    /// successful operation
    SuccessfulOperation
    (models::AudienceResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum DeleteAudienceResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetAgeGroupsResponse {
    /// successful operation
    SuccessfulOperation
    (Vec<models::AgeGroupResponse>)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetAudienceResponse {
    /// successful operation
    SuccessfulOperation
    (models::AudienceResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetAudienceListResponse {
    /// successful operation
    SuccessfulOperation
    (Vec<models::SearchResponse>)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetDevicesResponse {
    /// successful operation
    SuccessfulOperation
    (Vec<models::AudienceDeviceResponse>)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetExperiencesResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetGroupedAudiencesResponse {
    /// successful operation
    SuccessfulOperation
    (models::AudienceResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum ListByAccountResponse {
    /// successful operation
    SuccessfulOperation
    (models::OfferListResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum ListByAudienceResponse {
    /// successful operation
    SuccessfulOperation
    (models::OfferListResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum ListLastestByAccountResponse {
    /// successful operation
    SuccessfulOperation
    (models::OfferListResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum SendByAccountResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum UpdateAudienceResponse {
    /// successful operation
    SuccessfulOperation
    (models::AudienceResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum CreateBidResponse {
    /// successful operation
    SuccessfulOperation
    (models::BidResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum DeleteBidResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetBidResponse {
    /// successful operation
    SuccessfulOperation
    (models::BidResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum UpdateBidResponse {
    /// successful operation
    SuccessfulOperation
    (models::BidResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum CreateBillableEntityResponse {
    /// successful operation
    SuccessfulOperation
    (models::BillableEntityResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum DeleteBillableEntityResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetBillableEntityResponse {
    /// successful operation
    SuccessfulOperation
    (models::BillableEntityResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum UpdateBillableEntityResponse {
    /// successful operation
    SuccessfulOperation
    (models::BillableEntityResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum AddPaymentMethodResponse {
    /// successful operation
    SuccessfulOperation
    (models::PaymentTypesResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum CreatePaymentMethodResponse {
    /// successful operation
    SuccessfulOperation
    (models::PaymentTypesResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum CreateSmartContractResponse {
    /// successful operation
    SuccessfulOperation
    (models::PaymentTypesResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetCryptoBalanceResponse {
    /// successful operation
    SuccessfulOperation
    (models::PaymentTypesResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetPaymentMethodResponse {
    /// successful operation
    SuccessfulOperation
    (models::PaymentTypesResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum SearchPaymentMethodResponse {
    /// successful operation
    SuccessfulOperation
    (models::PaymentTypesResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetStatusCsvResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum ListStatusCsvResponse {
    /// successful operation
    SuccessfulOperation
    (models::CsvImportResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum StatusCsvResponse {
    /// successful operation
    SuccessfulOperation
    (models::CsvImportResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum UploadCsvResponse {
    /// successful operation
    SuccessfulOperation
    (models::CsvImportResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum CreateCargoTypeResponse {
    /// successful operation
    SuccessfulOperation
    (models::CargoType)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum SearchCargoTypesResponse {
    /// successful operation
    SuccessfulOperation
    (Vec<models::CargoType>)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum DeleteCargoTypeResponse {
    /// successful operation
    SuccessfulOperation
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetCargoTypeResponse {
    /// successful operation
    SuccessfulOperation
    (models::CargoType)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum UpdateCargoTypeResponse {
    /// successful operation
    SuccessfulOperation
    (models::CargoType)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum SearchCarriersResponse {
    /// successful operation
    SuccessfulOperation
    (Vec<models::CellCarrierResponse>)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum CategoryDistanceSearchResponse {
    /// successful operation
    SuccessfulOperation
    (Vec<models::CategoryResponse>)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum CreateCategoryResponse {
    /// successful operation
    SuccessfulOperation
    (models::CategoryTreeResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum DeleteCategoryResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum DuplicateCategoryResponse {
    /// successful operation
    SuccessfulOperation
    (models::CategoryTreeResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetCategoryResponse {
    /// successful operation
    SuccessfulOperation
    (models::CategoryTreeResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum SearchCategoriesResponse {
    /// successful operation
    SuccessfulOperation
    (Vec<models::CategoryResponse>)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum UpdateCategoryResponse {
    /// successful operation
    SuccessfulOperation
    (models::CategoryTreeResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum AddConnectionToGroupResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum AddConnectionsToGroupResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum AddSubGroupsResponse {
    /// successful operation
    SuccessfulOperation
    (models::ConnectionGroupResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum CreateOrUpdateConnectionResponse {
    /// successful operation
    SuccessfulOperation
    (models::ConnectionResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum CreateOrUpdateGroupResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum FollowAcceptResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum FollowRejectResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum FollowRemoveResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum FollowRequestResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum FriendAcceptResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum FriendRejectResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum FriendRemoveResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum FriendRequestResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetConnectionSentFriendRequestsResponse {
    /// successful operation
    SuccessfulOperation
    (models::ConnectionListResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetConnectionsResponse {
    /// successful operation
    SuccessfulOperation
    (models::ConnectionListResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetGroupDetailsResponse {
    /// successful operation
    SuccessfulOperation
    (models::ConnectionGroupResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GroupSearchResponse {
    /// successful operation
    SuccessfulOperation
    (Vec<models::ConnectionInfoResponse>)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum RemoveConnectionFromGroupResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum RemoveConnectionsFromGroupResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum RemoveGroupResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum RemoveSubGroupsResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum SearchConnectionsResponse {
    /// successful operation
    SuccessfulOperation
    (models::ConnectionListResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum AddOrUpdateAlbumContestResponse {
    /// successful operation
    SuccessfulOperation
    (models::AlbumContestResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum ApproveAlbumContestResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum DeleteContestResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetAlbumContestResponse {
    /// successful operation
    SuccessfulOperation
    (models::AlbumContestResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetAlbumContestsResponse {
    /// successful operation
    SuccessfulOperation
    (models::AlbumContestListResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum VoteOnAlbumContestResponse {
    /// successful operation
    SuccessfulOperation
    (models::AlbumContestResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum AddPreviewResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum AdsFindResponse {
    /// successful operation
    SuccessfulOperation
    (Vec<models::MissionResponse>)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum CreateCreativeResponse {
    /// successful operation
    SuccessfulOperation
    (models::CreativeResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum DeleteCreativeResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetCreativeResponse {
    /// successful operation
    SuccessfulOperation
    (models::CreativeResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetCreativesByApplicationResponse {
    /// successful operation
    SuccessfulOperation
    (Vec<models::CreativeResponse>)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum RemovePreviewResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum UpdateCreativeResponse {
    /// successful operation
    SuccessfulOperation
    (models::CreativeResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum CreateResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetDependentsResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum RemoveDependentResponse {
    /// successful operation
    SuccessfulOperation
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum CheckDisbursementsResponse {
    /// successful operation
    SuccessfulOperation
    (models::DisbursementResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum CreateDisbursementResponse {
    /// successful operation
    SuccessfulOperation
    (models::DisbursementResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetDisbursementResponse {
    /// successful operation
    SuccessfulOperation
    (models::DisbursementResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum SearchDisbursementsResponse {
    /// successful operation
    SuccessfulOperation
    (Vec<models::DisbursementResponse>)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum UpdateDisbursementResponse {
    /// successful operation
    SuccessfulOperation
    (models::DisbursementResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum AssignEmployeeResponse {
    /// successful operation
    SuccessfulOperation
    (models::EmployeeResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum AssignToLocationEmployeeResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum CreateEmployeeResponse {
    /// successful operation
    SuccessfulOperation
    (models::EmployeeResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum DeleteEmployeeResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetEmployeeResponse {
    /// successful operation
    SuccessfulOperation
    (models::EmployeeResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum SearchEmployeesResponse {
    /// successful operation
    SuccessfulOperation
    (Vec<models::EmployeeResponse>)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum UnassignEmployeeResponse {
    /// successful operation
    SuccessfulOperation
    (models::EmployeeResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum UpdateEmployeeResponse {
    /// successful operation
    SuccessfulOperation
    (models::EmployeeResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum AttendEventResponse {
    /// successful operation
    SuccessfulOperation
    (models::OfferResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum CreateEventResponse {
    /// successful operation
    SuccessfulOperation
    (models::OfferResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum DeleteEventResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetEventResponse {
    /// successful operation
    SuccessfulOperation
    (models::OfferResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum SearchEventTransactionsResponse {
    /// successful operation
    SuccessfulOperation
    (Vec<models::EventAttendanceResponse>)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum SearchEventsResponse {
    /// successful operation
    SuccessfulOperation
    (Vec<models::OfferShortResponse>)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum UpdateEventResponse {
    /// successful operation
    SuccessfulOperation
    (models::OfferResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetTokenResponse {
    /// successful operation
    SuccessfulOperation
    (models::TokenResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GraphInterfaceResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum AddFavoriteResponse {
    /// successful operation
    SuccessfulOperation
    (models::WrappedResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum DeleteFavoriteResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetFavoriteResponse {
    /// successful operation
    SuccessfulOperation
    (models::WrappedResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum SearchFavoritesResponse {
    /// successful operation
    SuccessfulOperation
    (models::SearchResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum WhoHasFavoritedResponse {
    /// successful operation
    SuccessfulOperation
    (Vec<models::AccountResponse>)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum CreateFilterResponse {
    /// successful operation
    SuccessfulOperation
    (models::FilterTreeResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum DeleteFilterResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetFilterResponse {
    /// successful operation
    SuccessfulOperation
    (models::FilterTreeResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum SearchFiltersResponse {
    /// successful operation
    SuccessfulOperation
    (Vec<models::FilterResponse>)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum UpdateFilterResponse {
    /// successful operation
    SuccessfulOperation
    (models::FilterTreeResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum CreateFlagResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum DeleteFlagResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetFlagResponse {
    /// successful operation
    SuccessfulOperation
    (models::FlagResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetFlagThresholdResponse {
    /// successful operation
    SuccessfulOperation
    (models::CountResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum UpdateFlagThresholdResponse {
    /// successful operation
    SuccessfulOperation
    (models::CountResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum CreateGameResponse {
    /// successful operation
    SuccessfulOperation
    (models::GameResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum DeleteGameResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetGameResponse {
    /// successful operation
    SuccessfulOperation
    (models::GameResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum SearchGamesResponse {
    /// successful operation
    SuccessfulOperation
    (models::GameResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum UpdateGameResponse {
    /// successful operation
    SuccessfulOperation
    (models::GameResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum CreateGameLevelResponse {
    /// successful operation
    SuccessfulOperation
    (models::GameLevelResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum DeleteGameLevelResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetGameLevelResponse {
    /// successful operation
    SuccessfulOperation
    (models::GameLevelResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetGameLevelsByApplicationResponse {
    /// successful operation
    SuccessfulOperation
    (models::GameLevelListResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetGameLevelsByBillableEntityResponse {
    /// successful operation
    SuccessfulOperation
    (models::GameLevelResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetQuestionsInLevelResponse {
    /// successful operation
    SuccessfulOperation
    (models::QuestionResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetWordsInLevelResponse {
    /// successful operation
    SuccessfulOperation
    (models::WordzWordResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum UpdateGameLevelResponse {
    /// successful operation
    SuccessfulOperation
    (models::GameLevelResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum UpdateQuestionsInLevelResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum UpdateWordsInLevelResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum AcceptInviteResponse {
    /// successful operation
    SuccessfulOperation
    (models::ConsumerInviteResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum AlbumContestInviteResponse {
    /// successful operation
    SuccessfulOperation
    (models::InviteResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum AlbumInviteResponse {
    /// successful operation
    SuccessfulOperation
    (models::InviteResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum EventInviteResponse {
    /// successful operation
    SuccessfulOperation
    (models::InviteResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GameInviteResponse {
    /// successful operation
    SuccessfulOperation
    (models::InviteResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetInviteResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum MissionInviteResponse {
    /// successful operation
    SuccessfulOperation
    (models::InviteResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum OfferInviteResponse {
    /// successful operation
    SuccessfulOperation
    (models::InviteResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum OfferLocationInviteResponse {
    /// successful operation
    SuccessfulOperation
    (models::InviteResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum RetailerLocationInviteResponse {
    /// successful operation
    SuccessfulOperation
    (models::InviteResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum CreateLeaderboardResponse {
    /// successful operation
    SuccessfulOperation
    (models::LeaderboardResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum DeleteLeaderboardResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetLeaderboardResponse {
    /// successful operation
    SuccessfulOperation
    (models::LeaderboardResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum SearchLeaderboardsResponse {
    /// successful operation
    SuccessfulOperation
    (models::LeaderboardResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum UpdateLeaderboardResponse {
    /// successful operation
    SuccessfulOperation
    (models::LeaderboardResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum RegisterLikeResponse {
    /// successful operation
    SuccessfulOperation
    (models::LikableResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum RemoveLikeResponse {
    /// successful operation
    SuccessfulOperation
    (models::LikableResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum SearchLikesResponse {
    /// successful operation
    SuccessfulOperation
    (models::SearchResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum CreateListingResponse {
    /// successful operation
    SuccessfulOperation
    (models::ListingFullResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum DeleteListingResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetListingResponse {
    /// successful operation
    SuccessfulOperation
    (models::ListingFullResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum SearchListingResponse {
    /// successful operation
    SuccessfulOperation
    (Vec<models::ListingResponse>)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum SummaryListingResponse {
    /// successful operation
    SuccessfulOperation
    (Vec<models::ListingGroupResponse>)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum UpdateListingResponse {
    /// successful operation
    SuccessfulOperation
    (models::ListingFullResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum CacheTrilaterationDataResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum CacheTrilaterationDataGzipResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetLocationByIpResponse {
    /// successful operation
    SuccessfulOperation
    (models::CoordsResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetLocationByTrilaterationResponse {
    /// successful operation
    SuccessfulOperation
    (models::GeoPointResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetLocationsResponse {
    /// successful operation
    SuccessfulOperation
    (models::LocationSearchResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum CreateLocationV2Response {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum UpdateLocationV2Response {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum CreateMediaResponse {
    /// successful operation
    SuccessfulOperation
    (models::MediaOfferResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum DeleteMediaResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetMediaResponse {
    /// successful operation
    SuccessfulOperation
    (models::MediaOfferResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum SearchMediaResponse {
    /// successful operation
    SuccessfulOperation
    (Vec<models::MediaOfferResponse>)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum UpdateMediaResponse {
    /// successful operation
    SuccessfulOperation
    (models::MediaOfferResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum CreateMissionResponse {
    /// successful operation
    SuccessfulOperation
    (models::MissionResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum DeleteMissionResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum FindMissionsResponse {
    /// successful operation
    SuccessfulOperation
    (models::MissionResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetMissionResponse {
    /// successful operation
    SuccessfulOperation
    (models::MissionResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum ImportMissionResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum SearchMissionFormatsResponse {
    /// successful operation
    SuccessfulOperation
    (Vec<models::MissionFormatResponse>)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum SearchMissionsResponse {
    /// successful operation
    SuccessfulOperation
    (Vec<models::MissionResponse>)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum SearchMissionsByBillableEntityResponse {
    /// successful operation
    SuccessfulOperation
    (Vec<models::MissionResponse>)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum UpdateMissionResponse {
    /// successful operation
    SuccessfulOperation
    (models::MissionResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum CreateMissionInviteResponse {
    /// successful operation
    SuccessfulOperation
    (models::MissionResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum DeleteMissionInviteResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetMissionInviteResponse {
    /// successful operation
    SuccessfulOperation
    (models::MissionResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum SearchMissionInvitesResponse {
    /// successful operation
    SuccessfulOperation
    (Vec<models::MissionResponse>)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum UpdateMissionInviteResponse {
    /// successful operation
    SuccessfulOperation
    (models::MissionResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum BatchOperationResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum CreateNoteResponse {
    /// successful operation
    SuccessfulOperation
    (models::NoteResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum DeleteNoteResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetNoteResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum SearchNotesResponse {
    /// successful operation
    SuccessfulOperation
    (Vec<models::NoteResponse>)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum UpdateNoteResponse {
    /// successful operation
    SuccessfulOperation
    (models::NoteResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum CreateNotificationTemplateResponse {
    /// successful operation
    SuccessfulOperation
    (models::NotificationTemplateResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum CreateOrUpdateBlockedNotificationsResponse {
    /// successful operation
    SuccessfulOperation
    (models::BlockedNotificationResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum DeleteNotificationTemplateResponse {
    /// successful operation
    SuccessfulOperation
    (models::NotificationTemplateResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetNotificationTemplateResponse {
    /// successful operation
    SuccessfulOperation
    (models::NotificationTemplateResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetNotificationsResponse {
    /// successful operation
    SuccessfulOperation
    (models::NotificationMessageListResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum RegisterNotificationTokenResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum SearchBlockedNotificationsResponse {
    /// successful operation
    SuccessfulOperation
    (models::BlockedNotificationResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum SearchNotificationTemplateResponse {
    /// successful operation
    SuccessfulOperation
    (models::NotificationTemplateResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum SearchRecipientsResponse {
    /// successful operation
    SuccessfulOperation
    (Vec<models::NotificationRecipientResponse>)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum SearchRecipientsCountResponse {
    /// successful operation
    SuccessfulOperation
    (models::NotificationRecipientResponseListResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum SendBatchNotificationsResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum SendCustomNotificationsResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum UpdateNotificationTemplateResponse {
    /// successful operation
    SuccessfulOperation
    (models::NotificationTemplateResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum AddFieldResponse {
    /// successful operation
    SuccessfulOperation
    (models::ObjectStoreResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum CreateObjectResponse {
    /// successful operation
    SuccessfulOperation
    (models::ObjectStoreResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum DeleteFieldResponse {
    /// successful operation
    SuccessfulOperation
    (models::ObjectStoreResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum DeleteObjectResponse {
    /// successful operation
    SuccessfulOperation
    (models::ObjectStoreResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetObjectResponse {
    /// successful operation
    SuccessfulOperation
    (models::ObjectStoreResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum SearchObjectResponse {
    /// successful operation
    SuccessfulOperation
    (models::ObjectStoreResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum CreateDataResponse {
    /// successful operation
    SuccessfulOperation
    (models::ObjectStoreResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum SearchDataResponse {
    /// successful operation
    SuccessfulOperation
    (models::ObjectStoreResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum DeleteDataResponse {
    /// successful operation
    SuccessfulOperation
    (models::ObjectStoreResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetDataResponse {
    /// successful operation
    SuccessfulOperation
    (models::ObjectStoreResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum UpdateDataResponse {
    /// successful operation
    SuccessfulOperation
    (models::ObjectStoreResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum BatchUpdateOfferLocationsResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum CreateOfferResponse {
    /// successful operation
    SuccessfulOperation
    (models::RetailerOfferResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum DeleteOfferResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum DeleteOfferLocationResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetOfferResponse {
    /// successful operation
    SuccessfulOperation
    (models::RetailerOfferResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetOfferDetailsResponse {
    /// successful operation
    SuccessfulOperation
    (models::OfferResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetOfferListCountsResponse {
    /// successful operation
    SuccessfulOperation
    (models::ListCountResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetOfferLocationResponse {
    /// successful operation
    SuccessfulOperation
    (models::OfferShortResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetOfferLocationsForRetailersResponse {
    /// successful operation
    SuccessfulOperation
    (Vec<models::OfferShortResponse>)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetOffersForRetailersResponse {
    /// successful operation
    SuccessfulOperation
    (Vec<models::OfferResponse>)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum RedeemOfferTransactionResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum SearchOfferTransactionsForRetailersResponse {
    /// successful operation
    SuccessfulOperation
    (Vec<models::OfferTransactionResponse>)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum SearchOffersForConsumerResponse {
    /// successful operation
    SuccessfulOperation
    (models::OfferListResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum TopOfferTransactionsResponse {
    /// successful operation
    SuccessfulOperation
    (models::OfferListResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum UpdateOfferResponse {
    /// successful operation
    SuccessfulOperation
    (models::RetailerOfferResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum UpdateOfferStatusResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum CreateOfferTransactionStatusResponse {
    /// successful operation
    SuccessfulOperation
    (models::OfferTransactionStatusResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum DeleteOfferTransactionStatusResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetOfferTransactionStatusResponse {
    /// successful operation
    SuccessfulOperation
    (models::OfferTransactionStatusResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum SearchOfferTransactionStatusesResponse {
    /// successful operation
    SuccessfulOperation
    (Vec<models::OfferTransactionStatusResponse>)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum UpdateOfferTransactionStatusResponse {
    /// successful operation
    SuccessfulOperation
    (models::OfferTransactionStatusResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum ImageGenerationResponse {
    /// successful operation
    SuccessfulOperation
    (models::WrappedProxyItemResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum RequestOptimizationResponse {
    /// successful operation
    SuccessfulOperation
    (models::ImportStatuses)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetOptimizationResultResponse {
    /// successful operation
    SuccessfulOperation
    (std::collections::HashMap<String, models::ShipmentOrder>)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum AddMovieResponse {
    /// successful operation
    SuccessfulOperation
    (models::OrsonAiAddMovieResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum AiDocsResponse {
    /// successful operation
    SuccessfulOperation
    (models::OrsonAiProtoResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum AiFindImagesResponse {
    /// successful operation
    SuccessfulOperation
    (models::OrsonAiProtoResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum AiTagsResponse {
    /// successful operation
    SuccessfulOperation
    (models::OrsonAiProtoResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum AiTextResponse {
    /// successful operation
    SuccessfulOperation
    (models::OrsonAiProtoResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum BatchResponse {
    /// successful operation
    SuccessfulOperation
    (models::OrsonAiBatchResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum CreateInstantEpisodeResponse {
    /// successful operation
    SuccessfulOperation
    (models::OrsonEpisodeResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum CreateVoiceCanvasResponse {
    /// successful operation
    SuccessfulOperation
    (models::OrsonAiVoiceCanvasResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum EmotionResponse {
    /// successful operation
    SuccessfulOperation
    (models::OrsonAiEmotionsResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum StartVideoRenderResponse {
    /// successful operation
    SuccessfulOperation
    (models::OrsonRenderResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum SttResponse {
    /// successful operation
    SuccessfulOperation
    (models::OrsonAiSttResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum SummarizeTopicsResponse {
    /// successful operation
    SuccessfulOperation
    (models::OrsonAiTopicsResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum TechTuneResponse {
    /// successful operation
    SuccessfulOperation
    (models::OrsonAiTechTuneResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum TtsResponse {
    /// successful operation
    SuccessfulOperation
    (models::OrsonAiTtsResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetAddMovieResultResponse {
    /// successful operation
    SuccessfulOperation
    (models::OrsonAiAddMovieResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetBatchResponse {
    /// successful operation
    SuccessfulOperation
    (models::OrsonAiBatchResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetEmotionResponse {
    /// successful operation
    SuccessfulOperation
    (models::OrsonAiEmotionsResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetEpisodeStatusResponse {
    /// successful operation
    SuccessfulOperation
    (models::OrsonEpisodeResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetRenderStatusResponse {
    /// successful operation
    SuccessfulOperation
    (models::OrsonRenderResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetSttResponse {
    /// successful operation
    SuccessfulOperation
    (models::OrsonAiSttResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetTechTuneResponse {
    /// successful operation
    SuccessfulOperation
    (models::OrsonAiTechTuneResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetTopicsResponse {
    /// successful operation
    SuccessfulOperation
    (models::OrsonAiTopicsResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetTtsResponse {
    /// successful operation
    SuccessfulOperation
    (models::OrsonAiTtsResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetVoiceCanvasResponse {
    /// successful operation
    SuccessfulOperation
    (models::OrsonAiVoiceCanvasResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum CreatePackResponse {
    /// successful operation
    SuccessfulOperation
    (models::PackResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum DeletePackResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetPackResponse {
    /// successful operation
    SuccessfulOperation
    (models::PackResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum SearchPacksResponse {
    /// successful operation
    SuccessfulOperation
    (Vec<models::PackResponse>)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum UpdatePackResponse {
    /// successful operation
    SuccessfulOperation
    (models::PackResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum ProcessAllParticipantsResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum ProcessParticipantsResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum ComputePathResponse {
    /// successful operation
    SuccessfulOperation
    (models::PathingResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum CreatePostalCodeResponse {
    /// successful operation
    SuccessfulOperation
    (models::PostalCodeResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum DeletePostalCodeResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetPostalCodeResponse {
    /// successful operation
    SuccessfulOperation
    (models::PostalCodeResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetPostalCodesResponse {
    /// successful operation
    SuccessfulOperation
    (Vec<models::PostalCodeResponse>)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum UpdatePostalCodeResponse {
    /// successful operation
    SuccessfulOperation
    (models::PostalCodeResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum CreatePersonaResponse {
    /// successful operation
    SuccessfulOperation
    (models::PreviewPersonaResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum DeletePersonaResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetPersonaListResponse {
    /// successful operation
    SuccessfulOperation
    (models::PreviewPersonaResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum SearchPersonaResponse {
    /// successful operation
    SuccessfulOperation
    (models::PreviewPersonaResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum UpdatePersonaResponse {
    /// successful operation
    SuccessfulOperation
    (models::PreviewPersonaResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum CreateProgramResponse {
    /// successful operation
    SuccessfulOperation
    (models::Program)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum SearchProgramsResponse {
    /// successful operation
    SuccessfulOperation
    (Vec<models::Program>)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum DeleteProgramResponse {
    /// successful operation
    SuccessfulOperation
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetProgramResponse {
    /// successful operation
    SuccessfulOperation
    (models::Program)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum PostProgramResponse {
    /// successful operation
    SuccessfulOperation
    (models::Program)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum PutProgramResponse {
    /// successful operation
    SuccessfulOperation
    (models::Program)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum CreatePurchaseItemResponse {
    /// successful operation
    SuccessfulOperation
    (models::PurchaseItemFullResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum DeletePurchaseItemResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetPurchaseItemResponse {
    /// successful operation
    SuccessfulOperation
    (models::PurchaseItemFullResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum SearchPurchaseItemsResponse {
    /// successful operation
    SuccessfulOperation
    (Vec<models::PurchaseItemResponse>)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum UpdatePurchaseItemResponse {
    /// successful operation
    SuccessfulOperation
    (models::PurchaseItemFullResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum CreateOrderResponse {
    /// successful operation
    SuccessfulOperation
    (models::OrderResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum DeleteOrderResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetOrderResponse {
    /// successful operation
    SuccessfulOperation
    (models::OrderResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum PreviewOrderResponse {
    /// successful operation
    SuccessfulOperation
    (models::OrderResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum SearchOrdersResponse {
    /// successful operation
    SuccessfulOperation
    (Vec<models::OrderResponse>)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum UpdateOrderResponse {
    /// successful operation
    SuccessfulOperation
    (models::OrderResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum CreateQuestionResponse {
    /// successful operation
    SuccessfulOperation
    (models::QuestionResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum DeleteQuestionResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetQuestionResponse {
    /// successful operation
    SuccessfulOperation
    (models::QuestionResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum SearchQuestionsResponse {
    /// successful operation
    SuccessfulOperation
    (Vec<models::QuestionResponse>)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum UpdateQuestionResponse {
    /// successful operation
    SuccessfulOperation
    (models::QuestionResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetHistoricalRankingsResponse {
    /// successful operation
    SuccessfulOperation
    (models::RankFullResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetRankingsResponse {
    /// successful operation
    SuccessfulOperation
    (models::RankFullResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetUserRankResponse {
    /// successful operation
    SuccessfulOperation
    (serde_json::Value)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum OverrideUserRankResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum UpdateRankingsResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum CreateRatingResponse {
    /// successful operation
    SuccessfulOperation
    (models::RatingResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum DeleteRatingResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum SearchLocationRatingIndexesResponse {
    /// successful operation
    SuccessfulOperation
    (Vec<models::RatingIndexResponse>)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum SearchRatingIndexesResponse {
    /// successful operation
    SuccessfulOperation
    (Vec<models::RatingIndexResponse>)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum SearchRatingsResponse {
    /// successful operation
    SuccessfulOperation
    (Vec<models::RatingResponse>)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum UpdateRatingResponse {
    /// successful operation
    SuccessfulOperation
    (models::RatingResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum CreateRegionResponse {
    /// successful operation
    SuccessfulOperation
    (models::RegionResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum DeleteRegionResponse {
    /// successful operation
    SuccessfulOperation
    (models::RegionResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetRegionResponse {
    /// successful operation
    SuccessfulOperation
    (models::RegionResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum SearchRegionsResponse {
    /// successful operation
    SuccessfulOperation
    (Vec<models::RegionResponse>)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum UpdateRegionResponse {
    /// successful operation
    SuccessfulOperation
    (models::RegionResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum CreateBatchResponse {
    /// successful operation
    SuccessfulOperation
    (models::ReportBatchResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum CreateRegionLegSummaryBatchResponse {
    /// successful operation
    SuccessfulOperation
    (models::ReportRegionLegSummaryBatchResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum DeleteBatchResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetReportBatchResponse {
    /// successful operation
    SuccessfulOperation
    (models::ReportBatchResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum RunReportResponse {
    /// successful operation
    SuccessfulOperation
    (models::ReportResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum SearchBatchResponse {
    /// successful operation
    SuccessfulOperation
    (Vec<models::ReportBatchResponse>)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum CreateReservationResponse {
    /// successful operation
    SuccessfulOperation
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum DeleteReservationResponse {
    /// successful operation
    SuccessfulOperation
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum ReservableAvailabilityResponse {
    /// successful operation
    SuccessfulOperation
    (Vec<models::AvailabilityResponse>)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum SearchAvailabilityResponse {
    /// successful operation
    SuccessfulOperation
    (Vec<models::AvailabilityResponse>)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum SearchReservationsResponse {
    /// successful operation
    SuccessfulOperation
    (Vec<models::ReservationResponse>)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum SearchScheduleResponse {
    /// successful operation
    SuccessfulOperation
    (Vec<models::TimeSlotResponse>)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum CreateRetailerResponse {
    /// successful operation
    SuccessfulOperation
    (models::RetailerFullResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum DeleteRetailerResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetRetailerResponse {
    /// successful operation
    SuccessfulOperation
    (models::RetailerFullResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetRetailersResponse {
    /// successful operation
    SuccessfulOperation
    (Vec<models::RetailerResponse>)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum RetailerLoginCheckResponse {
    /// successful operation
    SuccessfulOperation
    (models::AccountLoginResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum UpdateRetailerResponse {
    /// successful operation
    SuccessfulOperation
    (models::RetailerFullResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum CreateRetailerLocationConsumerResponse {
    /// successful operation
    SuccessfulOperation
    (models::RetailerLocationResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum CreateRetailerLocationsResponse {
    /// successful operation
    SuccessfulOperation
    (models::RetailerLocationResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum DeleteRetailerLocationResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetRetailerLocationResponse {
    /// successful operation
    SuccessfulOperation
    (models::RetailerLocationResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetRetailerLocationConsumerResponse {
    /// successful operation
    SuccessfulOperation
    (models::RetailerLocationResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum IndexedRetailerLocationDistanceSearchResponse {
    /// successful operation
    SuccessfulOperation
    (Vec<models::RetailerLocationResponse>)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum IndexedRetailerLocationSearchResponse {
    /// successful operation
    SuccessfulOperation
    (Vec<models::RetailerLocationResponse>)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum SearchRetailerLocationsResponse {
    /// successful operation
    SuccessfulOperation
    (Vec<models::RetailerLocationResponse>)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum UpdateRetailerLocationsResponse {
    /// successful operation
    SuccessfulOperation
    (models::RetailerLocationResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetRetaokilerResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum CreateRouteResponse {
    /// successful operation
    SuccessfulOperation
    (models::Route)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum SearchRoutesResponse {
    /// successful operation
    SuccessfulOperation
    (Vec<models::Route>)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum ApproveRouteResponse {
    /// successful operation
    SuccessfulOperation
    (models::Route)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum CopyRouteResponse {
    /// successful operation
    SuccessfulOperation
    (models::Route)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum CreateRouteDirectionsResponse {
    /// successful operation
    SuccessfulOperation
    (Vec<models::Direction>)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum CreateRoutePolylineResponse {
    /// successful operation
    SuccessfulOperation
    (models::Route)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum DeleteRouteResponse {
    /// successful operation
    SuccessfulOperation
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum DisapproveRouteResponse {
    /// successful operation
    SuccessfulOperation
    (models::Route)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetRouteResponse {
    /// successful operation
    SuccessfulOperation
    (models::Route)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetRouteDirectionsResponse {
    /// successful operation
    SuccessfulOperation
    (Vec<models::Direction>)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetRouteShipmentsResponse {
    /// successful operation
    SuccessfulOperation
    (Vec<models::Shipment>)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetRouteStopsResponse {
    /// successful operation
    SuccessfulOperation
    (Vec<models::Stop>)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum OptimizeRouteResponse {
    /// successful operation
    SuccessfulOperation
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum ReorderRouteStopsPatchResponse {
    /// successful operation
    SuccessfulOperation
    (Vec<models::Stop>)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum ReorderRouteStopsPostResponse {
    /// successful operation
    SuccessfulOperation
    (Vec<models::Stop>)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum UpdateRouteResponse {
    /// successful operation
    SuccessfulOperation
    (models::Route)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetRouteStopResponse {
    /// successful operation
    SuccessfulOperation
    (models::Stop)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetShipmentsAtStopResponse {
    /// successful operation
    SuccessfulOperation
    (Vec<models::Shipment>)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum RemoveStopResponse {
    /// successful operation
    SuccessfulOperation
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum SetDriverResponse {
    /// successful operation
    SuccessfulOperation
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum UpdateRouteStopResponse {
    /// successful operation
    SuccessfulOperation
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum CreateRouteSettingsResponse {
    /// successful operation
    SuccessfulOperation
    (models::RouteSettings)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum SearchRouteSettingsResponse {
    /// successful operation
    SuccessfulOperation
    (Vec<models::RouteSettings>)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum DeleteRouteSettingsResponse {
    /// successful operation
    SuccessfulOperation
    (serde_json::Value)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetRouteSettingsResponse {
    /// successful operation
    SuccessfulOperation
    (models::RouteSettings)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum UpdateRouteSettingsResponse {
    /// successful operation
    SuccessfulOperation
    (models::RouteSettings)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum ComputeRoutingResponse {
    /// successful operation
    SuccessfulOperation
    (models::RoutingListResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum CreateScheduledNotificationResponse {
    /// successful operation
    SuccessfulOperation
    (models::ScheduledNotificationFullResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum DeleteScheduledNotificationResponse {
    /// successful operation
    SuccessfulOperation
    (models::ScheduledNotificationFullResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetScheduledNotificationResponse {
    /// successful operation
    SuccessfulOperation
    (models::ScheduledNotificationFullResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum ScheduleNotificationListingsResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum SearchScheduledNotificationsResponse {
    /// successful operation
    SuccessfulOperation
    (models::ScheduledNotificationFullResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum UpdateScheduledNotificationResponse {
    /// successful operation
    SuccessfulOperation
    (models::ScheduledNotificationFullResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum CreateScoreResponse {
    /// successful operation
    SuccessfulOperation
    (models::ScoreResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetScoreResponse {
    /// successful operation
    SuccessfulOperation
    (models::ScoreResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum SearchScoresResponse {
    /// successful operation
    SuccessfulOperation
    (Vec<models::ScoreResponse>)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum CreateSecureApplicationResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum DeleteSecureApplicationResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum LoginSecureResponse {
    /// successful operation
    SuccessfulOperation
    (models::ProfileResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum PurchaseSecureResponse {
    /// successful operation
    SuccessfulOperation
    (models::ProfileResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum ResetSecureResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum UpdateSecureApplicationResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum CreateServiceHubResponse {
    /// successful operation
    SuccessfulOperation
    (models::ServiceHub)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum SearchServiceHubsResponse {
    /// successful operation
    SuccessfulOperation
    (Vec<models::ServiceHub>)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum DeleteServiceHubResponse {
    /// successful operation
    SuccessfulOperation
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetServiceHubResponse {
    /// successful operation
    SuccessfulOperation
    (serde_json::Value)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum PostServiceHubResponse {
    /// successful operation
    SuccessfulOperation
    (models::ServiceHub)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum PutServiceHubResponse {
    /// successful operation
    SuccessfulOperation
    (models::ServiceHub)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum CreateShipmentResponse {
    /// successful operation
    SuccessfulOperation
    (models::Shipment)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum SearchShipmentsResponse {
    /// successful operation
    SuccessfulOperation
    (Vec<models::Shipment>)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum CancelShipmentResponse {
    /// successful operation
    SuccessfulOperation
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum DeleteShipmentResponse {
    /// successful operation
    SuccessfulOperation
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetShipmentResponse {
    /// successful operation
    SuccessfulOperation
    (models::Shipment)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum UpdateShipmentResponse {
    /// successful operation
    SuccessfulOperation
    (models::Shipment)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum UpdateShipmentStatusResponse {
    /// successful operation
    SuccessfulOperation
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum CreateShipmentBatchResponse {
    /// successful operation
    SuccessfulOperation
    (models::ShipmentBatch)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum SearchShipmentBatchResponse {
    /// successful operation
    SuccessfulOperation
    (Vec<models::ShipmentBatch>)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum DeleteShipmentBatchResponse {
    /// successful operation
    SuccessfulOperation
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetShipmentBatchResponse {
    /// successful operation
    SuccessfulOperation
    (models::ShipmentBatch)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetShipmentBatchStatusResponse {
    /// successful operation
    SuccessfulOperation
    (Vec<models::ShipmentImportStatus>)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum SimulationResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetStopResponse {
    /// successful operation
    SuccessfulOperation
    (models::Stop)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum UpdateStopResponse {
    /// successful operation
    SuccessfulOperation
    (models::Stop)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum CreateStripeCheckoutSessionResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum CreateSubscriptionResponse {
    /// successful operation
    SuccessfulOperation
    (models::SubscriptionResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum DeleteSubscriptionResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetSubscriptionResponse {
    /// successful operation
    SuccessfulOperation
    (models::SubscriptionResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetSubscriptionPlanResponse {
    /// successful operation
    SuccessfulOperation
    (models::SubscriptionPlanResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetSubscriptionPlansResponse {
    /// successful operation
    SuccessfulOperation
    (Vec<models::SubscriptionPlanResponse>)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetSubscriptionUsageResponse {
    /// successful operation
    SuccessfulOperation
    (models::ApplicationUsageResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum UpdateSubscriptionResponse {
    /// successful operation
    SuccessfulOperation
    (models::SubscriptionResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum CreateTaskResponse {
    /// successful operation
    SuccessfulOperation
    (models::TaskResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum DeleteTaskResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetTaskResponse {
    /// successful operation
    SuccessfulOperation
    (models::TaskResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum SearchTasksResponse {
    /// successful operation
    SuccessfulOperation
    (Vec<models::TaskResponse>)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum UpdateTaskResponse {
    /// successful operation
    SuccessfulOperation
    (models::TaskResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum CreateTerritoryResponse {
    /// successful operation
    SuccessfulOperation
    (models::TerritoryResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum DeleteTerritoryResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetTerritoryResponse {
    /// successful operation
    SuccessfulOperation
    (models::TerritoryResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum SearchTerritoriesResponse {
    /// successful operation
    SuccessfulOperation
    (Vec<models::TerritoryResponse>)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum UpdateTerritoryResponse {
    /// successful operation
    SuccessfulOperation
    (models::TerritoryResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum AddOrUpdateThemeDescriptorResponse {
    /// successful operation
    SuccessfulOperation
    (models::ThemeDescriptorResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetThemeDescriptorResponse {
    /// successful operation
    SuccessfulOperation
    (models::PurchaseItemListResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetThemeDescriptorsResponse {
    /// successful operation
    SuccessfulOperation
    (models::PurchaseItemListResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum RemoveThemeDescriptorResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum CreateCredentialResponse {
    /// successful operation
    SuccessfulOperation
    (models::ProfileResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum CreateNetworkResponse {
    /// successful operation
    SuccessfulOperation
    (models::ThirdPartyNetworkResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum DeleteCredentialResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum DeleteNetworkResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetCredentialResponse {
    /// successful operation
    SuccessfulOperation
    (models::ProfileResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetNetworkResponse {
    /// successful operation
    SuccessfulOperation
    (models::ThirdPartyNetworkResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum SearchCredentialsResponse {
    /// successful operation
    SuccessfulOperation
    (Vec<models::ThirdPartyCredentialResponse>)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum SearchNetworksResponse {
    /// successful operation
    SuccessfulOperation
    (Vec<models::ThirdPartyNetworkShortResponse>)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum SendMfaChallengeResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum UpdateCredentialResponse {
    /// successful operation
    SuccessfulOperation
    (models::ProfileResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum UpdateNetworkResponse {
    /// successful operation
    SuccessfulOperation
    (models::ThirdPartyNetworkResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetTicketCountResponse {
    /// successful operation
    SuccessfulOperation
    (models::CountResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetTicketListResponse {
    /// successful operation
    SuccessfulOperation
    (models::TicketListResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GiftPurchaseResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum SaveTicketResponse {
    /// successful operation
    SuccessfulOperation
    (models::ProfileResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum SaveTicketViaFileUploadResponse {
    /// successful operation
    SuccessfulOperation
    (models::ProfileResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum TicketOffersResponse {
    /// successful operation
    SuccessfulOperation
    (models::TicketOfferResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum CreateTournamentResponse {
    /// successful operation
    SuccessfulOperation
    (models::TournamentResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum DeleteTournamentResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetTournamentResponse {
    /// successful operation
    SuccessfulOperation
    (models::TournamentResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum SearchObjectsResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum SearchRoundsResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum SearchTournamentsResponse {
    /// successful operation
    SuccessfulOperation
    (models::MissionShortResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum SubmitTournamentScoreResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum SubmitTournamentVoteResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum SubstituteTournamentPlayerResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum UpdateTournamentResponse {
    /// successful operation
    SuccessfulOperation
    (models::TournamentResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum BatchSaveTrackingResponse {
    /// successful operation
    SuccessfulOperation
    (Vec<models::Leg>)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetPredictedLocationsResponse {
    /// successful operation
    SuccessfulOperation
    (models::PredictedLocationResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetPredictedPathResponse {
    /// successful operation
    SuccessfulOperation
    (Vec<models::StepResponse>)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetPreferredLocationsResponse {
    /// successful operation
    SuccessfulOperation
    (Vec<models::PreferredLocationResponse>)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetTrackingLegsResponse {
    /// successful operation
    SuccessfulOperation
    (Vec<models::LegResponse>)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum SaveTrackingLegResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum SaveTrackingStepResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum SearchAccountsWithTrackingLegsResponse {
    /// successful operation
    SuccessfulOperation
    (Vec<models::AccountMiniResponse>)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum SearchTrackingLegsResponse {
    /// successful operation
    SuccessfulOperation
    (Vec<models::LegResponse>)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum CreateTriggerResponse {
    /// successful operation
    SuccessfulOperation
    (models::TriggerResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum DeleteTriggerResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetTriggerResponse {
    /// successful operation
    SuccessfulOperation
    (models::TriggerResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum SearchTriggersResponse {
    /// successful operation
    SuccessfulOperation
    (Vec<models::TriggerResponse>)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum UpdateTriggerResponse {
    /// successful operation
    SuccessfulOperation
    (models::TriggerResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum CreateTripResponse {
    /// successful operation
    SuccessfulOperation
    (models::Trip)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum ProcessTripMatchesResponse {
    /// successful operation
    SuccessfulOperation
    (Vec<models::Trip>)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum SearchResponse {
    /// successful operation
    SuccessfulOperation
    (Vec<models::Trip>)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum SearchTripsResponse {
    /// successful operation
    SuccessfulOperation
    (Vec<models::Trip>)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum UpdateTripNotificationsResponse {
    /// successful operation
    SuccessfulOperation
    (models::Trip)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum DeleteResponse {
    /// successful operation
    SuccessfulOperation
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum DriveTripResponse {
    /// successful operation
    SuccessfulOperation
    (models::Trip)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum FlexibleTripResponse {
    /// successful operation
    SuccessfulOperation
    (models::Trip)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetTripResponse {
    /// successful operation
    SuccessfulOperation
    (models::Trip)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetTripMatchesResponse {
    /// successful operation
    SuccessfulOperation
    (Vec<models::Trip>)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum RideResponse {
    /// successful operation
    SuccessfulOperation
    (models::Trip)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum UpdateLocationsResponse {
    /// successful operation
    SuccessfulOperation
    (models::Trip)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum UpdateRecurrenceLocationsResponse {
    /// successful operation
    SuccessfulOperation
    (Vec<models::Trip>)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum UpdateRecurrenceShipmentsResponse {
    /// successful operation
    SuccessfulOperation
    (Vec<models::Trip>)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum UpdateShipmentsResponse {
    /// successful operation
    SuccessfulOperation
    (models::Trip)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum UpdateTripResponse {
    /// successful operation
    SuccessfulOperation
    (models::Trip)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum SmsBuyOfferResponse {
    /// successful operation
    SuccessfulOperation
    (models::TwiMlResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum AuthorizeTwitterResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum LoginTwitterResponse {
    /// successful operation
    SuccessfulOperation
    (models::ProfileResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum AddUsersToPermissionableResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum ApprovePermissionableResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum LeaveFromPermissionableResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum RemoveUsersFromPermissionableResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum SearchPermissionablesResponse {
    /// successful operation
    SuccessfulOperation
    (Vec<models::UserPermissionsResponse>)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum SearchPermissionablesFollowingDistanceResponse {
    /// successful operation
    SuccessfulOperation
    (Vec<models::UserPermissionsResponse>)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum CreateFollowingResponse {
    /// successful operation
    SuccessfulOperation
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum CreateSpaceResponse {
    /// successful operation
    SuccessfulOperation
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum CreateVatomEventResponse {
    /// successful operation
    SuccessfulOperation
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum DeleteFollowingResponse {
    /// successful operation
    SuccessfulOperation
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum DeletePointsBalanceResponse {
    /// successful operation
    SuccessfulOperation
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum DeleteSpaceResponse {
    /// successful operation
    SuccessfulOperation
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum DeleteVatomEventResponse {
    /// successful operation
    SuccessfulOperation
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum DeleteVatomNftResponse {
    /// successful operation
    SuccessfulOperation
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum ExecuteActionOnNftResponse {
    /// successful operation
    SuccessfulOperation
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GeomapSearchResponse {
    /// successful operation
    SuccessfulOperation
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetBusinessBehaviorsResponse {
    /// successful operation
    SuccessfulOperation
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetBusinessCoinsBalanceResponse {
    /// successful operation
    SuccessfulOperation
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetBusinessIdsResponse {
    /// successful operation
    SuccessfulOperation
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetBusinessInfoResponse {
    /// successful operation
    SuccessfulOperation
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetBusinessUsersResponse {
    /// successful operation
    SuccessfulOperation
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetCampaignGroupEntitiesResponse {
    /// successful operation
    SuccessfulOperation
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetCampaignGroupRulesResponse {
    /// successful operation
    SuccessfulOperation
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetCampaignGroupStatsResponse {
    /// successful operation
    SuccessfulOperation
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetCampaignInfoResponse {
    /// successful operation
    SuccessfulOperation
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetEventGuestListResponse {
    /// successful operation
    SuccessfulOperation
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetInventoryResponse {
    /// successful operation
    SuccessfulOperation
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetMyFollowingResponse {
    /// successful operation
    SuccessfulOperation
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetPointsBalanceResponse {
    /// successful operation
    SuccessfulOperation
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetPointsBalanceAsBusinessResponse {
    /// successful operation
    SuccessfulOperation
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetSpaceResponse {
    /// successful operation
    SuccessfulOperation
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetUserCoinsAsBusinessResponse {
    /// successful operation
    SuccessfulOperation
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetUserCoinsBalanceResponse {
    /// successful operation
    SuccessfulOperation
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetUserFollowersResponse {
    /// successful operation
    SuccessfulOperation
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetUserFollowingResponse {
    /// successful operation
    SuccessfulOperation
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetUserInfoResponse {
    /// successful operation
    SuccessfulOperation
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetUserProfileResponse {
    /// successful operation
    SuccessfulOperation
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetVatomEventResponse {
    /// successful operation
    SuccessfulOperation
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetVatomNftResponse {
    /// successful operation
    SuccessfulOperation
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum ListCommunitiesResponse {
    /// successful operation
    SuccessfulOperation
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum ListEventsResponse {
    /// successful operation
    SuccessfulOperation
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum ListSpacesResponse {
    /// successful operation
    SuccessfulOperation
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum ListUserCoinTransactionsResponse {
    /// successful operation
    SuccessfulOperation
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum ListUserCoinTransactionsAsBusinessResponse {
    /// successful operation
    SuccessfulOperation
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum PerformActionOnNftResponse {
    /// successful operation
    SuccessfulOperation
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum RedeemNftResponse {
    /// successful operation
    SuccessfulOperation
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum RedeemUserCoinsAsBusinessResponse {
    /// successful operation
    SuccessfulOperation
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum SearchBusinessesResponse {
    /// successful operation
    SuccessfulOperation
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum SearchCampaignGroupsResponse {
    /// successful operation
    SuccessfulOperation
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum SearchIdentitiesResponse {
    /// successful operation
    SuccessfulOperation
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum SearchInventoryResponse {
    /// successful operation
    SuccessfulOperation
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum SendNftResponse {
    /// successful operation
    SuccessfulOperation
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum SetPointsBalanceAsBusinessResponse {
    /// successful operation
    SuccessfulOperation
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum TransferUserCoinsResponse {
    /// successful operation
    SuccessfulOperation
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum UpdateBusinessCoinsResponse {
    /// successful operation
    SuccessfulOperation
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum UpdateEventGuestListResponse {
    /// successful operation
    SuccessfulOperation
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum UpdateSpaceResponse {
    /// successful operation
    SuccessfulOperation
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum UpdateUserCoinsAsBusinessResponse {
    /// successful operation
    SuccessfulOperation
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum UpdateUserProfileResponse {
    /// successful operation
    SuccessfulOperation
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum UpdateVatomEventResponse {
    /// successful operation
    SuccessfulOperation
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum CreateVehicleResponse {
    /// successful operation
    SuccessfulOperation
    (models::Vehicle)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum SearchVehicleResponse {
    /// successful operation
    SuccessfulOperation
    (Vec<models::Vehicle>)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum DeleteVehicleResponse {
    /// successful operation
    SuccessfulOperation
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetVehicleResponse {
    /// successful operation
    SuccessfulOperation
    (models::Vehicle)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum UpdateVehicleResponse {
    /// successful operation
    SuccessfulOperation
    (models::Vehicle)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum CreateVehicleTypeResponse {
    /// successful operation
    SuccessfulOperation
    (models::VehicleType)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum SearchVehicleTypesResponse {
    /// successful operation
    SuccessfulOperation
    (Vec<models::VehicleType>)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum DeleteVehicleTypeResponse {
    /// successful operation
    SuccessfulOperation
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetVehicleTypeResponse {
    /// successful operation
    SuccessfulOperation
    (models::VehicleType)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum UpdateVehicleTypeResponse {
    /// successful operation
    SuccessfulOperation
    (models::VehicleType)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum CreateOfferTransactionResponse {
    /// successful operation
    SuccessfulOperation
    (Vec<models::OfferTransactionResponse>)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum DeleteOfferTransactionResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetOfferTransactionResponse {
    /// successful operation
    SuccessfulOperation
    (models::OfferTransactionResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum PreviewOfferTransactionResponse {
    /// successful operation
    SuccessfulOperation
    (Vec<models::OfferTransactionResponse>)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum SearchOfferTransactionsResponse {
    /// successful operation
    SuccessfulOperation
    (Vec<models::OfferTransactionResponse>)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum UpdateOfferTransactionResponse {
    /// successful operation
    SuccessfulOperation
    (models::OfferTransactionResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum SearchWeatherResponse {
    /// successful operation
    SuccessfulOperation
    (models::WeatherResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum CreateWordResponse {
    /// successful operation
    SuccessfulOperation
    (models::WordzWordResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum DeleteWordResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetWordResponse {
    /// successful operation
    SuccessfulOperation
    (models::WordzWordResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum GetWordsResponse {
    /// successful operation
    SuccessfulOperation
    (Vec<models::WordzWordResponse>)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum UpdateWordResponse {
    /// successful operation
    SuccessfulOperation
    (models::WordzWordResponse)
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum RunWorkflowResponse {
    /// successful operation
    SuccessfulOperation
    (models::SirqulResponse)
}

/// API
#[cfg_attr(feature = "mock", automock)]
#[async_trait]
#[allow(clippy::too_many_arguments, clippy::ptr_arg)]
pub trait Api<C: Send + Sync> {
    /// Create Consumer
    async fn consumer_create(
        &self,
        version: f64,
        app_key: String,
        name: String,
        hostname: String,
        username: String,
        password: String,
        data_mapping: String,
        device_id: Option<String>,
        account_id: Option<i64>,
        port: Option<i32>,
        virtual_host: Option<String>,
        exchanger: Option<String>,
        exchanger_type: Option<String>,
        workers: Option<i32>,
        use_ssl: Option<bool>,
        context: &C) -> Result<ConsumerCreateResponse, ApiError>;

    /// Update Consumer
    async fn consumer_update(
        &self,
        version: f64,
        app_key: String,
        queue_id: i64,
        data_mapping: String,
        device_id: Option<String>,
        account_id: Option<i64>,
        use_ssl: Option<bool>,
        context: &C) -> Result<ConsumerUpdateResponse, ApiError>;

    /// Create Queue
    async fn queue_create(
        &self,
        version: f64,
        app_key: String,
        name: String,
        device_id: Option<String>,
        account_id: Option<i64>,
        workers: Option<i32>,
        analytic_tags: Option<String>,
        hostname: Option<String>,
        port: Option<i32>,
        username: Option<String>,
        password: Option<String>,
        virtual_host: Option<String>,
        use_ssl: Option<bool>,
        context: &C) -> Result<QueueCreateResponse, ApiError>;

    /// Delete Queue
    async fn queue_delete(
        &self,
        version: f64,
        queue_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        context: &C) -> Result<QueueDeleteResponse, ApiError>;

    /// Get Queue
    async fn queue_get(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        queue_id: Option<i64>,
        app_key: Option<String>,
        name: Option<String>,
        hostname: Option<String>,
        virtual_host: Option<String>,
        context: &C) -> Result<QueueGetResponse, ApiError>;

    /// Publish Queue
    async fn queue_publish(
        &self,
        version: f64,
        message: String,
        queue_id: Option<i64>,
        app_key: Option<String>,
        name: Option<String>,
        hostname: Option<String>,
        virtual_host: Option<String>,
        context: &C) -> Result<QueuePublishResponse, ApiError>;

    /// Search Queue
    async fn queue_search(
        &self,
        version: f64,
        queue_id: Option<i64>,
        device_id: Option<String>,
        account_id: Option<i64>,
        name: Option<String>,
        start: Option<i32>,
        limit: Option<i32>,
        context: &C) -> Result<QueueSearchResponse, ApiError>;

    /// Update Queue
    async fn queue_update(
        &self,
        version: f64,
        queue_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        app_key: Option<String>,
        workers: Option<i32>,
        analytic_tags: Option<String>,
        hostname: Option<String>,
        port: Option<i32>,
        username: Option<String>,
        password: Option<String>,
        virtual_host: Option<String>,
        use_ssl: Option<bool>,
        context: &C) -> Result<QueueUpdateResponse, ApiError>;

    /// Search Accounts by Location
    async fn account_location_search(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        q: Option<String>,
        keyword: Option<String>,
        postal_code: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        app_key: Option<String>,
        range: Option<f64>,
        location_last_updated: Option<i64>,
        gender: Option<String>,
        min_age: Option<i32>,
        max_age: Option<i32>,
        companionship_index: Option<i32>,
        _i: Option<i32>,
        start: Option<i32>,
        _l: Option<i32>,
        limit: Option<i32>,
        search_mode: Option<String>,
        sort_field: Option<String>,
        descending: Option<bool>,
        roles: Option<String>,
        tags: Option<String>,
        experience: Option<String>,
        category_ids: Option<String>,
        audience_ids: Option<String>,
        audience_operator: Option<String>,
        update_current_location: Option<bool>,
        update_preferred_settings: Option<bool>,
        show_exact_locations: Option<bool>,
        show_connection_to_searcher: Option<bool>,
        flag_count_minimum: Option<i64>,
        verified_user_only: Option<bool>,
        content_admin_only: Option<bool>,
        context: &C) -> Result<AccountLocationSearchResponse, ApiError>;

    /// Block Account
    async fn block_account(
        &self,
        version: f64,
        account_id_being_blocked: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        block_flag_value: Option<bool>,
        remove_from_groups_if_blocked: Option<bool>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        context: &C) -> Result<BlockAccountResponse, ApiError>;

    /// Create Account
    async fn create_account(
        &self,
        version: f64,
        username: String,
        password: String,
        name: Option<String>,
        prefix_name: Option<String>,
        first_name: Option<String>,
        middle_name: Option<String>,
        last_name: Option<String>,
        suffix_name: Option<String>,
        title: Option<String>,
        device_id: Option<String>,
        device_id_type: Option<String>,
        email_address: Option<String>,
        asset_id: Option<i64>,
        street_address: Option<String>,
        zipcode: Option<String>,
        gender: Option<String>,
        birthday: Option<i64>,
        home_phone: Option<String>,
        cell_phone: Option<String>,
        cell_phone_carrier: Option<String>,
        business_phone: Option<String>,
        role: Option<String>,
        platforms: Option<String>,
        tags: Option<String>,
        about_us: Option<String>,
        game_experience: Option<String>,
        category_ids: Option<String>,
        hometown: Option<String>,
        height: Option<String>,
        height_index: Option<i32>,
        ethnicity: Option<String>,
        body_type: Option<String>,
        marital_status: Option<String>,
        children: Option<String>,
        religion: Option<String>,
        education: Option<String>,
        education_index: Option<i32>,
        smoke: Option<String>,
        drink: Option<String>,
        companionship: Option<String>,
        companionship_index: Option<i32>,
        preferred_min_age: Option<i32>,
        preferred_max_age: Option<i32>,
        preferred_min_height: Option<i32>,
        preferred_max_height: Option<i32>,
        preferred_gender: Option<String>,
        preferred_education: Option<String>,
        preferred_education_index: Option<i32>,
        preferred_body_type: Option<String>,
        preferred_ethnicity: Option<String>,
        preferred_location: Option<String>,
        preferred_location_range: Option<f64>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        accepted_terms: Option<bool>,
        invite_token: Option<String>,
        referral_account_id: Option<i64>,
        send_validation: Option<bool>,
        game_type: Option<String>,
        app_key: Option<String>,
        app_version: Option<String>,
        response_type: Option<String>,
        audience_ids_to_add: Option<String>,
        app_blob: Option<String>,
        app_enable_push: Option<bool>,
        app_enable_sms: Option<bool>,
        app_enable_email: Option<bool>,
        location_visibility: Option<String>,
        home_latitude: Option<f64>,
        home_longitude: Option<f64>,
        app_nickname: Option<String>,
        personal_audience_id: Option<i64>,
        context: &C) -> Result<CreateAccountResponse, ApiError>;

    /// Update Account
    async fn edit_account(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        connection_account_id: Option<i64>,
        role: Option<String>,
        asset_id: Option<i64>,
        name: Option<String>,
        prefix_name: Option<String>,
        first_name: Option<String>,
        middle_name: Option<String>,
        last_name: Option<String>,
        suffix_name: Option<String>,
        title: Option<String>,
        gender: Option<String>,
        age: Option<i32>,
        birthday: Option<i64>,
        home_phone: Option<String>,
        cell_phone: Option<String>,
        cell_phone_carrier: Option<String>,
        business_phone: Option<String>,
        email_address: Option<String>,
        street_address: Option<String>,
        street_address2: Option<String>,
        city: Option<String>,
        state: Option<String>,
        zipcode: Option<String>,
        country: Option<String>,
        make_profile_info_public: Option<bool>,
        make_game_info_public: Option<bool>,
        make_friends_info_public: Option<bool>,
        hometown: Option<String>,
        height: Option<String>,
        height_index: Option<i32>,
        ethnicity: Option<String>,
        body_type: Option<String>,
        marital_status: Option<String>,
        children: Option<String>,
        religion: Option<String>,
        education: Option<String>,
        education_index: Option<i32>,
        smoke: Option<String>,
        drink: Option<String>,
        companionship: Option<String>,
        companionship_index: Option<i32>,
        preferred_min_age: Option<i32>,
        preferred_max_age: Option<i32>,
        preferred_min_height: Option<i32>,
        preferred_max_height: Option<i32>,
        preferred_gender: Option<String>,
        preferred_education: Option<String>,
        preferred_education_index: Option<i32>,
        preferred_body_type: Option<String>,
        preferred_ethnicity: Option<String>,
        preferred_location: Option<String>,
        preferred_location_range: Option<f64>,
        platforms: Option<String>,
        tags: Option<String>,
        about_us: Option<String>,
        match_token: Option<String>,
        game_experience: Option<String>,
        categories: Option<String>,
        category_ids: Option<String>,
        response_filters: Option<String>,
        show_as_zipcode: Option<bool>,
        show_exact_location: Option<bool>,
        show_others_exact_location: Option<bool>,
        accepted_terms: Option<bool>,
        location_visibility: Option<String>,
        app_blob: Option<String>,
        app_enable_push: Option<bool>,
        app_enable_sms: Option<bool>,
        app_enable_email: Option<bool>,
        game_type: Option<String>,
        app_key: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        return_profile: Option<bool>,
        audience_ids_to_add: Option<String>,
        audience_ids_to_remove: Option<String>,
        referral_account_id: Option<i64>,
        app_nickname: Option<String>,
        personal_audience_id: Option<i64>,
        non_guest_username: Option<String>,
        context: &C) -> Result<EditAccountResponse, ApiError>;

    /// Update Username and Email
    async fn edit_username(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        email_address: Option<String>,
        username: Option<String>,
        context: &C) -> Result<EditUsernameResponse, ApiError>;

    /// Get Account
    async fn get_account(
        &self,
        version: f64,
        return_nulls: Option<bool>,
        device_id: Option<String>,
        account_id: Option<i64>,
        connection_account_email: Option<String>,
        connection_account_id: Option<i64>,
        response_filters: Option<String>,
        game_type: Option<String>,
        app_key: Option<String>,
        purchase_type: Option<String>,
        update_viewed_date: Option<bool>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        context: &C) -> Result<GetAccountResponse, ApiError>;

    /// Get Profile Assets
    async fn get_profile_assets(
        &self,
        version: f64,
        return_nulls: Option<bool>,
        device_id: Option<String>,
        account_id: Option<i64>,
        owner_id: Option<i64>,
        media_types: Option<String>,
        mime_types: Option<String>,
        sort_field: Option<String>,
        descending: Option<bool>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        _i: Option<i32>,
        start: Option<i32>,
        _l: Option<i32>,
        limit: Option<i32>,
        context: &C) -> Result<GetProfileAssetsResponse, ApiError>;

    /// Search Accounts
    async fn get_referral_list(
        &self,
        version: f64,
        account_id: Option<i64>,
        app_key: Option<String>,
        retrieve_type: Option<String>,
        level_limit: Option<f64>,
        ancestor_level_limit: Option<f64>,
        children_level_limit: Option<f64>,
        ancestor_list_start: Option<f64>,
        ancestor_list_limit: Option<f64>,
        children_list_start: Option<f64>,
        children_list_limit: Option<f64>,
        children_children: Option<bool>,
        context: &C) -> Result<GetReferralListResponse, ApiError>;

    /// Get Account Settings
    async fn get_settings(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        context: &C) -> Result<GetSettingsResponse, ApiError>;

    /// Login as Account
    async fn login_delegate(
        &self,
        version: f64,
        access_token: String,
        app_key: String,
        device_id: Option<String>,
        access_token_secret: Option<String>,
        delegated_account_id: Option<i64>,
        delegated_username: Option<String>,
        network_uid: Option<String>,
        age_restriction: Option<i32>,
        response_filters: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        context: &C) -> Result<LoginDelegateResponse, ApiError>;

    /// Login Account
    async fn login_general(
        &self,
        version: f64,
        access_token: String,
        network_uid: String,
        app_key: String,
        device_id: Option<String>,
        device_id_type: Option<String>,
        access_token_secret: Option<String>,
        age_restriction: Option<i32>,
        response_filters: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        email_match: Option<bool>,
        chosen_account_id: Option<i64>,
        third_party_credential_id: Option<i64>,
        context: &C) -> Result<LoginGeneralResponse, ApiError>;

    /// Login Account (Username)
    async fn login_username(
        &self,
        version: f64,
        username: String,
        password: String,
        device_id: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        app: Option<String>,
        game_type: Option<String>,
        app_key: Option<String>,
        return_profile: Option<bool>,
        response_filters: Option<String>,
        context: &C) -> Result<LoginUsernameResponse, ApiError>;

    /// Logout Account
    async fn logout(
        &self,
        version: f64,
        device_id: Option<String>,
        device_id_type: Option<String>,
        account_id: Option<i64>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        context: &C) -> Result<LogoutResponse, ApiError>;

    /// Merge Account
    async fn merge_account(
        &self,
        version: f64,
        merge_account_id: i64,
        app_key: String,
        device_id: Option<String>,
        account_id: Option<i64>,
        context: &C) -> Result<MergeAccountResponse, ApiError>;

    /// Update Password
    async fn password_change(
        &self,
        version: f64,
        account_id: i64,
        old_password: String,
        new_password: String,
        confirm_password: String,
        context: &C) -> Result<PasswordChangeResponse, ApiError>;

    /// Reset Password
    async fn password_reset(
        &self,
        version: f64,
        token: String,
        password: String,
        confirm: String,
        context: &C) -> Result<PasswordResetResponse, ApiError>;

    /// Request Password Reset
    async fn request_password_reset(
        &self,
        version: f64,
        email: String,
        from: Option<String>,
        domain: Option<String>,
        sub_url: Option<String>,
        referer: Option<String>,
        context: &C) -> Result<RequestPasswordResetResponse, ApiError>;

    /// Send Validation Request
    async fn request_validate_account(
        &self,
        version: f64,
        account_id: i64,
        context: &C) -> Result<RequestValidateAccountResponse, ApiError>;

    /// Search Accounts
    async fn search_accounts(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        keyword: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        radius: Option<f64>,
        gender: Option<models::SearchAccountsGenderParameter>,
        game_experience: Option<models::SearchAccountsGameExperienceParameter>,
        age: Option<i32>,
        category_ids: Option<String>,
        return_nulls: Option<bool>,
        response_filters: Option<String>,
        purchase_type: Option<String>,
        sort_field: Option<String>,
        descending: Option<bool>,
        start: Option<i32>,
        limit: Option<i32>,
        active_only: Option<bool>,
        context: &C) -> Result<SearchAccountsResponse, ApiError>;

    /// Login Account (Encrypted Username)
    async fn secure_login(
        &self,
        version: f64,
        username: String,
        password: String,
        game_type: String,
        device_id: Option<String>,
        charset_name: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        return_profile: Option<bool>,
        response_filters: Option<String>,
        context: &C) -> Result<SecureLoginResponse, ApiError>;

    /// Create Account (Encrypted Username)
    async fn secure_signup(
        &self,
        version: f64,
        device_id: String,
        username: String,
        password: String,
        name: Option<String>,
        invite_token: Option<String>,
        prefix_name: Option<String>,
        first_name: Option<String>,
        middle_name: Option<String>,
        last_name: Option<String>,
        suffix_name: Option<String>,
        title: Option<String>,
        device_id_type: Option<String>,
        email_address: Option<String>,
        asset_id: Option<i64>,
        address: Option<String>,
        zipcode: Option<String>,
        gender: Option<String>,
        birthday: Option<i64>,
        home_phone: Option<String>,
        cell_phone: Option<String>,
        cell_phone_carrier: Option<String>,
        business_phone: Option<String>,
        role: Option<String>,
        platforms: Option<String>,
        tags: Option<String>,
        about_us: Option<String>,
        game_experience: Option<String>,
        category_ids: Option<String>,
        hometown: Option<String>,
        height: Option<String>,
        height_index: Option<i32>,
        ethnicity: Option<String>,
        body_type: Option<String>,
        marital_status: Option<String>,
        children: Option<String>,
        religion: Option<String>,
        education: Option<String>,
        education_index: Option<i32>,
        smoke: Option<String>,
        drink: Option<String>,
        companionship: Option<String>,
        companionship_index: Option<i32>,
        preferred_min_age: Option<i32>,
        preferred_max_age: Option<i32>,
        preferred_min_height: Option<i32>,
        preferred_max_height: Option<i32>,
        preferred_gender: Option<String>,
        preferred_education: Option<String>,
        preferred_education_index: Option<i32>,
        preferred_body_type: Option<String>,
        preferred_ethnicity: Option<String>,
        preferred_location: Option<String>,
        preferred_location_range: Option<f64>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        accepted_terms: Option<bool>,
        charset_name: Option<String>,
        game_type: Option<String>,
        app_key: Option<String>,
        app_version: Option<String>,
        response_type: Option<String>,
        context: &C) -> Result<SecureSignupResponse, ApiError>;

    /// Save Match Token
    async fn set_match_token(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        match_token: Option<String>,
        game_type: Option<String>,
        app_key: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        context: &C) -> Result<SetMatchTokenResponse, ApiError>;

    /// Update Account Active Status
    async fn update_actve_status(
        &self,
        version: f64,
        account_id: i64,
        connection_account_id: i64,
        active: bool,
        device_id: Option<String>,
        app_key: Option<String>,
        context: &C) -> Result<UpdateActveStatusResponse, ApiError>;

    /// Update Location
    async fn update_location(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        client_time: Option<i64>,
        context: &C) -> Result<UpdateLocationResponse, ApiError>;

    /// Update Account Settings
    async fn update_settings(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        blocked_notifications: Option<String>,
        suggestion_method: Option<String>,
        suggestion_count: Option<i32>,
        suggestion_time_frame: Option<i32>,
        show_others_exact_location: Option<bool>,
        show_as_zipcode: Option<bool>,
        show_exact_location: Option<bool>,
        favorite_visibility: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        context: &C) -> Result<UpdateSettingsResponse, ApiError>;

    /// Save Validation Status
    async fn validate_account_signup(
        &self,
        version: f64,
        token: String,
        context: &C) -> Result<ValidateAccountSignupResponse, ApiError>;

    /// Validate Password Reset Token
    async fn validate_password_reset(
        &self,
        version: f64,
        token: String,
        context: &C) -> Result<ValidatePasswordResetResponse, ApiError>;

    /// Searches an Achievement Tier
    async fn api_version_achievement_tier_search_post(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        app_key: Option<String>,
        keyword: Option<String>,
        achievement_type: Option<i64>,
        rank_type: Option<String>,
        sort_field: Option<String>,
        descending: Option<bool>,
        descending_goal: Option<bool>,
        start: Option<i64>,
        limit: Option<i64>,
        context: &C) -> Result<ApiVersionAchievementTierSearchPostResponse, ApiError>;

    /// Create Achievement
    async fn create_achievement(
        &self,
        version: f64,
        app_key: String,
        title: String,
        device_id: Option<String>,
        account_id: Option<i64>,
        analytics_tag: Option<String>,
        description: Option<String>,
        rank_type: Option<String>,
        rank_increment: Option<i32>,
        min_increment: Option<i32>,
        max_increment: Option<i32>,
        validate: Option<bool>,
        active: Option<bool>,
        trigger_definition: Option<String>,
        context: &C) -> Result<CreateAchievementResponse, ApiError>;

    /// Create Achievement Tier
    async fn create_achievement_tier(
        &self,
        version: f64,
        achievement_id: i64,
        score_all_instances: bool,
        device_id: Option<String>,
        account_id: Option<i64>,
        icon: Option<swagger::ByteArray>,
        icon_asset_id: Option<i64>,
        title: Option<String>,
        description: Option<String>,
        goal_count: Option<i64>,
        mission_id: Option<i64>,
        game_id: Option<i64>,
        pack_id: Option<i64>,
        game_level_id: Option<i64>,
        game_object_id: Option<i32>,
        context: &C) -> Result<CreateAchievementTierResponse, ApiError>;

    /// Delete Achievement
    async fn delete_achievement(
        &self,
        version: f64,
        achievement_id: i64,
        account_id: Option<i64>,
        context: &C) -> Result<DeleteAchievementResponse, ApiError>;

    /// Delete Achievement Tier
    async fn delete_achievement_tier(
        &self,
        version: f64,
        achievement_tier_id: i64,
        account_id: Option<i64>,
        context: &C) -> Result<DeleteAchievementTierResponse, ApiError>;

    /// Get Achievement
    async fn get_achievement(
        &self,
        version: f64,
        achievement_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        achievement_type: Option<String>,
        context: &C) -> Result<GetAchievementResponse, ApiError>;

    /// Gets an achievement tier
    async fn get_achievement_tier(
        &self,
        version: f64,
        account_id: i64,
        achievement_tier_id: i64,
        context: &C) -> Result<GetAchievementTierResponse, ApiError>;

    /// Get Achievement Progress
    async fn get_user_achievements(
        &self,
        version: f64,
        return_nulls: bool,
        app_key: String,
        include_undiscovered: bool,
        device_id: Option<String>,
        account_id: Option<i64>,
        connection_account_email: Option<String>,
        connection_account_id: Option<i64>,
        rank_type: Option<String>,
        achievement_type: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        context: &C) -> Result<GetUserAchievementsResponse, ApiError>;

    /// List Achievement Tags
    async fn list_achievement_tags(
        &self,
        version: f64,
        app_key: Option<String>,
        context: &C) -> Result<ListAchievementTagsResponse, ApiError>;

    /// List Achievements
    async fn list_achievements(
        &self,
        version: f64,
        sort_field: models::ListAchievementsSortFieldParameter,
        descending: bool,
        start: i32,
        limit: i32,
        active_only: bool,
        device_id: Option<String>,
        account_id: Option<i64>,
        app_key: Option<String>,
        keyword: Option<String>,
        achievement_type: Option<String>,
        rank_type: Option<String>,
        context: &C) -> Result<ListAchievementsResponse, ApiError>;

    /// Search Achievements
    async fn search_achievements(
        &self,
        version: f64,
        app_key: String,
        sort_field: models::SearchAchievementsSortFieldParameter,
        descending: bool,
        include_tiers: bool,
        include_inactive_tiers: bool,
        start: i32,
        limit: i32,
        device_id: Option<String>,
        account_id: Option<i64>,
        keyword: Option<String>,
        achievement_type: Option<String>,
        rank_type: Option<String>,
        context: &C) -> Result<SearchAchievementsResponse, ApiError>;

    /// Update Achievement
    async fn update_achievement(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        achievement_id: Option<i64>,
        analytics_tag: Option<String>,
        title: Option<String>,
        description: Option<String>,
        rank_type: Option<String>,
        rank_increment: Option<i32>,
        min_increment: Option<i32>,
        null_min_increment: Option<bool>,
        max_increment: Option<i32>,
        null_max_increment: Option<bool>,
        validate: Option<bool>,
        active: Option<bool>,
        trigger_definition: Option<String>,
        context: &C) -> Result<UpdateAchievementResponse, ApiError>;

    /// Update Achievement Tier
    async fn update_achievement_tier(
        &self,
        version: f64,
        achievement_tier_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        icon: Option<swagger::ByteArray>,
        icon_asset_id: Option<i64>,
        title: Option<String>,
        description: Option<String>,
        goal_count: Option<i64>,
        mission_id: Option<i64>,
        game_id: Option<i64>,
        pack_id: Option<i64>,
        game_level_id: Option<i64>,
        game_object_id: Option<i64>,
        score_all_instances: Option<bool>,
        context: &C) -> Result<UpdateAchievementTierResponse, ApiError>;

    /// Update Achievement Progress
    async fn update_user_achievement(
        &self,
        version: f64,
        account_id: i64,
        achievement_id: Option<i64>,
        tag: Option<String>,
        custom_id: Option<i64>,
        increment: Option<i64>,
        start_date: Option<i64>,
        end_date: Option<i64>,
        return_progress: Option<bool>,
        context: &C) -> Result<UpdateUserAchievementResponse, ApiError>;

    /// Create an entity reference.
    async fn create_entity_reference(
        &self,
        version: f64,
        body: models::EntityReference,
        context: &C) -> Result<CreateEntityReferenceResponse, ApiError>;

    /// Create Album
    async fn add_album_collection(
        &self,
        version: f64,
        title: String,
        cover_asset_nullable: bool,
        include_cover_in_asset_list: bool,
        public_read: bool,
        public_write: bool,
        public_delete: bool,
        public_add: bool,
        anonymous: bool,
        device_id: Option<String>,
        account_id: Option<i64>,
        assets_to_add: Option<String>,
        media: Option<swagger::ByteArray>,
        media_url: Option<String>,
        asset_id: Option<i64>,
        attached_media: Option<swagger::ByteArray>,
        attached_media_url: Option<String>,
        start_date: Option<i64>,
        end_date: Option<i64>,
        tags: Option<String>,
        description: Option<String>,
        album_type: Option<String>,
        album_type_id: Option<i64>,
        sub_type: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        location_description: Option<String>,
        visibility: Option<models::AddAlbumCollectionVisibilityParameter>,
        game_type: Option<String>,
        app_key: Option<String>,
        cell_phone: Option<String>,
        street_address: Option<String>,
        street_address2: Option<String>,
        city: Option<String>,
        state: Option<String>,
        postal_code: Option<String>,
        full_address: Option<String>,
        meta_data: Option<String>,
        category_ids: Option<String>,
        category_filter_ids: Option<String>,
        audience_ids: Option<String>,
        include_all_app_users_as_members: Option<bool>,
        include_audiences_as_members: Option<bool>,
        audience_operator: Option<String>,
        approval_status: Option<models::ApproveAlbumApprovalStatusParameter>,
        linked_object_type: Option<String>,
        linked_object_id: Option<i64>,
        context: &C) -> Result<AddAlbumCollectionResponse, ApiError>;

    /// Add Album Users
    async fn add_album_users(
        &self,
        version: f64,
        album_id: i64,
        include_friend_group: bool,
        device_id: Option<String>,
        account_id: Option<i64>,
        read: Option<bool>,
        write: Option<bool>,
        delete: Option<bool>,
        add: Option<bool>,
        connections: Option<String>,
        connection_groups: Option<String>,
        context: &C) -> Result<AddAlbumUsersResponse, ApiError>;

    /// Approve Album
    async fn approve_album(
        &self,
        version: f64,
        album_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        approval_status: Option<models::ApproveAlbumApprovalStatusParameter>,
        verified: Option<bool>,
        context: &C) -> Result<ApproveAlbumResponse, ApiError>;

    ///  Get Album
    async fn get_album_collection(
        &self,
        version: f64,
        return_nulls: bool,
        album_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        like_preview_size: Option<i32>,
        asset_preview_size: Option<i32>,
        note_preview_size: Option<i32>,
        connection_preview_size: Option<i32>,
        audience_preview_size: Option<i32>,
        context: &C) -> Result<GetAlbumCollectionResponse, ApiError>;

    /// Leave Album
    async fn leave_album(
        &self,
        version: f64,
        album_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        context: &C) -> Result<LeaveAlbumResponse, ApiError>;

    /// Delete Album
    async fn remove_album(
        &self,
        version: f64,
        album_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        context: &C) -> Result<RemoveAlbumResponse, ApiError>;

    /// Remove Album Users
    async fn remove_album_users(
        &self,
        version: f64,
        album_id: i64,
        remove_friend_group: bool,
        device_id: Option<String>,
        account_id: Option<i64>,
        connections: Option<String>,
        connection_groups: Option<String>,
        context: &C) -> Result<RemoveAlbumUsersResponse, ApiError>;

    /// Search Albums
    async fn search_albums(
        &self,
        version: f64,
        filter: String,
        album_type_id: i64,
        sub_type: String,
        include_inactive: bool,
        sort_field: String,
        descending: bool,
        start: i32,
        limit: i32,
        range: f64,
        include_liked: bool,
        include_favorited: bool,
        include_permissions: bool,
        like_preview_size: i32,
        asset_preview_size: i32,
        note_preview_size: i32,
        connection_preview_size: i32,
        audience_preview_size: i32,
        device_id: Option<String>,
        account_id: Option<i64>,
        connection_account_id: Option<i64>,
        owner_id: Option<i64>,
        album_ids: Option<String>,
        exclude_album_ids: Option<String>,
        media_id: Option<i64>,
        keyword: Option<String>,
        album_type: Option<String>,
        limit_per_album_type: Option<i32>,
        date_created: Option<i64>,
        updated_since: Option<i64>,
        updated_before: Option<i64>,
        created_since: Option<i64>,
        created_before: Option<i64>,
        started_since: Option<i64>,
        started_before: Option<i64>,
        ended_since: Option<i64>,
        ended_before: Option<i64>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        app_key: Option<String>,
        category_ids: Option<String>,
        category_filter_ids: Option<String>,
        audience_ids: Option<String>,
        exclude_audience_ids: Option<String>,
        include_completable: Option<bool>,
        include_rating: Option<bool>,
        search_mode: Option<String>,
        stack_search: Option<bool>,
        stack_window_size: Option<i32>,
        min_stack_per_page: Option<i32>,
        stack_pagination_identifier: Option<String>,
        stack_details: Option<bool>,
        flag_count_minimum: Option<i64>,
        remove_flagged_content: Option<bool>,
        verified_filter: Option<bool>,
        linked_object_type: Option<String>,
        linked_object_id: Option<i64>,
        order_audience_id: Option<i64>,
        ignore_default_app_filter: Option<bool>,
        search_expression: Option<String>,
        generate_albums: Option<bool>,
        context: &C) -> Result<SearchAlbumsResponse, ApiError>;

    /// Update Album
    async fn update_album_collection(
        &self,
        version: f64,
        album_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        assets_to_add: Option<String>,
        assets_to_remove: Option<String>,
        asset_id: Option<i64>,
        media: Option<swagger::ByteArray>,
        media_url: Option<String>,
        active: Option<bool>,
        title: Option<String>,
        start_date: Option<i64>,
        end_date: Option<i64>,
        tags: Option<String>,
        description: Option<String>,
        album_type: Option<String>,
        album_type_id: Option<i64>,
        sub_type: Option<String>,
        public_read: Option<bool>,
        public_write: Option<bool>,
        public_delete: Option<bool>,
        public_add: Option<bool>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        location_description: Option<String>,
        visibility: Option<models::AddAlbumCollectionVisibilityParameter>,
        cell_phone: Option<String>,
        street_address: Option<String>,
        street_address2: Option<String>,
        city: Option<String>,
        state: Option<String>,
        postal_code: Option<String>,
        full_address: Option<String>,
        anonymous: Option<bool>,
        meta_data: Option<String>,
        category_ids: Option<String>,
        category_filter_ids: Option<String>,
        audience_ids: Option<String>,
        audience_ids_to_add: Option<String>,
        audience_ids_to_remove: Option<String>,
        include_all_app_users_as_members: Option<bool>,
        include_audiences_as_members: Option<bool>,
        audience_operator: Option<String>,
        linked_object_type: Option<String>,
        linked_object_id: Option<i64>,
        index_now: Option<bool>,
        context: &C) -> Result<UpdateAlbumCollectionResponse, ApiError>;

    /// Get User Activity
    async fn activities(
        &self,
        version: f64,
        start: i32,
        limit: i32,
        account_id: i64,
        context: &C) -> Result<ActivitiesResponse, ApiError>;

    /// Get Aggregated Filtered Usage
    async fn aggregated_filtered_usage(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        application_id: Option<i64>,
        app_key: Option<String>,
        start_date: Option<i64>,
        end_date: Option<i64>,
        device_type: Option<String>,
        device: Option<String>,
        device_os: Option<String>,
        gender: Option<String>,
        age_group: Option<String>,
        country: Option<String>,
        state: Option<String>,
        city: Option<String>,
        zip: Option<String>,
        model: Option<String>,
        tag: Option<String>,
        user_account_id: Option<i64>,
        user_account_display: Option<String>,
        user_account_username: Option<String>,
        group_by_root: Option<models::AggregatedFilteredUsageGroupByRootParameter>,
        group_by: Option<models::AggregatedFilteredUsageGroupByRootParameter>,
        distinct_count: Option<models::AggregatedFilteredUsageGroupByRootParameter>,
        sort_field: Option<models::AggregatedFilteredUsageGroupByRootParameter>,
        descending: Option<bool>,
        hide_unknown: Option<bool>,
        response_format: Option<models::AggregatedFilteredUsageResponseFormatParameter>,
        _l: Option<i32>,
        limit: Option<i32>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        context: &C) -> Result<AggregatedFilteredUsageResponse, ApiError>;

    /// Get Filtered Usage
    async fn filtered_usage(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        application_id: Option<i64>,
        app_key: Option<String>,
        start_date: Option<i64>,
        end_date: Option<i64>,
        device_type: Option<String>,
        device: Option<String>,
        device_os: Option<String>,
        gender: Option<String>,
        age_group: Option<String>,
        country: Option<String>,
        state: Option<String>,
        city: Option<String>,
        zip: Option<String>,
        model: Option<String>,
        tag: Option<String>,
        user_account_id: Option<i64>,
        user_account_display: Option<String>,
        user_account_username: Option<String>,
        custom_id: Option<i64>,
        custom_type: Option<String>,
        custom_value: Option<f64>,
        custom_value2: Option<f64>,
        custom_long: Option<i64>,
        custom_long2: Option<i64>,
        custom_message: Option<String>,
        custom_message2: Option<String>,
        group_by: Option<models::AggregatedFilteredUsageGroupByRootParameter>,
        distinct_count: Option<models::AggregatedFilteredUsageGroupByRootParameter>,
        sum_column: Option<models::AggregatedFilteredUsageGroupByRootParameter>,
        sort_field: Option<models::AggregatedFilteredUsageGroupByRootParameter>,
        descending: Option<bool>,
        hide_unknown: Option<bool>,
        response_format: Option<models::AggregatedFilteredUsageResponseFormatParameter>,
        _l: Option<i32>,
        limit: Option<i32>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        context: &C) -> Result<FilteredUsageResponse, ApiError>;

    /// Create Usage Record
    async fn usage(
        &self,
        version: f64,
        tag: String,
        device_id: Option<String>,
        account_id: Option<i64>,
        application_id: Option<i64>,
        app_key: Option<String>,
        app_version: Option<String>,
        device: Option<String>,
        device_type: Option<String>,
        device_os: Option<String>,
        model: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        custom_id: Option<i64>,
        custom_type: Option<String>,
        achievement_increment: Option<i64>,
        city: Option<String>,
        state: Option<String>,
        country: Option<String>,
        zip: Option<String>,
        location_description: Option<String>,
        client_time: Option<i64>,
        error_message: Option<String>,
        ip: Option<String>,
        user_agent: Option<String>,
        background_event: Option<bool>,
        custom_message: Option<String>,
        custom_message2: Option<String>,
        custom_value: Option<f64>,
        custom_value2: Option<f64>,
        custom_long: Option<i64>,
        custom_long2: Option<i64>,
        context: &C) -> Result<UsageResponse, ApiError>;

    /// Create Multiple Usage Records
    async fn usage_batch(
        &self,
        version: f64,
        app_key: String,
        device: String,
        data: String,
        device_id: Option<String>,
        account_id: Option<i64>,
        app_version: Option<String>,
        device_type: Option<String>,
        device_os: Option<String>,
        model: Option<String>,
        update_ranking: Option<bool>,
        return_summary_response: Option<bool>,
        context: &C) -> Result<UsageBatchResponse, ApiError>;

    /// Get App Data
    async fn get_app_data(
        &self,
        version: f64,
        start: i32,
        limit: i32,
        device_id: Option<String>,
        account_id: Option<i64>,
        game_type: Option<String>,
        include_game_data: Option<bool>,
        q: Option<String>,
        keyword: Option<String>,
        sort_field: Option<String>,
        descending: Option<bool>,
        _i: Option<i32>,
        _l: Option<i32>,
        game_object_count: Option<bool>,
        filter: Option<String>,
        date_created: Option<i64>,
        owner_id: Option<i64>,
        mission_ids: Option<String>,
        game_ids: Option<String>,
        pack_ids: Option<String>,
        game_level_ids: Option<String>,
        app_version: Option<String>,
        include_higher_version_packs: Option<bool>,
        include_higher_version_levels: Option<bool>,
        response_groups: Option<String>,
        purchase_type: Option<String>,
        context: &C) -> Result<GetAppDataResponse, ApiError>;

    /// Create App Data
    async fn post_app_data(
        &self,
        version: f64,
        game_type: String,
        start: i32,
        limit: i32,
        data: String,
        device_id: Option<String>,
        account_id: Option<i64>,
        include_game_data: Option<bool>,
        q: Option<String>,
        keyword: Option<String>,
        sort_field: Option<String>,
        descending: Option<bool>,
        _i: Option<i32>,
        _l: Option<i32>,
        game_object_count: Option<bool>,
        filter: Option<String>,
        date_created: Option<i64>,
        owner_id: Option<i64>,
        mission_ids: Option<String>,
        game_ids: Option<String>,
        pack_ids: Option<String>,
        game_level_ids: Option<String>,
        app_version: Option<String>,
        include_higher_version_packs: Option<bool>,
        include_higher_version_levels: Option<bool>,
        response_groups: Option<String>,
        purchase_type: Option<String>,
        context: &C) -> Result<PostAppDataResponse, ApiError>;

    /// Regenerate App Data
    async fn regen_app_data(
        &self,
        version: f64,
        account_id: Option<i64>,
        app_key: Option<String>,
        build_version: Option<String>,
        api_version: Option<String>,
        context: &C) -> Result<RegenAppDataResponse, ApiError>;

    /// Create Application
    async fn create_application(
        &self,
        version: f64,
        app_name: String,
        device_id: Option<String>,
        account_id: Option<i64>,
        about: Option<String>,
        bundle_id: Option<String>,
        app_icon_asset_id: Option<i64>,
        app_logo_asset_id: Option<i64>,
        facebook_app_id: Option<String>,
        facebook_app_secret: Option<String>,
        google_api_key: Option<String>,
        update_eula_date: Option<bool>,
        eula_version: Option<String>,
        landing_page_url: Option<String>,
        show_in_activities: Option<bool>,
        activity_description: Option<String>,
        invite_welcome_text: Option<String>,
        invite_page_url: Option<String>,
        url_scheme: Option<String>,
        platforms: Option<String>,
        download_urls: Option<String>,
        category_ids: Option<String>,
        scoring_type: Option<models::CreateApplicationScoringTypeParameter>,
        hint_cost: Option<i32>,
        max_score: Option<i32>,
        tickets_per_point: Option<f32>,
        has_game_data: Option<bool>,
        public_notifications: Option<bool>,
        use_matching_algorithm: Option<bool>,
        global_tickets: Option<bool>,
        build_version: Option<f32>,
        api_version: Option<f32>,
        placement_name: Option<String>,
        placement_description: Option<String>,
        placement_size: Option<models::CreateApplicationPlacementSizeParameter>,
        placement_height: Option<i32>,
        placement_width: Option<i32>,
        placement_refresh_interval: Option<i32>,
        create_object_store: Option<bool>,
        public_content_approval: Option<bool>,
        production_mode: Option<bool>,
        minimum_session_length: Option<i32>,
        session_gap_length: Option<i32>,
        local_ads_enabled: Option<bool>,
        sqoot_api_key: Option<String>,
        trilat_processing_type: Option<models::CreateApplicationTrilatProcessingTypeParameter>,
        max_sample_size: Option<i32>,
        min_rssi: Option<f64>,
        modules: Option<String>,
        authorized_count: Option<i32>,
        authorized_servers: Option<String>,
        default_timezone: Option<String>,
        smtp_pass: Option<String>,
        meta_data: Option<String>,
        placement_meta_data: Option<String>,
        ips_floor: Option<bool>,
        enable_apns_badge: Option<bool>,
        include_in_report: Option<bool>,
        default_app_filter_id: Option<i64>,
        enable_welcome_email: Option<bool>,
        apple_app_id: Option<String>,
        apple_team_id: Option<String>,
        apple_auth_key_id: Option<String>,
        apple_auth_key: Option<swagger::ByteArray>,
        apple_issuer_id: Option<String>,
        app_store_key_id: Option<String>,
        app_store_key: Option<swagger::ByteArray>,
        google_private_key_file: Option<swagger::ByteArray>,
        authorize_net_api_key: Option<String>,
        authorize_net_transaction_key: Option<String>,
        email_sender: Option<String>,
        smtp_user: Option<String>,
        smtp_host: Option<String>,
        vatom_business_id: Option<String>,
        vatom_rest_client_id: Option<String>,
        vatom_rest_secret_key: Option<String>,
        twilio_account_sid: Option<String>,
        twilio_auth_token: Option<String>,
        twilio_sender_phone_number: Option<String>,
        open_ai_secret_key: Option<String>,
        context: &C) -> Result<CreateApplicationResponse, ApiError>;

    /// Create Ad Placement
    async fn create_application_placement(
        &self,
        version: f64,
        app_key: String,
        size: models::CreateApplicationPlacementSizeParameter,
        device_id: Option<String>,
        account_id: Option<i64>,
        name: Option<String>,
        description: Option<String>,
        height: Option<i32>,
        width: Option<i32>,
        refresh_interval: Option<i32>,
        default_image_id: Option<i64>,
        active: Option<bool>,
        context: &C) -> Result<CreateApplicationPlacementResponse, ApiError>;

    /// Delete Application
    async fn delete_application(
        &self,
        version: f64,
        account_id: Option<i64>,
        app_key: Option<String>,
        context: &C) -> Result<DeleteApplicationResponse, ApiError>;

    /// Delete Ad Placement
    async fn delete_application_placement(
        &self,
        version: f64,
        placement_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        context: &C) -> Result<DeleteApplicationPlacementResponse, ApiError>;

    /// Get Application
    async fn get_application(
        &self,
        version: f64,
        app_key: Option<String>,
        application_id: Option<i64>,
        context: &C) -> Result<GetApplicationResponse, ApiError>;

    /// Get Ad Placement
    async fn get_application_placement(
        &self,
        version: f64,
        placement_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        context: &C) -> Result<GetApplicationPlacementResponse, ApiError>;

    /// Get API versions
    async fn get_application_versions(
        &self,
        version: f64,
        context: &C) -> Result<GetApplicationVersionsResponse, ApiError>;

    /// Search Application Users
    async fn get_unique_users_by_app(
        &self,
        version: f64,
        app_key: String,
        q: Option<String>,
        keyword: Option<String>,
        since: Option<i64>,
        _i: Option<i32>,
        start: Option<i32>,
        _l: Option<i32>,
        limit: Option<i32>,
        context: &C) -> Result<GetUniqueUsersByAppResponse, ApiError>;

    /// List Applications
    async fn list_applications(
        &self,
        version: f64,
        account_id: Option<i64>,
        q: Option<String>,
        keyword: Option<String>,
        platforms: Option<String>,
        device_ids: Option<String>,
        device_versions: Option<String>,
        category_ids: Option<String>,
        sort_field: Option<models::ListApplicationsSortFieldParameter>,
        has_ads: Option<bool>,
        public_notifications: Option<bool>,
        filter_billable: Option<bool>,
        filter_content_admin: Option<bool>,
        descending: Option<bool>,
        _i: Option<i32>,
        start: Option<i32>,
        _l: Option<i32>,
        limit: Option<i32>,
        application_ids: Option<String>,
        has_object_store: Option<bool>,
        active_only: Option<bool>,
        context: &C) -> Result<ListApplicationsResponse, ApiError>;

    /// Search for Ad Placements
    async fn search_application_placement(
        &self,
        version: f64,
        app_key: String,
        device_id: Option<String>,
        account_id: Option<i64>,
        start: Option<i32>,
        limit: Option<i32>,
        context: &C) -> Result<SearchApplicationPlacementResponse, ApiError>;

    /// Search for Application Settings
    async fn search_application_settings(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        connection_account_id: Option<i64>,
        keyword: Option<String>,
        sort_field: Option<String>,
        descending: Option<bool>,
        start: Option<i32>,
        limit: Option<i32>,
        context: &C) -> Result<SearchApplicationSettingsResponse, ApiError>;

    /// Search Applications
    async fn search_applications(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        q: Option<String>,
        keyword: Option<String>,
        q_search_fields: Option<String>,
        sort_field: Option<models::SearchApplicationsSortFieldParameter>,
        descending: Option<bool>,
        _i: Option<i32>,
        start: Option<i32>,
        _l: Option<i32>,
        limit: Option<i32>,
        has_ads: Option<bool>,
        public_notifications: Option<bool>,
        active_only: Option<bool>,
        context: &C) -> Result<SearchApplicationsResponse, ApiError>;

    /// Update Application
    async fn update_application(
        &self,
        version: f64,
        app_key: String,
        app_name: String,
        device_id: Option<String>,
        account_id: Option<i64>,
        about: Option<String>,
        bundle_id: Option<String>,
        app_icon_asset_id: Option<i64>,
        app_logo_asset_id: Option<i64>,
        facebook_app_id: Option<String>,
        facebook_app_secret: Option<String>,
        google_api_key: Option<String>,
        update_eula_date: Option<bool>,
        eula_version: Option<String>,
        landing_page_url: Option<String>,
        show_in_activities: Option<bool>,
        activity_description: Option<String>,
        invite_welcome_text: Option<String>,
        invite_page_url: Option<String>,
        url_scheme: Option<String>,
        platforms: Option<String>,
        download_urls: Option<String>,
        category_ids: Option<String>,
        scoring_type: Option<models::CreateApplicationScoringTypeParameter>,
        hint_cost: Option<i32>,
        max_score: Option<i32>,
        tickets_per_point: Option<f32>,
        has_game_data: Option<bool>,
        public_notifications: Option<bool>,
        use_matching_algorithm: Option<bool>,
        global_tickets: Option<bool>,
        build_version: Option<f32>,
        api_version: Option<f32>,
        placement_name: Option<String>,
        placement_description: Option<String>,
        placement_size: Option<models::CreateApplicationPlacementSizeParameter>,
        placement_height: Option<i32>,
        placement_width: Option<i32>,
        placement_refresh_interval: Option<i32>,
        create_object_store: Option<bool>,
        public_content_approval: Option<bool>,
        production_mode: Option<bool>,
        minimum_session_length: Option<i32>,
        session_gap_length: Option<i32>,
        local_ads_enabled: Option<bool>,
        sqoot_api_key: Option<String>,
        trilat_processing_type: Option<models::CreateApplicationTrilatProcessingTypeParameter>,
        max_sample_size: Option<i32>,
        min_rssi: Option<f64>,
        modules: Option<String>,
        authorized_count: Option<i32>,
        authorized_servers: Option<String>,
        default_timezone: Option<String>,
        smtp_pass: Option<String>,
        meta_data: Option<String>,
        placement_meta_data: Option<String>,
        ips_floor: Option<bool>,
        enable_apns_badge: Option<bool>,
        include_in_report: Option<bool>,
        default_app_filter_id: Option<i64>,
        enable_welcome_email: Option<bool>,
        apple_app_id: Option<String>,
        apple_team_id: Option<String>,
        apple_auth_key_id: Option<String>,
        apple_auth_key: Option<swagger::ByteArray>,
        apple_issuer_id: Option<String>,
        app_store_key_id: Option<String>,
        app_store_key: Option<swagger::ByteArray>,
        google_private_key_file: Option<swagger::ByteArray>,
        authorize_net_api_key: Option<String>,
        authorize_net_transaction_key: Option<String>,
        email_sender: Option<String>,
        smtp_user: Option<String>,
        smtp_host: Option<String>,
        vatom_business_id: Option<String>,
        vatom_rest_client_id: Option<String>,
        vatom_rest_secret_key: Option<String>,
        twilio_account_sid: Option<String>,
        twilio_auth_token: Option<String>,
        twilio_sender_phone_number: Option<String>,
        open_ai_secret_key: Option<String>,
        context: &C) -> Result<UpdateApplicationResponse, ApiError>;

    /// Change Appliation Status
    async fn update_application_active(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        active: bool,
        context: &C) -> Result<UpdateApplicationActiveResponse, ApiError>;

    /// Update Ad Placement
    async fn update_application_placement(
        &self,
        version: f64,
        placement_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        name: Option<String>,
        description: Option<String>,
        size: Option<models::CreateApplicationPlacementSizeParameter>,
        height: Option<i32>,
        width: Option<i32>,
        refresh_interval: Option<i32>,
        default_image_id: Option<i64>,
        active: Option<bool>,
        context: &C) -> Result<UpdateApplicationPlacementResponse, ApiError>;

    /// Create Application Certificate
    async fn upload_application_certificate(
        &self,
        version: f64,
        app_key: String,
        device_id: Option<String>,
        account_id: Option<i64>,
        certificate: Option<swagger::ByteArray>,
        context: &C) -> Result<UploadApplicationCertificateResponse, ApiError>;

    /// Create AppConfig
    async fn create_application_config(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        config_version: String,
        asset_id: i64,
        retailer_id: Option<i64>,
        retailer_location_id: Option<i64>,
        udid: Option<String>,
        context: &C) -> Result<CreateApplicationConfigResponse, ApiError>;

    /// Delete AppConfig
    async fn delete_application_config(
        &self,
        version: f64,
        account_id: i64,
        config_id: i64,
        context: &C) -> Result<DeleteApplicationConfigResponse, ApiError>;

    /// Get AppConfig
    async fn get_application_config(
        &self,
        version: f64,
        account_id: i64,
        config_id: i64,
        context: &C) -> Result<GetApplicationConfigResponse, ApiError>;

    /// Get AppConfig by Version
    async fn get_application_config_by_config_version(
        &self,
        version: f64,
        app_key: String,
        config_version: String,
        retailer_id: Option<i64>,
        retailer_location_id: Option<i64>,
        udid: Option<String>,
        allow_older_versions: Option<bool>,
        context: &C) -> Result<GetApplicationConfigByConfigVersionResponse, ApiError>;

    /// Search AppConfigs
    async fn search_application_config(
        &self,
        version: f64,
        account_id: i64,
        app_key: Option<String>,
        retailer_id: Option<i64>,
        retailer_location_id: Option<i64>,
        udid: Option<String>,
        config_version: Option<String>,
        sort_field: Option<String>,
        descending: Option<bool>,
        start: Option<i32>,
        limit: Option<i32>,
        context: &C) -> Result<SearchApplicationConfigResponse, ApiError>;

    /// Update AppConfig
    async fn update_application_config(
        &self,
        version: f64,
        account_id: i64,
        config_id: i64,
        app_key: Option<String>,
        config_version: Option<String>,
        asset_id: Option<i64>,
        retailer_id: Option<i64>,
        retailer_location_id: Option<i64>,
        udid: Option<String>,
        context: &C) -> Result<UpdateApplicationConfigResponse, ApiError>;

    /// Convert Offer to Creative
    async fn asset_morph(
        &self,
        version: f64,
        offer_id: i64,
        ad_size: models::CreateApplicationPlacementSizeParameter,
        creative_id: Option<i64>,
        width: Option<i32>,
        height: Option<i32>,
        background_size: Option<String>,
        template: Option<String>,
        context: &C) -> Result<AssetMorphResponse, ApiError>;

    /// Create Asset
    async fn create_asset(
        &self,
        version: f64,
        return_nulls: Option<bool>,
        device_id: Option<String>,
        account_id: Option<i64>,
        album_id: Option<i64>,
        collection_id: Option<i64>,
        add_to_default_album: Option<String>,
        add_to_media_library: Option<bool>,
        version_code: Option<i32>,
        version_name: Option<String>,
        meta_data: Option<String>,
        caption: Option<String>,
        asset_type: Option<String>,
        approval_status: Option<String>,
        assigned_account_id: Option<i64>,
        media: Option<swagger::ByteArray>,
        media_url: Option<String>,
        media_string: Option<String>,
        media_string_file_name: Option<String>,
        media_string_content_type: Option<String>,
        media_height: Option<i32>,
        media_width: Option<i32>,
        attached_media: Option<swagger::ByteArray>,
        attached_media_url: Option<String>,
        attached_media_string: Option<String>,
        attached_media_string_file_name: Option<String>,
        attached_media_string_content_type: Option<String>,
        attached_media_height: Option<i32>,
        attached_media_width: Option<i32>,
        location_description: Option<String>,
        app: Option<String>,
        app_key: Option<String>,
        search_tags: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        context: &C) -> Result<CreateAssetResponse, ApiError>;

    /// Delete Asset
    async fn delete_asset(
        &self,
        version: f64,
        asset_id: String,
        device_id: Option<String>,
        account_id: Option<i64>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        context: &C) -> Result<DeleteAssetResponse, ApiError>;

    /// Get Asset
    async fn get_asset(
        &self,
        version: f64,
        asset_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        note_descending: Option<bool>,
        context: &C) -> Result<GetAssetResponse, ApiError>;

    /// Remove Asset from Collection
    async fn remove_asset(
        &self,
        version: f64,
        asset_id: String,
        device_id: Option<String>,
        account_id: Option<i64>,
        album_id: Option<i64>,
        collection_id: Option<i64>,
        remove_from_default_albums: Option<bool>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        context: &C) -> Result<RemoveAssetResponse, ApiError>;

    /// Search Assets
    async fn search_assets(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        album_ids: Option<String>,
        asset_ids: Option<String>,
        app_key: Option<String>,
        media_type: Option<String>,
        mime_type: Option<String>,
        keyword: Option<String>,
        version_code: Option<i32>,
        version_name: Option<String>,
        updated_since: Option<i64>,
        updated_before: Option<i64>,
        sort_field: Option<String>,
        descending: Option<bool>,
        search_media_library: Option<bool>,
        filter_by_billable: Option<bool>,
        active_only: Option<bool>,
        return_app: Option<bool>,
        start: Option<i32>,
        limit: Option<i32>,
        search_mode: Option<String>,
        asset_type: Option<String>,
        approval_status: Option<String>,
        assigned_account_id: Option<i64>,
        context: &C) -> Result<SearchAssetsResponse, ApiError>;

    /// Update Asset
    async fn update_asset(
        &self,
        version: f64,
        asset_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        album_id: Option<i64>,
        attached_asset_id: Option<i64>,
        version_code: Option<i32>,
        version_name: Option<String>,
        meta_data: Option<String>,
        caption: Option<String>,
        asset_type: Option<String>,
        approval_status: Option<String>,
        assigned_account_id: Option<i64>,
        media: Option<swagger::ByteArray>,
        media_url: Option<String>,
        media_string: Option<String>,
        media_string_file_name: Option<String>,
        media_string_content_type: Option<String>,
        media_height: Option<i32>,
        media_width: Option<i32>,
        attached_media: Option<swagger::ByteArray>,
        attached_media_url: Option<String>,
        attached_media_string: Option<String>,
        attached_media_string_file_name: Option<String>,
        attached_media_string_content_type: Option<String>,
        attached_media_height: Option<i32>,
        attached_media_width: Option<i32>,
        location_description: Option<String>,
        search_tags: Option<String>,
        app_key: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        context: &C) -> Result<UpdateAssetResponse, ApiError>;

    /// Download Asset
    async fn asset_download(
        &self,
        version: f64,
        filename: String,
        context: &C) -> Result<AssetDownloadResponse, ApiError>;

    /// Search Assignment Assignees
    async fn assigment_assignee_account_search(
        &self,
        version: f64,
        account_id: i64,
        keyword: Option<String>,
        context: &C) -> Result<AssigmentAssigneeAccountSearchResponse, ApiError>;

    /// Create Assignment
    async fn assignment_create(
        &self,
        version: f64,
        account_id: i64,
        name: String,
        assignee_account_id: i64,
        description: Option<String>,
        retailer_location_id: Option<i64>,
        tags: Option<String>,
        active: Option<bool>,
        context: &C) -> Result<AssignmentCreateResponse, ApiError>;

    /// Delete Assignment
    async fn assignment_delete(
        &self,
        version: f64,
        account_id: i64,
        assignment_id: i64,
        context: &C) -> Result<AssignmentDeleteResponse, ApiError>;

    /// Get Assignment
    async fn assignment_get(
        &self,
        version: f64,
        account_id: i64,
        assignment_id: i64,
        context: &C) -> Result<AssignmentGetResponse, ApiError>;

    /// Search Assignments
    async fn assignment_search(
        &self,
        version: f64,
        account_id: i64,
        sort_field: models::AssignmentSearchSortFieldParameter,
        descending: bool,
        active_only: bool,
        start: i32,
        limit: i32,
        creator_account_id: Option<i64>,
        assignee_account_ids: Option<String>,
        retailer_location_ids: Option<String>,
        current_status_type: Option<models::AssignmentSearchCurrentStatusTypeParameter>,
        keyword: Option<String>,
        context: &C) -> Result<AssignmentSearchResponse, ApiError>;

    /// Create Assignment Status
    async fn assignment_status_create(
        &self,
        version: f64,
        account_id: i64,
        assignment_id: i64,
        scheduled_notification_id: Option<i64>,
        to_do: Option<models::AssignmentStatusCreateToDoParameter>,
        connection: Option<models::AssignmentStatusCreateConnectionParameter>,
        method: Option<models::AssignmentStatusCreateMethodParameter>,
        status: Option<models::AssignmentStatusCreateStatusParameter>,
        closure: Option<models::AssignmentStatusCreateClosureParameter>,
        message: Option<String>,
        follow_up: Option<i64>,
        active: Option<bool>,
        context: &C) -> Result<AssignmentStatusCreateResponse, ApiError>;

    /// Deletes Assignment Status
    async fn assignment_status_delete(
        &self,
        version: f64,
        account_id: i64,
        assignment_status_id: i64,
        context: &C) -> Result<AssignmentStatusDeleteResponse, ApiError>;

    /// Get Assignment Status
    async fn assignment_status_get(
        &self,
        version: f64,
        account_id: i64,
        assignment_status_id: i64,
        context: &C) -> Result<AssignmentStatusGetResponse, ApiError>;

    /// Search Assignment Statuses
    async fn assignment_status_search(
        &self,
        version: f64,
        account_id: i64,
        sort_field: models::AssignmentStatusSearchSortFieldParameter,
        descending: bool,
        active_only: bool,
        start: i32,
        limit: i32,
        assignment_id: Option<i64>,
        creator_account_id: Option<i64>,
        assignee_account_id: Option<i64>,
        retailer_location_id: Option<i64>,
        status_type: Option<models::AssignmentStatusCreateStatusParameter>,
        keyword: Option<String>,
        context: &C) -> Result<AssignmentStatusSearchResponse, ApiError>;

    /// Update Assignment Status
    async fn assignment_status_update(
        &self,
        version: f64,
        account_id: i64,
        assignment_status_id: i64,
        scheduled_notification_id: Option<i64>,
        to_do: Option<models::AssignmentStatusCreateToDoParameter>,
        connection: Option<models::AssignmentStatusCreateConnectionParameter>,
        method: Option<models::AssignmentStatusCreateMethodParameter>,
        status: Option<models::AssignmentStatusCreateStatusParameter>,
        closure: Option<models::AssignmentStatusCreateClosureParameter>,
        message: Option<String>,
        follow_up: Option<i64>,
        active: Option<bool>,
        context: &C) -> Result<AssignmentStatusUpdateResponse, ApiError>;

    /// Update Assignment
    async fn assignment_update(
        &self,
        version: f64,
        account_id: i64,
        assignment_id: i64,
        name: Option<String>,
        description: Option<String>,
        assignee_account_id: Option<i64>,
        retailer_location_id: Option<i64>,
        tags: Option<String>,
        active: Option<bool>,
        context: &C) -> Result<AssignmentUpdateResponse, ApiError>;

    /// Create Audience
    async fn create_audience(
        &self,
        version: f64,
        account_id: i64,
        name: String,
        description: Option<String>,
        search_tags: Option<String>,
        gender: Option<String>,
        age_groups: Option<String>,
        category_ids: Option<String>,
        application_ids: Option<String>,
        game_experience_level: Option<String>,
        devices: Option<String>,
        device_ids: Option<String>,
        device_versions: Option<String>,
        locations: Option<String>,
        radius: Option<String>,
        start_time_offset: Option<i32>,
        end_time_offset: Option<i32>,
        send_suggestion: Option<bool>,
        associate_description: Option<String>,
        associate_type: Option<String>,
        associate_id: Option<i64>,
        grouping_id: Option<String>,
        meta_data: Option<String>,
        visibility: Option<String>,
        audience_type: Option<String>,
        use_order: Option<bool>,
        cohort_regions_data: Option<String>,
        app_key: Option<String>,
        trilateration_types: Option<String>,
        unique_name: Option<bool>,
        context: &C) -> Result<CreateAudienceResponse, ApiError>;

    /// Delete Audience
    async fn delete_audience(
        &self,
        version: f64,
        account_id: i64,
        audience_id: i64,
        context: &C) -> Result<DeleteAudienceResponse, ApiError>;

    /// Get Age Groups
    async fn get_age_groups(
        &self,
        version: f64,
        context: &C) -> Result<GetAgeGroupsResponse, ApiError>;

    /// Get Audience
    async fn get_audience(
        &self,
        version: f64,
        account_id: i64,
        audience_id: i64,
        app_key: Option<String>,
        return_account_count: Option<bool>,
        return_album_count: Option<bool>,
        album_types_for_count: Option<String>,
        context: &C) -> Result<GetAudienceResponse, ApiError>;

    /// Search Audiences
    async fn get_audience_list(
        &self,
        version: f64,
        account_id: Option<i64>,
        album_ids: Option<String>,
        keyword: Option<String>,
        keyword_fields: Option<String>,
        sort_field: Option<models::GetAudienceListSortFieldParameter>,
        descending: Option<bool>,
        start: Option<i32>,
        limit: Option<i32>,
        send_suggestion: Option<bool>,
        active_only: Option<bool>,
        group_by_grouping_id: Option<bool>,
        app_key: Option<String>,
        return_global: Option<bool>,
        exact_keyword: Option<bool>,
        audience_type: Option<String>,
        audience_types: Option<String>,
        return_account_count: Option<bool>,
        return_album_count: Option<bool>,
        album_types_for_count: Option<String>,
        context: &C) -> Result<GetAudienceListResponse, ApiError>;

    /// Get Devices
    async fn get_devices(
        &self,
        version: f64,
        include_inactive: bool,
        context: &C) -> Result<GetDevicesResponse, ApiError>;

    /// Get Experiences
    async fn get_experiences(
        &self,
        version: f64,
        context: &C) -> Result<GetExperiencesResponse, ApiError>;

    /// Get GroupedAudiences
    async fn get_grouped_audiences(
        &self,
        version: f64,
        account_id: i64,
        audience_grouping_id: String,
        context: &C) -> Result<GetGroupedAudiencesResponse, ApiError>;

    /// List Suggestions by Audience
    async fn list_by_account(
        &self,
        version: f64,
        account_id: i64,
        limit: i32,
        suggestion_type: String,
        context: &C) -> Result<ListByAccountResponse, ApiError>;

    /// List Offers by Audience
    async fn list_by_audience(
        &self,
        version: f64,
        limit: i32,
        gender: Option<String>,
        age: Option<i32>,
        category_ids: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        context: &C) -> Result<ListByAudienceResponse, ApiError>;

    /// List Sent Suggestions 
    async fn list_lastest_by_account(
        &self,
        version: f64,
        account_id: i64,
        timeframe: i32,
        suggestion_type: String,
        context: &C) -> Result<ListLastestByAccountResponse, ApiError>;

    /// Send Suggestions
    async fn send_by_account(
        &self,
        version: f64,
        account_id: i64,
        latitude: f64,
        longitude: f64,
        context: &C) -> Result<SendByAccountResponse, ApiError>;

    /// Update Audience
    async fn update_audience(
        &self,
        version: f64,
        account_id: i64,
        audience_id: i64,
        name: Option<String>,
        description: Option<String>,
        search_tags: Option<String>,
        gender: Option<String>,
        age_groups: Option<String>,
        category_ids: Option<String>,
        application_ids: Option<String>,
        game_experience_level: Option<String>,
        devices: Option<String>,
        device_ids: Option<String>,
        device_versions: Option<String>,
        locations: Option<String>,
        radius: Option<String>,
        active: Option<bool>,
        send_suggestion: Option<bool>,
        start_time_offset: Option<i32>,
        end_time_offset: Option<i32>,
        associate_description: Option<String>,
        associate_type: Option<String>,
        associate_id: Option<i64>,
        grouping_id: Option<String>,
        meta_data: Option<String>,
        visibility: Option<String>,
        audience_type: Option<String>,
        use_order: Option<bool>,
        cohort_regions_data: Option<String>,
        app_key: Option<String>,
        trilateration_types: Option<String>,
        unique_name: Option<bool>,
        context: &C) -> Result<UpdateAudienceResponse, ApiError>;

    /// Create Bid
    async fn create_bid(
        &self,
        version: f64,
        biddable_type: String,
        biddable_id: i64,
        amount_per_view: f64,
        amount_per_action: f64,
        budget_amount: f64,
        budget_schedule: String,
        device_id: Option<String>,
        account_id: Option<i64>,
        context: &C) -> Result<CreateBidResponse, ApiError>;

    /// Delete Bid
    async fn delete_bid(
        &self,
        version: f64,
        bid_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        context: &C) -> Result<DeleteBidResponse, ApiError>;

    /// Get Bid
    async fn get_bid(
        &self,
        version: f64,
        bid_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        context: &C) -> Result<GetBidResponse, ApiError>;

    /// Update Bid
    async fn update_bid(
        &self,
        version: f64,
        bid_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        amount_per_view: Option<f64>,
        amount_per_action: Option<f64>,
        budget_amount: Option<f64>,
        budget_schedule: Option<String>,
        context: &C) -> Result<UpdateBidResponse, ApiError>;

    /// Create Billable
    async fn create_billable_entity(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        name: Option<String>,
        street_address: Option<String>,
        street_address2: Option<String>,
        city: Option<String>,
        state: Option<String>,
        postal_code: Option<String>,
        business_phone: Option<String>,
        business_phone_ext: Option<String>,
        authorize_net_api_key: Option<String>,
        authorize_net_transaction_key: Option<String>,
        context: &C) -> Result<CreateBillableEntityResponse, ApiError>;

    /// Delete Billable
    async fn delete_billable_entity(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        context: &C) -> Result<DeleteBillableEntityResponse, ApiError>;

    /// Get Billable
    async fn get_billable_entity(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        include_counts: Option<bool>,
        include_payments: Option<bool>,
        context: &C) -> Result<GetBillableEntityResponse, ApiError>;

    /// Update Billable
    async fn update_billable_entity(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        name: Option<String>,
        street_address: Option<String>,
        street_address2: Option<String>,
        city: Option<String>,
        state: Option<String>,
        postal_code: Option<String>,
        business_phone: Option<String>,
        business_phone_ext: Option<String>,
        authorize_net_api_key: Option<String>,
        authorize_net_transaction_key: Option<String>,
        context: &C) -> Result<UpdateBillableEntityResponse, ApiError>;

    /// Update Payment Method
    async fn add_payment_method(
        &self,
        version: f64,
        account_id: i64,
        payment_method_id: Option<i64>,
        account_name: Option<String>,
        first_name: Option<String>,
        last_name: Option<String>,
        address: Option<String>,
        city: Option<String>,
        state: Option<String>,
        postal_code: Option<String>,
        country: Option<String>,
        phone: Option<String>,
        credit_card_number: Option<String>,
        expiration_date: Option<String>,
        ccv: Option<String>,
        account_number: Option<String>,
        bank_name: Option<String>,
        routing_number: Option<String>,
        default_payment_method: Option<bool>,
        payment_method_nickname: Option<String>,
        tax_id: Option<String>,
        provider_customer_profile_id: Option<String>,
        provider_payment_profile_id: Option<String>,
        meta_data: Option<String>,
        context: &C) -> Result<AddPaymentMethodResponse, ApiError>;

    /// Create Payment Method
    async fn create_payment_method(
        &self,
        version: f64,
        account_id: i64,
        account_name: Option<String>,
        first_name: Option<String>,
        last_name: Option<String>,
        address: Option<String>,
        city: Option<String>,
        state: Option<String>,
        postal_code: Option<String>,
        country: Option<String>,
        phone: Option<String>,
        credit_card_number: Option<String>,
        expiration_date: Option<String>,
        ccv: Option<String>,
        account_number: Option<String>,
        bank_name: Option<String>,
        routing_number: Option<String>,
        payment_method_nickname: Option<String>,
        tax_id: Option<String>,
        default_payment_method: Option<bool>,
        auth_token: Option<String>,
        provider: Option<String>,
        provider_customer_profile_id: Option<String>,
        provider_payment_profile_id: Option<String>,
        meta_data: Option<String>,
        app_key: Option<String>,
        context: &C) -> Result<CreatePaymentMethodResponse, ApiError>;

    /// Create Smart Contract
    async fn create_smart_contract(
        &self,
        version: f64,
        account_id: i64,
        token_name: String,
        token_symbol: String,
        payment_method_id: Option<i64>,
        context: &C) -> Result<CreateSmartContractResponse, ApiError>;

    /// Get Crypto Balances
    async fn get_crypto_balance(
        &self,
        version: f64,
        account_id: i64,
        owner_account_id: Option<i64>,
        payment_method_id: Option<i64>,
        context: &C) -> Result<GetCryptoBalanceResponse, ApiError>;

    /// Get Payment Method
    async fn get_payment_method(
        &self,
        version: f64,
        account_id: i64,
        payment_method_id: Option<i64>,
        get_current_balance: Option<bool>,
        context: &C) -> Result<GetPaymentMethodResponse, ApiError>;

    /// Search Payment Methods
    async fn search_payment_method(
        &self,
        version: f64,
        account_id: i64,
        provider: Option<String>,
        param_type: Option<String>,
        keyword: Option<String>,
        sort_field: Option<String>,
        descending: Option<bool>,
        start: Option<i32>,
        limit: Option<i32>,
        context: &C) -> Result<SearchPaymentMethodResponse, ApiError>;

    /// Detail Status
    async fn get_status_csv(
        &self,
        version: f64,
        account_id: i64,
        batch_id: i64,
        response_group: models::GetStatusCsvResponseGroupParameter,
        start: i64,
        limit: i64,
        context: &C) -> Result<GetStatusCsvResponse, ApiError>;

    /// Search Status
    async fn list_status_csv(
        &self,
        version: f64,
        account_id: i64,
        start: i32,
        limit: i32,
        context: &C) -> Result<ListStatusCsvResponse, ApiError>;

    /// Batch Status
    async fn status_csv(
        &self,
        version: f64,
        account_id: i64,
        batch_id: i64,
        context: &C) -> Result<StatusCsvResponse, ApiError>;

    /// Upload CSV
    async fn upload_csv(
        &self,
        version: f64,
        account_id: i64,
        upload_type: models::UploadCsvUploadTypeParameter,
        import_file: swagger::ByteArray,
        file_format: models::UploadCsvFileFormatParameter,
        app_key: Option<String>,
        context: &C) -> Result<UploadCsvResponse, ApiError>;

    /// Create Cargo Type
    async fn create_cargo_type(
        &self,
        version: f64,
        body: Option<models::CargoType>,
        context: &C) -> Result<CreateCargoTypeResponse, ApiError>;

    /// Search Cargo Type
    async fn search_cargo_types(
        &self,
        version: f64,
        sort_field: String,
        descending: bool,
        start: i32,
        limit: i32,
        active_only: bool,
        retailer_id: Option<i64>,
        hub_id: Option<i64>,
        context: &C) -> Result<SearchCargoTypesResponse, ApiError>;

    /// Delete Cargo Type
    async fn delete_cargo_type(
        &self,
        version: f64,
        cargo_type_id: i64,
        context: &C) -> Result<DeleteCargoTypeResponse, ApiError>;

    /// Get Cargo Type
    async fn get_cargo_type(
        &self,
        version: f64,
        cargo_type_id: i64,
        context: &C) -> Result<GetCargoTypeResponse, ApiError>;

    /// Update Cargo Type
    async fn update_cargo_type(
        &self,
        version: f64,
        cargo_type_id: i64,
        body: Option<models::CargoType>,
        context: &C) -> Result<UpdateCargoTypeResponse, ApiError>;

    /// Search Carriers
    async fn search_carriers(
        &self,
        version: f64,
        keyword: Option<String>,
        descending: Option<bool>,
        start: Option<i32>,
        limit: Option<i32>,
        active_only: Option<bool>,
        context: &C) -> Result<SearchCarriersResponse, ApiError>;

    /// Search Categories by Distance
    async fn category_distance_search(
        &self,
        version: f64,
        account_id: Option<i64>,
        keyword: Option<String>,
        app_key: Option<String>,
        category_ids: Option<String>,
        parent_category_ids: Option<String>,
        root_only: Option<bool>,
        sort_field: Option<models::SearchCategoriesSortFieldParameter>,
        response_group: Option<models::SearchCategoriesResponseGroupParameter>,
        descending: Option<bool>,
        start: Option<i32>,
        limit: Option<i32>,
        active_only: Option<bool>,
        return_external: Option<bool>,
        exact_match: Option<bool>,
        param_type: Option<String>,
        external_type: Option<String>,
        min_offer_count: Option<i32>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        range: Option<f64>,
        context: &C) -> Result<CategoryDistanceSearchResponse, ApiError>;

    /// Create Category
    async fn create_category(
        &self,
        version: f64,
        account_id: i64,
        name: String,
        app_key: Option<String>,
        parent_category_id: Option<i64>,
        description: Option<String>,
        param_type: Option<String>,
        asset_id: Option<i64>,
        external_id: Option<String>,
        external_type: Option<String>,
        external_category_slug: Option<String>,
        sqoot_slug: Option<String>,
        active: Option<bool>,
        meta_data: Option<String>,
        search_tags: Option<String>,
        context: &C) -> Result<CreateCategoryResponse, ApiError>;

    /// Delete Category
    async fn delete_category(
        &self,
        version: f64,
        account_id: i64,
        category_id: i64,
        context: &C) -> Result<DeleteCategoryResponse, ApiError>;

    /// Duplicate Category
    async fn duplicate_category(
        &self,
        version: f64,
        account_id: i64,
        category_id: i64,
        app_key: Option<String>,
        parent_category_id: Option<i64>,
        context: &C) -> Result<DuplicateCategoryResponse, ApiError>;

    /// Get Category
    async fn get_category(
        &self,
        version: f64,
        category_id: i64,
        return_external: Option<bool>,
        context: &C) -> Result<GetCategoryResponse, ApiError>;

    /// Search Categories
    async fn search_categories(
        &self,
        version: f64,
        account_id: Option<i64>,
        keyword: Option<String>,
        app_key: Option<String>,
        category_id: Option<String>,
        category_ids: Option<String>,
        parent_category_ids: Option<String>,
        root_only: Option<bool>,
        sort_field: Option<models::SearchCategoriesSortFieldParameter>,
        response_group: Option<models::SearchCategoriesResponseGroupParameter>,
        descending: Option<bool>,
        start: Option<i32>,
        limit: Option<i32>,
        active_only: Option<bool>,
        return_external: Option<bool>,
        exact_match: Option<bool>,
        param_type: Option<String>,
        external_type: Option<String>,
        exclude_external_type: Option<bool>,
        min_offer_count: Option<i32>,
        search_depth: Option<i32>,
        search_mode: Option<String>,
        context: &C) -> Result<SearchCategoriesResponse, ApiError>;

    /// Update Category
    async fn update_category(
        &self,
        version: f64,
        account_id: i64,
        category_id: i64,
        parent_category_id: Option<i64>,
        name: Option<String>,
        description: Option<String>,
        param_type: Option<String>,
        asset_id: Option<i64>,
        external_id: Option<String>,
        external_type: Option<String>,
        external_category_slug: Option<String>,
        sqoot_slug: Option<String>,
        active: Option<bool>,
        meta_data: Option<String>,
        search_tags: Option<String>,
        context: &C) -> Result<UpdateCategoryResponse, ApiError>;

    /// Add Connection
    async fn add_connection_to_group(
        &self,
        version: f64,
        return_nulls: bool,
        group_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        connection_id: Option<i64>,
        connection_account_id: Option<i64>,
        pending_id: Option<i64>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        context: &C) -> Result<AddConnectionToGroupResponse, ApiError>;

    /// Add Connections
    async fn add_connections_to_group(
        &self,
        version: f64,
        connection_group_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        connection_ids: Option<String>,
        connection_account_ids: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        context: &C) -> Result<AddConnectionsToGroupResponse, ApiError>;

    /// Add Connection Groups
    async fn add_sub_groups(
        &self,
        version: f64,
        return_nulls: bool,
        group_id: i64,
        sub_group_ids: String,
        device_id: Option<String>,
        account_id: Option<i64>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        context: &C) -> Result<AddSubGroupsResponse, ApiError>;

    /// Create or Update Connection
    async fn create_or_update_connection(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        connection_id: Option<i64>,
        connection_account_id: Option<i64>,
        pending_id: Option<i64>,
        group_id: Option<i64>,
        game_type: Option<String>,
        app_key: Option<String>,
        is_trusted: Option<bool>,
        ignore_friend_request: Option<bool>,
        is_contact: Option<bool>,
        is_blocked: Option<bool>,
        is_following: Option<bool>,
        connection_response: Option<bool>,
        context: &C) -> Result<CreateOrUpdateConnectionResponse, ApiError>;

    /// Create or Update Connection Group
    async fn create_or_update_group(
        &self,
        version: f64,
        return_nulls: bool,
        device_id: Option<String>,
        account_id: Option<i64>,
        name: Option<String>,
        group_id: Option<i64>,
        asset_id: Option<i64>,
        connections: Option<String>,
        description: Option<String>,
        can_view_profile_info: Option<bool>,
        can_view_game_info: Option<bool>,
        can_view_friend_info: Option<bool>,
        active: Option<bool>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        context: &C) -> Result<CreateOrUpdateGroupResponse, ApiError>;

    /// Accept Follow Request
    async fn follow_accept(
        &self,
        version: f64,
        account_id: i64,
        connection_account_id: i64,
        app_key: String,
        context: &C) -> Result<FollowAcceptResponse, ApiError>;

    /// Reject Follow Request
    async fn follow_reject(
        &self,
        version: f64,
        account_id: i64,
        connection_account_id: i64,
        app_key: String,
        context: &C) -> Result<FollowRejectResponse, ApiError>;

    /// Remove Follower / Unfollow
    async fn follow_remove(
        &self,
        version: f64,
        account_id: i64,
        connection_account_id: i64,
        app_key: String,
        context: &C) -> Result<FollowRemoveResponse, ApiError>;

    /// Send Follow Request
    async fn follow_request(
        &self,
        version: f64,
        account_id: i64,
        connection_account_id: i64,
        app_key: String,
        approval_needed: Option<bool>,
        context: &C) -> Result<FollowRequestResponse, ApiError>;

    /// Accept Friend
    async fn friend_accept(
        &self,
        version: f64,
        friend_account_id: i64,
        notify_friend: bool,
        device_id: Option<String>,
        account_id: Option<i64>,
        game_type: Option<String>,
        app_key: Option<String>,
        notification_message: Option<String>,
        context: &C) -> Result<FriendAcceptResponse, ApiError>;

    /// Decline Friend
    async fn friend_reject(
        &self,
        version: f64,
        friend_account_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        game_type: Option<String>,
        app_key: Option<String>,
        notify_friend: Option<bool>,
        notification_message: Option<String>,
        context: &C) -> Result<FriendRejectResponse, ApiError>;

    /// Delete Friend
    async fn friend_remove(
        &self,
        version: f64,
        friend_account_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        notify_friend: Option<bool>,
        remove_from_groups: Option<bool>,
        context: &C) -> Result<FriendRemoveResponse, ApiError>;

    /// Request Friend
    async fn friend_request(
        &self,
        version: f64,
        friend_account_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        game_type: Option<String>,
        app_key: Option<String>,
        notification_message: Option<String>,
        context: &C) -> Result<FriendRequestResponse, ApiError>;

    /// Get Sent Friend Requests
    async fn get_connection_sent_friend_requests(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        context: &C) -> Result<GetConnectionSentFriendRequestsResponse, ApiError>;

    /// Search Connections
    async fn get_connections(
        &self,
        version: f64,
        return_nulls: bool,
        filter: String,
        sort_field: String,
        descending: bool,
        start: i32,
        limit: i32,
        device_id: Option<String>,
        account_id: Option<i64>,
        connection_account_id: Option<i64>,
        q: Option<String>,
        keyword: Option<String>,
        _i: Option<i32>,
        _l: Option<i32>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        context: &C) -> Result<GetConnectionsResponse, ApiError>;

    /// Get Connection Group
    async fn get_group_details(
        &self,
        version: f64,
        combine_connections: bool,
        device_id: Option<String>,
        account_id: Option<i64>,
        group_id: Option<i64>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        context: &C) -> Result<GetGroupDetailsResponse, ApiError>;

    /// Search Connection Groups
    async fn group_search(
        &self,
        version: f64,
        sort_field: models::GroupSearchSortFieldParameter,
        descending: bool,
        active_only: bool,
        start: i32,
        limit: i32,
        device_id: Option<String>,
        account_id: Option<i64>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        keyword: Option<String>,
        context: &C) -> Result<GroupSearchResponse, ApiError>;

    /// Delete Connection
    async fn remove_connection_from_group(
        &self,
        version: f64,
        return_nulls: bool,
        group_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        connection_id: Option<i64>,
        connection_account_id: Option<i64>,
        pending_id: Option<i64>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        context: &C) -> Result<RemoveConnectionFromGroupResponse, ApiError>;

    /// Remove Connections
    async fn remove_connections_from_group(
        &self,
        version: f64,
        connection_group_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        connection_ids: Option<String>,
        connection_account_ids: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        context: &C) -> Result<RemoveConnectionsFromGroupResponse, ApiError>;

    /// Delete Connection Group
    async fn remove_group(
        &self,
        version: f64,
        return_nulls: bool,
        group_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        context: &C) -> Result<RemoveGroupResponse, ApiError>;

    /// Remove Connection Groups
    async fn remove_sub_groups(
        &self,
        version: f64,
        return_nulls: bool,
        group_id: i64,
        sub_group_ids: String,
        device_id: Option<String>,
        account_id: Option<i64>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        context: &C) -> Result<RemoveSubGroupsResponse, ApiError>;

    /// Search Possible Connections
    async fn search_connections(
        &self,
        version: f64,
        return_nulls: bool,
        start: i32,
        limit: i32,
        device_id: Option<String>,
        account_id: Option<i64>,
        q: Option<String>,
        keyword: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        game_type: Option<String>,
        app_key: Option<String>,
        _i: Option<i32>,
        _l: Option<i32>,
        sort_field: Option<String>,
        has_location: Option<bool>,
        context: &C) -> Result<SearchConnectionsResponse, ApiError>;

    /// Create or Update Contest
    async fn add_or_update_album_contest(
        &self,
        version: f64,
        public_read: bool,
        public_write: bool,
        public_delete: bool,
        public_add: bool,
        visibility: models::AddAlbumCollectionVisibilityParameter,
        include_friend_group: bool,
        device_id: Option<String>,
        account_id: Option<i64>,
        game_type: Option<String>,
        app_key: Option<String>,
        contest_type: Option<String>,
        album_contest_id: Option<i64>,
        title: Option<String>,
        description: Option<String>,
        album_id1: Option<i64>,
        remove_album1: Option<bool>,
        album_id2: Option<i64>,
        remove_album2: Option<bool>,
        start_date: Option<i64>,
        end_date: Option<i64>,
        location_description: Option<String>,
        connection_ids_to_add: Option<String>,
        connection_group_ids_to_add: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        context: &C) -> Result<AddOrUpdateAlbumContestResponse, ApiError>;

    /// Approve Contest
    async fn approve_album_contest(
        &self,
        version: f64,
        album_contest_id: i64,
        approval_status: models::ApproveAlbumApprovalStatusParameter,
        device_id: Option<String>,
        account_id: Option<i64>,
        context: &C) -> Result<ApproveAlbumContestResponse, ApiError>;

    /// Delete Contest
    async fn delete_contest(
        &self,
        version: f64,
        album_contest_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        context: &C) -> Result<DeleteContestResponse, ApiError>;

    /// Get Contest
    async fn get_album_contest(
        &self,
        version: f64,
        album_contest_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        context: &C) -> Result<GetAlbumContestResponse, ApiError>;

    /// Search Contests
    async fn get_album_contests(
        &self,
        version: f64,
        filter: String,
        sort_field: String,
        descending: bool,
        start: i32,
        limit: i32,
        device_id: Option<String>,
        account_id: Option<i64>,
        game_type: Option<String>,
        app_key: Option<String>,
        app_type: Option<String>,
        contest_type: Option<String>,
        owner_id: Option<i64>,
        q: Option<String>,
        keyword: Option<String>,
        _i: Option<i32>,
        _l: Option<i32>,
        date_created: Option<i64>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        context: &C) -> Result<GetAlbumContestsResponse, ApiError>;

    /// Vote on Contest
    async fn vote_on_album_contest(
        &self,
        version: f64,
        album_contest_id: i64,
        album_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        contest_type: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        context: &C) -> Result<VoteOnAlbumContestResponse, ApiError>;

    /// Add Preview
    async fn add_preview(
        &self,
        version: f64,
        account_id: i64,
        creative_id: i64,
        context: &C) -> Result<AddPreviewResponse, ApiError>;

    /// Find Missions
    async fn ads_find(
        &self,
        version: f64,
        app_key: String,
        randomize: bool,
        targeted_ads_only: bool,
        param_type: Option<String>,
        account_id: Option<i64>,
        app_version: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        device: Option<String>,
        device_identifier: Option<i64>,
        device_version: Option<String>,
        start: Option<i32>,
        limit: Option<i32>,
        include_audiences: Option<bool>,
        allocates_tickets: Option<bool>,
        mission_ids: Option<String>,
        context: &C) -> Result<AdsFindResponse, ApiError>;

    /// Create Creative
    async fn create_creative(
        &self,
        version: f64,
        account_id: i64,
        name: String,
        active: bool,
        wait_for_asset: bool,
        description: Option<String>,
        asset_image_id: Option<i64>,
        action: Option<String>,
        data: Option<String>,
        suffix: Option<String>,
        param_type: Option<String>,
        balance: Option<f64>,
        reference_id: Option<i64>,
        app_version: Option<String>,
        mission_id: Option<i64>,
        offer_id: Option<i64>,
        context: &C) -> Result<CreateCreativeResponse, ApiError>;

    /// Delete Creative
    async fn delete_creative(
        &self,
        version: f64,
        account_id: i64,
        creative_id: i64,
        context: &C) -> Result<DeleteCreativeResponse, ApiError>;

    /// Get Creative
    async fn get_creative(
        &self,
        version: f64,
        account_id: i64,
        creative_id: i64,
        context: &C) -> Result<GetCreativeResponse, ApiError>;

    /// Search Creatives
    async fn get_creatives_by_application(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        start: i32,
        limit: i32,
        mission_id: Option<i64>,
        keyword: Option<String>,
        context: &C) -> Result<GetCreativesByApplicationResponse, ApiError>;

    /// Remove Preview
    async fn remove_preview(
        &self,
        version: f64,
        account_id: i64,
        creative_id: i64,
        context: &C) -> Result<RemovePreviewResponse, ApiError>;

    /// Update Creative
    async fn update_creative(
        &self,
        version: f64,
        account_id: i64,
        creative_id: i64,
        name: Option<String>,
        description: Option<String>,
        asset_image_id: Option<i64>,
        action: Option<String>,
        data: Option<String>,
        suffix: Option<String>,
        param_type: Option<String>,
        balance: Option<f64>,
        active: Option<bool>,
        reference_id: Option<i64>,
        app_version: Option<String>,
        mission_id: Option<i64>,
        context: &C) -> Result<UpdateCreativeResponse, ApiError>;

    /// Create Dependent
    async fn create(
        &self,
        version: f64,
        account_id: i64,
        body: Option<models::Account>,
        context: &C) -> Result<CreateResponse, ApiError>;

    /// Get dependent list of an account
    async fn get_dependents(
        &self,
        version: f64,
        account_id: i64,
        context: &C) -> Result<GetDependentsResponse, ApiError>;

    /// Delete Dependent
    async fn remove_dependent(
        &self,
        version: f64,
        account_id: i64,
        dependent_id: i64,
        context: &C) -> Result<RemoveDependentResponse, ApiError>;

    /// Check Disbursements
    async fn check_disbursements(
        &self,
        version: f64,
        disbursement_id: i64,
        context: &C) -> Result<CheckDisbursementsResponse, ApiError>;

    /// Create Disbursement
    async fn create_disbursement(
        &self,
        version: f64,
        account_id: i64,
        receiver_account_id: i64,
        original_sender_account_id: i64,
        amount: f64,
        provider: models::CreateDisbursementProviderParameter,
        scheduled_date: Option<i64>,
        title: Option<String>,
        comment: Option<String>,
        external_id: Option<String>,
        introspection_params: Option<String>,
        context: &C) -> Result<CreateDisbursementResponse, ApiError>;

    /// Get Disbursement
    async fn get_disbursement(
        &self,
        version: f64,
        account_id: i64,
        disbursement_id: i64,
        context: &C) -> Result<GetDisbursementResponse, ApiError>;

    /// Search Disbursements
    async fn search_disbursements(
        &self,
        version: f64,
        account_id: i64,
        receiver_account_id: Option<i64>,
        statuses: Option<String>,
        providers: Option<String>,
        before_date: Option<i64>,
        after_date: Option<i64>,
        start: Option<i32>,
        limit: Option<i32>,
        active_only: Option<bool>,
        external_id: Option<String>,
        context: &C) -> Result<SearchDisbursementsResponse, ApiError>;

    /// Update Disbursement
    async fn update_disbursement(
        &self,
        version: f64,
        account_id: i64,
        disbursement_id: i64,
        amount: Option<f64>,
        provider: Option<models::CreateDisbursementProviderParameter>,
        scheduled_date: Option<i64>,
        title: Option<String>,
        comment: Option<String>,
        external_id: Option<String>,
        retry: Option<bool>,
        introspection_params: Option<String>,
        context: &C) -> Result<UpdateDisbursementResponse, ApiError>;

    /// Assign Employee
    async fn assign_employee(
        &self,
        version: f64,
        account_id: i64,
        manager_account_id: i64,
        employee_account_id: i64,
        role: Option<String>,
        context: &C) -> Result<AssignEmployeeResponse, ApiError>;

    /// Assign Employee to Location
    async fn assign_to_location_employee(
        &self,
        version: f64,
        account_id: i64,
        retailer_location_id: i64,
        employee_account_id: Option<i64>,
        assign: Option<bool>,
        context: &C) -> Result<AssignToLocationEmployeeResponse, ApiError>;

    /// Create Employee
    async fn create_employee(
        &self,
        version: f64,
        account_id: i64,
        manager_account_id: i64,
        username: String,
        password: String,
        name: Option<String>,
        prefix_name: Option<String>,
        first_name: Option<String>,
        middle_name: Option<String>,
        last_name: Option<String>,
        suffix_name: Option<String>,
        title: Option<String>,
        about_us: Option<String>,
        asset_id: Option<i64>,
        gender: Option<models::SearchAccountsGenderParameter>,
        home_phone: Option<String>,
        cell_phone: Option<String>,
        cell_phone_carrier: Option<String>,
        business_phone: Option<String>,
        email_address: Option<String>,
        street_address: Option<String>,
        street_address2: Option<String>,
        city: Option<String>,
        state: Option<String>,
        zipcode: Option<String>,
        country: Option<String>,
        role: Option<String>,
        retailer_location_ids: Option<String>,
        settings_app_key: Option<String>,
        app_blob: Option<String>,
        assigned_device_id: Option<String>,
        context: &C) -> Result<CreateEmployeeResponse, ApiError>;

    /// Delete Employee
    async fn delete_employee(
        &self,
        version: f64,
        account_id: i64,
        employee_account_id: i64,
        context: &C) -> Result<DeleteEmployeeResponse, ApiError>;

    /// Get Employee
    async fn get_employee(
        &self,
        version: f64,
        account_id: i64,
        employee_account_id: i64,
        settings_app_key: Option<String>,
        context: &C) -> Result<GetEmployeeResponse, ApiError>;

    /// Search Employees
    async fn search_employees(
        &self,
        version: f64,
        account_id: i64,
        role: Option<String>,
        retailer_id: Option<i64>,
        retailer_location_id: Option<i64>,
        q: Option<String>,
        keyword: Option<String>,
        sort_field: Option<models::SearchEmployeesSortFieldParameter>,
        descending: Option<bool>,
        _i: Option<i32>,
        start: Option<i32>,
        _l: Option<i32>,
        limit: Option<i32>,
        active_only: Option<bool>,
        managed_only: Option<bool>,
        settings_app_key: Option<String>,
        category_ids: Option<String>,
        query: Option<String>,
        context: &C) -> Result<SearchEmployeesResponse, ApiError>;

    /// Unassign Employee
    async fn unassign_employee(
        &self,
        version: f64,
        account_id: i64,
        employee_account_id: i64,
        context: &C) -> Result<UnassignEmployeeResponse, ApiError>;

    /// Update Employee
    async fn update_employee(
        &self,
        version: f64,
        account_id: i64,
        employee_account_id: i64,
        manager_account_id: Option<i64>,
        name: Option<String>,
        prefix_name: Option<String>,
        first_name: Option<String>,
        middle_name: Option<String>,
        last_name: Option<String>,
        suffix_name: Option<String>,
        title: Option<String>,
        asset_id: Option<i64>,
        gender: Option<models::SearchAccountsGenderParameter>,
        home_phone: Option<String>,
        cell_phone: Option<String>,
        cell_phone_carrier: Option<String>,
        business_phone: Option<String>,
        email_address: Option<String>,
        street_address: Option<String>,
        street_address2: Option<String>,
        city: Option<String>,
        state: Option<String>,
        zipcode: Option<String>,
        country: Option<String>,
        role: Option<String>,
        active: Option<bool>,
        password: Option<String>,
        retailer_location_ids: Option<String>,
        settings_app_key: Option<String>,
        app_blob: Option<String>,
        assigned_device_id: Option<String>,
        context: &C) -> Result<UpdateEmployeeResponse, ApiError>;

    /// Attend Event
    async fn attend_event(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        app_key: Option<String>,
        listing_id: Option<i64>,
        retailer_location_id: Option<i64>,
        offer_location_id: Option<i64>,
        transaction_id: Option<i64>,
        status: Option<i32>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        context: &C) -> Result<AttendEventResponse, ApiError>;

    /// Create Event
    async fn create_event(
        &self,
        version: f64,
        account_id: i64,
        title: String,
        retailer_location_ids: Option<String>,
        sub_title: Option<String>,
        details: Option<String>,
        category_ids: Option<String>,
        filter_ids: Option<String>,
        active: Option<bool>,
        image_asset_id: Option<i64>,
        redeemable_start: Option<i64>,
        redeemable_end: Option<i64>,
        meta_data: Option<String>,
        context: &C) -> Result<CreateEventResponse, ApiError>;

    /// Delete Event
    async fn delete_event(
        &self,
        version: f64,
        account_id: i64,
        event_id: i64,
        context: &C) -> Result<DeleteEventResponse, ApiError>;

    /// Get Event
    async fn get_event(
        &self,
        version: f64,
        account_id: i64,
        event_id: i64,
        context: &C) -> Result<GetEventResponse, ApiError>;

    /// Search Event Attendance
    async fn search_event_transactions(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        app_key: Option<String>,
        keyword: Option<String>,
        retailer_id: Option<i64>,
        retailer_location_id: Option<i64>,
        exclude_retailer_location_id: Option<i64>,
        listing_id: Option<i64>,
        offer_id: Option<i64>,
        offer_location_id: Option<i64>,
        customer_account_ids: Option<String>,
        affiliated_category_ids: Option<String>,
        start_date: Option<i64>,
        end_date: Option<i64>,
        statuses: Option<String>,
        sort_field: Option<models::SearchEventTransactionsSortFieldParameter>,
        descending: Option<bool>,
        start: Option<i32>,
        limit: Option<i32>,
        context: &C) -> Result<SearchEventTransactionsResponse, ApiError>;

    /// Search Events
    async fn search_events(
        &self,
        version: f64,
        account_id: i64,
        keyword: Option<String>,
        active_only: Option<bool>,
        category_ids: Option<String>,
        filter_ids: Option<String>,
        offer_audience_ids: Option<String>,
        transaction_audience_ids: Option<String>,
        sort_field: Option<models::SearchEventsSortFieldParameter>,
        descending: Option<bool>,
        start_date: Option<i64>,
        end_date: Option<i64>,
        start: Option<i32>,
        limit: Option<i32>,
        context: &C) -> Result<SearchEventsResponse, ApiError>;

    /// Update Event
    async fn update_event(
        &self,
        version: f64,
        account_id: i64,
        event_id: i64,
        retailer_location_ids: Option<String>,
        title: Option<String>,
        sub_title: Option<String>,
        details: Option<String>,
        category_ids: Option<String>,
        filter_ids: Option<String>,
        active: Option<bool>,
        image_asset_id: Option<i64>,
        redeemable_start: Option<i64>,
        redeemable_end: Option<i64>,
        context: &C) -> Result<UpdateEventResponse, ApiError>;

    /// Get Facebook Token
    async fn get_token(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        context: &C) -> Result<GetTokenResponse, ApiError>;

    /// Post to Facebook
    async fn graph_interface(
        &self,
        version: f64,
        event: String,
        device_id: Option<String>,
        account_id: Option<i64>,
        permissionable_type: Option<String>,
        permissionable_id: Option<i64>,
        asset_id: Option<i64>,
        game_type: Option<String>,
        app_key: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        context: &C) -> Result<GraphInterfaceResponse, ApiError>;

    /// Create Favorite
    async fn add_favorite(
        &self,
        version: f64,
        favoritable_id: i64,
        favoritable_type: String,
        device_id: Option<String>,
        account_id: Option<i64>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        context: &C) -> Result<AddFavoriteResponse, ApiError>;

    /// Delete Favorite
    async fn delete_favorite(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        favorite_id: Option<i64>,
        favoritable_id: Option<i64>,
        favoritable_type: Option<String>,
        context: &C) -> Result<DeleteFavoriteResponse, ApiError>;

    /// Get Favorite
    async fn get_favorite(
        &self,
        version: f64,
        favorite_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        context: &C) -> Result<GetFavoriteResponse, ApiError>;

    /// Search Favorites
    async fn search_favorites(
        &self,
        version: f64,
        favoritable_type: String,
        sort_field: models::SearchFavoritesSortFieldParameter,
        descending: bool,
        start: i32,
        limit: i32,
        active_only: bool,
        return_full_response: bool,
        device_id: Option<String>,
        account_id: Option<i64>,
        connection_account_id: Option<i64>,
        secondary_type: Option<String>,
        keyword: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        context: &C) -> Result<SearchFavoritesResponse, ApiError>;

    /// Who has Favorited
    async fn who_has_favorited(
        &self,
        version: f64,
        favoritable_id: i64,
        favoritable_type: String,
        start: i32,
        limit: i32,
        device_id: Option<String>,
        account_id: Option<i64>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        keyword: Option<String>,
        context: &C) -> Result<WhoHasFavoritedResponse, ApiError>;

    /// Create Filter
    async fn create_filter(
        &self,
        version: f64,
        account_id: i64,
        name: String,
        app_key: Option<String>,
        parent_filter_id: Option<i64>,
        description: Option<String>,
        external_id: Option<String>,
        external_type: Option<String>,
        active: Option<bool>,
        meta_data: Option<String>,
        context: &C) -> Result<CreateFilterResponse, ApiError>;

    /// Delete Filter
    async fn delete_filter(
        &self,
        version: f64,
        account_id: i64,
        filter_id: i64,
        context: &C) -> Result<DeleteFilterResponse, ApiError>;

    /// Get Filter
    async fn get_filter(
        &self,
        version: f64,
        filter_id: i64,
        context: &C) -> Result<GetFilterResponse, ApiError>;

    /// Search Filters
    async fn search_filters(
        &self,
        version: f64,
        account_id: Option<i64>,
        keyword: Option<String>,
        app_key: Option<String>,
        response_group: Option<models::SearchCategoriesResponseGroupParameter>,
        root_only: Option<bool>,
        sort_field: Option<models::SearchCategoriesSortFieldParameter>,
        descending: Option<bool>,
        start: Option<i32>,
        limit: Option<i32>,
        active_only: Option<bool>,
        context: &C) -> Result<SearchFiltersResponse, ApiError>;

    /// Update Filter
    async fn update_filter(
        &self,
        version: f64,
        account_id: i64,
        filter_id: i64,
        parent_filter_id: Option<i64>,
        name: Option<String>,
        description: Option<String>,
        external_id: Option<String>,
        external_type: Option<String>,
        active: Option<bool>,
        meta_data: Option<String>,
        context: &C) -> Result<UpdateFilterResponse, ApiError>;

    /// Create Flag
    async fn create_flag(
        &self,
        version: f64,
        flagable_type: String,
        flagable_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        flag_description: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        context: &C) -> Result<CreateFlagResponse, ApiError>;

    /// Delete Flag
    async fn delete_flag(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        item_being_flagged_type: Option<String>,
        item_being_flagged_id: Option<i64>,
        flagable_type: Option<String>,
        flagable_id: Option<i64>,
        context: &C) -> Result<DeleteFlagResponse, ApiError>;

    /// Get Flag
    async fn get_flag(
        &self,
        version: f64,
        flagable_type: String,
        flagable_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        context: &C) -> Result<GetFlagResponse, ApiError>;

    /// Get Flag Threshold
    async fn get_flag_threshold(
        &self,
        version: f64,
        item_being_flagged_type: String,
        app_key: String,
        context: &C) -> Result<GetFlagThresholdResponse, ApiError>;

    /// Update Flag Threshold
    async fn update_flag_threshold(
        &self,
        version: f64,
        item_being_flagged_type: String,
        threshold: i64,
        app_key: String,
        device_id: Option<String>,
        account_id: Option<i64>,
        context: &C) -> Result<UpdateFlagThresholdResponse, ApiError>;

    /// Create a Game
    async fn create_game(
        &self,
        version: f64,
        account_id: Option<i64>,
        app_key: Option<String>,
        title: Option<String>,
        description: Option<String>,
        meta_data: Option<String>,
        pack_ids: Option<String>,
        include_game_data: Option<bool>,
        context: &C) -> Result<CreateGameResponse, ApiError>;

    /// Delete a Game
    async fn delete_game(
        &self,
        version: f64,
        account_id: i64,
        game_id: i64,
        context: &C) -> Result<DeleteGameResponse, ApiError>;

    /// Get a Game by id
    async fn get_game(
        &self,
        version: f64,
        account_id: i64,
        game_id: i64,
        include_game_data: Option<bool>,
        context: &C) -> Result<GetGameResponse, ApiError>;

    /// Search a Game
    async fn search_games(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        start: i32,
        limit: i32,
        keyword: Option<String>,
        app_version: Option<String>,
        include_game_data: Option<bool>,
        include_inactive: Option<bool>,
        context: &C) -> Result<SearchGamesResponse, ApiError>;

    /// Update a Game
    async fn update_game(
        &self,
        version: f64,
        account_id: Option<i64>,
        game_id: Option<i64>,
        app_key: Option<String>,
        title: Option<String>,
        description: Option<String>,
        meta_data: Option<String>,
        pack_ids: Option<String>,
        include_game_data: Option<bool>,
        context: &C) -> Result<UpdateGameResponse, ApiError>;

    /// Create Game Level
    async fn create_game_level(
        &self,
        version: f64,
        account_id: i64,
        name: String,
        game_data: String,
        game_data_suffix: String,
        app_key: Option<String>,
        description: Option<String>,
        difficulty: Option<String>,
        app_version: Option<String>,
        asset_image_id: Option<i64>,
        asset_icon_id: Option<i64>,
        visibility: Option<String>,
        friend_group: Option<bool>,
        connection_ids: Option<String>,
        connection_group_ids: Option<String>,
        balance: Option<f64>,
        active: Option<bool>,
        allocate_tickets: Option<bool>,
        ticket_count: Option<i64>,
        ticket_type: Option<String>,
        points: Option<i64>,
        tutorial_title: Option<String>,
        tutorial_message: Option<String>,
        tutorial_alignment: Option<String>,
        tutorial_image_asset_id: Option<i64>,
        offer_id: Option<i64>,
        meta_data: Option<String>,
        context: &C) -> Result<CreateGameLevelResponse, ApiError>;

    /// Delete Game Level
    async fn delete_game_level(
        &self,
        version: f64,
        account_id: i64,
        level_id: i64,
        context: &C) -> Result<DeleteGameLevelResponse, ApiError>;

    /// Get Game Level
    async fn get_game_level(
        &self,
        version: f64,
        account_id: i64,
        level_id: i64,
        include_game_data: Option<bool>,
        context: &C) -> Result<GetGameLevelResponse, ApiError>;

    /// Search Game Levels
    async fn get_game_levels_by_application(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        keyword: Option<String>,
        sort_field: Option<String>,
        descending: Option<bool>,
        start: Option<i32>,
        limit: Option<i32>,
        app_version: Option<String>,
        include_game_data: Option<bool>,
        filters: Option<String>,
        context: &C) -> Result<GetGameLevelsByApplicationResponse, ApiError>;

    /// Search Game Level by Billable Entity
    async fn get_game_levels_by_billable_entity(
        &self,
        version: f64,
        account_id: i64,
        app_key: Option<String>,
        keyword: Option<String>,
        sort_field: Option<models::GetGameLevelsByBillableEntitySortFieldParameter>,
        descending: Option<bool>,
        active_only: Option<bool>,
        start: Option<i64>,
        limit: Option<i64>,
        context: &C) -> Result<GetGameLevelsByBillableEntityResponse, ApiError>;

    /// Get Level Questions
    async fn get_questions_in_level(
        &self,
        version: f64,
        level_id: i64,
        account_id: i64,
        context: &C) -> Result<GetQuestionsInLevelResponse, ApiError>;

    /// Get Level Words
    async fn get_words_in_level(
        &self,
        version: f64,
        level_id: i64,
        account_id: i64,
        context: &C) -> Result<GetWordsInLevelResponse, ApiError>;

    /// Update Game Level
    async fn update_game_level(
        &self,
        version: f64,
        account_id: i64,
        level_id: i64,
        app_key: Option<String>,
        name: Option<String>,
        description: Option<String>,
        difficulty: Option<String>,
        app_version: Option<String>,
        asset_image_id: Option<i64>,
        asset_icon_id: Option<i64>,
        game_data: Option<String>,
        game_data_suffix: Option<String>,
        visibility: Option<String>,
        friend_group: Option<bool>,
        connection_ids: Option<String>,
        connection_group_ids: Option<String>,
        balance: Option<f64>,
        active: Option<bool>,
        allocate_tickets: Option<bool>,
        ticket_count: Option<i64>,
        ticket_type: Option<String>,
        points: Option<i64>,
        tutorial_title: Option<String>,
        tutorial_message: Option<String>,
        tutorial_alignment: Option<String>,
        tutorial_image_asset_id: Option<i64>,
        offer_id: Option<i64>,
        meta_data: Option<String>,
        context: &C) -> Result<UpdateGameLevelResponse, ApiError>;

    /// Update Level Questions
    async fn update_questions_in_level(
        &self,
        version: f64,
        level_id: i64,
        account_id: i64,
        question_ids: String,
        context: &C) -> Result<UpdateQuestionsInLevelResponse, ApiError>;

    /// Update Level Words
    async fn update_words_in_level(
        &self,
        version: f64,
        level_id: i64,
        account_id: i64,
        word_ids: String,
        context: &C) -> Result<UpdateWordsInLevelResponse, ApiError>;

    /// Accept Invite
    async fn accept_invite(
        &self,
        version: f64,
        token: String,
        account_id: i64,
        album_id: Option<i64>,
        mission_id: Option<i64>,
        album_contest_id: Option<i64>,
        offer_id: Option<i64>,
        offer_location_id: Option<i64>,
        retailer_location_id: Option<i64>,
        app_key: Option<String>,
        auto_friend: Option<bool>,
        auto_attend_event: Option<bool>,
        auto_favorite_offer: Option<bool>,
        auto_favorite_offer_location: Option<bool>,
        auto_favorite_retailer_location: Option<bool>,
        context: &C) -> Result<AcceptInviteResponse, ApiError>;

    /// Invite to Contest
    async fn album_contest_invite(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        app_id: Option<i64>,
        app_key: Option<String>,
        album_contest_id: Option<i64>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        context: &C) -> Result<AlbumContestInviteResponse, ApiError>;

    /// Invite to Collection
    async fn album_invite(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        app_id: Option<i64>,
        app_key: Option<String>,
        album_id: Option<i64>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        context: &C) -> Result<AlbumInviteResponse, ApiError>;

    /// Invite to Event
    async fn event_invite(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        listing_id: i64,
        receiver_account_ids: Option<String>,
        retailer_location_id: Option<i64>,
        context: &C) -> Result<EventInviteResponse, ApiError>;

    /// Invite to Game Level
    async fn game_invite(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        app_id: Option<i64>,
        app_key: Option<String>,
        game_level_id: Option<i64>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        context: &C) -> Result<GameInviteResponse, ApiError>;

    /// Get Invite
    async fn get_invite(
        &self,
        version: f64,
        account_id: Option<i64>,
        token: Option<String>,
        album_id: Option<i64>,
        mission_id: Option<i64>,
        album_contest_id: Option<i64>,
        offer_id: Option<i64>,
        offer_location_id: Option<i64>,
        retailer_location_id: Option<i64>,
        app_key: Option<String>,
        context: &C) -> Result<GetInviteResponse, ApiError>;

    /// Invite to Mission
    async fn mission_invite(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        app_id: Option<i64>,
        app_key: Option<String>,
        mission_id: Option<i64>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        context: &C) -> Result<MissionInviteResponse, ApiError>;

    /// Invite to Offer
    async fn offer_invite(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        offer_id: i64,
        context: &C) -> Result<OfferInviteResponse, ApiError>;

    /// Invite to Offer Location
    async fn offer_location_invite(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        offer_location_id: i64,
        context: &C) -> Result<OfferLocationInviteResponse, ApiError>;

    /// Invite to Retailer Location
    async fn retailer_location_invite(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        retailer_location_id: i64,
        album_id: Option<i64>,
        context: &C) -> Result<RetailerLocationInviteResponse, ApiError>;

    /// Create a leaderboard based on the rankingType, rankMode(leaderboardMode), sortField and limitation
    async fn create_leaderboard(
        &self,
        version: f64,
        account_id: Option<i64>,
        app_key: Option<String>,
        rank_type: Option<String>,
        leaderboard_mode: Option<String>,
        icon_media: Option<swagger::ByteArray>,
        icon_asset_id: Option<i64>,
        banner_media: Option<swagger::ByteArray>,
        banner_asset_id: Option<i64>,
        limitation: Option<i32>,
        sort_field: Option<String>,
        title: Option<String>,
        description: Option<String>,
        meta_data: Option<String>,
        context: &C) -> Result<CreateLeaderboardResponse, ApiError>;

    /// Delete the Leader Board
    async fn delete_leaderboard(
        &self,
        version: f64,
        leaderboard_id: i64,
        account_id: Option<i64>,
        context: &C) -> Result<DeleteLeaderboardResponse, ApiError>;

    /// Read a leaderboard by id and retrieve the matching ranking list
    async fn get_leaderboard(
        &self,
        version: f64,
        leaderboard_id: i64,
        account_id: Option<i64>,
        include_full_ranking_list: Option<bool>,
        context: &C) -> Result<GetLeaderboardResponse, ApiError>;

    /// Search leaderboard and retrieve the matching ranking list
    async fn search_leaderboards(
        &self,
        version: f64,
        account_id: Option<i64>,
        app_key: Option<String>,
        global_only: Option<bool>,
        keyword: Option<String>,
        leaderboard_ids: Option<String>,
        rank_types: Option<String>,
        sort_field: Option<String>,
        descending: Option<bool>,
        include_inactive: Option<bool>,
        include_app_response: Option<bool>,
        start: Option<i32>,
        limit: Option<i32>,
        context: &C) -> Result<SearchLeaderboardsResponse, ApiError>;

    /// Update a leaderboard based on the rankingType, rankMode(leaderboardMode), sortField and limitation
    async fn update_leaderboard(
        &self,
        version: f64,
        leaderboard_id: i64,
        account_id: Option<i64>,
        app_key: Option<String>,
        rank_type: Option<String>,
        leaderboard_mode: Option<String>,
        sort_field: Option<String>,
        icon_media: Option<swagger::ByteArray>,
        icon_asset_id: Option<i64>,
        banner_media: Option<swagger::ByteArray>,
        banner_asset_id: Option<i64>,
        limitation: Option<i32>,
        active: Option<bool>,
        title: Option<String>,
        description: Option<String>,
        meta_data: Option<String>,
        context: &C) -> Result<UpdateLeaderboardResponse, ApiError>;

    /// Create Like
    async fn register_like(
        &self,
        version: f64,
        likable_type: String,
        likable_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        permissionable_type: Option<String>,
        permissionable_id: Option<i64>,
        like: Option<bool>,
        app: Option<String>,
        game_type: Option<String>,
        app_key: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        context: &C) -> Result<RegisterLikeResponse, ApiError>;

    /// Delete Like
    async fn remove_like(
        &self,
        version: f64,
        likable_type: String,
        likable_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        context: &C) -> Result<RemoveLikeResponse, ApiError>;

    /// Search Likes
    async fn search_likes(
        &self,
        version: f64,
        likable_type: String,
        likable_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        connection_account_ids: Option<String>,
        sort_field: Option<String>,
        descending: Option<bool>,
        updated_since: Option<i64>,
        updated_before: Option<i64>,
        start: Option<i32>,
        limit: Option<i32>,
        context: &C) -> Result<SearchLikesResponse, ApiError>;

    /// Create Listing
    async fn create_listing(
        &self,
        version: f64,
        account_id: i64,
        name: String,
        filter_ids: Option<String>,
        description: Option<String>,
        start: Option<i64>,
        end: Option<i64>,
        location_name: Option<String>,
        location_description: Option<String>,
        is_private: Option<bool>,
        external_id: Option<String>,
        external_id2: Option<String>,
        external_group_id: Option<String>,
        active: Option<bool>,
        meta_data: Option<String>,
        context: &C) -> Result<CreateListingResponse, ApiError>;

    /// Delete Listing
    async fn delete_listing(
        &self,
        version: f64,
        account_id: i64,
        listing_id: i64,
        context: &C) -> Result<DeleteListingResponse, ApiError>;

    /// Get Listing
    async fn get_listing(
        &self,
        version: f64,
        listing_id: i64,
        context: &C) -> Result<GetListingResponse, ApiError>;

    /// Search Listings
    async fn search_listing(
        &self,
        version: f64,
        account_id: Option<i64>,
        keyword: Option<String>,
        start: Option<i32>,
        limit: Option<i32>,
        active_only: Option<bool>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        start_date: Option<i64>,
        end_date: Option<i64>,
        category_ids: Option<String>,
        filter_ids: Option<String>,
        use_listing_order_ids: Option<bool>,
        external_id: Option<String>,
        external_id2: Option<String>,
        external_group_id: Option<String>,
        context: &C) -> Result<SearchListingResponse, ApiError>;

    /// Summary Listing
    async fn summary_listing(
        &self,
        version: f64,
        account_id: Option<i64>,
        start_date: Option<i64>,
        category_ids: Option<String>,
        days_to_include: Option<i32>,
        use_listing_order_ids: Option<bool>,
        context: &C) -> Result<SummaryListingResponse, ApiError>;

    /// Update Listing
    async fn update_listing(
        &self,
        version: f64,
        account_id: i64,
        listing_id: i64,
        filter_ids: Option<String>,
        name: Option<String>,
        description: Option<String>,
        start: Option<i64>,
        end: Option<i64>,
        location_name: Option<String>,
        location_description: Option<String>,
        is_private: Option<bool>,
        external_id: Option<String>,
        external_id2: Option<String>,
        external_group_id: Option<String>,
        active: Option<bool>,
        meta_data: Option<String>,
        context: &C) -> Result<UpdateListingResponse, ApiError>;

    /// Create Trilateration Data with File
    async fn cache_trilateration_data(
        &self,
        version: f64,
        udid: String,
        source_time: Option<i64>,
        minimum_sample_size: Option<i32>,
        data: Option<String>,
        data_file: Option<swagger::ByteArray>,
        context: &C) -> Result<CacheTrilaterationDataResponse, ApiError>;

    /// Create Trilateration Data with Rest
    async fn cache_trilateration_data_gzip(
        &self,
        version: f64,
        body: Option<models::TrilatCacheRequest>,
        context: &C) -> Result<CacheTrilaterationDataGzipResponse, ApiError>;

    /// Get Location by IP
    async fn get_location_by_ip(
        &self,
        version: f64,
        ip: Option<String>,
        context: &C) -> Result<GetLocationByIpResponse, ApiError>;

    /// Get Location by Trilateration
    async fn get_location_by_trilateration(
        &self,
        version: f64,
        account_id: Option<i64>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        data: Option<String>,
        response_filters: Option<String>,
        context: &C) -> Result<GetLocationByTrilaterationResponse, ApiError>;

    /// Search Regions or Postal Codes
    async fn get_locations(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        currentlatitude: Option<f64>,
        currentlongitude: Option<f64>,
        current_latitude: Option<f64>,
        current_longitude: Option<f64>,
        query: Option<String>,
        zipcode: Option<String>,
        zip_code: Option<String>,
        selected_maplatitude: Option<f64>,
        selected_maplongitude: Option<f64>,
        selected_map_latitude: Option<f64>,
        selected_map_longitude: Option<f64>,
        search_range: Option<f64>,
        use_geocode: Option<bool>,
        _i: Option<i32>,
        start: Option<i32>,
        _l: Option<i32>,
        limit: Option<i32>,
        context: &C) -> Result<GetLocationsResponse, ApiError>;

    /// Create new location
    async fn create_location_v2(
        &self,
        version: f64,
        body: Option<models::Location>,
        context: &C) -> Result<CreateLocationV2Response, ApiError>;

    /// Update an existing location
    async fn update_location_v2(
        &self,
        version: f64,
        id: i64,
        body: Option<models::Location>,
        context: &C) -> Result<UpdateLocationV2Response, ApiError>;

    /// Create Media
    async fn create_media(
        &self,
        version: f64,
        account_id: i64,
        title: String,
        barcode_type: models::CreateMediaBarcodeTypeParameter,
        no_expiration: bool,
        available_limit: i32,
        available_limit_per_user: i32,
        added_limit: i32,
        view_limit: i32,
        max_prints: i32,
        ticket_price: i64,
        full_price: f64,
        discount_price: f64,
        special_offer_type: models::CreateMediaSpecialOfferTypeParameter,
        offer_visibility: models::CreateMediaOfferVisibilityParameter,
        active: bool,
        retailer_location_ids: Option<String>,
        sub_title: Option<String>,
        details: Option<String>,
        sub_details: Option<String>,
        fine_print: Option<String>,
        barcode_entry: Option<String>,
        external_redeem_options: Option<String>,
        external_url: Option<String>,
        tickets_reward_type: Option<String>,
        tickets_reward: Option<i64>,
        activated: Option<i64>,
        expires: Option<i64>,
        ticket_price_type: Option<String>,
        show_remaining: Option<bool>,
        show_redeemed: Option<bool>,
        replaced: Option<bool>,
        featured: Option<bool>,
        category_ids: Option<String>,
        filter_ids: Option<String>,
        barcode_asset_id: Option<i64>,
        image_asset_id: Option<i64>,
        image_asset_id1: Option<i64>,
        image_asset_id2: Option<i64>,
        image_asset_id3: Option<i64>,
        image_asset_id4: Option<i64>,
        image_asset_id5: Option<i64>,
        publisher: Option<String>,
        redeemable_start: Option<i64>,
        redeemable_end: Option<i64>,
        condition_type: Option<models::CreateMediaConditionTypeParameter>,
        isbn: Option<String>,
        asin: Option<String>,
        catalog_numbers: Option<String>,
        parental_rating: Option<String>,
        availability_date: Option<i64>,
        media_type: Option<models::CreateMediaMediaTypeParameter>,
        duration: Option<i32>,
        author: Option<String>,
        release_date: Option<i64>,
        collection_ids: Option<String>,
        availability: Option<String>,
        availability_summary: Option<String>,
        context: &C) -> Result<CreateMediaResponse, ApiError>;

    /// Delete Media
    async fn delete_media(
        &self,
        version: f64,
        account_id: i64,
        media_id: i64,
        context: &C) -> Result<DeleteMediaResponse, ApiError>;

    /// Media Get
    async fn get_media(
        &self,
        version: f64,
        account_id: i64,
        media_id: i64,
        context: &C) -> Result<GetMediaResponse, ApiError>;

    /// Search Media
    async fn search_media(
        &self,
        version: f64,
        account_id: i64,
        active_only: bool,
        sort_field: models::SearchEventsSortFieldParameter,
        descending: bool,
        keyword: Option<String>,
        category_ids: Option<String>,
        filter_ids: Option<String>,
        start: Option<i32>,
        limit: Option<i32>,
        context: &C) -> Result<SearchMediaResponse, ApiError>;

    /// Update Media
    async fn update_media(
        &self,
        version: f64,
        account_id: i64,
        media_id: i64,
        retailer_location_ids: Option<String>,
        offer_locations: Option<String>,
        title: Option<String>,
        sub_title: Option<String>,
        details: Option<String>,
        sub_details: Option<String>,
        fine_print: Option<String>,
        barcode_type: Option<models::CreateMediaBarcodeTypeParameter>,
        barcode_entry: Option<String>,
        external_redeem_options: Option<String>,
        external_url: Option<String>,
        tickets_reward_type: Option<String>,
        tickets_reward: Option<i64>,
        activated: Option<i64>,
        expires: Option<i64>,
        no_expiration: Option<bool>,
        available_limit: Option<i32>,
        available_limit_per_user: Option<i32>,
        added_limit: Option<i32>,
        view_limit: Option<i32>,
        max_prints: Option<i32>,
        ticket_price_type: Option<String>,
        ticket_price: Option<i64>,
        full_price: Option<f64>,
        discount_price: Option<f64>,
        show_remaining: Option<bool>,
        show_redeemed: Option<bool>,
        replaced: Option<bool>,
        featured: Option<bool>,
        special_offer_type: Option<models::CreateMediaSpecialOfferTypeParameter>,
        offer_visibility: Option<models::CreateMediaOfferVisibilityParameter>,
        category_ids: Option<String>,
        filter_ids: Option<String>,
        active: Option<bool>,
        barcode_asset_id: Option<i64>,
        image_asset_id: Option<i64>,
        image_asset_id1: Option<i64>,
        image_asset_id2: Option<i64>,
        image_asset_id3: Option<i64>,
        image_asset_id4: Option<i64>,
        image_asset_id5: Option<i64>,
        publisher: Option<String>,
        redeemable_start: Option<i64>,
        redeemable_end: Option<i64>,
        condition_type: Option<models::CreateMediaConditionTypeParameter>,
        isbn: Option<String>,
        asin: Option<String>,
        catalog_numbers: Option<String>,
        availability_date: Option<i64>,
        parental_rating: Option<String>,
        media_type: Option<models::CreateMediaMediaTypeParameter>,
        duration: Option<i32>,
        author: Option<String>,
        release_date: Option<i64>,
        collection_ids: Option<String>,
        availability: Option<String>,
        availability_summary: Option<String>,
        context: &C) -> Result<UpdateMediaResponse, ApiError>;

    /// Create Mission
    async fn create_mission(
        &self,
        version: f64,
        account_id: i64,
        title: String,
        description: Option<String>,
        sub_type: Option<String>,
        start_date: Option<i64>,
        end_date: Option<i64>,
        active: Option<bool>,
        game_level_ids: Option<String>,
        creative_ids: Option<String>,
        audience_ids: Option<String>,
        mission_task: Option<String>,
        format_type: Option<String>,
        offer_id: Option<i64>,
        balance: Option<f64>,
        advanced_reporting: Option<bool>,
        allocate_tickets: Option<bool>,
        ticket_count: Option<i64>,
        ticket_type: Option<String>,
        points: Option<i64>,
        meta_data: Option<String>,
        application_ids: Option<String>,
        devices: Option<String>,
        device_ids: Option<String>,
        device_versions: Option<String>,
        locations: Option<String>,
        radius: Option<String>,
        context: &C) -> Result<CreateMissionResponse, ApiError>;

    /// Delete Mission
    async fn delete_mission(
        &self,
        version: f64,
        account_id: i64,
        mission_id: i64,
        context: &C) -> Result<DeleteMissionResponse, ApiError>;

    /// Find Missions
    async fn find_missions(
        &self,
        version: f64,
        app_key: String,
        suffix: Option<String>,
        param_type: Option<String>,
        account_id: Option<i64>,
        app_version: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        device: Option<String>,
        device_identifier: Option<i64>,
        device_version: Option<String>,
        start: Option<i32>,
        limit: Option<i32>,
        include_game_data: Option<bool>,
        include_audiences: Option<bool>,
        allocates_tickets: Option<bool>,
        randomize: Option<bool>,
        targeted_ads_only: Option<bool>,
        mission_ids: Option<String>,
        audience_operator: Option<String>,
        context: &C) -> Result<FindMissionsResponse, ApiError>;

    /// Get Mission
    async fn get_mission(
        &self,
        version: f64,
        account_id: i64,
        mission_id: i64,
        return_creative: Option<bool>,
        context: &C) -> Result<GetMissionResponse, ApiError>;

    /// Import Mission
    async fn import_mission(
        &self,
        version: f64,
        account_id: i64,
        latitude: f64,
        longitude: f64,
        app_key: String,
        keyword: Option<String>,
        start: Option<i32>,
        limit: Option<i32>,
        ad_size: Option<models::CreateApplicationPlacementSizeParameter>,
        context: &C) -> Result<ImportMissionResponse, ApiError>;

    /// Search Mission Formats
    async fn search_mission_formats(
        &self,
        version: f64,
        start: i32,
        limit: i32,
        active_only: bool,
        context: &C) -> Result<SearchMissionFormatsResponse, ApiError>;

    /// Search Missions
    async fn search_missions(
        &self,
        version: f64,
        account_id: i64,
        keyword: Option<String>,
        sub_type: Option<String>,
        start: Option<i32>,
        limit: Option<i32>,
        include_game_data: Option<bool>,
        include_audiences: Option<bool>,
        include_inactive: Option<bool>,
        suffix: Option<String>,
        sort_field: Option<String>,
        descending: Option<bool>,
        context: &C) -> Result<SearchMissionsResponse, ApiError>;

    /// Search Missions by Billable Entity
    async fn search_missions_by_billable_entity(
        &self,
        version: f64,
        account_id: i64,
        keyword: Option<String>,
        start: Option<i32>,
        limit: Option<i32>,
        include_game_data: Option<bool>,
        include_audiences: Option<bool>,
        include_inactive: Option<bool>,
        suffix: Option<String>,
        sort_field: Option<String>,
        descending: Option<bool>,
        context: &C) -> Result<SearchMissionsByBillableEntityResponse, ApiError>;

    /// Update Mission
    async fn update_mission(
        &self,
        version: f64,
        account_id: i64,
        mission_id: i64,
        title: Option<String>,
        description: Option<String>,
        sub_type: Option<String>,
        meta_data: Option<String>,
        start_date: Option<i64>,
        end_date: Option<i64>,
        active: Option<bool>,
        game_level_ids: Option<String>,
        creative_ids: Option<String>,
        audience_ids: Option<String>,
        offer_id: Option<i64>,
        balance: Option<f64>,
        advanced_reporting: Option<bool>,
        allocate_tickets: Option<bool>,
        ticket_count: Option<i64>,
        ticket_type: Option<String>,
        points: Option<i64>,
        application_ids: Option<String>,
        devices: Option<String>,
        device_ids: Option<String>,
        device_versions: Option<String>,
        locations: Option<String>,
        radius: Option<String>,
        context: &C) -> Result<UpdateMissionResponse, ApiError>;

    /// Create Mission Invite
    async fn create_mission_invite(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        mission_id: Option<i64>,
        join_code: Option<String>,
        include_game_data: Option<bool>,
        context: &C) -> Result<CreateMissionInviteResponse, ApiError>;

    /// Delete Mission Invite
    async fn delete_mission_invite(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        mission_id: Option<i64>,
        mission_invite_id: Option<i64>,
        include_game_data: Option<bool>,
        context: &C) -> Result<DeleteMissionInviteResponse, ApiError>;

    /// Get Mission Invite
    async fn get_mission_invite(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        mission_id: Option<i64>,
        mission_invite_id: Option<i64>,
        include_game_data: Option<bool>,
        include_scores: Option<String>,
        context: &C) -> Result<GetMissionInviteResponse, ApiError>;

    /// Search Mission Invites
    async fn search_mission_invites(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        app_key: Option<String>,
        app_version: Option<String>,
        mission_id: Option<i64>,
        status: Option<String>,
        last_updated: Option<i64>,
        start: Option<i32>,
        limit: Option<i32>,
        keyword: Option<String>,
        mission_types: Option<String>,
        filter_by_billable: Option<bool>,
        include_game_data: Option<bool>,
        context: &C) -> Result<SearchMissionInvitesResponse, ApiError>;

    /// Update Mission Invite
    async fn update_mission_invite(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        app_key: Option<String>,
        mission_id: Option<i64>,
        mission_invite_id: Option<i64>,
        pack_id: Option<i64>,
        game_level_id: Option<i64>,
        status: Option<String>,
        permissionable_type: Option<String>,
        permissionable_id: Option<i64>,
        include_game_data: Option<bool>,
        context: &C) -> Result<UpdateMissionInviteResponse, ApiError>;

    /// Batch Note Operation
    async fn batch_operation(
        &self,
        version: f64,
        notable_id: i64,
        notable_type: String,
        device_id: Option<String>,
        account_id: Option<i64>,
        batch_operation: Option<String>,
        context: &C) -> Result<BatchOperationResponse, ApiError>;

    /// Create Note
    async fn create_note(
        &self,
        version: f64,
        comment: String,
        device_id: Option<String>,
        account_id: Option<i64>,
        notable_type: Option<String>,
        notable_id: Option<i64>,
        note_type: Option<String>,
        asset_ids: Option<String>,
        tags: Option<String>,
        permissionable_type: Option<String>,
        permissionable_id: Option<i64>,
        app_key: Option<String>,
        location_description: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        meta_data: Option<String>,
        receiver_account_ids: Option<String>,
        return_full_response: Option<bool>,
        initialize_asset: Option<bool>,
        asset_return_nulls: Option<bool>,
        asset_album_id: Option<i64>,
        asset_collection_id: Option<i64>,
        asset_add_to_default_album: Option<String>,
        asset_add_to_media_library: Option<bool>,
        asset_version_code: Option<i32>,
        asset_version_name: Option<String>,
        asset_meta_data: Option<String>,
        asset_caption: Option<String>,
        asset_media: Option<swagger::ByteArray>,
        asset_media_url: Option<String>,
        asset_media_string: Option<String>,
        asset_media_string_file_name: Option<String>,
        asset_media_string_content_type: Option<String>,
        asset_attached_media: Option<swagger::ByteArray>,
        asset_attached_media_url: Option<String>,
        asset_attached_media_string: Option<String>,
        asset_attached_media_string_file_name: Option<String>,
        asset_attached_media_string_content_type: Option<String>,
        asset_location_description: Option<String>,
        asset_app: Option<String>,
        asset_search_tags: Option<String>,
        asset_latitude: Option<f64>,
        asset_longitude: Option<f64>,
        context: &C) -> Result<CreateNoteResponse, ApiError>;

    /// Delete Note
    async fn delete_note(
        &self,
        version: f64,
        note_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        app_key: Option<String>,
        context: &C) -> Result<DeleteNoteResponse, ApiError>;

    /// Get Note
    async fn get_note(
        &self,
        version: f64,
        note_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        return_full_response: Option<bool>,
        context: &C) -> Result<GetNoteResponse, ApiError>;

    /// Search Notes
    async fn search_notes(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        notable_type: Option<String>,
        notable_id: Option<i64>,
        note_types: Option<String>,
        app_key: Option<String>,
        keyword: Option<String>,
        flag_count_minimum: Option<i64>,
        flags_exceed_threshold: Option<bool>,
        include_inactive: Option<bool>,
        sort_field: Option<models::SearchNotesSortFieldParameter>,
        descending: Option<bool>,
        return_full_response: Option<bool>,
        updated_since: Option<i64>,
        updated_before: Option<i64>,
        start: Option<i32>,
        limit: Option<i32>,
        context: &C) -> Result<SearchNotesResponse, ApiError>;

    /// Update Note
    async fn update_note(
        &self,
        version: f64,
        note_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        comment: Option<String>,
        note_type: Option<String>,
        asset_ids: Option<String>,
        tags: Option<String>,
        permissionable_type: Option<String>,
        permissionable_id: Option<i64>,
        app_key: Option<String>,
        location_description: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        meta_data: Option<String>,
        return_full_response: Option<bool>,
        active: Option<bool>,
        update_asset: Option<bool>,
        asset_return_nulls: Option<bool>,
        asset_album_id: Option<i64>,
        asset_collection_id: Option<i64>,
        asset_add_to_default_album: Option<String>,
        asset_add_to_media_library: Option<bool>,
        asset_version_code: Option<i32>,
        asset_version_name: Option<String>,
        asset_meta_data: Option<String>,
        asset_caption: Option<String>,
        asset_media: Option<swagger::ByteArray>,
        asset_media_url: Option<String>,
        asset_media_string: Option<String>,
        asset_media_string_file_name: Option<String>,
        asset_media_string_content_type: Option<String>,
        asset_attached_media: Option<swagger::ByteArray>,
        asset_attached_media_url: Option<String>,
        asset_attached_media_string: Option<String>,
        asset_attached_media_string_file_name: Option<String>,
        asset_attached_media_string_content_type: Option<String>,
        asset_location_description: Option<String>,
        asset_app: Option<String>,
        asset_search_tags: Option<String>,
        asset_latitude: Option<f64>,
        asset_longitude: Option<f64>,
        context: &C) -> Result<UpdateNoteResponse, ApiError>;

    /// Create Notification Template
    async fn create_notification_template(
        &self,
        version: f64,
        account_id: i64,
        conduit: String,
        title: String,
        body: String,
        app_key: Option<String>,
        event: Option<String>,
        tags: Option<String>,
        context: &C) -> Result<CreateNotificationTemplateResponse, ApiError>;

    /// Create or update blocked notification settings
    async fn create_or_update_blocked_notifications(
        &self,
        version: f64,
        app_key: String,
        data: String,
        account_id: Option<i64>,
        context: &C) -> Result<CreateOrUpdateBlockedNotificationsResponse, ApiError>;

    /// Delete Notification Template
    async fn delete_notification_template(
        &self,
        version: f64,
        account_id: i64,
        notification_template_id: i64,
        context: &C) -> Result<DeleteNotificationTemplateResponse, ApiError>;

    /// Get Notification Template
    async fn get_notification_template(
        &self,
        version: f64,
        account_id: i64,
        notification_template_id: i64,
        context: &C) -> Result<GetNotificationTemplateResponse, ApiError>;

    /// Get Notifications
    async fn get_notifications(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        connection_account_id: Option<i64>,
        app_key: Option<String>,
        event_type: Option<String>,
        content_ids: Option<String>,
        content_types: Option<String>,
        parent_ids: Option<String>,
        parent_types: Option<String>,
        action_category: Option<String>,
        conduits: Option<String>,
        keyword: Option<String>,
        return_read_messages: Option<bool>,
        mark_as_read: Option<bool>,
        from_date: Option<i64>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        return_sent: Option<bool>,
        ignore_flagged: Option<bool>,
        start: Option<i32>,
        limit: Option<i32>,
        context: &C) -> Result<GetNotificationsResponse, ApiError>;

    /// Register Notification Token
    async fn register_notification_token(
        &self,
        version: f64,
        token: String,
        push_type: models::RegisterNotificationTokenPushTypeParameter,
        device_id: Option<String>,
        account_id: Option<i64>,
        environment: Option<String>,
        app_key: Option<String>,
        game_type: Option<String>,
        active: Option<bool>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        context: &C) -> Result<RegisterNotificationTokenResponse, ApiError>;

    /// Search on the user's blocked notification settings
    async fn search_blocked_notifications(
        &self,
        version: f64,
        app_key: String,
        account_id: Option<i64>,
        search_tags: Option<String>,
        events: Option<String>,
        conduits: Option<String>,
        custom_types: Option<String>,
        content_types: Option<String>,
        content_ids: Option<String>,
        sort_field: Option<String>,
        descending: Option<bool>,
        start: Option<i32>,
        limit: Option<i32>,
        context: &C) -> Result<SearchBlockedNotificationsResponse, ApiError>;

    /// Search Notification Templates
    async fn search_notification_template(
        &self,
        version: f64,
        account_id: i64,
        sort_field: String,
        descending: bool,
        start: i32,
        limit: i32,
        app_key: Option<String>,
        event: Option<String>,
        conduit: Option<String>,
        global_only: Option<bool>,
        reserved_only: Option<bool>,
        keyword: Option<String>,
        context: &C) -> Result<SearchNotificationTemplateResponse, ApiError>;

    /// Search for Recipients
    async fn search_recipients(
        &self,
        version: f64,
        sort_field: models::SearchRecipientsSortFieldParameter,
        device_id: Option<String>,
        account_id: Option<i64>,
        app_key: Option<String>,
        conduit: Option<String>,
        keyword: Option<String>,
        audience_id: Option<i64>,
        audience_ids: Option<String>,
        connection_group_ids: Option<String>,
        recipient_account_ids: Option<String>,
        descending: Option<bool>,
        start: Option<i32>,
        limit: Option<i32>,
        context: &C) -> Result<SearchRecipientsResponse, ApiError>;

    /// Search for Recipients (Counts/Grouped)
    async fn search_recipients_count(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        app_key: Option<String>,
        conduit: Option<String>,
        keyword: Option<String>,
        audience_id: Option<i64>,
        audience_ids: Option<String>,
        connection_group_ids: Option<String>,
        sort_field: Option<String>,
        descending: Option<bool>,
        start: Option<i32>,
        limit: Option<i32>,
        context: &C) -> Result<SearchRecipientsCountResponse, ApiError>;

    /// Send Batch Notifications
    async fn send_batch_notifications(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        custom_message: String,
        conduit: Option<String>,
        content_id: Option<i64>,
        content_name: Option<String>,
        content_type: Option<String>,
        parent_id: Option<i64>,
        parent_type: Option<String>,
        context: &C) -> Result<SendBatchNotificationsResponse, ApiError>;

    /// Send Custom Notifications
    async fn send_custom_notifications(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        receiver_account_ids: Option<String>,
        include_friend_group: Option<bool>,
        app_key: Option<String>,
        game_type: Option<String>,
        conduit: Option<String>,
        content_id: Option<i64>,
        content_name: Option<String>,
        content_type: Option<String>,
        parent_id: Option<i64>,
        parent_type: Option<String>,
        action_category: Option<String>,
        subject: Option<String>,
        custom_message: Option<String>,
        friend_only_apns: Option<bool>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        context: &C) -> Result<SendCustomNotificationsResponse, ApiError>;

    /// Update Notification Template
    async fn update_notification_template(
        &self,
        version: f64,
        account_id: i64,
        notification_template_id: i64,
        title: Option<String>,
        body: Option<String>,
        tags: Option<String>,
        context: &C) -> Result<UpdateNotificationTemplateResponse, ApiError>;

    /// Create Field
    async fn add_field(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        object_name: String,
        field_name: String,
        field_type: String,
        context: &C) -> Result<AddFieldResponse, ApiError>;

    /// Create Object
    async fn create_object(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        object_name: String,
        context: &C) -> Result<CreateObjectResponse, ApiError>;

    /// Delete Field
    async fn delete_field(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        object_name: String,
        field_name: String,
        context: &C) -> Result<DeleteFieldResponse, ApiError>;

    /// Delete Object
    async fn delete_object(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        object_name: String,
        context: &C) -> Result<DeleteObjectResponse, ApiError>;

    /// Get Object
    async fn get_object(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        object_name: String,
        context: &C) -> Result<GetObjectResponse, ApiError>;

    /// Search Objects
    async fn search_object(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        start: i64,
        limit: i64,
        keyword: Option<String>,
        context: &C) -> Result<SearchObjectResponse, ApiError>;

    /// Create Data
    async fn create_data(
        &self,
        version: f64,
        object_name: String,
        account_id: Option<i64>,
        body: Option<String>,
        context: &C) -> Result<CreateDataResponse, ApiError>;

    /// Search Data
    async fn search_data(
        &self,
        version: f64,
        object_name: String,
        count: bool,
        start: i64,
        limit: i64,
        account_id: Option<i64>,
        criteria: Option<String>,
        order: Option<String>,
        include: Option<String>,
        context: &C) -> Result<SearchDataResponse, ApiError>;

    /// Delete Data
    async fn delete_data(
        &self,
        version: f64,
        object_name: String,
        object_id: String,
        account_id: Option<i64>,
        context: &C) -> Result<DeleteDataResponse, ApiError>;

    /// Get Data
    async fn get_data(
        &self,
        version: f64,
        object_name: String,
        object_id: String,
        account_id: Option<i64>,
        include: Option<String>,
        context: &C) -> Result<GetDataResponse, ApiError>;

    /// Update Data
    async fn update_data(
        &self,
        version: f64,
        object_name: String,
        object_id: String,
        account_id: Option<i64>,
        body: Option<String>,
        context: &C) -> Result<UpdateDataResponse, ApiError>;

    /// Update Offer Locations
    async fn batch_update_offer_locations(
        &self,
        version: f64,
        data: String,
        device_id: Option<String>,
        account_id: Option<i64>,
        context: &C) -> Result<BatchUpdateOfferLocationsResponse, ApiError>;

    /// Create Offer
    async fn create_offer(
        &self,
        version: f64,
        include_offer_locations: bool,
        title: String,
        barcode_type: models::CreateMediaBarcodeTypeParameter,
        no_expiration: bool,
        available_limit: i32,
        available_limit_per_user: i32,
        added_limit: i32,
        view_limit: i32,
        max_prints: i32,
        ticket_price: i64,
        full_price: f64,
        discount_price: f64,
        offer_type: models::CreateOfferOfferTypeParameter,
        special_offer_type: models::CreateMediaSpecialOfferTypeParameter,
        offer_visibility: models::CreateMediaOfferVisibilityParameter,
        active: bool,
        device_id: Option<String>,
        account_id: Option<i64>,
        tags: Option<String>,
        parent_offer_id: Option<i64>,
        retailer_location_ids: Option<String>,
        offer_locations: Option<String>,
        sub_title: Option<String>,
        details: Option<String>,
        sub_details: Option<String>,
        fine_print: Option<String>,
        barcode_entry: Option<String>,
        external_redeem_options: Option<String>,
        external_url: Option<String>,
        external_id: Option<String>,
        tickets_reward_type: Option<String>,
        tickets_reward: Option<i64>,
        activated: Option<i64>,
        expires: Option<i64>,
        ticket_price_type: Option<String>,
        show_remaining: Option<bool>,
        show_redeemed: Option<bool>,
        replaced: Option<bool>,
        featured: Option<bool>,
        category_ids: Option<String>,
        filter_ids: Option<String>,
        barcode_asset_id: Option<i64>,
        image_asset_id: Option<i64>,
        image_asset_id1: Option<i64>,
        image_asset_id2: Option<i64>,
        image_asset_id3: Option<i64>,
        image_asset_id4: Option<i64>,
        image_asset_id5: Option<i64>,
        publisher: Option<String>,
        redeemable_start: Option<i64>,
        redeemable_end: Option<i64>,
        brand: Option<String>,
        product_type: Option<models::CreateOfferProductTypeParameter>,
        condition_type: Option<models::CreateMediaConditionTypeParameter>,
        isbn: Option<String>,
        asin: Option<String>,
        catalog_numbers: Option<String>,
        department: Option<String>,
        features: Option<String>,
        minimum_price: Option<f64>,
        width: Option<f64>,
        height: Option<f64>,
        depth: Option<f64>,
        weight: Option<f64>,
        unit: Option<models::CreateOfferUnitParameter>,
        studio: Option<String>,
        parental_rating: Option<String>,
        publish_date: Option<i64>,
        availability_date: Option<i64>,
        size_id: Option<i64>,
        listing_id: Option<i64>,
        media_type: Option<models::CreateMediaMediaTypeParameter>,
        duration: Option<i32>,
        author: Option<String>,
        release_date: Option<i64>,
        collection_ids: Option<String>,
        reboot_time_hour: Option<i32>,
        reboot_time_minute: Option<i32>,
        idle_timeout_in_second: Option<i32>,
        serial_number: Option<String>,
        udid: Option<String>,
        device_type: Option<String>,
        device_power: Option<f64>,
        device_interference: Option<f64>,
        availability: Option<String>,
        availability_summary: Option<String>,
        context: &C) -> Result<CreateOfferResponse, ApiError>;

    /// Delete Offer
    async fn delete_offer(
        &self,
        version: f64,
        offer_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        context: &C) -> Result<DeleteOfferResponse, ApiError>;

    /// Delete Offer Location
    async fn delete_offer_location(
        &self,
        version: f64,
        offer_location_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        context: &C) -> Result<DeleteOfferLocationResponse, ApiError>;

    /// Get Offer
    async fn get_offer(
        &self,
        version: f64,
        offer_id: i64,
        include_offer_locations: bool,
        device_id: Option<String>,
        account_id: Option<i64>,
        context: &C) -> Result<GetOfferResponse, ApiError>;

    /// Get Offer
    async fn get_offer_details(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        offer_id: Option<i64>,
        offer_location_id: Option<i64>,
        distance: Option<f64>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        include_offer_locations: Option<bool>,
        include_retailer_locations: Option<bool>,
        include_child_offers: Option<bool>,
        context: &C) -> Result<GetOfferDetailsResponse, ApiError>;

    /// Get Offers (Counts)
    async fn get_offer_list_counts(
        &self,
        version: f64,
        latitude: f64,
        longitude: f64,
        search_range: Option<f64>,
        distance_unit: Option<models::GetOfferListCountsDistanceUnitParameter>,
        context: &C) -> Result<GetOfferListCountsResponse, ApiError>;

    /// Get Offer Location
    async fn get_offer_location(
        &self,
        version: f64,
        offer_location_id: Option<i64>,
        udid: Option<String>,
        context: &C) -> Result<GetOfferLocationResponse, ApiError>;

    /// Search Offer Locations
    async fn get_offer_locations_for_retailers(
        &self,
        version: f64,
        sort_field: models::SearchOffersForConsumerGroupByParameter,
        descending: bool,
        start: i32,
        limit: i32,
        active_only: bool,
        include_retailer_location: bool,
        device_id: Option<String>,
        account_id: Option<i64>,
        keyword: Option<String>,
        retailer_id: Option<i64>,
        retailer_location_id: Option<i64>,
        offer_type: Option<models::CreateOfferOfferTypeParameter>,
        special_offer_type: Option<models::CreateMediaSpecialOfferTypeParameter>,
        barcode_type: Option<String>,
        barcode_entry: Option<String>,
        isbn: Option<String>,
        asin: Option<String>,
        device_status: Option<models::GetOfferLocationsForRetailersDeviceStatusParameter>,
        needs_notification_sent: Option<bool>,
        last_notification_sent: Option<i64>,
        context: &C) -> Result<GetOfferLocationsForRetailersResponse, ApiError>;

    /// Search Offers
    async fn get_offers_for_retailers(
        &self,
        version: f64,
        offer_visibility: models::CreateMediaOfferVisibilityParameter,
        sort_field: models::SearchEventsSortFieldParameter,
        descending: bool,
        start: i32,
        limit: i32,
        available_only: bool,
        active_only: bool,
        include_categories: bool,
        include_filters: bool,
        include_offer_locations: bool,
        device_id: Option<String>,
        account_id: Option<i64>,
        category_ids: Option<String>,
        filter_ids: Option<String>,
        q: Option<String>,
        keyword: Option<String>,
        retailer_id: Option<i64>,
        retailer_location_id: Option<i64>,
        coupon_type: Option<models::CreateOfferOfferTypeParameter>,
        offer_type: Option<models::CreateOfferOfferTypeParameter>,
        offer_types: Option<String>,
        special_offer_type: Option<models::CreateMediaSpecialOfferTypeParameter>,
        _i: Option<i32>,
        _l: Option<i32>,
        barcode_type: Option<String>,
        barcode_entry: Option<String>,
        isbn: Option<String>,
        asin: Option<String>,
        device_status: Option<models::GetOfferLocationsForRetailersDeviceStatusParameter>,
        needs_notification_sent: Option<bool>,
        last_notification_sent: Option<i64>,
        context: &C) -> Result<GetOffersForRetailersResponse, ApiError>;

    /// Update Offer Transaction
    async fn redeem_offer_transaction(
        &self,
        version: f64,
        offer_transaction_id: i64,
        status: i32,
        device_id: Option<String>,
        account_id: Option<i64>,
        offer_location_id: Option<i64>,
        context: &C) -> Result<RedeemOfferTransactionResponse, ApiError>;

    /// Search Offer Transactions
    async fn search_offer_transactions_for_retailers(
        &self,
        version: f64,
        sort_field: models::SearchEventTransactionsSortFieldParameter,
        descending: bool,
        start: i32,
        limit: i32,
        active_only: bool,
        device_id: Option<String>,
        account_id: Option<i64>,
        q: Option<String>,
        keyword: Option<String>,
        retailer_id: Option<i64>,
        retailer_location_id: Option<i64>,
        offer_id: Option<i64>,
        offer_location_id: Option<i64>,
        redeemed: Option<bool>,
        reservations_only: Option<bool>,
        coupon_type: Option<models::CreateOfferOfferTypeParameter>,
        offer_type: Option<models::CreateOfferOfferTypeParameter>,
        special_offer_type: Option<models::CreateMediaSpecialOfferTypeParameter>,
        customer_account_ids: Option<String>,
        category_ids: Option<String>,
        redeemable_start_date: Option<i64>,
        redeemable_end_date: Option<i64>,
        _i: Option<i32>,
        _l: Option<i32>,
        context: &C) -> Result<SearchOfferTransactionsForRetailersResponse, ApiError>;

    /// Search Offers
    async fn search_offers_for_consumer(
        &self,
        version: f64,
        latitude: f64,
        longitude: f64,
        recommendation_type: models::SearchOffersForConsumerRecommendationTypeParameter,
        location_id: i64,
        start: i32,
        limit: i32,
        max_recommendations: i32,
        distance_unit: models::SearchOffersForConsumerDistanceUnitParameter,
        app_key: Option<String>,
        device_id: Option<String>,
        account_id: Option<i64>,
        search_range: Option<f64>,
        tags: Option<String>,
        supported_postal_codes: Option<String>,
        keyword: Option<String>,
        categories: Option<String>,
        filters: Option<String>,
        offer_types: Option<String>,
        param_type: Option<String>,
        sort_field: Option<String>,
        recommend_offer_ids: Option<String>,
        retailer_location_ids: Option<String>,
        offer_id: Option<i64>,
        include_mission: Option<bool>,
        include_categories: Option<bool>,
        include_filters: Option<bool>,
        include_expired: Option<bool>,
        include_favorite: Option<bool>,
        closest_offer_only: Option<bool>,
        search_expression: Option<String>,
        group_by: Option<models::SearchOffersForConsumerGroupByParameter>,
        context: &C) -> Result<SearchOffersForConsumerResponse, ApiError>;

    /// Get Offers (Top)
    async fn top_offer_transactions(
        &self,
        version: f64,
        start: Option<i32>,
        limit: Option<i32>,
        context: &C) -> Result<TopOfferTransactionsResponse, ApiError>;

    /// Update Offer
    async fn update_offer(
        &self,
        version: f64,
        offer_id: i64,
        include_offer_locations: bool,
        device_id: Option<String>,
        account_id: Option<i64>,
        parent_offer_id: Option<i64>,
        retailer_location_ids: Option<String>,
        offer_locations: Option<String>,
        tags: Option<String>,
        title: Option<String>,
        sub_title: Option<String>,
        details: Option<String>,
        sub_details: Option<String>,
        fine_print: Option<String>,
        barcode_type: Option<models::CreateMediaBarcodeTypeParameter>,
        barcode_entry: Option<String>,
        external_redeem_options: Option<String>,
        external_url: Option<String>,
        external_id: Option<String>,
        tickets_reward_type: Option<String>,
        tickets_reward: Option<i64>,
        activated: Option<i64>,
        expires: Option<i64>,
        no_expiration: Option<bool>,
        available_limit: Option<i32>,
        available_limit_per_user: Option<i32>,
        added_limit: Option<i32>,
        view_limit: Option<i32>,
        max_prints: Option<i32>,
        ticket_price_type: Option<String>,
        ticket_price: Option<i64>,
        full_price: Option<f64>,
        discount_price: Option<f64>,
        show_remaining: Option<bool>,
        show_redeemed: Option<bool>,
        replaced: Option<bool>,
        featured: Option<bool>,
        offer_type: Option<models::CreateOfferOfferTypeParameter>,
        special_offer_type: Option<models::CreateMediaSpecialOfferTypeParameter>,
        offer_visibility: Option<models::CreateMediaOfferVisibilityParameter>,
        category_ids: Option<String>,
        filter_ids: Option<String>,
        active: Option<bool>,
        barcode_asset_id: Option<i64>,
        image_asset_id: Option<i64>,
        image_asset_id1: Option<i64>,
        image_asset_id2: Option<i64>,
        image_asset_id3: Option<i64>,
        image_asset_id4: Option<i64>,
        image_asset_id5: Option<i64>,
        publisher: Option<String>,
        redeemable_start: Option<i64>,
        redeemable_end: Option<i64>,
        brand: Option<String>,
        product_type: Option<models::CreateOfferProductTypeParameter>,
        condition_type: Option<models::CreateMediaConditionTypeParameter>,
        isbn: Option<String>,
        asin: Option<String>,
        catalog_numbers: Option<String>,
        department: Option<String>,
        features: Option<String>,
        minimum_price: Option<f64>,
        width: Option<f64>,
        height: Option<f64>,
        depth: Option<f64>,
        weight: Option<f64>,
        unit: Option<models::CreateOfferUnitParameter>,
        studio: Option<String>,
        parental_rating: Option<String>,
        publish_date: Option<i64>,
        availability_date: Option<i64>,
        size_id: Option<i64>,
        listing_id: Option<i64>,
        media_type: Option<models::CreateMediaMediaTypeParameter>,
        duration: Option<i32>,
        author: Option<String>,
        release_date: Option<i64>,
        collection_ids: Option<String>,
        reboot_time_hour: Option<i32>,
        reboot_time_minute: Option<i32>,
        idle_timeout_in_second: Option<i32>,
        serial_number: Option<String>,
        udid: Option<String>,
        device_type: Option<String>,
        device_power: Option<f64>,
        device_interference: Option<f64>,
        availability: Option<String>,
        availability_summary: Option<String>,
        context: &C) -> Result<UpdateOfferResponse, ApiError>;

    /// Activate Offer
    async fn update_offer_status(
        &self,
        version: f64,
        offer_ids: String,
        active: bool,
        device_id: Option<String>,
        account_id: Option<i64>,
        context: &C) -> Result<UpdateOfferStatusResponse, ApiError>;

    /// Create Offer Status
    async fn create_offer_transaction_status(
        &self,
        version: f64,
        name: String,
        code: i32,
        device_id: Option<String>,
        account_id: Option<i64>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        description: Option<String>,
        role: Option<String>,
        active: Option<bool>,
        application_ids: Option<String>,
        context: &C) -> Result<CreateOfferTransactionStatusResponse, ApiError>;

    /// Delete Offer Status
    async fn delete_offer_transaction_status(
        &self,
        version: f64,
        status_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        context: &C) -> Result<DeleteOfferTransactionStatusResponse, ApiError>;

    /// Get Offer Status
    async fn get_offer_transaction_status(
        &self,
        version: f64,
        status_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        context: &C) -> Result<GetOfferTransactionStatusResponse, ApiError>;

    /// Search Offer Status
    async fn search_offer_transaction_statuses(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        keyword: Option<String>,
        role: Option<String>,
        app_key: Option<String>,
        sort_field: Option<models::SearchOfferTransactionStatusesSortFieldParameter>,
        descending: Option<bool>,
        start: Option<i32>,
        limit: Option<i32>,
        include_inactive: Option<bool>,
        context: &C) -> Result<SearchOfferTransactionStatusesResponse, ApiError>;

    /// Update Offer Status
    async fn update_offer_transaction_status(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        status_id: Option<i64>,
        name: Option<String>,
        description: Option<String>,
        code: Option<i32>,
        role: Option<String>,
        active: Option<bool>,
        application_ids: Option<String>,
        context: &C) -> Result<UpdateOfferTransactionStatusResponse, ApiError>;

    /// Generate images with OpenAI
    async fn image_generation(
        &self,
        version: f64,
        account_id: i64,
        post_body: String,
        return_raw_response: Option<bool>,
        context: &C) -> Result<ImageGenerationResponse, ApiError>;

    /// Request Optimization
    async fn request_optimization(
        &self,
        version: f64,
        body: Option<models::Orders>,
        context: &C) -> Result<RequestOptimizationResponse, ApiError>;

    /// Get Optimization Result
    async fn get_optimization_result(
        &self,
        version: f64,
        batch_id: String,
        start: i32,
        limit: i32,
        context: &C) -> Result<GetOptimizationResultResponse, ApiError>;

    /// Add Movie
    async fn add_movie(
        &self,
        version: f64,
        account_id: i64,
        movie_name: String,
        third_party_account_id: Option<String>,
        tags: Option<String>,
        file: Option<swagger::ByteArray>,
        url: Option<String>,
        callback: Option<String>,
        context: &C) -> Result<AddMovieResponse, ApiError>;

    /// Search Docs
    async fn ai_docs(
        &self,
        version: f64,
        account_id: i64,
        doc: String,
        return_topics: Option<bool>,
        limit: Option<i32>,
        offset: Option<i32>,
        context: &C) -> Result<AiDocsResponse, ApiError>;

    /// Find images
    async fn ai_find_images(
        &self,
        version: f64,
        account_id: i64,
        text: String,
        parse_flag: Option<String>,
        fetch_flag: Option<String>,
        size: Option<String>,
        context: &C) -> Result<AiFindImagesResponse, ApiError>;

    /// Search Tags
    async fn ai_tags(
        &self,
        version: f64,
        account_id: i64,
        tags: String,
        conditional: Option<String>,
        limit: Option<i32>,
        offset: Option<i32>,
        context: &C) -> Result<AiTagsResponse, ApiError>;

    /// Search Text
    async fn ai_text(
        &self,
        version: f64,
        account_id: i64,
        terms: String,
        conditional: Option<String>,
        limit: Option<i32>,
        offset: Option<i32>,
        context: &C) -> Result<AiTextResponse, ApiError>;

    /// Batch Analysis
    async fn batch(
        &self,
        version: f64,
        account_id: i64,
        third_party_account_id: Option<String>,
        limit: Option<i32>,
        operations: Option<String>,
        file: Option<swagger::ByteArray>,
        url: Option<String>,
        callback: Option<String>,
        context: &C) -> Result<BatchResponse, ApiError>;

    /// Creates an instant episode
    async fn create_instant_episode(
        &self,
        version: f64,
        account_id: i64,
        data: String,
        context: &C) -> Result<CreateInstantEpisodeResponse, ApiError>;

    /// Create VoiceCanvas images
    async fn create_voice_canvas(
        &self,
        version: f64,
        account_id: i64,
        dimensions: String,
        third_party_account_id: Option<String>,
        text: Option<String>,
        file: Option<swagger::ByteArray>,
        url: Option<String>,
        parse_flag: Option<bool>,
        fetch_flag: Option<bool>,
        callback: Option<String>,
        context: &C) -> Result<CreateVoiceCanvasResponse, ApiError>;

    /// Detect emotions
    async fn emotion(
        &self,
        version: f64,
        account_id: i64,
        third_party_account_id: Option<String>,
        file: Option<swagger::ByteArray>,
        url: Option<String>,
        callback: Option<String>,
        context: &C) -> Result<EmotionResponse, ApiError>;

    /// Starts a StoryStitch video render
    async fn start_video_render(
        &self,
        version: f64,
        account_id: i64,
        data: String,
        context: &C) -> Result<StartVideoRenderResponse, ApiError>;

    /// Speach to Text
    async fn stt(
        &self,
        version: f64,
        account_id: i64,
        third_party_account_id: Option<String>,
        source_language: Option<String>,
        target_language: Option<String>,
        file: Option<swagger::ByteArray>,
        url: Option<String>,
        callback: Option<String>,
        context: &C) -> Result<SttResponse, ApiError>;

    /// Summarize Topics
    async fn summarize_topics(
        &self,
        version: f64,
        account_id: i64,
        third_party_account_id: Option<String>,
        doc: Option<String>,
        file: Option<swagger::ByteArray>,
        url: Option<String>,
        limit: Option<i32>,
        offset: Option<i32>,
        callback: Option<String>,
        context: &C) -> Result<SummarizeTopicsResponse, ApiError>;

    /// Detect Technical Issues
    async fn tech_tune(
        &self,
        version: f64,
        account_id: i64,
        num_faces_expected: i32,
        third_party_account_id: Option<String>,
        file: Option<swagger::ByteArray>,
        url: Option<String>,
        callback: Option<String>,
        context: &C) -> Result<TechTuneResponse, ApiError>;

    /// Text to Speach
    async fn tts(
        &self,
        version: f64,
        account_id: i64,
        text: String,
        third_party_account_id: Option<String>,
        language: Option<String>,
        voice: Option<String>,
        callback: Option<String>,
        context: &C) -> Result<TtsResponse, ApiError>;

    /// Get Add Movie Result
    async fn get_add_movie_result(
        &self,
        version: f64,
        request_id: String,
        account_id: i64,
        context: &C) -> Result<GetAddMovieResultResponse, ApiError>;

    /// Get Batch Analysis Results
    async fn get_batch(
        &self,
        version: f64,
        request_id: String,
        account_id: i64,
        context: &C) -> Result<GetBatchResponse, ApiError>;

    /// Get Emotion Results
    async fn get_emotion(
        &self,
        version: f64,
        request_id: String,
        account_id: i64,
        context: &C) -> Result<GetEmotionResponse, ApiError>;

    /// Check episode status
    async fn get_episode_status(
        &self,
        version: f64,
        episode_id: i64,
        account_id: i64,
        context: &C) -> Result<GetEpisodeStatusResponse, ApiError>;

    /// Check episode status
    async fn get_render_status(
        &self,
        version: f64,
        render_id: String,
        account_id: i64,
        context: &C) -> Result<GetRenderStatusResponse, ApiError>;

    /// Get Speach to Text Result
    async fn get_stt(
        &self,
        version: f64,
        request_id: String,
        account_id: i64,
        context: &C) -> Result<GetSttResponse, ApiError>;

    /// Get TechTune Results
    async fn get_tech_tune(
        &self,
        version: f64,
        request_id: String,
        account_id: i64,
        context: &C) -> Result<GetTechTuneResponse, ApiError>;

    /// Get Topics
    async fn get_topics(
        &self,
        version: f64,
        request_id: String,
        account_id: i64,
        context: &C) -> Result<GetTopicsResponse, ApiError>;

    /// Get Text to Speach Result
    async fn get_tts(
        &self,
        version: f64,
        request_id: String,
        account_id: i64,
        context: &C) -> Result<GetTtsResponse, ApiError>;

    /// Get VoiceCanvas images
    async fn get_voice_canvas(
        &self,
        version: f64,
        request_id: String,
        account_id: i64,
        context: &C) -> Result<GetVoiceCanvasResponse, ApiError>;

    /// Create Pack
    async fn create_pack(
        &self,
        version: f64,
        account_id: i64,
        title: String,
        pack_order: i64,
        price: i32,
        highest: bool,
        allocate_tickets: bool,
        ticket_count: i64,
        description: Option<String>,
        search_tags: Option<String>,
        active: Option<bool>,
        game_type: Option<String>,
        app_key: Option<String>,
        pack_type: Option<models::CreatePackPackTypeParameter>,
        sequence_type: Option<models::CreatePackSequenceTypeParameter>,
        background_id: Option<i64>,
        image_id: Option<i64>,
        start_date: Option<i64>,
        end_date: Option<i64>,
        author_override: Option<String>,
        price_type: Option<String>,
        game_level_ids: Option<String>,
        in_game: Option<bool>,
        ticket_type: Option<String>,
        points: Option<i64>,
        context: &C) -> Result<CreatePackResponse, ApiError>;

    /// Delete Pack
    async fn delete_pack(
        &self,
        version: f64,
        account_id: i64,
        pack_id: i64,
        context: &C) -> Result<DeletePackResponse, ApiError>;

    /// Get Pack
    async fn get_pack(
        &self,
        version: f64,
        account_id: i64,
        pack_id: i64,
        include_game_data: bool,
        context: &C) -> Result<GetPackResponse, ApiError>;

    /// Search Packs
    async fn search_packs(
        &self,
        version: f64,
        account_id: i64,
        sort_field: models::SearchPacksSortFieldParameter,
        descending: bool,
        keyword: Option<String>,
        pack_type: Option<models::CreatePackPackTypeParameter>,
        start: Option<i32>,
        limit: Option<i32>,
        include_game_data: Option<bool>,
        include_inactive: Option<bool>,
        app_key: Option<String>,
        context: &C) -> Result<SearchPacksResponse, ApiError>;

    /// Update Pack
    async fn update_pack(
        &self,
        version: f64,
        account_id: i64,
        pack_id: i64,
        allocate_tickets: bool,
        ticket_count: i64,
        title: Option<String>,
        description: Option<String>,
        search_tags: Option<String>,
        active: Option<bool>,
        game_type: Option<String>,
        app_key: Option<String>,
        pack_type: Option<models::CreatePackPackTypeParameter>,
        pack_order: Option<i64>,
        sequence_type: Option<models::CreatePackSequenceTypeParameter>,
        background_id: Option<i64>,
        image_id: Option<i64>,
        start_date: Option<i64>,
        end_date: Option<i64>,
        author_override: Option<String>,
        price: Option<i32>,
        price_type: Option<String>,
        game_level_ids: Option<String>,
        in_game: Option<bool>,
        highest: Option<bool>,
        ticket_type: Option<String>,
        points: Option<i64>,
        context: &C) -> Result<UpdatePackResponse, ApiError>;

    /// Process All Participant Feeds
    async fn process_all_participants(
        &self,
        version: f64,
        account_id: i64,
        app_key: Option<String>,
        use_short_name_as_id: Option<bool>,
        context: &C) -> Result<ProcessAllParticipantsResponse, ApiError>;

    /// Process Participants Feed
    async fn process_participants(
        &self,
        version: f64,
        account_id: i64,
        league: String,
        app_key: Option<String>,
        use_short_name_as_id: Option<bool>,
        file: Option<swagger::ByteArray>,
        context: &C) -> Result<ProcessParticipantsResponse, ApiError>;

    /// Calculate Path
    async fn compute_path(
        &self,
        version: f64,
        data: String,
        units: models::ComputePathUnitsParameter,
        reduce_path: bool,
        directions: bool,
        context: &C) -> Result<ComputePathResponse, ApiError>;

    /// Create Postal Code
    async fn create_postal_code(
        &self,
        version: f64,
        account_id: i64,
        code: String,
        latitude: f64,
        longitude: f64,
        state_code: Option<String>,
        city: Option<String>,
        active: Option<bool>,
        context: &C) -> Result<CreatePostalCodeResponse, ApiError>;

    /// Delete Postal Code
    async fn delete_postal_code(
        &self,
        version: f64,
        account_id: i64,
        postal_code_id: i64,
        context: &C) -> Result<DeletePostalCodeResponse, ApiError>;

    /// Get Postal Code
    async fn get_postal_code(
        &self,
        version: f64,
        postal_code_id: i64,
        context: &C) -> Result<GetPostalCodeResponse, ApiError>;

    /// Search Postal Codes
    async fn get_postal_codes(
        &self,
        version: f64,
        sort_field: String,
        descending: bool,
        latitude: Option<f64>,
        longitude: Option<f64>,
        keyword: Option<String>,
        miles: Option<f64>,
        start: Option<i32>,
        limit: Option<i32>,
        context: &C) -> Result<GetPostalCodesResponse, ApiError>;

    /// Update Postal Code
    async fn update_postal_code(
        &self,
        version: f64,
        account_id: i64,
        postal_code_id: i64,
        code: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        state_code: Option<String>,
        city: Option<String>,
        active: Option<bool>,
        context: &C) -> Result<UpdatePostalCodeResponse, ApiError>;

    /// Create Persona
    async fn create_persona(
        &self,
        version: f64,
        account_id: i64,
        title: String,
        preview_accounts: Option<String>,
        date: Option<i64>,
        age: Option<i32>,
        gender: Option<String>,
        game_experience_level: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        context: &C) -> Result<CreatePersonaResponse, ApiError>;

    /// Delete Persona
    async fn delete_persona(
        &self,
        version: f64,
        account_id: i64,
        persona_id: i64,
        context: &C) -> Result<DeletePersonaResponse, ApiError>;

    /// Get Persona
    async fn get_persona_list(
        &self,
        version: f64,
        account_id: i64,
        persona_id: i64,
        context: &C) -> Result<GetPersonaListResponse, ApiError>;

    /// Search Personas
    async fn search_persona(
        &self,
        version: f64,
        account_id: i64,
        start: i32,
        limit: i32,
        context: &C) -> Result<SearchPersonaResponse, ApiError>;

    /// Update Persona
    async fn update_persona(
        &self,
        version: f64,
        account_id: i64,
        persona_id: i64,
        title: Option<String>,
        preview_accounts: Option<String>,
        active: Option<bool>,
        date: Option<i64>,
        age: Option<i32>,
        gender: Option<String>,
        game_experience_level: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        context: &C) -> Result<UpdatePersonaResponse, ApiError>;

    /// Create Program
    async fn create_program(
        &self,
        version: f64,
        body: Option<models::Program>,
        context: &C) -> Result<CreateProgramResponse, ApiError>;

    /// Search Programs
    async fn search_programs(
        &self,
        version: f64,
        sort_field: String,
        descending: bool,
        start: i32,
        limit: i32,
        active_only: bool,
        keyword: Option<String>,
        context: &C) -> Result<SearchProgramsResponse, ApiError>;

    /// Delete Program
    async fn delete_program(
        &self,
        version: f64,
        id: i64,
        context: &C) -> Result<DeleteProgramResponse, ApiError>;

    /// Get Program
    async fn get_program(
        &self,
        version: f64,
        id: i64,
        context: &C) -> Result<GetProgramResponse, ApiError>;

    /// Update Program
    async fn post_program(
        &self,
        version: f64,
        id: i64,
        body: Option<models::Program>,
        context: &C) -> Result<PostProgramResponse, ApiError>;

    /// Update Program
    async fn put_program(
        &self,
        version: f64,
        id: i64,
        body: Option<models::Program>,
        context: &C) -> Result<PutProgramResponse, ApiError>;

    /// Create Purchase
    async fn create_purchase_item(
        &self,
        version: f64,
        app_key: String,
        name: String,
        purchase_type: models::CreatePurchaseItemPurchaseTypeParameter,
        device_id: Option<String>,
        account_id: Option<i64>,
        description: Option<String>,
        tickets: Option<i32>,
        price: Option<f32>,
        purchase_code: Option<String>,
        secret_key: Option<String>,
        purchase_limit: Option<i32>,
        service_action: Option<models::CreatePurchaseItemServiceActionParameter>,
        cover_asset_id: Option<i64>,
        promo_asset_id: Option<i64>,
        giftable: Option<bool>,
        assetable: Option<bool>,
        allocate_tickets: Option<bool>,
        ticket_type: Option<String>,
        points: Option<i64>,
        offer_location_id: Option<i64>,
        context: &C) -> Result<CreatePurchaseItemResponse, ApiError>;

    /// Delete Purchase
    async fn delete_purchase_item(
        &self,
        version: f64,
        purchase_item_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        context: &C) -> Result<DeletePurchaseItemResponse, ApiError>;

    /// Get Purchase
    async fn get_purchase_item(
        &self,
        version: f64,
        purchase_item_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        context: &C) -> Result<GetPurchaseItemResponse, ApiError>;

    /// Search Purchases
    async fn search_purchase_items(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        app_key: Option<String>,
        filter_by_billable: Option<bool>,
        purchase_type: Option<String>,
        service_action: Option<String>,
        keyword: Option<String>,
        sort_field: Option<models::SearchPurchaseItemsSortFieldParameter>,
        descending: Option<bool>,
        start: Option<i32>,
        limit: Option<i32>,
        active_only: Option<bool>,
        context: &C) -> Result<SearchPurchaseItemsResponse, ApiError>;

    /// Update Purchase
    async fn update_purchase_item(
        &self,
        version: f64,
        purchase_item_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        name: Option<String>,
        description: Option<String>,
        tickets: Option<i32>,
        price: Option<f32>,
        purchase_type: Option<models::CreatePurchaseItemPurchaseTypeParameter>,
        purchase_code: Option<String>,
        secret_key: Option<String>,
        purchase_limit: Option<i32>,
        service_action: Option<models::CreatePurchaseItemServiceActionParameter>,
        cover_asset_id: Option<i64>,
        promo_asset_id: Option<i64>,
        giftable: Option<bool>,
        assetable: Option<bool>,
        active: Option<bool>,
        allocate_tickets: Option<bool>,
        ticket_type: Option<String>,
        points: Option<i64>,
        offer_location_id: Option<i64>,
        context: &C) -> Result<UpdatePurchaseItemResponse, ApiError>;

    /// Create Order
    async fn create_order(
        &self,
        version: f64,
        app_key: String,
        cart: String,
        device_id: Option<String>,
        account_id: Option<i64>,
        description: Option<String>,
        currency_type: Option<models::CreateOrderCurrencyTypeParameter>,
        payment_method_id: Option<i64>,
        external_order_id: Option<String>,
        external_payment_id: Option<String>,
        remote_ref_type: Option<String>,
        external_date: Option<i64>,
        promo_code: Option<String>,
        context: &C) -> Result<CreateOrderResponse, ApiError>;

    /// Delete Order
    async fn delete_order(
        &self,
        version: f64,
        order_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        context: &C) -> Result<DeleteOrderResponse, ApiError>;

    /// Get Order
    async fn get_order(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        order_id: Option<i64>,
        external_order_id: Option<String>,
        context: &C) -> Result<GetOrderResponse, ApiError>;

    /// Preview Order
    async fn preview_order(
        &self,
        version: f64,
        app_key: String,
        cart: String,
        device_id: Option<String>,
        account_id: Option<i64>,
        description: Option<String>,
        currency_type: Option<models::CreateOrderCurrencyTypeParameter>,
        payment_method_id: Option<i64>,
        external_order_id: Option<String>,
        external_payment_id: Option<String>,
        remote_ref_type: Option<String>,
        external_date: Option<i64>,
        promo_code: Option<String>,
        context: &C) -> Result<PreviewOrderResponse, ApiError>;

    /// Search Orders
    async fn search_orders(
        &self,
        version: f64,
        app_key: String,
        device_id: Option<String>,
        account_id: Option<i64>,
        start: Option<i32>,
        limit: Option<i32>,
        descending: Option<bool>,
        active_only: Option<bool>,
        ignore_customer_filter: Option<bool>,
        order_item_types: Option<String>,
        order_item_ids: Option<String>,
        order_custom_types: Option<String>,
        order_custom_ids: Option<String>,
        sort_field: Option<String>,
        offer_types: Option<String>,
        special_offer_types: Option<String>,
        category_ids: Option<String>,
        filter_ids: Option<String>,
        offer_audience_ids: Option<String>,
        transaction_audience_ids: Option<String>,
        offer_ids: Option<String>,
        offer_location_ids: Option<String>,
        retailer_ids: Option<String>,
        retailer_location_ids: Option<String>,
        statuses: Option<String>,
        keyword: Option<String>,
        redeemable_start_date: Option<i64>,
        redeemable_end_date: Option<i64>,
        started_since: Option<i64>,
        started_before: Option<i64>,
        ended_since: Option<i64>,
        ended_before: Option<i64>,
        context: &C) -> Result<SearchOrdersResponse, ApiError>;

    /// Update Order
    async fn update_order(
        &self,
        version: f64,
        order_id: i64,
        app_key: String,
        cart: String,
        device_id: Option<String>,
        account_id: Option<i64>,
        payment_transaction_id: Option<i64>,
        description: Option<String>,
        currency_type: Option<models::CreateOrderCurrencyTypeParameter>,
        payment_method_id: Option<i64>,
        external_payment_id: Option<String>,
        external_date: Option<i64>,
        context: &C) -> Result<UpdateOrderResponse, ApiError>;

    /// Create Question
    async fn create_question(
        &self,
        version: f64,
        account_id: i64,
        question: String,
        answers: String,
        active: bool,
        allocate_tickets: bool,
        ticket_count: i64,
        tags: Option<String>,
        video_url: Option<String>,
        asset_id: Option<i64>,
        ticket_type: Option<String>,
        points: Option<i64>,
        context: &C) -> Result<CreateQuestionResponse, ApiError>;

    /// Delete Question
    async fn delete_question(
        &self,
        version: f64,
        question_id: i64,
        account_id: i64,
        context: &C) -> Result<DeleteQuestionResponse, ApiError>;

    /// Get Question
    async fn get_question(
        &self,
        version: f64,
        question_id: i64,
        account_id: i64,
        context: &C) -> Result<GetQuestionResponse, ApiError>;

    /// Search Questions
    async fn search_questions(
        &self,
        version: f64,
        account_id: i64,
        sort_field: String,
        descending: bool,
        active_only: bool,
        start: i32,
        limit: i32,
        keyword: Option<String>,
        context: &C) -> Result<SearchQuestionsResponse, ApiError>;

    /// Update Question
    async fn update_question(
        &self,
        version: f64,
        question_id: i64,
        account_id: i64,
        ticket_count: i64,
        question: Option<String>,
        answers: Option<String>,
        tags: Option<String>,
        video_url: Option<String>,
        asset_id: Option<i64>,
        active: Option<bool>,
        allocate_tickets: Option<bool>,
        ticket_type: Option<String>,
        points: Option<i64>,
        context: &C) -> Result<UpdateQuestionResponse, ApiError>;

    /// Search Historical Rankings
    async fn get_historical_rankings(
        &self,
        version: f64,
        app_key: String,
        rank_type: String,
        start_date: i64,
        end_date: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        sort_field: Option<String>,
        descending: Option<bool>,
        start: Option<i32>,
        limit: Option<i32>,
        context: &C) -> Result<GetHistoricalRankingsResponse, ApiError>;

    /// Search Rankings
    async fn get_rankings(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        game_type: Option<String>,
        app_key: Option<String>,
        q: Option<String>,
        keyword: Option<String>,
        rank_type: Option<String>,
        leaderboard_mode: Option<String>,
        within_account_ids: Option<String>,
        return_user_rank: Option<bool>,
        album_id: Option<i64>,
        audience_id: Option<i64>,
        sort_field: Option<String>,
        descending: Option<bool>,
        _i: Option<i32>,
        start: Option<i32>,
        _l: Option<i32>,
        limit: Option<i32>,
        context: &C) -> Result<GetRankingsResponse, ApiError>;

    /// Get Personal Rankings
    async fn get_user_rank(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        app_key: Option<String>,
        rank_type: Option<String>,
        return_user_rank: Option<bool>,
        leaderboard_mode: Option<String>,
        sort_field: Option<String>,
        keyword: Option<String>,
        descending: Option<bool>,
        start: Option<i32>,
        limit: Option<i32>,
        context: &C) -> Result<GetUserRankResponse, ApiError>;

    /// Override User Rank
    async fn override_user_rank(
        &self,
        version: f64,
        account_id: i64,
        owner_account_id: i64,
        app_key: String,
        rank_type: String,
        total_score: Option<i64>,
        total_count: Option<i64>,
        total_time: Option<i64>,
        daily_score: Option<i64>,
        daily_count: Option<i64>,
        daily_time: Option<i64>,
        weekly_score: Option<i64>,
        weekly_count: Option<i64>,
        weekly_time: Option<i64>,
        monthly_score: Option<i64>,
        monthly_count: Option<i64>,
        monthly_time: Option<i64>,
        top_score: Option<i64>,
        lowest_score: Option<i64>,
        streak_count: Option<i64>,
        streak_best_count: Option<i64>,
        start_date: Option<i64>,
        end_date: Option<i64>,
        context: &C) -> Result<OverrideUserRankResponse, ApiError>;

    /// Update Ranking
    async fn update_rankings(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        rank_type: String,
        increment: Option<i64>,
        time_increment: Option<i64>,
        tag: Option<String>,
        start_date: Option<i64>,
        end_date: Option<i64>,
        update_global: Option<bool>,
        create_leaderboard: Option<bool>,
        context: &C) -> Result<UpdateRankingsResponse, ApiError>;

    /// Create Rating
    async fn create_rating(
        &self,
        version: f64,
        ratable_type: String,
        ratable_id: i64,
        rating_value: i32,
        device_id: Option<String>,
        account_id: Option<i64>,
        category_id: Option<i64>,
        display: Option<String>,
        description: Option<String>,
        location_description: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        context: &C) -> Result<CreateRatingResponse, ApiError>;

    /// Delete Rating
    async fn delete_rating(
        &self,
        version: f64,
        rating_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        context: &C) -> Result<DeleteRatingResponse, ApiError>;

    /// Search Location Rating Indexes
    async fn search_location_rating_indexes(
        &self,
        version: f64,
        category_ids: Option<String>,
        keyword: Option<String>,
        location_type: Option<String>,
        sort_field: Option<models::SearchRatingIndexesSortFieldParameter>,
        descending: Option<bool>,
        start: Option<i32>,
        limit: Option<i32>,
        search_range: Option<f64>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        return_overall_rating: Option<bool>,
        distance_unit: Option<models::SearchOffersForConsumerDistanceUnitParameter>,
        return_retailer: Option<bool>,
        return_assets: Option<bool>,
        return_offers: Option<bool>,
        return_categories: Option<bool>,
        return_filters: Option<bool>,
        context: &C) -> Result<SearchLocationRatingIndexesResponse, ApiError>;

    /// Search Rating Indexes
    async fn search_rating_indexes(
        &self,
        version: f64,
        ratable_type: models::SearchRatingIndexesRatableTypeParameter,
        ratable_ids: Option<String>,
        category_ids: Option<String>,
        secondary_type: Option<String>,
        keyword: Option<String>,
        sort_field: Option<models::SearchRatingIndexesSortFieldParameter>,
        descending: Option<bool>,
        start: Option<i32>,
        limit: Option<i32>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        return_ratable: Option<bool>,
        return_overall_rating: Option<bool>,
        context: &C) -> Result<SearchRatingIndexesResponse, ApiError>;

    /// Search Ratings
    async fn search_ratings(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        filter_account_id: Option<i64>,
        ratable_type: Option<String>,
        ratable_id: Option<i64>,
        category_ids: Option<String>,
        keyword: Option<String>,
        sort_field: Option<models::SearchRatingsSortFieldParameter>,
        descending: Option<bool>,
        start: Option<i32>,
        limit: Option<i32>,
        context: &C) -> Result<SearchRatingsResponse, ApiError>;

    /// Update Rating
    async fn update_rating(
        &self,
        version: f64,
        rating_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        rating_value: Option<i32>,
        category_id: Option<i64>,
        display: Option<String>,
        description: Option<String>,
        location_description: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        context: &C) -> Result<UpdateRatingResponse, ApiError>;

    /// Create Region
    async fn create_region(
        &self,
        version: f64,
        account_id: i64,
        region_class: String,
        short_name: String,
        full_name: Option<String>,
        parent_ids: Option<String>,
        children_ids: Option<String>,
        postal_code_ids: Option<String>,
        locations: Option<String>,
        retailer_location_id: Option<i64>,
        visibility: Option<models::AddAlbumCollectionVisibilityParameter>,
        category_ids: Option<String>,
        filter_ids: Option<String>,
        start: Option<i64>,
        end: Option<i64>,
        polygon: Option<String>,
        meta_data: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        version_code: Option<i32>,
        root: Option<bool>,
        active: Option<bool>,
        context: &C) -> Result<CreateRegionResponse, ApiError>;

    /// Delete Region
    async fn delete_region(
        &self,
        version: f64,
        account_id: i64,
        region_id: i64,
        context: &C) -> Result<DeleteRegionResponse, ApiError>;

    /// Get Region
    async fn get_region(
        &self,
        version: f64,
        region_id: i64,
        account_id: Option<i64>,
        context: &C) -> Result<GetRegionResponse, ApiError>;

    /// Search Regions
    async fn search_regions(
        &self,
        version: f64,
        account_id: Option<i64>,
        query: Option<String>,
        keyword: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        range: Option<f64>,
        region_class: Option<models::SearchRegionsRegionClassParameter>,
        visibility: Option<models::AddAlbumCollectionVisibilityParameter>,
        search_mode: Option<models::SearchRegionsSearchModeParameter>,
        sort_field: Option<models::SearchRegionsSortFieldParameter>,
        descending: Option<bool>,
        include_parent: Option<bool>,
        include_children: Option<bool>,
        include_postal_codes: Option<bool>,
        category_ids: Option<String>,
        filter_ids: Option<String>,
        version_code: Option<i32>,
        active_only: Option<bool>,
        show_deleted: Option<bool>,
        last_updated_since: Option<i64>,
        start: Option<i32>,
        limit: Option<i32>,
        context: &C) -> Result<SearchRegionsResponse, ApiError>;

    /// Update Region
    async fn update_region(
        &self,
        version: f64,
        account_id: i64,
        region_id: i64,
        region_class: Option<String>,
        short_name: Option<String>,
        full_name: Option<String>,
        parent_ids: Option<String>,
        children_ids: Option<String>,
        postal_code_ids: Option<String>,
        locations: Option<String>,
        retailer_location_id: Option<i64>,
        visibility: Option<models::AddAlbumCollectionVisibilityParameter>,
        category_ids: Option<String>,
        filter_ids: Option<String>,
        start: Option<i64>,
        end: Option<i64>,
        polygon: Option<String>,
        meta_data: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        version_code: Option<i32>,
        root: Option<bool>,
        active: Option<bool>,
        clear_lists: Option<bool>,
        context: &C) -> Result<UpdateRegionResponse, ApiError>;

    /// Create Offline Report
    async fn create_batch(
        &self,
        version: f64,
        account_id: i64,
        status: models::CreateBatchStatusParameter,
        preview_limit: i32,
        app_key: Option<String>,
        endpoint: Option<String>,
        parameters: Option<String>,
        name: Option<String>,
        start_date: Option<i64>,
        end_date: Option<i64>,
        description: Option<String>,
        page_url: Option<String>,
        context: &C) -> Result<CreateBatchResponse, ApiError>;

    /// Create Offline Report
    async fn create_region_leg_summary_batch<'a>(
        &self,
        version: f64,
        body: Option<&'a Vec<models::RegionLegSummary>>,
        context: &C) -> Result<CreateRegionLegSummaryBatchResponse, ApiError>;

    /// Delete Offline Report
    async fn delete_batch(
        &self,
        version: f64,
        account_id: i64,
        batch_id: i64,
        context: &C) -> Result<DeleteBatchResponse, ApiError>;

    /// Get Offline Report
    async fn get_report_batch(
        &self,
        version: f64,
        account_id: i64,
        batch_id: i64,
        all_results: bool,
        context: &C) -> Result<GetReportBatchResponse, ApiError>;

    /// Run Report
    async fn run_report(
        &self,
        version: f64,
        desc: bool,
        account_id: Option<i64>,
        query: Option<String>,
        parameters: Option<String>,
        order: Option<String>,
        start: Option<i64>,
        limit: Option<i64>,
        response_format: Option<models::AggregatedFilteredUsageResponseFormatParameter>,
        context: &C) -> Result<RunReportResponse, ApiError>;

    /// Search Offline Reports
    async fn search_batch(
        &self,
        version: f64,
        account_id: i64,
        start: i32,
        limit: i32,
        names: Option<String>,
        app_key: Option<String>,
        status: Option<models::CreateBatchStatusParameter>,
        global_app_search: Option<bool>,
        start_date: Option<i64>,
        end_date: Option<i64>,
        context: &C) -> Result<SearchBatchResponse, ApiError>;

    /// Create Reservation
    async fn create_reservation(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        start_date: Option<i64>,
        end_date: Option<i64>,
        offer_id: Option<i64>,
        offer_location_id: Option<i64>,
        app_key: Option<String>,
        meta_data: Option<String>,
        context: &C) -> Result<CreateReservationResponse, ApiError>;

    /// Delete Reservation
    async fn delete_reservation(
        &self,
        version: f64,
        reservation_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        context: &C) -> Result<DeleteReservationResponse, ApiError>;

    /// Update Availability
    async fn reservable_availability(
        &self,
        version: f64,
        reservable_id: i64,
        reservable_type: models::SearchRatingIndexesRatableTypeParameter,
        device_id: Option<String>,
        account_id: Option<i64>,
        availability: Option<String>,
        availability_summary: Option<String>,
        context: &C) -> Result<ReservableAvailabilityResponse, ApiError>;

    /// Search Availability
    async fn search_availability(
        &self,
        version: f64,
        reservable_id: i64,
        reservable_type: models::SearchRatingIndexesRatableTypeParameter,
        device_id: Option<String>,
        account_id: Option<i64>,
        start_date: Option<i64>,
        end_date: Option<i64>,
        start: Option<i32>,
        limit: Option<i32>,
        context: &C) -> Result<SearchAvailabilityResponse, ApiError>;

    /// Search Reservations
    async fn search_reservations(
        &self,
        version: f64,
        device_id: Option<String>,
        app_key: Option<String>,
        account_id: Option<i64>,
        filter_account_id: Option<i64>,
        reservable_id: Option<i64>,
        reservable_type: Option<models::SearchRatingIndexesRatableTypeParameter>,
        keyword: Option<String>,
        start_date: Option<i64>,
        end_date: Option<i64>,
        start: Option<i32>,
        limit: Option<i32>,
        context: &C) -> Result<SearchReservationsResponse, ApiError>;

    /// Search Schedule
    async fn search_schedule(
        &self,
        version: f64,
        reservable_id: i64,
        reservable_type: models::SearchRatingIndexesRatableTypeParameter,
        start_date: i64,
        end_date: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        time_bucket_mins: Option<i32>,
        context: &C) -> Result<SearchScheduleResponse, ApiError>;

    /// Create Retailer
    async fn create_retailer(
        &self,
        version: f64,
        name: String,
        device_id: Option<String>,
        account_id: Option<i64>,
        street_address: Option<String>,
        street_address2: Option<String>,
        city: Option<String>,
        state: Option<String>,
        postal_code: Option<String>,
        country: Option<String>,
        business_phone: Option<String>,
        business_phone_ext: Option<String>,
        website: Option<String>,
        email: Option<String>,
        facebook_url: Option<String>,
        twitter_url: Option<String>,
        logo: Option<swagger::ByteArray>,
        logo_asset_id: Option<i64>,
        picture1: Option<swagger::ByteArray>,
        picture1_asset_id: Option<i64>,
        picture2: Option<swagger::ByteArray>,
        picture2_asset_id: Option<i64>,
        category_ids: Option<String>,
        category_ids_to_add: Option<String>,
        category_ids_to_remove: Option<String>,
        filter_ids: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        meta_data: Option<String>,
        search_tags: Option<String>,
        retailer_type: Option<String>,
        visibility: Option<models::AddAlbumCollectionVisibilityParameter>,
        create_default_location: Option<bool>,
        response_format: Option<models::AggregatedFilteredUsageResponseFormatParameter>,
        context: &C) -> Result<CreateRetailerResponse, ApiError>;

    /// Delete Retailer
    async fn delete_retailer(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        retailer_id: Option<i64>,
        context: &C) -> Result<DeleteRetailerResponse, ApiError>;

    /// Get Retailer
    async fn get_retailer(
        &self,
        version: f64,
        retailer_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        include_counts: Option<bool>,
        context: &C) -> Result<GetRetailerResponse, ApiError>;

    /// Search Retailers
    async fn get_retailers(
        &self,
        version: f64,
        visibility: models::AddAlbumCollectionVisibilityParameter,
        sort_field: models::GetRetailersSortFieldParameter,
        descending: bool,
        start: i32,
        limit: i32,
        active_only: bool,
        device_id: Option<String>,
        account_id: Option<i64>,
        q: Option<String>,
        keyword: Option<String>,
        category_ids: Option<String>,
        filter_ids: Option<String>,
        _i: Option<i32>,
        _l: Option<i32>,
        context: &C) -> Result<GetRetailersResponse, ApiError>;

    /// Login Retailer
    async fn retailer_login_check(
        &self,
        version: f64,
        username: String,
        password: String,
        device_id: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        app_key: Option<String>,
        context: &C) -> Result<RetailerLoginCheckResponse, ApiError>;

    /// Update Retailer
    async fn update_retailer(
        &self,
        version: f64,
        retailer_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        name: Option<String>,
        street_address: Option<String>,
        street_address2: Option<String>,
        city: Option<String>,
        state: Option<String>,
        postal_code: Option<String>,
        country: Option<String>,
        business_phone: Option<String>,
        business_phone_ext: Option<String>,
        website: Option<String>,
        email: Option<String>,
        facebook_url: Option<String>,
        twitter_url: Option<String>,
        logo: Option<swagger::ByteArray>,
        logo_asset_id: Option<i64>,
        picture1: Option<swagger::ByteArray>,
        picture1_asset_id: Option<i64>,
        picture2: Option<swagger::ByteArray>,
        picture2_asset_id: Option<i64>,
        category_ids: Option<String>,
        filter_ids: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        meta_data: Option<String>,
        search_tags: Option<String>,
        retailer_type: Option<String>,
        visibility: Option<models::AddAlbumCollectionVisibilityParameter>,
        active: Option<bool>,
        response_format: Option<models::AggregatedFilteredUsageResponseFormatParameter>,
        context: &C) -> Result<UpdateRetailerResponse, ApiError>;

    /// Create Retailer Location (Consumer)
    async fn create_retailer_location_consumer(
        &self,
        version: f64,
        app_key: String,
        name: String,
        device_id: Option<String>,
        account_id: Option<i64>,
        street_address: Option<String>,
        street_address2: Option<String>,
        city: Option<String>,
        state: Option<String>,
        postal_code: Option<String>,
        country: Option<String>,
        business_phone: Option<String>,
        business_phone_ext: Option<String>,
        website: Option<String>,
        email: Option<String>,
        details_header: Option<String>,
        details_body: Option<String>,
        hours: Option<String>,
        tags: Option<String>,
        logo_asset_id: Option<i64>,
        picture1_asset_id: Option<i64>,
        picture2_asset_id: Option<i64>,
        category_ids: Option<String>,
        filter_ids: Option<String>,
        meta_data: Option<String>,
        public_location: Option<bool>,
        active: Option<bool>,
        location_type: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        context: &C) -> Result<CreateRetailerLocationConsumerResponse, ApiError>;

    /// Create Retailer Location
    async fn create_retailer_locations(
        &self,
        version: f64,
        retailer_id: i64,
        name: String,
        street_address: String,
        city: String,
        state: String,
        postal_code: String,
        device_id: Option<String>,
        account_id: Option<i64>,
        street_address2: Option<String>,
        country: Option<String>,
        business_phone: Option<String>,
        business_phone_ext: Option<String>,
        website: Option<String>,
        email: Option<String>,
        internal_id: Option<String>,
        details_header: Option<String>,
        details_body: Option<String>,
        hours: Option<String>,
        logo: Option<swagger::ByteArray>,
        logo_asset_id: Option<i64>,
        picture1: Option<swagger::ByteArray>,
        picture1_asset_id: Option<i64>,
        picture2: Option<swagger::ByteArray>,
        picture2_asset_id: Option<i64>,
        category_ids: Option<String>,
        filter_ids: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        building: Option<String>,
        google_place_id: Option<String>,
        yelp_id: Option<String>,
        active: Option<bool>,
        public_location: Option<bool>,
        location_type: Option<String>,
        audience_ids: Option<String>,
        audience_ids_to_add: Option<String>,
        audience_ids_to_remove: Option<String>,
        response_format: Option<models::AggregatedFilteredUsageResponseFormatParameter>,
        response_includes: Option<String>,
        context: &C) -> Result<CreateRetailerLocationsResponse, ApiError>;

    /// Delete Retailer Location
    async fn delete_retailer_location(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        retailer_location_id: Option<i64>,
        context: &C) -> Result<DeleteRetailerLocationResponse, ApiError>;

    /// Get Retailer Location
    async fn get_retailer_location(
        &self,
        version: f64,
        retailer_location_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        retailer_location_token: Option<String>,
        context: &C) -> Result<GetRetailerLocationResponse, ApiError>;

    /// Get Retailer Location (Consumer)
    async fn get_retailer_location_consumer(
        &self,
        version: f64,
        retailer_location_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        context: &C) -> Result<GetRetailerLocationConsumerResponse, ApiError>;

    /// Distance Search Retailer Locations (Indexed)
    async fn indexed_retailer_location_distance_search(
        &self,
        version: f64,
        latitude: f64,
        longitude: f64,
        search_range: f64,
        start: i32,
        limit: i32,
        account_id: Option<i64>,
        address: Option<String>,
        has_offers: Option<bool>,
        categories: Option<String>,
        filters: Option<String>,
        audiences: Option<String>,
        retailer_ids: Option<String>,
        retailer_location_ids: Option<String>,
        tags: Option<String>,
        location_type: Option<String>,
        sort_field: Option<String>,
        descending: Option<bool>,
        q: Option<String>,
        keyword: Option<String>,
        keyword_operator: Option<String>,
        search_expression: Option<String>,
        distance_unit: Option<models::SearchOffersForConsumerDistanceUnitParameter>,
        return_favorited: Option<bool>,
        return_retailer: Option<bool>,
        return_assets: Option<bool>,
        return_offers: Option<bool>,
        return_categories: Option<bool>,
        return_filters: Option<bool>,
        return_audiences: Option<bool>,
        return_qr_code: Option<bool>,
        return_external_category_data: Option<bool>,
        include_favorite: Option<bool>,
        include_liked: Option<bool>,
        include_rating: Option<bool>,
        context: &C) -> Result<IndexedRetailerLocationDistanceSearchResponse, ApiError>;

    /// Keyword Search Retailer Locations (Indexed)
    async fn indexed_retailer_location_search(
        &self,
        version: f64,
        account_id: Option<i64>,
        start: Option<i32>,
        limit: Option<i32>,
        has_offers: Option<bool>,
        categories: Option<String>,
        filters: Option<String>,
        audiences: Option<String>,
        retailer_ids: Option<String>,
        retailer_location_ids: Option<String>,
        tags: Option<String>,
        location_type: Option<String>,
        sort_field: Option<String>,
        descending: Option<bool>,
        q: Option<String>,
        keyword: Option<String>,
        keyword_operator: Option<String>,
        search_expression: Option<String>,
        return_retailer: Option<bool>,
        return_assets: Option<bool>,
        return_offers: Option<bool>,
        return_categories: Option<bool>,
        return_filters: Option<bool>,
        return_audiences: Option<bool>,
        return_qr_code: Option<bool>,
        return_external_category_data: Option<bool>,
        include_favorite: Option<bool>,
        include_liked: Option<bool>,
        include_rating: Option<bool>,
        context: &C) -> Result<IndexedRetailerLocationSearchResponse, ApiError>;

    /// Search Retailer Locations (Owned)
    async fn search_retailer_locations(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        q: Option<String>,
        keyword: Option<String>,
        retailer_ids: Option<String>,
        retailer_location_ids: Option<String>,
        location_type: Option<String>,
        sort_field: Option<models::SearchRetailerLocationsSortFieldParameter>,
        descending: Option<bool>,
        _i: Option<i32>,
        start: Option<i32>,
        _l: Option<i32>,
        limit: Option<i32>,
        show_public_locations: Option<bool>,
        active_only: Option<bool>,
        return_retailer: Option<bool>,
        return_assets: Option<bool>,
        return_offers: Option<bool>,
        return_categories: Option<bool>,
        return_filters: Option<bool>,
        return_audiences: Option<bool>,
        return_qr_code: Option<bool>,
        include_favorite: Option<bool>,
        include_liked: Option<bool>,
        include_rating: Option<bool>,
        context: &C) -> Result<SearchRetailerLocationsResponse, ApiError>;

    /// Update Retailer Location
    async fn update_retailer_locations(
        &self,
        version: f64,
        retailer_location_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        name: Option<String>,
        street_address: Option<String>,
        street_address2: Option<String>,
        city: Option<String>,
        state: Option<String>,
        postal_code: Option<String>,
        country: Option<String>,
        business_phone: Option<String>,
        business_phone_ext: Option<String>,
        website: Option<String>,
        email: Option<String>,
        internal_id: Option<String>,
        details_header: Option<String>,
        details_body: Option<String>,
        hours: Option<String>,
        logo: Option<swagger::ByteArray>,
        logo_asset_id: Option<i64>,
        picture1: Option<swagger::ByteArray>,
        picture1_asset_id: Option<i64>,
        picture2: Option<swagger::ByteArray>,
        picture2_asset_id: Option<i64>,
        category_ids: Option<String>,
        filter_ids: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        building: Option<String>,
        google_place_id: Option<String>,
        yelp_id: Option<String>,
        meta_data: Option<String>,
        payment_provider: Option<String>,
        active: Option<bool>,
        public_location: Option<bool>,
        location_type: Option<String>,
        audience_ids: Option<String>,
        audience_ids_to_add: Option<String>,
        audience_ids_to_remove: Option<String>,
        response_format: Option<models::AggregatedFilteredUsageResponseFormatParameter>,
        tags: Option<String>,
        context: &C) -> Result<UpdateRetailerLocationsResponse, ApiError>;

    /// Get Retailer
    async fn get_retaokiler(
        &self,
        version: f64,
        retailer_id: i64,
        active_only: bool,
        keyword: Option<String>,
        sort_field: Option<String>,
        start: Option<i64>,
        limit: Option<i64>,
        context: &C) -> Result<GetRetaokilerResponse, ApiError>;

    /// Create Route
    async fn create_route(
        &self,
        version: f64,
        body: Option<models::Route>,
        context: &C) -> Result<CreateRouteResponse, ApiError>;

    /// Search Routes
    async fn search_routes(
        &self,
        version: f64,
        sort_field: String,
        descending: bool,
        start: i32,
        limit: i32,
        active_only: bool,
        includes_empty: bool,
        root_only: bool,
        show_inherited_properties: bool,
        hub_id: Option<i64>,
        program_id: Option<i64>,
        scheduled_start: Option<i64>,
        scheduled_end: Option<i64>,
        updated_start: Option<i64>,
        updated_end: Option<i64>,
        featured: Option<bool>,
        seat_count: Option<i32>,
        approved: Option<bool>,
        started: Option<bool>,
        completed: Option<bool>,
        valid: Option<bool>,
        parent_id: Option<i64>,
        context: &C) -> Result<SearchRoutesResponse, ApiError>;

    /// Approve Route
    async fn approve_route(
        &self,
        version: f64,
        route_id: i64,
        context: &C) -> Result<ApproveRouteResponse, ApiError>;

    /// Copy Route
    async fn copy_route(
        &self,
        version: f64,
        route_id: i64,
        body: Option<models::Route>,
        context: &C) -> Result<CopyRouteResponse, ApiError>;

    /// Update Route Directions
    async fn create_route_directions(
        &self,
        version: f64,
        route_id: i64,
        context: &C) -> Result<CreateRouteDirectionsResponse, ApiError>;

    /// Create Route Polyline
    async fn create_route_polyline(
        &self,
        version: f64,
        route_id: i64,
        context: &C) -> Result<CreateRoutePolylineResponse, ApiError>;

    /// Delete Route
    async fn delete_route(
        &self,
        version: f64,
        route_id: i64,
        context: &C) -> Result<DeleteRouteResponse, ApiError>;

    /// Disapprove Route
    async fn disapprove_route(
        &self,
        version: f64,
        route_id: i64,
        context: &C) -> Result<DisapproveRouteResponse, ApiError>;

    /// Get Route
    async fn get_route(
        &self,
        version: f64,
        route_id: i64,
        show_inherited_properties: bool,
        context: &C) -> Result<GetRouteResponse, ApiError>;

    /// Get Route Directions
    async fn get_route_directions(
        &self,
        version: f64,
        route_id: i64,
        context: &C) -> Result<GetRouteDirectionsResponse, ApiError>;

    /// Get Route Shipments
    async fn get_route_shipments(
        &self,
        version: f64,
        route_id: i64,
        context: &C) -> Result<GetRouteShipmentsResponse, ApiError>;

    /// Get Route Stops
    async fn get_route_stops(
        &self,
        version: f64,
        route_id: i64,
        confirmed_only: bool,
        context: &C) -> Result<GetRouteStopsResponse, ApiError>;

    /// Optimize Route
    async fn optimize_route(
        &self,
        version: f64,
        route_id: i64,
        context: &C) -> Result<OptimizeRouteResponse, ApiError>;

    /// Reorder Route Stops
    async fn reorder_route_stops_patch<'a>(
        &self,
        version: f64,
        route_id: i64,
        body: Option<&'a Vec<models::Stop>>,
        context: &C) -> Result<ReorderRouteStopsPatchResponse, ApiError>;

    /// Reorder Route Stops
    async fn reorder_route_stops_post<'a>(
        &self,
        version: f64,
        route_id: i64,
        body: Option<&'a Vec<models::Stop>>,
        context: &C) -> Result<ReorderRouteStopsPostResponse, ApiError>;

    /// Update Route
    async fn update_route(
        &self,
        version: f64,
        route_id: i64,
        body: Option<models::Route>,
        context: &C) -> Result<UpdateRouteResponse, ApiError>;

    /// Get Route Stop
    async fn get_route_stop(
        &self,
        version: f64,
        route_id: i64,
        stop_id: i64,
        context: &C) -> Result<GetRouteStopResponse, ApiError>;

    /// Get Shipments At Stop
    async fn get_shipments_at_stop(
        &self,
        version: f64,
        route_id: i64,
        stop_id: i64,
        context: &C) -> Result<GetShipmentsAtStopResponse, ApiError>;

    /// Delete Stop
    async fn remove_stop(
        &self,
        version: f64,
        route_id: i64,
        stop_id: i64,
        context: &C) -> Result<RemoveStopResponse, ApiError>;

    /// Set Driver
    async fn set_driver(
        &self,
        version: f64,
        id: i64,
        driver_id: i64,
        context: &C) -> Result<SetDriverResponse, ApiError>;

    /// Update Route Stop
    async fn update_route_stop(
        &self,
        version: f64,
        route_id: i64,
        stop_id: i64,
        body: Option<models::Stop>,
        context: &C) -> Result<UpdateRouteStopResponse, ApiError>;

    /// Create Route Setting
    async fn create_route_settings(
        &self,
        version: f64,
        body: Option<models::RouteSettings>,
        context: &C) -> Result<CreateRouteSettingsResponse, ApiError>;

    /// Search Route Settings
    async fn search_route_settings(
        &self,
        version: f64,
        sort_field: String,
        descending: bool,
        start: i32,
        limit: i32,
        active_only: bool,
        hub_id: Option<i64>,
        program_id: Option<i64>,
        keyword: Option<String>,
        context: &C) -> Result<SearchRouteSettingsResponse, ApiError>;

    /// Delete Route Setting
    async fn delete_route_settings(
        &self,
        version: f64,
        route_settings_id: i64,
        context: &C) -> Result<DeleteRouteSettingsResponse, ApiError>;

    /// Get Route Setting
    async fn get_route_settings(
        &self,
        version: f64,
        route_settings_id: i64,
        context: &C) -> Result<GetRouteSettingsResponse, ApiError>;

    /// Update Route Setting
    async fn update_route_settings(
        &self,
        version: f64,
        route_settings_id: i64,
        body: Option<models::RouteSettings>,
        context: &C) -> Result<UpdateRouteSettingsResponse, ApiError>;

    /// Compute Route
    async fn compute_routing(
        &self,
        version: f64,
        data: String,
        context: &C) -> Result<ComputeRoutingResponse, ApiError>;

    /// Create Scheduled Notification
    async fn create_scheduled_notification(
        &self,
        version: f64,
        account_id: i64,
        name: String,
        param_type: String,
        message: String,
        content_id: Option<i64>,
        content_name: Option<String>,
        content_type: Option<String>,
        parent_id: Option<i64>,
        parent_type: Option<String>,
        app_key: Option<String>,
        grouping_id: Option<String>,
        connection_group_ids: Option<String>,
        connection_account_ids: Option<String>,
        audience_id: Option<i64>,
        audience_ids: Option<String>,
        album_ids: Option<String>,
        report_id: Option<i64>,
        report_params: Option<String>,
        endpoint_url: Option<String>,
        payload: Option<String>,
        scheduled_date: Option<i64>,
        start_date: Option<i64>,
        end_date: Option<i64>,
        cron_expression: Option<String>,
        cron_type: Option<String>,
        meta_data: Option<String>,
        conditional_input: Option<String>,
        template_type: Option<String>,
        visibility: Option<models::AddAlbumCollectionVisibilityParameter>,
        active: Option<bool>,
        send_now: Option<bool>,
        event_type: Option<String>,
        deep_link_uri: Option<String>,
        send_to_all: Option<bool>,
        context: &C) -> Result<CreateScheduledNotificationResponse, ApiError>;

    /// Delete Scheduled Notification
    async fn delete_scheduled_notification(
        &self,
        version: f64,
        account_id: i64,
        scheduled_notification_id: i64,
        delete_by_grouping_id: Option<bool>,
        context: &C) -> Result<DeleteScheduledNotificationResponse, ApiError>;

    /// Get Scheduled Notification
    async fn get_scheduled_notification(
        &self,
        version: f64,
        account_id: i64,
        scheduled_notification_id: i64,
        context: &C) -> Result<GetScheduledNotificationResponse, ApiError>;

    /// Generate Schedule Notifications
    async fn schedule_notification_listings(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        report_name: String,
        message: String,
        offset: i32,
        recipient_report_id: i64,
        report_params: Option<String>,
        param_type: Option<String>,
        context: &C) -> Result<ScheduleNotificationListingsResponse, ApiError>;

    /// Search Scheduled Notifications
    async fn search_scheduled_notifications(
        &self,
        version: f64,
        account_id: i64,
        grouping_id: Option<String>,
        audience_id: Option<i64>,
        filter: Option<String>,
        types: Option<String>,
        content_ids: Option<String>,
        content_types: Option<String>,
        parent_ids: Option<String>,
        parent_types: Option<String>,
        statuses: Option<String>,
        template_types: Option<String>,
        app_key: Option<String>,
        keyword: Option<String>,
        sort_field: Option<String>,
        descending: Option<bool>,
        start: Option<i32>,
        limit: Option<i32>,
        active_only: Option<bool>,
        group_by_grouping_id: Option<bool>,
        return_audience_account_count: Option<bool>,
        context: &C) -> Result<SearchScheduledNotificationsResponse, ApiError>;

    /// Update Scheduled Notification
    async fn update_scheduled_notification(
        &self,
        version: f64,
        scheduled_notification_id: i64,
        account_id: i64,
        name: Option<String>,
        param_type: Option<String>,
        message: Option<String>,
        payload: Option<String>,
        content_id: Option<i64>,
        content_name: Option<String>,
        content_type: Option<String>,
        parent_id: Option<i64>,
        parent_type: Option<String>,
        app_key: Option<String>,
        grouping_id: Option<String>,
        connection_group_ids: Option<String>,
        connection_account_ids: Option<String>,
        audience_id: Option<i64>,
        audience_ids: Option<String>,
        album_ids: Option<String>,
        report_id: Option<i64>,
        report_params: Option<String>,
        endpoint_url: Option<String>,
        scheduled_date: Option<i64>,
        start_date: Option<i64>,
        end_date: Option<i64>,
        cron_expression: Option<String>,
        cron_type: Option<String>,
        meta_data: Option<String>,
        conditional_input: Option<String>,
        template_type: Option<String>,
        visibility: Option<models::AddAlbumCollectionVisibilityParameter>,
        active: Option<bool>,
        error_message: Option<String>,
        status: Option<String>,
        update_by_grouping_id: Option<bool>,
        send_now: Option<bool>,
        event_type: Option<String>,
        deep_link_uri: Option<String>,
        send_to_all: Option<bool>,
        context: &C) -> Result<UpdateScheduledNotificationResponse, ApiError>;

    /// Create Score
    async fn create_score(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        points: i32,
        mission_id: Option<i64>,
        game_id: Option<i64>,
        pack_id: Option<i64>,
        game_level_id: Option<i64>,
        game_object_id: Option<i64>,
        time_taken: Option<i32>,
        highest: Option<bool>,
        context: &C) -> Result<CreateScoreResponse, ApiError>;

    /// Get Score
    async fn get_score(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        mission_id: Option<i64>,
        game_id: Option<i64>,
        pack_id: Option<i64>,
        game_level_id: Option<i64>,
        game_object_id: Option<i64>,
        score_object_type: Option<String>,
        score_status: Option<String>,
        context: &C) -> Result<GetScoreResponse, ApiError>;

    /// Search Score
    async fn search_scores(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        mission_id: Option<i64>,
        game_id: Option<i64>,
        pack_id: Option<i64>,
        game_level_id: Option<i64>,
        game_object_id: Option<i64>,
        context: &C) -> Result<SearchScoresResponse, ApiError>;

    /// Create Secure Application
    async fn create_secure_application(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        key_cert: swagger::ByteArray,
        trust_store: swagger::ByteArray,
        username: String,
        password: String,
        active: Option<bool>,
        biometric_type: Option<models::CreateSecureApplicationBiometricTypeParameter>,
        biometric_position: Option<models::CreateSecureApplicationBiometricPositionParameter>,
        biometric_position2: Option<models::CreateSecureApplicationBiometricPositionParameter>,
        context: &C) -> Result<CreateSecureApplicationResponse, ApiError>;

    /// Delete Secure Application
    async fn delete_secure_application(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        context: &C) -> Result<DeleteSecureApplicationResponse, ApiError>;

    /// Login Clear
    async fn login_secure(
        &self,
        version: f64,
        app_key: String,
        biometric_file: swagger::ByteArray,
        device_id: Option<String>,
        biometric_file2: Option<swagger::ByteArray>,
        age_restriction: Option<i32>,
        return_profile: Option<bool>,
        response_filters: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        context: &C) -> Result<LoginSecureResponse, ApiError>;

    /// Purchase Clear
    async fn purchase_secure(
        &self,
        version: f64,
        body: models::PaymentRequest,
        context: &C) -> Result<PurchaseSecureResponse, ApiError>;

    /// Rest Secure Application
    async fn reset_secure(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        context: &C) -> Result<ResetSecureResponse, ApiError>;

    /// Update Secure Application
    async fn update_secure_application(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        active: Option<bool>,
        key_cert: Option<swagger::ByteArray>,
        trust_store: Option<swagger::ByteArray>,
        username: Option<String>,
        password: Option<String>,
        biometric_type: Option<models::UpdateSecureApplicationBiometricTypeParameter>,
        biometric_position: Option<models::UpdateSecureApplicationBiometricPositionParameter>,
        biometric_position2: Option<models::UpdateSecureApplicationBiometricPositionParameter>,
        context: &C) -> Result<UpdateSecureApplicationResponse, ApiError>;

    /// Create Service Hub
    async fn create_service_hub(
        &self,
        version: f64,
        body: Option<models::ServiceHub>,
        context: &C) -> Result<CreateServiceHubResponse, ApiError>;

    /// Search Service Hubs
    async fn search_service_hubs(
        &self,
        version: f64,
        sort_field: String,
        descending: bool,
        start: i32,
        limit: i32,
        active_only: bool,
        keyword: Option<String>,
        retailer_id: Option<i64>,
        context: &C) -> Result<SearchServiceHubsResponse, ApiError>;

    /// Delete Service Hub
    async fn delete_service_hub(
        &self,
        version: f64,
        id: i64,
        context: &C) -> Result<DeleteServiceHubResponse, ApiError>;

    /// Get Service Hub
    async fn get_service_hub(
        &self,
        version: f64,
        id: i64,
        context: &C) -> Result<GetServiceHubResponse, ApiError>;

    /// Update Service Hub
    async fn post_service_hub(
        &self,
        version: f64,
        id: i64,
        body: Option<models::ServiceHub>,
        context: &C) -> Result<PostServiceHubResponse, ApiError>;

    /// Update Service Hub
    async fn put_service_hub(
        &self,
        version: f64,
        id: i64,
        body: Option<models::ServiceHub>,
        context: &C) -> Result<PutServiceHubResponse, ApiError>;

    /// Create Shipment
    async fn create_shipment(
        &self,
        version: f64,
        body: Option<models::Shipment>,
        context: &C) -> Result<CreateShipmentResponse, ApiError>;

    /// Search Shipments
    async fn search_shipments(
        &self,
        version: f64,
        sort_field: String,
        descending: bool,
        start: i32,
        limit: i32,
        active_only: bool,
        owner_id: Option<i64>,
        rider_id: Option<i64>,
        route_id: Option<i64>,
        context: &C) -> Result<SearchShipmentsResponse, ApiError>;

    /// Cancel Shipment
    async fn cancel_shipment(
        &self,
        version: f64,
        id: i64,
        context: &C) -> Result<CancelShipmentResponse, ApiError>;

    /// Delete Shipment
    async fn delete_shipment(
        &self,
        version: f64,
        id: i64,
        context: &C) -> Result<DeleteShipmentResponse, ApiError>;

    /// Get Shipment
    async fn get_shipment(
        &self,
        version: f64,
        id: i64,
        context: &C) -> Result<GetShipmentResponse, ApiError>;

    /// Update Shipment
    async fn update_shipment(
        &self,
        version: f64,
        id: i64,
        body: Option<models::Shipment>,
        context: &C) -> Result<UpdateShipmentResponse, ApiError>;

    /// Uupdate Shipment Status
    async fn update_shipment_status(
        &self,
        version: f64,
        id: i64,
        body: Option<std::collections::HashMap<String, bool>>,
        context: &C) -> Result<UpdateShipmentStatusResponse, ApiError>;

    /// Create Shipment Batch
    async fn create_shipment_batch(
        &self,
        version: f64,
        body: Option<models::ShipmentBatch>,
        context: &C) -> Result<CreateShipmentBatchResponse, ApiError>;

    /// Search Shipment Batch
    async fn search_shipment_batch(
        &self,
        version: f64,
        hub_id: i64,
        sort_field: String,
        descending: bool,
        start: i32,
        limit: i32,
        context: &C) -> Result<SearchShipmentBatchResponse, ApiError>;

    /// Delete Shipment Batch
    async fn delete_shipment_batch(
        &self,
        version: f64,
        batch_id: i64,
        context: &C) -> Result<DeleteShipmentBatchResponse, ApiError>;

    /// Get Shipment Batch
    async fn get_shipment_batch(
        &self,
        version: f64,
        batch_id: i64,
        context: &C) -> Result<GetShipmentBatchResponse, ApiError>;

    /// Get Shipment Batch Status
    async fn get_shipment_batch_status(
        &self,
        version: f64,
        batch_id: i64,
        account_id: i64,
        sort_field: String,
        descending: bool,
        start: i32,
        limit: i32,
        valid: Option<bool>,
        started: Option<bool>,
        completed: Option<bool>,
        has_shipment: Option<bool>,
        has_route: Option<bool>,
        keyword: Option<String>,
        context: &C) -> Result<GetShipmentBatchStatusResponse, ApiError>;

    /// Routing Simulation
    async fn simulation(
        &self,
        version: f64,
        data: String,
        real_time: bool,
        context: &C) -> Result<SimulationResponse, ApiError>;

    /// Get Stop
    async fn get_stop(
        &self,
        version: f64,
        id: i64,
        context: &C) -> Result<GetStopResponse, ApiError>;

    /// Update Stop
    async fn update_stop(
        &self,
        version: f64,
        id: i64,
        body: Option<models::Stop>,
        context: &C) -> Result<UpdateStopResponse, ApiError>;

    /// Create Stripe Checkout Session
    async fn create_stripe_checkout_session(
        &self,
        version: f64,
        app_key: String,
        stripe_parameters: String,
        context: &C) -> Result<CreateStripeCheckoutSessionResponse, ApiError>;

    /// Create Subscription
    async fn create_subscription(
        &self,
        version: f64,
        account_id: i64,
        plan_id: Option<i64>,
        promo_code: Option<String>,
        context: &C) -> Result<CreateSubscriptionResponse, ApiError>;

    /// Delete Subscription
    async fn delete_subscription(
        &self,
        version: f64,
        account_id: i64,
        context: &C) -> Result<DeleteSubscriptionResponse, ApiError>;

    /// Get Subscription
    async fn get_subscription(
        &self,
        version: f64,
        account_id: i64,
        context: &C) -> Result<GetSubscriptionResponse, ApiError>;

    /// Get Subscription Plan
    async fn get_subscription_plan(
        &self,
        version: f64,
        plan_id: i64,
        context: &C) -> Result<GetSubscriptionPlanResponse, ApiError>;

    /// List Subscription Plans
    async fn get_subscription_plans(
        &self,
        version: f64,
        visible: Option<bool>,
        role: Option<String>,
        context: &C) -> Result<GetSubscriptionPlansResponse, ApiError>;

    /// Get Subscription Usage
    async fn get_subscription_usage(
        &self,
        version: f64,
        account_id: i64,
        application_id: Option<i64>,
        start: Option<i64>,
        end: Option<i64>,
        context: &C) -> Result<GetSubscriptionUsageResponse, ApiError>;

    /// Update Subscription
    async fn update_subscription(
        &self,
        version: f64,
        account_id: i64,
        plan_id: Option<i64>,
        promo_code: Option<String>,
        active: Option<bool>,
        context: &C) -> Result<UpdateSubscriptionResponse, ApiError>;

    /// Create Task
    async fn create_task(
        &self,
        version: f64,
        account_id: i64,
        name: String,
        app_key: Option<String>,
        grouping_id: Option<String>,
        endpoint_url: Option<String>,
        payload: Option<String>,
        scheduled_date: Option<i64>,
        start_date: Option<i64>,
        end_date: Option<i64>,
        cron_expression: Option<String>,
        visibility: Option<models::AddAlbumCollectionVisibilityParameter>,
        active: Option<bool>,
        context: &C) -> Result<CreateTaskResponse, ApiError>;

    /// Delete Task
    async fn delete_task(
        &self,
        version: f64,
        account_id: i64,
        task_id: i64,
        context: &C) -> Result<DeleteTaskResponse, ApiError>;

    /// Get Task
    async fn get_task(
        &self,
        version: f64,
        account_id: i64,
        task_id: i64,
        context: &C) -> Result<GetTaskResponse, ApiError>;

    /// Search Tasks
    async fn search_tasks(
        &self,
        version: f64,
        account_id: i64,
        grouping_id: Option<String>,
        filter: Option<String>,
        statuses: Option<String>,
        template_types: Option<String>,
        app_key: Option<String>,
        keyword: Option<String>,
        sort_field: Option<String>,
        descending: Option<bool>,
        start: Option<i32>,
        limit: Option<i32>,
        active_only: Option<bool>,
        context: &C) -> Result<SearchTasksResponse, ApiError>;

    /// Update Task
    async fn update_task(
        &self,
        version: f64,
        task_id: i64,
        account_id: i64,
        name: Option<String>,
        app_key: Option<String>,
        grouping_id: Option<String>,
        endpoint_url: Option<String>,
        payload: Option<String>,
        scheduled_date: Option<i64>,
        start_date: Option<i64>,
        end_date: Option<i64>,
        cron_expression: Option<String>,
        visibility: Option<models::AddAlbumCollectionVisibilityParameter>,
        active: Option<bool>,
        context: &C) -> Result<UpdateTaskResponse, ApiError>;

    /// Create Territory
    async fn create_territory(
        &self,
        version: f64,
        account_id: i64,
        name: String,
        active: Option<bool>,
        context: &C) -> Result<CreateTerritoryResponse, ApiError>;

    /// Delete Territory
    async fn delete_territory(
        &self,
        version: f64,
        account_id: i64,
        territory_id: i64,
        context: &C) -> Result<DeleteTerritoryResponse, ApiError>;

    /// Get Territory
    async fn get_territory(
        &self,
        version: f64,
        territory_id: i64,
        context: &C) -> Result<GetTerritoryResponse, ApiError>;

    /// Search Territories
    async fn search_territories(
        &self,
        version: f64,
        sort_field: models::SearchTerritoriesSortFieldParameter,
        descending: bool,
        keyword: Option<String>,
        start: Option<i32>,
        limit: Option<i32>,
        context: &C) -> Result<SearchTerritoriesResponse, ApiError>;

    /// Update Territory
    async fn update_territory(
        &self,
        version: f64,
        account_id: i64,
        territory_id: i64,
        name: Option<String>,
        active: Option<bool>,
        context: &C) -> Result<UpdateTerritoryResponse, ApiError>;

    /// Create/Update Theme
    async fn add_or_update_theme_descriptor(
        &self,
        version: f64,
        public_read: bool,
        public_write: bool,
        public_delete: bool,
        public_add: bool,
        visibility: models::AddAlbumCollectionVisibilityParameter,
        include_friend_group: bool,
        complete_with_default_values: bool,
        device_id: Option<String>,
        account_id: Option<i64>,
        game_type: Option<String>,
        theme_descriptor_id: Option<i64>,
        title: Option<String>,
        description: Option<String>,
        connection_ids_to_add: Option<String>,
        connection_group_ids_to_add: Option<String>,
        app_version: Option<String>,
        color_value_json: Option<String>,
        string_replacer_json: Option<String>,
        custom_json_objects: Option<String>,
        icon_image: Option<swagger::ByteArray>,
        scene_atlas_image: Option<swagger::ByteArray>,
        bg_image: Option<swagger::ByteArray>,
        bg_sound: Option<swagger::ByteArray>,
        music_selection: Option<String>,
        location_description: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        context: &C) -> Result<AddOrUpdateThemeDescriptorResponse, ApiError>;

    /// Get Theme
    async fn get_theme_descriptor(
        &self,
        version: f64,
        theme_descriptor_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        game_type: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        context: &C) -> Result<GetThemeDescriptorResponse, ApiError>;

    /// Search Themes
    async fn get_theme_descriptors(
        &self,
        version: f64,
        filter: String,
        sort_field: String,
        descending: bool,
        start: i32,
        limit: i32,
        device_id: Option<String>,
        account_id: Option<i64>,
        game_type: Option<String>,
        contest_type: Option<String>,
        owner_id: Option<i64>,
        q: Option<String>,
        keyword: Option<String>,
        _i: Option<i32>,
        _l: Option<i32>,
        date_created: Option<i64>,
        app_version: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        context: &C) -> Result<GetThemeDescriptorsResponse, ApiError>;

    /// Delete Theme
    async fn remove_theme_descriptor(
        &self,
        version: f64,
        theme_descriptor_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        game_type: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        context: &C) -> Result<RemoveThemeDescriptorResponse, ApiError>;

    /// Create Credential
    async fn create_credential(
        &self,
        version: f64,
        third_party_id: String,
        third_party_token: String,
        network_uid: String,
        app_key: String,
        account_id: Option<i64>,
        device_id: Option<String>,
        session_id: Option<String>,
        third_party_name: Option<String>,
        email_address: Option<String>,
        signin_only_mode: Option<bool>,
        response_filters: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        meta_data: Option<String>,
        third_party_refresh_token: Option<String>,
        audience_ids_to_add: Option<String>,
        audience_ids_to_remove: Option<String>,
        context: &C) -> Result<CreateCredentialResponse, ApiError>;

    /// Create Network
    async fn create_network(
        &self,
        version: f64,
        account_id: i64,
        name: String,
        enable_introspection: bool,
        description: Option<String>,
        introspection_method: Option<String>,
        introspection_url: Option<String>,
        introspection_params: Option<String>,
        required_root_field: Option<String>,
        enable_mfa: Option<bool>,
        size_mfa: Option<i32>,
        shelf_life_mfa: Option<i32>,
        oauth_token_url: Option<String>,
        oauth_private_key: Option<swagger::ByteArray>,
        oauth_public_key: Option<swagger::ByteArray>,
        oauth_client_id: Option<String>,
        oauth_secret_key: Option<String>,
        body: Option<String>,
        context: &C) -> Result<CreateNetworkResponse, ApiError>;

    /// Delete Credential
    async fn delete_credential(
        &self,
        version: f64,
        account_id: i64,
        network_uid: String,
        third_party_id: String,
        app_key: String,
        context: &C) -> Result<DeleteCredentialResponse, ApiError>;

    /// Delete Network
    async fn delete_network(
        &self,
        version: f64,
        account_id: i64,
        network_uid: String,
        context: &C) -> Result<DeleteNetworkResponse, ApiError>;

    /// Get Credential
    async fn get_credential(
        &self,
        version: f64,
        network_uid: String,
        app_key: String,
        account_id: Option<i64>,
        device_id: Option<String>,
        session_id: Option<String>,
        third_party_credential_id: Option<i64>,
        third_party_token: Option<String>,
        third_party_secret: Option<String>,
        create_new_account: Option<bool>,
        response_filters: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        audience_ids_to_add: Option<String>,
        audience_ids_to_remove: Option<String>,
        referral_account_id: Option<i64>,
        context: &C) -> Result<GetCredentialResponse, ApiError>;

    /// Get Network
    async fn get_network(
        &self,
        version: f64,
        account_id: i64,
        network_uid: String,
        context: &C) -> Result<GetNetworkResponse, ApiError>;

    /// Search Credentials
    async fn search_credentials(
        &self,
        version: f64,
        account_id: i64,
        keyword: Option<String>,
        network_uid: Option<String>,
        descending: Option<bool>,
        start: Option<i32>,
        limit: Option<i32>,
        context: &C) -> Result<SearchCredentialsResponse, ApiError>;

    /// Search Networks
    async fn search_networks(
        &self,
        version: f64,
        account_id: i64,
        sort_field: models::SearchNetworksSortFieldParameter,
        descending: bool,
        start: i32,
        limit: i32,
        active_only: bool,
        keyword: Option<String>,
        filter_billable: Option<bool>,
        context: &C) -> Result<SearchNetworksResponse, ApiError>;

    /// Send MFA Challenge
    async fn send_mfa_challenge(
        &self,
        version: f64,
        network_uid: String,
        app_key: String,
        third_party_token: Option<String>,
        third_party_credential_id: Option<i64>,
        device_id: Option<String>,
        context: &C) -> Result<SendMfaChallengeResponse, ApiError>;

    /// Update Credential
    async fn update_credential(
        &self,
        version: f64,
        network_uid: String,
        third_party_id: String,
        app_key: String,
        device_id: Option<String>,
        third_party_name: Option<String>,
        third_party_token: Option<String>,
        response_filters: Option<String>,
        meta_data: Option<String>,
        third_party_refresh_token: Option<String>,
        context: &C) -> Result<UpdateCredentialResponse, ApiError>;

    /// Update Network
    async fn update_network(
        &self,
        version: f64,
        account_id: i64,
        network_uid: String,
        name: Option<String>,
        description: Option<String>,
        enable_introspection: Option<bool>,
        introspection_method: Option<String>,
        introspection_url: Option<String>,
        introspection_params: Option<String>,
        required_root_field: Option<String>,
        enable_mfa: Option<bool>,
        size_mfa: Option<i32>,
        shelf_life_mfa: Option<i32>,
        oauth_token_url: Option<String>,
        oauth_private_key: Option<swagger::ByteArray>,
        oauth_public_key: Option<swagger::ByteArray>,
        oauth_client_id: Option<String>,
        oauth_secret_key: Option<String>,
        body: Option<String>,
        context: &C) -> Result<UpdateNetworkResponse, ApiError>;

    /// Get Ticket Count
    async fn get_ticket_count(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        game_type: Option<String>,
        app_key: Option<String>,
        ticket_type: Option<String>,
        context: &C) -> Result<GetTicketCountResponse, ApiError>;

    /// Get Ticket List
    async fn get_ticket_list(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        ticket_object_type: Option<String>,
        action_type: Option<String>,
        ticket_ids: Option<String>,
        object_ids: Option<String>,
        receipt_tokens: Option<String>,
        game_type: Option<String>,
        app_key: Option<String>,
        context: &C) -> Result<GetTicketListResponse, ApiError>;

    /// Gift Tickets
    async fn gift_purchase(
        &self,
        version: f64,
        receiver_account_id: i64,
        ticket_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        asset_id: Option<i64>,
        custom_message: Option<String>,
        game_type: Option<String>,
        app_key: Option<String>,
        context: &C) -> Result<GiftPurchaseResponse, ApiError>;

    /// Save Ticket
    async fn save_ticket(
        &self,
        version: f64,
        action_type: String,
        ticket_object_type: String,
        return_nulls: Option<bool>,
        device_id: Option<String>,
        account_id: Option<i64>,
        game_type: Option<String>,
        app_key: Option<String>,
        object_id: Option<i64>,
        purchase_code: Option<String>,
        receipt_token: Option<String>,
        receipt_data: Option<String>,
        count: Option<i64>,
        ticket_type: Option<String>,
        purchase_provider: Option<String>,
        purchase_type: Option<String>,
        return_profile_response: Option<bool>,
        include_profile_response: Option<bool>,
        app_version: Option<String>,
        context: &C) -> Result<SaveTicketResponse, ApiError>;

    /// Save Ticket with Reciept
    async fn save_ticket_via_file_upload(
        &self,
        version: f64,
        action_type: String,
        ticket_object_type: String,
        receipt_data: swagger::ByteArray,
        return_nulls: Option<bool>,
        device_id: Option<String>,
        account_id: Option<i64>,
        game_type: Option<String>,
        app_key: Option<String>,
        object_id: Option<i64>,
        purchase_code: Option<String>,
        receipt_token: Option<String>,
        count: Option<i64>,
        ticket_type: Option<String>,
        purchase_provider: Option<String>,
        purchase_type: Option<String>,
        return_profile_response: Option<bool>,
        include_profile_response: Option<bool>,
        app_version: Option<String>,
        context: &C) -> Result<SaveTicketViaFileUploadResponse, ApiError>;

    /// Get Ticket Offers
    async fn ticket_offers(
        &self,
        version: f64,
        context: &C) -> Result<TicketOffersResponse, ApiError>;

    /// Create Tournament
    async fn create_tournament(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        title: String,
        cost_to_play: i32,
        start_date: i64,
        sub_type: Option<String>,
        image_asset_id: Option<i64>,
        seconds_between_levels: Option<i32>,
        seconds_for_tie_breaker: Option<i32>,
        seconds_between_packs: Option<i32>,
        maximum_level_length: Option<i32>,
        cost_to_play_type: Option<String>,
        minimum_to_play: Option<i32>,
        starting_limit: Option<i32>,
        available_limit: Option<i32>,
        description: Option<String>,
        meta_data: Option<String>,
        audience_ids: Option<String>,
        active: Option<bool>,
        enable_buy_back: Option<bool>,
        offer_ids: Option<String>,
        offer_asset_id: Option<i64>,
        fixed_reward: Option<bool>,
        split_reward: Option<models::CreateTournamentSplitRewardParameter>,
        allocate_tickets: Option<bool>,
        tournament_data: Option<String>,
        mission_type: Option<models::CreateTournamentMissionTypeParameter>,
        visibility: Option<models::CreateTournamentVisibilityParameter>,
        preliminary_groups: Option<i32>,
        preliminary_group_advancements: Option<String>,
        enable_multiple_entries: Option<bool>,
        enable_multiple_votes: Option<bool>,
        featured: Option<bool>,
        winner_tag: Option<String>,
        tie_tag: Option<String>,
        context: &C) -> Result<CreateTournamentResponse, ApiError>;

    /// Delete Tournament
    async fn delete_tournament(
        &self,
        version: f64,
        account_id: i64,
        mission_id: i64,
        context: &C) -> Result<DeleteTournamentResponse, ApiError>;

    /// Get Tournament
    async fn get_tournament(
        &self,
        version: f64,
        account_id: i64,
        mission_id: Option<i64>,
        join_code: Option<String>,
        include_scores: Option<models::GetTournamentIncludeScoresParameter>,
        object_preview_size: Option<i32>,
        context: &C) -> Result<GetTournamentResponse, ApiError>;

    /// Search Tournament Objects
    async fn search_objects(
        &self,
        version: f64,
        account_id: i64,
        game_level_id: i64,
        sort_field: Option<models::SearchObjectsSortFieldParameter>,
        descending: Option<bool>,
        start: Option<i32>,
        limit: Option<i32>,
        context: &C) -> Result<SearchObjectsResponse, ApiError>;

    /// Search Tournament Rounds
    async fn search_rounds(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        status: Option<String>,
        mission_type: Option<models::SearchRoundsMissionTypeParameter>,
        current_only: Option<bool>,
        visibilities: Option<String>,
        start: Option<i32>,
        limit: Option<i32>,
        context: &C) -> Result<SearchRoundsResponse, ApiError>;

    /// Search Tournaments
    async fn search_tournaments(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        keyword: Option<String>,
        sub_type: Option<String>,
        include_inactive: Option<bool>,
        mission_types: Option<String>,
        filter: Option<models::SearchTournamentsFilterParameter>,
        sort_field: Option<models::SearchTournamentsSortFieldParameter>,
        descending: Option<bool>,
        visibility: Option<String>,
        start: Option<i32>,
        limit: Option<i32>,
        context: &C) -> Result<SearchTournamentsResponse, ApiError>;

    /// Submit Tournament Score
    async fn submit_tournament_score(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        mission_id: i64,
        game_id: i64,
        pack_id: i64,
        scores: String,
        game_level_id: Option<i64>,
        context: &C) -> Result<SubmitTournamentScoreResponse, ApiError>;

    /// Submit a vote for a multi-stage album tournament.
    async fn submit_tournament_vote(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        mission_id: i64,
        game_object_id: i64,
        device_id: Option<String>,
        check_if_device_already_voted: Option<bool>,
        context: &C) -> Result<SubmitTournamentVoteResponse, ApiError>;

    /// Substitute Tournament Player
    async fn substitute_tournament_player(
        &self,
        version: f64,
        account_id: i64,
        mission_id: i64,
        pack_id: i64,
        game_level_id: i64,
        context: &C) -> Result<SubstituteTournamentPlayerResponse, ApiError>;

    /// Update Tournament
    async fn update_tournament(
        &self,
        version: f64,
        account_id: i64,
        mission_id: i64,
        title: Option<String>,
        sub_type: Option<String>,
        image_asset_id: Option<i64>,
        seconds_between_levels: Option<i32>,
        seconds_for_tie_breaker: Option<i32>,
        seconds_between_packs: Option<i32>,
        maximum_level_length: Option<i32>,
        cost_to_play: Option<i32>,
        cost_to_play_type: Option<String>,
        minimum_to_play: Option<i32>,
        starting_limit: Option<i32>,
        available_limit: Option<i32>,
        description: Option<String>,
        meta_data: Option<String>,
        start_date: Option<i64>,
        audience_ids: Option<String>,
        active: Option<bool>,
        enable_buy_back: Option<bool>,
        offer_ids: Option<String>,
        offer_asset_id: Option<i64>,
        fixed_reward: Option<bool>,
        split_reward: Option<models::UpdateTournamentSplitRewardParameter>,
        allocate_tickets: Option<bool>,
        tournament_data: Option<String>,
        visibility: Option<models::CreateMediaOfferVisibilityParameter>,
        preliminary_groups: Option<i32>,
        preliminary_group_advancements: Option<String>,
        enable_multiple_entries: Option<bool>,
        enable_multiple_votes: Option<bool>,
        featured: Option<bool>,
        winner_tag: Option<String>,
        tie_tag: Option<String>,
        context: &C) -> Result<UpdateTournamentResponse, ApiError>;

    /// Create Batch Tracking
    async fn batch_save_tracking(
        &self,
        version: f64,
        data: String,
        device_id: Option<String>,
        account_id: Option<i64>,
        generate_accounts: Option<bool>,
        update_account_locations: Option<bool>,
        default_tag: Option<String>,
        slave_uid: Option<String>,
        context: &C) -> Result<BatchSaveTrackingResponse, ApiError>;

    /// Get Predicted Locations
    async fn get_predicted_locations(
        &self,
        version: f64,
        account_id: i64,
        latitude: Option<f64>,
        longitude: Option<f64>,
        date_check: Option<i64>,
        hour_check: Option<String>,
        threshold: Option<i64>,
        distance_unit: Option<models::GetOfferListCountsDistanceUnitParameter>,
        search_range: Option<f64>,
        sort_order: Option<models::GetPredictedLocationsSortOrderParameter>,
        context: &C) -> Result<GetPredictedLocationsResponse, ApiError>;

    /// Get Tracking Path
    async fn get_predicted_path(
        &self,
        version: f64,
        account_id: i64,
        start_step_id: i64,
        end_step_id: i64,
        context: &C) -> Result<GetPredictedPathResponse, ApiError>;

    /// Search Preferred Locations
    async fn get_preferred_locations(
        &self,
        version: f64,
        account_id: i64,
        latitude: Option<f64>,
        longitude: Option<f64>,
        date_check: Option<i64>,
        hour_check: Option<String>,
        sort_field: Option<String>,
        descending: Option<bool>,
        start: Option<i32>,
        limit: Option<i32>,
        search_range: Option<f64>,
        distance_unit: Option<models::GetOfferListCountsDistanceUnitParameter>,
        context: &C) -> Result<GetPreferredLocationsResponse, ApiError>;

    /// Search Tracking
    async fn get_tracking_legs(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        owner_id: Option<i64>,
        tracking_device_id: Option<String>,
        start_date: Option<i64>,
        end_date: Option<i64>,
        tags: Option<String>,
        get_last_point: Option<bool>,
        context: &C) -> Result<GetTrackingLegsResponse, ApiError>;

    /// Create Tracking Leg
    async fn save_tracking_leg(
        &self,
        version: f64,
        start_lat: f64,
        start_lng: f64,
        start_date: i64,
        end_lat: f64,
        end_lng: f64,
        end_date: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        distance: Option<f64>,
        duration: Option<i64>,
        steps: Option<String>,
        tags: Option<String>,
        context: &C) -> Result<SaveTrackingLegResponse, ApiError>;

    /// Create Tracking Step
    async fn save_tracking_step(
        &self,
        version: f64,
        leg_id: i64,
        start_lat: f64,
        start_lng: f64,
        start_date: i64,
        end_lat: f64,
        end_lng: f64,
        end_date: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        distance: Option<f64>,
        duration: Option<i64>,
        context: &C) -> Result<SaveTrackingStepResponse, ApiError>;

    /// List Tracking
    async fn search_accounts_with_tracking_legs(
        &self,
        version: f64,
        account_id: i64,
        keyword: Option<String>,
        start_date: Option<i64>,
        end_date: Option<i64>,
        tags: Option<String>,
        audience_ids: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        range: Option<f64>,
        sort_field: Option<String>,
        descending: Option<bool>,
        start: Option<i32>,
        limit: Option<i32>,
        active_only: Option<bool>,
        context: &C) -> Result<SearchAccountsWithTrackingLegsResponse, ApiError>;

    /// Search Tracking (Billable)
    async fn search_tracking_legs(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        tracking_device_id: Option<String>,
        start_date: Option<i64>,
        end_date: Option<i64>,
        tags: Option<String>,
        start: Option<i32>,
        limit: Option<i32>,
        context: &C) -> Result<SearchTrackingLegsResponse, ApiError>;

    /// Create Trigger
    async fn create_trigger(
        &self,
        version: f64,
        account_id: i64,
        name: String,
        app_key: Option<String>,
        grouping_id: Option<String>,
        endpoint_url: Option<String>,
        payload: Option<String>,
        scheduled_date: Option<i64>,
        start_date: Option<i64>,
        end_date: Option<i64>,
        cron_expression: Option<String>,
        conditional_input: Option<String>,
        visibility: Option<models::AddAlbumCollectionVisibilityParameter>,
        active: Option<bool>,
        context: &C) -> Result<CreateTriggerResponse, ApiError>;

    /// Delete Trigger
    async fn delete_trigger(
        &self,
        version: f64,
        account_id: i64,
        trigger_id: i64,
        context: &C) -> Result<DeleteTriggerResponse, ApiError>;

    /// Get Trigger
    async fn get_trigger(
        &self,
        version: f64,
        account_id: i64,
        trigger_id: i64,
        context: &C) -> Result<GetTriggerResponse, ApiError>;

    /// Search Triggers
    async fn search_triggers(
        &self,
        version: f64,
        account_id: i64,
        grouping_id: Option<String>,
        filter: Option<String>,
        statuses: Option<String>,
        template_types: Option<String>,
        app_key: Option<String>,
        keyword: Option<String>,
        sort_field: Option<String>,
        descending: Option<bool>,
        start: Option<i32>,
        limit: Option<i32>,
        active_only: Option<bool>,
        context: &C) -> Result<SearchTriggersResponse, ApiError>;

    /// Update Trigger
    async fn update_trigger(
        &self,
        version: f64,
        trigger_id: i64,
        account_id: i64,
        name: Option<String>,
        app_key: Option<String>,
        grouping_id: Option<String>,
        endpoint_url: Option<String>,
        payload: Option<String>,
        scheduled_date: Option<i64>,
        start_date: Option<i64>,
        end_date: Option<i64>,
        cron_expression: Option<String>,
        conditional_input: Option<String>,
        visibility: Option<models::AddAlbumCollectionVisibilityParameter>,
        active: Option<bool>,
        context: &C) -> Result<UpdateTriggerResponse, ApiError>;

    /// Create Trip
    async fn create_trip(
        &self,
        version: f64,
        body: Option<models::Trip>,
        context: &C) -> Result<CreateTripResponse, ApiError>;

    /// Process Trip Matches
    async fn process_trip_matches(
        &self,
        version: f64,
        start_date: Option<i64>,
        end_date: Option<i64>,
        trip_id: Option<i64>,
        context: &C) -> Result<ProcessTripMatchesResponse, ApiError>;

    /// Search Trips
    async fn search(
        &self,
        version: f64,
        account_id: i64,
        sort_field: String,
        descending: bool,
        start: i32,
        limit: i32,
        active_only: bool,
        start_date: Option<i64>,
        end_date: Option<i64>,
        has_notifications: Option<bool>,
        context: &C) -> Result<SearchResponse, ApiError>;

    /// Search Trips
    async fn search_trips(
        &self,
        version: f64,
        account_id: i64,
        sort_field: String,
        descending: bool,
        start: i32,
        limit: i32,
        active_only: bool,
        start_date: Option<i64>,
        end_date: Option<i64>,
        matched_has_route: Option<bool>,
        matched_has_driver: Option<bool>,
        context: &C) -> Result<SearchTripsResponse, ApiError>;

    /// Trip Notifications
    async fn update_trip_notifications(
        &self,
        version: f64,
        id: i64,
        notifications: Option<String>,
        context: &C) -> Result<UpdateTripNotificationsResponse, ApiError>;

    /// Delete Trip
    async fn delete(
        &self,
        version: f64,
        id: i64,
        context: &C) -> Result<DeleteResponse, ApiError>;

    /// Set Trip Preference Driver
    async fn drive_trip(
        &self,
        version: f64,
        id: i64,
        recurrence: bool,
        context: &C) -> Result<DriveTripResponse, ApiError>;

    /// Set Trip Preference Flexible
    async fn flexible_trip(
        &self,
        version: f64,
        id: i64,
        recurrence: bool,
        context: &C) -> Result<FlexibleTripResponse, ApiError>;

    /// Get Trip
    async fn get_trip(
        &self,
        version: f64,
        id: i64,
        context: &C) -> Result<GetTripResponse, ApiError>;

    /// Get Trip Matches
    async fn get_trip_matches(
        &self,
        version: f64,
        id: i64,
        sort_field: String,
        descending: bool,
        start: i32,
        limit: i32,
        active_only: bool,
        matched_has_route: Option<bool>,
        matched_has_driver: Option<bool>,
        context: &C) -> Result<GetTripMatchesResponse, ApiError>;

    /// Set Trip Preference Rider
    async fn ride(
        &self,
        version: f64,
        id: i64,
        recurrence: bool,
        context: &C) -> Result<RideResponse, ApiError>;

    /// Update Trip Locations
    async fn update_locations(
        &self,
        version: f64,
        id: i64,
        body: Option<models::Trip>,
        context: &C) -> Result<UpdateLocationsResponse, ApiError>;

    /// Update Recurrence Locations
    async fn update_recurrence_locations(
        &self,
        version: f64,
        id: i64,
        body: Option<models::Trip>,
        context: &C) -> Result<UpdateRecurrenceLocationsResponse, ApiError>;

    /// Update Recurrence Shipments
    async fn update_recurrence_shipments(
        &self,
        version: f64,
        id: i64,
        body: Option<models::Trip>,
        context: &C) -> Result<UpdateRecurrenceShipmentsResponse, ApiError>;

    /// Update Trip Shipments
    async fn update_shipments(
        &self,
        version: f64,
        id: i64,
        body: Option<models::Trip>,
        context: &C) -> Result<UpdateShipmentsResponse, ApiError>;

    /// Update Trip
    async fn update_trip(
        &self,
        version: f64,
        id: i64,
        body: Option<models::Trip>,
        context: &C) -> Result<UpdateTripResponse, ApiError>;

    /// Buy Offer by SMS
    async fn sms_buy_offer(
        &self,
        version: f64,
        app_key: String,
        body: String,
        from: String,
        currency_type: String,
        context: &C) -> Result<SmsBuyOfferResponse, ApiError>;

    /// Authorize Twitter
    async fn authorize_twitter(
        &self,
        version: f64,
        app_key: String,
        context: &C) -> Result<AuthorizeTwitterResponse, ApiError>;

    /// Login Twitter
    async fn login_twitter(
        &self,
        version: f64,
        access_token: String,
        access_token_secret: String,
        app_key: String,
        response_filters: String,
        device_id: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        context: &C) -> Result<LoginTwitterResponse, ApiError>;

    /// Add User
    async fn add_users_to_permissionable(
        &self,
        version: f64,
        permissionable_type: models::AddUsersToPermissionablePermissionableTypeParameter,
        permissionable_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        read: Option<bool>,
        write: Option<bool>,
        delete: Option<bool>,
        add: Option<bool>,
        connection_ids: Option<String>,
        connection_account_ids: Option<String>,
        connection_group_ids: Option<String>,
        pending: Option<bool>,
        admin: Option<bool>,
        include_friend_group: Option<bool>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        audience_ids: Option<String>,
        context: &C) -> Result<AddUsersToPermissionableResponse, ApiError>;

    /// Approve Permissionable
    async fn approve_permissionable(
        &self,
        version: f64,
        permissionable_type: models::AddUsersToPermissionablePermissionableTypeParameter,
        permissionable_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        approval_status: Option<models::ApprovePermissionableApprovalStatusParameter>,
        context: &C) -> Result<ApprovePermissionableResponse, ApiError>;

    /// Leave
    async fn leave_from_permissionable(
        &self,
        version: f64,
        permissionable_type: String,
        permissionable_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        context: &C) -> Result<LeaveFromPermissionableResponse, ApiError>;

    /// Remove User
    async fn remove_users_from_permissionable(
        &self,
        version: f64,
        permissionable_type: models::AddUsersToPermissionablePermissionableTypeParameter,
        permissionable_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        connection_ids: Option<String>,
        connection_account_ids: Option<String>,
        connection_group_ids: Option<String>,
        remove_friend_group: Option<bool>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        audience_ids: Option<String>,
        context: &C) -> Result<RemoveUsersFromPermissionableResponse, ApiError>;

    /// Search Permissionables
    async fn search_permissionables(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        connection_account_id: Option<i64>,
        connection_account_ids: Option<String>,
        permissionable_type: Option<models::AddUsersToPermissionablePermissionableTypeParameter>,
        permissionable_id: Option<i64>,
        keyword: Option<String>,
        sort_field: Option<String>,
        descending: Option<bool>,
        pending: Option<bool>,
        admin: Option<bool>,
        start: Option<i32>,
        limit: Option<i32>,
        context: &C) -> Result<SearchPermissionablesResponse, ApiError>;

    /// Search Permissionables by Distnace
    async fn search_permissionables_following_distance(
        &self,
        version: f64,
        latitude: f64,
        longitude: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        connection_account_id: Option<i64>,
        connection_account_ids: Option<String>,
        permissionable_type: Option<models::AddUsersToPermissionablePermissionableTypeParameter>,
        permissionable_id: Option<i64>,
        search_range: Option<f64>,
        keyword: Option<String>,
        pending: Option<bool>,
        admin: Option<bool>,
        start: Option<i32>,
        limit: Option<i32>,
        context: &C) -> Result<SearchPermissionablesFollowingDistanceResponse, ApiError>;

    /// Create following
    async fn create_following(
        &self,
        version: f64,
        account_id: i64,
        vatom_parameters: String,
        return_raw_response: Option<bool>,
        context: &C) -> Result<CreateFollowingResponse, ApiError>;

    /// Create Vatom Space
    async fn create_space(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        vatom_parameters: String,
        return_raw_response: Option<bool>,
        context: &C) -> Result<CreateSpaceResponse, ApiError>;

    /// Create Vatom Event
    async fn create_vatom_event(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        vatom_parameters: String,
        return_raw_response: Option<bool>,
        context: &C) -> Result<CreateVatomEventResponse, ApiError>;

    /// Delete following
    async fn delete_following(
        &self,
        version: f64,
        account_id: i64,
        vatom_rels_key: String,
        return_raw_response: Option<bool>,
        context: &C) -> Result<DeleteFollowingResponse, ApiError>;

    /// Reset All Points Balance
    async fn delete_points_balance(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        vatom_campaign_id: String,
        return_raw_response: Option<bool>,
        context: &C) -> Result<DeletePointsBalanceResponse, ApiError>;

    /// Delete Vatom Space
    async fn delete_space(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        vatom_space_id: String,
        return_raw_response: Option<bool>,
        context: &C) -> Result<DeleteSpaceResponse, ApiError>;

    /// Delete Vatom Event
    async fn delete_vatom_event(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        vatom_event_id: String,
        return_raw_response: Option<bool>,
        context: &C) -> Result<DeleteVatomEventResponse, ApiError>;

    /// Delete Vatom NFT
    async fn delete_vatom_nft(
        &self,
        version: f64,
        account_id: i64,
        vatom_id: String,
        return_raw_response: Option<bool>,
        context: &C) -> Result<DeleteVatomNftResponse, ApiError>;

    /// Execute Action on NFT
    async fn execute_action_on_nft(
        &self,
        version: f64,
        account_id: i64,
        vatom_id: String,
        vatom_parameters: String,
        return_raw_response: Option<bool>,
        context: &C) -> Result<ExecuteActionOnNftResponse, ApiError>;

    /// Search Vatom Geo Map
    async fn geomap_search(
        &self,
        version: f64,
        account_id: i64,
        vatom_parameters: String,
        return_raw_response: Option<bool>,
        context: &C) -> Result<GeomapSearchResponse, ApiError>;

    /// Get Vatom Business Behaviors
    async fn get_business_behaviors(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        return_raw_response: Option<bool>,
        context: &C) -> Result<GetBusinessBehaviorsResponse, ApiError>;

    /// Get the coins for a Business
    async fn get_business_coins_balance(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        return_raw_response: Option<bool>,
        context: &C) -> Result<GetBusinessCoinsBalanceResponse, ApiError>;

    /// Get the user business ids
    async fn get_business_ids(
        &self,
        version: f64,
        account_id: i64,
        return_raw_response: Option<bool>,
        context: &C) -> Result<GetBusinessIdsResponse, ApiError>;

    /// Get Vatom Business Info
    async fn get_business_info(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        vatom_parameters: Option<String>,
        return_raw_response: Option<bool>,
        context: &C) -> Result<GetBusinessInfoResponse, ApiError>;

    /// Get Vatom Business Users
    async fn get_business_users(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        return_raw_response: Option<bool>,
        context: &C) -> Result<GetBusinessUsersResponse, ApiError>;

    /// Get Campaign Group Entities
    async fn get_campaign_group_entities(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        vatom_campaign_id: String,
        return_raw_response: Option<bool>,
        context: &C) -> Result<GetCampaignGroupEntitiesResponse, ApiError>;

    /// Get Campaign Group Rules
    async fn get_campaign_group_rules(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        vatom_campaign_id: String,
        return_raw_response: Option<bool>,
        context: &C) -> Result<GetCampaignGroupRulesResponse, ApiError>;

    /// Get Campaign Group Stats
    async fn get_campaign_group_stats(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        vatom_campaign_id: String,
        return_raw_response: Option<bool>,
        context: &C) -> Result<GetCampaignGroupStatsResponse, ApiError>;

    /// Get Campaign Info
    async fn get_campaign_info(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        vatom_campaign_id: String,
        return_raw_response: Option<bool>,
        context: &C) -> Result<GetCampaignInfoResponse, ApiError>;

    /// Get Vatom Event Guest List
    async fn get_event_guest_list(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        vatom_event_id: String,
        return_raw_response: Option<bool>,
        context: &C) -> Result<GetEventGuestListResponse, ApiError>;

    /// Get Vatom User's Inventory
    async fn get_inventory(
        &self,
        version: f64,
        account_id: i64,
        vatom_parameters: String,
        return_raw_response: Option<bool>,
        context: &C) -> Result<GetInventoryResponse, ApiError>;

    /// Get following
    async fn get_my_following(
        &self,
        version: f64,
        account_id: i64,
        return_raw_response: Option<bool>,
        context: &C) -> Result<GetMyFollowingResponse, ApiError>;

    /// Get Points Balance
    async fn get_points_balance(
        &self,
        version: f64,
        account_id: i64,
        vatom_user_id: String,
        vatom_campaign_id: String,
        return_raw_response: Option<bool>,
        context: &C) -> Result<GetPointsBalanceResponse, ApiError>;

    /// Get Points Balance as Business
    async fn get_points_balance_as_business(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        vatom_user_id: String,
        vatom_campaign_id: String,
        return_raw_response: Option<bool>,
        context: &C) -> Result<GetPointsBalanceAsBusinessResponse, ApiError>;

    /// Get Vatom Space
    async fn get_space(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        vatom_space_id: String,
        return_raw_response: Option<bool>,
        context: &C) -> Result<GetSpaceResponse, ApiError>;

    /// Get the coins for a user (as a Business)
    async fn get_user_coins_as_business(
        &self,
        version: f64,
        account_id: i64,
        vatom_user_id: String,
        app_key: String,
        return_raw_response: Option<bool>,
        context: &C) -> Result<GetUserCoinsAsBusinessResponse, ApiError>;

    /// Gets the coins balance for a Vatom User
    async fn get_user_coins_balance(
        &self,
        version: f64,
        account_id: i64,
        vatom_user_id: String,
        vatom_parameters: Option<String>,
        return_raw_response: Option<bool>,
        context: &C) -> Result<GetUserCoinsBalanceResponse, ApiError>;

    /// Get user followers
    async fn get_user_followers(
        &self,
        version: f64,
        account_id: i64,
        vatom_user_id: String,
        return_raw_response: Option<bool>,
        context: &C) -> Result<GetUserFollowersResponse, ApiError>;

    /// Get user following
    async fn get_user_following(
        &self,
        version: f64,
        account_id: i64,
        vatom_user_id: String,
        return_raw_response: Option<bool>,
        context: &C) -> Result<GetUserFollowingResponse, ApiError>;

    /// Get User Info
    async fn get_user_info(
        &self,
        version: f64,
        account_id: i64,
        vatom_user_id: String,
        return_raw_response: Option<bool>,
        context: &C) -> Result<GetUserInfoResponse, ApiError>;

    /// Get Vatom User Profile
    async fn get_user_profile(
        &self,
        version: f64,
        account_id: i64,
        return_raw_response: Option<bool>,
        context: &C) -> Result<GetUserProfileResponse, ApiError>;

    /// Get Vatom Event
    async fn get_vatom_event(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        vatom_event_id: String,
        return_raw_response: Option<bool>,
        context: &C) -> Result<GetVatomEventResponse, ApiError>;

    /// Get Vatom NFT Details
    async fn get_vatom_nft(
        &self,
        version: f64,
        account_id: i64,
        vatom_id: String,
        return_raw_response: Option<bool>,
        context: &C) -> Result<GetVatomNftResponse, ApiError>;

    /// List Vatom Communities
    async fn list_communities(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        vatom_parameters: Option<String>,
        return_raw_response: Option<bool>,
        context: &C) -> Result<ListCommunitiesResponse, ApiError>;

    /// List Vatom Events
    async fn list_events(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        vatom_parameters: Option<String>,
        return_raw_response: Option<bool>,
        context: &C) -> Result<ListEventsResponse, ApiError>;

    /// List Vatom Spaces
    async fn list_spaces(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        vatom_parameters: Option<String>,
        return_raw_response: Option<bool>,
        context: &C) -> Result<ListSpacesResponse, ApiError>;

    /// List Coin Transactions for a Vatom User
    async fn list_user_coin_transactions(
        &self,
        version: f64,
        account_id: i64,
        vatom_user_id: String,
        vatom_parameters: Option<String>,
        return_raw_response: Option<bool>,
        context: &C) -> Result<ListUserCoinTransactionsResponse, ApiError>;

    /// List coin transactions for a user (as a Business)
    async fn list_user_coin_transactions_as_business(
        &self,
        version: f64,
        account_id: i64,
        vatom_user_id: String,
        app_key: String,
        vatom_parameters: Option<String>,
        return_raw_response: Option<bool>,
        context: &C) -> Result<ListUserCoinTransactionsAsBusinessResponse, ApiError>;

    /// Perform Action on NFT
    async fn perform_action_on_nft(
        &self,
        version: f64,
        account_id: i64,
        vatom_id: String,
        vatom_action: String,
        vatom_parameters: String,
        return_raw_response: Option<bool>,
        context: &C) -> Result<PerformActionOnNftResponse, ApiError>;

    /// Redeem NFT
    async fn redeem_nft(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        vatom_parameters: String,
        return_raw_response: Option<bool>,
        context: &C) -> Result<RedeemNftResponse, ApiError>;

    /// Redeem the coins for a user (as a Business)
    async fn redeem_user_coins_as_business(
        &self,
        version: f64,
        account_id: i64,
        vatom_user_id: String,
        app_key: String,
        vatom_parameters: String,
        return_raw_response: Option<bool>,
        context: &C) -> Result<RedeemUserCoinsAsBusinessResponse, ApiError>;

    /// Search for Vatom Businesses
    async fn search_businesses(
        &self,
        version: f64,
        account_id: i64,
        vatom_parameters: Option<String>,
        return_raw_response: Option<bool>,
        context: &C) -> Result<SearchBusinessesResponse, ApiError>;

    /// Search Campaign Groups
    async fn search_campaign_groups(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        return_raw_response: Option<bool>,
        context: &C) -> Result<SearchCampaignGroupsResponse, ApiError>;

    /// Search User Identities
    async fn search_identities(
        &self,
        version: f64,
        account_id: i64,
        return_raw_response: Option<bool>,
        context: &C) -> Result<SearchIdentitiesResponse, ApiError>;

    /// Search Vatom User's Inventory
    async fn search_inventory(
        &self,
        version: f64,
        account_id: i64,
        vatom_parameters: Option<String>,
        return_raw_response: Option<bool>,
        context: &C) -> Result<SearchInventoryResponse, ApiError>;

    /// Send NFT
    async fn send_nft(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        vatom_campaign_id: String,
        vatom_parameters: String,
        return_raw_response: Option<bool>,
        context: &C) -> Result<SendNftResponse, ApiError>;

    /// Set Points Balance as Business
    async fn set_points_balance_as_business(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        vatom_user_id: String,
        vatom_campaign_id: String,
        vatom_parameters: String,
        return_raw_response: Option<bool>,
        context: &C) -> Result<SetPointsBalanceAsBusinessResponse, ApiError>;

    /// Transfer coins from Vatom Users
    async fn transfer_user_coins(
        &self,
        version: f64,
        account_id: i64,
        vatom_user_id: String,
        vatom_parameters: String,
        return_raw_response: Option<bool>,
        context: &C) -> Result<TransferUserCoinsResponse, ApiError>;

    /// Fund coins for a Business
    async fn update_business_coins(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        vatom_parameters: String,
        return_raw_response: Option<bool>,
        context: &C) -> Result<UpdateBusinessCoinsResponse, ApiError>;

    /// Update Vatom Event Guest List
    async fn update_event_guest_list(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        vatom_event_id: String,
        vatom_parameters: String,
        return_raw_response: Option<bool>,
        context: &C) -> Result<UpdateEventGuestListResponse, ApiError>;

    /// Update Vatom Space
    async fn update_space(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        vatom_space_id: String,
        vatom_parameters: String,
        return_raw_response: Option<bool>,
        context: &C) -> Result<UpdateSpaceResponse, ApiError>;

    /// Update the coins for a user (as a Business)
    async fn update_user_coins_as_business(
        &self,
        version: f64,
        account_id: i64,
        vatom_user_id: String,
        app_key: String,
        vatom_parameters: String,
        return_raw_response: Option<bool>,
        context: &C) -> Result<UpdateUserCoinsAsBusinessResponse, ApiError>;

    /// Update Vatom User Profile
    async fn update_user_profile(
        &self,
        version: f64,
        account_id: i64,
        vatom_parameters: String,
        return_raw_response: Option<bool>,
        context: &C) -> Result<UpdateUserProfileResponse, ApiError>;

    /// Update Vatom Event
    async fn update_vatom_event(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        vatom_event_id: String,
        vatom_parameters: String,
        return_raw_response: Option<bool>,
        context: &C) -> Result<UpdateVatomEventResponse, ApiError>;

    /// Create Vehicle
    async fn create_vehicle(
        &self,
        version: f64,
        vehicle: String,
        body: Option<models::Vehicle>,
        context: &C) -> Result<CreateVehicleResponse, ApiError>;

    /// Search Vehicle
    async fn search_vehicle(
        &self,
        version: f64,
        hub_id: i64,
        sort_field: String,
        descending: bool,
        start: i32,
        limit: i32,
        active_only: bool,
        keyword: Option<String>,
        context: &C) -> Result<SearchVehicleResponse, ApiError>;

    /// Delete Vehicle
    async fn delete_vehicle(
        &self,
        version: f64,
        id: i64,
        context: &C) -> Result<DeleteVehicleResponse, ApiError>;

    /// Get Vehicle
    async fn get_vehicle(
        &self,
        version: f64,
        id: i64,
        context: &C) -> Result<GetVehicleResponse, ApiError>;

    /// Update Vehicle
    async fn update_vehicle(
        &self,
        version: f64,
        id: i64,
        vehicle: String,
        body: Option<models::Vehicle>,
        context: &C) -> Result<UpdateVehicleResponse, ApiError>;

    /// Create Vehicle Type
    async fn create_vehicle_type(
        &self,
        version: f64,
        vehicle_type: String,
        body: Option<models::VehicleType>,
        context: &C) -> Result<CreateVehicleTypeResponse, ApiError>;

    /// Search Vehicle Type
    async fn search_vehicle_types(
        &self,
        version: f64,
        sort_field: String,
        descending: bool,
        start: i32,
        limit: i32,
        active_only: bool,
        retailer_id: Option<i64>,
        hub_id: Option<i64>,
        context: &C) -> Result<SearchVehicleTypesResponse, ApiError>;

    /// Delete Vehicle Type
    async fn delete_vehicle_type(
        &self,
        version: f64,
        vehicle_type_id: i64,
        context: &C) -> Result<DeleteVehicleTypeResponse, ApiError>;

    /// Get Vehicle Type
    async fn get_vehicle_type(
        &self,
        version: f64,
        vehicle_type_id: i64,
        context: &C) -> Result<GetVehicleTypeResponse, ApiError>;

    /// Update Vehicle Type
    async fn update_vehicle_type(
        &self,
        version: f64,
        vehicle_type_id: i64,
        vehicle_type: String,
        body: Option<models::VehicleType>,
        context: &C) -> Result<UpdateVehicleTypeResponse, ApiError>;

    /// Create Wallet Offers
    async fn create_offer_transaction(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        offer_id: Option<i64>,
        offer_location_id: Option<i64>,
        offer_cart: Option<String>,
        promo_code: Option<String>,
        currency_type: Option<String>,
        use_points: Option<bool>,
        meta_data: Option<String>,
        app_key: Option<String>,
        status: Option<i32>,
        context: &C) -> Result<CreateOfferTransactionResponse, ApiError>;

    /// Delete Wallet Offer
    async fn delete_offer_transaction(
        &self,
        version: f64,
        transaction_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        context: &C) -> Result<DeleteOfferTransactionResponse, ApiError>;

    /// Get Wallet Offer
    async fn get_offer_transaction(
        &self,
        version: f64,
        transaction_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        include_mission: Option<bool>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        return_full_response: Option<bool>,
        context: &C) -> Result<GetOfferTransactionResponse, ApiError>;

    /// Preview Wallet Offers
    async fn preview_offer_transaction(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        offer_id: Option<i64>,
        offer_location_id: Option<i64>,
        offer_cart: Option<String>,
        promo_code: Option<String>,
        currency_type: Option<String>,
        use_points: Option<bool>,
        meta_data: Option<String>,
        app_key: Option<String>,
        context: &C) -> Result<PreviewOfferTransactionResponse, ApiError>;

    /// Search Wallet Offers
    async fn search_offer_transactions(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        keyword: Option<String>,
        retailer_id: Option<i64>,
        retailer_ids: Option<String>,
        retailer_location_id: Option<i64>,
        retailer_location_ids: Option<String>,
        exclude_retailer_location_ids: Option<String>,
        offer_id: Option<i64>,
        offer_ids: Option<String>,
        offer_location_id: Option<i64>,
        offer_location_ids: Option<String>,
        offer_type: Option<models::CreateOfferOfferTypeParameter>,
        offer_types: Option<String>,
        special_offer_type: Option<String>,
        special_offer_types: Option<String>,
        category_ids: Option<String>,
        filter_ids: Option<String>,
        offer_audience_ids: Option<String>,
        sort_field: Option<models::SearchOfferTransactionsSortFieldParameter>,
        descending: Option<bool>,
        start: Option<i32>,
        limit: Option<i32>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        redeemable_start_date: Option<i64>,
        redeemable_end_date: Option<i64>,
        filter_by_parent_offer: Option<bool>,
        started_since: Option<i64>,
        started_before: Option<i64>,
        ended_since: Option<i64>,
        ended_before: Option<i64>,
        redeemed: Option<bool>,
        statuses: Option<String>,
        reservations_only: Option<bool>,
        active_only: Option<bool>,
        return_full_response: Option<bool>,
        recurring_started_since: Option<i64>,
        recurring_started_before: Option<i64>,
        recurring_expiration_since: Option<i64>,
        recurring_expiration_before: Option<i64>,
        context: &C) -> Result<SearchOfferTransactionsResponse, ApiError>;

    /// Update Wallet Offer
    async fn update_offer_transaction(
        &self,
        version: f64,
        transaction_id: i64,
        status: i32,
        device_id: Option<String>,
        account_id: Option<i64>,
        offer_location_id: Option<i64>,
        currency_type: Option<String>,
        use_points: Option<bool>,
        app_key: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        meta_data: Option<String>,
        return_full_response: Option<bool>,
        exception_membership_offer_ids: Option<String>,
        context: &C) -> Result<UpdateOfferTransactionResponse, ApiError>;

    /// Search Weather
    async fn search_weather(
        &self,
        version: f64,
        region_id: Option<i64>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        timezone_offset: Option<i64>,
        context: &C) -> Result<SearchWeatherResponse, ApiError>;

    /// Create Word
    async fn create_word(
        &self,
        version: f64,
        account_id: i64,
        word: String,
        definition: String,
        active: bool,
        allocate_tickets: bool,
        ticket_count: i64,
        asset_id: Option<i64>,
        ticket_type: Option<String>,
        points: Option<i64>,
        context: &C) -> Result<CreateWordResponse, ApiError>;

    /// Delete Word
    async fn delete_word(
        &self,
        version: f64,
        word_id: i64,
        account_id: i64,
        context: &C) -> Result<DeleteWordResponse, ApiError>;

    /// Get Word
    async fn get_word(
        &self,
        version: f64,
        word_id: i64,
        account_id: i64,
        context: &C) -> Result<GetWordResponse, ApiError>;

    /// Search Words
    async fn get_words(
        &self,
        version: f64,
        account_id: i64,
        sort_field: String,
        descending: bool,
        active_only: bool,
        start: i32,
        limit: i32,
        keyword: Option<String>,
        context: &C) -> Result<GetWordsResponse, ApiError>;

    /// Update Word
    async fn update_word(
        &self,
        version: f64,
        word_id: i64,
        account_id: i64,
        ticket_count: i64,
        word_text: Option<String>,
        definition: Option<String>,
        asset_id: Option<i64>,
        active: Option<bool>,
        allocate_tickets: Option<bool>,
        ticket_type: Option<String>,
        points: Option<i64>,
        context: &C) -> Result<UpdateWordResponse, ApiError>;

    /// Run Workflow
    async fn run_workflow(
        &self,
        version: f64,
        account_id: i64,
        workflow_id: i64,
        sku_id: Option<i64>,
        version_code: Option<i32>,
        parameters: Option<String>,
        context: &C) -> Result<RunWorkflowResponse, ApiError>;

}

/// API where `Context` isn't passed on every API call
#[cfg_attr(feature = "mock", automock)]
#[async_trait]
#[allow(clippy::too_many_arguments, clippy::ptr_arg)]
pub trait ApiNoContext<C: Send + Sync> {
    // The std::task::Context struct houses a reference to std::task::Waker with the lifetime <'a>.
    // Adding an anonymous lifetime `'a` to allow mockall to create a mock object with the right lifetimes.
    // This is needed because the compiler is unable to determine the lifetimes on F's trait bound
    // where F is the closure created by mockall. We use higher-rank trait bounds here to get around this.

    fn context(&self) -> &C;

    /// Create Consumer
    async fn consumer_create(
        &self,
        version: f64,
        app_key: String,
        name: String,
        hostname: String,
        username: String,
        password: String,
        data_mapping: String,
        device_id: Option<String>,
        account_id: Option<i64>,
        port: Option<i32>,
        virtual_host: Option<String>,
        exchanger: Option<String>,
        exchanger_type: Option<String>,
        workers: Option<i32>,
        use_ssl: Option<bool>,
        ) -> Result<ConsumerCreateResponse, ApiError>;

    /// Update Consumer
    async fn consumer_update(
        &self,
        version: f64,
        app_key: String,
        queue_id: i64,
        data_mapping: String,
        device_id: Option<String>,
        account_id: Option<i64>,
        use_ssl: Option<bool>,
        ) -> Result<ConsumerUpdateResponse, ApiError>;

    /// Create Queue
    async fn queue_create(
        &self,
        version: f64,
        app_key: String,
        name: String,
        device_id: Option<String>,
        account_id: Option<i64>,
        workers: Option<i32>,
        analytic_tags: Option<String>,
        hostname: Option<String>,
        port: Option<i32>,
        username: Option<String>,
        password: Option<String>,
        virtual_host: Option<String>,
        use_ssl: Option<bool>,
        ) -> Result<QueueCreateResponse, ApiError>;

    /// Delete Queue
    async fn queue_delete(
        &self,
        version: f64,
        queue_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        ) -> Result<QueueDeleteResponse, ApiError>;

    /// Get Queue
    async fn queue_get(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        queue_id: Option<i64>,
        app_key: Option<String>,
        name: Option<String>,
        hostname: Option<String>,
        virtual_host: Option<String>,
        ) -> Result<QueueGetResponse, ApiError>;

    /// Publish Queue
    async fn queue_publish(
        &self,
        version: f64,
        message: String,
        queue_id: Option<i64>,
        app_key: Option<String>,
        name: Option<String>,
        hostname: Option<String>,
        virtual_host: Option<String>,
        ) -> Result<QueuePublishResponse, ApiError>;

    /// Search Queue
    async fn queue_search(
        &self,
        version: f64,
        queue_id: Option<i64>,
        device_id: Option<String>,
        account_id: Option<i64>,
        name: Option<String>,
        start: Option<i32>,
        limit: Option<i32>,
        ) -> Result<QueueSearchResponse, ApiError>;

    /// Update Queue
    async fn queue_update(
        &self,
        version: f64,
        queue_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        app_key: Option<String>,
        workers: Option<i32>,
        analytic_tags: Option<String>,
        hostname: Option<String>,
        port: Option<i32>,
        username: Option<String>,
        password: Option<String>,
        virtual_host: Option<String>,
        use_ssl: Option<bool>,
        ) -> Result<QueueUpdateResponse, ApiError>;

    /// Search Accounts by Location
    async fn account_location_search(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        q: Option<String>,
        keyword: Option<String>,
        postal_code: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        app_key: Option<String>,
        range: Option<f64>,
        location_last_updated: Option<i64>,
        gender: Option<String>,
        min_age: Option<i32>,
        max_age: Option<i32>,
        companionship_index: Option<i32>,
        _i: Option<i32>,
        start: Option<i32>,
        _l: Option<i32>,
        limit: Option<i32>,
        search_mode: Option<String>,
        sort_field: Option<String>,
        descending: Option<bool>,
        roles: Option<String>,
        tags: Option<String>,
        experience: Option<String>,
        category_ids: Option<String>,
        audience_ids: Option<String>,
        audience_operator: Option<String>,
        update_current_location: Option<bool>,
        update_preferred_settings: Option<bool>,
        show_exact_locations: Option<bool>,
        show_connection_to_searcher: Option<bool>,
        flag_count_minimum: Option<i64>,
        verified_user_only: Option<bool>,
        content_admin_only: Option<bool>,
        ) -> Result<AccountLocationSearchResponse, ApiError>;

    /// Block Account
    async fn block_account(
        &self,
        version: f64,
        account_id_being_blocked: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        block_flag_value: Option<bool>,
        remove_from_groups_if_blocked: Option<bool>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        ) -> Result<BlockAccountResponse, ApiError>;

    /// Create Account
    async fn create_account(
        &self,
        version: f64,
        username: String,
        password: String,
        name: Option<String>,
        prefix_name: Option<String>,
        first_name: Option<String>,
        middle_name: Option<String>,
        last_name: Option<String>,
        suffix_name: Option<String>,
        title: Option<String>,
        device_id: Option<String>,
        device_id_type: Option<String>,
        email_address: Option<String>,
        asset_id: Option<i64>,
        street_address: Option<String>,
        zipcode: Option<String>,
        gender: Option<String>,
        birthday: Option<i64>,
        home_phone: Option<String>,
        cell_phone: Option<String>,
        cell_phone_carrier: Option<String>,
        business_phone: Option<String>,
        role: Option<String>,
        platforms: Option<String>,
        tags: Option<String>,
        about_us: Option<String>,
        game_experience: Option<String>,
        category_ids: Option<String>,
        hometown: Option<String>,
        height: Option<String>,
        height_index: Option<i32>,
        ethnicity: Option<String>,
        body_type: Option<String>,
        marital_status: Option<String>,
        children: Option<String>,
        religion: Option<String>,
        education: Option<String>,
        education_index: Option<i32>,
        smoke: Option<String>,
        drink: Option<String>,
        companionship: Option<String>,
        companionship_index: Option<i32>,
        preferred_min_age: Option<i32>,
        preferred_max_age: Option<i32>,
        preferred_min_height: Option<i32>,
        preferred_max_height: Option<i32>,
        preferred_gender: Option<String>,
        preferred_education: Option<String>,
        preferred_education_index: Option<i32>,
        preferred_body_type: Option<String>,
        preferred_ethnicity: Option<String>,
        preferred_location: Option<String>,
        preferred_location_range: Option<f64>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        accepted_terms: Option<bool>,
        invite_token: Option<String>,
        referral_account_id: Option<i64>,
        send_validation: Option<bool>,
        game_type: Option<String>,
        app_key: Option<String>,
        app_version: Option<String>,
        response_type: Option<String>,
        audience_ids_to_add: Option<String>,
        app_blob: Option<String>,
        app_enable_push: Option<bool>,
        app_enable_sms: Option<bool>,
        app_enable_email: Option<bool>,
        location_visibility: Option<String>,
        home_latitude: Option<f64>,
        home_longitude: Option<f64>,
        app_nickname: Option<String>,
        personal_audience_id: Option<i64>,
        ) -> Result<CreateAccountResponse, ApiError>;

    /// Update Account
    async fn edit_account(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        connection_account_id: Option<i64>,
        role: Option<String>,
        asset_id: Option<i64>,
        name: Option<String>,
        prefix_name: Option<String>,
        first_name: Option<String>,
        middle_name: Option<String>,
        last_name: Option<String>,
        suffix_name: Option<String>,
        title: Option<String>,
        gender: Option<String>,
        age: Option<i32>,
        birthday: Option<i64>,
        home_phone: Option<String>,
        cell_phone: Option<String>,
        cell_phone_carrier: Option<String>,
        business_phone: Option<String>,
        email_address: Option<String>,
        street_address: Option<String>,
        street_address2: Option<String>,
        city: Option<String>,
        state: Option<String>,
        zipcode: Option<String>,
        country: Option<String>,
        make_profile_info_public: Option<bool>,
        make_game_info_public: Option<bool>,
        make_friends_info_public: Option<bool>,
        hometown: Option<String>,
        height: Option<String>,
        height_index: Option<i32>,
        ethnicity: Option<String>,
        body_type: Option<String>,
        marital_status: Option<String>,
        children: Option<String>,
        religion: Option<String>,
        education: Option<String>,
        education_index: Option<i32>,
        smoke: Option<String>,
        drink: Option<String>,
        companionship: Option<String>,
        companionship_index: Option<i32>,
        preferred_min_age: Option<i32>,
        preferred_max_age: Option<i32>,
        preferred_min_height: Option<i32>,
        preferred_max_height: Option<i32>,
        preferred_gender: Option<String>,
        preferred_education: Option<String>,
        preferred_education_index: Option<i32>,
        preferred_body_type: Option<String>,
        preferred_ethnicity: Option<String>,
        preferred_location: Option<String>,
        preferred_location_range: Option<f64>,
        platforms: Option<String>,
        tags: Option<String>,
        about_us: Option<String>,
        match_token: Option<String>,
        game_experience: Option<String>,
        categories: Option<String>,
        category_ids: Option<String>,
        response_filters: Option<String>,
        show_as_zipcode: Option<bool>,
        show_exact_location: Option<bool>,
        show_others_exact_location: Option<bool>,
        accepted_terms: Option<bool>,
        location_visibility: Option<String>,
        app_blob: Option<String>,
        app_enable_push: Option<bool>,
        app_enable_sms: Option<bool>,
        app_enable_email: Option<bool>,
        game_type: Option<String>,
        app_key: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        return_profile: Option<bool>,
        audience_ids_to_add: Option<String>,
        audience_ids_to_remove: Option<String>,
        referral_account_id: Option<i64>,
        app_nickname: Option<String>,
        personal_audience_id: Option<i64>,
        non_guest_username: Option<String>,
        ) -> Result<EditAccountResponse, ApiError>;

    /// Update Username and Email
    async fn edit_username(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        email_address: Option<String>,
        username: Option<String>,
        ) -> Result<EditUsernameResponse, ApiError>;

    /// Get Account
    async fn get_account(
        &self,
        version: f64,
        return_nulls: Option<bool>,
        device_id: Option<String>,
        account_id: Option<i64>,
        connection_account_email: Option<String>,
        connection_account_id: Option<i64>,
        response_filters: Option<String>,
        game_type: Option<String>,
        app_key: Option<String>,
        purchase_type: Option<String>,
        update_viewed_date: Option<bool>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        ) -> Result<GetAccountResponse, ApiError>;

    /// Get Profile Assets
    async fn get_profile_assets(
        &self,
        version: f64,
        return_nulls: Option<bool>,
        device_id: Option<String>,
        account_id: Option<i64>,
        owner_id: Option<i64>,
        media_types: Option<String>,
        mime_types: Option<String>,
        sort_field: Option<String>,
        descending: Option<bool>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        _i: Option<i32>,
        start: Option<i32>,
        _l: Option<i32>,
        limit: Option<i32>,
        ) -> Result<GetProfileAssetsResponse, ApiError>;

    /// Search Accounts
    async fn get_referral_list(
        &self,
        version: f64,
        account_id: Option<i64>,
        app_key: Option<String>,
        retrieve_type: Option<String>,
        level_limit: Option<f64>,
        ancestor_level_limit: Option<f64>,
        children_level_limit: Option<f64>,
        ancestor_list_start: Option<f64>,
        ancestor_list_limit: Option<f64>,
        children_list_start: Option<f64>,
        children_list_limit: Option<f64>,
        children_children: Option<bool>,
        ) -> Result<GetReferralListResponse, ApiError>;

    /// Get Account Settings
    async fn get_settings(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        ) -> Result<GetSettingsResponse, ApiError>;

    /// Login as Account
    async fn login_delegate(
        &self,
        version: f64,
        access_token: String,
        app_key: String,
        device_id: Option<String>,
        access_token_secret: Option<String>,
        delegated_account_id: Option<i64>,
        delegated_username: Option<String>,
        network_uid: Option<String>,
        age_restriction: Option<i32>,
        response_filters: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        ) -> Result<LoginDelegateResponse, ApiError>;

    /// Login Account
    async fn login_general(
        &self,
        version: f64,
        access_token: String,
        network_uid: String,
        app_key: String,
        device_id: Option<String>,
        device_id_type: Option<String>,
        access_token_secret: Option<String>,
        age_restriction: Option<i32>,
        response_filters: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        email_match: Option<bool>,
        chosen_account_id: Option<i64>,
        third_party_credential_id: Option<i64>,
        ) -> Result<LoginGeneralResponse, ApiError>;

    /// Login Account (Username)
    async fn login_username(
        &self,
        version: f64,
        username: String,
        password: String,
        device_id: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        app: Option<String>,
        game_type: Option<String>,
        app_key: Option<String>,
        return_profile: Option<bool>,
        response_filters: Option<String>,
        ) -> Result<LoginUsernameResponse, ApiError>;

    /// Logout Account
    async fn logout(
        &self,
        version: f64,
        device_id: Option<String>,
        device_id_type: Option<String>,
        account_id: Option<i64>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        ) -> Result<LogoutResponse, ApiError>;

    /// Merge Account
    async fn merge_account(
        &self,
        version: f64,
        merge_account_id: i64,
        app_key: String,
        device_id: Option<String>,
        account_id: Option<i64>,
        ) -> Result<MergeAccountResponse, ApiError>;

    /// Update Password
    async fn password_change(
        &self,
        version: f64,
        account_id: i64,
        old_password: String,
        new_password: String,
        confirm_password: String,
        ) -> Result<PasswordChangeResponse, ApiError>;

    /// Reset Password
    async fn password_reset(
        &self,
        version: f64,
        token: String,
        password: String,
        confirm: String,
        ) -> Result<PasswordResetResponse, ApiError>;

    /// Request Password Reset
    async fn request_password_reset(
        &self,
        version: f64,
        email: String,
        from: Option<String>,
        domain: Option<String>,
        sub_url: Option<String>,
        referer: Option<String>,
        ) -> Result<RequestPasswordResetResponse, ApiError>;

    /// Send Validation Request
    async fn request_validate_account(
        &self,
        version: f64,
        account_id: i64,
        ) -> Result<RequestValidateAccountResponse, ApiError>;

    /// Search Accounts
    async fn search_accounts(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        keyword: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        radius: Option<f64>,
        gender: Option<models::SearchAccountsGenderParameter>,
        game_experience: Option<models::SearchAccountsGameExperienceParameter>,
        age: Option<i32>,
        category_ids: Option<String>,
        return_nulls: Option<bool>,
        response_filters: Option<String>,
        purchase_type: Option<String>,
        sort_field: Option<String>,
        descending: Option<bool>,
        start: Option<i32>,
        limit: Option<i32>,
        active_only: Option<bool>,
        ) -> Result<SearchAccountsResponse, ApiError>;

    /// Login Account (Encrypted Username)
    async fn secure_login(
        &self,
        version: f64,
        username: String,
        password: String,
        game_type: String,
        device_id: Option<String>,
        charset_name: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        return_profile: Option<bool>,
        response_filters: Option<String>,
        ) -> Result<SecureLoginResponse, ApiError>;

    /// Create Account (Encrypted Username)
    async fn secure_signup(
        &self,
        version: f64,
        device_id: String,
        username: String,
        password: String,
        name: Option<String>,
        invite_token: Option<String>,
        prefix_name: Option<String>,
        first_name: Option<String>,
        middle_name: Option<String>,
        last_name: Option<String>,
        suffix_name: Option<String>,
        title: Option<String>,
        device_id_type: Option<String>,
        email_address: Option<String>,
        asset_id: Option<i64>,
        address: Option<String>,
        zipcode: Option<String>,
        gender: Option<String>,
        birthday: Option<i64>,
        home_phone: Option<String>,
        cell_phone: Option<String>,
        cell_phone_carrier: Option<String>,
        business_phone: Option<String>,
        role: Option<String>,
        platforms: Option<String>,
        tags: Option<String>,
        about_us: Option<String>,
        game_experience: Option<String>,
        category_ids: Option<String>,
        hometown: Option<String>,
        height: Option<String>,
        height_index: Option<i32>,
        ethnicity: Option<String>,
        body_type: Option<String>,
        marital_status: Option<String>,
        children: Option<String>,
        religion: Option<String>,
        education: Option<String>,
        education_index: Option<i32>,
        smoke: Option<String>,
        drink: Option<String>,
        companionship: Option<String>,
        companionship_index: Option<i32>,
        preferred_min_age: Option<i32>,
        preferred_max_age: Option<i32>,
        preferred_min_height: Option<i32>,
        preferred_max_height: Option<i32>,
        preferred_gender: Option<String>,
        preferred_education: Option<String>,
        preferred_education_index: Option<i32>,
        preferred_body_type: Option<String>,
        preferred_ethnicity: Option<String>,
        preferred_location: Option<String>,
        preferred_location_range: Option<f64>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        accepted_terms: Option<bool>,
        charset_name: Option<String>,
        game_type: Option<String>,
        app_key: Option<String>,
        app_version: Option<String>,
        response_type: Option<String>,
        ) -> Result<SecureSignupResponse, ApiError>;

    /// Save Match Token
    async fn set_match_token(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        match_token: Option<String>,
        game_type: Option<String>,
        app_key: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        ) -> Result<SetMatchTokenResponse, ApiError>;

    /// Update Account Active Status
    async fn update_actve_status(
        &self,
        version: f64,
        account_id: i64,
        connection_account_id: i64,
        active: bool,
        device_id: Option<String>,
        app_key: Option<String>,
        ) -> Result<UpdateActveStatusResponse, ApiError>;

    /// Update Location
    async fn update_location(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        client_time: Option<i64>,
        ) -> Result<UpdateLocationResponse, ApiError>;

    /// Update Account Settings
    async fn update_settings(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        blocked_notifications: Option<String>,
        suggestion_method: Option<String>,
        suggestion_count: Option<i32>,
        suggestion_time_frame: Option<i32>,
        show_others_exact_location: Option<bool>,
        show_as_zipcode: Option<bool>,
        show_exact_location: Option<bool>,
        favorite_visibility: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        ) -> Result<UpdateSettingsResponse, ApiError>;

    /// Save Validation Status
    async fn validate_account_signup(
        &self,
        version: f64,
        token: String,
        ) -> Result<ValidateAccountSignupResponse, ApiError>;

    /// Validate Password Reset Token
    async fn validate_password_reset(
        &self,
        version: f64,
        token: String,
        ) -> Result<ValidatePasswordResetResponse, ApiError>;

    /// Searches an Achievement Tier
    async fn api_version_achievement_tier_search_post(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        app_key: Option<String>,
        keyword: Option<String>,
        achievement_type: Option<i64>,
        rank_type: Option<String>,
        sort_field: Option<String>,
        descending: Option<bool>,
        descending_goal: Option<bool>,
        start: Option<i64>,
        limit: Option<i64>,
        ) -> Result<ApiVersionAchievementTierSearchPostResponse, ApiError>;

    /// Create Achievement
    async fn create_achievement(
        &self,
        version: f64,
        app_key: String,
        title: String,
        device_id: Option<String>,
        account_id: Option<i64>,
        analytics_tag: Option<String>,
        description: Option<String>,
        rank_type: Option<String>,
        rank_increment: Option<i32>,
        min_increment: Option<i32>,
        max_increment: Option<i32>,
        validate: Option<bool>,
        active: Option<bool>,
        trigger_definition: Option<String>,
        ) -> Result<CreateAchievementResponse, ApiError>;

    /// Create Achievement Tier
    async fn create_achievement_tier(
        &self,
        version: f64,
        achievement_id: i64,
        score_all_instances: bool,
        device_id: Option<String>,
        account_id: Option<i64>,
        icon: Option<swagger::ByteArray>,
        icon_asset_id: Option<i64>,
        title: Option<String>,
        description: Option<String>,
        goal_count: Option<i64>,
        mission_id: Option<i64>,
        game_id: Option<i64>,
        pack_id: Option<i64>,
        game_level_id: Option<i64>,
        game_object_id: Option<i32>,
        ) -> Result<CreateAchievementTierResponse, ApiError>;

    /// Delete Achievement
    async fn delete_achievement(
        &self,
        version: f64,
        achievement_id: i64,
        account_id: Option<i64>,
        ) -> Result<DeleteAchievementResponse, ApiError>;

    /// Delete Achievement Tier
    async fn delete_achievement_tier(
        &self,
        version: f64,
        achievement_tier_id: i64,
        account_id: Option<i64>,
        ) -> Result<DeleteAchievementTierResponse, ApiError>;

    /// Get Achievement
    async fn get_achievement(
        &self,
        version: f64,
        achievement_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        achievement_type: Option<String>,
        ) -> Result<GetAchievementResponse, ApiError>;

    /// Gets an achievement tier
    async fn get_achievement_tier(
        &self,
        version: f64,
        account_id: i64,
        achievement_tier_id: i64,
        ) -> Result<GetAchievementTierResponse, ApiError>;

    /// Get Achievement Progress
    async fn get_user_achievements(
        &self,
        version: f64,
        return_nulls: bool,
        app_key: String,
        include_undiscovered: bool,
        device_id: Option<String>,
        account_id: Option<i64>,
        connection_account_email: Option<String>,
        connection_account_id: Option<i64>,
        rank_type: Option<String>,
        achievement_type: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        ) -> Result<GetUserAchievementsResponse, ApiError>;

    /// List Achievement Tags
    async fn list_achievement_tags(
        &self,
        version: f64,
        app_key: Option<String>,
        ) -> Result<ListAchievementTagsResponse, ApiError>;

    /// List Achievements
    async fn list_achievements(
        &self,
        version: f64,
        sort_field: models::ListAchievementsSortFieldParameter,
        descending: bool,
        start: i32,
        limit: i32,
        active_only: bool,
        device_id: Option<String>,
        account_id: Option<i64>,
        app_key: Option<String>,
        keyword: Option<String>,
        achievement_type: Option<String>,
        rank_type: Option<String>,
        ) -> Result<ListAchievementsResponse, ApiError>;

    /// Search Achievements
    async fn search_achievements(
        &self,
        version: f64,
        app_key: String,
        sort_field: models::SearchAchievementsSortFieldParameter,
        descending: bool,
        include_tiers: bool,
        include_inactive_tiers: bool,
        start: i32,
        limit: i32,
        device_id: Option<String>,
        account_id: Option<i64>,
        keyword: Option<String>,
        achievement_type: Option<String>,
        rank_type: Option<String>,
        ) -> Result<SearchAchievementsResponse, ApiError>;

    /// Update Achievement
    async fn update_achievement(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        achievement_id: Option<i64>,
        analytics_tag: Option<String>,
        title: Option<String>,
        description: Option<String>,
        rank_type: Option<String>,
        rank_increment: Option<i32>,
        min_increment: Option<i32>,
        null_min_increment: Option<bool>,
        max_increment: Option<i32>,
        null_max_increment: Option<bool>,
        validate: Option<bool>,
        active: Option<bool>,
        trigger_definition: Option<String>,
        ) -> Result<UpdateAchievementResponse, ApiError>;

    /// Update Achievement Tier
    async fn update_achievement_tier(
        &self,
        version: f64,
        achievement_tier_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        icon: Option<swagger::ByteArray>,
        icon_asset_id: Option<i64>,
        title: Option<String>,
        description: Option<String>,
        goal_count: Option<i64>,
        mission_id: Option<i64>,
        game_id: Option<i64>,
        pack_id: Option<i64>,
        game_level_id: Option<i64>,
        game_object_id: Option<i64>,
        score_all_instances: Option<bool>,
        ) -> Result<UpdateAchievementTierResponse, ApiError>;

    /// Update Achievement Progress
    async fn update_user_achievement(
        &self,
        version: f64,
        account_id: i64,
        achievement_id: Option<i64>,
        tag: Option<String>,
        custom_id: Option<i64>,
        increment: Option<i64>,
        start_date: Option<i64>,
        end_date: Option<i64>,
        return_progress: Option<bool>,
        ) -> Result<UpdateUserAchievementResponse, ApiError>;

    /// Create an entity reference.
    async fn create_entity_reference(
        &self,
        version: f64,
        body: models::EntityReference,
        ) -> Result<CreateEntityReferenceResponse, ApiError>;

    /// Create Album
    async fn add_album_collection(
        &self,
        version: f64,
        title: String,
        cover_asset_nullable: bool,
        include_cover_in_asset_list: bool,
        public_read: bool,
        public_write: bool,
        public_delete: bool,
        public_add: bool,
        anonymous: bool,
        device_id: Option<String>,
        account_id: Option<i64>,
        assets_to_add: Option<String>,
        media: Option<swagger::ByteArray>,
        media_url: Option<String>,
        asset_id: Option<i64>,
        attached_media: Option<swagger::ByteArray>,
        attached_media_url: Option<String>,
        start_date: Option<i64>,
        end_date: Option<i64>,
        tags: Option<String>,
        description: Option<String>,
        album_type: Option<String>,
        album_type_id: Option<i64>,
        sub_type: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        location_description: Option<String>,
        visibility: Option<models::AddAlbumCollectionVisibilityParameter>,
        game_type: Option<String>,
        app_key: Option<String>,
        cell_phone: Option<String>,
        street_address: Option<String>,
        street_address2: Option<String>,
        city: Option<String>,
        state: Option<String>,
        postal_code: Option<String>,
        full_address: Option<String>,
        meta_data: Option<String>,
        category_ids: Option<String>,
        category_filter_ids: Option<String>,
        audience_ids: Option<String>,
        include_all_app_users_as_members: Option<bool>,
        include_audiences_as_members: Option<bool>,
        audience_operator: Option<String>,
        approval_status: Option<models::ApproveAlbumApprovalStatusParameter>,
        linked_object_type: Option<String>,
        linked_object_id: Option<i64>,
        ) -> Result<AddAlbumCollectionResponse, ApiError>;

    /// Add Album Users
    async fn add_album_users(
        &self,
        version: f64,
        album_id: i64,
        include_friend_group: bool,
        device_id: Option<String>,
        account_id: Option<i64>,
        read: Option<bool>,
        write: Option<bool>,
        delete: Option<bool>,
        add: Option<bool>,
        connections: Option<String>,
        connection_groups: Option<String>,
        ) -> Result<AddAlbumUsersResponse, ApiError>;

    /// Approve Album
    async fn approve_album(
        &self,
        version: f64,
        album_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        approval_status: Option<models::ApproveAlbumApprovalStatusParameter>,
        verified: Option<bool>,
        ) -> Result<ApproveAlbumResponse, ApiError>;

    ///  Get Album
    async fn get_album_collection(
        &self,
        version: f64,
        return_nulls: bool,
        album_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        like_preview_size: Option<i32>,
        asset_preview_size: Option<i32>,
        note_preview_size: Option<i32>,
        connection_preview_size: Option<i32>,
        audience_preview_size: Option<i32>,
        ) -> Result<GetAlbumCollectionResponse, ApiError>;

    /// Leave Album
    async fn leave_album(
        &self,
        version: f64,
        album_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        ) -> Result<LeaveAlbumResponse, ApiError>;

    /// Delete Album
    async fn remove_album(
        &self,
        version: f64,
        album_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        ) -> Result<RemoveAlbumResponse, ApiError>;

    /// Remove Album Users
    async fn remove_album_users(
        &self,
        version: f64,
        album_id: i64,
        remove_friend_group: bool,
        device_id: Option<String>,
        account_id: Option<i64>,
        connections: Option<String>,
        connection_groups: Option<String>,
        ) -> Result<RemoveAlbumUsersResponse, ApiError>;

    /// Search Albums
    async fn search_albums(
        &self,
        version: f64,
        filter: String,
        album_type_id: i64,
        sub_type: String,
        include_inactive: bool,
        sort_field: String,
        descending: bool,
        start: i32,
        limit: i32,
        range: f64,
        include_liked: bool,
        include_favorited: bool,
        include_permissions: bool,
        like_preview_size: i32,
        asset_preview_size: i32,
        note_preview_size: i32,
        connection_preview_size: i32,
        audience_preview_size: i32,
        device_id: Option<String>,
        account_id: Option<i64>,
        connection_account_id: Option<i64>,
        owner_id: Option<i64>,
        album_ids: Option<String>,
        exclude_album_ids: Option<String>,
        media_id: Option<i64>,
        keyword: Option<String>,
        album_type: Option<String>,
        limit_per_album_type: Option<i32>,
        date_created: Option<i64>,
        updated_since: Option<i64>,
        updated_before: Option<i64>,
        created_since: Option<i64>,
        created_before: Option<i64>,
        started_since: Option<i64>,
        started_before: Option<i64>,
        ended_since: Option<i64>,
        ended_before: Option<i64>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        app_key: Option<String>,
        category_ids: Option<String>,
        category_filter_ids: Option<String>,
        audience_ids: Option<String>,
        exclude_audience_ids: Option<String>,
        include_completable: Option<bool>,
        include_rating: Option<bool>,
        search_mode: Option<String>,
        stack_search: Option<bool>,
        stack_window_size: Option<i32>,
        min_stack_per_page: Option<i32>,
        stack_pagination_identifier: Option<String>,
        stack_details: Option<bool>,
        flag_count_minimum: Option<i64>,
        remove_flagged_content: Option<bool>,
        verified_filter: Option<bool>,
        linked_object_type: Option<String>,
        linked_object_id: Option<i64>,
        order_audience_id: Option<i64>,
        ignore_default_app_filter: Option<bool>,
        search_expression: Option<String>,
        generate_albums: Option<bool>,
        ) -> Result<SearchAlbumsResponse, ApiError>;

    /// Update Album
    async fn update_album_collection(
        &self,
        version: f64,
        album_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        assets_to_add: Option<String>,
        assets_to_remove: Option<String>,
        asset_id: Option<i64>,
        media: Option<swagger::ByteArray>,
        media_url: Option<String>,
        active: Option<bool>,
        title: Option<String>,
        start_date: Option<i64>,
        end_date: Option<i64>,
        tags: Option<String>,
        description: Option<String>,
        album_type: Option<String>,
        album_type_id: Option<i64>,
        sub_type: Option<String>,
        public_read: Option<bool>,
        public_write: Option<bool>,
        public_delete: Option<bool>,
        public_add: Option<bool>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        location_description: Option<String>,
        visibility: Option<models::AddAlbumCollectionVisibilityParameter>,
        cell_phone: Option<String>,
        street_address: Option<String>,
        street_address2: Option<String>,
        city: Option<String>,
        state: Option<String>,
        postal_code: Option<String>,
        full_address: Option<String>,
        anonymous: Option<bool>,
        meta_data: Option<String>,
        category_ids: Option<String>,
        category_filter_ids: Option<String>,
        audience_ids: Option<String>,
        audience_ids_to_add: Option<String>,
        audience_ids_to_remove: Option<String>,
        include_all_app_users_as_members: Option<bool>,
        include_audiences_as_members: Option<bool>,
        audience_operator: Option<String>,
        linked_object_type: Option<String>,
        linked_object_id: Option<i64>,
        index_now: Option<bool>,
        ) -> Result<UpdateAlbumCollectionResponse, ApiError>;

    /// Get User Activity
    async fn activities(
        &self,
        version: f64,
        start: i32,
        limit: i32,
        account_id: i64,
        ) -> Result<ActivitiesResponse, ApiError>;

    /// Get Aggregated Filtered Usage
    async fn aggregated_filtered_usage(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        application_id: Option<i64>,
        app_key: Option<String>,
        start_date: Option<i64>,
        end_date: Option<i64>,
        device_type: Option<String>,
        device: Option<String>,
        device_os: Option<String>,
        gender: Option<String>,
        age_group: Option<String>,
        country: Option<String>,
        state: Option<String>,
        city: Option<String>,
        zip: Option<String>,
        model: Option<String>,
        tag: Option<String>,
        user_account_id: Option<i64>,
        user_account_display: Option<String>,
        user_account_username: Option<String>,
        group_by_root: Option<models::AggregatedFilteredUsageGroupByRootParameter>,
        group_by: Option<models::AggregatedFilteredUsageGroupByRootParameter>,
        distinct_count: Option<models::AggregatedFilteredUsageGroupByRootParameter>,
        sort_field: Option<models::AggregatedFilteredUsageGroupByRootParameter>,
        descending: Option<bool>,
        hide_unknown: Option<bool>,
        response_format: Option<models::AggregatedFilteredUsageResponseFormatParameter>,
        _l: Option<i32>,
        limit: Option<i32>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        ) -> Result<AggregatedFilteredUsageResponse, ApiError>;

    /// Get Filtered Usage
    async fn filtered_usage(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        application_id: Option<i64>,
        app_key: Option<String>,
        start_date: Option<i64>,
        end_date: Option<i64>,
        device_type: Option<String>,
        device: Option<String>,
        device_os: Option<String>,
        gender: Option<String>,
        age_group: Option<String>,
        country: Option<String>,
        state: Option<String>,
        city: Option<String>,
        zip: Option<String>,
        model: Option<String>,
        tag: Option<String>,
        user_account_id: Option<i64>,
        user_account_display: Option<String>,
        user_account_username: Option<String>,
        custom_id: Option<i64>,
        custom_type: Option<String>,
        custom_value: Option<f64>,
        custom_value2: Option<f64>,
        custom_long: Option<i64>,
        custom_long2: Option<i64>,
        custom_message: Option<String>,
        custom_message2: Option<String>,
        group_by: Option<models::AggregatedFilteredUsageGroupByRootParameter>,
        distinct_count: Option<models::AggregatedFilteredUsageGroupByRootParameter>,
        sum_column: Option<models::AggregatedFilteredUsageGroupByRootParameter>,
        sort_field: Option<models::AggregatedFilteredUsageGroupByRootParameter>,
        descending: Option<bool>,
        hide_unknown: Option<bool>,
        response_format: Option<models::AggregatedFilteredUsageResponseFormatParameter>,
        _l: Option<i32>,
        limit: Option<i32>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        ) -> Result<FilteredUsageResponse, ApiError>;

    /// Create Usage Record
    async fn usage(
        &self,
        version: f64,
        tag: String,
        device_id: Option<String>,
        account_id: Option<i64>,
        application_id: Option<i64>,
        app_key: Option<String>,
        app_version: Option<String>,
        device: Option<String>,
        device_type: Option<String>,
        device_os: Option<String>,
        model: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        custom_id: Option<i64>,
        custom_type: Option<String>,
        achievement_increment: Option<i64>,
        city: Option<String>,
        state: Option<String>,
        country: Option<String>,
        zip: Option<String>,
        location_description: Option<String>,
        client_time: Option<i64>,
        error_message: Option<String>,
        ip: Option<String>,
        user_agent: Option<String>,
        background_event: Option<bool>,
        custom_message: Option<String>,
        custom_message2: Option<String>,
        custom_value: Option<f64>,
        custom_value2: Option<f64>,
        custom_long: Option<i64>,
        custom_long2: Option<i64>,
        ) -> Result<UsageResponse, ApiError>;

    /// Create Multiple Usage Records
    async fn usage_batch(
        &self,
        version: f64,
        app_key: String,
        device: String,
        data: String,
        device_id: Option<String>,
        account_id: Option<i64>,
        app_version: Option<String>,
        device_type: Option<String>,
        device_os: Option<String>,
        model: Option<String>,
        update_ranking: Option<bool>,
        return_summary_response: Option<bool>,
        ) -> Result<UsageBatchResponse, ApiError>;

    /// Get App Data
    async fn get_app_data(
        &self,
        version: f64,
        start: i32,
        limit: i32,
        device_id: Option<String>,
        account_id: Option<i64>,
        game_type: Option<String>,
        include_game_data: Option<bool>,
        q: Option<String>,
        keyword: Option<String>,
        sort_field: Option<String>,
        descending: Option<bool>,
        _i: Option<i32>,
        _l: Option<i32>,
        game_object_count: Option<bool>,
        filter: Option<String>,
        date_created: Option<i64>,
        owner_id: Option<i64>,
        mission_ids: Option<String>,
        game_ids: Option<String>,
        pack_ids: Option<String>,
        game_level_ids: Option<String>,
        app_version: Option<String>,
        include_higher_version_packs: Option<bool>,
        include_higher_version_levels: Option<bool>,
        response_groups: Option<String>,
        purchase_type: Option<String>,
        ) -> Result<GetAppDataResponse, ApiError>;

    /// Create App Data
    async fn post_app_data(
        &self,
        version: f64,
        game_type: String,
        start: i32,
        limit: i32,
        data: String,
        device_id: Option<String>,
        account_id: Option<i64>,
        include_game_data: Option<bool>,
        q: Option<String>,
        keyword: Option<String>,
        sort_field: Option<String>,
        descending: Option<bool>,
        _i: Option<i32>,
        _l: Option<i32>,
        game_object_count: Option<bool>,
        filter: Option<String>,
        date_created: Option<i64>,
        owner_id: Option<i64>,
        mission_ids: Option<String>,
        game_ids: Option<String>,
        pack_ids: Option<String>,
        game_level_ids: Option<String>,
        app_version: Option<String>,
        include_higher_version_packs: Option<bool>,
        include_higher_version_levels: Option<bool>,
        response_groups: Option<String>,
        purchase_type: Option<String>,
        ) -> Result<PostAppDataResponse, ApiError>;

    /// Regenerate App Data
    async fn regen_app_data(
        &self,
        version: f64,
        account_id: Option<i64>,
        app_key: Option<String>,
        build_version: Option<String>,
        api_version: Option<String>,
        ) -> Result<RegenAppDataResponse, ApiError>;

    /// Create Application
    async fn create_application(
        &self,
        version: f64,
        app_name: String,
        device_id: Option<String>,
        account_id: Option<i64>,
        about: Option<String>,
        bundle_id: Option<String>,
        app_icon_asset_id: Option<i64>,
        app_logo_asset_id: Option<i64>,
        facebook_app_id: Option<String>,
        facebook_app_secret: Option<String>,
        google_api_key: Option<String>,
        update_eula_date: Option<bool>,
        eula_version: Option<String>,
        landing_page_url: Option<String>,
        show_in_activities: Option<bool>,
        activity_description: Option<String>,
        invite_welcome_text: Option<String>,
        invite_page_url: Option<String>,
        url_scheme: Option<String>,
        platforms: Option<String>,
        download_urls: Option<String>,
        category_ids: Option<String>,
        scoring_type: Option<models::CreateApplicationScoringTypeParameter>,
        hint_cost: Option<i32>,
        max_score: Option<i32>,
        tickets_per_point: Option<f32>,
        has_game_data: Option<bool>,
        public_notifications: Option<bool>,
        use_matching_algorithm: Option<bool>,
        global_tickets: Option<bool>,
        build_version: Option<f32>,
        api_version: Option<f32>,
        placement_name: Option<String>,
        placement_description: Option<String>,
        placement_size: Option<models::CreateApplicationPlacementSizeParameter>,
        placement_height: Option<i32>,
        placement_width: Option<i32>,
        placement_refresh_interval: Option<i32>,
        create_object_store: Option<bool>,
        public_content_approval: Option<bool>,
        production_mode: Option<bool>,
        minimum_session_length: Option<i32>,
        session_gap_length: Option<i32>,
        local_ads_enabled: Option<bool>,
        sqoot_api_key: Option<String>,
        trilat_processing_type: Option<models::CreateApplicationTrilatProcessingTypeParameter>,
        max_sample_size: Option<i32>,
        min_rssi: Option<f64>,
        modules: Option<String>,
        authorized_count: Option<i32>,
        authorized_servers: Option<String>,
        default_timezone: Option<String>,
        smtp_pass: Option<String>,
        meta_data: Option<String>,
        placement_meta_data: Option<String>,
        ips_floor: Option<bool>,
        enable_apns_badge: Option<bool>,
        include_in_report: Option<bool>,
        default_app_filter_id: Option<i64>,
        enable_welcome_email: Option<bool>,
        apple_app_id: Option<String>,
        apple_team_id: Option<String>,
        apple_auth_key_id: Option<String>,
        apple_auth_key: Option<swagger::ByteArray>,
        apple_issuer_id: Option<String>,
        app_store_key_id: Option<String>,
        app_store_key: Option<swagger::ByteArray>,
        google_private_key_file: Option<swagger::ByteArray>,
        authorize_net_api_key: Option<String>,
        authorize_net_transaction_key: Option<String>,
        email_sender: Option<String>,
        smtp_user: Option<String>,
        smtp_host: Option<String>,
        vatom_business_id: Option<String>,
        vatom_rest_client_id: Option<String>,
        vatom_rest_secret_key: Option<String>,
        twilio_account_sid: Option<String>,
        twilio_auth_token: Option<String>,
        twilio_sender_phone_number: Option<String>,
        open_ai_secret_key: Option<String>,
        ) -> Result<CreateApplicationResponse, ApiError>;

    /// Create Ad Placement
    async fn create_application_placement(
        &self,
        version: f64,
        app_key: String,
        size: models::CreateApplicationPlacementSizeParameter,
        device_id: Option<String>,
        account_id: Option<i64>,
        name: Option<String>,
        description: Option<String>,
        height: Option<i32>,
        width: Option<i32>,
        refresh_interval: Option<i32>,
        default_image_id: Option<i64>,
        active: Option<bool>,
        ) -> Result<CreateApplicationPlacementResponse, ApiError>;

    /// Delete Application
    async fn delete_application(
        &self,
        version: f64,
        account_id: Option<i64>,
        app_key: Option<String>,
        ) -> Result<DeleteApplicationResponse, ApiError>;

    /// Delete Ad Placement
    async fn delete_application_placement(
        &self,
        version: f64,
        placement_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        ) -> Result<DeleteApplicationPlacementResponse, ApiError>;

    /// Get Application
    async fn get_application(
        &self,
        version: f64,
        app_key: Option<String>,
        application_id: Option<i64>,
        ) -> Result<GetApplicationResponse, ApiError>;

    /// Get Ad Placement
    async fn get_application_placement(
        &self,
        version: f64,
        placement_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        ) -> Result<GetApplicationPlacementResponse, ApiError>;

    /// Get API versions
    async fn get_application_versions(
        &self,
        version: f64,
        ) -> Result<GetApplicationVersionsResponse, ApiError>;

    /// Search Application Users
    async fn get_unique_users_by_app(
        &self,
        version: f64,
        app_key: String,
        q: Option<String>,
        keyword: Option<String>,
        since: Option<i64>,
        _i: Option<i32>,
        start: Option<i32>,
        _l: Option<i32>,
        limit: Option<i32>,
        ) -> Result<GetUniqueUsersByAppResponse, ApiError>;

    /// List Applications
    async fn list_applications(
        &self,
        version: f64,
        account_id: Option<i64>,
        q: Option<String>,
        keyword: Option<String>,
        platforms: Option<String>,
        device_ids: Option<String>,
        device_versions: Option<String>,
        category_ids: Option<String>,
        sort_field: Option<models::ListApplicationsSortFieldParameter>,
        has_ads: Option<bool>,
        public_notifications: Option<bool>,
        filter_billable: Option<bool>,
        filter_content_admin: Option<bool>,
        descending: Option<bool>,
        _i: Option<i32>,
        start: Option<i32>,
        _l: Option<i32>,
        limit: Option<i32>,
        application_ids: Option<String>,
        has_object_store: Option<bool>,
        active_only: Option<bool>,
        ) -> Result<ListApplicationsResponse, ApiError>;

    /// Search for Ad Placements
    async fn search_application_placement(
        &self,
        version: f64,
        app_key: String,
        device_id: Option<String>,
        account_id: Option<i64>,
        start: Option<i32>,
        limit: Option<i32>,
        ) -> Result<SearchApplicationPlacementResponse, ApiError>;

    /// Search for Application Settings
    async fn search_application_settings(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        connection_account_id: Option<i64>,
        keyword: Option<String>,
        sort_field: Option<String>,
        descending: Option<bool>,
        start: Option<i32>,
        limit: Option<i32>,
        ) -> Result<SearchApplicationSettingsResponse, ApiError>;

    /// Search Applications
    async fn search_applications(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        q: Option<String>,
        keyword: Option<String>,
        q_search_fields: Option<String>,
        sort_field: Option<models::SearchApplicationsSortFieldParameter>,
        descending: Option<bool>,
        _i: Option<i32>,
        start: Option<i32>,
        _l: Option<i32>,
        limit: Option<i32>,
        has_ads: Option<bool>,
        public_notifications: Option<bool>,
        active_only: Option<bool>,
        ) -> Result<SearchApplicationsResponse, ApiError>;

    /// Update Application
    async fn update_application(
        &self,
        version: f64,
        app_key: String,
        app_name: String,
        device_id: Option<String>,
        account_id: Option<i64>,
        about: Option<String>,
        bundle_id: Option<String>,
        app_icon_asset_id: Option<i64>,
        app_logo_asset_id: Option<i64>,
        facebook_app_id: Option<String>,
        facebook_app_secret: Option<String>,
        google_api_key: Option<String>,
        update_eula_date: Option<bool>,
        eula_version: Option<String>,
        landing_page_url: Option<String>,
        show_in_activities: Option<bool>,
        activity_description: Option<String>,
        invite_welcome_text: Option<String>,
        invite_page_url: Option<String>,
        url_scheme: Option<String>,
        platforms: Option<String>,
        download_urls: Option<String>,
        category_ids: Option<String>,
        scoring_type: Option<models::CreateApplicationScoringTypeParameter>,
        hint_cost: Option<i32>,
        max_score: Option<i32>,
        tickets_per_point: Option<f32>,
        has_game_data: Option<bool>,
        public_notifications: Option<bool>,
        use_matching_algorithm: Option<bool>,
        global_tickets: Option<bool>,
        build_version: Option<f32>,
        api_version: Option<f32>,
        placement_name: Option<String>,
        placement_description: Option<String>,
        placement_size: Option<models::CreateApplicationPlacementSizeParameter>,
        placement_height: Option<i32>,
        placement_width: Option<i32>,
        placement_refresh_interval: Option<i32>,
        create_object_store: Option<bool>,
        public_content_approval: Option<bool>,
        production_mode: Option<bool>,
        minimum_session_length: Option<i32>,
        session_gap_length: Option<i32>,
        local_ads_enabled: Option<bool>,
        sqoot_api_key: Option<String>,
        trilat_processing_type: Option<models::CreateApplicationTrilatProcessingTypeParameter>,
        max_sample_size: Option<i32>,
        min_rssi: Option<f64>,
        modules: Option<String>,
        authorized_count: Option<i32>,
        authorized_servers: Option<String>,
        default_timezone: Option<String>,
        smtp_pass: Option<String>,
        meta_data: Option<String>,
        placement_meta_data: Option<String>,
        ips_floor: Option<bool>,
        enable_apns_badge: Option<bool>,
        include_in_report: Option<bool>,
        default_app_filter_id: Option<i64>,
        enable_welcome_email: Option<bool>,
        apple_app_id: Option<String>,
        apple_team_id: Option<String>,
        apple_auth_key_id: Option<String>,
        apple_auth_key: Option<swagger::ByteArray>,
        apple_issuer_id: Option<String>,
        app_store_key_id: Option<String>,
        app_store_key: Option<swagger::ByteArray>,
        google_private_key_file: Option<swagger::ByteArray>,
        authorize_net_api_key: Option<String>,
        authorize_net_transaction_key: Option<String>,
        email_sender: Option<String>,
        smtp_user: Option<String>,
        smtp_host: Option<String>,
        vatom_business_id: Option<String>,
        vatom_rest_client_id: Option<String>,
        vatom_rest_secret_key: Option<String>,
        twilio_account_sid: Option<String>,
        twilio_auth_token: Option<String>,
        twilio_sender_phone_number: Option<String>,
        open_ai_secret_key: Option<String>,
        ) -> Result<UpdateApplicationResponse, ApiError>;

    /// Change Appliation Status
    async fn update_application_active(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        active: bool,
        ) -> Result<UpdateApplicationActiveResponse, ApiError>;

    /// Update Ad Placement
    async fn update_application_placement(
        &self,
        version: f64,
        placement_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        name: Option<String>,
        description: Option<String>,
        size: Option<models::CreateApplicationPlacementSizeParameter>,
        height: Option<i32>,
        width: Option<i32>,
        refresh_interval: Option<i32>,
        default_image_id: Option<i64>,
        active: Option<bool>,
        ) -> Result<UpdateApplicationPlacementResponse, ApiError>;

    /// Create Application Certificate
    async fn upload_application_certificate(
        &self,
        version: f64,
        app_key: String,
        device_id: Option<String>,
        account_id: Option<i64>,
        certificate: Option<swagger::ByteArray>,
        ) -> Result<UploadApplicationCertificateResponse, ApiError>;

    /// Create AppConfig
    async fn create_application_config(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        config_version: String,
        asset_id: i64,
        retailer_id: Option<i64>,
        retailer_location_id: Option<i64>,
        udid: Option<String>,
        ) -> Result<CreateApplicationConfigResponse, ApiError>;

    /// Delete AppConfig
    async fn delete_application_config(
        &self,
        version: f64,
        account_id: i64,
        config_id: i64,
        ) -> Result<DeleteApplicationConfigResponse, ApiError>;

    /// Get AppConfig
    async fn get_application_config(
        &self,
        version: f64,
        account_id: i64,
        config_id: i64,
        ) -> Result<GetApplicationConfigResponse, ApiError>;

    /// Get AppConfig by Version
    async fn get_application_config_by_config_version(
        &self,
        version: f64,
        app_key: String,
        config_version: String,
        retailer_id: Option<i64>,
        retailer_location_id: Option<i64>,
        udid: Option<String>,
        allow_older_versions: Option<bool>,
        ) -> Result<GetApplicationConfigByConfigVersionResponse, ApiError>;

    /// Search AppConfigs
    async fn search_application_config(
        &self,
        version: f64,
        account_id: i64,
        app_key: Option<String>,
        retailer_id: Option<i64>,
        retailer_location_id: Option<i64>,
        udid: Option<String>,
        config_version: Option<String>,
        sort_field: Option<String>,
        descending: Option<bool>,
        start: Option<i32>,
        limit: Option<i32>,
        ) -> Result<SearchApplicationConfigResponse, ApiError>;

    /// Update AppConfig
    async fn update_application_config(
        &self,
        version: f64,
        account_id: i64,
        config_id: i64,
        app_key: Option<String>,
        config_version: Option<String>,
        asset_id: Option<i64>,
        retailer_id: Option<i64>,
        retailer_location_id: Option<i64>,
        udid: Option<String>,
        ) -> Result<UpdateApplicationConfigResponse, ApiError>;

    /// Convert Offer to Creative
    async fn asset_morph(
        &self,
        version: f64,
        offer_id: i64,
        ad_size: models::CreateApplicationPlacementSizeParameter,
        creative_id: Option<i64>,
        width: Option<i32>,
        height: Option<i32>,
        background_size: Option<String>,
        template: Option<String>,
        ) -> Result<AssetMorphResponse, ApiError>;

    /// Create Asset
    async fn create_asset(
        &self,
        version: f64,
        return_nulls: Option<bool>,
        device_id: Option<String>,
        account_id: Option<i64>,
        album_id: Option<i64>,
        collection_id: Option<i64>,
        add_to_default_album: Option<String>,
        add_to_media_library: Option<bool>,
        version_code: Option<i32>,
        version_name: Option<String>,
        meta_data: Option<String>,
        caption: Option<String>,
        asset_type: Option<String>,
        approval_status: Option<String>,
        assigned_account_id: Option<i64>,
        media: Option<swagger::ByteArray>,
        media_url: Option<String>,
        media_string: Option<String>,
        media_string_file_name: Option<String>,
        media_string_content_type: Option<String>,
        media_height: Option<i32>,
        media_width: Option<i32>,
        attached_media: Option<swagger::ByteArray>,
        attached_media_url: Option<String>,
        attached_media_string: Option<String>,
        attached_media_string_file_name: Option<String>,
        attached_media_string_content_type: Option<String>,
        attached_media_height: Option<i32>,
        attached_media_width: Option<i32>,
        location_description: Option<String>,
        app: Option<String>,
        app_key: Option<String>,
        search_tags: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        ) -> Result<CreateAssetResponse, ApiError>;

    /// Delete Asset
    async fn delete_asset(
        &self,
        version: f64,
        asset_id: String,
        device_id: Option<String>,
        account_id: Option<i64>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        ) -> Result<DeleteAssetResponse, ApiError>;

    /// Get Asset
    async fn get_asset(
        &self,
        version: f64,
        asset_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        note_descending: Option<bool>,
        ) -> Result<GetAssetResponse, ApiError>;

    /// Remove Asset from Collection
    async fn remove_asset(
        &self,
        version: f64,
        asset_id: String,
        device_id: Option<String>,
        account_id: Option<i64>,
        album_id: Option<i64>,
        collection_id: Option<i64>,
        remove_from_default_albums: Option<bool>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        ) -> Result<RemoveAssetResponse, ApiError>;

    /// Search Assets
    async fn search_assets(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        album_ids: Option<String>,
        asset_ids: Option<String>,
        app_key: Option<String>,
        media_type: Option<String>,
        mime_type: Option<String>,
        keyword: Option<String>,
        version_code: Option<i32>,
        version_name: Option<String>,
        updated_since: Option<i64>,
        updated_before: Option<i64>,
        sort_field: Option<String>,
        descending: Option<bool>,
        search_media_library: Option<bool>,
        filter_by_billable: Option<bool>,
        active_only: Option<bool>,
        return_app: Option<bool>,
        start: Option<i32>,
        limit: Option<i32>,
        search_mode: Option<String>,
        asset_type: Option<String>,
        approval_status: Option<String>,
        assigned_account_id: Option<i64>,
        ) -> Result<SearchAssetsResponse, ApiError>;

    /// Update Asset
    async fn update_asset(
        &self,
        version: f64,
        asset_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        album_id: Option<i64>,
        attached_asset_id: Option<i64>,
        version_code: Option<i32>,
        version_name: Option<String>,
        meta_data: Option<String>,
        caption: Option<String>,
        asset_type: Option<String>,
        approval_status: Option<String>,
        assigned_account_id: Option<i64>,
        media: Option<swagger::ByteArray>,
        media_url: Option<String>,
        media_string: Option<String>,
        media_string_file_name: Option<String>,
        media_string_content_type: Option<String>,
        media_height: Option<i32>,
        media_width: Option<i32>,
        attached_media: Option<swagger::ByteArray>,
        attached_media_url: Option<String>,
        attached_media_string: Option<String>,
        attached_media_string_file_name: Option<String>,
        attached_media_string_content_type: Option<String>,
        attached_media_height: Option<i32>,
        attached_media_width: Option<i32>,
        location_description: Option<String>,
        search_tags: Option<String>,
        app_key: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        ) -> Result<UpdateAssetResponse, ApiError>;

    /// Download Asset
    async fn asset_download(
        &self,
        version: f64,
        filename: String,
        ) -> Result<AssetDownloadResponse, ApiError>;

    /// Search Assignment Assignees
    async fn assigment_assignee_account_search(
        &self,
        version: f64,
        account_id: i64,
        keyword: Option<String>,
        ) -> Result<AssigmentAssigneeAccountSearchResponse, ApiError>;

    /// Create Assignment
    async fn assignment_create(
        &self,
        version: f64,
        account_id: i64,
        name: String,
        assignee_account_id: i64,
        description: Option<String>,
        retailer_location_id: Option<i64>,
        tags: Option<String>,
        active: Option<bool>,
        ) -> Result<AssignmentCreateResponse, ApiError>;

    /// Delete Assignment
    async fn assignment_delete(
        &self,
        version: f64,
        account_id: i64,
        assignment_id: i64,
        ) -> Result<AssignmentDeleteResponse, ApiError>;

    /// Get Assignment
    async fn assignment_get(
        &self,
        version: f64,
        account_id: i64,
        assignment_id: i64,
        ) -> Result<AssignmentGetResponse, ApiError>;

    /// Search Assignments
    async fn assignment_search(
        &self,
        version: f64,
        account_id: i64,
        sort_field: models::AssignmentSearchSortFieldParameter,
        descending: bool,
        active_only: bool,
        start: i32,
        limit: i32,
        creator_account_id: Option<i64>,
        assignee_account_ids: Option<String>,
        retailer_location_ids: Option<String>,
        current_status_type: Option<models::AssignmentSearchCurrentStatusTypeParameter>,
        keyword: Option<String>,
        ) -> Result<AssignmentSearchResponse, ApiError>;

    /// Create Assignment Status
    async fn assignment_status_create(
        &self,
        version: f64,
        account_id: i64,
        assignment_id: i64,
        scheduled_notification_id: Option<i64>,
        to_do: Option<models::AssignmentStatusCreateToDoParameter>,
        connection: Option<models::AssignmentStatusCreateConnectionParameter>,
        method: Option<models::AssignmentStatusCreateMethodParameter>,
        status: Option<models::AssignmentStatusCreateStatusParameter>,
        closure: Option<models::AssignmentStatusCreateClosureParameter>,
        message: Option<String>,
        follow_up: Option<i64>,
        active: Option<bool>,
        ) -> Result<AssignmentStatusCreateResponse, ApiError>;

    /// Deletes Assignment Status
    async fn assignment_status_delete(
        &self,
        version: f64,
        account_id: i64,
        assignment_status_id: i64,
        ) -> Result<AssignmentStatusDeleteResponse, ApiError>;

    /// Get Assignment Status
    async fn assignment_status_get(
        &self,
        version: f64,
        account_id: i64,
        assignment_status_id: i64,
        ) -> Result<AssignmentStatusGetResponse, ApiError>;

    /// Search Assignment Statuses
    async fn assignment_status_search(
        &self,
        version: f64,
        account_id: i64,
        sort_field: models::AssignmentStatusSearchSortFieldParameter,
        descending: bool,
        active_only: bool,
        start: i32,
        limit: i32,
        assignment_id: Option<i64>,
        creator_account_id: Option<i64>,
        assignee_account_id: Option<i64>,
        retailer_location_id: Option<i64>,
        status_type: Option<models::AssignmentStatusCreateStatusParameter>,
        keyword: Option<String>,
        ) -> Result<AssignmentStatusSearchResponse, ApiError>;

    /// Update Assignment Status
    async fn assignment_status_update(
        &self,
        version: f64,
        account_id: i64,
        assignment_status_id: i64,
        scheduled_notification_id: Option<i64>,
        to_do: Option<models::AssignmentStatusCreateToDoParameter>,
        connection: Option<models::AssignmentStatusCreateConnectionParameter>,
        method: Option<models::AssignmentStatusCreateMethodParameter>,
        status: Option<models::AssignmentStatusCreateStatusParameter>,
        closure: Option<models::AssignmentStatusCreateClosureParameter>,
        message: Option<String>,
        follow_up: Option<i64>,
        active: Option<bool>,
        ) -> Result<AssignmentStatusUpdateResponse, ApiError>;

    /// Update Assignment
    async fn assignment_update(
        &self,
        version: f64,
        account_id: i64,
        assignment_id: i64,
        name: Option<String>,
        description: Option<String>,
        assignee_account_id: Option<i64>,
        retailer_location_id: Option<i64>,
        tags: Option<String>,
        active: Option<bool>,
        ) -> Result<AssignmentUpdateResponse, ApiError>;

    /// Create Audience
    async fn create_audience(
        &self,
        version: f64,
        account_id: i64,
        name: String,
        description: Option<String>,
        search_tags: Option<String>,
        gender: Option<String>,
        age_groups: Option<String>,
        category_ids: Option<String>,
        application_ids: Option<String>,
        game_experience_level: Option<String>,
        devices: Option<String>,
        device_ids: Option<String>,
        device_versions: Option<String>,
        locations: Option<String>,
        radius: Option<String>,
        start_time_offset: Option<i32>,
        end_time_offset: Option<i32>,
        send_suggestion: Option<bool>,
        associate_description: Option<String>,
        associate_type: Option<String>,
        associate_id: Option<i64>,
        grouping_id: Option<String>,
        meta_data: Option<String>,
        visibility: Option<String>,
        audience_type: Option<String>,
        use_order: Option<bool>,
        cohort_regions_data: Option<String>,
        app_key: Option<String>,
        trilateration_types: Option<String>,
        unique_name: Option<bool>,
        ) -> Result<CreateAudienceResponse, ApiError>;

    /// Delete Audience
    async fn delete_audience(
        &self,
        version: f64,
        account_id: i64,
        audience_id: i64,
        ) -> Result<DeleteAudienceResponse, ApiError>;

    /// Get Age Groups
    async fn get_age_groups(
        &self,
        version: f64,
        ) -> Result<GetAgeGroupsResponse, ApiError>;

    /// Get Audience
    async fn get_audience(
        &self,
        version: f64,
        account_id: i64,
        audience_id: i64,
        app_key: Option<String>,
        return_account_count: Option<bool>,
        return_album_count: Option<bool>,
        album_types_for_count: Option<String>,
        ) -> Result<GetAudienceResponse, ApiError>;

    /// Search Audiences
    async fn get_audience_list(
        &self,
        version: f64,
        account_id: Option<i64>,
        album_ids: Option<String>,
        keyword: Option<String>,
        keyword_fields: Option<String>,
        sort_field: Option<models::GetAudienceListSortFieldParameter>,
        descending: Option<bool>,
        start: Option<i32>,
        limit: Option<i32>,
        send_suggestion: Option<bool>,
        active_only: Option<bool>,
        group_by_grouping_id: Option<bool>,
        app_key: Option<String>,
        return_global: Option<bool>,
        exact_keyword: Option<bool>,
        audience_type: Option<String>,
        audience_types: Option<String>,
        return_account_count: Option<bool>,
        return_album_count: Option<bool>,
        album_types_for_count: Option<String>,
        ) -> Result<GetAudienceListResponse, ApiError>;

    /// Get Devices
    async fn get_devices(
        &self,
        version: f64,
        include_inactive: bool,
        ) -> Result<GetDevicesResponse, ApiError>;

    /// Get Experiences
    async fn get_experiences(
        &self,
        version: f64,
        ) -> Result<GetExperiencesResponse, ApiError>;

    /// Get GroupedAudiences
    async fn get_grouped_audiences(
        &self,
        version: f64,
        account_id: i64,
        audience_grouping_id: String,
        ) -> Result<GetGroupedAudiencesResponse, ApiError>;

    /// List Suggestions by Audience
    async fn list_by_account(
        &self,
        version: f64,
        account_id: i64,
        limit: i32,
        suggestion_type: String,
        ) -> Result<ListByAccountResponse, ApiError>;

    /// List Offers by Audience
    async fn list_by_audience(
        &self,
        version: f64,
        limit: i32,
        gender: Option<String>,
        age: Option<i32>,
        category_ids: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        ) -> Result<ListByAudienceResponse, ApiError>;

    /// List Sent Suggestions 
    async fn list_lastest_by_account(
        &self,
        version: f64,
        account_id: i64,
        timeframe: i32,
        suggestion_type: String,
        ) -> Result<ListLastestByAccountResponse, ApiError>;

    /// Send Suggestions
    async fn send_by_account(
        &self,
        version: f64,
        account_id: i64,
        latitude: f64,
        longitude: f64,
        ) -> Result<SendByAccountResponse, ApiError>;

    /// Update Audience
    async fn update_audience(
        &self,
        version: f64,
        account_id: i64,
        audience_id: i64,
        name: Option<String>,
        description: Option<String>,
        search_tags: Option<String>,
        gender: Option<String>,
        age_groups: Option<String>,
        category_ids: Option<String>,
        application_ids: Option<String>,
        game_experience_level: Option<String>,
        devices: Option<String>,
        device_ids: Option<String>,
        device_versions: Option<String>,
        locations: Option<String>,
        radius: Option<String>,
        active: Option<bool>,
        send_suggestion: Option<bool>,
        start_time_offset: Option<i32>,
        end_time_offset: Option<i32>,
        associate_description: Option<String>,
        associate_type: Option<String>,
        associate_id: Option<i64>,
        grouping_id: Option<String>,
        meta_data: Option<String>,
        visibility: Option<String>,
        audience_type: Option<String>,
        use_order: Option<bool>,
        cohort_regions_data: Option<String>,
        app_key: Option<String>,
        trilateration_types: Option<String>,
        unique_name: Option<bool>,
        ) -> Result<UpdateAudienceResponse, ApiError>;

    /// Create Bid
    async fn create_bid(
        &self,
        version: f64,
        biddable_type: String,
        biddable_id: i64,
        amount_per_view: f64,
        amount_per_action: f64,
        budget_amount: f64,
        budget_schedule: String,
        device_id: Option<String>,
        account_id: Option<i64>,
        ) -> Result<CreateBidResponse, ApiError>;

    /// Delete Bid
    async fn delete_bid(
        &self,
        version: f64,
        bid_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        ) -> Result<DeleteBidResponse, ApiError>;

    /// Get Bid
    async fn get_bid(
        &self,
        version: f64,
        bid_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        ) -> Result<GetBidResponse, ApiError>;

    /// Update Bid
    async fn update_bid(
        &self,
        version: f64,
        bid_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        amount_per_view: Option<f64>,
        amount_per_action: Option<f64>,
        budget_amount: Option<f64>,
        budget_schedule: Option<String>,
        ) -> Result<UpdateBidResponse, ApiError>;

    /// Create Billable
    async fn create_billable_entity(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        name: Option<String>,
        street_address: Option<String>,
        street_address2: Option<String>,
        city: Option<String>,
        state: Option<String>,
        postal_code: Option<String>,
        business_phone: Option<String>,
        business_phone_ext: Option<String>,
        authorize_net_api_key: Option<String>,
        authorize_net_transaction_key: Option<String>,
        ) -> Result<CreateBillableEntityResponse, ApiError>;

    /// Delete Billable
    async fn delete_billable_entity(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        ) -> Result<DeleteBillableEntityResponse, ApiError>;

    /// Get Billable
    async fn get_billable_entity(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        include_counts: Option<bool>,
        include_payments: Option<bool>,
        ) -> Result<GetBillableEntityResponse, ApiError>;

    /// Update Billable
    async fn update_billable_entity(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        name: Option<String>,
        street_address: Option<String>,
        street_address2: Option<String>,
        city: Option<String>,
        state: Option<String>,
        postal_code: Option<String>,
        business_phone: Option<String>,
        business_phone_ext: Option<String>,
        authorize_net_api_key: Option<String>,
        authorize_net_transaction_key: Option<String>,
        ) -> Result<UpdateBillableEntityResponse, ApiError>;

    /// Update Payment Method
    async fn add_payment_method(
        &self,
        version: f64,
        account_id: i64,
        payment_method_id: Option<i64>,
        account_name: Option<String>,
        first_name: Option<String>,
        last_name: Option<String>,
        address: Option<String>,
        city: Option<String>,
        state: Option<String>,
        postal_code: Option<String>,
        country: Option<String>,
        phone: Option<String>,
        credit_card_number: Option<String>,
        expiration_date: Option<String>,
        ccv: Option<String>,
        account_number: Option<String>,
        bank_name: Option<String>,
        routing_number: Option<String>,
        default_payment_method: Option<bool>,
        payment_method_nickname: Option<String>,
        tax_id: Option<String>,
        provider_customer_profile_id: Option<String>,
        provider_payment_profile_id: Option<String>,
        meta_data: Option<String>,
        ) -> Result<AddPaymentMethodResponse, ApiError>;

    /// Create Payment Method
    async fn create_payment_method(
        &self,
        version: f64,
        account_id: i64,
        account_name: Option<String>,
        first_name: Option<String>,
        last_name: Option<String>,
        address: Option<String>,
        city: Option<String>,
        state: Option<String>,
        postal_code: Option<String>,
        country: Option<String>,
        phone: Option<String>,
        credit_card_number: Option<String>,
        expiration_date: Option<String>,
        ccv: Option<String>,
        account_number: Option<String>,
        bank_name: Option<String>,
        routing_number: Option<String>,
        payment_method_nickname: Option<String>,
        tax_id: Option<String>,
        default_payment_method: Option<bool>,
        auth_token: Option<String>,
        provider: Option<String>,
        provider_customer_profile_id: Option<String>,
        provider_payment_profile_id: Option<String>,
        meta_data: Option<String>,
        app_key: Option<String>,
        ) -> Result<CreatePaymentMethodResponse, ApiError>;

    /// Create Smart Contract
    async fn create_smart_contract(
        &self,
        version: f64,
        account_id: i64,
        token_name: String,
        token_symbol: String,
        payment_method_id: Option<i64>,
        ) -> Result<CreateSmartContractResponse, ApiError>;

    /// Get Crypto Balances
    async fn get_crypto_balance(
        &self,
        version: f64,
        account_id: i64,
        owner_account_id: Option<i64>,
        payment_method_id: Option<i64>,
        ) -> Result<GetCryptoBalanceResponse, ApiError>;

    /// Get Payment Method
    async fn get_payment_method(
        &self,
        version: f64,
        account_id: i64,
        payment_method_id: Option<i64>,
        get_current_balance: Option<bool>,
        ) -> Result<GetPaymentMethodResponse, ApiError>;

    /// Search Payment Methods
    async fn search_payment_method(
        &self,
        version: f64,
        account_id: i64,
        provider: Option<String>,
        param_type: Option<String>,
        keyword: Option<String>,
        sort_field: Option<String>,
        descending: Option<bool>,
        start: Option<i32>,
        limit: Option<i32>,
        ) -> Result<SearchPaymentMethodResponse, ApiError>;

    /// Detail Status
    async fn get_status_csv(
        &self,
        version: f64,
        account_id: i64,
        batch_id: i64,
        response_group: models::GetStatusCsvResponseGroupParameter,
        start: i64,
        limit: i64,
        ) -> Result<GetStatusCsvResponse, ApiError>;

    /// Search Status
    async fn list_status_csv(
        &self,
        version: f64,
        account_id: i64,
        start: i32,
        limit: i32,
        ) -> Result<ListStatusCsvResponse, ApiError>;

    /// Batch Status
    async fn status_csv(
        &self,
        version: f64,
        account_id: i64,
        batch_id: i64,
        ) -> Result<StatusCsvResponse, ApiError>;

    /// Upload CSV
    async fn upload_csv(
        &self,
        version: f64,
        account_id: i64,
        upload_type: models::UploadCsvUploadTypeParameter,
        import_file: swagger::ByteArray,
        file_format: models::UploadCsvFileFormatParameter,
        app_key: Option<String>,
        ) -> Result<UploadCsvResponse, ApiError>;

    /// Create Cargo Type
    async fn create_cargo_type(
        &self,
        version: f64,
        body: Option<models::CargoType>,
        ) -> Result<CreateCargoTypeResponse, ApiError>;

    /// Search Cargo Type
    async fn search_cargo_types(
        &self,
        version: f64,
        sort_field: String,
        descending: bool,
        start: i32,
        limit: i32,
        active_only: bool,
        retailer_id: Option<i64>,
        hub_id: Option<i64>,
        ) -> Result<SearchCargoTypesResponse, ApiError>;

    /// Delete Cargo Type
    async fn delete_cargo_type(
        &self,
        version: f64,
        cargo_type_id: i64,
        ) -> Result<DeleteCargoTypeResponse, ApiError>;

    /// Get Cargo Type
    async fn get_cargo_type(
        &self,
        version: f64,
        cargo_type_id: i64,
        ) -> Result<GetCargoTypeResponse, ApiError>;

    /// Update Cargo Type
    async fn update_cargo_type(
        &self,
        version: f64,
        cargo_type_id: i64,
        body: Option<models::CargoType>,
        ) -> Result<UpdateCargoTypeResponse, ApiError>;

    /// Search Carriers
    async fn search_carriers(
        &self,
        version: f64,
        keyword: Option<String>,
        descending: Option<bool>,
        start: Option<i32>,
        limit: Option<i32>,
        active_only: Option<bool>,
        ) -> Result<SearchCarriersResponse, ApiError>;

    /// Search Categories by Distance
    async fn category_distance_search(
        &self,
        version: f64,
        account_id: Option<i64>,
        keyword: Option<String>,
        app_key: Option<String>,
        category_ids: Option<String>,
        parent_category_ids: Option<String>,
        root_only: Option<bool>,
        sort_field: Option<models::SearchCategoriesSortFieldParameter>,
        response_group: Option<models::SearchCategoriesResponseGroupParameter>,
        descending: Option<bool>,
        start: Option<i32>,
        limit: Option<i32>,
        active_only: Option<bool>,
        return_external: Option<bool>,
        exact_match: Option<bool>,
        param_type: Option<String>,
        external_type: Option<String>,
        min_offer_count: Option<i32>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        range: Option<f64>,
        ) -> Result<CategoryDistanceSearchResponse, ApiError>;

    /// Create Category
    async fn create_category(
        &self,
        version: f64,
        account_id: i64,
        name: String,
        app_key: Option<String>,
        parent_category_id: Option<i64>,
        description: Option<String>,
        param_type: Option<String>,
        asset_id: Option<i64>,
        external_id: Option<String>,
        external_type: Option<String>,
        external_category_slug: Option<String>,
        sqoot_slug: Option<String>,
        active: Option<bool>,
        meta_data: Option<String>,
        search_tags: Option<String>,
        ) -> Result<CreateCategoryResponse, ApiError>;

    /// Delete Category
    async fn delete_category(
        &self,
        version: f64,
        account_id: i64,
        category_id: i64,
        ) -> Result<DeleteCategoryResponse, ApiError>;

    /// Duplicate Category
    async fn duplicate_category(
        &self,
        version: f64,
        account_id: i64,
        category_id: i64,
        app_key: Option<String>,
        parent_category_id: Option<i64>,
        ) -> Result<DuplicateCategoryResponse, ApiError>;

    /// Get Category
    async fn get_category(
        &self,
        version: f64,
        category_id: i64,
        return_external: Option<bool>,
        ) -> Result<GetCategoryResponse, ApiError>;

    /// Search Categories
    async fn search_categories(
        &self,
        version: f64,
        account_id: Option<i64>,
        keyword: Option<String>,
        app_key: Option<String>,
        category_id: Option<String>,
        category_ids: Option<String>,
        parent_category_ids: Option<String>,
        root_only: Option<bool>,
        sort_field: Option<models::SearchCategoriesSortFieldParameter>,
        response_group: Option<models::SearchCategoriesResponseGroupParameter>,
        descending: Option<bool>,
        start: Option<i32>,
        limit: Option<i32>,
        active_only: Option<bool>,
        return_external: Option<bool>,
        exact_match: Option<bool>,
        param_type: Option<String>,
        external_type: Option<String>,
        exclude_external_type: Option<bool>,
        min_offer_count: Option<i32>,
        search_depth: Option<i32>,
        search_mode: Option<String>,
        ) -> Result<SearchCategoriesResponse, ApiError>;

    /// Update Category
    async fn update_category(
        &self,
        version: f64,
        account_id: i64,
        category_id: i64,
        parent_category_id: Option<i64>,
        name: Option<String>,
        description: Option<String>,
        param_type: Option<String>,
        asset_id: Option<i64>,
        external_id: Option<String>,
        external_type: Option<String>,
        external_category_slug: Option<String>,
        sqoot_slug: Option<String>,
        active: Option<bool>,
        meta_data: Option<String>,
        search_tags: Option<String>,
        ) -> Result<UpdateCategoryResponse, ApiError>;

    /// Add Connection
    async fn add_connection_to_group(
        &self,
        version: f64,
        return_nulls: bool,
        group_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        connection_id: Option<i64>,
        connection_account_id: Option<i64>,
        pending_id: Option<i64>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        ) -> Result<AddConnectionToGroupResponse, ApiError>;

    /// Add Connections
    async fn add_connections_to_group(
        &self,
        version: f64,
        connection_group_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        connection_ids: Option<String>,
        connection_account_ids: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        ) -> Result<AddConnectionsToGroupResponse, ApiError>;

    /// Add Connection Groups
    async fn add_sub_groups(
        &self,
        version: f64,
        return_nulls: bool,
        group_id: i64,
        sub_group_ids: String,
        device_id: Option<String>,
        account_id: Option<i64>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        ) -> Result<AddSubGroupsResponse, ApiError>;

    /// Create or Update Connection
    async fn create_or_update_connection(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        connection_id: Option<i64>,
        connection_account_id: Option<i64>,
        pending_id: Option<i64>,
        group_id: Option<i64>,
        game_type: Option<String>,
        app_key: Option<String>,
        is_trusted: Option<bool>,
        ignore_friend_request: Option<bool>,
        is_contact: Option<bool>,
        is_blocked: Option<bool>,
        is_following: Option<bool>,
        connection_response: Option<bool>,
        ) -> Result<CreateOrUpdateConnectionResponse, ApiError>;

    /// Create or Update Connection Group
    async fn create_or_update_group(
        &self,
        version: f64,
        return_nulls: bool,
        device_id: Option<String>,
        account_id: Option<i64>,
        name: Option<String>,
        group_id: Option<i64>,
        asset_id: Option<i64>,
        connections: Option<String>,
        description: Option<String>,
        can_view_profile_info: Option<bool>,
        can_view_game_info: Option<bool>,
        can_view_friend_info: Option<bool>,
        active: Option<bool>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        ) -> Result<CreateOrUpdateGroupResponse, ApiError>;

    /// Accept Follow Request
    async fn follow_accept(
        &self,
        version: f64,
        account_id: i64,
        connection_account_id: i64,
        app_key: String,
        ) -> Result<FollowAcceptResponse, ApiError>;

    /// Reject Follow Request
    async fn follow_reject(
        &self,
        version: f64,
        account_id: i64,
        connection_account_id: i64,
        app_key: String,
        ) -> Result<FollowRejectResponse, ApiError>;

    /// Remove Follower / Unfollow
    async fn follow_remove(
        &self,
        version: f64,
        account_id: i64,
        connection_account_id: i64,
        app_key: String,
        ) -> Result<FollowRemoveResponse, ApiError>;

    /// Send Follow Request
    async fn follow_request(
        &self,
        version: f64,
        account_id: i64,
        connection_account_id: i64,
        app_key: String,
        approval_needed: Option<bool>,
        ) -> Result<FollowRequestResponse, ApiError>;

    /// Accept Friend
    async fn friend_accept(
        &self,
        version: f64,
        friend_account_id: i64,
        notify_friend: bool,
        device_id: Option<String>,
        account_id: Option<i64>,
        game_type: Option<String>,
        app_key: Option<String>,
        notification_message: Option<String>,
        ) -> Result<FriendAcceptResponse, ApiError>;

    /// Decline Friend
    async fn friend_reject(
        &self,
        version: f64,
        friend_account_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        game_type: Option<String>,
        app_key: Option<String>,
        notify_friend: Option<bool>,
        notification_message: Option<String>,
        ) -> Result<FriendRejectResponse, ApiError>;

    /// Delete Friend
    async fn friend_remove(
        &self,
        version: f64,
        friend_account_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        notify_friend: Option<bool>,
        remove_from_groups: Option<bool>,
        ) -> Result<FriendRemoveResponse, ApiError>;

    /// Request Friend
    async fn friend_request(
        &self,
        version: f64,
        friend_account_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        game_type: Option<String>,
        app_key: Option<String>,
        notification_message: Option<String>,
        ) -> Result<FriendRequestResponse, ApiError>;

    /// Get Sent Friend Requests
    async fn get_connection_sent_friend_requests(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        ) -> Result<GetConnectionSentFriendRequestsResponse, ApiError>;

    /// Search Connections
    async fn get_connections(
        &self,
        version: f64,
        return_nulls: bool,
        filter: String,
        sort_field: String,
        descending: bool,
        start: i32,
        limit: i32,
        device_id: Option<String>,
        account_id: Option<i64>,
        connection_account_id: Option<i64>,
        q: Option<String>,
        keyword: Option<String>,
        _i: Option<i32>,
        _l: Option<i32>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        ) -> Result<GetConnectionsResponse, ApiError>;

    /// Get Connection Group
    async fn get_group_details(
        &self,
        version: f64,
        combine_connections: bool,
        device_id: Option<String>,
        account_id: Option<i64>,
        group_id: Option<i64>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        ) -> Result<GetGroupDetailsResponse, ApiError>;

    /// Search Connection Groups
    async fn group_search(
        &self,
        version: f64,
        sort_field: models::GroupSearchSortFieldParameter,
        descending: bool,
        active_only: bool,
        start: i32,
        limit: i32,
        device_id: Option<String>,
        account_id: Option<i64>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        keyword: Option<String>,
        ) -> Result<GroupSearchResponse, ApiError>;

    /// Delete Connection
    async fn remove_connection_from_group(
        &self,
        version: f64,
        return_nulls: bool,
        group_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        connection_id: Option<i64>,
        connection_account_id: Option<i64>,
        pending_id: Option<i64>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        ) -> Result<RemoveConnectionFromGroupResponse, ApiError>;

    /// Remove Connections
    async fn remove_connections_from_group(
        &self,
        version: f64,
        connection_group_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        connection_ids: Option<String>,
        connection_account_ids: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        ) -> Result<RemoveConnectionsFromGroupResponse, ApiError>;

    /// Delete Connection Group
    async fn remove_group(
        &self,
        version: f64,
        return_nulls: bool,
        group_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        ) -> Result<RemoveGroupResponse, ApiError>;

    /// Remove Connection Groups
    async fn remove_sub_groups(
        &self,
        version: f64,
        return_nulls: bool,
        group_id: i64,
        sub_group_ids: String,
        device_id: Option<String>,
        account_id: Option<i64>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        ) -> Result<RemoveSubGroupsResponse, ApiError>;

    /// Search Possible Connections
    async fn search_connections(
        &self,
        version: f64,
        return_nulls: bool,
        start: i32,
        limit: i32,
        device_id: Option<String>,
        account_id: Option<i64>,
        q: Option<String>,
        keyword: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        game_type: Option<String>,
        app_key: Option<String>,
        _i: Option<i32>,
        _l: Option<i32>,
        sort_field: Option<String>,
        has_location: Option<bool>,
        ) -> Result<SearchConnectionsResponse, ApiError>;

    /// Create or Update Contest
    async fn add_or_update_album_contest(
        &self,
        version: f64,
        public_read: bool,
        public_write: bool,
        public_delete: bool,
        public_add: bool,
        visibility: models::AddAlbumCollectionVisibilityParameter,
        include_friend_group: bool,
        device_id: Option<String>,
        account_id: Option<i64>,
        game_type: Option<String>,
        app_key: Option<String>,
        contest_type: Option<String>,
        album_contest_id: Option<i64>,
        title: Option<String>,
        description: Option<String>,
        album_id1: Option<i64>,
        remove_album1: Option<bool>,
        album_id2: Option<i64>,
        remove_album2: Option<bool>,
        start_date: Option<i64>,
        end_date: Option<i64>,
        location_description: Option<String>,
        connection_ids_to_add: Option<String>,
        connection_group_ids_to_add: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        ) -> Result<AddOrUpdateAlbumContestResponse, ApiError>;

    /// Approve Contest
    async fn approve_album_contest(
        &self,
        version: f64,
        album_contest_id: i64,
        approval_status: models::ApproveAlbumApprovalStatusParameter,
        device_id: Option<String>,
        account_id: Option<i64>,
        ) -> Result<ApproveAlbumContestResponse, ApiError>;

    /// Delete Contest
    async fn delete_contest(
        &self,
        version: f64,
        album_contest_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        ) -> Result<DeleteContestResponse, ApiError>;

    /// Get Contest
    async fn get_album_contest(
        &self,
        version: f64,
        album_contest_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        ) -> Result<GetAlbumContestResponse, ApiError>;

    /// Search Contests
    async fn get_album_contests(
        &self,
        version: f64,
        filter: String,
        sort_field: String,
        descending: bool,
        start: i32,
        limit: i32,
        device_id: Option<String>,
        account_id: Option<i64>,
        game_type: Option<String>,
        app_key: Option<String>,
        app_type: Option<String>,
        contest_type: Option<String>,
        owner_id: Option<i64>,
        q: Option<String>,
        keyword: Option<String>,
        _i: Option<i32>,
        _l: Option<i32>,
        date_created: Option<i64>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        ) -> Result<GetAlbumContestsResponse, ApiError>;

    /// Vote on Contest
    async fn vote_on_album_contest(
        &self,
        version: f64,
        album_contest_id: i64,
        album_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        contest_type: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        ) -> Result<VoteOnAlbumContestResponse, ApiError>;

    /// Add Preview
    async fn add_preview(
        &self,
        version: f64,
        account_id: i64,
        creative_id: i64,
        ) -> Result<AddPreviewResponse, ApiError>;

    /// Find Missions
    async fn ads_find(
        &self,
        version: f64,
        app_key: String,
        randomize: bool,
        targeted_ads_only: bool,
        param_type: Option<String>,
        account_id: Option<i64>,
        app_version: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        device: Option<String>,
        device_identifier: Option<i64>,
        device_version: Option<String>,
        start: Option<i32>,
        limit: Option<i32>,
        include_audiences: Option<bool>,
        allocates_tickets: Option<bool>,
        mission_ids: Option<String>,
        ) -> Result<AdsFindResponse, ApiError>;

    /// Create Creative
    async fn create_creative(
        &self,
        version: f64,
        account_id: i64,
        name: String,
        active: bool,
        wait_for_asset: bool,
        description: Option<String>,
        asset_image_id: Option<i64>,
        action: Option<String>,
        data: Option<String>,
        suffix: Option<String>,
        param_type: Option<String>,
        balance: Option<f64>,
        reference_id: Option<i64>,
        app_version: Option<String>,
        mission_id: Option<i64>,
        offer_id: Option<i64>,
        ) -> Result<CreateCreativeResponse, ApiError>;

    /// Delete Creative
    async fn delete_creative(
        &self,
        version: f64,
        account_id: i64,
        creative_id: i64,
        ) -> Result<DeleteCreativeResponse, ApiError>;

    /// Get Creative
    async fn get_creative(
        &self,
        version: f64,
        account_id: i64,
        creative_id: i64,
        ) -> Result<GetCreativeResponse, ApiError>;

    /// Search Creatives
    async fn get_creatives_by_application(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        start: i32,
        limit: i32,
        mission_id: Option<i64>,
        keyword: Option<String>,
        ) -> Result<GetCreativesByApplicationResponse, ApiError>;

    /// Remove Preview
    async fn remove_preview(
        &self,
        version: f64,
        account_id: i64,
        creative_id: i64,
        ) -> Result<RemovePreviewResponse, ApiError>;

    /// Update Creative
    async fn update_creative(
        &self,
        version: f64,
        account_id: i64,
        creative_id: i64,
        name: Option<String>,
        description: Option<String>,
        asset_image_id: Option<i64>,
        action: Option<String>,
        data: Option<String>,
        suffix: Option<String>,
        param_type: Option<String>,
        balance: Option<f64>,
        active: Option<bool>,
        reference_id: Option<i64>,
        app_version: Option<String>,
        mission_id: Option<i64>,
        ) -> Result<UpdateCreativeResponse, ApiError>;

    /// Create Dependent
    async fn create(
        &self,
        version: f64,
        account_id: i64,
        body: Option<models::Account>,
        ) -> Result<CreateResponse, ApiError>;

    /// Get dependent list of an account
    async fn get_dependents(
        &self,
        version: f64,
        account_id: i64,
        ) -> Result<GetDependentsResponse, ApiError>;

    /// Delete Dependent
    async fn remove_dependent(
        &self,
        version: f64,
        account_id: i64,
        dependent_id: i64,
        ) -> Result<RemoveDependentResponse, ApiError>;

    /// Check Disbursements
    async fn check_disbursements(
        &self,
        version: f64,
        disbursement_id: i64,
        ) -> Result<CheckDisbursementsResponse, ApiError>;

    /// Create Disbursement
    async fn create_disbursement(
        &self,
        version: f64,
        account_id: i64,
        receiver_account_id: i64,
        original_sender_account_id: i64,
        amount: f64,
        provider: models::CreateDisbursementProviderParameter,
        scheduled_date: Option<i64>,
        title: Option<String>,
        comment: Option<String>,
        external_id: Option<String>,
        introspection_params: Option<String>,
        ) -> Result<CreateDisbursementResponse, ApiError>;

    /// Get Disbursement
    async fn get_disbursement(
        &self,
        version: f64,
        account_id: i64,
        disbursement_id: i64,
        ) -> Result<GetDisbursementResponse, ApiError>;

    /// Search Disbursements
    async fn search_disbursements(
        &self,
        version: f64,
        account_id: i64,
        receiver_account_id: Option<i64>,
        statuses: Option<String>,
        providers: Option<String>,
        before_date: Option<i64>,
        after_date: Option<i64>,
        start: Option<i32>,
        limit: Option<i32>,
        active_only: Option<bool>,
        external_id: Option<String>,
        ) -> Result<SearchDisbursementsResponse, ApiError>;

    /// Update Disbursement
    async fn update_disbursement(
        &self,
        version: f64,
        account_id: i64,
        disbursement_id: i64,
        amount: Option<f64>,
        provider: Option<models::CreateDisbursementProviderParameter>,
        scheduled_date: Option<i64>,
        title: Option<String>,
        comment: Option<String>,
        external_id: Option<String>,
        retry: Option<bool>,
        introspection_params: Option<String>,
        ) -> Result<UpdateDisbursementResponse, ApiError>;

    /// Assign Employee
    async fn assign_employee(
        &self,
        version: f64,
        account_id: i64,
        manager_account_id: i64,
        employee_account_id: i64,
        role: Option<String>,
        ) -> Result<AssignEmployeeResponse, ApiError>;

    /// Assign Employee to Location
    async fn assign_to_location_employee(
        &self,
        version: f64,
        account_id: i64,
        retailer_location_id: i64,
        employee_account_id: Option<i64>,
        assign: Option<bool>,
        ) -> Result<AssignToLocationEmployeeResponse, ApiError>;

    /// Create Employee
    async fn create_employee(
        &self,
        version: f64,
        account_id: i64,
        manager_account_id: i64,
        username: String,
        password: String,
        name: Option<String>,
        prefix_name: Option<String>,
        first_name: Option<String>,
        middle_name: Option<String>,
        last_name: Option<String>,
        suffix_name: Option<String>,
        title: Option<String>,
        about_us: Option<String>,
        asset_id: Option<i64>,
        gender: Option<models::SearchAccountsGenderParameter>,
        home_phone: Option<String>,
        cell_phone: Option<String>,
        cell_phone_carrier: Option<String>,
        business_phone: Option<String>,
        email_address: Option<String>,
        street_address: Option<String>,
        street_address2: Option<String>,
        city: Option<String>,
        state: Option<String>,
        zipcode: Option<String>,
        country: Option<String>,
        role: Option<String>,
        retailer_location_ids: Option<String>,
        settings_app_key: Option<String>,
        app_blob: Option<String>,
        assigned_device_id: Option<String>,
        ) -> Result<CreateEmployeeResponse, ApiError>;

    /// Delete Employee
    async fn delete_employee(
        &self,
        version: f64,
        account_id: i64,
        employee_account_id: i64,
        ) -> Result<DeleteEmployeeResponse, ApiError>;

    /// Get Employee
    async fn get_employee(
        &self,
        version: f64,
        account_id: i64,
        employee_account_id: i64,
        settings_app_key: Option<String>,
        ) -> Result<GetEmployeeResponse, ApiError>;

    /// Search Employees
    async fn search_employees(
        &self,
        version: f64,
        account_id: i64,
        role: Option<String>,
        retailer_id: Option<i64>,
        retailer_location_id: Option<i64>,
        q: Option<String>,
        keyword: Option<String>,
        sort_field: Option<models::SearchEmployeesSortFieldParameter>,
        descending: Option<bool>,
        _i: Option<i32>,
        start: Option<i32>,
        _l: Option<i32>,
        limit: Option<i32>,
        active_only: Option<bool>,
        managed_only: Option<bool>,
        settings_app_key: Option<String>,
        category_ids: Option<String>,
        query: Option<String>,
        ) -> Result<SearchEmployeesResponse, ApiError>;

    /// Unassign Employee
    async fn unassign_employee(
        &self,
        version: f64,
        account_id: i64,
        employee_account_id: i64,
        ) -> Result<UnassignEmployeeResponse, ApiError>;

    /// Update Employee
    async fn update_employee(
        &self,
        version: f64,
        account_id: i64,
        employee_account_id: i64,
        manager_account_id: Option<i64>,
        name: Option<String>,
        prefix_name: Option<String>,
        first_name: Option<String>,
        middle_name: Option<String>,
        last_name: Option<String>,
        suffix_name: Option<String>,
        title: Option<String>,
        asset_id: Option<i64>,
        gender: Option<models::SearchAccountsGenderParameter>,
        home_phone: Option<String>,
        cell_phone: Option<String>,
        cell_phone_carrier: Option<String>,
        business_phone: Option<String>,
        email_address: Option<String>,
        street_address: Option<String>,
        street_address2: Option<String>,
        city: Option<String>,
        state: Option<String>,
        zipcode: Option<String>,
        country: Option<String>,
        role: Option<String>,
        active: Option<bool>,
        password: Option<String>,
        retailer_location_ids: Option<String>,
        settings_app_key: Option<String>,
        app_blob: Option<String>,
        assigned_device_id: Option<String>,
        ) -> Result<UpdateEmployeeResponse, ApiError>;

    /// Attend Event
    async fn attend_event(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        app_key: Option<String>,
        listing_id: Option<i64>,
        retailer_location_id: Option<i64>,
        offer_location_id: Option<i64>,
        transaction_id: Option<i64>,
        status: Option<i32>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        ) -> Result<AttendEventResponse, ApiError>;

    /// Create Event
    async fn create_event(
        &self,
        version: f64,
        account_id: i64,
        title: String,
        retailer_location_ids: Option<String>,
        sub_title: Option<String>,
        details: Option<String>,
        category_ids: Option<String>,
        filter_ids: Option<String>,
        active: Option<bool>,
        image_asset_id: Option<i64>,
        redeemable_start: Option<i64>,
        redeemable_end: Option<i64>,
        meta_data: Option<String>,
        ) -> Result<CreateEventResponse, ApiError>;

    /// Delete Event
    async fn delete_event(
        &self,
        version: f64,
        account_id: i64,
        event_id: i64,
        ) -> Result<DeleteEventResponse, ApiError>;

    /// Get Event
    async fn get_event(
        &self,
        version: f64,
        account_id: i64,
        event_id: i64,
        ) -> Result<GetEventResponse, ApiError>;

    /// Search Event Attendance
    async fn search_event_transactions(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        app_key: Option<String>,
        keyword: Option<String>,
        retailer_id: Option<i64>,
        retailer_location_id: Option<i64>,
        exclude_retailer_location_id: Option<i64>,
        listing_id: Option<i64>,
        offer_id: Option<i64>,
        offer_location_id: Option<i64>,
        customer_account_ids: Option<String>,
        affiliated_category_ids: Option<String>,
        start_date: Option<i64>,
        end_date: Option<i64>,
        statuses: Option<String>,
        sort_field: Option<models::SearchEventTransactionsSortFieldParameter>,
        descending: Option<bool>,
        start: Option<i32>,
        limit: Option<i32>,
        ) -> Result<SearchEventTransactionsResponse, ApiError>;

    /// Search Events
    async fn search_events(
        &self,
        version: f64,
        account_id: i64,
        keyword: Option<String>,
        active_only: Option<bool>,
        category_ids: Option<String>,
        filter_ids: Option<String>,
        offer_audience_ids: Option<String>,
        transaction_audience_ids: Option<String>,
        sort_field: Option<models::SearchEventsSortFieldParameter>,
        descending: Option<bool>,
        start_date: Option<i64>,
        end_date: Option<i64>,
        start: Option<i32>,
        limit: Option<i32>,
        ) -> Result<SearchEventsResponse, ApiError>;

    /// Update Event
    async fn update_event(
        &self,
        version: f64,
        account_id: i64,
        event_id: i64,
        retailer_location_ids: Option<String>,
        title: Option<String>,
        sub_title: Option<String>,
        details: Option<String>,
        category_ids: Option<String>,
        filter_ids: Option<String>,
        active: Option<bool>,
        image_asset_id: Option<i64>,
        redeemable_start: Option<i64>,
        redeemable_end: Option<i64>,
        ) -> Result<UpdateEventResponse, ApiError>;

    /// Get Facebook Token
    async fn get_token(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        ) -> Result<GetTokenResponse, ApiError>;

    /// Post to Facebook
    async fn graph_interface(
        &self,
        version: f64,
        event: String,
        device_id: Option<String>,
        account_id: Option<i64>,
        permissionable_type: Option<String>,
        permissionable_id: Option<i64>,
        asset_id: Option<i64>,
        game_type: Option<String>,
        app_key: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        ) -> Result<GraphInterfaceResponse, ApiError>;

    /// Create Favorite
    async fn add_favorite(
        &self,
        version: f64,
        favoritable_id: i64,
        favoritable_type: String,
        device_id: Option<String>,
        account_id: Option<i64>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        ) -> Result<AddFavoriteResponse, ApiError>;

    /// Delete Favorite
    async fn delete_favorite(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        favorite_id: Option<i64>,
        favoritable_id: Option<i64>,
        favoritable_type: Option<String>,
        ) -> Result<DeleteFavoriteResponse, ApiError>;

    /// Get Favorite
    async fn get_favorite(
        &self,
        version: f64,
        favorite_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        ) -> Result<GetFavoriteResponse, ApiError>;

    /// Search Favorites
    async fn search_favorites(
        &self,
        version: f64,
        favoritable_type: String,
        sort_field: models::SearchFavoritesSortFieldParameter,
        descending: bool,
        start: i32,
        limit: i32,
        active_only: bool,
        return_full_response: bool,
        device_id: Option<String>,
        account_id: Option<i64>,
        connection_account_id: Option<i64>,
        secondary_type: Option<String>,
        keyword: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        ) -> Result<SearchFavoritesResponse, ApiError>;

    /// Who has Favorited
    async fn who_has_favorited(
        &self,
        version: f64,
        favoritable_id: i64,
        favoritable_type: String,
        start: i32,
        limit: i32,
        device_id: Option<String>,
        account_id: Option<i64>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        keyword: Option<String>,
        ) -> Result<WhoHasFavoritedResponse, ApiError>;

    /// Create Filter
    async fn create_filter(
        &self,
        version: f64,
        account_id: i64,
        name: String,
        app_key: Option<String>,
        parent_filter_id: Option<i64>,
        description: Option<String>,
        external_id: Option<String>,
        external_type: Option<String>,
        active: Option<bool>,
        meta_data: Option<String>,
        ) -> Result<CreateFilterResponse, ApiError>;

    /// Delete Filter
    async fn delete_filter(
        &self,
        version: f64,
        account_id: i64,
        filter_id: i64,
        ) -> Result<DeleteFilterResponse, ApiError>;

    /// Get Filter
    async fn get_filter(
        &self,
        version: f64,
        filter_id: i64,
        ) -> Result<GetFilterResponse, ApiError>;

    /// Search Filters
    async fn search_filters(
        &self,
        version: f64,
        account_id: Option<i64>,
        keyword: Option<String>,
        app_key: Option<String>,
        response_group: Option<models::SearchCategoriesResponseGroupParameter>,
        root_only: Option<bool>,
        sort_field: Option<models::SearchCategoriesSortFieldParameter>,
        descending: Option<bool>,
        start: Option<i32>,
        limit: Option<i32>,
        active_only: Option<bool>,
        ) -> Result<SearchFiltersResponse, ApiError>;

    /// Update Filter
    async fn update_filter(
        &self,
        version: f64,
        account_id: i64,
        filter_id: i64,
        parent_filter_id: Option<i64>,
        name: Option<String>,
        description: Option<String>,
        external_id: Option<String>,
        external_type: Option<String>,
        active: Option<bool>,
        meta_data: Option<String>,
        ) -> Result<UpdateFilterResponse, ApiError>;

    /// Create Flag
    async fn create_flag(
        &self,
        version: f64,
        flagable_type: String,
        flagable_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        flag_description: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        ) -> Result<CreateFlagResponse, ApiError>;

    /// Delete Flag
    async fn delete_flag(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        item_being_flagged_type: Option<String>,
        item_being_flagged_id: Option<i64>,
        flagable_type: Option<String>,
        flagable_id: Option<i64>,
        ) -> Result<DeleteFlagResponse, ApiError>;

    /// Get Flag
    async fn get_flag(
        &self,
        version: f64,
        flagable_type: String,
        flagable_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        ) -> Result<GetFlagResponse, ApiError>;

    /// Get Flag Threshold
    async fn get_flag_threshold(
        &self,
        version: f64,
        item_being_flagged_type: String,
        app_key: String,
        ) -> Result<GetFlagThresholdResponse, ApiError>;

    /// Update Flag Threshold
    async fn update_flag_threshold(
        &self,
        version: f64,
        item_being_flagged_type: String,
        threshold: i64,
        app_key: String,
        device_id: Option<String>,
        account_id: Option<i64>,
        ) -> Result<UpdateFlagThresholdResponse, ApiError>;

    /// Create a Game
    async fn create_game(
        &self,
        version: f64,
        account_id: Option<i64>,
        app_key: Option<String>,
        title: Option<String>,
        description: Option<String>,
        meta_data: Option<String>,
        pack_ids: Option<String>,
        include_game_data: Option<bool>,
        ) -> Result<CreateGameResponse, ApiError>;

    /// Delete a Game
    async fn delete_game(
        &self,
        version: f64,
        account_id: i64,
        game_id: i64,
        ) -> Result<DeleteGameResponse, ApiError>;

    /// Get a Game by id
    async fn get_game(
        &self,
        version: f64,
        account_id: i64,
        game_id: i64,
        include_game_data: Option<bool>,
        ) -> Result<GetGameResponse, ApiError>;

    /// Search a Game
    async fn search_games(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        start: i32,
        limit: i32,
        keyword: Option<String>,
        app_version: Option<String>,
        include_game_data: Option<bool>,
        include_inactive: Option<bool>,
        ) -> Result<SearchGamesResponse, ApiError>;

    /// Update a Game
    async fn update_game(
        &self,
        version: f64,
        account_id: Option<i64>,
        game_id: Option<i64>,
        app_key: Option<String>,
        title: Option<String>,
        description: Option<String>,
        meta_data: Option<String>,
        pack_ids: Option<String>,
        include_game_data: Option<bool>,
        ) -> Result<UpdateGameResponse, ApiError>;

    /// Create Game Level
    async fn create_game_level(
        &self,
        version: f64,
        account_id: i64,
        name: String,
        game_data: String,
        game_data_suffix: String,
        app_key: Option<String>,
        description: Option<String>,
        difficulty: Option<String>,
        app_version: Option<String>,
        asset_image_id: Option<i64>,
        asset_icon_id: Option<i64>,
        visibility: Option<String>,
        friend_group: Option<bool>,
        connection_ids: Option<String>,
        connection_group_ids: Option<String>,
        balance: Option<f64>,
        active: Option<bool>,
        allocate_tickets: Option<bool>,
        ticket_count: Option<i64>,
        ticket_type: Option<String>,
        points: Option<i64>,
        tutorial_title: Option<String>,
        tutorial_message: Option<String>,
        tutorial_alignment: Option<String>,
        tutorial_image_asset_id: Option<i64>,
        offer_id: Option<i64>,
        meta_data: Option<String>,
        ) -> Result<CreateGameLevelResponse, ApiError>;

    /// Delete Game Level
    async fn delete_game_level(
        &self,
        version: f64,
        account_id: i64,
        level_id: i64,
        ) -> Result<DeleteGameLevelResponse, ApiError>;

    /// Get Game Level
    async fn get_game_level(
        &self,
        version: f64,
        account_id: i64,
        level_id: i64,
        include_game_data: Option<bool>,
        ) -> Result<GetGameLevelResponse, ApiError>;

    /// Search Game Levels
    async fn get_game_levels_by_application(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        keyword: Option<String>,
        sort_field: Option<String>,
        descending: Option<bool>,
        start: Option<i32>,
        limit: Option<i32>,
        app_version: Option<String>,
        include_game_data: Option<bool>,
        filters: Option<String>,
        ) -> Result<GetGameLevelsByApplicationResponse, ApiError>;

    /// Search Game Level by Billable Entity
    async fn get_game_levels_by_billable_entity(
        &self,
        version: f64,
        account_id: i64,
        app_key: Option<String>,
        keyword: Option<String>,
        sort_field: Option<models::GetGameLevelsByBillableEntitySortFieldParameter>,
        descending: Option<bool>,
        active_only: Option<bool>,
        start: Option<i64>,
        limit: Option<i64>,
        ) -> Result<GetGameLevelsByBillableEntityResponse, ApiError>;

    /// Get Level Questions
    async fn get_questions_in_level(
        &self,
        version: f64,
        level_id: i64,
        account_id: i64,
        ) -> Result<GetQuestionsInLevelResponse, ApiError>;

    /// Get Level Words
    async fn get_words_in_level(
        &self,
        version: f64,
        level_id: i64,
        account_id: i64,
        ) -> Result<GetWordsInLevelResponse, ApiError>;

    /// Update Game Level
    async fn update_game_level(
        &self,
        version: f64,
        account_id: i64,
        level_id: i64,
        app_key: Option<String>,
        name: Option<String>,
        description: Option<String>,
        difficulty: Option<String>,
        app_version: Option<String>,
        asset_image_id: Option<i64>,
        asset_icon_id: Option<i64>,
        game_data: Option<String>,
        game_data_suffix: Option<String>,
        visibility: Option<String>,
        friend_group: Option<bool>,
        connection_ids: Option<String>,
        connection_group_ids: Option<String>,
        balance: Option<f64>,
        active: Option<bool>,
        allocate_tickets: Option<bool>,
        ticket_count: Option<i64>,
        ticket_type: Option<String>,
        points: Option<i64>,
        tutorial_title: Option<String>,
        tutorial_message: Option<String>,
        tutorial_alignment: Option<String>,
        tutorial_image_asset_id: Option<i64>,
        offer_id: Option<i64>,
        meta_data: Option<String>,
        ) -> Result<UpdateGameLevelResponse, ApiError>;

    /// Update Level Questions
    async fn update_questions_in_level(
        &self,
        version: f64,
        level_id: i64,
        account_id: i64,
        question_ids: String,
        ) -> Result<UpdateQuestionsInLevelResponse, ApiError>;

    /// Update Level Words
    async fn update_words_in_level(
        &self,
        version: f64,
        level_id: i64,
        account_id: i64,
        word_ids: String,
        ) -> Result<UpdateWordsInLevelResponse, ApiError>;

    /// Accept Invite
    async fn accept_invite(
        &self,
        version: f64,
        token: String,
        account_id: i64,
        album_id: Option<i64>,
        mission_id: Option<i64>,
        album_contest_id: Option<i64>,
        offer_id: Option<i64>,
        offer_location_id: Option<i64>,
        retailer_location_id: Option<i64>,
        app_key: Option<String>,
        auto_friend: Option<bool>,
        auto_attend_event: Option<bool>,
        auto_favorite_offer: Option<bool>,
        auto_favorite_offer_location: Option<bool>,
        auto_favorite_retailer_location: Option<bool>,
        ) -> Result<AcceptInviteResponse, ApiError>;

    /// Invite to Contest
    async fn album_contest_invite(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        app_id: Option<i64>,
        app_key: Option<String>,
        album_contest_id: Option<i64>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        ) -> Result<AlbumContestInviteResponse, ApiError>;

    /// Invite to Collection
    async fn album_invite(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        app_id: Option<i64>,
        app_key: Option<String>,
        album_id: Option<i64>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        ) -> Result<AlbumInviteResponse, ApiError>;

    /// Invite to Event
    async fn event_invite(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        listing_id: i64,
        receiver_account_ids: Option<String>,
        retailer_location_id: Option<i64>,
        ) -> Result<EventInviteResponse, ApiError>;

    /// Invite to Game Level
    async fn game_invite(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        app_id: Option<i64>,
        app_key: Option<String>,
        game_level_id: Option<i64>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        ) -> Result<GameInviteResponse, ApiError>;

    /// Get Invite
    async fn get_invite(
        &self,
        version: f64,
        account_id: Option<i64>,
        token: Option<String>,
        album_id: Option<i64>,
        mission_id: Option<i64>,
        album_contest_id: Option<i64>,
        offer_id: Option<i64>,
        offer_location_id: Option<i64>,
        retailer_location_id: Option<i64>,
        app_key: Option<String>,
        ) -> Result<GetInviteResponse, ApiError>;

    /// Invite to Mission
    async fn mission_invite(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        app_id: Option<i64>,
        app_key: Option<String>,
        mission_id: Option<i64>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        ) -> Result<MissionInviteResponse, ApiError>;

    /// Invite to Offer
    async fn offer_invite(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        offer_id: i64,
        ) -> Result<OfferInviteResponse, ApiError>;

    /// Invite to Offer Location
    async fn offer_location_invite(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        offer_location_id: i64,
        ) -> Result<OfferLocationInviteResponse, ApiError>;

    /// Invite to Retailer Location
    async fn retailer_location_invite(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        retailer_location_id: i64,
        album_id: Option<i64>,
        ) -> Result<RetailerLocationInviteResponse, ApiError>;

    /// Create a leaderboard based on the rankingType, rankMode(leaderboardMode), sortField and limitation
    async fn create_leaderboard(
        &self,
        version: f64,
        account_id: Option<i64>,
        app_key: Option<String>,
        rank_type: Option<String>,
        leaderboard_mode: Option<String>,
        icon_media: Option<swagger::ByteArray>,
        icon_asset_id: Option<i64>,
        banner_media: Option<swagger::ByteArray>,
        banner_asset_id: Option<i64>,
        limitation: Option<i32>,
        sort_field: Option<String>,
        title: Option<String>,
        description: Option<String>,
        meta_data: Option<String>,
        ) -> Result<CreateLeaderboardResponse, ApiError>;

    /// Delete the Leader Board
    async fn delete_leaderboard(
        &self,
        version: f64,
        leaderboard_id: i64,
        account_id: Option<i64>,
        ) -> Result<DeleteLeaderboardResponse, ApiError>;

    /// Read a leaderboard by id and retrieve the matching ranking list
    async fn get_leaderboard(
        &self,
        version: f64,
        leaderboard_id: i64,
        account_id: Option<i64>,
        include_full_ranking_list: Option<bool>,
        ) -> Result<GetLeaderboardResponse, ApiError>;

    /// Search leaderboard and retrieve the matching ranking list
    async fn search_leaderboards(
        &self,
        version: f64,
        account_id: Option<i64>,
        app_key: Option<String>,
        global_only: Option<bool>,
        keyword: Option<String>,
        leaderboard_ids: Option<String>,
        rank_types: Option<String>,
        sort_field: Option<String>,
        descending: Option<bool>,
        include_inactive: Option<bool>,
        include_app_response: Option<bool>,
        start: Option<i32>,
        limit: Option<i32>,
        ) -> Result<SearchLeaderboardsResponse, ApiError>;

    /// Update a leaderboard based on the rankingType, rankMode(leaderboardMode), sortField and limitation
    async fn update_leaderboard(
        &self,
        version: f64,
        leaderboard_id: i64,
        account_id: Option<i64>,
        app_key: Option<String>,
        rank_type: Option<String>,
        leaderboard_mode: Option<String>,
        sort_field: Option<String>,
        icon_media: Option<swagger::ByteArray>,
        icon_asset_id: Option<i64>,
        banner_media: Option<swagger::ByteArray>,
        banner_asset_id: Option<i64>,
        limitation: Option<i32>,
        active: Option<bool>,
        title: Option<String>,
        description: Option<String>,
        meta_data: Option<String>,
        ) -> Result<UpdateLeaderboardResponse, ApiError>;

    /// Create Like
    async fn register_like(
        &self,
        version: f64,
        likable_type: String,
        likable_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        permissionable_type: Option<String>,
        permissionable_id: Option<i64>,
        like: Option<bool>,
        app: Option<String>,
        game_type: Option<String>,
        app_key: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        ) -> Result<RegisterLikeResponse, ApiError>;

    /// Delete Like
    async fn remove_like(
        &self,
        version: f64,
        likable_type: String,
        likable_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        ) -> Result<RemoveLikeResponse, ApiError>;

    /// Search Likes
    async fn search_likes(
        &self,
        version: f64,
        likable_type: String,
        likable_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        connection_account_ids: Option<String>,
        sort_field: Option<String>,
        descending: Option<bool>,
        updated_since: Option<i64>,
        updated_before: Option<i64>,
        start: Option<i32>,
        limit: Option<i32>,
        ) -> Result<SearchLikesResponse, ApiError>;

    /// Create Listing
    async fn create_listing(
        &self,
        version: f64,
        account_id: i64,
        name: String,
        filter_ids: Option<String>,
        description: Option<String>,
        start: Option<i64>,
        end: Option<i64>,
        location_name: Option<String>,
        location_description: Option<String>,
        is_private: Option<bool>,
        external_id: Option<String>,
        external_id2: Option<String>,
        external_group_id: Option<String>,
        active: Option<bool>,
        meta_data: Option<String>,
        ) -> Result<CreateListingResponse, ApiError>;

    /// Delete Listing
    async fn delete_listing(
        &self,
        version: f64,
        account_id: i64,
        listing_id: i64,
        ) -> Result<DeleteListingResponse, ApiError>;

    /// Get Listing
    async fn get_listing(
        &self,
        version: f64,
        listing_id: i64,
        ) -> Result<GetListingResponse, ApiError>;

    /// Search Listings
    async fn search_listing(
        &self,
        version: f64,
        account_id: Option<i64>,
        keyword: Option<String>,
        start: Option<i32>,
        limit: Option<i32>,
        active_only: Option<bool>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        start_date: Option<i64>,
        end_date: Option<i64>,
        category_ids: Option<String>,
        filter_ids: Option<String>,
        use_listing_order_ids: Option<bool>,
        external_id: Option<String>,
        external_id2: Option<String>,
        external_group_id: Option<String>,
        ) -> Result<SearchListingResponse, ApiError>;

    /// Summary Listing
    async fn summary_listing(
        &self,
        version: f64,
        account_id: Option<i64>,
        start_date: Option<i64>,
        category_ids: Option<String>,
        days_to_include: Option<i32>,
        use_listing_order_ids: Option<bool>,
        ) -> Result<SummaryListingResponse, ApiError>;

    /// Update Listing
    async fn update_listing(
        &self,
        version: f64,
        account_id: i64,
        listing_id: i64,
        filter_ids: Option<String>,
        name: Option<String>,
        description: Option<String>,
        start: Option<i64>,
        end: Option<i64>,
        location_name: Option<String>,
        location_description: Option<String>,
        is_private: Option<bool>,
        external_id: Option<String>,
        external_id2: Option<String>,
        external_group_id: Option<String>,
        active: Option<bool>,
        meta_data: Option<String>,
        ) -> Result<UpdateListingResponse, ApiError>;

    /// Create Trilateration Data with File
    async fn cache_trilateration_data(
        &self,
        version: f64,
        udid: String,
        source_time: Option<i64>,
        minimum_sample_size: Option<i32>,
        data: Option<String>,
        data_file: Option<swagger::ByteArray>,
        ) -> Result<CacheTrilaterationDataResponse, ApiError>;

    /// Create Trilateration Data with Rest
    async fn cache_trilateration_data_gzip(
        &self,
        version: f64,
        body: Option<models::TrilatCacheRequest>,
        ) -> Result<CacheTrilaterationDataGzipResponse, ApiError>;

    /// Get Location by IP
    async fn get_location_by_ip(
        &self,
        version: f64,
        ip: Option<String>,
        ) -> Result<GetLocationByIpResponse, ApiError>;

    /// Get Location by Trilateration
    async fn get_location_by_trilateration(
        &self,
        version: f64,
        account_id: Option<i64>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        data: Option<String>,
        response_filters: Option<String>,
        ) -> Result<GetLocationByTrilaterationResponse, ApiError>;

    /// Search Regions or Postal Codes
    async fn get_locations(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        currentlatitude: Option<f64>,
        currentlongitude: Option<f64>,
        current_latitude: Option<f64>,
        current_longitude: Option<f64>,
        query: Option<String>,
        zipcode: Option<String>,
        zip_code: Option<String>,
        selected_maplatitude: Option<f64>,
        selected_maplongitude: Option<f64>,
        selected_map_latitude: Option<f64>,
        selected_map_longitude: Option<f64>,
        search_range: Option<f64>,
        use_geocode: Option<bool>,
        _i: Option<i32>,
        start: Option<i32>,
        _l: Option<i32>,
        limit: Option<i32>,
        ) -> Result<GetLocationsResponse, ApiError>;

    /// Create new location
    async fn create_location_v2(
        &self,
        version: f64,
        body: Option<models::Location>,
        ) -> Result<CreateLocationV2Response, ApiError>;

    /// Update an existing location
    async fn update_location_v2(
        &self,
        version: f64,
        id: i64,
        body: Option<models::Location>,
        ) -> Result<UpdateLocationV2Response, ApiError>;

    /// Create Media
    async fn create_media(
        &self,
        version: f64,
        account_id: i64,
        title: String,
        barcode_type: models::CreateMediaBarcodeTypeParameter,
        no_expiration: bool,
        available_limit: i32,
        available_limit_per_user: i32,
        added_limit: i32,
        view_limit: i32,
        max_prints: i32,
        ticket_price: i64,
        full_price: f64,
        discount_price: f64,
        special_offer_type: models::CreateMediaSpecialOfferTypeParameter,
        offer_visibility: models::CreateMediaOfferVisibilityParameter,
        active: bool,
        retailer_location_ids: Option<String>,
        sub_title: Option<String>,
        details: Option<String>,
        sub_details: Option<String>,
        fine_print: Option<String>,
        barcode_entry: Option<String>,
        external_redeem_options: Option<String>,
        external_url: Option<String>,
        tickets_reward_type: Option<String>,
        tickets_reward: Option<i64>,
        activated: Option<i64>,
        expires: Option<i64>,
        ticket_price_type: Option<String>,
        show_remaining: Option<bool>,
        show_redeemed: Option<bool>,
        replaced: Option<bool>,
        featured: Option<bool>,
        category_ids: Option<String>,
        filter_ids: Option<String>,
        barcode_asset_id: Option<i64>,
        image_asset_id: Option<i64>,
        image_asset_id1: Option<i64>,
        image_asset_id2: Option<i64>,
        image_asset_id3: Option<i64>,
        image_asset_id4: Option<i64>,
        image_asset_id5: Option<i64>,
        publisher: Option<String>,
        redeemable_start: Option<i64>,
        redeemable_end: Option<i64>,
        condition_type: Option<models::CreateMediaConditionTypeParameter>,
        isbn: Option<String>,
        asin: Option<String>,
        catalog_numbers: Option<String>,
        parental_rating: Option<String>,
        availability_date: Option<i64>,
        media_type: Option<models::CreateMediaMediaTypeParameter>,
        duration: Option<i32>,
        author: Option<String>,
        release_date: Option<i64>,
        collection_ids: Option<String>,
        availability: Option<String>,
        availability_summary: Option<String>,
        ) -> Result<CreateMediaResponse, ApiError>;

    /// Delete Media
    async fn delete_media(
        &self,
        version: f64,
        account_id: i64,
        media_id: i64,
        ) -> Result<DeleteMediaResponse, ApiError>;

    /// Media Get
    async fn get_media(
        &self,
        version: f64,
        account_id: i64,
        media_id: i64,
        ) -> Result<GetMediaResponse, ApiError>;

    /// Search Media
    async fn search_media(
        &self,
        version: f64,
        account_id: i64,
        active_only: bool,
        sort_field: models::SearchEventsSortFieldParameter,
        descending: bool,
        keyword: Option<String>,
        category_ids: Option<String>,
        filter_ids: Option<String>,
        start: Option<i32>,
        limit: Option<i32>,
        ) -> Result<SearchMediaResponse, ApiError>;

    /// Update Media
    async fn update_media(
        &self,
        version: f64,
        account_id: i64,
        media_id: i64,
        retailer_location_ids: Option<String>,
        offer_locations: Option<String>,
        title: Option<String>,
        sub_title: Option<String>,
        details: Option<String>,
        sub_details: Option<String>,
        fine_print: Option<String>,
        barcode_type: Option<models::CreateMediaBarcodeTypeParameter>,
        barcode_entry: Option<String>,
        external_redeem_options: Option<String>,
        external_url: Option<String>,
        tickets_reward_type: Option<String>,
        tickets_reward: Option<i64>,
        activated: Option<i64>,
        expires: Option<i64>,
        no_expiration: Option<bool>,
        available_limit: Option<i32>,
        available_limit_per_user: Option<i32>,
        added_limit: Option<i32>,
        view_limit: Option<i32>,
        max_prints: Option<i32>,
        ticket_price_type: Option<String>,
        ticket_price: Option<i64>,
        full_price: Option<f64>,
        discount_price: Option<f64>,
        show_remaining: Option<bool>,
        show_redeemed: Option<bool>,
        replaced: Option<bool>,
        featured: Option<bool>,
        special_offer_type: Option<models::CreateMediaSpecialOfferTypeParameter>,
        offer_visibility: Option<models::CreateMediaOfferVisibilityParameter>,
        category_ids: Option<String>,
        filter_ids: Option<String>,
        active: Option<bool>,
        barcode_asset_id: Option<i64>,
        image_asset_id: Option<i64>,
        image_asset_id1: Option<i64>,
        image_asset_id2: Option<i64>,
        image_asset_id3: Option<i64>,
        image_asset_id4: Option<i64>,
        image_asset_id5: Option<i64>,
        publisher: Option<String>,
        redeemable_start: Option<i64>,
        redeemable_end: Option<i64>,
        condition_type: Option<models::CreateMediaConditionTypeParameter>,
        isbn: Option<String>,
        asin: Option<String>,
        catalog_numbers: Option<String>,
        availability_date: Option<i64>,
        parental_rating: Option<String>,
        media_type: Option<models::CreateMediaMediaTypeParameter>,
        duration: Option<i32>,
        author: Option<String>,
        release_date: Option<i64>,
        collection_ids: Option<String>,
        availability: Option<String>,
        availability_summary: Option<String>,
        ) -> Result<UpdateMediaResponse, ApiError>;

    /// Create Mission
    async fn create_mission(
        &self,
        version: f64,
        account_id: i64,
        title: String,
        description: Option<String>,
        sub_type: Option<String>,
        start_date: Option<i64>,
        end_date: Option<i64>,
        active: Option<bool>,
        game_level_ids: Option<String>,
        creative_ids: Option<String>,
        audience_ids: Option<String>,
        mission_task: Option<String>,
        format_type: Option<String>,
        offer_id: Option<i64>,
        balance: Option<f64>,
        advanced_reporting: Option<bool>,
        allocate_tickets: Option<bool>,
        ticket_count: Option<i64>,
        ticket_type: Option<String>,
        points: Option<i64>,
        meta_data: Option<String>,
        application_ids: Option<String>,
        devices: Option<String>,
        device_ids: Option<String>,
        device_versions: Option<String>,
        locations: Option<String>,
        radius: Option<String>,
        ) -> Result<CreateMissionResponse, ApiError>;

    /// Delete Mission
    async fn delete_mission(
        &self,
        version: f64,
        account_id: i64,
        mission_id: i64,
        ) -> Result<DeleteMissionResponse, ApiError>;

    /// Find Missions
    async fn find_missions(
        &self,
        version: f64,
        app_key: String,
        suffix: Option<String>,
        param_type: Option<String>,
        account_id: Option<i64>,
        app_version: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        device: Option<String>,
        device_identifier: Option<i64>,
        device_version: Option<String>,
        start: Option<i32>,
        limit: Option<i32>,
        include_game_data: Option<bool>,
        include_audiences: Option<bool>,
        allocates_tickets: Option<bool>,
        randomize: Option<bool>,
        targeted_ads_only: Option<bool>,
        mission_ids: Option<String>,
        audience_operator: Option<String>,
        ) -> Result<FindMissionsResponse, ApiError>;

    /// Get Mission
    async fn get_mission(
        &self,
        version: f64,
        account_id: i64,
        mission_id: i64,
        return_creative: Option<bool>,
        ) -> Result<GetMissionResponse, ApiError>;

    /// Import Mission
    async fn import_mission(
        &self,
        version: f64,
        account_id: i64,
        latitude: f64,
        longitude: f64,
        app_key: String,
        keyword: Option<String>,
        start: Option<i32>,
        limit: Option<i32>,
        ad_size: Option<models::CreateApplicationPlacementSizeParameter>,
        ) -> Result<ImportMissionResponse, ApiError>;

    /// Search Mission Formats
    async fn search_mission_formats(
        &self,
        version: f64,
        start: i32,
        limit: i32,
        active_only: bool,
        ) -> Result<SearchMissionFormatsResponse, ApiError>;

    /// Search Missions
    async fn search_missions(
        &self,
        version: f64,
        account_id: i64,
        keyword: Option<String>,
        sub_type: Option<String>,
        start: Option<i32>,
        limit: Option<i32>,
        include_game_data: Option<bool>,
        include_audiences: Option<bool>,
        include_inactive: Option<bool>,
        suffix: Option<String>,
        sort_field: Option<String>,
        descending: Option<bool>,
        ) -> Result<SearchMissionsResponse, ApiError>;

    /// Search Missions by Billable Entity
    async fn search_missions_by_billable_entity(
        &self,
        version: f64,
        account_id: i64,
        keyword: Option<String>,
        start: Option<i32>,
        limit: Option<i32>,
        include_game_data: Option<bool>,
        include_audiences: Option<bool>,
        include_inactive: Option<bool>,
        suffix: Option<String>,
        sort_field: Option<String>,
        descending: Option<bool>,
        ) -> Result<SearchMissionsByBillableEntityResponse, ApiError>;

    /// Update Mission
    async fn update_mission(
        &self,
        version: f64,
        account_id: i64,
        mission_id: i64,
        title: Option<String>,
        description: Option<String>,
        sub_type: Option<String>,
        meta_data: Option<String>,
        start_date: Option<i64>,
        end_date: Option<i64>,
        active: Option<bool>,
        game_level_ids: Option<String>,
        creative_ids: Option<String>,
        audience_ids: Option<String>,
        offer_id: Option<i64>,
        balance: Option<f64>,
        advanced_reporting: Option<bool>,
        allocate_tickets: Option<bool>,
        ticket_count: Option<i64>,
        ticket_type: Option<String>,
        points: Option<i64>,
        application_ids: Option<String>,
        devices: Option<String>,
        device_ids: Option<String>,
        device_versions: Option<String>,
        locations: Option<String>,
        radius: Option<String>,
        ) -> Result<UpdateMissionResponse, ApiError>;

    /// Create Mission Invite
    async fn create_mission_invite(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        mission_id: Option<i64>,
        join_code: Option<String>,
        include_game_data: Option<bool>,
        ) -> Result<CreateMissionInviteResponse, ApiError>;

    /// Delete Mission Invite
    async fn delete_mission_invite(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        mission_id: Option<i64>,
        mission_invite_id: Option<i64>,
        include_game_data: Option<bool>,
        ) -> Result<DeleteMissionInviteResponse, ApiError>;

    /// Get Mission Invite
    async fn get_mission_invite(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        mission_id: Option<i64>,
        mission_invite_id: Option<i64>,
        include_game_data: Option<bool>,
        include_scores: Option<String>,
        ) -> Result<GetMissionInviteResponse, ApiError>;

    /// Search Mission Invites
    async fn search_mission_invites(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        app_key: Option<String>,
        app_version: Option<String>,
        mission_id: Option<i64>,
        status: Option<String>,
        last_updated: Option<i64>,
        start: Option<i32>,
        limit: Option<i32>,
        keyword: Option<String>,
        mission_types: Option<String>,
        filter_by_billable: Option<bool>,
        include_game_data: Option<bool>,
        ) -> Result<SearchMissionInvitesResponse, ApiError>;

    /// Update Mission Invite
    async fn update_mission_invite(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        app_key: Option<String>,
        mission_id: Option<i64>,
        mission_invite_id: Option<i64>,
        pack_id: Option<i64>,
        game_level_id: Option<i64>,
        status: Option<String>,
        permissionable_type: Option<String>,
        permissionable_id: Option<i64>,
        include_game_data: Option<bool>,
        ) -> Result<UpdateMissionInviteResponse, ApiError>;

    /// Batch Note Operation
    async fn batch_operation(
        &self,
        version: f64,
        notable_id: i64,
        notable_type: String,
        device_id: Option<String>,
        account_id: Option<i64>,
        batch_operation: Option<String>,
        ) -> Result<BatchOperationResponse, ApiError>;

    /// Create Note
    async fn create_note(
        &self,
        version: f64,
        comment: String,
        device_id: Option<String>,
        account_id: Option<i64>,
        notable_type: Option<String>,
        notable_id: Option<i64>,
        note_type: Option<String>,
        asset_ids: Option<String>,
        tags: Option<String>,
        permissionable_type: Option<String>,
        permissionable_id: Option<i64>,
        app_key: Option<String>,
        location_description: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        meta_data: Option<String>,
        receiver_account_ids: Option<String>,
        return_full_response: Option<bool>,
        initialize_asset: Option<bool>,
        asset_return_nulls: Option<bool>,
        asset_album_id: Option<i64>,
        asset_collection_id: Option<i64>,
        asset_add_to_default_album: Option<String>,
        asset_add_to_media_library: Option<bool>,
        asset_version_code: Option<i32>,
        asset_version_name: Option<String>,
        asset_meta_data: Option<String>,
        asset_caption: Option<String>,
        asset_media: Option<swagger::ByteArray>,
        asset_media_url: Option<String>,
        asset_media_string: Option<String>,
        asset_media_string_file_name: Option<String>,
        asset_media_string_content_type: Option<String>,
        asset_attached_media: Option<swagger::ByteArray>,
        asset_attached_media_url: Option<String>,
        asset_attached_media_string: Option<String>,
        asset_attached_media_string_file_name: Option<String>,
        asset_attached_media_string_content_type: Option<String>,
        asset_location_description: Option<String>,
        asset_app: Option<String>,
        asset_search_tags: Option<String>,
        asset_latitude: Option<f64>,
        asset_longitude: Option<f64>,
        ) -> Result<CreateNoteResponse, ApiError>;

    /// Delete Note
    async fn delete_note(
        &self,
        version: f64,
        note_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        app_key: Option<String>,
        ) -> Result<DeleteNoteResponse, ApiError>;

    /// Get Note
    async fn get_note(
        &self,
        version: f64,
        note_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        return_full_response: Option<bool>,
        ) -> Result<GetNoteResponse, ApiError>;

    /// Search Notes
    async fn search_notes(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        notable_type: Option<String>,
        notable_id: Option<i64>,
        note_types: Option<String>,
        app_key: Option<String>,
        keyword: Option<String>,
        flag_count_minimum: Option<i64>,
        flags_exceed_threshold: Option<bool>,
        include_inactive: Option<bool>,
        sort_field: Option<models::SearchNotesSortFieldParameter>,
        descending: Option<bool>,
        return_full_response: Option<bool>,
        updated_since: Option<i64>,
        updated_before: Option<i64>,
        start: Option<i32>,
        limit: Option<i32>,
        ) -> Result<SearchNotesResponse, ApiError>;

    /// Update Note
    async fn update_note(
        &self,
        version: f64,
        note_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        comment: Option<String>,
        note_type: Option<String>,
        asset_ids: Option<String>,
        tags: Option<String>,
        permissionable_type: Option<String>,
        permissionable_id: Option<i64>,
        app_key: Option<String>,
        location_description: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        meta_data: Option<String>,
        return_full_response: Option<bool>,
        active: Option<bool>,
        update_asset: Option<bool>,
        asset_return_nulls: Option<bool>,
        asset_album_id: Option<i64>,
        asset_collection_id: Option<i64>,
        asset_add_to_default_album: Option<String>,
        asset_add_to_media_library: Option<bool>,
        asset_version_code: Option<i32>,
        asset_version_name: Option<String>,
        asset_meta_data: Option<String>,
        asset_caption: Option<String>,
        asset_media: Option<swagger::ByteArray>,
        asset_media_url: Option<String>,
        asset_media_string: Option<String>,
        asset_media_string_file_name: Option<String>,
        asset_media_string_content_type: Option<String>,
        asset_attached_media: Option<swagger::ByteArray>,
        asset_attached_media_url: Option<String>,
        asset_attached_media_string: Option<String>,
        asset_attached_media_string_file_name: Option<String>,
        asset_attached_media_string_content_type: Option<String>,
        asset_location_description: Option<String>,
        asset_app: Option<String>,
        asset_search_tags: Option<String>,
        asset_latitude: Option<f64>,
        asset_longitude: Option<f64>,
        ) -> Result<UpdateNoteResponse, ApiError>;

    /// Create Notification Template
    async fn create_notification_template(
        &self,
        version: f64,
        account_id: i64,
        conduit: String,
        title: String,
        body: String,
        app_key: Option<String>,
        event: Option<String>,
        tags: Option<String>,
        ) -> Result<CreateNotificationTemplateResponse, ApiError>;

    /// Create or update blocked notification settings
    async fn create_or_update_blocked_notifications(
        &self,
        version: f64,
        app_key: String,
        data: String,
        account_id: Option<i64>,
        ) -> Result<CreateOrUpdateBlockedNotificationsResponse, ApiError>;

    /// Delete Notification Template
    async fn delete_notification_template(
        &self,
        version: f64,
        account_id: i64,
        notification_template_id: i64,
        ) -> Result<DeleteNotificationTemplateResponse, ApiError>;

    /// Get Notification Template
    async fn get_notification_template(
        &self,
        version: f64,
        account_id: i64,
        notification_template_id: i64,
        ) -> Result<GetNotificationTemplateResponse, ApiError>;

    /// Get Notifications
    async fn get_notifications(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        connection_account_id: Option<i64>,
        app_key: Option<String>,
        event_type: Option<String>,
        content_ids: Option<String>,
        content_types: Option<String>,
        parent_ids: Option<String>,
        parent_types: Option<String>,
        action_category: Option<String>,
        conduits: Option<String>,
        keyword: Option<String>,
        return_read_messages: Option<bool>,
        mark_as_read: Option<bool>,
        from_date: Option<i64>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        return_sent: Option<bool>,
        ignore_flagged: Option<bool>,
        start: Option<i32>,
        limit: Option<i32>,
        ) -> Result<GetNotificationsResponse, ApiError>;

    /// Register Notification Token
    async fn register_notification_token(
        &self,
        version: f64,
        token: String,
        push_type: models::RegisterNotificationTokenPushTypeParameter,
        device_id: Option<String>,
        account_id: Option<i64>,
        environment: Option<String>,
        app_key: Option<String>,
        game_type: Option<String>,
        active: Option<bool>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        ) -> Result<RegisterNotificationTokenResponse, ApiError>;

    /// Search on the user's blocked notification settings
    async fn search_blocked_notifications(
        &self,
        version: f64,
        app_key: String,
        account_id: Option<i64>,
        search_tags: Option<String>,
        events: Option<String>,
        conduits: Option<String>,
        custom_types: Option<String>,
        content_types: Option<String>,
        content_ids: Option<String>,
        sort_field: Option<String>,
        descending: Option<bool>,
        start: Option<i32>,
        limit: Option<i32>,
        ) -> Result<SearchBlockedNotificationsResponse, ApiError>;

    /// Search Notification Templates
    async fn search_notification_template(
        &self,
        version: f64,
        account_id: i64,
        sort_field: String,
        descending: bool,
        start: i32,
        limit: i32,
        app_key: Option<String>,
        event: Option<String>,
        conduit: Option<String>,
        global_only: Option<bool>,
        reserved_only: Option<bool>,
        keyword: Option<String>,
        ) -> Result<SearchNotificationTemplateResponse, ApiError>;

    /// Search for Recipients
    async fn search_recipients(
        &self,
        version: f64,
        sort_field: models::SearchRecipientsSortFieldParameter,
        device_id: Option<String>,
        account_id: Option<i64>,
        app_key: Option<String>,
        conduit: Option<String>,
        keyword: Option<String>,
        audience_id: Option<i64>,
        audience_ids: Option<String>,
        connection_group_ids: Option<String>,
        recipient_account_ids: Option<String>,
        descending: Option<bool>,
        start: Option<i32>,
        limit: Option<i32>,
        ) -> Result<SearchRecipientsResponse, ApiError>;

    /// Search for Recipients (Counts/Grouped)
    async fn search_recipients_count(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        app_key: Option<String>,
        conduit: Option<String>,
        keyword: Option<String>,
        audience_id: Option<i64>,
        audience_ids: Option<String>,
        connection_group_ids: Option<String>,
        sort_field: Option<String>,
        descending: Option<bool>,
        start: Option<i32>,
        limit: Option<i32>,
        ) -> Result<SearchRecipientsCountResponse, ApiError>;

    /// Send Batch Notifications
    async fn send_batch_notifications(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        custom_message: String,
        conduit: Option<String>,
        content_id: Option<i64>,
        content_name: Option<String>,
        content_type: Option<String>,
        parent_id: Option<i64>,
        parent_type: Option<String>,
        ) -> Result<SendBatchNotificationsResponse, ApiError>;

    /// Send Custom Notifications
    async fn send_custom_notifications(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        receiver_account_ids: Option<String>,
        include_friend_group: Option<bool>,
        app_key: Option<String>,
        game_type: Option<String>,
        conduit: Option<String>,
        content_id: Option<i64>,
        content_name: Option<String>,
        content_type: Option<String>,
        parent_id: Option<i64>,
        parent_type: Option<String>,
        action_category: Option<String>,
        subject: Option<String>,
        custom_message: Option<String>,
        friend_only_apns: Option<bool>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        ) -> Result<SendCustomNotificationsResponse, ApiError>;

    /// Update Notification Template
    async fn update_notification_template(
        &self,
        version: f64,
        account_id: i64,
        notification_template_id: i64,
        title: Option<String>,
        body: Option<String>,
        tags: Option<String>,
        ) -> Result<UpdateNotificationTemplateResponse, ApiError>;

    /// Create Field
    async fn add_field(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        object_name: String,
        field_name: String,
        field_type: String,
        ) -> Result<AddFieldResponse, ApiError>;

    /// Create Object
    async fn create_object(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        object_name: String,
        ) -> Result<CreateObjectResponse, ApiError>;

    /// Delete Field
    async fn delete_field(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        object_name: String,
        field_name: String,
        ) -> Result<DeleteFieldResponse, ApiError>;

    /// Delete Object
    async fn delete_object(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        object_name: String,
        ) -> Result<DeleteObjectResponse, ApiError>;

    /// Get Object
    async fn get_object(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        object_name: String,
        ) -> Result<GetObjectResponse, ApiError>;

    /// Search Objects
    async fn search_object(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        start: i64,
        limit: i64,
        keyword: Option<String>,
        ) -> Result<SearchObjectResponse, ApiError>;

    /// Create Data
    async fn create_data(
        &self,
        version: f64,
        object_name: String,
        account_id: Option<i64>,
        body: Option<String>,
        ) -> Result<CreateDataResponse, ApiError>;

    /// Search Data
    async fn search_data(
        &self,
        version: f64,
        object_name: String,
        count: bool,
        start: i64,
        limit: i64,
        account_id: Option<i64>,
        criteria: Option<String>,
        order: Option<String>,
        include: Option<String>,
        ) -> Result<SearchDataResponse, ApiError>;

    /// Delete Data
    async fn delete_data(
        &self,
        version: f64,
        object_name: String,
        object_id: String,
        account_id: Option<i64>,
        ) -> Result<DeleteDataResponse, ApiError>;

    /// Get Data
    async fn get_data(
        &self,
        version: f64,
        object_name: String,
        object_id: String,
        account_id: Option<i64>,
        include: Option<String>,
        ) -> Result<GetDataResponse, ApiError>;

    /// Update Data
    async fn update_data(
        &self,
        version: f64,
        object_name: String,
        object_id: String,
        account_id: Option<i64>,
        body: Option<String>,
        ) -> Result<UpdateDataResponse, ApiError>;

    /// Update Offer Locations
    async fn batch_update_offer_locations(
        &self,
        version: f64,
        data: String,
        device_id: Option<String>,
        account_id: Option<i64>,
        ) -> Result<BatchUpdateOfferLocationsResponse, ApiError>;

    /// Create Offer
    async fn create_offer(
        &self,
        version: f64,
        include_offer_locations: bool,
        title: String,
        barcode_type: models::CreateMediaBarcodeTypeParameter,
        no_expiration: bool,
        available_limit: i32,
        available_limit_per_user: i32,
        added_limit: i32,
        view_limit: i32,
        max_prints: i32,
        ticket_price: i64,
        full_price: f64,
        discount_price: f64,
        offer_type: models::CreateOfferOfferTypeParameter,
        special_offer_type: models::CreateMediaSpecialOfferTypeParameter,
        offer_visibility: models::CreateMediaOfferVisibilityParameter,
        active: bool,
        device_id: Option<String>,
        account_id: Option<i64>,
        tags: Option<String>,
        parent_offer_id: Option<i64>,
        retailer_location_ids: Option<String>,
        offer_locations: Option<String>,
        sub_title: Option<String>,
        details: Option<String>,
        sub_details: Option<String>,
        fine_print: Option<String>,
        barcode_entry: Option<String>,
        external_redeem_options: Option<String>,
        external_url: Option<String>,
        external_id: Option<String>,
        tickets_reward_type: Option<String>,
        tickets_reward: Option<i64>,
        activated: Option<i64>,
        expires: Option<i64>,
        ticket_price_type: Option<String>,
        show_remaining: Option<bool>,
        show_redeemed: Option<bool>,
        replaced: Option<bool>,
        featured: Option<bool>,
        category_ids: Option<String>,
        filter_ids: Option<String>,
        barcode_asset_id: Option<i64>,
        image_asset_id: Option<i64>,
        image_asset_id1: Option<i64>,
        image_asset_id2: Option<i64>,
        image_asset_id3: Option<i64>,
        image_asset_id4: Option<i64>,
        image_asset_id5: Option<i64>,
        publisher: Option<String>,
        redeemable_start: Option<i64>,
        redeemable_end: Option<i64>,
        brand: Option<String>,
        product_type: Option<models::CreateOfferProductTypeParameter>,
        condition_type: Option<models::CreateMediaConditionTypeParameter>,
        isbn: Option<String>,
        asin: Option<String>,
        catalog_numbers: Option<String>,
        department: Option<String>,
        features: Option<String>,
        minimum_price: Option<f64>,
        width: Option<f64>,
        height: Option<f64>,
        depth: Option<f64>,
        weight: Option<f64>,
        unit: Option<models::CreateOfferUnitParameter>,
        studio: Option<String>,
        parental_rating: Option<String>,
        publish_date: Option<i64>,
        availability_date: Option<i64>,
        size_id: Option<i64>,
        listing_id: Option<i64>,
        media_type: Option<models::CreateMediaMediaTypeParameter>,
        duration: Option<i32>,
        author: Option<String>,
        release_date: Option<i64>,
        collection_ids: Option<String>,
        reboot_time_hour: Option<i32>,
        reboot_time_minute: Option<i32>,
        idle_timeout_in_second: Option<i32>,
        serial_number: Option<String>,
        udid: Option<String>,
        device_type: Option<String>,
        device_power: Option<f64>,
        device_interference: Option<f64>,
        availability: Option<String>,
        availability_summary: Option<String>,
        ) -> Result<CreateOfferResponse, ApiError>;

    /// Delete Offer
    async fn delete_offer(
        &self,
        version: f64,
        offer_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        ) -> Result<DeleteOfferResponse, ApiError>;

    /// Delete Offer Location
    async fn delete_offer_location(
        &self,
        version: f64,
        offer_location_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        ) -> Result<DeleteOfferLocationResponse, ApiError>;

    /// Get Offer
    async fn get_offer(
        &self,
        version: f64,
        offer_id: i64,
        include_offer_locations: bool,
        device_id: Option<String>,
        account_id: Option<i64>,
        ) -> Result<GetOfferResponse, ApiError>;

    /// Get Offer
    async fn get_offer_details(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        offer_id: Option<i64>,
        offer_location_id: Option<i64>,
        distance: Option<f64>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        include_offer_locations: Option<bool>,
        include_retailer_locations: Option<bool>,
        include_child_offers: Option<bool>,
        ) -> Result<GetOfferDetailsResponse, ApiError>;

    /// Get Offers (Counts)
    async fn get_offer_list_counts(
        &self,
        version: f64,
        latitude: f64,
        longitude: f64,
        search_range: Option<f64>,
        distance_unit: Option<models::GetOfferListCountsDistanceUnitParameter>,
        ) -> Result<GetOfferListCountsResponse, ApiError>;

    /// Get Offer Location
    async fn get_offer_location(
        &self,
        version: f64,
        offer_location_id: Option<i64>,
        udid: Option<String>,
        ) -> Result<GetOfferLocationResponse, ApiError>;

    /// Search Offer Locations
    async fn get_offer_locations_for_retailers(
        &self,
        version: f64,
        sort_field: models::SearchOffersForConsumerGroupByParameter,
        descending: bool,
        start: i32,
        limit: i32,
        active_only: bool,
        include_retailer_location: bool,
        device_id: Option<String>,
        account_id: Option<i64>,
        keyword: Option<String>,
        retailer_id: Option<i64>,
        retailer_location_id: Option<i64>,
        offer_type: Option<models::CreateOfferOfferTypeParameter>,
        special_offer_type: Option<models::CreateMediaSpecialOfferTypeParameter>,
        barcode_type: Option<String>,
        barcode_entry: Option<String>,
        isbn: Option<String>,
        asin: Option<String>,
        device_status: Option<models::GetOfferLocationsForRetailersDeviceStatusParameter>,
        needs_notification_sent: Option<bool>,
        last_notification_sent: Option<i64>,
        ) -> Result<GetOfferLocationsForRetailersResponse, ApiError>;

    /// Search Offers
    async fn get_offers_for_retailers(
        &self,
        version: f64,
        offer_visibility: models::CreateMediaOfferVisibilityParameter,
        sort_field: models::SearchEventsSortFieldParameter,
        descending: bool,
        start: i32,
        limit: i32,
        available_only: bool,
        active_only: bool,
        include_categories: bool,
        include_filters: bool,
        include_offer_locations: bool,
        device_id: Option<String>,
        account_id: Option<i64>,
        category_ids: Option<String>,
        filter_ids: Option<String>,
        q: Option<String>,
        keyword: Option<String>,
        retailer_id: Option<i64>,
        retailer_location_id: Option<i64>,
        coupon_type: Option<models::CreateOfferOfferTypeParameter>,
        offer_type: Option<models::CreateOfferOfferTypeParameter>,
        offer_types: Option<String>,
        special_offer_type: Option<models::CreateMediaSpecialOfferTypeParameter>,
        _i: Option<i32>,
        _l: Option<i32>,
        barcode_type: Option<String>,
        barcode_entry: Option<String>,
        isbn: Option<String>,
        asin: Option<String>,
        device_status: Option<models::GetOfferLocationsForRetailersDeviceStatusParameter>,
        needs_notification_sent: Option<bool>,
        last_notification_sent: Option<i64>,
        ) -> Result<GetOffersForRetailersResponse, ApiError>;

    /// Update Offer Transaction
    async fn redeem_offer_transaction(
        &self,
        version: f64,
        offer_transaction_id: i64,
        status: i32,
        device_id: Option<String>,
        account_id: Option<i64>,
        offer_location_id: Option<i64>,
        ) -> Result<RedeemOfferTransactionResponse, ApiError>;

    /// Search Offer Transactions
    async fn search_offer_transactions_for_retailers(
        &self,
        version: f64,
        sort_field: models::SearchEventTransactionsSortFieldParameter,
        descending: bool,
        start: i32,
        limit: i32,
        active_only: bool,
        device_id: Option<String>,
        account_id: Option<i64>,
        q: Option<String>,
        keyword: Option<String>,
        retailer_id: Option<i64>,
        retailer_location_id: Option<i64>,
        offer_id: Option<i64>,
        offer_location_id: Option<i64>,
        redeemed: Option<bool>,
        reservations_only: Option<bool>,
        coupon_type: Option<models::CreateOfferOfferTypeParameter>,
        offer_type: Option<models::CreateOfferOfferTypeParameter>,
        special_offer_type: Option<models::CreateMediaSpecialOfferTypeParameter>,
        customer_account_ids: Option<String>,
        category_ids: Option<String>,
        redeemable_start_date: Option<i64>,
        redeemable_end_date: Option<i64>,
        _i: Option<i32>,
        _l: Option<i32>,
        ) -> Result<SearchOfferTransactionsForRetailersResponse, ApiError>;

    /// Search Offers
    async fn search_offers_for_consumer(
        &self,
        version: f64,
        latitude: f64,
        longitude: f64,
        recommendation_type: models::SearchOffersForConsumerRecommendationTypeParameter,
        location_id: i64,
        start: i32,
        limit: i32,
        max_recommendations: i32,
        distance_unit: models::SearchOffersForConsumerDistanceUnitParameter,
        app_key: Option<String>,
        device_id: Option<String>,
        account_id: Option<i64>,
        search_range: Option<f64>,
        tags: Option<String>,
        supported_postal_codes: Option<String>,
        keyword: Option<String>,
        categories: Option<String>,
        filters: Option<String>,
        offer_types: Option<String>,
        param_type: Option<String>,
        sort_field: Option<String>,
        recommend_offer_ids: Option<String>,
        retailer_location_ids: Option<String>,
        offer_id: Option<i64>,
        include_mission: Option<bool>,
        include_categories: Option<bool>,
        include_filters: Option<bool>,
        include_expired: Option<bool>,
        include_favorite: Option<bool>,
        closest_offer_only: Option<bool>,
        search_expression: Option<String>,
        group_by: Option<models::SearchOffersForConsumerGroupByParameter>,
        ) -> Result<SearchOffersForConsumerResponse, ApiError>;

    /// Get Offers (Top)
    async fn top_offer_transactions(
        &self,
        version: f64,
        start: Option<i32>,
        limit: Option<i32>,
        ) -> Result<TopOfferTransactionsResponse, ApiError>;

    /// Update Offer
    async fn update_offer(
        &self,
        version: f64,
        offer_id: i64,
        include_offer_locations: bool,
        device_id: Option<String>,
        account_id: Option<i64>,
        parent_offer_id: Option<i64>,
        retailer_location_ids: Option<String>,
        offer_locations: Option<String>,
        tags: Option<String>,
        title: Option<String>,
        sub_title: Option<String>,
        details: Option<String>,
        sub_details: Option<String>,
        fine_print: Option<String>,
        barcode_type: Option<models::CreateMediaBarcodeTypeParameter>,
        barcode_entry: Option<String>,
        external_redeem_options: Option<String>,
        external_url: Option<String>,
        external_id: Option<String>,
        tickets_reward_type: Option<String>,
        tickets_reward: Option<i64>,
        activated: Option<i64>,
        expires: Option<i64>,
        no_expiration: Option<bool>,
        available_limit: Option<i32>,
        available_limit_per_user: Option<i32>,
        added_limit: Option<i32>,
        view_limit: Option<i32>,
        max_prints: Option<i32>,
        ticket_price_type: Option<String>,
        ticket_price: Option<i64>,
        full_price: Option<f64>,
        discount_price: Option<f64>,
        show_remaining: Option<bool>,
        show_redeemed: Option<bool>,
        replaced: Option<bool>,
        featured: Option<bool>,
        offer_type: Option<models::CreateOfferOfferTypeParameter>,
        special_offer_type: Option<models::CreateMediaSpecialOfferTypeParameter>,
        offer_visibility: Option<models::CreateMediaOfferVisibilityParameter>,
        category_ids: Option<String>,
        filter_ids: Option<String>,
        active: Option<bool>,
        barcode_asset_id: Option<i64>,
        image_asset_id: Option<i64>,
        image_asset_id1: Option<i64>,
        image_asset_id2: Option<i64>,
        image_asset_id3: Option<i64>,
        image_asset_id4: Option<i64>,
        image_asset_id5: Option<i64>,
        publisher: Option<String>,
        redeemable_start: Option<i64>,
        redeemable_end: Option<i64>,
        brand: Option<String>,
        product_type: Option<models::CreateOfferProductTypeParameter>,
        condition_type: Option<models::CreateMediaConditionTypeParameter>,
        isbn: Option<String>,
        asin: Option<String>,
        catalog_numbers: Option<String>,
        department: Option<String>,
        features: Option<String>,
        minimum_price: Option<f64>,
        width: Option<f64>,
        height: Option<f64>,
        depth: Option<f64>,
        weight: Option<f64>,
        unit: Option<models::CreateOfferUnitParameter>,
        studio: Option<String>,
        parental_rating: Option<String>,
        publish_date: Option<i64>,
        availability_date: Option<i64>,
        size_id: Option<i64>,
        listing_id: Option<i64>,
        media_type: Option<models::CreateMediaMediaTypeParameter>,
        duration: Option<i32>,
        author: Option<String>,
        release_date: Option<i64>,
        collection_ids: Option<String>,
        reboot_time_hour: Option<i32>,
        reboot_time_minute: Option<i32>,
        idle_timeout_in_second: Option<i32>,
        serial_number: Option<String>,
        udid: Option<String>,
        device_type: Option<String>,
        device_power: Option<f64>,
        device_interference: Option<f64>,
        availability: Option<String>,
        availability_summary: Option<String>,
        ) -> Result<UpdateOfferResponse, ApiError>;

    /// Activate Offer
    async fn update_offer_status(
        &self,
        version: f64,
        offer_ids: String,
        active: bool,
        device_id: Option<String>,
        account_id: Option<i64>,
        ) -> Result<UpdateOfferStatusResponse, ApiError>;

    /// Create Offer Status
    async fn create_offer_transaction_status(
        &self,
        version: f64,
        name: String,
        code: i32,
        device_id: Option<String>,
        account_id: Option<i64>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        description: Option<String>,
        role: Option<String>,
        active: Option<bool>,
        application_ids: Option<String>,
        ) -> Result<CreateOfferTransactionStatusResponse, ApiError>;

    /// Delete Offer Status
    async fn delete_offer_transaction_status(
        &self,
        version: f64,
        status_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        ) -> Result<DeleteOfferTransactionStatusResponse, ApiError>;

    /// Get Offer Status
    async fn get_offer_transaction_status(
        &self,
        version: f64,
        status_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        ) -> Result<GetOfferTransactionStatusResponse, ApiError>;

    /// Search Offer Status
    async fn search_offer_transaction_statuses(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        keyword: Option<String>,
        role: Option<String>,
        app_key: Option<String>,
        sort_field: Option<models::SearchOfferTransactionStatusesSortFieldParameter>,
        descending: Option<bool>,
        start: Option<i32>,
        limit: Option<i32>,
        include_inactive: Option<bool>,
        ) -> Result<SearchOfferTransactionStatusesResponse, ApiError>;

    /// Update Offer Status
    async fn update_offer_transaction_status(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        status_id: Option<i64>,
        name: Option<String>,
        description: Option<String>,
        code: Option<i32>,
        role: Option<String>,
        active: Option<bool>,
        application_ids: Option<String>,
        ) -> Result<UpdateOfferTransactionStatusResponse, ApiError>;

    /// Generate images with OpenAI
    async fn image_generation(
        &self,
        version: f64,
        account_id: i64,
        post_body: String,
        return_raw_response: Option<bool>,
        ) -> Result<ImageGenerationResponse, ApiError>;

    /// Request Optimization
    async fn request_optimization(
        &self,
        version: f64,
        body: Option<models::Orders>,
        ) -> Result<RequestOptimizationResponse, ApiError>;

    /// Get Optimization Result
    async fn get_optimization_result(
        &self,
        version: f64,
        batch_id: String,
        start: i32,
        limit: i32,
        ) -> Result<GetOptimizationResultResponse, ApiError>;

    /// Add Movie
    async fn add_movie(
        &self,
        version: f64,
        account_id: i64,
        movie_name: String,
        third_party_account_id: Option<String>,
        tags: Option<String>,
        file: Option<swagger::ByteArray>,
        url: Option<String>,
        callback: Option<String>,
        ) -> Result<AddMovieResponse, ApiError>;

    /// Search Docs
    async fn ai_docs(
        &self,
        version: f64,
        account_id: i64,
        doc: String,
        return_topics: Option<bool>,
        limit: Option<i32>,
        offset: Option<i32>,
        ) -> Result<AiDocsResponse, ApiError>;

    /// Find images
    async fn ai_find_images(
        &self,
        version: f64,
        account_id: i64,
        text: String,
        parse_flag: Option<String>,
        fetch_flag: Option<String>,
        size: Option<String>,
        ) -> Result<AiFindImagesResponse, ApiError>;

    /// Search Tags
    async fn ai_tags(
        &self,
        version: f64,
        account_id: i64,
        tags: String,
        conditional: Option<String>,
        limit: Option<i32>,
        offset: Option<i32>,
        ) -> Result<AiTagsResponse, ApiError>;

    /// Search Text
    async fn ai_text(
        &self,
        version: f64,
        account_id: i64,
        terms: String,
        conditional: Option<String>,
        limit: Option<i32>,
        offset: Option<i32>,
        ) -> Result<AiTextResponse, ApiError>;

    /// Batch Analysis
    async fn batch(
        &self,
        version: f64,
        account_id: i64,
        third_party_account_id: Option<String>,
        limit: Option<i32>,
        operations: Option<String>,
        file: Option<swagger::ByteArray>,
        url: Option<String>,
        callback: Option<String>,
        ) -> Result<BatchResponse, ApiError>;

    /// Creates an instant episode
    async fn create_instant_episode(
        &self,
        version: f64,
        account_id: i64,
        data: String,
        ) -> Result<CreateInstantEpisodeResponse, ApiError>;

    /// Create VoiceCanvas images
    async fn create_voice_canvas(
        &self,
        version: f64,
        account_id: i64,
        dimensions: String,
        third_party_account_id: Option<String>,
        text: Option<String>,
        file: Option<swagger::ByteArray>,
        url: Option<String>,
        parse_flag: Option<bool>,
        fetch_flag: Option<bool>,
        callback: Option<String>,
        ) -> Result<CreateVoiceCanvasResponse, ApiError>;

    /// Detect emotions
    async fn emotion(
        &self,
        version: f64,
        account_id: i64,
        third_party_account_id: Option<String>,
        file: Option<swagger::ByteArray>,
        url: Option<String>,
        callback: Option<String>,
        ) -> Result<EmotionResponse, ApiError>;

    /// Starts a StoryStitch video render
    async fn start_video_render(
        &self,
        version: f64,
        account_id: i64,
        data: String,
        ) -> Result<StartVideoRenderResponse, ApiError>;

    /// Speach to Text
    async fn stt(
        &self,
        version: f64,
        account_id: i64,
        third_party_account_id: Option<String>,
        source_language: Option<String>,
        target_language: Option<String>,
        file: Option<swagger::ByteArray>,
        url: Option<String>,
        callback: Option<String>,
        ) -> Result<SttResponse, ApiError>;

    /// Summarize Topics
    async fn summarize_topics(
        &self,
        version: f64,
        account_id: i64,
        third_party_account_id: Option<String>,
        doc: Option<String>,
        file: Option<swagger::ByteArray>,
        url: Option<String>,
        limit: Option<i32>,
        offset: Option<i32>,
        callback: Option<String>,
        ) -> Result<SummarizeTopicsResponse, ApiError>;

    /// Detect Technical Issues
    async fn tech_tune(
        &self,
        version: f64,
        account_id: i64,
        num_faces_expected: i32,
        third_party_account_id: Option<String>,
        file: Option<swagger::ByteArray>,
        url: Option<String>,
        callback: Option<String>,
        ) -> Result<TechTuneResponse, ApiError>;

    /// Text to Speach
    async fn tts(
        &self,
        version: f64,
        account_id: i64,
        text: String,
        third_party_account_id: Option<String>,
        language: Option<String>,
        voice: Option<String>,
        callback: Option<String>,
        ) -> Result<TtsResponse, ApiError>;

    /// Get Add Movie Result
    async fn get_add_movie_result(
        &self,
        version: f64,
        request_id: String,
        account_id: i64,
        ) -> Result<GetAddMovieResultResponse, ApiError>;

    /// Get Batch Analysis Results
    async fn get_batch(
        &self,
        version: f64,
        request_id: String,
        account_id: i64,
        ) -> Result<GetBatchResponse, ApiError>;

    /// Get Emotion Results
    async fn get_emotion(
        &self,
        version: f64,
        request_id: String,
        account_id: i64,
        ) -> Result<GetEmotionResponse, ApiError>;

    /// Check episode status
    async fn get_episode_status(
        &self,
        version: f64,
        episode_id: i64,
        account_id: i64,
        ) -> Result<GetEpisodeStatusResponse, ApiError>;

    /// Check episode status
    async fn get_render_status(
        &self,
        version: f64,
        render_id: String,
        account_id: i64,
        ) -> Result<GetRenderStatusResponse, ApiError>;

    /// Get Speach to Text Result
    async fn get_stt(
        &self,
        version: f64,
        request_id: String,
        account_id: i64,
        ) -> Result<GetSttResponse, ApiError>;

    /// Get TechTune Results
    async fn get_tech_tune(
        &self,
        version: f64,
        request_id: String,
        account_id: i64,
        ) -> Result<GetTechTuneResponse, ApiError>;

    /// Get Topics
    async fn get_topics(
        &self,
        version: f64,
        request_id: String,
        account_id: i64,
        ) -> Result<GetTopicsResponse, ApiError>;

    /// Get Text to Speach Result
    async fn get_tts(
        &self,
        version: f64,
        request_id: String,
        account_id: i64,
        ) -> Result<GetTtsResponse, ApiError>;

    /// Get VoiceCanvas images
    async fn get_voice_canvas(
        &self,
        version: f64,
        request_id: String,
        account_id: i64,
        ) -> Result<GetVoiceCanvasResponse, ApiError>;

    /// Create Pack
    async fn create_pack(
        &self,
        version: f64,
        account_id: i64,
        title: String,
        pack_order: i64,
        price: i32,
        highest: bool,
        allocate_tickets: bool,
        ticket_count: i64,
        description: Option<String>,
        search_tags: Option<String>,
        active: Option<bool>,
        game_type: Option<String>,
        app_key: Option<String>,
        pack_type: Option<models::CreatePackPackTypeParameter>,
        sequence_type: Option<models::CreatePackSequenceTypeParameter>,
        background_id: Option<i64>,
        image_id: Option<i64>,
        start_date: Option<i64>,
        end_date: Option<i64>,
        author_override: Option<String>,
        price_type: Option<String>,
        game_level_ids: Option<String>,
        in_game: Option<bool>,
        ticket_type: Option<String>,
        points: Option<i64>,
        ) -> Result<CreatePackResponse, ApiError>;

    /// Delete Pack
    async fn delete_pack(
        &self,
        version: f64,
        account_id: i64,
        pack_id: i64,
        ) -> Result<DeletePackResponse, ApiError>;

    /// Get Pack
    async fn get_pack(
        &self,
        version: f64,
        account_id: i64,
        pack_id: i64,
        include_game_data: bool,
        ) -> Result<GetPackResponse, ApiError>;

    /// Search Packs
    async fn search_packs(
        &self,
        version: f64,
        account_id: i64,
        sort_field: models::SearchPacksSortFieldParameter,
        descending: bool,
        keyword: Option<String>,
        pack_type: Option<models::CreatePackPackTypeParameter>,
        start: Option<i32>,
        limit: Option<i32>,
        include_game_data: Option<bool>,
        include_inactive: Option<bool>,
        app_key: Option<String>,
        ) -> Result<SearchPacksResponse, ApiError>;

    /// Update Pack
    async fn update_pack(
        &self,
        version: f64,
        account_id: i64,
        pack_id: i64,
        allocate_tickets: bool,
        ticket_count: i64,
        title: Option<String>,
        description: Option<String>,
        search_tags: Option<String>,
        active: Option<bool>,
        game_type: Option<String>,
        app_key: Option<String>,
        pack_type: Option<models::CreatePackPackTypeParameter>,
        pack_order: Option<i64>,
        sequence_type: Option<models::CreatePackSequenceTypeParameter>,
        background_id: Option<i64>,
        image_id: Option<i64>,
        start_date: Option<i64>,
        end_date: Option<i64>,
        author_override: Option<String>,
        price: Option<i32>,
        price_type: Option<String>,
        game_level_ids: Option<String>,
        in_game: Option<bool>,
        highest: Option<bool>,
        ticket_type: Option<String>,
        points: Option<i64>,
        ) -> Result<UpdatePackResponse, ApiError>;

    /// Process All Participant Feeds
    async fn process_all_participants(
        &self,
        version: f64,
        account_id: i64,
        app_key: Option<String>,
        use_short_name_as_id: Option<bool>,
        ) -> Result<ProcessAllParticipantsResponse, ApiError>;

    /// Process Participants Feed
    async fn process_participants(
        &self,
        version: f64,
        account_id: i64,
        league: String,
        app_key: Option<String>,
        use_short_name_as_id: Option<bool>,
        file: Option<swagger::ByteArray>,
        ) -> Result<ProcessParticipantsResponse, ApiError>;

    /// Calculate Path
    async fn compute_path(
        &self,
        version: f64,
        data: String,
        units: models::ComputePathUnitsParameter,
        reduce_path: bool,
        directions: bool,
        ) -> Result<ComputePathResponse, ApiError>;

    /// Create Postal Code
    async fn create_postal_code(
        &self,
        version: f64,
        account_id: i64,
        code: String,
        latitude: f64,
        longitude: f64,
        state_code: Option<String>,
        city: Option<String>,
        active: Option<bool>,
        ) -> Result<CreatePostalCodeResponse, ApiError>;

    /// Delete Postal Code
    async fn delete_postal_code(
        &self,
        version: f64,
        account_id: i64,
        postal_code_id: i64,
        ) -> Result<DeletePostalCodeResponse, ApiError>;

    /// Get Postal Code
    async fn get_postal_code(
        &self,
        version: f64,
        postal_code_id: i64,
        ) -> Result<GetPostalCodeResponse, ApiError>;

    /// Search Postal Codes
    async fn get_postal_codes(
        &self,
        version: f64,
        sort_field: String,
        descending: bool,
        latitude: Option<f64>,
        longitude: Option<f64>,
        keyword: Option<String>,
        miles: Option<f64>,
        start: Option<i32>,
        limit: Option<i32>,
        ) -> Result<GetPostalCodesResponse, ApiError>;

    /// Update Postal Code
    async fn update_postal_code(
        &self,
        version: f64,
        account_id: i64,
        postal_code_id: i64,
        code: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        state_code: Option<String>,
        city: Option<String>,
        active: Option<bool>,
        ) -> Result<UpdatePostalCodeResponse, ApiError>;

    /// Create Persona
    async fn create_persona(
        &self,
        version: f64,
        account_id: i64,
        title: String,
        preview_accounts: Option<String>,
        date: Option<i64>,
        age: Option<i32>,
        gender: Option<String>,
        game_experience_level: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        ) -> Result<CreatePersonaResponse, ApiError>;

    /// Delete Persona
    async fn delete_persona(
        &self,
        version: f64,
        account_id: i64,
        persona_id: i64,
        ) -> Result<DeletePersonaResponse, ApiError>;

    /// Get Persona
    async fn get_persona_list(
        &self,
        version: f64,
        account_id: i64,
        persona_id: i64,
        ) -> Result<GetPersonaListResponse, ApiError>;

    /// Search Personas
    async fn search_persona(
        &self,
        version: f64,
        account_id: i64,
        start: i32,
        limit: i32,
        ) -> Result<SearchPersonaResponse, ApiError>;

    /// Update Persona
    async fn update_persona(
        &self,
        version: f64,
        account_id: i64,
        persona_id: i64,
        title: Option<String>,
        preview_accounts: Option<String>,
        active: Option<bool>,
        date: Option<i64>,
        age: Option<i32>,
        gender: Option<String>,
        game_experience_level: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        ) -> Result<UpdatePersonaResponse, ApiError>;

    /// Create Program
    async fn create_program(
        &self,
        version: f64,
        body: Option<models::Program>,
        ) -> Result<CreateProgramResponse, ApiError>;

    /// Search Programs
    async fn search_programs(
        &self,
        version: f64,
        sort_field: String,
        descending: bool,
        start: i32,
        limit: i32,
        active_only: bool,
        keyword: Option<String>,
        ) -> Result<SearchProgramsResponse, ApiError>;

    /// Delete Program
    async fn delete_program(
        &self,
        version: f64,
        id: i64,
        ) -> Result<DeleteProgramResponse, ApiError>;

    /// Get Program
    async fn get_program(
        &self,
        version: f64,
        id: i64,
        ) -> Result<GetProgramResponse, ApiError>;

    /// Update Program
    async fn post_program(
        &self,
        version: f64,
        id: i64,
        body: Option<models::Program>,
        ) -> Result<PostProgramResponse, ApiError>;

    /// Update Program
    async fn put_program(
        &self,
        version: f64,
        id: i64,
        body: Option<models::Program>,
        ) -> Result<PutProgramResponse, ApiError>;

    /// Create Purchase
    async fn create_purchase_item(
        &self,
        version: f64,
        app_key: String,
        name: String,
        purchase_type: models::CreatePurchaseItemPurchaseTypeParameter,
        device_id: Option<String>,
        account_id: Option<i64>,
        description: Option<String>,
        tickets: Option<i32>,
        price: Option<f32>,
        purchase_code: Option<String>,
        secret_key: Option<String>,
        purchase_limit: Option<i32>,
        service_action: Option<models::CreatePurchaseItemServiceActionParameter>,
        cover_asset_id: Option<i64>,
        promo_asset_id: Option<i64>,
        giftable: Option<bool>,
        assetable: Option<bool>,
        allocate_tickets: Option<bool>,
        ticket_type: Option<String>,
        points: Option<i64>,
        offer_location_id: Option<i64>,
        ) -> Result<CreatePurchaseItemResponse, ApiError>;

    /// Delete Purchase
    async fn delete_purchase_item(
        &self,
        version: f64,
        purchase_item_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        ) -> Result<DeletePurchaseItemResponse, ApiError>;

    /// Get Purchase
    async fn get_purchase_item(
        &self,
        version: f64,
        purchase_item_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        ) -> Result<GetPurchaseItemResponse, ApiError>;

    /// Search Purchases
    async fn search_purchase_items(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        app_key: Option<String>,
        filter_by_billable: Option<bool>,
        purchase_type: Option<String>,
        service_action: Option<String>,
        keyword: Option<String>,
        sort_field: Option<models::SearchPurchaseItemsSortFieldParameter>,
        descending: Option<bool>,
        start: Option<i32>,
        limit: Option<i32>,
        active_only: Option<bool>,
        ) -> Result<SearchPurchaseItemsResponse, ApiError>;

    /// Update Purchase
    async fn update_purchase_item(
        &self,
        version: f64,
        purchase_item_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        name: Option<String>,
        description: Option<String>,
        tickets: Option<i32>,
        price: Option<f32>,
        purchase_type: Option<models::CreatePurchaseItemPurchaseTypeParameter>,
        purchase_code: Option<String>,
        secret_key: Option<String>,
        purchase_limit: Option<i32>,
        service_action: Option<models::CreatePurchaseItemServiceActionParameter>,
        cover_asset_id: Option<i64>,
        promo_asset_id: Option<i64>,
        giftable: Option<bool>,
        assetable: Option<bool>,
        active: Option<bool>,
        allocate_tickets: Option<bool>,
        ticket_type: Option<String>,
        points: Option<i64>,
        offer_location_id: Option<i64>,
        ) -> Result<UpdatePurchaseItemResponse, ApiError>;

    /// Create Order
    async fn create_order(
        &self,
        version: f64,
        app_key: String,
        cart: String,
        device_id: Option<String>,
        account_id: Option<i64>,
        description: Option<String>,
        currency_type: Option<models::CreateOrderCurrencyTypeParameter>,
        payment_method_id: Option<i64>,
        external_order_id: Option<String>,
        external_payment_id: Option<String>,
        remote_ref_type: Option<String>,
        external_date: Option<i64>,
        promo_code: Option<String>,
        ) -> Result<CreateOrderResponse, ApiError>;

    /// Delete Order
    async fn delete_order(
        &self,
        version: f64,
        order_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        ) -> Result<DeleteOrderResponse, ApiError>;

    /// Get Order
    async fn get_order(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        order_id: Option<i64>,
        external_order_id: Option<String>,
        ) -> Result<GetOrderResponse, ApiError>;

    /// Preview Order
    async fn preview_order(
        &self,
        version: f64,
        app_key: String,
        cart: String,
        device_id: Option<String>,
        account_id: Option<i64>,
        description: Option<String>,
        currency_type: Option<models::CreateOrderCurrencyTypeParameter>,
        payment_method_id: Option<i64>,
        external_order_id: Option<String>,
        external_payment_id: Option<String>,
        remote_ref_type: Option<String>,
        external_date: Option<i64>,
        promo_code: Option<String>,
        ) -> Result<PreviewOrderResponse, ApiError>;

    /// Search Orders
    async fn search_orders(
        &self,
        version: f64,
        app_key: String,
        device_id: Option<String>,
        account_id: Option<i64>,
        start: Option<i32>,
        limit: Option<i32>,
        descending: Option<bool>,
        active_only: Option<bool>,
        ignore_customer_filter: Option<bool>,
        order_item_types: Option<String>,
        order_item_ids: Option<String>,
        order_custom_types: Option<String>,
        order_custom_ids: Option<String>,
        sort_field: Option<String>,
        offer_types: Option<String>,
        special_offer_types: Option<String>,
        category_ids: Option<String>,
        filter_ids: Option<String>,
        offer_audience_ids: Option<String>,
        transaction_audience_ids: Option<String>,
        offer_ids: Option<String>,
        offer_location_ids: Option<String>,
        retailer_ids: Option<String>,
        retailer_location_ids: Option<String>,
        statuses: Option<String>,
        keyword: Option<String>,
        redeemable_start_date: Option<i64>,
        redeemable_end_date: Option<i64>,
        started_since: Option<i64>,
        started_before: Option<i64>,
        ended_since: Option<i64>,
        ended_before: Option<i64>,
        ) -> Result<SearchOrdersResponse, ApiError>;

    /// Update Order
    async fn update_order(
        &self,
        version: f64,
        order_id: i64,
        app_key: String,
        cart: String,
        device_id: Option<String>,
        account_id: Option<i64>,
        payment_transaction_id: Option<i64>,
        description: Option<String>,
        currency_type: Option<models::CreateOrderCurrencyTypeParameter>,
        payment_method_id: Option<i64>,
        external_payment_id: Option<String>,
        external_date: Option<i64>,
        ) -> Result<UpdateOrderResponse, ApiError>;

    /// Create Question
    async fn create_question(
        &self,
        version: f64,
        account_id: i64,
        question: String,
        answers: String,
        active: bool,
        allocate_tickets: bool,
        ticket_count: i64,
        tags: Option<String>,
        video_url: Option<String>,
        asset_id: Option<i64>,
        ticket_type: Option<String>,
        points: Option<i64>,
        ) -> Result<CreateQuestionResponse, ApiError>;

    /// Delete Question
    async fn delete_question(
        &self,
        version: f64,
        question_id: i64,
        account_id: i64,
        ) -> Result<DeleteQuestionResponse, ApiError>;

    /// Get Question
    async fn get_question(
        &self,
        version: f64,
        question_id: i64,
        account_id: i64,
        ) -> Result<GetQuestionResponse, ApiError>;

    /// Search Questions
    async fn search_questions(
        &self,
        version: f64,
        account_id: i64,
        sort_field: String,
        descending: bool,
        active_only: bool,
        start: i32,
        limit: i32,
        keyword: Option<String>,
        ) -> Result<SearchQuestionsResponse, ApiError>;

    /// Update Question
    async fn update_question(
        &self,
        version: f64,
        question_id: i64,
        account_id: i64,
        ticket_count: i64,
        question: Option<String>,
        answers: Option<String>,
        tags: Option<String>,
        video_url: Option<String>,
        asset_id: Option<i64>,
        active: Option<bool>,
        allocate_tickets: Option<bool>,
        ticket_type: Option<String>,
        points: Option<i64>,
        ) -> Result<UpdateQuestionResponse, ApiError>;

    /// Search Historical Rankings
    async fn get_historical_rankings(
        &self,
        version: f64,
        app_key: String,
        rank_type: String,
        start_date: i64,
        end_date: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        sort_field: Option<String>,
        descending: Option<bool>,
        start: Option<i32>,
        limit: Option<i32>,
        ) -> Result<GetHistoricalRankingsResponse, ApiError>;

    /// Search Rankings
    async fn get_rankings(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        game_type: Option<String>,
        app_key: Option<String>,
        q: Option<String>,
        keyword: Option<String>,
        rank_type: Option<String>,
        leaderboard_mode: Option<String>,
        within_account_ids: Option<String>,
        return_user_rank: Option<bool>,
        album_id: Option<i64>,
        audience_id: Option<i64>,
        sort_field: Option<String>,
        descending: Option<bool>,
        _i: Option<i32>,
        start: Option<i32>,
        _l: Option<i32>,
        limit: Option<i32>,
        ) -> Result<GetRankingsResponse, ApiError>;

    /// Get Personal Rankings
    async fn get_user_rank(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        app_key: Option<String>,
        rank_type: Option<String>,
        return_user_rank: Option<bool>,
        leaderboard_mode: Option<String>,
        sort_field: Option<String>,
        keyword: Option<String>,
        descending: Option<bool>,
        start: Option<i32>,
        limit: Option<i32>,
        ) -> Result<GetUserRankResponse, ApiError>;

    /// Override User Rank
    async fn override_user_rank(
        &self,
        version: f64,
        account_id: i64,
        owner_account_id: i64,
        app_key: String,
        rank_type: String,
        total_score: Option<i64>,
        total_count: Option<i64>,
        total_time: Option<i64>,
        daily_score: Option<i64>,
        daily_count: Option<i64>,
        daily_time: Option<i64>,
        weekly_score: Option<i64>,
        weekly_count: Option<i64>,
        weekly_time: Option<i64>,
        monthly_score: Option<i64>,
        monthly_count: Option<i64>,
        monthly_time: Option<i64>,
        top_score: Option<i64>,
        lowest_score: Option<i64>,
        streak_count: Option<i64>,
        streak_best_count: Option<i64>,
        start_date: Option<i64>,
        end_date: Option<i64>,
        ) -> Result<OverrideUserRankResponse, ApiError>;

    /// Update Ranking
    async fn update_rankings(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        rank_type: String,
        increment: Option<i64>,
        time_increment: Option<i64>,
        tag: Option<String>,
        start_date: Option<i64>,
        end_date: Option<i64>,
        update_global: Option<bool>,
        create_leaderboard: Option<bool>,
        ) -> Result<UpdateRankingsResponse, ApiError>;

    /// Create Rating
    async fn create_rating(
        &self,
        version: f64,
        ratable_type: String,
        ratable_id: i64,
        rating_value: i32,
        device_id: Option<String>,
        account_id: Option<i64>,
        category_id: Option<i64>,
        display: Option<String>,
        description: Option<String>,
        location_description: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        ) -> Result<CreateRatingResponse, ApiError>;

    /// Delete Rating
    async fn delete_rating(
        &self,
        version: f64,
        rating_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        ) -> Result<DeleteRatingResponse, ApiError>;

    /// Search Location Rating Indexes
    async fn search_location_rating_indexes(
        &self,
        version: f64,
        category_ids: Option<String>,
        keyword: Option<String>,
        location_type: Option<String>,
        sort_field: Option<models::SearchRatingIndexesSortFieldParameter>,
        descending: Option<bool>,
        start: Option<i32>,
        limit: Option<i32>,
        search_range: Option<f64>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        return_overall_rating: Option<bool>,
        distance_unit: Option<models::SearchOffersForConsumerDistanceUnitParameter>,
        return_retailer: Option<bool>,
        return_assets: Option<bool>,
        return_offers: Option<bool>,
        return_categories: Option<bool>,
        return_filters: Option<bool>,
        ) -> Result<SearchLocationRatingIndexesResponse, ApiError>;

    /// Search Rating Indexes
    async fn search_rating_indexes(
        &self,
        version: f64,
        ratable_type: models::SearchRatingIndexesRatableTypeParameter,
        ratable_ids: Option<String>,
        category_ids: Option<String>,
        secondary_type: Option<String>,
        keyword: Option<String>,
        sort_field: Option<models::SearchRatingIndexesSortFieldParameter>,
        descending: Option<bool>,
        start: Option<i32>,
        limit: Option<i32>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        return_ratable: Option<bool>,
        return_overall_rating: Option<bool>,
        ) -> Result<SearchRatingIndexesResponse, ApiError>;

    /// Search Ratings
    async fn search_ratings(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        filter_account_id: Option<i64>,
        ratable_type: Option<String>,
        ratable_id: Option<i64>,
        category_ids: Option<String>,
        keyword: Option<String>,
        sort_field: Option<models::SearchRatingsSortFieldParameter>,
        descending: Option<bool>,
        start: Option<i32>,
        limit: Option<i32>,
        ) -> Result<SearchRatingsResponse, ApiError>;

    /// Update Rating
    async fn update_rating(
        &self,
        version: f64,
        rating_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        rating_value: Option<i32>,
        category_id: Option<i64>,
        display: Option<String>,
        description: Option<String>,
        location_description: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        ) -> Result<UpdateRatingResponse, ApiError>;

    /// Create Region
    async fn create_region(
        &self,
        version: f64,
        account_id: i64,
        region_class: String,
        short_name: String,
        full_name: Option<String>,
        parent_ids: Option<String>,
        children_ids: Option<String>,
        postal_code_ids: Option<String>,
        locations: Option<String>,
        retailer_location_id: Option<i64>,
        visibility: Option<models::AddAlbumCollectionVisibilityParameter>,
        category_ids: Option<String>,
        filter_ids: Option<String>,
        start: Option<i64>,
        end: Option<i64>,
        polygon: Option<String>,
        meta_data: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        version_code: Option<i32>,
        root: Option<bool>,
        active: Option<bool>,
        ) -> Result<CreateRegionResponse, ApiError>;

    /// Delete Region
    async fn delete_region(
        &self,
        version: f64,
        account_id: i64,
        region_id: i64,
        ) -> Result<DeleteRegionResponse, ApiError>;

    /// Get Region
    async fn get_region(
        &self,
        version: f64,
        region_id: i64,
        account_id: Option<i64>,
        ) -> Result<GetRegionResponse, ApiError>;

    /// Search Regions
    async fn search_regions(
        &self,
        version: f64,
        account_id: Option<i64>,
        query: Option<String>,
        keyword: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        range: Option<f64>,
        region_class: Option<models::SearchRegionsRegionClassParameter>,
        visibility: Option<models::AddAlbumCollectionVisibilityParameter>,
        search_mode: Option<models::SearchRegionsSearchModeParameter>,
        sort_field: Option<models::SearchRegionsSortFieldParameter>,
        descending: Option<bool>,
        include_parent: Option<bool>,
        include_children: Option<bool>,
        include_postal_codes: Option<bool>,
        category_ids: Option<String>,
        filter_ids: Option<String>,
        version_code: Option<i32>,
        active_only: Option<bool>,
        show_deleted: Option<bool>,
        last_updated_since: Option<i64>,
        start: Option<i32>,
        limit: Option<i32>,
        ) -> Result<SearchRegionsResponse, ApiError>;

    /// Update Region
    async fn update_region(
        &self,
        version: f64,
        account_id: i64,
        region_id: i64,
        region_class: Option<String>,
        short_name: Option<String>,
        full_name: Option<String>,
        parent_ids: Option<String>,
        children_ids: Option<String>,
        postal_code_ids: Option<String>,
        locations: Option<String>,
        retailer_location_id: Option<i64>,
        visibility: Option<models::AddAlbumCollectionVisibilityParameter>,
        category_ids: Option<String>,
        filter_ids: Option<String>,
        start: Option<i64>,
        end: Option<i64>,
        polygon: Option<String>,
        meta_data: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        version_code: Option<i32>,
        root: Option<bool>,
        active: Option<bool>,
        clear_lists: Option<bool>,
        ) -> Result<UpdateRegionResponse, ApiError>;

    /// Create Offline Report
    async fn create_batch(
        &self,
        version: f64,
        account_id: i64,
        status: models::CreateBatchStatusParameter,
        preview_limit: i32,
        app_key: Option<String>,
        endpoint: Option<String>,
        parameters: Option<String>,
        name: Option<String>,
        start_date: Option<i64>,
        end_date: Option<i64>,
        description: Option<String>,
        page_url: Option<String>,
        ) -> Result<CreateBatchResponse, ApiError>;

    /// Create Offline Report
    async fn create_region_leg_summary_batch<'a>(
        &self,
        version: f64,
        body: Option<&'a Vec<models::RegionLegSummary>>,
        ) -> Result<CreateRegionLegSummaryBatchResponse, ApiError>;

    /// Delete Offline Report
    async fn delete_batch(
        &self,
        version: f64,
        account_id: i64,
        batch_id: i64,
        ) -> Result<DeleteBatchResponse, ApiError>;

    /// Get Offline Report
    async fn get_report_batch(
        &self,
        version: f64,
        account_id: i64,
        batch_id: i64,
        all_results: bool,
        ) -> Result<GetReportBatchResponse, ApiError>;

    /// Run Report
    async fn run_report(
        &self,
        version: f64,
        desc: bool,
        account_id: Option<i64>,
        query: Option<String>,
        parameters: Option<String>,
        order: Option<String>,
        start: Option<i64>,
        limit: Option<i64>,
        response_format: Option<models::AggregatedFilteredUsageResponseFormatParameter>,
        ) -> Result<RunReportResponse, ApiError>;

    /// Search Offline Reports
    async fn search_batch(
        &self,
        version: f64,
        account_id: i64,
        start: i32,
        limit: i32,
        names: Option<String>,
        app_key: Option<String>,
        status: Option<models::CreateBatchStatusParameter>,
        global_app_search: Option<bool>,
        start_date: Option<i64>,
        end_date: Option<i64>,
        ) -> Result<SearchBatchResponse, ApiError>;

    /// Create Reservation
    async fn create_reservation(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        start_date: Option<i64>,
        end_date: Option<i64>,
        offer_id: Option<i64>,
        offer_location_id: Option<i64>,
        app_key: Option<String>,
        meta_data: Option<String>,
        ) -> Result<CreateReservationResponse, ApiError>;

    /// Delete Reservation
    async fn delete_reservation(
        &self,
        version: f64,
        reservation_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        ) -> Result<DeleteReservationResponse, ApiError>;

    /// Update Availability
    async fn reservable_availability(
        &self,
        version: f64,
        reservable_id: i64,
        reservable_type: models::SearchRatingIndexesRatableTypeParameter,
        device_id: Option<String>,
        account_id: Option<i64>,
        availability: Option<String>,
        availability_summary: Option<String>,
        ) -> Result<ReservableAvailabilityResponse, ApiError>;

    /// Search Availability
    async fn search_availability(
        &self,
        version: f64,
        reservable_id: i64,
        reservable_type: models::SearchRatingIndexesRatableTypeParameter,
        device_id: Option<String>,
        account_id: Option<i64>,
        start_date: Option<i64>,
        end_date: Option<i64>,
        start: Option<i32>,
        limit: Option<i32>,
        ) -> Result<SearchAvailabilityResponse, ApiError>;

    /// Search Reservations
    async fn search_reservations(
        &self,
        version: f64,
        device_id: Option<String>,
        app_key: Option<String>,
        account_id: Option<i64>,
        filter_account_id: Option<i64>,
        reservable_id: Option<i64>,
        reservable_type: Option<models::SearchRatingIndexesRatableTypeParameter>,
        keyword: Option<String>,
        start_date: Option<i64>,
        end_date: Option<i64>,
        start: Option<i32>,
        limit: Option<i32>,
        ) -> Result<SearchReservationsResponse, ApiError>;

    /// Search Schedule
    async fn search_schedule(
        &self,
        version: f64,
        reservable_id: i64,
        reservable_type: models::SearchRatingIndexesRatableTypeParameter,
        start_date: i64,
        end_date: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        time_bucket_mins: Option<i32>,
        ) -> Result<SearchScheduleResponse, ApiError>;

    /// Create Retailer
    async fn create_retailer(
        &self,
        version: f64,
        name: String,
        device_id: Option<String>,
        account_id: Option<i64>,
        street_address: Option<String>,
        street_address2: Option<String>,
        city: Option<String>,
        state: Option<String>,
        postal_code: Option<String>,
        country: Option<String>,
        business_phone: Option<String>,
        business_phone_ext: Option<String>,
        website: Option<String>,
        email: Option<String>,
        facebook_url: Option<String>,
        twitter_url: Option<String>,
        logo: Option<swagger::ByteArray>,
        logo_asset_id: Option<i64>,
        picture1: Option<swagger::ByteArray>,
        picture1_asset_id: Option<i64>,
        picture2: Option<swagger::ByteArray>,
        picture2_asset_id: Option<i64>,
        category_ids: Option<String>,
        category_ids_to_add: Option<String>,
        category_ids_to_remove: Option<String>,
        filter_ids: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        meta_data: Option<String>,
        search_tags: Option<String>,
        retailer_type: Option<String>,
        visibility: Option<models::AddAlbumCollectionVisibilityParameter>,
        create_default_location: Option<bool>,
        response_format: Option<models::AggregatedFilteredUsageResponseFormatParameter>,
        ) -> Result<CreateRetailerResponse, ApiError>;

    /// Delete Retailer
    async fn delete_retailer(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        retailer_id: Option<i64>,
        ) -> Result<DeleteRetailerResponse, ApiError>;

    /// Get Retailer
    async fn get_retailer(
        &self,
        version: f64,
        retailer_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        include_counts: Option<bool>,
        ) -> Result<GetRetailerResponse, ApiError>;

    /// Search Retailers
    async fn get_retailers(
        &self,
        version: f64,
        visibility: models::AddAlbumCollectionVisibilityParameter,
        sort_field: models::GetRetailersSortFieldParameter,
        descending: bool,
        start: i32,
        limit: i32,
        active_only: bool,
        device_id: Option<String>,
        account_id: Option<i64>,
        q: Option<String>,
        keyword: Option<String>,
        category_ids: Option<String>,
        filter_ids: Option<String>,
        _i: Option<i32>,
        _l: Option<i32>,
        ) -> Result<GetRetailersResponse, ApiError>;

    /// Login Retailer
    async fn retailer_login_check(
        &self,
        version: f64,
        username: String,
        password: String,
        device_id: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        app_key: Option<String>,
        ) -> Result<RetailerLoginCheckResponse, ApiError>;

    /// Update Retailer
    async fn update_retailer(
        &self,
        version: f64,
        retailer_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        name: Option<String>,
        street_address: Option<String>,
        street_address2: Option<String>,
        city: Option<String>,
        state: Option<String>,
        postal_code: Option<String>,
        country: Option<String>,
        business_phone: Option<String>,
        business_phone_ext: Option<String>,
        website: Option<String>,
        email: Option<String>,
        facebook_url: Option<String>,
        twitter_url: Option<String>,
        logo: Option<swagger::ByteArray>,
        logo_asset_id: Option<i64>,
        picture1: Option<swagger::ByteArray>,
        picture1_asset_id: Option<i64>,
        picture2: Option<swagger::ByteArray>,
        picture2_asset_id: Option<i64>,
        category_ids: Option<String>,
        filter_ids: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        meta_data: Option<String>,
        search_tags: Option<String>,
        retailer_type: Option<String>,
        visibility: Option<models::AddAlbumCollectionVisibilityParameter>,
        active: Option<bool>,
        response_format: Option<models::AggregatedFilteredUsageResponseFormatParameter>,
        ) -> Result<UpdateRetailerResponse, ApiError>;

    /// Create Retailer Location (Consumer)
    async fn create_retailer_location_consumer(
        &self,
        version: f64,
        app_key: String,
        name: String,
        device_id: Option<String>,
        account_id: Option<i64>,
        street_address: Option<String>,
        street_address2: Option<String>,
        city: Option<String>,
        state: Option<String>,
        postal_code: Option<String>,
        country: Option<String>,
        business_phone: Option<String>,
        business_phone_ext: Option<String>,
        website: Option<String>,
        email: Option<String>,
        details_header: Option<String>,
        details_body: Option<String>,
        hours: Option<String>,
        tags: Option<String>,
        logo_asset_id: Option<i64>,
        picture1_asset_id: Option<i64>,
        picture2_asset_id: Option<i64>,
        category_ids: Option<String>,
        filter_ids: Option<String>,
        meta_data: Option<String>,
        public_location: Option<bool>,
        active: Option<bool>,
        location_type: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        ) -> Result<CreateRetailerLocationConsumerResponse, ApiError>;

    /// Create Retailer Location
    async fn create_retailer_locations(
        &self,
        version: f64,
        retailer_id: i64,
        name: String,
        street_address: String,
        city: String,
        state: String,
        postal_code: String,
        device_id: Option<String>,
        account_id: Option<i64>,
        street_address2: Option<String>,
        country: Option<String>,
        business_phone: Option<String>,
        business_phone_ext: Option<String>,
        website: Option<String>,
        email: Option<String>,
        internal_id: Option<String>,
        details_header: Option<String>,
        details_body: Option<String>,
        hours: Option<String>,
        logo: Option<swagger::ByteArray>,
        logo_asset_id: Option<i64>,
        picture1: Option<swagger::ByteArray>,
        picture1_asset_id: Option<i64>,
        picture2: Option<swagger::ByteArray>,
        picture2_asset_id: Option<i64>,
        category_ids: Option<String>,
        filter_ids: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        building: Option<String>,
        google_place_id: Option<String>,
        yelp_id: Option<String>,
        active: Option<bool>,
        public_location: Option<bool>,
        location_type: Option<String>,
        audience_ids: Option<String>,
        audience_ids_to_add: Option<String>,
        audience_ids_to_remove: Option<String>,
        response_format: Option<models::AggregatedFilteredUsageResponseFormatParameter>,
        response_includes: Option<String>,
        ) -> Result<CreateRetailerLocationsResponse, ApiError>;

    /// Delete Retailer Location
    async fn delete_retailer_location(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        retailer_location_id: Option<i64>,
        ) -> Result<DeleteRetailerLocationResponse, ApiError>;

    /// Get Retailer Location
    async fn get_retailer_location(
        &self,
        version: f64,
        retailer_location_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        retailer_location_token: Option<String>,
        ) -> Result<GetRetailerLocationResponse, ApiError>;

    /// Get Retailer Location (Consumer)
    async fn get_retailer_location_consumer(
        &self,
        version: f64,
        retailer_location_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        ) -> Result<GetRetailerLocationConsumerResponse, ApiError>;

    /// Distance Search Retailer Locations (Indexed)
    async fn indexed_retailer_location_distance_search(
        &self,
        version: f64,
        latitude: f64,
        longitude: f64,
        search_range: f64,
        start: i32,
        limit: i32,
        account_id: Option<i64>,
        address: Option<String>,
        has_offers: Option<bool>,
        categories: Option<String>,
        filters: Option<String>,
        audiences: Option<String>,
        retailer_ids: Option<String>,
        retailer_location_ids: Option<String>,
        tags: Option<String>,
        location_type: Option<String>,
        sort_field: Option<String>,
        descending: Option<bool>,
        q: Option<String>,
        keyword: Option<String>,
        keyword_operator: Option<String>,
        search_expression: Option<String>,
        distance_unit: Option<models::SearchOffersForConsumerDistanceUnitParameter>,
        return_favorited: Option<bool>,
        return_retailer: Option<bool>,
        return_assets: Option<bool>,
        return_offers: Option<bool>,
        return_categories: Option<bool>,
        return_filters: Option<bool>,
        return_audiences: Option<bool>,
        return_qr_code: Option<bool>,
        return_external_category_data: Option<bool>,
        include_favorite: Option<bool>,
        include_liked: Option<bool>,
        include_rating: Option<bool>,
        ) -> Result<IndexedRetailerLocationDistanceSearchResponse, ApiError>;

    /// Keyword Search Retailer Locations (Indexed)
    async fn indexed_retailer_location_search(
        &self,
        version: f64,
        account_id: Option<i64>,
        start: Option<i32>,
        limit: Option<i32>,
        has_offers: Option<bool>,
        categories: Option<String>,
        filters: Option<String>,
        audiences: Option<String>,
        retailer_ids: Option<String>,
        retailer_location_ids: Option<String>,
        tags: Option<String>,
        location_type: Option<String>,
        sort_field: Option<String>,
        descending: Option<bool>,
        q: Option<String>,
        keyword: Option<String>,
        keyword_operator: Option<String>,
        search_expression: Option<String>,
        return_retailer: Option<bool>,
        return_assets: Option<bool>,
        return_offers: Option<bool>,
        return_categories: Option<bool>,
        return_filters: Option<bool>,
        return_audiences: Option<bool>,
        return_qr_code: Option<bool>,
        return_external_category_data: Option<bool>,
        include_favorite: Option<bool>,
        include_liked: Option<bool>,
        include_rating: Option<bool>,
        ) -> Result<IndexedRetailerLocationSearchResponse, ApiError>;

    /// Search Retailer Locations (Owned)
    async fn search_retailer_locations(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        q: Option<String>,
        keyword: Option<String>,
        retailer_ids: Option<String>,
        retailer_location_ids: Option<String>,
        location_type: Option<String>,
        sort_field: Option<models::SearchRetailerLocationsSortFieldParameter>,
        descending: Option<bool>,
        _i: Option<i32>,
        start: Option<i32>,
        _l: Option<i32>,
        limit: Option<i32>,
        show_public_locations: Option<bool>,
        active_only: Option<bool>,
        return_retailer: Option<bool>,
        return_assets: Option<bool>,
        return_offers: Option<bool>,
        return_categories: Option<bool>,
        return_filters: Option<bool>,
        return_audiences: Option<bool>,
        return_qr_code: Option<bool>,
        include_favorite: Option<bool>,
        include_liked: Option<bool>,
        include_rating: Option<bool>,
        ) -> Result<SearchRetailerLocationsResponse, ApiError>;

    /// Update Retailer Location
    async fn update_retailer_locations(
        &self,
        version: f64,
        retailer_location_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        name: Option<String>,
        street_address: Option<String>,
        street_address2: Option<String>,
        city: Option<String>,
        state: Option<String>,
        postal_code: Option<String>,
        country: Option<String>,
        business_phone: Option<String>,
        business_phone_ext: Option<String>,
        website: Option<String>,
        email: Option<String>,
        internal_id: Option<String>,
        details_header: Option<String>,
        details_body: Option<String>,
        hours: Option<String>,
        logo: Option<swagger::ByteArray>,
        logo_asset_id: Option<i64>,
        picture1: Option<swagger::ByteArray>,
        picture1_asset_id: Option<i64>,
        picture2: Option<swagger::ByteArray>,
        picture2_asset_id: Option<i64>,
        category_ids: Option<String>,
        filter_ids: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        building: Option<String>,
        google_place_id: Option<String>,
        yelp_id: Option<String>,
        meta_data: Option<String>,
        payment_provider: Option<String>,
        active: Option<bool>,
        public_location: Option<bool>,
        location_type: Option<String>,
        audience_ids: Option<String>,
        audience_ids_to_add: Option<String>,
        audience_ids_to_remove: Option<String>,
        response_format: Option<models::AggregatedFilteredUsageResponseFormatParameter>,
        tags: Option<String>,
        ) -> Result<UpdateRetailerLocationsResponse, ApiError>;

    /// Get Retailer
    async fn get_retaokiler(
        &self,
        version: f64,
        retailer_id: i64,
        active_only: bool,
        keyword: Option<String>,
        sort_field: Option<String>,
        start: Option<i64>,
        limit: Option<i64>,
        ) -> Result<GetRetaokilerResponse, ApiError>;

    /// Create Route
    async fn create_route(
        &self,
        version: f64,
        body: Option<models::Route>,
        ) -> Result<CreateRouteResponse, ApiError>;

    /// Search Routes
    async fn search_routes(
        &self,
        version: f64,
        sort_field: String,
        descending: bool,
        start: i32,
        limit: i32,
        active_only: bool,
        includes_empty: bool,
        root_only: bool,
        show_inherited_properties: bool,
        hub_id: Option<i64>,
        program_id: Option<i64>,
        scheduled_start: Option<i64>,
        scheduled_end: Option<i64>,
        updated_start: Option<i64>,
        updated_end: Option<i64>,
        featured: Option<bool>,
        seat_count: Option<i32>,
        approved: Option<bool>,
        started: Option<bool>,
        completed: Option<bool>,
        valid: Option<bool>,
        parent_id: Option<i64>,
        ) -> Result<SearchRoutesResponse, ApiError>;

    /// Approve Route
    async fn approve_route(
        &self,
        version: f64,
        route_id: i64,
        ) -> Result<ApproveRouteResponse, ApiError>;

    /// Copy Route
    async fn copy_route(
        &self,
        version: f64,
        route_id: i64,
        body: Option<models::Route>,
        ) -> Result<CopyRouteResponse, ApiError>;

    /// Update Route Directions
    async fn create_route_directions(
        &self,
        version: f64,
        route_id: i64,
        ) -> Result<CreateRouteDirectionsResponse, ApiError>;

    /// Create Route Polyline
    async fn create_route_polyline(
        &self,
        version: f64,
        route_id: i64,
        ) -> Result<CreateRoutePolylineResponse, ApiError>;

    /// Delete Route
    async fn delete_route(
        &self,
        version: f64,
        route_id: i64,
        ) -> Result<DeleteRouteResponse, ApiError>;

    /// Disapprove Route
    async fn disapprove_route(
        &self,
        version: f64,
        route_id: i64,
        ) -> Result<DisapproveRouteResponse, ApiError>;

    /// Get Route
    async fn get_route(
        &self,
        version: f64,
        route_id: i64,
        show_inherited_properties: bool,
        ) -> Result<GetRouteResponse, ApiError>;

    /// Get Route Directions
    async fn get_route_directions(
        &self,
        version: f64,
        route_id: i64,
        ) -> Result<GetRouteDirectionsResponse, ApiError>;

    /// Get Route Shipments
    async fn get_route_shipments(
        &self,
        version: f64,
        route_id: i64,
        ) -> Result<GetRouteShipmentsResponse, ApiError>;

    /// Get Route Stops
    async fn get_route_stops(
        &self,
        version: f64,
        route_id: i64,
        confirmed_only: bool,
        ) -> Result<GetRouteStopsResponse, ApiError>;

    /// Optimize Route
    async fn optimize_route(
        &self,
        version: f64,
        route_id: i64,
        ) -> Result<OptimizeRouteResponse, ApiError>;

    /// Reorder Route Stops
    async fn reorder_route_stops_patch<'a>(
        &self,
        version: f64,
        route_id: i64,
        body: Option<&'a Vec<models::Stop>>,
        ) -> Result<ReorderRouteStopsPatchResponse, ApiError>;

    /// Reorder Route Stops
    async fn reorder_route_stops_post<'a>(
        &self,
        version: f64,
        route_id: i64,
        body: Option<&'a Vec<models::Stop>>,
        ) -> Result<ReorderRouteStopsPostResponse, ApiError>;

    /// Update Route
    async fn update_route(
        &self,
        version: f64,
        route_id: i64,
        body: Option<models::Route>,
        ) -> Result<UpdateRouteResponse, ApiError>;

    /// Get Route Stop
    async fn get_route_stop(
        &self,
        version: f64,
        route_id: i64,
        stop_id: i64,
        ) -> Result<GetRouteStopResponse, ApiError>;

    /// Get Shipments At Stop
    async fn get_shipments_at_stop(
        &self,
        version: f64,
        route_id: i64,
        stop_id: i64,
        ) -> Result<GetShipmentsAtStopResponse, ApiError>;

    /// Delete Stop
    async fn remove_stop(
        &self,
        version: f64,
        route_id: i64,
        stop_id: i64,
        ) -> Result<RemoveStopResponse, ApiError>;

    /// Set Driver
    async fn set_driver(
        &self,
        version: f64,
        id: i64,
        driver_id: i64,
        ) -> Result<SetDriverResponse, ApiError>;

    /// Update Route Stop
    async fn update_route_stop(
        &self,
        version: f64,
        route_id: i64,
        stop_id: i64,
        body: Option<models::Stop>,
        ) -> Result<UpdateRouteStopResponse, ApiError>;

    /// Create Route Setting
    async fn create_route_settings(
        &self,
        version: f64,
        body: Option<models::RouteSettings>,
        ) -> Result<CreateRouteSettingsResponse, ApiError>;

    /// Search Route Settings
    async fn search_route_settings(
        &self,
        version: f64,
        sort_field: String,
        descending: bool,
        start: i32,
        limit: i32,
        active_only: bool,
        hub_id: Option<i64>,
        program_id: Option<i64>,
        keyword: Option<String>,
        ) -> Result<SearchRouteSettingsResponse, ApiError>;

    /// Delete Route Setting
    async fn delete_route_settings(
        &self,
        version: f64,
        route_settings_id: i64,
        ) -> Result<DeleteRouteSettingsResponse, ApiError>;

    /// Get Route Setting
    async fn get_route_settings(
        &self,
        version: f64,
        route_settings_id: i64,
        ) -> Result<GetRouteSettingsResponse, ApiError>;

    /// Update Route Setting
    async fn update_route_settings(
        &self,
        version: f64,
        route_settings_id: i64,
        body: Option<models::RouteSettings>,
        ) -> Result<UpdateRouteSettingsResponse, ApiError>;

    /// Compute Route
    async fn compute_routing(
        &self,
        version: f64,
        data: String,
        ) -> Result<ComputeRoutingResponse, ApiError>;

    /// Create Scheduled Notification
    async fn create_scheduled_notification(
        &self,
        version: f64,
        account_id: i64,
        name: String,
        param_type: String,
        message: String,
        content_id: Option<i64>,
        content_name: Option<String>,
        content_type: Option<String>,
        parent_id: Option<i64>,
        parent_type: Option<String>,
        app_key: Option<String>,
        grouping_id: Option<String>,
        connection_group_ids: Option<String>,
        connection_account_ids: Option<String>,
        audience_id: Option<i64>,
        audience_ids: Option<String>,
        album_ids: Option<String>,
        report_id: Option<i64>,
        report_params: Option<String>,
        endpoint_url: Option<String>,
        payload: Option<String>,
        scheduled_date: Option<i64>,
        start_date: Option<i64>,
        end_date: Option<i64>,
        cron_expression: Option<String>,
        cron_type: Option<String>,
        meta_data: Option<String>,
        conditional_input: Option<String>,
        template_type: Option<String>,
        visibility: Option<models::AddAlbumCollectionVisibilityParameter>,
        active: Option<bool>,
        send_now: Option<bool>,
        event_type: Option<String>,
        deep_link_uri: Option<String>,
        send_to_all: Option<bool>,
        ) -> Result<CreateScheduledNotificationResponse, ApiError>;

    /// Delete Scheduled Notification
    async fn delete_scheduled_notification(
        &self,
        version: f64,
        account_id: i64,
        scheduled_notification_id: i64,
        delete_by_grouping_id: Option<bool>,
        ) -> Result<DeleteScheduledNotificationResponse, ApiError>;

    /// Get Scheduled Notification
    async fn get_scheduled_notification(
        &self,
        version: f64,
        account_id: i64,
        scheduled_notification_id: i64,
        ) -> Result<GetScheduledNotificationResponse, ApiError>;

    /// Generate Schedule Notifications
    async fn schedule_notification_listings(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        report_name: String,
        message: String,
        offset: i32,
        recipient_report_id: i64,
        report_params: Option<String>,
        param_type: Option<String>,
        ) -> Result<ScheduleNotificationListingsResponse, ApiError>;

    /// Search Scheduled Notifications
    async fn search_scheduled_notifications(
        &self,
        version: f64,
        account_id: i64,
        grouping_id: Option<String>,
        audience_id: Option<i64>,
        filter: Option<String>,
        types: Option<String>,
        content_ids: Option<String>,
        content_types: Option<String>,
        parent_ids: Option<String>,
        parent_types: Option<String>,
        statuses: Option<String>,
        template_types: Option<String>,
        app_key: Option<String>,
        keyword: Option<String>,
        sort_field: Option<String>,
        descending: Option<bool>,
        start: Option<i32>,
        limit: Option<i32>,
        active_only: Option<bool>,
        group_by_grouping_id: Option<bool>,
        return_audience_account_count: Option<bool>,
        ) -> Result<SearchScheduledNotificationsResponse, ApiError>;

    /// Update Scheduled Notification
    async fn update_scheduled_notification(
        &self,
        version: f64,
        scheduled_notification_id: i64,
        account_id: i64,
        name: Option<String>,
        param_type: Option<String>,
        message: Option<String>,
        payload: Option<String>,
        content_id: Option<i64>,
        content_name: Option<String>,
        content_type: Option<String>,
        parent_id: Option<i64>,
        parent_type: Option<String>,
        app_key: Option<String>,
        grouping_id: Option<String>,
        connection_group_ids: Option<String>,
        connection_account_ids: Option<String>,
        audience_id: Option<i64>,
        audience_ids: Option<String>,
        album_ids: Option<String>,
        report_id: Option<i64>,
        report_params: Option<String>,
        endpoint_url: Option<String>,
        scheduled_date: Option<i64>,
        start_date: Option<i64>,
        end_date: Option<i64>,
        cron_expression: Option<String>,
        cron_type: Option<String>,
        meta_data: Option<String>,
        conditional_input: Option<String>,
        template_type: Option<String>,
        visibility: Option<models::AddAlbumCollectionVisibilityParameter>,
        active: Option<bool>,
        error_message: Option<String>,
        status: Option<String>,
        update_by_grouping_id: Option<bool>,
        send_now: Option<bool>,
        event_type: Option<String>,
        deep_link_uri: Option<String>,
        send_to_all: Option<bool>,
        ) -> Result<UpdateScheduledNotificationResponse, ApiError>;

    /// Create Score
    async fn create_score(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        points: i32,
        mission_id: Option<i64>,
        game_id: Option<i64>,
        pack_id: Option<i64>,
        game_level_id: Option<i64>,
        game_object_id: Option<i64>,
        time_taken: Option<i32>,
        highest: Option<bool>,
        ) -> Result<CreateScoreResponse, ApiError>;

    /// Get Score
    async fn get_score(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        mission_id: Option<i64>,
        game_id: Option<i64>,
        pack_id: Option<i64>,
        game_level_id: Option<i64>,
        game_object_id: Option<i64>,
        score_object_type: Option<String>,
        score_status: Option<String>,
        ) -> Result<GetScoreResponse, ApiError>;

    /// Search Score
    async fn search_scores(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        mission_id: Option<i64>,
        game_id: Option<i64>,
        pack_id: Option<i64>,
        game_level_id: Option<i64>,
        game_object_id: Option<i64>,
        ) -> Result<SearchScoresResponse, ApiError>;

    /// Create Secure Application
    async fn create_secure_application(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        key_cert: swagger::ByteArray,
        trust_store: swagger::ByteArray,
        username: String,
        password: String,
        active: Option<bool>,
        biometric_type: Option<models::CreateSecureApplicationBiometricTypeParameter>,
        biometric_position: Option<models::CreateSecureApplicationBiometricPositionParameter>,
        biometric_position2: Option<models::CreateSecureApplicationBiometricPositionParameter>,
        ) -> Result<CreateSecureApplicationResponse, ApiError>;

    /// Delete Secure Application
    async fn delete_secure_application(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        ) -> Result<DeleteSecureApplicationResponse, ApiError>;

    /// Login Clear
    async fn login_secure(
        &self,
        version: f64,
        app_key: String,
        biometric_file: swagger::ByteArray,
        device_id: Option<String>,
        biometric_file2: Option<swagger::ByteArray>,
        age_restriction: Option<i32>,
        return_profile: Option<bool>,
        response_filters: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        ) -> Result<LoginSecureResponse, ApiError>;

    /// Purchase Clear
    async fn purchase_secure(
        &self,
        version: f64,
        body: models::PaymentRequest,
        ) -> Result<PurchaseSecureResponse, ApiError>;

    /// Rest Secure Application
    async fn reset_secure(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        ) -> Result<ResetSecureResponse, ApiError>;

    /// Update Secure Application
    async fn update_secure_application(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        active: Option<bool>,
        key_cert: Option<swagger::ByteArray>,
        trust_store: Option<swagger::ByteArray>,
        username: Option<String>,
        password: Option<String>,
        biometric_type: Option<models::UpdateSecureApplicationBiometricTypeParameter>,
        biometric_position: Option<models::UpdateSecureApplicationBiometricPositionParameter>,
        biometric_position2: Option<models::UpdateSecureApplicationBiometricPositionParameter>,
        ) -> Result<UpdateSecureApplicationResponse, ApiError>;

    /// Create Service Hub
    async fn create_service_hub(
        &self,
        version: f64,
        body: Option<models::ServiceHub>,
        ) -> Result<CreateServiceHubResponse, ApiError>;

    /// Search Service Hubs
    async fn search_service_hubs(
        &self,
        version: f64,
        sort_field: String,
        descending: bool,
        start: i32,
        limit: i32,
        active_only: bool,
        keyword: Option<String>,
        retailer_id: Option<i64>,
        ) -> Result<SearchServiceHubsResponse, ApiError>;

    /// Delete Service Hub
    async fn delete_service_hub(
        &self,
        version: f64,
        id: i64,
        ) -> Result<DeleteServiceHubResponse, ApiError>;

    /// Get Service Hub
    async fn get_service_hub(
        &self,
        version: f64,
        id: i64,
        ) -> Result<GetServiceHubResponse, ApiError>;

    /// Update Service Hub
    async fn post_service_hub(
        &self,
        version: f64,
        id: i64,
        body: Option<models::ServiceHub>,
        ) -> Result<PostServiceHubResponse, ApiError>;

    /// Update Service Hub
    async fn put_service_hub(
        &self,
        version: f64,
        id: i64,
        body: Option<models::ServiceHub>,
        ) -> Result<PutServiceHubResponse, ApiError>;

    /// Create Shipment
    async fn create_shipment(
        &self,
        version: f64,
        body: Option<models::Shipment>,
        ) -> Result<CreateShipmentResponse, ApiError>;

    /// Search Shipments
    async fn search_shipments(
        &self,
        version: f64,
        sort_field: String,
        descending: bool,
        start: i32,
        limit: i32,
        active_only: bool,
        owner_id: Option<i64>,
        rider_id: Option<i64>,
        route_id: Option<i64>,
        ) -> Result<SearchShipmentsResponse, ApiError>;

    /// Cancel Shipment
    async fn cancel_shipment(
        &self,
        version: f64,
        id: i64,
        ) -> Result<CancelShipmentResponse, ApiError>;

    /// Delete Shipment
    async fn delete_shipment(
        &self,
        version: f64,
        id: i64,
        ) -> Result<DeleteShipmentResponse, ApiError>;

    /// Get Shipment
    async fn get_shipment(
        &self,
        version: f64,
        id: i64,
        ) -> Result<GetShipmentResponse, ApiError>;

    /// Update Shipment
    async fn update_shipment(
        &self,
        version: f64,
        id: i64,
        body: Option<models::Shipment>,
        ) -> Result<UpdateShipmentResponse, ApiError>;

    /// Uupdate Shipment Status
    async fn update_shipment_status(
        &self,
        version: f64,
        id: i64,
        body: Option<std::collections::HashMap<String, bool>>,
        ) -> Result<UpdateShipmentStatusResponse, ApiError>;

    /// Create Shipment Batch
    async fn create_shipment_batch(
        &self,
        version: f64,
        body: Option<models::ShipmentBatch>,
        ) -> Result<CreateShipmentBatchResponse, ApiError>;

    /// Search Shipment Batch
    async fn search_shipment_batch(
        &self,
        version: f64,
        hub_id: i64,
        sort_field: String,
        descending: bool,
        start: i32,
        limit: i32,
        ) -> Result<SearchShipmentBatchResponse, ApiError>;

    /// Delete Shipment Batch
    async fn delete_shipment_batch(
        &self,
        version: f64,
        batch_id: i64,
        ) -> Result<DeleteShipmentBatchResponse, ApiError>;

    /// Get Shipment Batch
    async fn get_shipment_batch(
        &self,
        version: f64,
        batch_id: i64,
        ) -> Result<GetShipmentBatchResponse, ApiError>;

    /// Get Shipment Batch Status
    async fn get_shipment_batch_status(
        &self,
        version: f64,
        batch_id: i64,
        account_id: i64,
        sort_field: String,
        descending: bool,
        start: i32,
        limit: i32,
        valid: Option<bool>,
        started: Option<bool>,
        completed: Option<bool>,
        has_shipment: Option<bool>,
        has_route: Option<bool>,
        keyword: Option<String>,
        ) -> Result<GetShipmentBatchStatusResponse, ApiError>;

    /// Routing Simulation
    async fn simulation(
        &self,
        version: f64,
        data: String,
        real_time: bool,
        ) -> Result<SimulationResponse, ApiError>;

    /// Get Stop
    async fn get_stop(
        &self,
        version: f64,
        id: i64,
        ) -> Result<GetStopResponse, ApiError>;

    /// Update Stop
    async fn update_stop(
        &self,
        version: f64,
        id: i64,
        body: Option<models::Stop>,
        ) -> Result<UpdateStopResponse, ApiError>;

    /// Create Stripe Checkout Session
    async fn create_stripe_checkout_session(
        &self,
        version: f64,
        app_key: String,
        stripe_parameters: String,
        ) -> Result<CreateStripeCheckoutSessionResponse, ApiError>;

    /// Create Subscription
    async fn create_subscription(
        &self,
        version: f64,
        account_id: i64,
        plan_id: Option<i64>,
        promo_code: Option<String>,
        ) -> Result<CreateSubscriptionResponse, ApiError>;

    /// Delete Subscription
    async fn delete_subscription(
        &self,
        version: f64,
        account_id: i64,
        ) -> Result<DeleteSubscriptionResponse, ApiError>;

    /// Get Subscription
    async fn get_subscription(
        &self,
        version: f64,
        account_id: i64,
        ) -> Result<GetSubscriptionResponse, ApiError>;

    /// Get Subscription Plan
    async fn get_subscription_plan(
        &self,
        version: f64,
        plan_id: i64,
        ) -> Result<GetSubscriptionPlanResponse, ApiError>;

    /// List Subscription Plans
    async fn get_subscription_plans(
        &self,
        version: f64,
        visible: Option<bool>,
        role: Option<String>,
        ) -> Result<GetSubscriptionPlansResponse, ApiError>;

    /// Get Subscription Usage
    async fn get_subscription_usage(
        &self,
        version: f64,
        account_id: i64,
        application_id: Option<i64>,
        start: Option<i64>,
        end: Option<i64>,
        ) -> Result<GetSubscriptionUsageResponse, ApiError>;

    /// Update Subscription
    async fn update_subscription(
        &self,
        version: f64,
        account_id: i64,
        plan_id: Option<i64>,
        promo_code: Option<String>,
        active: Option<bool>,
        ) -> Result<UpdateSubscriptionResponse, ApiError>;

    /// Create Task
    async fn create_task(
        &self,
        version: f64,
        account_id: i64,
        name: String,
        app_key: Option<String>,
        grouping_id: Option<String>,
        endpoint_url: Option<String>,
        payload: Option<String>,
        scheduled_date: Option<i64>,
        start_date: Option<i64>,
        end_date: Option<i64>,
        cron_expression: Option<String>,
        visibility: Option<models::AddAlbumCollectionVisibilityParameter>,
        active: Option<bool>,
        ) -> Result<CreateTaskResponse, ApiError>;

    /// Delete Task
    async fn delete_task(
        &self,
        version: f64,
        account_id: i64,
        task_id: i64,
        ) -> Result<DeleteTaskResponse, ApiError>;

    /// Get Task
    async fn get_task(
        &self,
        version: f64,
        account_id: i64,
        task_id: i64,
        ) -> Result<GetTaskResponse, ApiError>;

    /// Search Tasks
    async fn search_tasks(
        &self,
        version: f64,
        account_id: i64,
        grouping_id: Option<String>,
        filter: Option<String>,
        statuses: Option<String>,
        template_types: Option<String>,
        app_key: Option<String>,
        keyword: Option<String>,
        sort_field: Option<String>,
        descending: Option<bool>,
        start: Option<i32>,
        limit: Option<i32>,
        active_only: Option<bool>,
        ) -> Result<SearchTasksResponse, ApiError>;

    /// Update Task
    async fn update_task(
        &self,
        version: f64,
        task_id: i64,
        account_id: i64,
        name: Option<String>,
        app_key: Option<String>,
        grouping_id: Option<String>,
        endpoint_url: Option<String>,
        payload: Option<String>,
        scheduled_date: Option<i64>,
        start_date: Option<i64>,
        end_date: Option<i64>,
        cron_expression: Option<String>,
        visibility: Option<models::AddAlbumCollectionVisibilityParameter>,
        active: Option<bool>,
        ) -> Result<UpdateTaskResponse, ApiError>;

    /// Create Territory
    async fn create_territory(
        &self,
        version: f64,
        account_id: i64,
        name: String,
        active: Option<bool>,
        ) -> Result<CreateTerritoryResponse, ApiError>;

    /// Delete Territory
    async fn delete_territory(
        &self,
        version: f64,
        account_id: i64,
        territory_id: i64,
        ) -> Result<DeleteTerritoryResponse, ApiError>;

    /// Get Territory
    async fn get_territory(
        &self,
        version: f64,
        territory_id: i64,
        ) -> Result<GetTerritoryResponse, ApiError>;

    /// Search Territories
    async fn search_territories(
        &self,
        version: f64,
        sort_field: models::SearchTerritoriesSortFieldParameter,
        descending: bool,
        keyword: Option<String>,
        start: Option<i32>,
        limit: Option<i32>,
        ) -> Result<SearchTerritoriesResponse, ApiError>;

    /// Update Territory
    async fn update_territory(
        &self,
        version: f64,
        account_id: i64,
        territory_id: i64,
        name: Option<String>,
        active: Option<bool>,
        ) -> Result<UpdateTerritoryResponse, ApiError>;

    /// Create/Update Theme
    async fn add_or_update_theme_descriptor(
        &self,
        version: f64,
        public_read: bool,
        public_write: bool,
        public_delete: bool,
        public_add: bool,
        visibility: models::AddAlbumCollectionVisibilityParameter,
        include_friend_group: bool,
        complete_with_default_values: bool,
        device_id: Option<String>,
        account_id: Option<i64>,
        game_type: Option<String>,
        theme_descriptor_id: Option<i64>,
        title: Option<String>,
        description: Option<String>,
        connection_ids_to_add: Option<String>,
        connection_group_ids_to_add: Option<String>,
        app_version: Option<String>,
        color_value_json: Option<String>,
        string_replacer_json: Option<String>,
        custom_json_objects: Option<String>,
        icon_image: Option<swagger::ByteArray>,
        scene_atlas_image: Option<swagger::ByteArray>,
        bg_image: Option<swagger::ByteArray>,
        bg_sound: Option<swagger::ByteArray>,
        music_selection: Option<String>,
        location_description: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        ) -> Result<AddOrUpdateThemeDescriptorResponse, ApiError>;

    /// Get Theme
    async fn get_theme_descriptor(
        &self,
        version: f64,
        theme_descriptor_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        game_type: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        ) -> Result<GetThemeDescriptorResponse, ApiError>;

    /// Search Themes
    async fn get_theme_descriptors(
        &self,
        version: f64,
        filter: String,
        sort_field: String,
        descending: bool,
        start: i32,
        limit: i32,
        device_id: Option<String>,
        account_id: Option<i64>,
        game_type: Option<String>,
        contest_type: Option<String>,
        owner_id: Option<i64>,
        q: Option<String>,
        keyword: Option<String>,
        _i: Option<i32>,
        _l: Option<i32>,
        date_created: Option<i64>,
        app_version: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        ) -> Result<GetThemeDescriptorsResponse, ApiError>;

    /// Delete Theme
    async fn remove_theme_descriptor(
        &self,
        version: f64,
        theme_descriptor_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        game_type: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        ) -> Result<RemoveThemeDescriptorResponse, ApiError>;

    /// Create Credential
    async fn create_credential(
        &self,
        version: f64,
        third_party_id: String,
        third_party_token: String,
        network_uid: String,
        app_key: String,
        account_id: Option<i64>,
        device_id: Option<String>,
        session_id: Option<String>,
        third_party_name: Option<String>,
        email_address: Option<String>,
        signin_only_mode: Option<bool>,
        response_filters: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        meta_data: Option<String>,
        third_party_refresh_token: Option<String>,
        audience_ids_to_add: Option<String>,
        audience_ids_to_remove: Option<String>,
        ) -> Result<CreateCredentialResponse, ApiError>;

    /// Create Network
    async fn create_network(
        &self,
        version: f64,
        account_id: i64,
        name: String,
        enable_introspection: bool,
        description: Option<String>,
        introspection_method: Option<String>,
        introspection_url: Option<String>,
        introspection_params: Option<String>,
        required_root_field: Option<String>,
        enable_mfa: Option<bool>,
        size_mfa: Option<i32>,
        shelf_life_mfa: Option<i32>,
        oauth_token_url: Option<String>,
        oauth_private_key: Option<swagger::ByteArray>,
        oauth_public_key: Option<swagger::ByteArray>,
        oauth_client_id: Option<String>,
        oauth_secret_key: Option<String>,
        body: Option<String>,
        ) -> Result<CreateNetworkResponse, ApiError>;

    /// Delete Credential
    async fn delete_credential(
        &self,
        version: f64,
        account_id: i64,
        network_uid: String,
        third_party_id: String,
        app_key: String,
        ) -> Result<DeleteCredentialResponse, ApiError>;

    /// Delete Network
    async fn delete_network(
        &self,
        version: f64,
        account_id: i64,
        network_uid: String,
        ) -> Result<DeleteNetworkResponse, ApiError>;

    /// Get Credential
    async fn get_credential(
        &self,
        version: f64,
        network_uid: String,
        app_key: String,
        account_id: Option<i64>,
        device_id: Option<String>,
        session_id: Option<String>,
        third_party_credential_id: Option<i64>,
        third_party_token: Option<String>,
        third_party_secret: Option<String>,
        create_new_account: Option<bool>,
        response_filters: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        audience_ids_to_add: Option<String>,
        audience_ids_to_remove: Option<String>,
        referral_account_id: Option<i64>,
        ) -> Result<GetCredentialResponse, ApiError>;

    /// Get Network
    async fn get_network(
        &self,
        version: f64,
        account_id: i64,
        network_uid: String,
        ) -> Result<GetNetworkResponse, ApiError>;

    /// Search Credentials
    async fn search_credentials(
        &self,
        version: f64,
        account_id: i64,
        keyword: Option<String>,
        network_uid: Option<String>,
        descending: Option<bool>,
        start: Option<i32>,
        limit: Option<i32>,
        ) -> Result<SearchCredentialsResponse, ApiError>;

    /// Search Networks
    async fn search_networks(
        &self,
        version: f64,
        account_id: i64,
        sort_field: models::SearchNetworksSortFieldParameter,
        descending: bool,
        start: i32,
        limit: i32,
        active_only: bool,
        keyword: Option<String>,
        filter_billable: Option<bool>,
        ) -> Result<SearchNetworksResponse, ApiError>;

    /// Send MFA Challenge
    async fn send_mfa_challenge(
        &self,
        version: f64,
        network_uid: String,
        app_key: String,
        third_party_token: Option<String>,
        third_party_credential_id: Option<i64>,
        device_id: Option<String>,
        ) -> Result<SendMfaChallengeResponse, ApiError>;

    /// Update Credential
    async fn update_credential(
        &self,
        version: f64,
        network_uid: String,
        third_party_id: String,
        app_key: String,
        device_id: Option<String>,
        third_party_name: Option<String>,
        third_party_token: Option<String>,
        response_filters: Option<String>,
        meta_data: Option<String>,
        third_party_refresh_token: Option<String>,
        ) -> Result<UpdateCredentialResponse, ApiError>;

    /// Update Network
    async fn update_network(
        &self,
        version: f64,
        account_id: i64,
        network_uid: String,
        name: Option<String>,
        description: Option<String>,
        enable_introspection: Option<bool>,
        introspection_method: Option<String>,
        introspection_url: Option<String>,
        introspection_params: Option<String>,
        required_root_field: Option<String>,
        enable_mfa: Option<bool>,
        size_mfa: Option<i32>,
        shelf_life_mfa: Option<i32>,
        oauth_token_url: Option<String>,
        oauth_private_key: Option<swagger::ByteArray>,
        oauth_public_key: Option<swagger::ByteArray>,
        oauth_client_id: Option<String>,
        oauth_secret_key: Option<String>,
        body: Option<String>,
        ) -> Result<UpdateNetworkResponse, ApiError>;

    /// Get Ticket Count
    async fn get_ticket_count(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        game_type: Option<String>,
        app_key: Option<String>,
        ticket_type: Option<String>,
        ) -> Result<GetTicketCountResponse, ApiError>;

    /// Get Ticket List
    async fn get_ticket_list(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        ticket_object_type: Option<String>,
        action_type: Option<String>,
        ticket_ids: Option<String>,
        object_ids: Option<String>,
        receipt_tokens: Option<String>,
        game_type: Option<String>,
        app_key: Option<String>,
        ) -> Result<GetTicketListResponse, ApiError>;

    /// Gift Tickets
    async fn gift_purchase(
        &self,
        version: f64,
        receiver_account_id: i64,
        ticket_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        asset_id: Option<i64>,
        custom_message: Option<String>,
        game_type: Option<String>,
        app_key: Option<String>,
        ) -> Result<GiftPurchaseResponse, ApiError>;

    /// Save Ticket
    async fn save_ticket(
        &self,
        version: f64,
        action_type: String,
        ticket_object_type: String,
        return_nulls: Option<bool>,
        device_id: Option<String>,
        account_id: Option<i64>,
        game_type: Option<String>,
        app_key: Option<String>,
        object_id: Option<i64>,
        purchase_code: Option<String>,
        receipt_token: Option<String>,
        receipt_data: Option<String>,
        count: Option<i64>,
        ticket_type: Option<String>,
        purchase_provider: Option<String>,
        purchase_type: Option<String>,
        return_profile_response: Option<bool>,
        include_profile_response: Option<bool>,
        app_version: Option<String>,
        ) -> Result<SaveTicketResponse, ApiError>;

    /// Save Ticket with Reciept
    async fn save_ticket_via_file_upload(
        &self,
        version: f64,
        action_type: String,
        ticket_object_type: String,
        receipt_data: swagger::ByteArray,
        return_nulls: Option<bool>,
        device_id: Option<String>,
        account_id: Option<i64>,
        game_type: Option<String>,
        app_key: Option<String>,
        object_id: Option<i64>,
        purchase_code: Option<String>,
        receipt_token: Option<String>,
        count: Option<i64>,
        ticket_type: Option<String>,
        purchase_provider: Option<String>,
        purchase_type: Option<String>,
        return_profile_response: Option<bool>,
        include_profile_response: Option<bool>,
        app_version: Option<String>,
        ) -> Result<SaveTicketViaFileUploadResponse, ApiError>;

    /// Get Ticket Offers
    async fn ticket_offers(
        &self,
        version: f64,
        ) -> Result<TicketOffersResponse, ApiError>;

    /// Create Tournament
    async fn create_tournament(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        title: String,
        cost_to_play: i32,
        start_date: i64,
        sub_type: Option<String>,
        image_asset_id: Option<i64>,
        seconds_between_levels: Option<i32>,
        seconds_for_tie_breaker: Option<i32>,
        seconds_between_packs: Option<i32>,
        maximum_level_length: Option<i32>,
        cost_to_play_type: Option<String>,
        minimum_to_play: Option<i32>,
        starting_limit: Option<i32>,
        available_limit: Option<i32>,
        description: Option<String>,
        meta_data: Option<String>,
        audience_ids: Option<String>,
        active: Option<bool>,
        enable_buy_back: Option<bool>,
        offer_ids: Option<String>,
        offer_asset_id: Option<i64>,
        fixed_reward: Option<bool>,
        split_reward: Option<models::CreateTournamentSplitRewardParameter>,
        allocate_tickets: Option<bool>,
        tournament_data: Option<String>,
        mission_type: Option<models::CreateTournamentMissionTypeParameter>,
        visibility: Option<models::CreateTournamentVisibilityParameter>,
        preliminary_groups: Option<i32>,
        preliminary_group_advancements: Option<String>,
        enable_multiple_entries: Option<bool>,
        enable_multiple_votes: Option<bool>,
        featured: Option<bool>,
        winner_tag: Option<String>,
        tie_tag: Option<String>,
        ) -> Result<CreateTournamentResponse, ApiError>;

    /// Delete Tournament
    async fn delete_tournament(
        &self,
        version: f64,
        account_id: i64,
        mission_id: i64,
        ) -> Result<DeleteTournamentResponse, ApiError>;

    /// Get Tournament
    async fn get_tournament(
        &self,
        version: f64,
        account_id: i64,
        mission_id: Option<i64>,
        join_code: Option<String>,
        include_scores: Option<models::GetTournamentIncludeScoresParameter>,
        object_preview_size: Option<i32>,
        ) -> Result<GetTournamentResponse, ApiError>;

    /// Search Tournament Objects
    async fn search_objects(
        &self,
        version: f64,
        account_id: i64,
        game_level_id: i64,
        sort_field: Option<models::SearchObjectsSortFieldParameter>,
        descending: Option<bool>,
        start: Option<i32>,
        limit: Option<i32>,
        ) -> Result<SearchObjectsResponse, ApiError>;

    /// Search Tournament Rounds
    async fn search_rounds(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        status: Option<String>,
        mission_type: Option<models::SearchRoundsMissionTypeParameter>,
        current_only: Option<bool>,
        visibilities: Option<String>,
        start: Option<i32>,
        limit: Option<i32>,
        ) -> Result<SearchRoundsResponse, ApiError>;

    /// Search Tournaments
    async fn search_tournaments(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        keyword: Option<String>,
        sub_type: Option<String>,
        include_inactive: Option<bool>,
        mission_types: Option<String>,
        filter: Option<models::SearchTournamentsFilterParameter>,
        sort_field: Option<models::SearchTournamentsSortFieldParameter>,
        descending: Option<bool>,
        visibility: Option<String>,
        start: Option<i32>,
        limit: Option<i32>,
        ) -> Result<SearchTournamentsResponse, ApiError>;

    /// Submit Tournament Score
    async fn submit_tournament_score(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        mission_id: i64,
        game_id: i64,
        pack_id: i64,
        scores: String,
        game_level_id: Option<i64>,
        ) -> Result<SubmitTournamentScoreResponse, ApiError>;

    /// Submit a vote for a multi-stage album tournament.
    async fn submit_tournament_vote(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        mission_id: i64,
        game_object_id: i64,
        device_id: Option<String>,
        check_if_device_already_voted: Option<bool>,
        ) -> Result<SubmitTournamentVoteResponse, ApiError>;

    /// Substitute Tournament Player
    async fn substitute_tournament_player(
        &self,
        version: f64,
        account_id: i64,
        mission_id: i64,
        pack_id: i64,
        game_level_id: i64,
        ) -> Result<SubstituteTournamentPlayerResponse, ApiError>;

    /// Update Tournament
    async fn update_tournament(
        &self,
        version: f64,
        account_id: i64,
        mission_id: i64,
        title: Option<String>,
        sub_type: Option<String>,
        image_asset_id: Option<i64>,
        seconds_between_levels: Option<i32>,
        seconds_for_tie_breaker: Option<i32>,
        seconds_between_packs: Option<i32>,
        maximum_level_length: Option<i32>,
        cost_to_play: Option<i32>,
        cost_to_play_type: Option<String>,
        minimum_to_play: Option<i32>,
        starting_limit: Option<i32>,
        available_limit: Option<i32>,
        description: Option<String>,
        meta_data: Option<String>,
        start_date: Option<i64>,
        audience_ids: Option<String>,
        active: Option<bool>,
        enable_buy_back: Option<bool>,
        offer_ids: Option<String>,
        offer_asset_id: Option<i64>,
        fixed_reward: Option<bool>,
        split_reward: Option<models::UpdateTournamentSplitRewardParameter>,
        allocate_tickets: Option<bool>,
        tournament_data: Option<String>,
        visibility: Option<models::CreateMediaOfferVisibilityParameter>,
        preliminary_groups: Option<i32>,
        preliminary_group_advancements: Option<String>,
        enable_multiple_entries: Option<bool>,
        enable_multiple_votes: Option<bool>,
        featured: Option<bool>,
        winner_tag: Option<String>,
        tie_tag: Option<String>,
        ) -> Result<UpdateTournamentResponse, ApiError>;

    /// Create Batch Tracking
    async fn batch_save_tracking(
        &self,
        version: f64,
        data: String,
        device_id: Option<String>,
        account_id: Option<i64>,
        generate_accounts: Option<bool>,
        update_account_locations: Option<bool>,
        default_tag: Option<String>,
        slave_uid: Option<String>,
        ) -> Result<BatchSaveTrackingResponse, ApiError>;

    /// Get Predicted Locations
    async fn get_predicted_locations(
        &self,
        version: f64,
        account_id: i64,
        latitude: Option<f64>,
        longitude: Option<f64>,
        date_check: Option<i64>,
        hour_check: Option<String>,
        threshold: Option<i64>,
        distance_unit: Option<models::GetOfferListCountsDistanceUnitParameter>,
        search_range: Option<f64>,
        sort_order: Option<models::GetPredictedLocationsSortOrderParameter>,
        ) -> Result<GetPredictedLocationsResponse, ApiError>;

    /// Get Tracking Path
    async fn get_predicted_path(
        &self,
        version: f64,
        account_id: i64,
        start_step_id: i64,
        end_step_id: i64,
        ) -> Result<GetPredictedPathResponse, ApiError>;

    /// Search Preferred Locations
    async fn get_preferred_locations(
        &self,
        version: f64,
        account_id: i64,
        latitude: Option<f64>,
        longitude: Option<f64>,
        date_check: Option<i64>,
        hour_check: Option<String>,
        sort_field: Option<String>,
        descending: Option<bool>,
        start: Option<i32>,
        limit: Option<i32>,
        search_range: Option<f64>,
        distance_unit: Option<models::GetOfferListCountsDistanceUnitParameter>,
        ) -> Result<GetPreferredLocationsResponse, ApiError>;

    /// Search Tracking
    async fn get_tracking_legs(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        owner_id: Option<i64>,
        tracking_device_id: Option<String>,
        start_date: Option<i64>,
        end_date: Option<i64>,
        tags: Option<String>,
        get_last_point: Option<bool>,
        ) -> Result<GetTrackingLegsResponse, ApiError>;

    /// Create Tracking Leg
    async fn save_tracking_leg(
        &self,
        version: f64,
        start_lat: f64,
        start_lng: f64,
        start_date: i64,
        end_lat: f64,
        end_lng: f64,
        end_date: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        distance: Option<f64>,
        duration: Option<i64>,
        steps: Option<String>,
        tags: Option<String>,
        ) -> Result<SaveTrackingLegResponse, ApiError>;

    /// Create Tracking Step
    async fn save_tracking_step(
        &self,
        version: f64,
        leg_id: i64,
        start_lat: f64,
        start_lng: f64,
        start_date: i64,
        end_lat: f64,
        end_lng: f64,
        end_date: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        distance: Option<f64>,
        duration: Option<i64>,
        ) -> Result<SaveTrackingStepResponse, ApiError>;

    /// List Tracking
    async fn search_accounts_with_tracking_legs(
        &self,
        version: f64,
        account_id: i64,
        keyword: Option<String>,
        start_date: Option<i64>,
        end_date: Option<i64>,
        tags: Option<String>,
        audience_ids: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        range: Option<f64>,
        sort_field: Option<String>,
        descending: Option<bool>,
        start: Option<i32>,
        limit: Option<i32>,
        active_only: Option<bool>,
        ) -> Result<SearchAccountsWithTrackingLegsResponse, ApiError>;

    /// Search Tracking (Billable)
    async fn search_tracking_legs(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        tracking_device_id: Option<String>,
        start_date: Option<i64>,
        end_date: Option<i64>,
        tags: Option<String>,
        start: Option<i32>,
        limit: Option<i32>,
        ) -> Result<SearchTrackingLegsResponse, ApiError>;

    /// Create Trigger
    async fn create_trigger(
        &self,
        version: f64,
        account_id: i64,
        name: String,
        app_key: Option<String>,
        grouping_id: Option<String>,
        endpoint_url: Option<String>,
        payload: Option<String>,
        scheduled_date: Option<i64>,
        start_date: Option<i64>,
        end_date: Option<i64>,
        cron_expression: Option<String>,
        conditional_input: Option<String>,
        visibility: Option<models::AddAlbumCollectionVisibilityParameter>,
        active: Option<bool>,
        ) -> Result<CreateTriggerResponse, ApiError>;

    /// Delete Trigger
    async fn delete_trigger(
        &self,
        version: f64,
        account_id: i64,
        trigger_id: i64,
        ) -> Result<DeleteTriggerResponse, ApiError>;

    /// Get Trigger
    async fn get_trigger(
        &self,
        version: f64,
        account_id: i64,
        trigger_id: i64,
        ) -> Result<GetTriggerResponse, ApiError>;

    /// Search Triggers
    async fn search_triggers(
        &self,
        version: f64,
        account_id: i64,
        grouping_id: Option<String>,
        filter: Option<String>,
        statuses: Option<String>,
        template_types: Option<String>,
        app_key: Option<String>,
        keyword: Option<String>,
        sort_field: Option<String>,
        descending: Option<bool>,
        start: Option<i32>,
        limit: Option<i32>,
        active_only: Option<bool>,
        ) -> Result<SearchTriggersResponse, ApiError>;

    /// Update Trigger
    async fn update_trigger(
        &self,
        version: f64,
        trigger_id: i64,
        account_id: i64,
        name: Option<String>,
        app_key: Option<String>,
        grouping_id: Option<String>,
        endpoint_url: Option<String>,
        payload: Option<String>,
        scheduled_date: Option<i64>,
        start_date: Option<i64>,
        end_date: Option<i64>,
        cron_expression: Option<String>,
        conditional_input: Option<String>,
        visibility: Option<models::AddAlbumCollectionVisibilityParameter>,
        active: Option<bool>,
        ) -> Result<UpdateTriggerResponse, ApiError>;

    /// Create Trip
    async fn create_trip(
        &self,
        version: f64,
        body: Option<models::Trip>,
        ) -> Result<CreateTripResponse, ApiError>;

    /// Process Trip Matches
    async fn process_trip_matches(
        &self,
        version: f64,
        start_date: Option<i64>,
        end_date: Option<i64>,
        trip_id: Option<i64>,
        ) -> Result<ProcessTripMatchesResponse, ApiError>;

    /// Search Trips
    async fn search(
        &self,
        version: f64,
        account_id: i64,
        sort_field: String,
        descending: bool,
        start: i32,
        limit: i32,
        active_only: bool,
        start_date: Option<i64>,
        end_date: Option<i64>,
        has_notifications: Option<bool>,
        ) -> Result<SearchResponse, ApiError>;

    /// Search Trips
    async fn search_trips(
        &self,
        version: f64,
        account_id: i64,
        sort_field: String,
        descending: bool,
        start: i32,
        limit: i32,
        active_only: bool,
        start_date: Option<i64>,
        end_date: Option<i64>,
        matched_has_route: Option<bool>,
        matched_has_driver: Option<bool>,
        ) -> Result<SearchTripsResponse, ApiError>;

    /// Trip Notifications
    async fn update_trip_notifications(
        &self,
        version: f64,
        id: i64,
        notifications: Option<String>,
        ) -> Result<UpdateTripNotificationsResponse, ApiError>;

    /// Delete Trip
    async fn delete(
        &self,
        version: f64,
        id: i64,
        ) -> Result<DeleteResponse, ApiError>;

    /// Set Trip Preference Driver
    async fn drive_trip(
        &self,
        version: f64,
        id: i64,
        recurrence: bool,
        ) -> Result<DriveTripResponse, ApiError>;

    /// Set Trip Preference Flexible
    async fn flexible_trip(
        &self,
        version: f64,
        id: i64,
        recurrence: bool,
        ) -> Result<FlexibleTripResponse, ApiError>;

    /// Get Trip
    async fn get_trip(
        &self,
        version: f64,
        id: i64,
        ) -> Result<GetTripResponse, ApiError>;

    /// Get Trip Matches
    async fn get_trip_matches(
        &self,
        version: f64,
        id: i64,
        sort_field: String,
        descending: bool,
        start: i32,
        limit: i32,
        active_only: bool,
        matched_has_route: Option<bool>,
        matched_has_driver: Option<bool>,
        ) -> Result<GetTripMatchesResponse, ApiError>;

    /// Set Trip Preference Rider
    async fn ride(
        &self,
        version: f64,
        id: i64,
        recurrence: bool,
        ) -> Result<RideResponse, ApiError>;

    /// Update Trip Locations
    async fn update_locations(
        &self,
        version: f64,
        id: i64,
        body: Option<models::Trip>,
        ) -> Result<UpdateLocationsResponse, ApiError>;

    /// Update Recurrence Locations
    async fn update_recurrence_locations(
        &self,
        version: f64,
        id: i64,
        body: Option<models::Trip>,
        ) -> Result<UpdateRecurrenceLocationsResponse, ApiError>;

    /// Update Recurrence Shipments
    async fn update_recurrence_shipments(
        &self,
        version: f64,
        id: i64,
        body: Option<models::Trip>,
        ) -> Result<UpdateRecurrenceShipmentsResponse, ApiError>;

    /// Update Trip Shipments
    async fn update_shipments(
        &self,
        version: f64,
        id: i64,
        body: Option<models::Trip>,
        ) -> Result<UpdateShipmentsResponse, ApiError>;

    /// Update Trip
    async fn update_trip(
        &self,
        version: f64,
        id: i64,
        body: Option<models::Trip>,
        ) -> Result<UpdateTripResponse, ApiError>;

    /// Buy Offer by SMS
    async fn sms_buy_offer(
        &self,
        version: f64,
        app_key: String,
        body: String,
        from: String,
        currency_type: String,
        ) -> Result<SmsBuyOfferResponse, ApiError>;

    /// Authorize Twitter
    async fn authorize_twitter(
        &self,
        version: f64,
        app_key: String,
        ) -> Result<AuthorizeTwitterResponse, ApiError>;

    /// Login Twitter
    async fn login_twitter(
        &self,
        version: f64,
        access_token: String,
        access_token_secret: String,
        app_key: String,
        response_filters: String,
        device_id: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        ) -> Result<LoginTwitterResponse, ApiError>;

    /// Add User
    async fn add_users_to_permissionable(
        &self,
        version: f64,
        permissionable_type: models::AddUsersToPermissionablePermissionableTypeParameter,
        permissionable_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        read: Option<bool>,
        write: Option<bool>,
        delete: Option<bool>,
        add: Option<bool>,
        connection_ids: Option<String>,
        connection_account_ids: Option<String>,
        connection_group_ids: Option<String>,
        pending: Option<bool>,
        admin: Option<bool>,
        include_friend_group: Option<bool>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        audience_ids: Option<String>,
        ) -> Result<AddUsersToPermissionableResponse, ApiError>;

    /// Approve Permissionable
    async fn approve_permissionable(
        &self,
        version: f64,
        permissionable_type: models::AddUsersToPermissionablePermissionableTypeParameter,
        permissionable_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        approval_status: Option<models::ApprovePermissionableApprovalStatusParameter>,
        ) -> Result<ApprovePermissionableResponse, ApiError>;

    /// Leave
    async fn leave_from_permissionable(
        &self,
        version: f64,
        permissionable_type: String,
        permissionable_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        ) -> Result<LeaveFromPermissionableResponse, ApiError>;

    /// Remove User
    async fn remove_users_from_permissionable(
        &self,
        version: f64,
        permissionable_type: models::AddUsersToPermissionablePermissionableTypeParameter,
        permissionable_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        connection_ids: Option<String>,
        connection_account_ids: Option<String>,
        connection_group_ids: Option<String>,
        remove_friend_group: Option<bool>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        audience_ids: Option<String>,
        ) -> Result<RemoveUsersFromPermissionableResponse, ApiError>;

    /// Search Permissionables
    async fn search_permissionables(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        connection_account_id: Option<i64>,
        connection_account_ids: Option<String>,
        permissionable_type: Option<models::AddUsersToPermissionablePermissionableTypeParameter>,
        permissionable_id: Option<i64>,
        keyword: Option<String>,
        sort_field: Option<String>,
        descending: Option<bool>,
        pending: Option<bool>,
        admin: Option<bool>,
        start: Option<i32>,
        limit: Option<i32>,
        ) -> Result<SearchPermissionablesResponse, ApiError>;

    /// Search Permissionables by Distnace
    async fn search_permissionables_following_distance(
        &self,
        version: f64,
        latitude: f64,
        longitude: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        connection_account_id: Option<i64>,
        connection_account_ids: Option<String>,
        permissionable_type: Option<models::AddUsersToPermissionablePermissionableTypeParameter>,
        permissionable_id: Option<i64>,
        search_range: Option<f64>,
        keyword: Option<String>,
        pending: Option<bool>,
        admin: Option<bool>,
        start: Option<i32>,
        limit: Option<i32>,
        ) -> Result<SearchPermissionablesFollowingDistanceResponse, ApiError>;

    /// Create following
    async fn create_following(
        &self,
        version: f64,
        account_id: i64,
        vatom_parameters: String,
        return_raw_response: Option<bool>,
        ) -> Result<CreateFollowingResponse, ApiError>;

    /// Create Vatom Space
    async fn create_space(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        vatom_parameters: String,
        return_raw_response: Option<bool>,
        ) -> Result<CreateSpaceResponse, ApiError>;

    /// Create Vatom Event
    async fn create_vatom_event(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        vatom_parameters: String,
        return_raw_response: Option<bool>,
        ) -> Result<CreateVatomEventResponse, ApiError>;

    /// Delete following
    async fn delete_following(
        &self,
        version: f64,
        account_id: i64,
        vatom_rels_key: String,
        return_raw_response: Option<bool>,
        ) -> Result<DeleteFollowingResponse, ApiError>;

    /// Reset All Points Balance
    async fn delete_points_balance(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        vatom_campaign_id: String,
        return_raw_response: Option<bool>,
        ) -> Result<DeletePointsBalanceResponse, ApiError>;

    /// Delete Vatom Space
    async fn delete_space(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        vatom_space_id: String,
        return_raw_response: Option<bool>,
        ) -> Result<DeleteSpaceResponse, ApiError>;

    /// Delete Vatom Event
    async fn delete_vatom_event(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        vatom_event_id: String,
        return_raw_response: Option<bool>,
        ) -> Result<DeleteVatomEventResponse, ApiError>;

    /// Delete Vatom NFT
    async fn delete_vatom_nft(
        &self,
        version: f64,
        account_id: i64,
        vatom_id: String,
        return_raw_response: Option<bool>,
        ) -> Result<DeleteVatomNftResponse, ApiError>;

    /// Execute Action on NFT
    async fn execute_action_on_nft(
        &self,
        version: f64,
        account_id: i64,
        vatom_id: String,
        vatom_parameters: String,
        return_raw_response: Option<bool>,
        ) -> Result<ExecuteActionOnNftResponse, ApiError>;

    /// Search Vatom Geo Map
    async fn geomap_search(
        &self,
        version: f64,
        account_id: i64,
        vatom_parameters: String,
        return_raw_response: Option<bool>,
        ) -> Result<GeomapSearchResponse, ApiError>;

    /// Get Vatom Business Behaviors
    async fn get_business_behaviors(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        return_raw_response: Option<bool>,
        ) -> Result<GetBusinessBehaviorsResponse, ApiError>;

    /// Get the coins for a Business
    async fn get_business_coins_balance(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        return_raw_response: Option<bool>,
        ) -> Result<GetBusinessCoinsBalanceResponse, ApiError>;

    /// Get the user business ids
    async fn get_business_ids(
        &self,
        version: f64,
        account_id: i64,
        return_raw_response: Option<bool>,
        ) -> Result<GetBusinessIdsResponse, ApiError>;

    /// Get Vatom Business Info
    async fn get_business_info(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        vatom_parameters: Option<String>,
        return_raw_response: Option<bool>,
        ) -> Result<GetBusinessInfoResponse, ApiError>;

    /// Get Vatom Business Users
    async fn get_business_users(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        return_raw_response: Option<bool>,
        ) -> Result<GetBusinessUsersResponse, ApiError>;

    /// Get Campaign Group Entities
    async fn get_campaign_group_entities(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        vatom_campaign_id: String,
        return_raw_response: Option<bool>,
        ) -> Result<GetCampaignGroupEntitiesResponse, ApiError>;

    /// Get Campaign Group Rules
    async fn get_campaign_group_rules(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        vatom_campaign_id: String,
        return_raw_response: Option<bool>,
        ) -> Result<GetCampaignGroupRulesResponse, ApiError>;

    /// Get Campaign Group Stats
    async fn get_campaign_group_stats(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        vatom_campaign_id: String,
        return_raw_response: Option<bool>,
        ) -> Result<GetCampaignGroupStatsResponse, ApiError>;

    /// Get Campaign Info
    async fn get_campaign_info(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        vatom_campaign_id: String,
        return_raw_response: Option<bool>,
        ) -> Result<GetCampaignInfoResponse, ApiError>;

    /// Get Vatom Event Guest List
    async fn get_event_guest_list(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        vatom_event_id: String,
        return_raw_response: Option<bool>,
        ) -> Result<GetEventGuestListResponse, ApiError>;

    /// Get Vatom User's Inventory
    async fn get_inventory(
        &self,
        version: f64,
        account_id: i64,
        vatom_parameters: String,
        return_raw_response: Option<bool>,
        ) -> Result<GetInventoryResponse, ApiError>;

    /// Get following
    async fn get_my_following(
        &self,
        version: f64,
        account_id: i64,
        return_raw_response: Option<bool>,
        ) -> Result<GetMyFollowingResponse, ApiError>;

    /// Get Points Balance
    async fn get_points_balance(
        &self,
        version: f64,
        account_id: i64,
        vatom_user_id: String,
        vatom_campaign_id: String,
        return_raw_response: Option<bool>,
        ) -> Result<GetPointsBalanceResponse, ApiError>;

    /// Get Points Balance as Business
    async fn get_points_balance_as_business(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        vatom_user_id: String,
        vatom_campaign_id: String,
        return_raw_response: Option<bool>,
        ) -> Result<GetPointsBalanceAsBusinessResponse, ApiError>;

    /// Get Vatom Space
    async fn get_space(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        vatom_space_id: String,
        return_raw_response: Option<bool>,
        ) -> Result<GetSpaceResponse, ApiError>;

    /// Get the coins for a user (as a Business)
    async fn get_user_coins_as_business(
        &self,
        version: f64,
        account_id: i64,
        vatom_user_id: String,
        app_key: String,
        return_raw_response: Option<bool>,
        ) -> Result<GetUserCoinsAsBusinessResponse, ApiError>;

    /// Gets the coins balance for a Vatom User
    async fn get_user_coins_balance(
        &self,
        version: f64,
        account_id: i64,
        vatom_user_id: String,
        vatom_parameters: Option<String>,
        return_raw_response: Option<bool>,
        ) -> Result<GetUserCoinsBalanceResponse, ApiError>;

    /// Get user followers
    async fn get_user_followers(
        &self,
        version: f64,
        account_id: i64,
        vatom_user_id: String,
        return_raw_response: Option<bool>,
        ) -> Result<GetUserFollowersResponse, ApiError>;

    /// Get user following
    async fn get_user_following(
        &self,
        version: f64,
        account_id: i64,
        vatom_user_id: String,
        return_raw_response: Option<bool>,
        ) -> Result<GetUserFollowingResponse, ApiError>;

    /// Get User Info
    async fn get_user_info(
        &self,
        version: f64,
        account_id: i64,
        vatom_user_id: String,
        return_raw_response: Option<bool>,
        ) -> Result<GetUserInfoResponse, ApiError>;

    /// Get Vatom User Profile
    async fn get_user_profile(
        &self,
        version: f64,
        account_id: i64,
        return_raw_response: Option<bool>,
        ) -> Result<GetUserProfileResponse, ApiError>;

    /// Get Vatom Event
    async fn get_vatom_event(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        vatom_event_id: String,
        return_raw_response: Option<bool>,
        ) -> Result<GetVatomEventResponse, ApiError>;

    /// Get Vatom NFT Details
    async fn get_vatom_nft(
        &self,
        version: f64,
        account_id: i64,
        vatom_id: String,
        return_raw_response: Option<bool>,
        ) -> Result<GetVatomNftResponse, ApiError>;

    /// List Vatom Communities
    async fn list_communities(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        vatom_parameters: Option<String>,
        return_raw_response: Option<bool>,
        ) -> Result<ListCommunitiesResponse, ApiError>;

    /// List Vatom Events
    async fn list_events(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        vatom_parameters: Option<String>,
        return_raw_response: Option<bool>,
        ) -> Result<ListEventsResponse, ApiError>;

    /// List Vatom Spaces
    async fn list_spaces(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        vatom_parameters: Option<String>,
        return_raw_response: Option<bool>,
        ) -> Result<ListSpacesResponse, ApiError>;

    /// List Coin Transactions for a Vatom User
    async fn list_user_coin_transactions(
        &self,
        version: f64,
        account_id: i64,
        vatom_user_id: String,
        vatom_parameters: Option<String>,
        return_raw_response: Option<bool>,
        ) -> Result<ListUserCoinTransactionsResponse, ApiError>;

    /// List coin transactions for a user (as a Business)
    async fn list_user_coin_transactions_as_business(
        &self,
        version: f64,
        account_id: i64,
        vatom_user_id: String,
        app_key: String,
        vatom_parameters: Option<String>,
        return_raw_response: Option<bool>,
        ) -> Result<ListUserCoinTransactionsAsBusinessResponse, ApiError>;

    /// Perform Action on NFT
    async fn perform_action_on_nft(
        &self,
        version: f64,
        account_id: i64,
        vatom_id: String,
        vatom_action: String,
        vatom_parameters: String,
        return_raw_response: Option<bool>,
        ) -> Result<PerformActionOnNftResponse, ApiError>;

    /// Redeem NFT
    async fn redeem_nft(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        vatom_parameters: String,
        return_raw_response: Option<bool>,
        ) -> Result<RedeemNftResponse, ApiError>;

    /// Redeem the coins for a user (as a Business)
    async fn redeem_user_coins_as_business(
        &self,
        version: f64,
        account_id: i64,
        vatom_user_id: String,
        app_key: String,
        vatom_parameters: String,
        return_raw_response: Option<bool>,
        ) -> Result<RedeemUserCoinsAsBusinessResponse, ApiError>;

    /// Search for Vatom Businesses
    async fn search_businesses(
        &self,
        version: f64,
        account_id: i64,
        vatom_parameters: Option<String>,
        return_raw_response: Option<bool>,
        ) -> Result<SearchBusinessesResponse, ApiError>;

    /// Search Campaign Groups
    async fn search_campaign_groups(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        return_raw_response: Option<bool>,
        ) -> Result<SearchCampaignGroupsResponse, ApiError>;

    /// Search User Identities
    async fn search_identities(
        &self,
        version: f64,
        account_id: i64,
        return_raw_response: Option<bool>,
        ) -> Result<SearchIdentitiesResponse, ApiError>;

    /// Search Vatom User's Inventory
    async fn search_inventory(
        &self,
        version: f64,
        account_id: i64,
        vatom_parameters: Option<String>,
        return_raw_response: Option<bool>,
        ) -> Result<SearchInventoryResponse, ApiError>;

    /// Send NFT
    async fn send_nft(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        vatom_campaign_id: String,
        vatom_parameters: String,
        return_raw_response: Option<bool>,
        ) -> Result<SendNftResponse, ApiError>;

    /// Set Points Balance as Business
    async fn set_points_balance_as_business(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        vatom_user_id: String,
        vatom_campaign_id: String,
        vatom_parameters: String,
        return_raw_response: Option<bool>,
        ) -> Result<SetPointsBalanceAsBusinessResponse, ApiError>;

    /// Transfer coins from Vatom Users
    async fn transfer_user_coins(
        &self,
        version: f64,
        account_id: i64,
        vatom_user_id: String,
        vatom_parameters: String,
        return_raw_response: Option<bool>,
        ) -> Result<TransferUserCoinsResponse, ApiError>;

    /// Fund coins for a Business
    async fn update_business_coins(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        vatom_parameters: String,
        return_raw_response: Option<bool>,
        ) -> Result<UpdateBusinessCoinsResponse, ApiError>;

    /// Update Vatom Event Guest List
    async fn update_event_guest_list(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        vatom_event_id: String,
        vatom_parameters: String,
        return_raw_response: Option<bool>,
        ) -> Result<UpdateEventGuestListResponse, ApiError>;

    /// Update Vatom Space
    async fn update_space(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        vatom_space_id: String,
        vatom_parameters: String,
        return_raw_response: Option<bool>,
        ) -> Result<UpdateSpaceResponse, ApiError>;

    /// Update the coins for a user (as a Business)
    async fn update_user_coins_as_business(
        &self,
        version: f64,
        account_id: i64,
        vatom_user_id: String,
        app_key: String,
        vatom_parameters: String,
        return_raw_response: Option<bool>,
        ) -> Result<UpdateUserCoinsAsBusinessResponse, ApiError>;

    /// Update Vatom User Profile
    async fn update_user_profile(
        &self,
        version: f64,
        account_id: i64,
        vatom_parameters: String,
        return_raw_response: Option<bool>,
        ) -> Result<UpdateUserProfileResponse, ApiError>;

    /// Update Vatom Event
    async fn update_vatom_event(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        vatom_event_id: String,
        vatom_parameters: String,
        return_raw_response: Option<bool>,
        ) -> Result<UpdateVatomEventResponse, ApiError>;

    /// Create Vehicle
    async fn create_vehicle(
        &self,
        version: f64,
        vehicle: String,
        body: Option<models::Vehicle>,
        ) -> Result<CreateVehicleResponse, ApiError>;

    /// Search Vehicle
    async fn search_vehicle(
        &self,
        version: f64,
        hub_id: i64,
        sort_field: String,
        descending: bool,
        start: i32,
        limit: i32,
        active_only: bool,
        keyword: Option<String>,
        ) -> Result<SearchVehicleResponse, ApiError>;

    /// Delete Vehicle
    async fn delete_vehicle(
        &self,
        version: f64,
        id: i64,
        ) -> Result<DeleteVehicleResponse, ApiError>;

    /// Get Vehicle
    async fn get_vehicle(
        &self,
        version: f64,
        id: i64,
        ) -> Result<GetVehicleResponse, ApiError>;

    /// Update Vehicle
    async fn update_vehicle(
        &self,
        version: f64,
        id: i64,
        vehicle: String,
        body: Option<models::Vehicle>,
        ) -> Result<UpdateVehicleResponse, ApiError>;

    /// Create Vehicle Type
    async fn create_vehicle_type(
        &self,
        version: f64,
        vehicle_type: String,
        body: Option<models::VehicleType>,
        ) -> Result<CreateVehicleTypeResponse, ApiError>;

    /// Search Vehicle Type
    async fn search_vehicle_types(
        &self,
        version: f64,
        sort_field: String,
        descending: bool,
        start: i32,
        limit: i32,
        active_only: bool,
        retailer_id: Option<i64>,
        hub_id: Option<i64>,
        ) -> Result<SearchVehicleTypesResponse, ApiError>;

    /// Delete Vehicle Type
    async fn delete_vehicle_type(
        &self,
        version: f64,
        vehicle_type_id: i64,
        ) -> Result<DeleteVehicleTypeResponse, ApiError>;

    /// Get Vehicle Type
    async fn get_vehicle_type(
        &self,
        version: f64,
        vehicle_type_id: i64,
        ) -> Result<GetVehicleTypeResponse, ApiError>;

    /// Update Vehicle Type
    async fn update_vehicle_type(
        &self,
        version: f64,
        vehicle_type_id: i64,
        vehicle_type: String,
        body: Option<models::VehicleType>,
        ) -> Result<UpdateVehicleTypeResponse, ApiError>;

    /// Create Wallet Offers
    async fn create_offer_transaction(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        offer_id: Option<i64>,
        offer_location_id: Option<i64>,
        offer_cart: Option<String>,
        promo_code: Option<String>,
        currency_type: Option<String>,
        use_points: Option<bool>,
        meta_data: Option<String>,
        app_key: Option<String>,
        status: Option<i32>,
        ) -> Result<CreateOfferTransactionResponse, ApiError>;

    /// Delete Wallet Offer
    async fn delete_offer_transaction(
        &self,
        version: f64,
        transaction_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        ) -> Result<DeleteOfferTransactionResponse, ApiError>;

    /// Get Wallet Offer
    async fn get_offer_transaction(
        &self,
        version: f64,
        transaction_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        include_mission: Option<bool>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        return_full_response: Option<bool>,
        ) -> Result<GetOfferTransactionResponse, ApiError>;

    /// Preview Wallet Offers
    async fn preview_offer_transaction(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        offer_id: Option<i64>,
        offer_location_id: Option<i64>,
        offer_cart: Option<String>,
        promo_code: Option<String>,
        currency_type: Option<String>,
        use_points: Option<bool>,
        meta_data: Option<String>,
        app_key: Option<String>,
        ) -> Result<PreviewOfferTransactionResponse, ApiError>;

    /// Search Wallet Offers
    async fn search_offer_transactions(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        keyword: Option<String>,
        retailer_id: Option<i64>,
        retailer_ids: Option<String>,
        retailer_location_id: Option<i64>,
        retailer_location_ids: Option<String>,
        exclude_retailer_location_ids: Option<String>,
        offer_id: Option<i64>,
        offer_ids: Option<String>,
        offer_location_id: Option<i64>,
        offer_location_ids: Option<String>,
        offer_type: Option<models::CreateOfferOfferTypeParameter>,
        offer_types: Option<String>,
        special_offer_type: Option<String>,
        special_offer_types: Option<String>,
        category_ids: Option<String>,
        filter_ids: Option<String>,
        offer_audience_ids: Option<String>,
        sort_field: Option<models::SearchOfferTransactionsSortFieldParameter>,
        descending: Option<bool>,
        start: Option<i32>,
        limit: Option<i32>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        redeemable_start_date: Option<i64>,
        redeemable_end_date: Option<i64>,
        filter_by_parent_offer: Option<bool>,
        started_since: Option<i64>,
        started_before: Option<i64>,
        ended_since: Option<i64>,
        ended_before: Option<i64>,
        redeemed: Option<bool>,
        statuses: Option<String>,
        reservations_only: Option<bool>,
        active_only: Option<bool>,
        return_full_response: Option<bool>,
        recurring_started_since: Option<i64>,
        recurring_started_before: Option<i64>,
        recurring_expiration_since: Option<i64>,
        recurring_expiration_before: Option<i64>,
        ) -> Result<SearchOfferTransactionsResponse, ApiError>;

    /// Update Wallet Offer
    async fn update_offer_transaction(
        &self,
        version: f64,
        transaction_id: i64,
        status: i32,
        device_id: Option<String>,
        account_id: Option<i64>,
        offer_location_id: Option<i64>,
        currency_type: Option<String>,
        use_points: Option<bool>,
        app_key: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        meta_data: Option<String>,
        return_full_response: Option<bool>,
        exception_membership_offer_ids: Option<String>,
        ) -> Result<UpdateOfferTransactionResponse, ApiError>;

    /// Search Weather
    async fn search_weather(
        &self,
        version: f64,
        region_id: Option<i64>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        timezone_offset: Option<i64>,
        ) -> Result<SearchWeatherResponse, ApiError>;

    /// Create Word
    async fn create_word(
        &self,
        version: f64,
        account_id: i64,
        word: String,
        definition: String,
        active: bool,
        allocate_tickets: bool,
        ticket_count: i64,
        asset_id: Option<i64>,
        ticket_type: Option<String>,
        points: Option<i64>,
        ) -> Result<CreateWordResponse, ApiError>;

    /// Delete Word
    async fn delete_word(
        &self,
        version: f64,
        word_id: i64,
        account_id: i64,
        ) -> Result<DeleteWordResponse, ApiError>;

    /// Get Word
    async fn get_word(
        &self,
        version: f64,
        word_id: i64,
        account_id: i64,
        ) -> Result<GetWordResponse, ApiError>;

    /// Search Words
    async fn get_words(
        &self,
        version: f64,
        account_id: i64,
        sort_field: String,
        descending: bool,
        active_only: bool,
        start: i32,
        limit: i32,
        keyword: Option<String>,
        ) -> Result<GetWordsResponse, ApiError>;

    /// Update Word
    async fn update_word(
        &self,
        version: f64,
        word_id: i64,
        account_id: i64,
        ticket_count: i64,
        word_text: Option<String>,
        definition: Option<String>,
        asset_id: Option<i64>,
        active: Option<bool>,
        allocate_tickets: Option<bool>,
        ticket_type: Option<String>,
        points: Option<i64>,
        ) -> Result<UpdateWordResponse, ApiError>;

    /// Run Workflow
    async fn run_workflow(
        &self,
        version: f64,
        account_id: i64,
        workflow_id: i64,
        sku_id: Option<i64>,
        version_code: Option<i32>,
        parameters: Option<String>,
        ) -> Result<RunWorkflowResponse, ApiError>;

}

/// Trait to extend an API to make it easy to bind it to a context.
pub trait ContextWrapperExt<C: Send + Sync> where Self: Sized
{
    /// Binds this API to a context.
    fn with_context(self, context: C) -> ContextWrapper<Self, C>;
}

impl<T: Api<C> + Send + Sync, C: Clone + Send + Sync> ContextWrapperExt<C> for T {
    fn with_context(self: T, context: C) -> ContextWrapper<T, C> {
         ContextWrapper::<T, C>::new(self, context)
    }
}

#[async_trait]
impl<T: Api<C> + Send + Sync, C: Clone + Send + Sync> ApiNoContext<C> for ContextWrapper<T, C> {
    fn context(&self) -> &C {
        ContextWrapper::context(self)
    }

    /// Create Consumer
    async fn consumer_create(
        &self,
        version: f64,
        app_key: String,
        name: String,
        hostname: String,
        username: String,
        password: String,
        data_mapping: String,
        device_id: Option<String>,
        account_id: Option<i64>,
        port: Option<i32>,
        virtual_host: Option<String>,
        exchanger: Option<String>,
        exchanger_type: Option<String>,
        workers: Option<i32>,
        use_ssl: Option<bool>,
        ) -> Result<ConsumerCreateResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().consumer_create(version, app_key, name, hostname, username, password, data_mapping, device_id, account_id, port, virtual_host, exchanger, exchanger_type, workers, use_ssl, &context).await
    }

    /// Update Consumer
    async fn consumer_update(
        &self,
        version: f64,
        app_key: String,
        queue_id: i64,
        data_mapping: String,
        device_id: Option<String>,
        account_id: Option<i64>,
        use_ssl: Option<bool>,
        ) -> Result<ConsumerUpdateResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().consumer_update(version, app_key, queue_id, data_mapping, device_id, account_id, use_ssl, &context).await
    }

    /// Create Queue
    async fn queue_create(
        &self,
        version: f64,
        app_key: String,
        name: String,
        device_id: Option<String>,
        account_id: Option<i64>,
        workers: Option<i32>,
        analytic_tags: Option<String>,
        hostname: Option<String>,
        port: Option<i32>,
        username: Option<String>,
        password: Option<String>,
        virtual_host: Option<String>,
        use_ssl: Option<bool>,
        ) -> Result<QueueCreateResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().queue_create(version, app_key, name, device_id, account_id, workers, analytic_tags, hostname, port, username, password, virtual_host, use_ssl, &context).await
    }

    /// Delete Queue
    async fn queue_delete(
        &self,
        version: f64,
        queue_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        ) -> Result<QueueDeleteResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().queue_delete(version, queue_id, device_id, account_id, &context).await
    }

    /// Get Queue
    async fn queue_get(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        queue_id: Option<i64>,
        app_key: Option<String>,
        name: Option<String>,
        hostname: Option<String>,
        virtual_host: Option<String>,
        ) -> Result<QueueGetResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().queue_get(version, device_id, account_id, queue_id, app_key, name, hostname, virtual_host, &context).await
    }

    /// Publish Queue
    async fn queue_publish(
        &self,
        version: f64,
        message: String,
        queue_id: Option<i64>,
        app_key: Option<String>,
        name: Option<String>,
        hostname: Option<String>,
        virtual_host: Option<String>,
        ) -> Result<QueuePublishResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().queue_publish(version, message, queue_id, app_key, name, hostname, virtual_host, &context).await
    }

    /// Search Queue
    async fn queue_search(
        &self,
        version: f64,
        queue_id: Option<i64>,
        device_id: Option<String>,
        account_id: Option<i64>,
        name: Option<String>,
        start: Option<i32>,
        limit: Option<i32>,
        ) -> Result<QueueSearchResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().queue_search(version, queue_id, device_id, account_id, name, start, limit, &context).await
    }

    /// Update Queue
    async fn queue_update(
        &self,
        version: f64,
        queue_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        app_key: Option<String>,
        workers: Option<i32>,
        analytic_tags: Option<String>,
        hostname: Option<String>,
        port: Option<i32>,
        username: Option<String>,
        password: Option<String>,
        virtual_host: Option<String>,
        use_ssl: Option<bool>,
        ) -> Result<QueueUpdateResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().queue_update(version, queue_id, device_id, account_id, app_key, workers, analytic_tags, hostname, port, username, password, virtual_host, use_ssl, &context).await
    }

    /// Search Accounts by Location
    async fn account_location_search(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        q: Option<String>,
        keyword: Option<String>,
        postal_code: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        app_key: Option<String>,
        range: Option<f64>,
        location_last_updated: Option<i64>,
        gender: Option<String>,
        min_age: Option<i32>,
        max_age: Option<i32>,
        companionship_index: Option<i32>,
        _i: Option<i32>,
        start: Option<i32>,
        _l: Option<i32>,
        limit: Option<i32>,
        search_mode: Option<String>,
        sort_field: Option<String>,
        descending: Option<bool>,
        roles: Option<String>,
        tags: Option<String>,
        experience: Option<String>,
        category_ids: Option<String>,
        audience_ids: Option<String>,
        audience_operator: Option<String>,
        update_current_location: Option<bool>,
        update_preferred_settings: Option<bool>,
        show_exact_locations: Option<bool>,
        show_connection_to_searcher: Option<bool>,
        flag_count_minimum: Option<i64>,
        verified_user_only: Option<bool>,
        content_admin_only: Option<bool>,
        ) -> Result<AccountLocationSearchResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().account_location_search(version, device_id, account_id, q, keyword, postal_code, latitude, longitude, app_key, range, location_last_updated, gender, min_age, max_age, companionship_index, _i, start, _l, limit, search_mode, sort_field, descending, roles, tags, experience, category_ids, audience_ids, audience_operator, update_current_location, update_preferred_settings, show_exact_locations, show_connection_to_searcher, flag_count_minimum, verified_user_only, content_admin_only, &context).await
    }

    /// Block Account
    async fn block_account(
        &self,
        version: f64,
        account_id_being_blocked: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        block_flag_value: Option<bool>,
        remove_from_groups_if_blocked: Option<bool>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        ) -> Result<BlockAccountResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().block_account(version, account_id_being_blocked, device_id, account_id, block_flag_value, remove_from_groups_if_blocked, latitude, longitude, &context).await
    }

    /// Create Account
    async fn create_account(
        &self,
        version: f64,
        username: String,
        password: String,
        name: Option<String>,
        prefix_name: Option<String>,
        first_name: Option<String>,
        middle_name: Option<String>,
        last_name: Option<String>,
        suffix_name: Option<String>,
        title: Option<String>,
        device_id: Option<String>,
        device_id_type: Option<String>,
        email_address: Option<String>,
        asset_id: Option<i64>,
        street_address: Option<String>,
        zipcode: Option<String>,
        gender: Option<String>,
        birthday: Option<i64>,
        home_phone: Option<String>,
        cell_phone: Option<String>,
        cell_phone_carrier: Option<String>,
        business_phone: Option<String>,
        role: Option<String>,
        platforms: Option<String>,
        tags: Option<String>,
        about_us: Option<String>,
        game_experience: Option<String>,
        category_ids: Option<String>,
        hometown: Option<String>,
        height: Option<String>,
        height_index: Option<i32>,
        ethnicity: Option<String>,
        body_type: Option<String>,
        marital_status: Option<String>,
        children: Option<String>,
        religion: Option<String>,
        education: Option<String>,
        education_index: Option<i32>,
        smoke: Option<String>,
        drink: Option<String>,
        companionship: Option<String>,
        companionship_index: Option<i32>,
        preferred_min_age: Option<i32>,
        preferred_max_age: Option<i32>,
        preferred_min_height: Option<i32>,
        preferred_max_height: Option<i32>,
        preferred_gender: Option<String>,
        preferred_education: Option<String>,
        preferred_education_index: Option<i32>,
        preferred_body_type: Option<String>,
        preferred_ethnicity: Option<String>,
        preferred_location: Option<String>,
        preferred_location_range: Option<f64>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        accepted_terms: Option<bool>,
        invite_token: Option<String>,
        referral_account_id: Option<i64>,
        send_validation: Option<bool>,
        game_type: Option<String>,
        app_key: Option<String>,
        app_version: Option<String>,
        response_type: Option<String>,
        audience_ids_to_add: Option<String>,
        app_blob: Option<String>,
        app_enable_push: Option<bool>,
        app_enable_sms: Option<bool>,
        app_enable_email: Option<bool>,
        location_visibility: Option<String>,
        home_latitude: Option<f64>,
        home_longitude: Option<f64>,
        app_nickname: Option<String>,
        personal_audience_id: Option<i64>,
        ) -> Result<CreateAccountResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().create_account(version, username, password, name, prefix_name, first_name, middle_name, last_name, suffix_name, title, device_id, device_id_type, email_address, asset_id, street_address, zipcode, gender, birthday, home_phone, cell_phone, cell_phone_carrier, business_phone, role, platforms, tags, about_us, game_experience, category_ids, hometown, height, height_index, ethnicity, body_type, marital_status, children, religion, education, education_index, smoke, drink, companionship, companionship_index, preferred_min_age, preferred_max_age, preferred_min_height, preferred_max_height, preferred_gender, preferred_education, preferred_education_index, preferred_body_type, preferred_ethnicity, preferred_location, preferred_location_range, latitude, longitude, accepted_terms, invite_token, referral_account_id, send_validation, game_type, app_key, app_version, response_type, audience_ids_to_add, app_blob, app_enable_push, app_enable_sms, app_enable_email, location_visibility, home_latitude, home_longitude, app_nickname, personal_audience_id, &context).await
    }

    /// Update Account
    async fn edit_account(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        connection_account_id: Option<i64>,
        role: Option<String>,
        asset_id: Option<i64>,
        name: Option<String>,
        prefix_name: Option<String>,
        first_name: Option<String>,
        middle_name: Option<String>,
        last_name: Option<String>,
        suffix_name: Option<String>,
        title: Option<String>,
        gender: Option<String>,
        age: Option<i32>,
        birthday: Option<i64>,
        home_phone: Option<String>,
        cell_phone: Option<String>,
        cell_phone_carrier: Option<String>,
        business_phone: Option<String>,
        email_address: Option<String>,
        street_address: Option<String>,
        street_address2: Option<String>,
        city: Option<String>,
        state: Option<String>,
        zipcode: Option<String>,
        country: Option<String>,
        make_profile_info_public: Option<bool>,
        make_game_info_public: Option<bool>,
        make_friends_info_public: Option<bool>,
        hometown: Option<String>,
        height: Option<String>,
        height_index: Option<i32>,
        ethnicity: Option<String>,
        body_type: Option<String>,
        marital_status: Option<String>,
        children: Option<String>,
        religion: Option<String>,
        education: Option<String>,
        education_index: Option<i32>,
        smoke: Option<String>,
        drink: Option<String>,
        companionship: Option<String>,
        companionship_index: Option<i32>,
        preferred_min_age: Option<i32>,
        preferred_max_age: Option<i32>,
        preferred_min_height: Option<i32>,
        preferred_max_height: Option<i32>,
        preferred_gender: Option<String>,
        preferred_education: Option<String>,
        preferred_education_index: Option<i32>,
        preferred_body_type: Option<String>,
        preferred_ethnicity: Option<String>,
        preferred_location: Option<String>,
        preferred_location_range: Option<f64>,
        platforms: Option<String>,
        tags: Option<String>,
        about_us: Option<String>,
        match_token: Option<String>,
        game_experience: Option<String>,
        categories: Option<String>,
        category_ids: Option<String>,
        response_filters: Option<String>,
        show_as_zipcode: Option<bool>,
        show_exact_location: Option<bool>,
        show_others_exact_location: Option<bool>,
        accepted_terms: Option<bool>,
        location_visibility: Option<String>,
        app_blob: Option<String>,
        app_enable_push: Option<bool>,
        app_enable_sms: Option<bool>,
        app_enable_email: Option<bool>,
        game_type: Option<String>,
        app_key: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        return_profile: Option<bool>,
        audience_ids_to_add: Option<String>,
        audience_ids_to_remove: Option<String>,
        referral_account_id: Option<i64>,
        app_nickname: Option<String>,
        personal_audience_id: Option<i64>,
        non_guest_username: Option<String>,
        ) -> Result<EditAccountResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().edit_account(version, device_id, account_id, connection_account_id, role, asset_id, name, prefix_name, first_name, middle_name, last_name, suffix_name, title, gender, age, birthday, home_phone, cell_phone, cell_phone_carrier, business_phone, email_address, street_address, street_address2, city, state, zipcode, country, make_profile_info_public, make_game_info_public, make_friends_info_public, hometown, height, height_index, ethnicity, body_type, marital_status, children, religion, education, education_index, smoke, drink, companionship, companionship_index, preferred_min_age, preferred_max_age, preferred_min_height, preferred_max_height, preferred_gender, preferred_education, preferred_education_index, preferred_body_type, preferred_ethnicity, preferred_location, preferred_location_range, platforms, tags, about_us, match_token, game_experience, categories, category_ids, response_filters, show_as_zipcode, show_exact_location, show_others_exact_location, accepted_terms, location_visibility, app_blob, app_enable_push, app_enable_sms, app_enable_email, game_type, app_key, latitude, longitude, return_profile, audience_ids_to_add, audience_ids_to_remove, referral_account_id, app_nickname, personal_audience_id, non_guest_username, &context).await
    }

    /// Update Username and Email
    async fn edit_username(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        email_address: Option<String>,
        username: Option<String>,
        ) -> Result<EditUsernameResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().edit_username(version, device_id, account_id, email_address, username, &context).await
    }

    /// Get Account
    async fn get_account(
        &self,
        version: f64,
        return_nulls: Option<bool>,
        device_id: Option<String>,
        account_id: Option<i64>,
        connection_account_email: Option<String>,
        connection_account_id: Option<i64>,
        response_filters: Option<String>,
        game_type: Option<String>,
        app_key: Option<String>,
        purchase_type: Option<String>,
        update_viewed_date: Option<bool>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        ) -> Result<GetAccountResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_account(version, return_nulls, device_id, account_id, connection_account_email, connection_account_id, response_filters, game_type, app_key, purchase_type, update_viewed_date, latitude, longitude, &context).await
    }

    /// Get Profile Assets
    async fn get_profile_assets(
        &self,
        version: f64,
        return_nulls: Option<bool>,
        device_id: Option<String>,
        account_id: Option<i64>,
        owner_id: Option<i64>,
        media_types: Option<String>,
        mime_types: Option<String>,
        sort_field: Option<String>,
        descending: Option<bool>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        _i: Option<i32>,
        start: Option<i32>,
        _l: Option<i32>,
        limit: Option<i32>,
        ) -> Result<GetProfileAssetsResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_profile_assets(version, return_nulls, device_id, account_id, owner_id, media_types, mime_types, sort_field, descending, latitude, longitude, _i, start, _l, limit, &context).await
    }

    /// Search Accounts
    async fn get_referral_list(
        &self,
        version: f64,
        account_id: Option<i64>,
        app_key: Option<String>,
        retrieve_type: Option<String>,
        level_limit: Option<f64>,
        ancestor_level_limit: Option<f64>,
        children_level_limit: Option<f64>,
        ancestor_list_start: Option<f64>,
        ancestor_list_limit: Option<f64>,
        children_list_start: Option<f64>,
        children_list_limit: Option<f64>,
        children_children: Option<bool>,
        ) -> Result<GetReferralListResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_referral_list(version, account_id, app_key, retrieve_type, level_limit, ancestor_level_limit, children_level_limit, ancestor_list_start, ancestor_list_limit, children_list_start, children_list_limit, children_children, &context).await
    }

    /// Get Account Settings
    async fn get_settings(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        ) -> Result<GetSettingsResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_settings(version, device_id, account_id, latitude, longitude, &context).await
    }

    /// Login as Account
    async fn login_delegate(
        &self,
        version: f64,
        access_token: String,
        app_key: String,
        device_id: Option<String>,
        access_token_secret: Option<String>,
        delegated_account_id: Option<i64>,
        delegated_username: Option<String>,
        network_uid: Option<String>,
        age_restriction: Option<i32>,
        response_filters: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        ) -> Result<LoginDelegateResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().login_delegate(version, access_token, app_key, device_id, access_token_secret, delegated_account_id, delegated_username, network_uid, age_restriction, response_filters, latitude, longitude, &context).await
    }

    /// Login Account
    async fn login_general(
        &self,
        version: f64,
        access_token: String,
        network_uid: String,
        app_key: String,
        device_id: Option<String>,
        device_id_type: Option<String>,
        access_token_secret: Option<String>,
        age_restriction: Option<i32>,
        response_filters: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        email_match: Option<bool>,
        chosen_account_id: Option<i64>,
        third_party_credential_id: Option<i64>,
        ) -> Result<LoginGeneralResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().login_general(version, access_token, network_uid, app_key, device_id, device_id_type, access_token_secret, age_restriction, response_filters, latitude, longitude, email_match, chosen_account_id, third_party_credential_id, &context).await
    }

    /// Login Account (Username)
    async fn login_username(
        &self,
        version: f64,
        username: String,
        password: String,
        device_id: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        app: Option<String>,
        game_type: Option<String>,
        app_key: Option<String>,
        return_profile: Option<bool>,
        response_filters: Option<String>,
        ) -> Result<LoginUsernameResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().login_username(version, username, password, device_id, latitude, longitude, app, game_type, app_key, return_profile, response_filters, &context).await
    }

    /// Logout Account
    async fn logout(
        &self,
        version: f64,
        device_id: Option<String>,
        device_id_type: Option<String>,
        account_id: Option<i64>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        ) -> Result<LogoutResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().logout(version, device_id, device_id_type, account_id, latitude, longitude, &context).await
    }

    /// Merge Account
    async fn merge_account(
        &self,
        version: f64,
        merge_account_id: i64,
        app_key: String,
        device_id: Option<String>,
        account_id: Option<i64>,
        ) -> Result<MergeAccountResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().merge_account(version, merge_account_id, app_key, device_id, account_id, &context).await
    }

    /// Update Password
    async fn password_change(
        &self,
        version: f64,
        account_id: i64,
        old_password: String,
        new_password: String,
        confirm_password: String,
        ) -> Result<PasswordChangeResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().password_change(version, account_id, old_password, new_password, confirm_password, &context).await
    }

    /// Reset Password
    async fn password_reset(
        &self,
        version: f64,
        token: String,
        password: String,
        confirm: String,
        ) -> Result<PasswordResetResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().password_reset(version, token, password, confirm, &context).await
    }

    /// Request Password Reset
    async fn request_password_reset(
        &self,
        version: f64,
        email: String,
        from: Option<String>,
        domain: Option<String>,
        sub_url: Option<String>,
        referer: Option<String>,
        ) -> Result<RequestPasswordResetResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().request_password_reset(version, email, from, domain, sub_url, referer, &context).await
    }

    /// Send Validation Request
    async fn request_validate_account(
        &self,
        version: f64,
        account_id: i64,
        ) -> Result<RequestValidateAccountResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().request_validate_account(version, account_id, &context).await
    }

    /// Search Accounts
    async fn search_accounts(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        keyword: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        radius: Option<f64>,
        gender: Option<models::SearchAccountsGenderParameter>,
        game_experience: Option<models::SearchAccountsGameExperienceParameter>,
        age: Option<i32>,
        category_ids: Option<String>,
        return_nulls: Option<bool>,
        response_filters: Option<String>,
        purchase_type: Option<String>,
        sort_field: Option<String>,
        descending: Option<bool>,
        start: Option<i32>,
        limit: Option<i32>,
        active_only: Option<bool>,
        ) -> Result<SearchAccountsResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().search_accounts(version, account_id, app_key, keyword, latitude, longitude, radius, gender, game_experience, age, category_ids, return_nulls, response_filters, purchase_type, sort_field, descending, start, limit, active_only, &context).await
    }

    /// Login Account (Encrypted Username)
    async fn secure_login(
        &self,
        version: f64,
        username: String,
        password: String,
        game_type: String,
        device_id: Option<String>,
        charset_name: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        return_profile: Option<bool>,
        response_filters: Option<String>,
        ) -> Result<SecureLoginResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().secure_login(version, username, password, game_type, device_id, charset_name, latitude, longitude, return_profile, response_filters, &context).await
    }

    /// Create Account (Encrypted Username)
    async fn secure_signup(
        &self,
        version: f64,
        device_id: String,
        username: String,
        password: String,
        name: Option<String>,
        invite_token: Option<String>,
        prefix_name: Option<String>,
        first_name: Option<String>,
        middle_name: Option<String>,
        last_name: Option<String>,
        suffix_name: Option<String>,
        title: Option<String>,
        device_id_type: Option<String>,
        email_address: Option<String>,
        asset_id: Option<i64>,
        address: Option<String>,
        zipcode: Option<String>,
        gender: Option<String>,
        birthday: Option<i64>,
        home_phone: Option<String>,
        cell_phone: Option<String>,
        cell_phone_carrier: Option<String>,
        business_phone: Option<String>,
        role: Option<String>,
        platforms: Option<String>,
        tags: Option<String>,
        about_us: Option<String>,
        game_experience: Option<String>,
        category_ids: Option<String>,
        hometown: Option<String>,
        height: Option<String>,
        height_index: Option<i32>,
        ethnicity: Option<String>,
        body_type: Option<String>,
        marital_status: Option<String>,
        children: Option<String>,
        religion: Option<String>,
        education: Option<String>,
        education_index: Option<i32>,
        smoke: Option<String>,
        drink: Option<String>,
        companionship: Option<String>,
        companionship_index: Option<i32>,
        preferred_min_age: Option<i32>,
        preferred_max_age: Option<i32>,
        preferred_min_height: Option<i32>,
        preferred_max_height: Option<i32>,
        preferred_gender: Option<String>,
        preferred_education: Option<String>,
        preferred_education_index: Option<i32>,
        preferred_body_type: Option<String>,
        preferred_ethnicity: Option<String>,
        preferred_location: Option<String>,
        preferred_location_range: Option<f64>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        accepted_terms: Option<bool>,
        charset_name: Option<String>,
        game_type: Option<String>,
        app_key: Option<String>,
        app_version: Option<String>,
        response_type: Option<String>,
        ) -> Result<SecureSignupResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().secure_signup(version, device_id, username, password, name, invite_token, prefix_name, first_name, middle_name, last_name, suffix_name, title, device_id_type, email_address, asset_id, address, zipcode, gender, birthday, home_phone, cell_phone, cell_phone_carrier, business_phone, role, platforms, tags, about_us, game_experience, category_ids, hometown, height, height_index, ethnicity, body_type, marital_status, children, religion, education, education_index, smoke, drink, companionship, companionship_index, preferred_min_age, preferred_max_age, preferred_min_height, preferred_max_height, preferred_gender, preferred_education, preferred_education_index, preferred_body_type, preferred_ethnicity, preferred_location, preferred_location_range, latitude, longitude, accepted_terms, charset_name, game_type, app_key, app_version, response_type, &context).await
    }

    /// Save Match Token
    async fn set_match_token(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        match_token: Option<String>,
        game_type: Option<String>,
        app_key: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        ) -> Result<SetMatchTokenResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().set_match_token(version, device_id, account_id, match_token, game_type, app_key, latitude, longitude, &context).await
    }

    /// Update Account Active Status
    async fn update_actve_status(
        &self,
        version: f64,
        account_id: i64,
        connection_account_id: i64,
        active: bool,
        device_id: Option<String>,
        app_key: Option<String>,
        ) -> Result<UpdateActveStatusResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().update_actve_status(version, account_id, connection_account_id, active, device_id, app_key, &context).await
    }

    /// Update Location
    async fn update_location(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        client_time: Option<i64>,
        ) -> Result<UpdateLocationResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().update_location(version, device_id, account_id, latitude, longitude, client_time, &context).await
    }

    /// Update Account Settings
    async fn update_settings(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        blocked_notifications: Option<String>,
        suggestion_method: Option<String>,
        suggestion_count: Option<i32>,
        suggestion_time_frame: Option<i32>,
        show_others_exact_location: Option<bool>,
        show_as_zipcode: Option<bool>,
        show_exact_location: Option<bool>,
        favorite_visibility: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        ) -> Result<UpdateSettingsResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().update_settings(version, device_id, account_id, blocked_notifications, suggestion_method, suggestion_count, suggestion_time_frame, show_others_exact_location, show_as_zipcode, show_exact_location, favorite_visibility, latitude, longitude, &context).await
    }

    /// Save Validation Status
    async fn validate_account_signup(
        &self,
        version: f64,
        token: String,
        ) -> Result<ValidateAccountSignupResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().validate_account_signup(version, token, &context).await
    }

    /// Validate Password Reset Token
    async fn validate_password_reset(
        &self,
        version: f64,
        token: String,
        ) -> Result<ValidatePasswordResetResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().validate_password_reset(version, token, &context).await
    }

    /// Searches an Achievement Tier
    async fn api_version_achievement_tier_search_post(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        app_key: Option<String>,
        keyword: Option<String>,
        achievement_type: Option<i64>,
        rank_type: Option<String>,
        sort_field: Option<String>,
        descending: Option<bool>,
        descending_goal: Option<bool>,
        start: Option<i64>,
        limit: Option<i64>,
        ) -> Result<ApiVersionAchievementTierSearchPostResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().api_version_achievement_tier_search_post(version, device_id, account_id, app_key, keyword, achievement_type, rank_type, sort_field, descending, descending_goal, start, limit, &context).await
    }

    /// Create Achievement
    async fn create_achievement(
        &self,
        version: f64,
        app_key: String,
        title: String,
        device_id: Option<String>,
        account_id: Option<i64>,
        analytics_tag: Option<String>,
        description: Option<String>,
        rank_type: Option<String>,
        rank_increment: Option<i32>,
        min_increment: Option<i32>,
        max_increment: Option<i32>,
        validate: Option<bool>,
        active: Option<bool>,
        trigger_definition: Option<String>,
        ) -> Result<CreateAchievementResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().create_achievement(version, app_key, title, device_id, account_id, analytics_tag, description, rank_type, rank_increment, min_increment, max_increment, validate, active, trigger_definition, &context).await
    }

    /// Create Achievement Tier
    async fn create_achievement_tier(
        &self,
        version: f64,
        achievement_id: i64,
        score_all_instances: bool,
        device_id: Option<String>,
        account_id: Option<i64>,
        icon: Option<swagger::ByteArray>,
        icon_asset_id: Option<i64>,
        title: Option<String>,
        description: Option<String>,
        goal_count: Option<i64>,
        mission_id: Option<i64>,
        game_id: Option<i64>,
        pack_id: Option<i64>,
        game_level_id: Option<i64>,
        game_object_id: Option<i32>,
        ) -> Result<CreateAchievementTierResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().create_achievement_tier(version, achievement_id, score_all_instances, device_id, account_id, icon, icon_asset_id, title, description, goal_count, mission_id, game_id, pack_id, game_level_id, game_object_id, &context).await
    }

    /// Delete Achievement
    async fn delete_achievement(
        &self,
        version: f64,
        achievement_id: i64,
        account_id: Option<i64>,
        ) -> Result<DeleteAchievementResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().delete_achievement(version, achievement_id, account_id, &context).await
    }

    /// Delete Achievement Tier
    async fn delete_achievement_tier(
        &self,
        version: f64,
        achievement_tier_id: i64,
        account_id: Option<i64>,
        ) -> Result<DeleteAchievementTierResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().delete_achievement_tier(version, achievement_tier_id, account_id, &context).await
    }

    /// Get Achievement
    async fn get_achievement(
        &self,
        version: f64,
        achievement_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        achievement_type: Option<String>,
        ) -> Result<GetAchievementResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_achievement(version, achievement_id, device_id, account_id, achievement_type, &context).await
    }

    /// Gets an achievement tier
    async fn get_achievement_tier(
        &self,
        version: f64,
        account_id: i64,
        achievement_tier_id: i64,
        ) -> Result<GetAchievementTierResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_achievement_tier(version, account_id, achievement_tier_id, &context).await
    }

    /// Get Achievement Progress
    async fn get_user_achievements(
        &self,
        version: f64,
        return_nulls: bool,
        app_key: String,
        include_undiscovered: bool,
        device_id: Option<String>,
        account_id: Option<i64>,
        connection_account_email: Option<String>,
        connection_account_id: Option<i64>,
        rank_type: Option<String>,
        achievement_type: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        ) -> Result<GetUserAchievementsResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_user_achievements(version, return_nulls, app_key, include_undiscovered, device_id, account_id, connection_account_email, connection_account_id, rank_type, achievement_type, latitude, longitude, &context).await
    }

    /// List Achievement Tags
    async fn list_achievement_tags(
        &self,
        version: f64,
        app_key: Option<String>,
        ) -> Result<ListAchievementTagsResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().list_achievement_tags(version, app_key, &context).await
    }

    /// List Achievements
    async fn list_achievements(
        &self,
        version: f64,
        sort_field: models::ListAchievementsSortFieldParameter,
        descending: bool,
        start: i32,
        limit: i32,
        active_only: bool,
        device_id: Option<String>,
        account_id: Option<i64>,
        app_key: Option<String>,
        keyword: Option<String>,
        achievement_type: Option<String>,
        rank_type: Option<String>,
        ) -> Result<ListAchievementsResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().list_achievements(version, sort_field, descending, start, limit, active_only, device_id, account_id, app_key, keyword, achievement_type, rank_type, &context).await
    }

    /// Search Achievements
    async fn search_achievements(
        &self,
        version: f64,
        app_key: String,
        sort_field: models::SearchAchievementsSortFieldParameter,
        descending: bool,
        include_tiers: bool,
        include_inactive_tiers: bool,
        start: i32,
        limit: i32,
        device_id: Option<String>,
        account_id: Option<i64>,
        keyword: Option<String>,
        achievement_type: Option<String>,
        rank_type: Option<String>,
        ) -> Result<SearchAchievementsResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().search_achievements(version, app_key, sort_field, descending, include_tiers, include_inactive_tiers, start, limit, device_id, account_id, keyword, achievement_type, rank_type, &context).await
    }

    /// Update Achievement
    async fn update_achievement(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        achievement_id: Option<i64>,
        analytics_tag: Option<String>,
        title: Option<String>,
        description: Option<String>,
        rank_type: Option<String>,
        rank_increment: Option<i32>,
        min_increment: Option<i32>,
        null_min_increment: Option<bool>,
        max_increment: Option<i32>,
        null_max_increment: Option<bool>,
        validate: Option<bool>,
        active: Option<bool>,
        trigger_definition: Option<String>,
        ) -> Result<UpdateAchievementResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().update_achievement(version, device_id, account_id, achievement_id, analytics_tag, title, description, rank_type, rank_increment, min_increment, null_min_increment, max_increment, null_max_increment, validate, active, trigger_definition, &context).await
    }

    /// Update Achievement Tier
    async fn update_achievement_tier(
        &self,
        version: f64,
        achievement_tier_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        icon: Option<swagger::ByteArray>,
        icon_asset_id: Option<i64>,
        title: Option<String>,
        description: Option<String>,
        goal_count: Option<i64>,
        mission_id: Option<i64>,
        game_id: Option<i64>,
        pack_id: Option<i64>,
        game_level_id: Option<i64>,
        game_object_id: Option<i64>,
        score_all_instances: Option<bool>,
        ) -> Result<UpdateAchievementTierResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().update_achievement_tier(version, achievement_tier_id, device_id, account_id, icon, icon_asset_id, title, description, goal_count, mission_id, game_id, pack_id, game_level_id, game_object_id, score_all_instances, &context).await
    }

    /// Update Achievement Progress
    async fn update_user_achievement(
        &self,
        version: f64,
        account_id: i64,
        achievement_id: Option<i64>,
        tag: Option<String>,
        custom_id: Option<i64>,
        increment: Option<i64>,
        start_date: Option<i64>,
        end_date: Option<i64>,
        return_progress: Option<bool>,
        ) -> Result<UpdateUserAchievementResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().update_user_achievement(version, account_id, achievement_id, tag, custom_id, increment, start_date, end_date, return_progress, &context).await
    }

    /// Create an entity reference.
    async fn create_entity_reference(
        &self,
        version: f64,
        body: models::EntityReference,
        ) -> Result<CreateEntityReferenceResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().create_entity_reference(version, body, &context).await
    }

    /// Create Album
    async fn add_album_collection(
        &self,
        version: f64,
        title: String,
        cover_asset_nullable: bool,
        include_cover_in_asset_list: bool,
        public_read: bool,
        public_write: bool,
        public_delete: bool,
        public_add: bool,
        anonymous: bool,
        device_id: Option<String>,
        account_id: Option<i64>,
        assets_to_add: Option<String>,
        media: Option<swagger::ByteArray>,
        media_url: Option<String>,
        asset_id: Option<i64>,
        attached_media: Option<swagger::ByteArray>,
        attached_media_url: Option<String>,
        start_date: Option<i64>,
        end_date: Option<i64>,
        tags: Option<String>,
        description: Option<String>,
        album_type: Option<String>,
        album_type_id: Option<i64>,
        sub_type: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        location_description: Option<String>,
        visibility: Option<models::AddAlbumCollectionVisibilityParameter>,
        game_type: Option<String>,
        app_key: Option<String>,
        cell_phone: Option<String>,
        street_address: Option<String>,
        street_address2: Option<String>,
        city: Option<String>,
        state: Option<String>,
        postal_code: Option<String>,
        full_address: Option<String>,
        meta_data: Option<String>,
        category_ids: Option<String>,
        category_filter_ids: Option<String>,
        audience_ids: Option<String>,
        include_all_app_users_as_members: Option<bool>,
        include_audiences_as_members: Option<bool>,
        audience_operator: Option<String>,
        approval_status: Option<models::ApproveAlbumApprovalStatusParameter>,
        linked_object_type: Option<String>,
        linked_object_id: Option<i64>,
        ) -> Result<AddAlbumCollectionResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().add_album_collection(version, title, cover_asset_nullable, include_cover_in_asset_list, public_read, public_write, public_delete, public_add, anonymous, device_id, account_id, assets_to_add, media, media_url, asset_id, attached_media, attached_media_url, start_date, end_date, tags, description, album_type, album_type_id, sub_type, latitude, longitude, location_description, visibility, game_type, app_key, cell_phone, street_address, street_address2, city, state, postal_code, full_address, meta_data, category_ids, category_filter_ids, audience_ids, include_all_app_users_as_members, include_audiences_as_members, audience_operator, approval_status, linked_object_type, linked_object_id, &context).await
    }

    /// Add Album Users
    async fn add_album_users(
        &self,
        version: f64,
        album_id: i64,
        include_friend_group: bool,
        device_id: Option<String>,
        account_id: Option<i64>,
        read: Option<bool>,
        write: Option<bool>,
        delete: Option<bool>,
        add: Option<bool>,
        connections: Option<String>,
        connection_groups: Option<String>,
        ) -> Result<AddAlbumUsersResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().add_album_users(version, album_id, include_friend_group, device_id, account_id, read, write, delete, add, connections, connection_groups, &context).await
    }

    /// Approve Album
    async fn approve_album(
        &self,
        version: f64,
        album_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        approval_status: Option<models::ApproveAlbumApprovalStatusParameter>,
        verified: Option<bool>,
        ) -> Result<ApproveAlbumResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().approve_album(version, album_id, device_id, account_id, approval_status, verified, &context).await
    }

    ///  Get Album
    async fn get_album_collection(
        &self,
        version: f64,
        return_nulls: bool,
        album_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        like_preview_size: Option<i32>,
        asset_preview_size: Option<i32>,
        note_preview_size: Option<i32>,
        connection_preview_size: Option<i32>,
        audience_preview_size: Option<i32>,
        ) -> Result<GetAlbumCollectionResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_album_collection(version, return_nulls, album_id, device_id, account_id, like_preview_size, asset_preview_size, note_preview_size, connection_preview_size, audience_preview_size, &context).await
    }

    /// Leave Album
    async fn leave_album(
        &self,
        version: f64,
        album_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        ) -> Result<LeaveAlbumResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().leave_album(version, album_id, device_id, account_id, &context).await
    }

    /// Delete Album
    async fn remove_album(
        &self,
        version: f64,
        album_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        ) -> Result<RemoveAlbumResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().remove_album(version, album_id, device_id, account_id, &context).await
    }

    /// Remove Album Users
    async fn remove_album_users(
        &self,
        version: f64,
        album_id: i64,
        remove_friend_group: bool,
        device_id: Option<String>,
        account_id: Option<i64>,
        connections: Option<String>,
        connection_groups: Option<String>,
        ) -> Result<RemoveAlbumUsersResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().remove_album_users(version, album_id, remove_friend_group, device_id, account_id, connections, connection_groups, &context).await
    }

    /// Search Albums
    async fn search_albums(
        &self,
        version: f64,
        filter: String,
        album_type_id: i64,
        sub_type: String,
        include_inactive: bool,
        sort_field: String,
        descending: bool,
        start: i32,
        limit: i32,
        range: f64,
        include_liked: bool,
        include_favorited: bool,
        include_permissions: bool,
        like_preview_size: i32,
        asset_preview_size: i32,
        note_preview_size: i32,
        connection_preview_size: i32,
        audience_preview_size: i32,
        device_id: Option<String>,
        account_id: Option<i64>,
        connection_account_id: Option<i64>,
        owner_id: Option<i64>,
        album_ids: Option<String>,
        exclude_album_ids: Option<String>,
        media_id: Option<i64>,
        keyword: Option<String>,
        album_type: Option<String>,
        limit_per_album_type: Option<i32>,
        date_created: Option<i64>,
        updated_since: Option<i64>,
        updated_before: Option<i64>,
        created_since: Option<i64>,
        created_before: Option<i64>,
        started_since: Option<i64>,
        started_before: Option<i64>,
        ended_since: Option<i64>,
        ended_before: Option<i64>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        app_key: Option<String>,
        category_ids: Option<String>,
        category_filter_ids: Option<String>,
        audience_ids: Option<String>,
        exclude_audience_ids: Option<String>,
        include_completable: Option<bool>,
        include_rating: Option<bool>,
        search_mode: Option<String>,
        stack_search: Option<bool>,
        stack_window_size: Option<i32>,
        min_stack_per_page: Option<i32>,
        stack_pagination_identifier: Option<String>,
        stack_details: Option<bool>,
        flag_count_minimum: Option<i64>,
        remove_flagged_content: Option<bool>,
        verified_filter: Option<bool>,
        linked_object_type: Option<String>,
        linked_object_id: Option<i64>,
        order_audience_id: Option<i64>,
        ignore_default_app_filter: Option<bool>,
        search_expression: Option<String>,
        generate_albums: Option<bool>,
        ) -> Result<SearchAlbumsResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().search_albums(version, filter, album_type_id, sub_type, include_inactive, sort_field, descending, start, limit, range, include_liked, include_favorited, include_permissions, like_preview_size, asset_preview_size, note_preview_size, connection_preview_size, audience_preview_size, device_id, account_id, connection_account_id, owner_id, album_ids, exclude_album_ids, media_id, keyword, album_type, limit_per_album_type, date_created, updated_since, updated_before, created_since, created_before, started_since, started_before, ended_since, ended_before, latitude, longitude, app_key, category_ids, category_filter_ids, audience_ids, exclude_audience_ids, include_completable, include_rating, search_mode, stack_search, stack_window_size, min_stack_per_page, stack_pagination_identifier, stack_details, flag_count_minimum, remove_flagged_content, verified_filter, linked_object_type, linked_object_id, order_audience_id, ignore_default_app_filter, search_expression, generate_albums, &context).await
    }

    /// Update Album
    async fn update_album_collection(
        &self,
        version: f64,
        album_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        assets_to_add: Option<String>,
        assets_to_remove: Option<String>,
        asset_id: Option<i64>,
        media: Option<swagger::ByteArray>,
        media_url: Option<String>,
        active: Option<bool>,
        title: Option<String>,
        start_date: Option<i64>,
        end_date: Option<i64>,
        tags: Option<String>,
        description: Option<String>,
        album_type: Option<String>,
        album_type_id: Option<i64>,
        sub_type: Option<String>,
        public_read: Option<bool>,
        public_write: Option<bool>,
        public_delete: Option<bool>,
        public_add: Option<bool>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        location_description: Option<String>,
        visibility: Option<models::AddAlbumCollectionVisibilityParameter>,
        cell_phone: Option<String>,
        street_address: Option<String>,
        street_address2: Option<String>,
        city: Option<String>,
        state: Option<String>,
        postal_code: Option<String>,
        full_address: Option<String>,
        anonymous: Option<bool>,
        meta_data: Option<String>,
        category_ids: Option<String>,
        category_filter_ids: Option<String>,
        audience_ids: Option<String>,
        audience_ids_to_add: Option<String>,
        audience_ids_to_remove: Option<String>,
        include_all_app_users_as_members: Option<bool>,
        include_audiences_as_members: Option<bool>,
        audience_operator: Option<String>,
        linked_object_type: Option<String>,
        linked_object_id: Option<i64>,
        index_now: Option<bool>,
        ) -> Result<UpdateAlbumCollectionResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().update_album_collection(version, album_id, device_id, account_id, assets_to_add, assets_to_remove, asset_id, media, media_url, active, title, start_date, end_date, tags, description, album_type, album_type_id, sub_type, public_read, public_write, public_delete, public_add, latitude, longitude, location_description, visibility, cell_phone, street_address, street_address2, city, state, postal_code, full_address, anonymous, meta_data, category_ids, category_filter_ids, audience_ids, audience_ids_to_add, audience_ids_to_remove, include_all_app_users_as_members, include_audiences_as_members, audience_operator, linked_object_type, linked_object_id, index_now, &context).await
    }

    /// Get User Activity
    async fn activities(
        &self,
        version: f64,
        start: i32,
        limit: i32,
        account_id: i64,
        ) -> Result<ActivitiesResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().activities(version, start, limit, account_id, &context).await
    }

    /// Get Aggregated Filtered Usage
    async fn aggregated_filtered_usage(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        application_id: Option<i64>,
        app_key: Option<String>,
        start_date: Option<i64>,
        end_date: Option<i64>,
        device_type: Option<String>,
        device: Option<String>,
        device_os: Option<String>,
        gender: Option<String>,
        age_group: Option<String>,
        country: Option<String>,
        state: Option<String>,
        city: Option<String>,
        zip: Option<String>,
        model: Option<String>,
        tag: Option<String>,
        user_account_id: Option<i64>,
        user_account_display: Option<String>,
        user_account_username: Option<String>,
        group_by_root: Option<models::AggregatedFilteredUsageGroupByRootParameter>,
        group_by: Option<models::AggregatedFilteredUsageGroupByRootParameter>,
        distinct_count: Option<models::AggregatedFilteredUsageGroupByRootParameter>,
        sort_field: Option<models::AggregatedFilteredUsageGroupByRootParameter>,
        descending: Option<bool>,
        hide_unknown: Option<bool>,
        response_format: Option<models::AggregatedFilteredUsageResponseFormatParameter>,
        _l: Option<i32>,
        limit: Option<i32>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        ) -> Result<AggregatedFilteredUsageResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().aggregated_filtered_usage(version, device_id, account_id, application_id, app_key, start_date, end_date, device_type, device, device_os, gender, age_group, country, state, city, zip, model, tag, user_account_id, user_account_display, user_account_username, group_by_root, group_by, distinct_count, sort_field, descending, hide_unknown, response_format, _l, limit, latitude, longitude, &context).await
    }

    /// Get Filtered Usage
    async fn filtered_usage(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        application_id: Option<i64>,
        app_key: Option<String>,
        start_date: Option<i64>,
        end_date: Option<i64>,
        device_type: Option<String>,
        device: Option<String>,
        device_os: Option<String>,
        gender: Option<String>,
        age_group: Option<String>,
        country: Option<String>,
        state: Option<String>,
        city: Option<String>,
        zip: Option<String>,
        model: Option<String>,
        tag: Option<String>,
        user_account_id: Option<i64>,
        user_account_display: Option<String>,
        user_account_username: Option<String>,
        custom_id: Option<i64>,
        custom_type: Option<String>,
        custom_value: Option<f64>,
        custom_value2: Option<f64>,
        custom_long: Option<i64>,
        custom_long2: Option<i64>,
        custom_message: Option<String>,
        custom_message2: Option<String>,
        group_by: Option<models::AggregatedFilteredUsageGroupByRootParameter>,
        distinct_count: Option<models::AggregatedFilteredUsageGroupByRootParameter>,
        sum_column: Option<models::AggregatedFilteredUsageGroupByRootParameter>,
        sort_field: Option<models::AggregatedFilteredUsageGroupByRootParameter>,
        descending: Option<bool>,
        hide_unknown: Option<bool>,
        response_format: Option<models::AggregatedFilteredUsageResponseFormatParameter>,
        _l: Option<i32>,
        limit: Option<i32>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        ) -> Result<FilteredUsageResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().filtered_usage(version, device_id, account_id, application_id, app_key, start_date, end_date, device_type, device, device_os, gender, age_group, country, state, city, zip, model, tag, user_account_id, user_account_display, user_account_username, custom_id, custom_type, custom_value, custom_value2, custom_long, custom_long2, custom_message, custom_message2, group_by, distinct_count, sum_column, sort_field, descending, hide_unknown, response_format, _l, limit, latitude, longitude, &context).await
    }

    /// Create Usage Record
    async fn usage(
        &self,
        version: f64,
        tag: String,
        device_id: Option<String>,
        account_id: Option<i64>,
        application_id: Option<i64>,
        app_key: Option<String>,
        app_version: Option<String>,
        device: Option<String>,
        device_type: Option<String>,
        device_os: Option<String>,
        model: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        custom_id: Option<i64>,
        custom_type: Option<String>,
        achievement_increment: Option<i64>,
        city: Option<String>,
        state: Option<String>,
        country: Option<String>,
        zip: Option<String>,
        location_description: Option<String>,
        client_time: Option<i64>,
        error_message: Option<String>,
        ip: Option<String>,
        user_agent: Option<String>,
        background_event: Option<bool>,
        custom_message: Option<String>,
        custom_message2: Option<String>,
        custom_value: Option<f64>,
        custom_value2: Option<f64>,
        custom_long: Option<i64>,
        custom_long2: Option<i64>,
        ) -> Result<UsageResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().usage(version, tag, device_id, account_id, application_id, app_key, app_version, device, device_type, device_os, model, latitude, longitude, custom_id, custom_type, achievement_increment, city, state, country, zip, location_description, client_time, error_message, ip, user_agent, background_event, custom_message, custom_message2, custom_value, custom_value2, custom_long, custom_long2, &context).await
    }

    /// Create Multiple Usage Records
    async fn usage_batch(
        &self,
        version: f64,
        app_key: String,
        device: String,
        data: String,
        device_id: Option<String>,
        account_id: Option<i64>,
        app_version: Option<String>,
        device_type: Option<String>,
        device_os: Option<String>,
        model: Option<String>,
        update_ranking: Option<bool>,
        return_summary_response: Option<bool>,
        ) -> Result<UsageBatchResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().usage_batch(version, app_key, device, data, device_id, account_id, app_version, device_type, device_os, model, update_ranking, return_summary_response, &context).await
    }

    /// Get App Data
    async fn get_app_data(
        &self,
        version: f64,
        start: i32,
        limit: i32,
        device_id: Option<String>,
        account_id: Option<i64>,
        game_type: Option<String>,
        include_game_data: Option<bool>,
        q: Option<String>,
        keyword: Option<String>,
        sort_field: Option<String>,
        descending: Option<bool>,
        _i: Option<i32>,
        _l: Option<i32>,
        game_object_count: Option<bool>,
        filter: Option<String>,
        date_created: Option<i64>,
        owner_id: Option<i64>,
        mission_ids: Option<String>,
        game_ids: Option<String>,
        pack_ids: Option<String>,
        game_level_ids: Option<String>,
        app_version: Option<String>,
        include_higher_version_packs: Option<bool>,
        include_higher_version_levels: Option<bool>,
        response_groups: Option<String>,
        purchase_type: Option<String>,
        ) -> Result<GetAppDataResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_app_data(version, start, limit, device_id, account_id, game_type, include_game_data, q, keyword, sort_field, descending, _i, _l, game_object_count, filter, date_created, owner_id, mission_ids, game_ids, pack_ids, game_level_ids, app_version, include_higher_version_packs, include_higher_version_levels, response_groups, purchase_type, &context).await
    }

    /// Create App Data
    async fn post_app_data(
        &self,
        version: f64,
        game_type: String,
        start: i32,
        limit: i32,
        data: String,
        device_id: Option<String>,
        account_id: Option<i64>,
        include_game_data: Option<bool>,
        q: Option<String>,
        keyword: Option<String>,
        sort_field: Option<String>,
        descending: Option<bool>,
        _i: Option<i32>,
        _l: Option<i32>,
        game_object_count: Option<bool>,
        filter: Option<String>,
        date_created: Option<i64>,
        owner_id: Option<i64>,
        mission_ids: Option<String>,
        game_ids: Option<String>,
        pack_ids: Option<String>,
        game_level_ids: Option<String>,
        app_version: Option<String>,
        include_higher_version_packs: Option<bool>,
        include_higher_version_levels: Option<bool>,
        response_groups: Option<String>,
        purchase_type: Option<String>,
        ) -> Result<PostAppDataResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().post_app_data(version, game_type, start, limit, data, device_id, account_id, include_game_data, q, keyword, sort_field, descending, _i, _l, game_object_count, filter, date_created, owner_id, mission_ids, game_ids, pack_ids, game_level_ids, app_version, include_higher_version_packs, include_higher_version_levels, response_groups, purchase_type, &context).await
    }

    /// Regenerate App Data
    async fn regen_app_data(
        &self,
        version: f64,
        account_id: Option<i64>,
        app_key: Option<String>,
        build_version: Option<String>,
        api_version: Option<String>,
        ) -> Result<RegenAppDataResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().regen_app_data(version, account_id, app_key, build_version, api_version, &context).await
    }

    /// Create Application
    async fn create_application(
        &self,
        version: f64,
        app_name: String,
        device_id: Option<String>,
        account_id: Option<i64>,
        about: Option<String>,
        bundle_id: Option<String>,
        app_icon_asset_id: Option<i64>,
        app_logo_asset_id: Option<i64>,
        facebook_app_id: Option<String>,
        facebook_app_secret: Option<String>,
        google_api_key: Option<String>,
        update_eula_date: Option<bool>,
        eula_version: Option<String>,
        landing_page_url: Option<String>,
        show_in_activities: Option<bool>,
        activity_description: Option<String>,
        invite_welcome_text: Option<String>,
        invite_page_url: Option<String>,
        url_scheme: Option<String>,
        platforms: Option<String>,
        download_urls: Option<String>,
        category_ids: Option<String>,
        scoring_type: Option<models::CreateApplicationScoringTypeParameter>,
        hint_cost: Option<i32>,
        max_score: Option<i32>,
        tickets_per_point: Option<f32>,
        has_game_data: Option<bool>,
        public_notifications: Option<bool>,
        use_matching_algorithm: Option<bool>,
        global_tickets: Option<bool>,
        build_version: Option<f32>,
        api_version: Option<f32>,
        placement_name: Option<String>,
        placement_description: Option<String>,
        placement_size: Option<models::CreateApplicationPlacementSizeParameter>,
        placement_height: Option<i32>,
        placement_width: Option<i32>,
        placement_refresh_interval: Option<i32>,
        create_object_store: Option<bool>,
        public_content_approval: Option<bool>,
        production_mode: Option<bool>,
        minimum_session_length: Option<i32>,
        session_gap_length: Option<i32>,
        local_ads_enabled: Option<bool>,
        sqoot_api_key: Option<String>,
        trilat_processing_type: Option<models::CreateApplicationTrilatProcessingTypeParameter>,
        max_sample_size: Option<i32>,
        min_rssi: Option<f64>,
        modules: Option<String>,
        authorized_count: Option<i32>,
        authorized_servers: Option<String>,
        default_timezone: Option<String>,
        smtp_pass: Option<String>,
        meta_data: Option<String>,
        placement_meta_data: Option<String>,
        ips_floor: Option<bool>,
        enable_apns_badge: Option<bool>,
        include_in_report: Option<bool>,
        default_app_filter_id: Option<i64>,
        enable_welcome_email: Option<bool>,
        apple_app_id: Option<String>,
        apple_team_id: Option<String>,
        apple_auth_key_id: Option<String>,
        apple_auth_key: Option<swagger::ByteArray>,
        apple_issuer_id: Option<String>,
        app_store_key_id: Option<String>,
        app_store_key: Option<swagger::ByteArray>,
        google_private_key_file: Option<swagger::ByteArray>,
        authorize_net_api_key: Option<String>,
        authorize_net_transaction_key: Option<String>,
        email_sender: Option<String>,
        smtp_user: Option<String>,
        smtp_host: Option<String>,
        vatom_business_id: Option<String>,
        vatom_rest_client_id: Option<String>,
        vatom_rest_secret_key: Option<String>,
        twilio_account_sid: Option<String>,
        twilio_auth_token: Option<String>,
        twilio_sender_phone_number: Option<String>,
        open_ai_secret_key: Option<String>,
        ) -> Result<CreateApplicationResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().create_application(version, app_name, device_id, account_id, about, bundle_id, app_icon_asset_id, app_logo_asset_id, facebook_app_id, facebook_app_secret, google_api_key, update_eula_date, eula_version, landing_page_url, show_in_activities, activity_description, invite_welcome_text, invite_page_url, url_scheme, platforms, download_urls, category_ids, scoring_type, hint_cost, max_score, tickets_per_point, has_game_data, public_notifications, use_matching_algorithm, global_tickets, build_version, api_version, placement_name, placement_description, placement_size, placement_height, placement_width, placement_refresh_interval, create_object_store, public_content_approval, production_mode, minimum_session_length, session_gap_length, local_ads_enabled, sqoot_api_key, trilat_processing_type, max_sample_size, min_rssi, modules, authorized_count, authorized_servers, default_timezone, smtp_pass, meta_data, placement_meta_data, ips_floor, enable_apns_badge, include_in_report, default_app_filter_id, enable_welcome_email, apple_app_id, apple_team_id, apple_auth_key_id, apple_auth_key, apple_issuer_id, app_store_key_id, app_store_key, google_private_key_file, authorize_net_api_key, authorize_net_transaction_key, email_sender, smtp_user, smtp_host, vatom_business_id, vatom_rest_client_id, vatom_rest_secret_key, twilio_account_sid, twilio_auth_token, twilio_sender_phone_number, open_ai_secret_key, &context).await
    }

    /// Create Ad Placement
    async fn create_application_placement(
        &self,
        version: f64,
        app_key: String,
        size: models::CreateApplicationPlacementSizeParameter,
        device_id: Option<String>,
        account_id: Option<i64>,
        name: Option<String>,
        description: Option<String>,
        height: Option<i32>,
        width: Option<i32>,
        refresh_interval: Option<i32>,
        default_image_id: Option<i64>,
        active: Option<bool>,
        ) -> Result<CreateApplicationPlacementResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().create_application_placement(version, app_key, size, device_id, account_id, name, description, height, width, refresh_interval, default_image_id, active, &context).await
    }

    /// Delete Application
    async fn delete_application(
        &self,
        version: f64,
        account_id: Option<i64>,
        app_key: Option<String>,
        ) -> Result<DeleteApplicationResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().delete_application(version, account_id, app_key, &context).await
    }

    /// Delete Ad Placement
    async fn delete_application_placement(
        &self,
        version: f64,
        placement_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        ) -> Result<DeleteApplicationPlacementResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().delete_application_placement(version, placement_id, device_id, account_id, &context).await
    }

    /// Get Application
    async fn get_application(
        &self,
        version: f64,
        app_key: Option<String>,
        application_id: Option<i64>,
        ) -> Result<GetApplicationResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_application(version, app_key, application_id, &context).await
    }

    /// Get Ad Placement
    async fn get_application_placement(
        &self,
        version: f64,
        placement_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        ) -> Result<GetApplicationPlacementResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_application_placement(version, placement_id, device_id, account_id, &context).await
    }

    /// Get API versions
    async fn get_application_versions(
        &self,
        version: f64,
        ) -> Result<GetApplicationVersionsResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_application_versions(version, &context).await
    }

    /// Search Application Users
    async fn get_unique_users_by_app(
        &self,
        version: f64,
        app_key: String,
        q: Option<String>,
        keyword: Option<String>,
        since: Option<i64>,
        _i: Option<i32>,
        start: Option<i32>,
        _l: Option<i32>,
        limit: Option<i32>,
        ) -> Result<GetUniqueUsersByAppResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_unique_users_by_app(version, app_key, q, keyword, since, _i, start, _l, limit, &context).await
    }

    /// List Applications
    async fn list_applications(
        &self,
        version: f64,
        account_id: Option<i64>,
        q: Option<String>,
        keyword: Option<String>,
        platforms: Option<String>,
        device_ids: Option<String>,
        device_versions: Option<String>,
        category_ids: Option<String>,
        sort_field: Option<models::ListApplicationsSortFieldParameter>,
        has_ads: Option<bool>,
        public_notifications: Option<bool>,
        filter_billable: Option<bool>,
        filter_content_admin: Option<bool>,
        descending: Option<bool>,
        _i: Option<i32>,
        start: Option<i32>,
        _l: Option<i32>,
        limit: Option<i32>,
        application_ids: Option<String>,
        has_object_store: Option<bool>,
        active_only: Option<bool>,
        ) -> Result<ListApplicationsResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().list_applications(version, account_id, q, keyword, platforms, device_ids, device_versions, category_ids, sort_field, has_ads, public_notifications, filter_billable, filter_content_admin, descending, _i, start, _l, limit, application_ids, has_object_store, active_only, &context).await
    }

    /// Search for Ad Placements
    async fn search_application_placement(
        &self,
        version: f64,
        app_key: String,
        device_id: Option<String>,
        account_id: Option<i64>,
        start: Option<i32>,
        limit: Option<i32>,
        ) -> Result<SearchApplicationPlacementResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().search_application_placement(version, app_key, device_id, account_id, start, limit, &context).await
    }

    /// Search for Application Settings
    async fn search_application_settings(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        connection_account_id: Option<i64>,
        keyword: Option<String>,
        sort_field: Option<String>,
        descending: Option<bool>,
        start: Option<i32>,
        limit: Option<i32>,
        ) -> Result<SearchApplicationSettingsResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().search_application_settings(version, device_id, account_id, connection_account_id, keyword, sort_field, descending, start, limit, &context).await
    }

    /// Search Applications
    async fn search_applications(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        q: Option<String>,
        keyword: Option<String>,
        q_search_fields: Option<String>,
        sort_field: Option<models::SearchApplicationsSortFieldParameter>,
        descending: Option<bool>,
        _i: Option<i32>,
        start: Option<i32>,
        _l: Option<i32>,
        limit: Option<i32>,
        has_ads: Option<bool>,
        public_notifications: Option<bool>,
        active_only: Option<bool>,
        ) -> Result<SearchApplicationsResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().search_applications(version, device_id, account_id, latitude, longitude, q, keyword, q_search_fields, sort_field, descending, _i, start, _l, limit, has_ads, public_notifications, active_only, &context).await
    }

    /// Update Application
    async fn update_application(
        &self,
        version: f64,
        app_key: String,
        app_name: String,
        device_id: Option<String>,
        account_id: Option<i64>,
        about: Option<String>,
        bundle_id: Option<String>,
        app_icon_asset_id: Option<i64>,
        app_logo_asset_id: Option<i64>,
        facebook_app_id: Option<String>,
        facebook_app_secret: Option<String>,
        google_api_key: Option<String>,
        update_eula_date: Option<bool>,
        eula_version: Option<String>,
        landing_page_url: Option<String>,
        show_in_activities: Option<bool>,
        activity_description: Option<String>,
        invite_welcome_text: Option<String>,
        invite_page_url: Option<String>,
        url_scheme: Option<String>,
        platforms: Option<String>,
        download_urls: Option<String>,
        category_ids: Option<String>,
        scoring_type: Option<models::CreateApplicationScoringTypeParameter>,
        hint_cost: Option<i32>,
        max_score: Option<i32>,
        tickets_per_point: Option<f32>,
        has_game_data: Option<bool>,
        public_notifications: Option<bool>,
        use_matching_algorithm: Option<bool>,
        global_tickets: Option<bool>,
        build_version: Option<f32>,
        api_version: Option<f32>,
        placement_name: Option<String>,
        placement_description: Option<String>,
        placement_size: Option<models::CreateApplicationPlacementSizeParameter>,
        placement_height: Option<i32>,
        placement_width: Option<i32>,
        placement_refresh_interval: Option<i32>,
        create_object_store: Option<bool>,
        public_content_approval: Option<bool>,
        production_mode: Option<bool>,
        minimum_session_length: Option<i32>,
        session_gap_length: Option<i32>,
        local_ads_enabled: Option<bool>,
        sqoot_api_key: Option<String>,
        trilat_processing_type: Option<models::CreateApplicationTrilatProcessingTypeParameter>,
        max_sample_size: Option<i32>,
        min_rssi: Option<f64>,
        modules: Option<String>,
        authorized_count: Option<i32>,
        authorized_servers: Option<String>,
        default_timezone: Option<String>,
        smtp_pass: Option<String>,
        meta_data: Option<String>,
        placement_meta_data: Option<String>,
        ips_floor: Option<bool>,
        enable_apns_badge: Option<bool>,
        include_in_report: Option<bool>,
        default_app_filter_id: Option<i64>,
        enable_welcome_email: Option<bool>,
        apple_app_id: Option<String>,
        apple_team_id: Option<String>,
        apple_auth_key_id: Option<String>,
        apple_auth_key: Option<swagger::ByteArray>,
        apple_issuer_id: Option<String>,
        app_store_key_id: Option<String>,
        app_store_key: Option<swagger::ByteArray>,
        google_private_key_file: Option<swagger::ByteArray>,
        authorize_net_api_key: Option<String>,
        authorize_net_transaction_key: Option<String>,
        email_sender: Option<String>,
        smtp_user: Option<String>,
        smtp_host: Option<String>,
        vatom_business_id: Option<String>,
        vatom_rest_client_id: Option<String>,
        vatom_rest_secret_key: Option<String>,
        twilio_account_sid: Option<String>,
        twilio_auth_token: Option<String>,
        twilio_sender_phone_number: Option<String>,
        open_ai_secret_key: Option<String>,
        ) -> Result<UpdateApplicationResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().update_application(version, app_key, app_name, device_id, account_id, about, bundle_id, app_icon_asset_id, app_logo_asset_id, facebook_app_id, facebook_app_secret, google_api_key, update_eula_date, eula_version, landing_page_url, show_in_activities, activity_description, invite_welcome_text, invite_page_url, url_scheme, platforms, download_urls, category_ids, scoring_type, hint_cost, max_score, tickets_per_point, has_game_data, public_notifications, use_matching_algorithm, global_tickets, build_version, api_version, placement_name, placement_description, placement_size, placement_height, placement_width, placement_refresh_interval, create_object_store, public_content_approval, production_mode, minimum_session_length, session_gap_length, local_ads_enabled, sqoot_api_key, trilat_processing_type, max_sample_size, min_rssi, modules, authorized_count, authorized_servers, default_timezone, smtp_pass, meta_data, placement_meta_data, ips_floor, enable_apns_badge, include_in_report, default_app_filter_id, enable_welcome_email, apple_app_id, apple_team_id, apple_auth_key_id, apple_auth_key, apple_issuer_id, app_store_key_id, app_store_key, google_private_key_file, authorize_net_api_key, authorize_net_transaction_key, email_sender, smtp_user, smtp_host, vatom_business_id, vatom_rest_client_id, vatom_rest_secret_key, twilio_account_sid, twilio_auth_token, twilio_sender_phone_number, open_ai_secret_key, &context).await
    }

    /// Change Appliation Status
    async fn update_application_active(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        active: bool,
        ) -> Result<UpdateApplicationActiveResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().update_application_active(version, account_id, app_key, active, &context).await
    }

    /// Update Ad Placement
    async fn update_application_placement(
        &self,
        version: f64,
        placement_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        name: Option<String>,
        description: Option<String>,
        size: Option<models::CreateApplicationPlacementSizeParameter>,
        height: Option<i32>,
        width: Option<i32>,
        refresh_interval: Option<i32>,
        default_image_id: Option<i64>,
        active: Option<bool>,
        ) -> Result<UpdateApplicationPlacementResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().update_application_placement(version, placement_id, device_id, account_id, name, description, size, height, width, refresh_interval, default_image_id, active, &context).await
    }

    /// Create Application Certificate
    async fn upload_application_certificate(
        &self,
        version: f64,
        app_key: String,
        device_id: Option<String>,
        account_id: Option<i64>,
        certificate: Option<swagger::ByteArray>,
        ) -> Result<UploadApplicationCertificateResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().upload_application_certificate(version, app_key, device_id, account_id, certificate, &context).await
    }

    /// Create AppConfig
    async fn create_application_config(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        config_version: String,
        asset_id: i64,
        retailer_id: Option<i64>,
        retailer_location_id: Option<i64>,
        udid: Option<String>,
        ) -> Result<CreateApplicationConfigResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().create_application_config(version, account_id, app_key, config_version, asset_id, retailer_id, retailer_location_id, udid, &context).await
    }

    /// Delete AppConfig
    async fn delete_application_config(
        &self,
        version: f64,
        account_id: i64,
        config_id: i64,
        ) -> Result<DeleteApplicationConfigResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().delete_application_config(version, account_id, config_id, &context).await
    }

    /// Get AppConfig
    async fn get_application_config(
        &self,
        version: f64,
        account_id: i64,
        config_id: i64,
        ) -> Result<GetApplicationConfigResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_application_config(version, account_id, config_id, &context).await
    }

    /// Get AppConfig by Version
    async fn get_application_config_by_config_version(
        &self,
        version: f64,
        app_key: String,
        config_version: String,
        retailer_id: Option<i64>,
        retailer_location_id: Option<i64>,
        udid: Option<String>,
        allow_older_versions: Option<bool>,
        ) -> Result<GetApplicationConfigByConfigVersionResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_application_config_by_config_version(version, app_key, config_version, retailer_id, retailer_location_id, udid, allow_older_versions, &context).await
    }

    /// Search AppConfigs
    async fn search_application_config(
        &self,
        version: f64,
        account_id: i64,
        app_key: Option<String>,
        retailer_id: Option<i64>,
        retailer_location_id: Option<i64>,
        udid: Option<String>,
        config_version: Option<String>,
        sort_field: Option<String>,
        descending: Option<bool>,
        start: Option<i32>,
        limit: Option<i32>,
        ) -> Result<SearchApplicationConfigResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().search_application_config(version, account_id, app_key, retailer_id, retailer_location_id, udid, config_version, sort_field, descending, start, limit, &context).await
    }

    /// Update AppConfig
    async fn update_application_config(
        &self,
        version: f64,
        account_id: i64,
        config_id: i64,
        app_key: Option<String>,
        config_version: Option<String>,
        asset_id: Option<i64>,
        retailer_id: Option<i64>,
        retailer_location_id: Option<i64>,
        udid: Option<String>,
        ) -> Result<UpdateApplicationConfigResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().update_application_config(version, account_id, config_id, app_key, config_version, asset_id, retailer_id, retailer_location_id, udid, &context).await
    }

    /// Convert Offer to Creative
    async fn asset_morph(
        &self,
        version: f64,
        offer_id: i64,
        ad_size: models::CreateApplicationPlacementSizeParameter,
        creative_id: Option<i64>,
        width: Option<i32>,
        height: Option<i32>,
        background_size: Option<String>,
        template: Option<String>,
        ) -> Result<AssetMorphResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().asset_morph(version, offer_id, ad_size, creative_id, width, height, background_size, template, &context).await
    }

    /// Create Asset
    async fn create_asset(
        &self,
        version: f64,
        return_nulls: Option<bool>,
        device_id: Option<String>,
        account_id: Option<i64>,
        album_id: Option<i64>,
        collection_id: Option<i64>,
        add_to_default_album: Option<String>,
        add_to_media_library: Option<bool>,
        version_code: Option<i32>,
        version_name: Option<String>,
        meta_data: Option<String>,
        caption: Option<String>,
        asset_type: Option<String>,
        approval_status: Option<String>,
        assigned_account_id: Option<i64>,
        media: Option<swagger::ByteArray>,
        media_url: Option<String>,
        media_string: Option<String>,
        media_string_file_name: Option<String>,
        media_string_content_type: Option<String>,
        media_height: Option<i32>,
        media_width: Option<i32>,
        attached_media: Option<swagger::ByteArray>,
        attached_media_url: Option<String>,
        attached_media_string: Option<String>,
        attached_media_string_file_name: Option<String>,
        attached_media_string_content_type: Option<String>,
        attached_media_height: Option<i32>,
        attached_media_width: Option<i32>,
        location_description: Option<String>,
        app: Option<String>,
        app_key: Option<String>,
        search_tags: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        ) -> Result<CreateAssetResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().create_asset(version, return_nulls, device_id, account_id, album_id, collection_id, add_to_default_album, add_to_media_library, version_code, version_name, meta_data, caption, asset_type, approval_status, assigned_account_id, media, media_url, media_string, media_string_file_name, media_string_content_type, media_height, media_width, attached_media, attached_media_url, attached_media_string, attached_media_string_file_name, attached_media_string_content_type, attached_media_height, attached_media_width, location_description, app, app_key, search_tags, latitude, longitude, &context).await
    }

    /// Delete Asset
    async fn delete_asset(
        &self,
        version: f64,
        asset_id: String,
        device_id: Option<String>,
        account_id: Option<i64>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        ) -> Result<DeleteAssetResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().delete_asset(version, asset_id, device_id, account_id, latitude, longitude, &context).await
    }

    /// Get Asset
    async fn get_asset(
        &self,
        version: f64,
        asset_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        note_descending: Option<bool>,
        ) -> Result<GetAssetResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_asset(version, asset_id, device_id, account_id, note_descending, &context).await
    }

    /// Remove Asset from Collection
    async fn remove_asset(
        &self,
        version: f64,
        asset_id: String,
        device_id: Option<String>,
        account_id: Option<i64>,
        album_id: Option<i64>,
        collection_id: Option<i64>,
        remove_from_default_albums: Option<bool>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        ) -> Result<RemoveAssetResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().remove_asset(version, asset_id, device_id, account_id, album_id, collection_id, remove_from_default_albums, latitude, longitude, &context).await
    }

    /// Search Assets
    async fn search_assets(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        album_ids: Option<String>,
        asset_ids: Option<String>,
        app_key: Option<String>,
        media_type: Option<String>,
        mime_type: Option<String>,
        keyword: Option<String>,
        version_code: Option<i32>,
        version_name: Option<String>,
        updated_since: Option<i64>,
        updated_before: Option<i64>,
        sort_field: Option<String>,
        descending: Option<bool>,
        search_media_library: Option<bool>,
        filter_by_billable: Option<bool>,
        active_only: Option<bool>,
        return_app: Option<bool>,
        start: Option<i32>,
        limit: Option<i32>,
        search_mode: Option<String>,
        asset_type: Option<String>,
        approval_status: Option<String>,
        assigned_account_id: Option<i64>,
        ) -> Result<SearchAssetsResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().search_assets(version, device_id, account_id, album_ids, asset_ids, app_key, media_type, mime_type, keyword, version_code, version_name, updated_since, updated_before, sort_field, descending, search_media_library, filter_by_billable, active_only, return_app, start, limit, search_mode, asset_type, approval_status, assigned_account_id, &context).await
    }

    /// Update Asset
    async fn update_asset(
        &self,
        version: f64,
        asset_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        album_id: Option<i64>,
        attached_asset_id: Option<i64>,
        version_code: Option<i32>,
        version_name: Option<String>,
        meta_data: Option<String>,
        caption: Option<String>,
        asset_type: Option<String>,
        approval_status: Option<String>,
        assigned_account_id: Option<i64>,
        media: Option<swagger::ByteArray>,
        media_url: Option<String>,
        media_string: Option<String>,
        media_string_file_name: Option<String>,
        media_string_content_type: Option<String>,
        media_height: Option<i32>,
        media_width: Option<i32>,
        attached_media: Option<swagger::ByteArray>,
        attached_media_url: Option<String>,
        attached_media_string: Option<String>,
        attached_media_string_file_name: Option<String>,
        attached_media_string_content_type: Option<String>,
        attached_media_height: Option<i32>,
        attached_media_width: Option<i32>,
        location_description: Option<String>,
        search_tags: Option<String>,
        app_key: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        ) -> Result<UpdateAssetResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().update_asset(version, asset_id, device_id, account_id, album_id, attached_asset_id, version_code, version_name, meta_data, caption, asset_type, approval_status, assigned_account_id, media, media_url, media_string, media_string_file_name, media_string_content_type, media_height, media_width, attached_media, attached_media_url, attached_media_string, attached_media_string_file_name, attached_media_string_content_type, attached_media_height, attached_media_width, location_description, search_tags, app_key, latitude, longitude, &context).await
    }

    /// Download Asset
    async fn asset_download(
        &self,
        version: f64,
        filename: String,
        ) -> Result<AssetDownloadResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().asset_download(version, filename, &context).await
    }

    /// Search Assignment Assignees
    async fn assigment_assignee_account_search(
        &self,
        version: f64,
        account_id: i64,
        keyword: Option<String>,
        ) -> Result<AssigmentAssigneeAccountSearchResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().assigment_assignee_account_search(version, account_id, keyword, &context).await
    }

    /// Create Assignment
    async fn assignment_create(
        &self,
        version: f64,
        account_id: i64,
        name: String,
        assignee_account_id: i64,
        description: Option<String>,
        retailer_location_id: Option<i64>,
        tags: Option<String>,
        active: Option<bool>,
        ) -> Result<AssignmentCreateResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().assignment_create(version, account_id, name, assignee_account_id, description, retailer_location_id, tags, active, &context).await
    }

    /// Delete Assignment
    async fn assignment_delete(
        &self,
        version: f64,
        account_id: i64,
        assignment_id: i64,
        ) -> Result<AssignmentDeleteResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().assignment_delete(version, account_id, assignment_id, &context).await
    }

    /// Get Assignment
    async fn assignment_get(
        &self,
        version: f64,
        account_id: i64,
        assignment_id: i64,
        ) -> Result<AssignmentGetResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().assignment_get(version, account_id, assignment_id, &context).await
    }

    /// Search Assignments
    async fn assignment_search(
        &self,
        version: f64,
        account_id: i64,
        sort_field: models::AssignmentSearchSortFieldParameter,
        descending: bool,
        active_only: bool,
        start: i32,
        limit: i32,
        creator_account_id: Option<i64>,
        assignee_account_ids: Option<String>,
        retailer_location_ids: Option<String>,
        current_status_type: Option<models::AssignmentSearchCurrentStatusTypeParameter>,
        keyword: Option<String>,
        ) -> Result<AssignmentSearchResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().assignment_search(version, account_id, sort_field, descending, active_only, start, limit, creator_account_id, assignee_account_ids, retailer_location_ids, current_status_type, keyword, &context).await
    }

    /// Create Assignment Status
    async fn assignment_status_create(
        &self,
        version: f64,
        account_id: i64,
        assignment_id: i64,
        scheduled_notification_id: Option<i64>,
        to_do: Option<models::AssignmentStatusCreateToDoParameter>,
        connection: Option<models::AssignmentStatusCreateConnectionParameter>,
        method: Option<models::AssignmentStatusCreateMethodParameter>,
        status: Option<models::AssignmentStatusCreateStatusParameter>,
        closure: Option<models::AssignmentStatusCreateClosureParameter>,
        message: Option<String>,
        follow_up: Option<i64>,
        active: Option<bool>,
        ) -> Result<AssignmentStatusCreateResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().assignment_status_create(version, account_id, assignment_id, scheduled_notification_id, to_do, connection, method, status, closure, message, follow_up, active, &context).await
    }

    /// Deletes Assignment Status
    async fn assignment_status_delete(
        &self,
        version: f64,
        account_id: i64,
        assignment_status_id: i64,
        ) -> Result<AssignmentStatusDeleteResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().assignment_status_delete(version, account_id, assignment_status_id, &context).await
    }

    /// Get Assignment Status
    async fn assignment_status_get(
        &self,
        version: f64,
        account_id: i64,
        assignment_status_id: i64,
        ) -> Result<AssignmentStatusGetResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().assignment_status_get(version, account_id, assignment_status_id, &context).await
    }

    /// Search Assignment Statuses
    async fn assignment_status_search(
        &self,
        version: f64,
        account_id: i64,
        sort_field: models::AssignmentStatusSearchSortFieldParameter,
        descending: bool,
        active_only: bool,
        start: i32,
        limit: i32,
        assignment_id: Option<i64>,
        creator_account_id: Option<i64>,
        assignee_account_id: Option<i64>,
        retailer_location_id: Option<i64>,
        status_type: Option<models::AssignmentStatusCreateStatusParameter>,
        keyword: Option<String>,
        ) -> Result<AssignmentStatusSearchResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().assignment_status_search(version, account_id, sort_field, descending, active_only, start, limit, assignment_id, creator_account_id, assignee_account_id, retailer_location_id, status_type, keyword, &context).await
    }

    /// Update Assignment Status
    async fn assignment_status_update(
        &self,
        version: f64,
        account_id: i64,
        assignment_status_id: i64,
        scheduled_notification_id: Option<i64>,
        to_do: Option<models::AssignmentStatusCreateToDoParameter>,
        connection: Option<models::AssignmentStatusCreateConnectionParameter>,
        method: Option<models::AssignmentStatusCreateMethodParameter>,
        status: Option<models::AssignmentStatusCreateStatusParameter>,
        closure: Option<models::AssignmentStatusCreateClosureParameter>,
        message: Option<String>,
        follow_up: Option<i64>,
        active: Option<bool>,
        ) -> Result<AssignmentStatusUpdateResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().assignment_status_update(version, account_id, assignment_status_id, scheduled_notification_id, to_do, connection, method, status, closure, message, follow_up, active, &context).await
    }

    /// Update Assignment
    async fn assignment_update(
        &self,
        version: f64,
        account_id: i64,
        assignment_id: i64,
        name: Option<String>,
        description: Option<String>,
        assignee_account_id: Option<i64>,
        retailer_location_id: Option<i64>,
        tags: Option<String>,
        active: Option<bool>,
        ) -> Result<AssignmentUpdateResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().assignment_update(version, account_id, assignment_id, name, description, assignee_account_id, retailer_location_id, tags, active, &context).await
    }

    /// Create Audience
    async fn create_audience(
        &self,
        version: f64,
        account_id: i64,
        name: String,
        description: Option<String>,
        search_tags: Option<String>,
        gender: Option<String>,
        age_groups: Option<String>,
        category_ids: Option<String>,
        application_ids: Option<String>,
        game_experience_level: Option<String>,
        devices: Option<String>,
        device_ids: Option<String>,
        device_versions: Option<String>,
        locations: Option<String>,
        radius: Option<String>,
        start_time_offset: Option<i32>,
        end_time_offset: Option<i32>,
        send_suggestion: Option<bool>,
        associate_description: Option<String>,
        associate_type: Option<String>,
        associate_id: Option<i64>,
        grouping_id: Option<String>,
        meta_data: Option<String>,
        visibility: Option<String>,
        audience_type: Option<String>,
        use_order: Option<bool>,
        cohort_regions_data: Option<String>,
        app_key: Option<String>,
        trilateration_types: Option<String>,
        unique_name: Option<bool>,
        ) -> Result<CreateAudienceResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().create_audience(version, account_id, name, description, search_tags, gender, age_groups, category_ids, application_ids, game_experience_level, devices, device_ids, device_versions, locations, radius, start_time_offset, end_time_offset, send_suggestion, associate_description, associate_type, associate_id, grouping_id, meta_data, visibility, audience_type, use_order, cohort_regions_data, app_key, trilateration_types, unique_name, &context).await
    }

    /// Delete Audience
    async fn delete_audience(
        &self,
        version: f64,
        account_id: i64,
        audience_id: i64,
        ) -> Result<DeleteAudienceResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().delete_audience(version, account_id, audience_id, &context).await
    }

    /// Get Age Groups
    async fn get_age_groups(
        &self,
        version: f64,
        ) -> Result<GetAgeGroupsResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_age_groups(version, &context).await
    }

    /// Get Audience
    async fn get_audience(
        &self,
        version: f64,
        account_id: i64,
        audience_id: i64,
        app_key: Option<String>,
        return_account_count: Option<bool>,
        return_album_count: Option<bool>,
        album_types_for_count: Option<String>,
        ) -> Result<GetAudienceResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_audience(version, account_id, audience_id, app_key, return_account_count, return_album_count, album_types_for_count, &context).await
    }

    /// Search Audiences
    async fn get_audience_list(
        &self,
        version: f64,
        account_id: Option<i64>,
        album_ids: Option<String>,
        keyword: Option<String>,
        keyword_fields: Option<String>,
        sort_field: Option<models::GetAudienceListSortFieldParameter>,
        descending: Option<bool>,
        start: Option<i32>,
        limit: Option<i32>,
        send_suggestion: Option<bool>,
        active_only: Option<bool>,
        group_by_grouping_id: Option<bool>,
        app_key: Option<String>,
        return_global: Option<bool>,
        exact_keyword: Option<bool>,
        audience_type: Option<String>,
        audience_types: Option<String>,
        return_account_count: Option<bool>,
        return_album_count: Option<bool>,
        album_types_for_count: Option<String>,
        ) -> Result<GetAudienceListResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_audience_list(version, account_id, album_ids, keyword, keyword_fields, sort_field, descending, start, limit, send_suggestion, active_only, group_by_grouping_id, app_key, return_global, exact_keyword, audience_type, audience_types, return_account_count, return_album_count, album_types_for_count, &context).await
    }

    /// Get Devices
    async fn get_devices(
        &self,
        version: f64,
        include_inactive: bool,
        ) -> Result<GetDevicesResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_devices(version, include_inactive, &context).await
    }

    /// Get Experiences
    async fn get_experiences(
        &self,
        version: f64,
        ) -> Result<GetExperiencesResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_experiences(version, &context).await
    }

    /// Get GroupedAudiences
    async fn get_grouped_audiences(
        &self,
        version: f64,
        account_id: i64,
        audience_grouping_id: String,
        ) -> Result<GetGroupedAudiencesResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_grouped_audiences(version, account_id, audience_grouping_id, &context).await
    }

    /// List Suggestions by Audience
    async fn list_by_account(
        &self,
        version: f64,
        account_id: i64,
        limit: i32,
        suggestion_type: String,
        ) -> Result<ListByAccountResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().list_by_account(version, account_id, limit, suggestion_type, &context).await
    }

    /// List Offers by Audience
    async fn list_by_audience(
        &self,
        version: f64,
        limit: i32,
        gender: Option<String>,
        age: Option<i32>,
        category_ids: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        ) -> Result<ListByAudienceResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().list_by_audience(version, limit, gender, age, category_ids, latitude, longitude, &context).await
    }

    /// List Sent Suggestions 
    async fn list_lastest_by_account(
        &self,
        version: f64,
        account_id: i64,
        timeframe: i32,
        suggestion_type: String,
        ) -> Result<ListLastestByAccountResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().list_lastest_by_account(version, account_id, timeframe, suggestion_type, &context).await
    }

    /// Send Suggestions
    async fn send_by_account(
        &self,
        version: f64,
        account_id: i64,
        latitude: f64,
        longitude: f64,
        ) -> Result<SendByAccountResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().send_by_account(version, account_id, latitude, longitude, &context).await
    }

    /// Update Audience
    async fn update_audience(
        &self,
        version: f64,
        account_id: i64,
        audience_id: i64,
        name: Option<String>,
        description: Option<String>,
        search_tags: Option<String>,
        gender: Option<String>,
        age_groups: Option<String>,
        category_ids: Option<String>,
        application_ids: Option<String>,
        game_experience_level: Option<String>,
        devices: Option<String>,
        device_ids: Option<String>,
        device_versions: Option<String>,
        locations: Option<String>,
        radius: Option<String>,
        active: Option<bool>,
        send_suggestion: Option<bool>,
        start_time_offset: Option<i32>,
        end_time_offset: Option<i32>,
        associate_description: Option<String>,
        associate_type: Option<String>,
        associate_id: Option<i64>,
        grouping_id: Option<String>,
        meta_data: Option<String>,
        visibility: Option<String>,
        audience_type: Option<String>,
        use_order: Option<bool>,
        cohort_regions_data: Option<String>,
        app_key: Option<String>,
        trilateration_types: Option<String>,
        unique_name: Option<bool>,
        ) -> Result<UpdateAudienceResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().update_audience(version, account_id, audience_id, name, description, search_tags, gender, age_groups, category_ids, application_ids, game_experience_level, devices, device_ids, device_versions, locations, radius, active, send_suggestion, start_time_offset, end_time_offset, associate_description, associate_type, associate_id, grouping_id, meta_data, visibility, audience_type, use_order, cohort_regions_data, app_key, trilateration_types, unique_name, &context).await
    }

    /// Create Bid
    async fn create_bid(
        &self,
        version: f64,
        biddable_type: String,
        biddable_id: i64,
        amount_per_view: f64,
        amount_per_action: f64,
        budget_amount: f64,
        budget_schedule: String,
        device_id: Option<String>,
        account_id: Option<i64>,
        ) -> Result<CreateBidResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().create_bid(version, biddable_type, biddable_id, amount_per_view, amount_per_action, budget_amount, budget_schedule, device_id, account_id, &context).await
    }

    /// Delete Bid
    async fn delete_bid(
        &self,
        version: f64,
        bid_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        ) -> Result<DeleteBidResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().delete_bid(version, bid_id, device_id, account_id, &context).await
    }

    /// Get Bid
    async fn get_bid(
        &self,
        version: f64,
        bid_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        ) -> Result<GetBidResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_bid(version, bid_id, device_id, account_id, &context).await
    }

    /// Update Bid
    async fn update_bid(
        &self,
        version: f64,
        bid_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        amount_per_view: Option<f64>,
        amount_per_action: Option<f64>,
        budget_amount: Option<f64>,
        budget_schedule: Option<String>,
        ) -> Result<UpdateBidResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().update_bid(version, bid_id, device_id, account_id, amount_per_view, amount_per_action, budget_amount, budget_schedule, &context).await
    }

    /// Create Billable
    async fn create_billable_entity(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        name: Option<String>,
        street_address: Option<String>,
        street_address2: Option<String>,
        city: Option<String>,
        state: Option<String>,
        postal_code: Option<String>,
        business_phone: Option<String>,
        business_phone_ext: Option<String>,
        authorize_net_api_key: Option<String>,
        authorize_net_transaction_key: Option<String>,
        ) -> Result<CreateBillableEntityResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().create_billable_entity(version, device_id, account_id, name, street_address, street_address2, city, state, postal_code, business_phone, business_phone_ext, authorize_net_api_key, authorize_net_transaction_key, &context).await
    }

    /// Delete Billable
    async fn delete_billable_entity(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        ) -> Result<DeleteBillableEntityResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().delete_billable_entity(version, device_id, account_id, &context).await
    }

    /// Get Billable
    async fn get_billable_entity(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        include_counts: Option<bool>,
        include_payments: Option<bool>,
        ) -> Result<GetBillableEntityResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_billable_entity(version, device_id, account_id, include_counts, include_payments, &context).await
    }

    /// Update Billable
    async fn update_billable_entity(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        name: Option<String>,
        street_address: Option<String>,
        street_address2: Option<String>,
        city: Option<String>,
        state: Option<String>,
        postal_code: Option<String>,
        business_phone: Option<String>,
        business_phone_ext: Option<String>,
        authorize_net_api_key: Option<String>,
        authorize_net_transaction_key: Option<String>,
        ) -> Result<UpdateBillableEntityResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().update_billable_entity(version, device_id, account_id, name, street_address, street_address2, city, state, postal_code, business_phone, business_phone_ext, authorize_net_api_key, authorize_net_transaction_key, &context).await
    }

    /// Update Payment Method
    async fn add_payment_method(
        &self,
        version: f64,
        account_id: i64,
        payment_method_id: Option<i64>,
        account_name: Option<String>,
        first_name: Option<String>,
        last_name: Option<String>,
        address: Option<String>,
        city: Option<String>,
        state: Option<String>,
        postal_code: Option<String>,
        country: Option<String>,
        phone: Option<String>,
        credit_card_number: Option<String>,
        expiration_date: Option<String>,
        ccv: Option<String>,
        account_number: Option<String>,
        bank_name: Option<String>,
        routing_number: Option<String>,
        default_payment_method: Option<bool>,
        payment_method_nickname: Option<String>,
        tax_id: Option<String>,
        provider_customer_profile_id: Option<String>,
        provider_payment_profile_id: Option<String>,
        meta_data: Option<String>,
        ) -> Result<AddPaymentMethodResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().add_payment_method(version, account_id, payment_method_id, account_name, first_name, last_name, address, city, state, postal_code, country, phone, credit_card_number, expiration_date, ccv, account_number, bank_name, routing_number, default_payment_method, payment_method_nickname, tax_id, provider_customer_profile_id, provider_payment_profile_id, meta_data, &context).await
    }

    /// Create Payment Method
    async fn create_payment_method(
        &self,
        version: f64,
        account_id: i64,
        account_name: Option<String>,
        first_name: Option<String>,
        last_name: Option<String>,
        address: Option<String>,
        city: Option<String>,
        state: Option<String>,
        postal_code: Option<String>,
        country: Option<String>,
        phone: Option<String>,
        credit_card_number: Option<String>,
        expiration_date: Option<String>,
        ccv: Option<String>,
        account_number: Option<String>,
        bank_name: Option<String>,
        routing_number: Option<String>,
        payment_method_nickname: Option<String>,
        tax_id: Option<String>,
        default_payment_method: Option<bool>,
        auth_token: Option<String>,
        provider: Option<String>,
        provider_customer_profile_id: Option<String>,
        provider_payment_profile_id: Option<String>,
        meta_data: Option<String>,
        app_key: Option<String>,
        ) -> Result<CreatePaymentMethodResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().create_payment_method(version, account_id, account_name, first_name, last_name, address, city, state, postal_code, country, phone, credit_card_number, expiration_date, ccv, account_number, bank_name, routing_number, payment_method_nickname, tax_id, default_payment_method, auth_token, provider, provider_customer_profile_id, provider_payment_profile_id, meta_data, app_key, &context).await
    }

    /// Create Smart Contract
    async fn create_smart_contract(
        &self,
        version: f64,
        account_id: i64,
        token_name: String,
        token_symbol: String,
        payment_method_id: Option<i64>,
        ) -> Result<CreateSmartContractResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().create_smart_contract(version, account_id, token_name, token_symbol, payment_method_id, &context).await
    }

    /// Get Crypto Balances
    async fn get_crypto_balance(
        &self,
        version: f64,
        account_id: i64,
        owner_account_id: Option<i64>,
        payment_method_id: Option<i64>,
        ) -> Result<GetCryptoBalanceResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_crypto_balance(version, account_id, owner_account_id, payment_method_id, &context).await
    }

    /// Get Payment Method
    async fn get_payment_method(
        &self,
        version: f64,
        account_id: i64,
        payment_method_id: Option<i64>,
        get_current_balance: Option<bool>,
        ) -> Result<GetPaymentMethodResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_payment_method(version, account_id, payment_method_id, get_current_balance, &context).await
    }

    /// Search Payment Methods
    async fn search_payment_method(
        &self,
        version: f64,
        account_id: i64,
        provider: Option<String>,
        param_type: Option<String>,
        keyword: Option<String>,
        sort_field: Option<String>,
        descending: Option<bool>,
        start: Option<i32>,
        limit: Option<i32>,
        ) -> Result<SearchPaymentMethodResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().search_payment_method(version, account_id, provider, param_type, keyword, sort_field, descending, start, limit, &context).await
    }

    /// Detail Status
    async fn get_status_csv(
        &self,
        version: f64,
        account_id: i64,
        batch_id: i64,
        response_group: models::GetStatusCsvResponseGroupParameter,
        start: i64,
        limit: i64,
        ) -> Result<GetStatusCsvResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_status_csv(version, account_id, batch_id, response_group, start, limit, &context).await
    }

    /// Search Status
    async fn list_status_csv(
        &self,
        version: f64,
        account_id: i64,
        start: i32,
        limit: i32,
        ) -> Result<ListStatusCsvResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().list_status_csv(version, account_id, start, limit, &context).await
    }

    /// Batch Status
    async fn status_csv(
        &self,
        version: f64,
        account_id: i64,
        batch_id: i64,
        ) -> Result<StatusCsvResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().status_csv(version, account_id, batch_id, &context).await
    }

    /// Upload CSV
    async fn upload_csv(
        &self,
        version: f64,
        account_id: i64,
        upload_type: models::UploadCsvUploadTypeParameter,
        import_file: swagger::ByteArray,
        file_format: models::UploadCsvFileFormatParameter,
        app_key: Option<String>,
        ) -> Result<UploadCsvResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().upload_csv(version, account_id, upload_type, import_file, file_format, app_key, &context).await
    }

    /// Create Cargo Type
    async fn create_cargo_type(
        &self,
        version: f64,
        body: Option<models::CargoType>,
        ) -> Result<CreateCargoTypeResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().create_cargo_type(version, body, &context).await
    }

    /// Search Cargo Type
    async fn search_cargo_types(
        &self,
        version: f64,
        sort_field: String,
        descending: bool,
        start: i32,
        limit: i32,
        active_only: bool,
        retailer_id: Option<i64>,
        hub_id: Option<i64>,
        ) -> Result<SearchCargoTypesResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().search_cargo_types(version, sort_field, descending, start, limit, active_only, retailer_id, hub_id, &context).await
    }

    /// Delete Cargo Type
    async fn delete_cargo_type(
        &self,
        version: f64,
        cargo_type_id: i64,
        ) -> Result<DeleteCargoTypeResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().delete_cargo_type(version, cargo_type_id, &context).await
    }

    /// Get Cargo Type
    async fn get_cargo_type(
        &self,
        version: f64,
        cargo_type_id: i64,
        ) -> Result<GetCargoTypeResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_cargo_type(version, cargo_type_id, &context).await
    }

    /// Update Cargo Type
    async fn update_cargo_type(
        &self,
        version: f64,
        cargo_type_id: i64,
        body: Option<models::CargoType>,
        ) -> Result<UpdateCargoTypeResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().update_cargo_type(version, cargo_type_id, body, &context).await
    }

    /// Search Carriers
    async fn search_carriers(
        &self,
        version: f64,
        keyword: Option<String>,
        descending: Option<bool>,
        start: Option<i32>,
        limit: Option<i32>,
        active_only: Option<bool>,
        ) -> Result<SearchCarriersResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().search_carriers(version, keyword, descending, start, limit, active_only, &context).await
    }

    /// Search Categories by Distance
    async fn category_distance_search(
        &self,
        version: f64,
        account_id: Option<i64>,
        keyword: Option<String>,
        app_key: Option<String>,
        category_ids: Option<String>,
        parent_category_ids: Option<String>,
        root_only: Option<bool>,
        sort_field: Option<models::SearchCategoriesSortFieldParameter>,
        response_group: Option<models::SearchCategoriesResponseGroupParameter>,
        descending: Option<bool>,
        start: Option<i32>,
        limit: Option<i32>,
        active_only: Option<bool>,
        return_external: Option<bool>,
        exact_match: Option<bool>,
        param_type: Option<String>,
        external_type: Option<String>,
        min_offer_count: Option<i32>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        range: Option<f64>,
        ) -> Result<CategoryDistanceSearchResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().category_distance_search(version, account_id, keyword, app_key, category_ids, parent_category_ids, root_only, sort_field, response_group, descending, start, limit, active_only, return_external, exact_match, param_type, external_type, min_offer_count, latitude, longitude, range, &context).await
    }

    /// Create Category
    async fn create_category(
        &self,
        version: f64,
        account_id: i64,
        name: String,
        app_key: Option<String>,
        parent_category_id: Option<i64>,
        description: Option<String>,
        param_type: Option<String>,
        asset_id: Option<i64>,
        external_id: Option<String>,
        external_type: Option<String>,
        external_category_slug: Option<String>,
        sqoot_slug: Option<String>,
        active: Option<bool>,
        meta_data: Option<String>,
        search_tags: Option<String>,
        ) -> Result<CreateCategoryResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().create_category(version, account_id, name, app_key, parent_category_id, description, param_type, asset_id, external_id, external_type, external_category_slug, sqoot_slug, active, meta_data, search_tags, &context).await
    }

    /// Delete Category
    async fn delete_category(
        &self,
        version: f64,
        account_id: i64,
        category_id: i64,
        ) -> Result<DeleteCategoryResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().delete_category(version, account_id, category_id, &context).await
    }

    /// Duplicate Category
    async fn duplicate_category(
        &self,
        version: f64,
        account_id: i64,
        category_id: i64,
        app_key: Option<String>,
        parent_category_id: Option<i64>,
        ) -> Result<DuplicateCategoryResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().duplicate_category(version, account_id, category_id, app_key, parent_category_id, &context).await
    }

    /// Get Category
    async fn get_category(
        &self,
        version: f64,
        category_id: i64,
        return_external: Option<bool>,
        ) -> Result<GetCategoryResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_category(version, category_id, return_external, &context).await
    }

    /// Search Categories
    async fn search_categories(
        &self,
        version: f64,
        account_id: Option<i64>,
        keyword: Option<String>,
        app_key: Option<String>,
        category_id: Option<String>,
        category_ids: Option<String>,
        parent_category_ids: Option<String>,
        root_only: Option<bool>,
        sort_field: Option<models::SearchCategoriesSortFieldParameter>,
        response_group: Option<models::SearchCategoriesResponseGroupParameter>,
        descending: Option<bool>,
        start: Option<i32>,
        limit: Option<i32>,
        active_only: Option<bool>,
        return_external: Option<bool>,
        exact_match: Option<bool>,
        param_type: Option<String>,
        external_type: Option<String>,
        exclude_external_type: Option<bool>,
        min_offer_count: Option<i32>,
        search_depth: Option<i32>,
        search_mode: Option<String>,
        ) -> Result<SearchCategoriesResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().search_categories(version, account_id, keyword, app_key, category_id, category_ids, parent_category_ids, root_only, sort_field, response_group, descending, start, limit, active_only, return_external, exact_match, param_type, external_type, exclude_external_type, min_offer_count, search_depth, search_mode, &context).await
    }

    /// Update Category
    async fn update_category(
        &self,
        version: f64,
        account_id: i64,
        category_id: i64,
        parent_category_id: Option<i64>,
        name: Option<String>,
        description: Option<String>,
        param_type: Option<String>,
        asset_id: Option<i64>,
        external_id: Option<String>,
        external_type: Option<String>,
        external_category_slug: Option<String>,
        sqoot_slug: Option<String>,
        active: Option<bool>,
        meta_data: Option<String>,
        search_tags: Option<String>,
        ) -> Result<UpdateCategoryResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().update_category(version, account_id, category_id, parent_category_id, name, description, param_type, asset_id, external_id, external_type, external_category_slug, sqoot_slug, active, meta_data, search_tags, &context).await
    }

    /// Add Connection
    async fn add_connection_to_group(
        &self,
        version: f64,
        return_nulls: bool,
        group_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        connection_id: Option<i64>,
        connection_account_id: Option<i64>,
        pending_id: Option<i64>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        ) -> Result<AddConnectionToGroupResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().add_connection_to_group(version, return_nulls, group_id, device_id, account_id, connection_id, connection_account_id, pending_id, latitude, longitude, &context).await
    }

    /// Add Connections
    async fn add_connections_to_group(
        &self,
        version: f64,
        connection_group_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        connection_ids: Option<String>,
        connection_account_ids: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        ) -> Result<AddConnectionsToGroupResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().add_connections_to_group(version, connection_group_id, device_id, account_id, connection_ids, connection_account_ids, latitude, longitude, &context).await
    }

    /// Add Connection Groups
    async fn add_sub_groups(
        &self,
        version: f64,
        return_nulls: bool,
        group_id: i64,
        sub_group_ids: String,
        device_id: Option<String>,
        account_id: Option<i64>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        ) -> Result<AddSubGroupsResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().add_sub_groups(version, return_nulls, group_id, sub_group_ids, device_id, account_id, latitude, longitude, &context).await
    }

    /// Create or Update Connection
    async fn create_or_update_connection(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        connection_id: Option<i64>,
        connection_account_id: Option<i64>,
        pending_id: Option<i64>,
        group_id: Option<i64>,
        game_type: Option<String>,
        app_key: Option<String>,
        is_trusted: Option<bool>,
        ignore_friend_request: Option<bool>,
        is_contact: Option<bool>,
        is_blocked: Option<bool>,
        is_following: Option<bool>,
        connection_response: Option<bool>,
        ) -> Result<CreateOrUpdateConnectionResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().create_or_update_connection(version, device_id, account_id, connection_id, connection_account_id, pending_id, group_id, game_type, app_key, is_trusted, ignore_friend_request, is_contact, is_blocked, is_following, connection_response, &context).await
    }

    /// Create or Update Connection Group
    async fn create_or_update_group(
        &self,
        version: f64,
        return_nulls: bool,
        device_id: Option<String>,
        account_id: Option<i64>,
        name: Option<String>,
        group_id: Option<i64>,
        asset_id: Option<i64>,
        connections: Option<String>,
        description: Option<String>,
        can_view_profile_info: Option<bool>,
        can_view_game_info: Option<bool>,
        can_view_friend_info: Option<bool>,
        active: Option<bool>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        ) -> Result<CreateOrUpdateGroupResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().create_or_update_group(version, return_nulls, device_id, account_id, name, group_id, asset_id, connections, description, can_view_profile_info, can_view_game_info, can_view_friend_info, active, latitude, longitude, &context).await
    }

    /// Accept Follow Request
    async fn follow_accept(
        &self,
        version: f64,
        account_id: i64,
        connection_account_id: i64,
        app_key: String,
        ) -> Result<FollowAcceptResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().follow_accept(version, account_id, connection_account_id, app_key, &context).await
    }

    /// Reject Follow Request
    async fn follow_reject(
        &self,
        version: f64,
        account_id: i64,
        connection_account_id: i64,
        app_key: String,
        ) -> Result<FollowRejectResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().follow_reject(version, account_id, connection_account_id, app_key, &context).await
    }

    /// Remove Follower / Unfollow
    async fn follow_remove(
        &self,
        version: f64,
        account_id: i64,
        connection_account_id: i64,
        app_key: String,
        ) -> Result<FollowRemoveResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().follow_remove(version, account_id, connection_account_id, app_key, &context).await
    }

    /// Send Follow Request
    async fn follow_request(
        &self,
        version: f64,
        account_id: i64,
        connection_account_id: i64,
        app_key: String,
        approval_needed: Option<bool>,
        ) -> Result<FollowRequestResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().follow_request(version, account_id, connection_account_id, app_key, approval_needed, &context).await
    }

    /// Accept Friend
    async fn friend_accept(
        &self,
        version: f64,
        friend_account_id: i64,
        notify_friend: bool,
        device_id: Option<String>,
        account_id: Option<i64>,
        game_type: Option<String>,
        app_key: Option<String>,
        notification_message: Option<String>,
        ) -> Result<FriendAcceptResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().friend_accept(version, friend_account_id, notify_friend, device_id, account_id, game_type, app_key, notification_message, &context).await
    }

    /// Decline Friend
    async fn friend_reject(
        &self,
        version: f64,
        friend_account_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        game_type: Option<String>,
        app_key: Option<String>,
        notify_friend: Option<bool>,
        notification_message: Option<String>,
        ) -> Result<FriendRejectResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().friend_reject(version, friend_account_id, device_id, account_id, game_type, app_key, notify_friend, notification_message, &context).await
    }

    /// Delete Friend
    async fn friend_remove(
        &self,
        version: f64,
        friend_account_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        notify_friend: Option<bool>,
        remove_from_groups: Option<bool>,
        ) -> Result<FriendRemoveResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().friend_remove(version, friend_account_id, device_id, account_id, notify_friend, remove_from_groups, &context).await
    }

    /// Request Friend
    async fn friend_request(
        &self,
        version: f64,
        friend_account_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        game_type: Option<String>,
        app_key: Option<String>,
        notification_message: Option<String>,
        ) -> Result<FriendRequestResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().friend_request(version, friend_account_id, device_id, account_id, game_type, app_key, notification_message, &context).await
    }

    /// Get Sent Friend Requests
    async fn get_connection_sent_friend_requests(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        ) -> Result<GetConnectionSentFriendRequestsResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_connection_sent_friend_requests(version, device_id, account_id, &context).await
    }

    /// Search Connections
    async fn get_connections(
        &self,
        version: f64,
        return_nulls: bool,
        filter: String,
        sort_field: String,
        descending: bool,
        start: i32,
        limit: i32,
        device_id: Option<String>,
        account_id: Option<i64>,
        connection_account_id: Option<i64>,
        q: Option<String>,
        keyword: Option<String>,
        _i: Option<i32>,
        _l: Option<i32>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        ) -> Result<GetConnectionsResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_connections(version, return_nulls, filter, sort_field, descending, start, limit, device_id, account_id, connection_account_id, q, keyword, _i, _l, latitude, longitude, &context).await
    }

    /// Get Connection Group
    async fn get_group_details(
        &self,
        version: f64,
        combine_connections: bool,
        device_id: Option<String>,
        account_id: Option<i64>,
        group_id: Option<i64>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        ) -> Result<GetGroupDetailsResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_group_details(version, combine_connections, device_id, account_id, group_id, latitude, longitude, &context).await
    }

    /// Search Connection Groups
    async fn group_search(
        &self,
        version: f64,
        sort_field: models::GroupSearchSortFieldParameter,
        descending: bool,
        active_only: bool,
        start: i32,
        limit: i32,
        device_id: Option<String>,
        account_id: Option<i64>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        keyword: Option<String>,
        ) -> Result<GroupSearchResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().group_search(version, sort_field, descending, active_only, start, limit, device_id, account_id, latitude, longitude, keyword, &context).await
    }

    /// Delete Connection
    async fn remove_connection_from_group(
        &self,
        version: f64,
        return_nulls: bool,
        group_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        connection_id: Option<i64>,
        connection_account_id: Option<i64>,
        pending_id: Option<i64>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        ) -> Result<RemoveConnectionFromGroupResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().remove_connection_from_group(version, return_nulls, group_id, device_id, account_id, connection_id, connection_account_id, pending_id, latitude, longitude, &context).await
    }

    /// Remove Connections
    async fn remove_connections_from_group(
        &self,
        version: f64,
        connection_group_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        connection_ids: Option<String>,
        connection_account_ids: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        ) -> Result<RemoveConnectionsFromGroupResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().remove_connections_from_group(version, connection_group_id, device_id, account_id, connection_ids, connection_account_ids, latitude, longitude, &context).await
    }

    /// Delete Connection Group
    async fn remove_group(
        &self,
        version: f64,
        return_nulls: bool,
        group_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        ) -> Result<RemoveGroupResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().remove_group(version, return_nulls, group_id, device_id, account_id, latitude, longitude, &context).await
    }

    /// Remove Connection Groups
    async fn remove_sub_groups(
        &self,
        version: f64,
        return_nulls: bool,
        group_id: i64,
        sub_group_ids: String,
        device_id: Option<String>,
        account_id: Option<i64>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        ) -> Result<RemoveSubGroupsResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().remove_sub_groups(version, return_nulls, group_id, sub_group_ids, device_id, account_id, latitude, longitude, &context).await
    }

    /// Search Possible Connections
    async fn search_connections(
        &self,
        version: f64,
        return_nulls: bool,
        start: i32,
        limit: i32,
        device_id: Option<String>,
        account_id: Option<i64>,
        q: Option<String>,
        keyword: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        game_type: Option<String>,
        app_key: Option<String>,
        _i: Option<i32>,
        _l: Option<i32>,
        sort_field: Option<String>,
        has_location: Option<bool>,
        ) -> Result<SearchConnectionsResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().search_connections(version, return_nulls, start, limit, device_id, account_id, q, keyword, latitude, longitude, game_type, app_key, _i, _l, sort_field, has_location, &context).await
    }

    /// Create or Update Contest
    async fn add_or_update_album_contest(
        &self,
        version: f64,
        public_read: bool,
        public_write: bool,
        public_delete: bool,
        public_add: bool,
        visibility: models::AddAlbumCollectionVisibilityParameter,
        include_friend_group: bool,
        device_id: Option<String>,
        account_id: Option<i64>,
        game_type: Option<String>,
        app_key: Option<String>,
        contest_type: Option<String>,
        album_contest_id: Option<i64>,
        title: Option<String>,
        description: Option<String>,
        album_id1: Option<i64>,
        remove_album1: Option<bool>,
        album_id2: Option<i64>,
        remove_album2: Option<bool>,
        start_date: Option<i64>,
        end_date: Option<i64>,
        location_description: Option<String>,
        connection_ids_to_add: Option<String>,
        connection_group_ids_to_add: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        ) -> Result<AddOrUpdateAlbumContestResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().add_or_update_album_contest(version, public_read, public_write, public_delete, public_add, visibility, include_friend_group, device_id, account_id, game_type, app_key, contest_type, album_contest_id, title, description, album_id1, remove_album1, album_id2, remove_album2, start_date, end_date, location_description, connection_ids_to_add, connection_group_ids_to_add, latitude, longitude, &context).await
    }

    /// Approve Contest
    async fn approve_album_contest(
        &self,
        version: f64,
        album_contest_id: i64,
        approval_status: models::ApproveAlbumApprovalStatusParameter,
        device_id: Option<String>,
        account_id: Option<i64>,
        ) -> Result<ApproveAlbumContestResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().approve_album_contest(version, album_contest_id, approval_status, device_id, account_id, &context).await
    }

    /// Delete Contest
    async fn delete_contest(
        &self,
        version: f64,
        album_contest_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        ) -> Result<DeleteContestResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().delete_contest(version, album_contest_id, device_id, account_id, latitude, longitude, &context).await
    }

    /// Get Contest
    async fn get_album_contest(
        &self,
        version: f64,
        album_contest_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        ) -> Result<GetAlbumContestResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_album_contest(version, album_contest_id, device_id, account_id, latitude, longitude, &context).await
    }

    /// Search Contests
    async fn get_album_contests(
        &self,
        version: f64,
        filter: String,
        sort_field: String,
        descending: bool,
        start: i32,
        limit: i32,
        device_id: Option<String>,
        account_id: Option<i64>,
        game_type: Option<String>,
        app_key: Option<String>,
        app_type: Option<String>,
        contest_type: Option<String>,
        owner_id: Option<i64>,
        q: Option<String>,
        keyword: Option<String>,
        _i: Option<i32>,
        _l: Option<i32>,
        date_created: Option<i64>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        ) -> Result<GetAlbumContestsResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_album_contests(version, filter, sort_field, descending, start, limit, device_id, account_id, game_type, app_key, app_type, contest_type, owner_id, q, keyword, _i, _l, date_created, latitude, longitude, &context).await
    }

    /// Vote on Contest
    async fn vote_on_album_contest(
        &self,
        version: f64,
        album_contest_id: i64,
        album_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        contest_type: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        ) -> Result<VoteOnAlbumContestResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().vote_on_album_contest(version, album_contest_id, album_id, device_id, account_id, contest_type, latitude, longitude, &context).await
    }

    /// Add Preview
    async fn add_preview(
        &self,
        version: f64,
        account_id: i64,
        creative_id: i64,
        ) -> Result<AddPreviewResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().add_preview(version, account_id, creative_id, &context).await
    }

    /// Find Missions
    async fn ads_find(
        &self,
        version: f64,
        app_key: String,
        randomize: bool,
        targeted_ads_only: bool,
        param_type: Option<String>,
        account_id: Option<i64>,
        app_version: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        device: Option<String>,
        device_identifier: Option<i64>,
        device_version: Option<String>,
        start: Option<i32>,
        limit: Option<i32>,
        include_audiences: Option<bool>,
        allocates_tickets: Option<bool>,
        mission_ids: Option<String>,
        ) -> Result<AdsFindResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().ads_find(version, app_key, randomize, targeted_ads_only, param_type, account_id, app_version, latitude, longitude, device, device_identifier, device_version, start, limit, include_audiences, allocates_tickets, mission_ids, &context).await
    }

    /// Create Creative
    async fn create_creative(
        &self,
        version: f64,
        account_id: i64,
        name: String,
        active: bool,
        wait_for_asset: bool,
        description: Option<String>,
        asset_image_id: Option<i64>,
        action: Option<String>,
        data: Option<String>,
        suffix: Option<String>,
        param_type: Option<String>,
        balance: Option<f64>,
        reference_id: Option<i64>,
        app_version: Option<String>,
        mission_id: Option<i64>,
        offer_id: Option<i64>,
        ) -> Result<CreateCreativeResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().create_creative(version, account_id, name, active, wait_for_asset, description, asset_image_id, action, data, suffix, param_type, balance, reference_id, app_version, mission_id, offer_id, &context).await
    }

    /// Delete Creative
    async fn delete_creative(
        &self,
        version: f64,
        account_id: i64,
        creative_id: i64,
        ) -> Result<DeleteCreativeResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().delete_creative(version, account_id, creative_id, &context).await
    }

    /// Get Creative
    async fn get_creative(
        &self,
        version: f64,
        account_id: i64,
        creative_id: i64,
        ) -> Result<GetCreativeResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_creative(version, account_id, creative_id, &context).await
    }

    /// Search Creatives
    async fn get_creatives_by_application(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        start: i32,
        limit: i32,
        mission_id: Option<i64>,
        keyword: Option<String>,
        ) -> Result<GetCreativesByApplicationResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_creatives_by_application(version, account_id, app_key, start, limit, mission_id, keyword, &context).await
    }

    /// Remove Preview
    async fn remove_preview(
        &self,
        version: f64,
        account_id: i64,
        creative_id: i64,
        ) -> Result<RemovePreviewResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().remove_preview(version, account_id, creative_id, &context).await
    }

    /// Update Creative
    async fn update_creative(
        &self,
        version: f64,
        account_id: i64,
        creative_id: i64,
        name: Option<String>,
        description: Option<String>,
        asset_image_id: Option<i64>,
        action: Option<String>,
        data: Option<String>,
        suffix: Option<String>,
        param_type: Option<String>,
        balance: Option<f64>,
        active: Option<bool>,
        reference_id: Option<i64>,
        app_version: Option<String>,
        mission_id: Option<i64>,
        ) -> Result<UpdateCreativeResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().update_creative(version, account_id, creative_id, name, description, asset_image_id, action, data, suffix, param_type, balance, active, reference_id, app_version, mission_id, &context).await
    }

    /// Create Dependent
    async fn create(
        &self,
        version: f64,
        account_id: i64,
        body: Option<models::Account>,
        ) -> Result<CreateResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().create(version, account_id, body, &context).await
    }

    /// Get dependent list of an account
    async fn get_dependents(
        &self,
        version: f64,
        account_id: i64,
        ) -> Result<GetDependentsResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_dependents(version, account_id, &context).await
    }

    /// Delete Dependent
    async fn remove_dependent(
        &self,
        version: f64,
        account_id: i64,
        dependent_id: i64,
        ) -> Result<RemoveDependentResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().remove_dependent(version, account_id, dependent_id, &context).await
    }

    /// Check Disbursements
    async fn check_disbursements(
        &self,
        version: f64,
        disbursement_id: i64,
        ) -> Result<CheckDisbursementsResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().check_disbursements(version, disbursement_id, &context).await
    }

    /// Create Disbursement
    async fn create_disbursement(
        &self,
        version: f64,
        account_id: i64,
        receiver_account_id: i64,
        original_sender_account_id: i64,
        amount: f64,
        provider: models::CreateDisbursementProviderParameter,
        scheduled_date: Option<i64>,
        title: Option<String>,
        comment: Option<String>,
        external_id: Option<String>,
        introspection_params: Option<String>,
        ) -> Result<CreateDisbursementResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().create_disbursement(version, account_id, receiver_account_id, original_sender_account_id, amount, provider, scheduled_date, title, comment, external_id, introspection_params, &context).await
    }

    /// Get Disbursement
    async fn get_disbursement(
        &self,
        version: f64,
        account_id: i64,
        disbursement_id: i64,
        ) -> Result<GetDisbursementResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_disbursement(version, account_id, disbursement_id, &context).await
    }

    /// Search Disbursements
    async fn search_disbursements(
        &self,
        version: f64,
        account_id: i64,
        receiver_account_id: Option<i64>,
        statuses: Option<String>,
        providers: Option<String>,
        before_date: Option<i64>,
        after_date: Option<i64>,
        start: Option<i32>,
        limit: Option<i32>,
        active_only: Option<bool>,
        external_id: Option<String>,
        ) -> Result<SearchDisbursementsResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().search_disbursements(version, account_id, receiver_account_id, statuses, providers, before_date, after_date, start, limit, active_only, external_id, &context).await
    }

    /// Update Disbursement
    async fn update_disbursement(
        &self,
        version: f64,
        account_id: i64,
        disbursement_id: i64,
        amount: Option<f64>,
        provider: Option<models::CreateDisbursementProviderParameter>,
        scheduled_date: Option<i64>,
        title: Option<String>,
        comment: Option<String>,
        external_id: Option<String>,
        retry: Option<bool>,
        introspection_params: Option<String>,
        ) -> Result<UpdateDisbursementResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().update_disbursement(version, account_id, disbursement_id, amount, provider, scheduled_date, title, comment, external_id, retry, introspection_params, &context).await
    }

    /// Assign Employee
    async fn assign_employee(
        &self,
        version: f64,
        account_id: i64,
        manager_account_id: i64,
        employee_account_id: i64,
        role: Option<String>,
        ) -> Result<AssignEmployeeResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().assign_employee(version, account_id, manager_account_id, employee_account_id, role, &context).await
    }

    /// Assign Employee to Location
    async fn assign_to_location_employee(
        &self,
        version: f64,
        account_id: i64,
        retailer_location_id: i64,
        employee_account_id: Option<i64>,
        assign: Option<bool>,
        ) -> Result<AssignToLocationEmployeeResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().assign_to_location_employee(version, account_id, retailer_location_id, employee_account_id, assign, &context).await
    }

    /// Create Employee
    async fn create_employee(
        &self,
        version: f64,
        account_id: i64,
        manager_account_id: i64,
        username: String,
        password: String,
        name: Option<String>,
        prefix_name: Option<String>,
        first_name: Option<String>,
        middle_name: Option<String>,
        last_name: Option<String>,
        suffix_name: Option<String>,
        title: Option<String>,
        about_us: Option<String>,
        asset_id: Option<i64>,
        gender: Option<models::SearchAccountsGenderParameter>,
        home_phone: Option<String>,
        cell_phone: Option<String>,
        cell_phone_carrier: Option<String>,
        business_phone: Option<String>,
        email_address: Option<String>,
        street_address: Option<String>,
        street_address2: Option<String>,
        city: Option<String>,
        state: Option<String>,
        zipcode: Option<String>,
        country: Option<String>,
        role: Option<String>,
        retailer_location_ids: Option<String>,
        settings_app_key: Option<String>,
        app_blob: Option<String>,
        assigned_device_id: Option<String>,
        ) -> Result<CreateEmployeeResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().create_employee(version, account_id, manager_account_id, username, password, name, prefix_name, first_name, middle_name, last_name, suffix_name, title, about_us, asset_id, gender, home_phone, cell_phone, cell_phone_carrier, business_phone, email_address, street_address, street_address2, city, state, zipcode, country, role, retailer_location_ids, settings_app_key, app_blob, assigned_device_id, &context).await
    }

    /// Delete Employee
    async fn delete_employee(
        &self,
        version: f64,
        account_id: i64,
        employee_account_id: i64,
        ) -> Result<DeleteEmployeeResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().delete_employee(version, account_id, employee_account_id, &context).await
    }

    /// Get Employee
    async fn get_employee(
        &self,
        version: f64,
        account_id: i64,
        employee_account_id: i64,
        settings_app_key: Option<String>,
        ) -> Result<GetEmployeeResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_employee(version, account_id, employee_account_id, settings_app_key, &context).await
    }

    /// Search Employees
    async fn search_employees(
        &self,
        version: f64,
        account_id: i64,
        role: Option<String>,
        retailer_id: Option<i64>,
        retailer_location_id: Option<i64>,
        q: Option<String>,
        keyword: Option<String>,
        sort_field: Option<models::SearchEmployeesSortFieldParameter>,
        descending: Option<bool>,
        _i: Option<i32>,
        start: Option<i32>,
        _l: Option<i32>,
        limit: Option<i32>,
        active_only: Option<bool>,
        managed_only: Option<bool>,
        settings_app_key: Option<String>,
        category_ids: Option<String>,
        query: Option<String>,
        ) -> Result<SearchEmployeesResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().search_employees(version, account_id, role, retailer_id, retailer_location_id, q, keyword, sort_field, descending, _i, start, _l, limit, active_only, managed_only, settings_app_key, category_ids, query, &context).await
    }

    /// Unassign Employee
    async fn unassign_employee(
        &self,
        version: f64,
        account_id: i64,
        employee_account_id: i64,
        ) -> Result<UnassignEmployeeResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().unassign_employee(version, account_id, employee_account_id, &context).await
    }

    /// Update Employee
    async fn update_employee(
        &self,
        version: f64,
        account_id: i64,
        employee_account_id: i64,
        manager_account_id: Option<i64>,
        name: Option<String>,
        prefix_name: Option<String>,
        first_name: Option<String>,
        middle_name: Option<String>,
        last_name: Option<String>,
        suffix_name: Option<String>,
        title: Option<String>,
        asset_id: Option<i64>,
        gender: Option<models::SearchAccountsGenderParameter>,
        home_phone: Option<String>,
        cell_phone: Option<String>,
        cell_phone_carrier: Option<String>,
        business_phone: Option<String>,
        email_address: Option<String>,
        street_address: Option<String>,
        street_address2: Option<String>,
        city: Option<String>,
        state: Option<String>,
        zipcode: Option<String>,
        country: Option<String>,
        role: Option<String>,
        active: Option<bool>,
        password: Option<String>,
        retailer_location_ids: Option<String>,
        settings_app_key: Option<String>,
        app_blob: Option<String>,
        assigned_device_id: Option<String>,
        ) -> Result<UpdateEmployeeResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().update_employee(version, account_id, employee_account_id, manager_account_id, name, prefix_name, first_name, middle_name, last_name, suffix_name, title, asset_id, gender, home_phone, cell_phone, cell_phone_carrier, business_phone, email_address, street_address, street_address2, city, state, zipcode, country, role, active, password, retailer_location_ids, settings_app_key, app_blob, assigned_device_id, &context).await
    }

    /// Attend Event
    async fn attend_event(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        app_key: Option<String>,
        listing_id: Option<i64>,
        retailer_location_id: Option<i64>,
        offer_location_id: Option<i64>,
        transaction_id: Option<i64>,
        status: Option<i32>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        ) -> Result<AttendEventResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().attend_event(version, device_id, account_id, app_key, listing_id, retailer_location_id, offer_location_id, transaction_id, status, latitude, longitude, &context).await
    }

    /// Create Event
    async fn create_event(
        &self,
        version: f64,
        account_id: i64,
        title: String,
        retailer_location_ids: Option<String>,
        sub_title: Option<String>,
        details: Option<String>,
        category_ids: Option<String>,
        filter_ids: Option<String>,
        active: Option<bool>,
        image_asset_id: Option<i64>,
        redeemable_start: Option<i64>,
        redeemable_end: Option<i64>,
        meta_data: Option<String>,
        ) -> Result<CreateEventResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().create_event(version, account_id, title, retailer_location_ids, sub_title, details, category_ids, filter_ids, active, image_asset_id, redeemable_start, redeemable_end, meta_data, &context).await
    }

    /// Delete Event
    async fn delete_event(
        &self,
        version: f64,
        account_id: i64,
        event_id: i64,
        ) -> Result<DeleteEventResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().delete_event(version, account_id, event_id, &context).await
    }

    /// Get Event
    async fn get_event(
        &self,
        version: f64,
        account_id: i64,
        event_id: i64,
        ) -> Result<GetEventResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_event(version, account_id, event_id, &context).await
    }

    /// Search Event Attendance
    async fn search_event_transactions(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        app_key: Option<String>,
        keyword: Option<String>,
        retailer_id: Option<i64>,
        retailer_location_id: Option<i64>,
        exclude_retailer_location_id: Option<i64>,
        listing_id: Option<i64>,
        offer_id: Option<i64>,
        offer_location_id: Option<i64>,
        customer_account_ids: Option<String>,
        affiliated_category_ids: Option<String>,
        start_date: Option<i64>,
        end_date: Option<i64>,
        statuses: Option<String>,
        sort_field: Option<models::SearchEventTransactionsSortFieldParameter>,
        descending: Option<bool>,
        start: Option<i32>,
        limit: Option<i32>,
        ) -> Result<SearchEventTransactionsResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().search_event_transactions(version, device_id, account_id, app_key, keyword, retailer_id, retailer_location_id, exclude_retailer_location_id, listing_id, offer_id, offer_location_id, customer_account_ids, affiliated_category_ids, start_date, end_date, statuses, sort_field, descending, start, limit, &context).await
    }

    /// Search Events
    async fn search_events(
        &self,
        version: f64,
        account_id: i64,
        keyword: Option<String>,
        active_only: Option<bool>,
        category_ids: Option<String>,
        filter_ids: Option<String>,
        offer_audience_ids: Option<String>,
        transaction_audience_ids: Option<String>,
        sort_field: Option<models::SearchEventsSortFieldParameter>,
        descending: Option<bool>,
        start_date: Option<i64>,
        end_date: Option<i64>,
        start: Option<i32>,
        limit: Option<i32>,
        ) -> Result<SearchEventsResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().search_events(version, account_id, keyword, active_only, category_ids, filter_ids, offer_audience_ids, transaction_audience_ids, sort_field, descending, start_date, end_date, start, limit, &context).await
    }

    /// Update Event
    async fn update_event(
        &self,
        version: f64,
        account_id: i64,
        event_id: i64,
        retailer_location_ids: Option<String>,
        title: Option<String>,
        sub_title: Option<String>,
        details: Option<String>,
        category_ids: Option<String>,
        filter_ids: Option<String>,
        active: Option<bool>,
        image_asset_id: Option<i64>,
        redeemable_start: Option<i64>,
        redeemable_end: Option<i64>,
        ) -> Result<UpdateEventResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().update_event(version, account_id, event_id, retailer_location_ids, title, sub_title, details, category_ids, filter_ids, active, image_asset_id, redeemable_start, redeemable_end, &context).await
    }

    /// Get Facebook Token
    async fn get_token(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        ) -> Result<GetTokenResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_token(version, device_id, account_id, latitude, longitude, &context).await
    }

    /// Post to Facebook
    async fn graph_interface(
        &self,
        version: f64,
        event: String,
        device_id: Option<String>,
        account_id: Option<i64>,
        permissionable_type: Option<String>,
        permissionable_id: Option<i64>,
        asset_id: Option<i64>,
        game_type: Option<String>,
        app_key: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        ) -> Result<GraphInterfaceResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().graph_interface(version, event, device_id, account_id, permissionable_type, permissionable_id, asset_id, game_type, app_key, latitude, longitude, &context).await
    }

    /// Create Favorite
    async fn add_favorite(
        &self,
        version: f64,
        favoritable_id: i64,
        favoritable_type: String,
        device_id: Option<String>,
        account_id: Option<i64>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        ) -> Result<AddFavoriteResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().add_favorite(version, favoritable_id, favoritable_type, device_id, account_id, latitude, longitude, &context).await
    }

    /// Delete Favorite
    async fn delete_favorite(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        favorite_id: Option<i64>,
        favoritable_id: Option<i64>,
        favoritable_type: Option<String>,
        ) -> Result<DeleteFavoriteResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().delete_favorite(version, device_id, account_id, favorite_id, favoritable_id, favoritable_type, &context).await
    }

    /// Get Favorite
    async fn get_favorite(
        &self,
        version: f64,
        favorite_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        ) -> Result<GetFavoriteResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_favorite(version, favorite_id, device_id, account_id, latitude, longitude, &context).await
    }

    /// Search Favorites
    async fn search_favorites(
        &self,
        version: f64,
        favoritable_type: String,
        sort_field: models::SearchFavoritesSortFieldParameter,
        descending: bool,
        start: i32,
        limit: i32,
        active_only: bool,
        return_full_response: bool,
        device_id: Option<String>,
        account_id: Option<i64>,
        connection_account_id: Option<i64>,
        secondary_type: Option<String>,
        keyword: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        ) -> Result<SearchFavoritesResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().search_favorites(version, favoritable_type, sort_field, descending, start, limit, active_only, return_full_response, device_id, account_id, connection_account_id, secondary_type, keyword, latitude, longitude, &context).await
    }

    /// Who has Favorited
    async fn who_has_favorited(
        &self,
        version: f64,
        favoritable_id: i64,
        favoritable_type: String,
        start: i32,
        limit: i32,
        device_id: Option<String>,
        account_id: Option<i64>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        keyword: Option<String>,
        ) -> Result<WhoHasFavoritedResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().who_has_favorited(version, favoritable_id, favoritable_type, start, limit, device_id, account_id, latitude, longitude, keyword, &context).await
    }

    /// Create Filter
    async fn create_filter(
        &self,
        version: f64,
        account_id: i64,
        name: String,
        app_key: Option<String>,
        parent_filter_id: Option<i64>,
        description: Option<String>,
        external_id: Option<String>,
        external_type: Option<String>,
        active: Option<bool>,
        meta_data: Option<String>,
        ) -> Result<CreateFilterResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().create_filter(version, account_id, name, app_key, parent_filter_id, description, external_id, external_type, active, meta_data, &context).await
    }

    /// Delete Filter
    async fn delete_filter(
        &self,
        version: f64,
        account_id: i64,
        filter_id: i64,
        ) -> Result<DeleteFilterResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().delete_filter(version, account_id, filter_id, &context).await
    }

    /// Get Filter
    async fn get_filter(
        &self,
        version: f64,
        filter_id: i64,
        ) -> Result<GetFilterResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_filter(version, filter_id, &context).await
    }

    /// Search Filters
    async fn search_filters(
        &self,
        version: f64,
        account_id: Option<i64>,
        keyword: Option<String>,
        app_key: Option<String>,
        response_group: Option<models::SearchCategoriesResponseGroupParameter>,
        root_only: Option<bool>,
        sort_field: Option<models::SearchCategoriesSortFieldParameter>,
        descending: Option<bool>,
        start: Option<i32>,
        limit: Option<i32>,
        active_only: Option<bool>,
        ) -> Result<SearchFiltersResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().search_filters(version, account_id, keyword, app_key, response_group, root_only, sort_field, descending, start, limit, active_only, &context).await
    }

    /// Update Filter
    async fn update_filter(
        &self,
        version: f64,
        account_id: i64,
        filter_id: i64,
        parent_filter_id: Option<i64>,
        name: Option<String>,
        description: Option<String>,
        external_id: Option<String>,
        external_type: Option<String>,
        active: Option<bool>,
        meta_data: Option<String>,
        ) -> Result<UpdateFilterResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().update_filter(version, account_id, filter_id, parent_filter_id, name, description, external_id, external_type, active, meta_data, &context).await
    }

    /// Create Flag
    async fn create_flag(
        &self,
        version: f64,
        flagable_type: String,
        flagable_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        flag_description: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        ) -> Result<CreateFlagResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().create_flag(version, flagable_type, flagable_id, device_id, account_id, flag_description, latitude, longitude, &context).await
    }

    /// Delete Flag
    async fn delete_flag(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        item_being_flagged_type: Option<String>,
        item_being_flagged_id: Option<i64>,
        flagable_type: Option<String>,
        flagable_id: Option<i64>,
        ) -> Result<DeleteFlagResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().delete_flag(version, device_id, account_id, item_being_flagged_type, item_being_flagged_id, flagable_type, flagable_id, &context).await
    }

    /// Get Flag
    async fn get_flag(
        &self,
        version: f64,
        flagable_type: String,
        flagable_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        ) -> Result<GetFlagResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_flag(version, flagable_type, flagable_id, device_id, account_id, latitude, longitude, &context).await
    }

    /// Get Flag Threshold
    async fn get_flag_threshold(
        &self,
        version: f64,
        item_being_flagged_type: String,
        app_key: String,
        ) -> Result<GetFlagThresholdResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_flag_threshold(version, item_being_flagged_type, app_key, &context).await
    }

    /// Update Flag Threshold
    async fn update_flag_threshold(
        &self,
        version: f64,
        item_being_flagged_type: String,
        threshold: i64,
        app_key: String,
        device_id: Option<String>,
        account_id: Option<i64>,
        ) -> Result<UpdateFlagThresholdResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().update_flag_threshold(version, item_being_flagged_type, threshold, app_key, device_id, account_id, &context).await
    }

    /// Create a Game
    async fn create_game(
        &self,
        version: f64,
        account_id: Option<i64>,
        app_key: Option<String>,
        title: Option<String>,
        description: Option<String>,
        meta_data: Option<String>,
        pack_ids: Option<String>,
        include_game_data: Option<bool>,
        ) -> Result<CreateGameResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().create_game(version, account_id, app_key, title, description, meta_data, pack_ids, include_game_data, &context).await
    }

    /// Delete a Game
    async fn delete_game(
        &self,
        version: f64,
        account_id: i64,
        game_id: i64,
        ) -> Result<DeleteGameResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().delete_game(version, account_id, game_id, &context).await
    }

    /// Get a Game by id
    async fn get_game(
        &self,
        version: f64,
        account_id: i64,
        game_id: i64,
        include_game_data: Option<bool>,
        ) -> Result<GetGameResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_game(version, account_id, game_id, include_game_data, &context).await
    }

    /// Search a Game
    async fn search_games(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        start: i32,
        limit: i32,
        keyword: Option<String>,
        app_version: Option<String>,
        include_game_data: Option<bool>,
        include_inactive: Option<bool>,
        ) -> Result<SearchGamesResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().search_games(version, account_id, app_key, start, limit, keyword, app_version, include_game_data, include_inactive, &context).await
    }

    /// Update a Game
    async fn update_game(
        &self,
        version: f64,
        account_id: Option<i64>,
        game_id: Option<i64>,
        app_key: Option<String>,
        title: Option<String>,
        description: Option<String>,
        meta_data: Option<String>,
        pack_ids: Option<String>,
        include_game_data: Option<bool>,
        ) -> Result<UpdateGameResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().update_game(version, account_id, game_id, app_key, title, description, meta_data, pack_ids, include_game_data, &context).await
    }

    /// Create Game Level
    async fn create_game_level(
        &self,
        version: f64,
        account_id: i64,
        name: String,
        game_data: String,
        game_data_suffix: String,
        app_key: Option<String>,
        description: Option<String>,
        difficulty: Option<String>,
        app_version: Option<String>,
        asset_image_id: Option<i64>,
        asset_icon_id: Option<i64>,
        visibility: Option<String>,
        friend_group: Option<bool>,
        connection_ids: Option<String>,
        connection_group_ids: Option<String>,
        balance: Option<f64>,
        active: Option<bool>,
        allocate_tickets: Option<bool>,
        ticket_count: Option<i64>,
        ticket_type: Option<String>,
        points: Option<i64>,
        tutorial_title: Option<String>,
        tutorial_message: Option<String>,
        tutorial_alignment: Option<String>,
        tutorial_image_asset_id: Option<i64>,
        offer_id: Option<i64>,
        meta_data: Option<String>,
        ) -> Result<CreateGameLevelResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().create_game_level(version, account_id, name, game_data, game_data_suffix, app_key, description, difficulty, app_version, asset_image_id, asset_icon_id, visibility, friend_group, connection_ids, connection_group_ids, balance, active, allocate_tickets, ticket_count, ticket_type, points, tutorial_title, tutorial_message, tutorial_alignment, tutorial_image_asset_id, offer_id, meta_data, &context).await
    }

    /// Delete Game Level
    async fn delete_game_level(
        &self,
        version: f64,
        account_id: i64,
        level_id: i64,
        ) -> Result<DeleteGameLevelResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().delete_game_level(version, account_id, level_id, &context).await
    }

    /// Get Game Level
    async fn get_game_level(
        &self,
        version: f64,
        account_id: i64,
        level_id: i64,
        include_game_data: Option<bool>,
        ) -> Result<GetGameLevelResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_game_level(version, account_id, level_id, include_game_data, &context).await
    }

    /// Search Game Levels
    async fn get_game_levels_by_application(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        keyword: Option<String>,
        sort_field: Option<String>,
        descending: Option<bool>,
        start: Option<i32>,
        limit: Option<i32>,
        app_version: Option<String>,
        include_game_data: Option<bool>,
        filters: Option<String>,
        ) -> Result<GetGameLevelsByApplicationResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_game_levels_by_application(version, account_id, app_key, keyword, sort_field, descending, start, limit, app_version, include_game_data, filters, &context).await
    }

    /// Search Game Level by Billable Entity
    async fn get_game_levels_by_billable_entity(
        &self,
        version: f64,
        account_id: i64,
        app_key: Option<String>,
        keyword: Option<String>,
        sort_field: Option<models::GetGameLevelsByBillableEntitySortFieldParameter>,
        descending: Option<bool>,
        active_only: Option<bool>,
        start: Option<i64>,
        limit: Option<i64>,
        ) -> Result<GetGameLevelsByBillableEntityResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_game_levels_by_billable_entity(version, account_id, app_key, keyword, sort_field, descending, active_only, start, limit, &context).await
    }

    /// Get Level Questions
    async fn get_questions_in_level(
        &self,
        version: f64,
        level_id: i64,
        account_id: i64,
        ) -> Result<GetQuestionsInLevelResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_questions_in_level(version, level_id, account_id, &context).await
    }

    /// Get Level Words
    async fn get_words_in_level(
        &self,
        version: f64,
        level_id: i64,
        account_id: i64,
        ) -> Result<GetWordsInLevelResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_words_in_level(version, level_id, account_id, &context).await
    }

    /// Update Game Level
    async fn update_game_level(
        &self,
        version: f64,
        account_id: i64,
        level_id: i64,
        app_key: Option<String>,
        name: Option<String>,
        description: Option<String>,
        difficulty: Option<String>,
        app_version: Option<String>,
        asset_image_id: Option<i64>,
        asset_icon_id: Option<i64>,
        game_data: Option<String>,
        game_data_suffix: Option<String>,
        visibility: Option<String>,
        friend_group: Option<bool>,
        connection_ids: Option<String>,
        connection_group_ids: Option<String>,
        balance: Option<f64>,
        active: Option<bool>,
        allocate_tickets: Option<bool>,
        ticket_count: Option<i64>,
        ticket_type: Option<String>,
        points: Option<i64>,
        tutorial_title: Option<String>,
        tutorial_message: Option<String>,
        tutorial_alignment: Option<String>,
        tutorial_image_asset_id: Option<i64>,
        offer_id: Option<i64>,
        meta_data: Option<String>,
        ) -> Result<UpdateGameLevelResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().update_game_level(version, account_id, level_id, app_key, name, description, difficulty, app_version, asset_image_id, asset_icon_id, game_data, game_data_suffix, visibility, friend_group, connection_ids, connection_group_ids, balance, active, allocate_tickets, ticket_count, ticket_type, points, tutorial_title, tutorial_message, tutorial_alignment, tutorial_image_asset_id, offer_id, meta_data, &context).await
    }

    /// Update Level Questions
    async fn update_questions_in_level(
        &self,
        version: f64,
        level_id: i64,
        account_id: i64,
        question_ids: String,
        ) -> Result<UpdateQuestionsInLevelResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().update_questions_in_level(version, level_id, account_id, question_ids, &context).await
    }

    /// Update Level Words
    async fn update_words_in_level(
        &self,
        version: f64,
        level_id: i64,
        account_id: i64,
        word_ids: String,
        ) -> Result<UpdateWordsInLevelResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().update_words_in_level(version, level_id, account_id, word_ids, &context).await
    }

    /// Accept Invite
    async fn accept_invite(
        &self,
        version: f64,
        token: String,
        account_id: i64,
        album_id: Option<i64>,
        mission_id: Option<i64>,
        album_contest_id: Option<i64>,
        offer_id: Option<i64>,
        offer_location_id: Option<i64>,
        retailer_location_id: Option<i64>,
        app_key: Option<String>,
        auto_friend: Option<bool>,
        auto_attend_event: Option<bool>,
        auto_favorite_offer: Option<bool>,
        auto_favorite_offer_location: Option<bool>,
        auto_favorite_retailer_location: Option<bool>,
        ) -> Result<AcceptInviteResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().accept_invite(version, token, account_id, album_id, mission_id, album_contest_id, offer_id, offer_location_id, retailer_location_id, app_key, auto_friend, auto_attend_event, auto_favorite_offer, auto_favorite_offer_location, auto_favorite_retailer_location, &context).await
    }

    /// Invite to Contest
    async fn album_contest_invite(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        app_id: Option<i64>,
        app_key: Option<String>,
        album_contest_id: Option<i64>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        ) -> Result<AlbumContestInviteResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().album_contest_invite(version, device_id, account_id, app_id, app_key, album_contest_id, latitude, longitude, &context).await
    }

    /// Invite to Collection
    async fn album_invite(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        app_id: Option<i64>,
        app_key: Option<String>,
        album_id: Option<i64>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        ) -> Result<AlbumInviteResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().album_invite(version, device_id, account_id, app_id, app_key, album_id, latitude, longitude, &context).await
    }

    /// Invite to Event
    async fn event_invite(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        listing_id: i64,
        receiver_account_ids: Option<String>,
        retailer_location_id: Option<i64>,
        ) -> Result<EventInviteResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().event_invite(version, account_id, app_key, listing_id, receiver_account_ids, retailer_location_id, &context).await
    }

    /// Invite to Game Level
    async fn game_invite(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        app_id: Option<i64>,
        app_key: Option<String>,
        game_level_id: Option<i64>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        ) -> Result<GameInviteResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().game_invite(version, device_id, account_id, app_id, app_key, game_level_id, latitude, longitude, &context).await
    }

    /// Get Invite
    async fn get_invite(
        &self,
        version: f64,
        account_id: Option<i64>,
        token: Option<String>,
        album_id: Option<i64>,
        mission_id: Option<i64>,
        album_contest_id: Option<i64>,
        offer_id: Option<i64>,
        offer_location_id: Option<i64>,
        retailer_location_id: Option<i64>,
        app_key: Option<String>,
        ) -> Result<GetInviteResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_invite(version, account_id, token, album_id, mission_id, album_contest_id, offer_id, offer_location_id, retailer_location_id, app_key, &context).await
    }

    /// Invite to Mission
    async fn mission_invite(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        app_id: Option<i64>,
        app_key: Option<String>,
        mission_id: Option<i64>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        ) -> Result<MissionInviteResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().mission_invite(version, device_id, account_id, app_id, app_key, mission_id, latitude, longitude, &context).await
    }

    /// Invite to Offer
    async fn offer_invite(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        offer_id: i64,
        ) -> Result<OfferInviteResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().offer_invite(version, account_id, app_key, offer_id, &context).await
    }

    /// Invite to Offer Location
    async fn offer_location_invite(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        offer_location_id: i64,
        ) -> Result<OfferLocationInviteResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().offer_location_invite(version, account_id, app_key, offer_location_id, &context).await
    }

    /// Invite to Retailer Location
    async fn retailer_location_invite(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        retailer_location_id: i64,
        album_id: Option<i64>,
        ) -> Result<RetailerLocationInviteResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().retailer_location_invite(version, account_id, app_key, retailer_location_id, album_id, &context).await
    }

    /// Create a leaderboard based on the rankingType, rankMode(leaderboardMode), sortField and limitation
    async fn create_leaderboard(
        &self,
        version: f64,
        account_id: Option<i64>,
        app_key: Option<String>,
        rank_type: Option<String>,
        leaderboard_mode: Option<String>,
        icon_media: Option<swagger::ByteArray>,
        icon_asset_id: Option<i64>,
        banner_media: Option<swagger::ByteArray>,
        banner_asset_id: Option<i64>,
        limitation: Option<i32>,
        sort_field: Option<String>,
        title: Option<String>,
        description: Option<String>,
        meta_data: Option<String>,
        ) -> Result<CreateLeaderboardResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().create_leaderboard(version, account_id, app_key, rank_type, leaderboard_mode, icon_media, icon_asset_id, banner_media, banner_asset_id, limitation, sort_field, title, description, meta_data, &context).await
    }

    /// Delete the Leader Board
    async fn delete_leaderboard(
        &self,
        version: f64,
        leaderboard_id: i64,
        account_id: Option<i64>,
        ) -> Result<DeleteLeaderboardResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().delete_leaderboard(version, leaderboard_id, account_id, &context).await
    }

    /// Read a leaderboard by id and retrieve the matching ranking list
    async fn get_leaderboard(
        &self,
        version: f64,
        leaderboard_id: i64,
        account_id: Option<i64>,
        include_full_ranking_list: Option<bool>,
        ) -> Result<GetLeaderboardResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_leaderboard(version, leaderboard_id, account_id, include_full_ranking_list, &context).await
    }

    /// Search leaderboard and retrieve the matching ranking list
    async fn search_leaderboards(
        &self,
        version: f64,
        account_id: Option<i64>,
        app_key: Option<String>,
        global_only: Option<bool>,
        keyword: Option<String>,
        leaderboard_ids: Option<String>,
        rank_types: Option<String>,
        sort_field: Option<String>,
        descending: Option<bool>,
        include_inactive: Option<bool>,
        include_app_response: Option<bool>,
        start: Option<i32>,
        limit: Option<i32>,
        ) -> Result<SearchLeaderboardsResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().search_leaderboards(version, account_id, app_key, global_only, keyword, leaderboard_ids, rank_types, sort_field, descending, include_inactive, include_app_response, start, limit, &context).await
    }

    /// Update a leaderboard based on the rankingType, rankMode(leaderboardMode), sortField and limitation
    async fn update_leaderboard(
        &self,
        version: f64,
        leaderboard_id: i64,
        account_id: Option<i64>,
        app_key: Option<String>,
        rank_type: Option<String>,
        leaderboard_mode: Option<String>,
        sort_field: Option<String>,
        icon_media: Option<swagger::ByteArray>,
        icon_asset_id: Option<i64>,
        banner_media: Option<swagger::ByteArray>,
        banner_asset_id: Option<i64>,
        limitation: Option<i32>,
        active: Option<bool>,
        title: Option<String>,
        description: Option<String>,
        meta_data: Option<String>,
        ) -> Result<UpdateLeaderboardResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().update_leaderboard(version, leaderboard_id, account_id, app_key, rank_type, leaderboard_mode, sort_field, icon_media, icon_asset_id, banner_media, banner_asset_id, limitation, active, title, description, meta_data, &context).await
    }

    /// Create Like
    async fn register_like(
        &self,
        version: f64,
        likable_type: String,
        likable_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        permissionable_type: Option<String>,
        permissionable_id: Option<i64>,
        like: Option<bool>,
        app: Option<String>,
        game_type: Option<String>,
        app_key: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        ) -> Result<RegisterLikeResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().register_like(version, likable_type, likable_id, device_id, account_id, permissionable_type, permissionable_id, like, app, game_type, app_key, latitude, longitude, &context).await
    }

    /// Delete Like
    async fn remove_like(
        &self,
        version: f64,
        likable_type: String,
        likable_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        ) -> Result<RemoveLikeResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().remove_like(version, likable_type, likable_id, device_id, account_id, latitude, longitude, &context).await
    }

    /// Search Likes
    async fn search_likes(
        &self,
        version: f64,
        likable_type: String,
        likable_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        connection_account_ids: Option<String>,
        sort_field: Option<String>,
        descending: Option<bool>,
        updated_since: Option<i64>,
        updated_before: Option<i64>,
        start: Option<i32>,
        limit: Option<i32>,
        ) -> Result<SearchLikesResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().search_likes(version, likable_type, likable_id, device_id, account_id, connection_account_ids, sort_field, descending, updated_since, updated_before, start, limit, &context).await
    }

    /// Create Listing
    async fn create_listing(
        &self,
        version: f64,
        account_id: i64,
        name: String,
        filter_ids: Option<String>,
        description: Option<String>,
        start: Option<i64>,
        end: Option<i64>,
        location_name: Option<String>,
        location_description: Option<String>,
        is_private: Option<bool>,
        external_id: Option<String>,
        external_id2: Option<String>,
        external_group_id: Option<String>,
        active: Option<bool>,
        meta_data: Option<String>,
        ) -> Result<CreateListingResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().create_listing(version, account_id, name, filter_ids, description, start, end, location_name, location_description, is_private, external_id, external_id2, external_group_id, active, meta_data, &context).await
    }

    /// Delete Listing
    async fn delete_listing(
        &self,
        version: f64,
        account_id: i64,
        listing_id: i64,
        ) -> Result<DeleteListingResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().delete_listing(version, account_id, listing_id, &context).await
    }

    /// Get Listing
    async fn get_listing(
        &self,
        version: f64,
        listing_id: i64,
        ) -> Result<GetListingResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_listing(version, listing_id, &context).await
    }

    /// Search Listings
    async fn search_listing(
        &self,
        version: f64,
        account_id: Option<i64>,
        keyword: Option<String>,
        start: Option<i32>,
        limit: Option<i32>,
        active_only: Option<bool>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        start_date: Option<i64>,
        end_date: Option<i64>,
        category_ids: Option<String>,
        filter_ids: Option<String>,
        use_listing_order_ids: Option<bool>,
        external_id: Option<String>,
        external_id2: Option<String>,
        external_group_id: Option<String>,
        ) -> Result<SearchListingResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().search_listing(version, account_id, keyword, start, limit, active_only, latitude, longitude, start_date, end_date, category_ids, filter_ids, use_listing_order_ids, external_id, external_id2, external_group_id, &context).await
    }

    /// Summary Listing
    async fn summary_listing(
        &self,
        version: f64,
        account_id: Option<i64>,
        start_date: Option<i64>,
        category_ids: Option<String>,
        days_to_include: Option<i32>,
        use_listing_order_ids: Option<bool>,
        ) -> Result<SummaryListingResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().summary_listing(version, account_id, start_date, category_ids, days_to_include, use_listing_order_ids, &context).await
    }

    /// Update Listing
    async fn update_listing(
        &self,
        version: f64,
        account_id: i64,
        listing_id: i64,
        filter_ids: Option<String>,
        name: Option<String>,
        description: Option<String>,
        start: Option<i64>,
        end: Option<i64>,
        location_name: Option<String>,
        location_description: Option<String>,
        is_private: Option<bool>,
        external_id: Option<String>,
        external_id2: Option<String>,
        external_group_id: Option<String>,
        active: Option<bool>,
        meta_data: Option<String>,
        ) -> Result<UpdateListingResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().update_listing(version, account_id, listing_id, filter_ids, name, description, start, end, location_name, location_description, is_private, external_id, external_id2, external_group_id, active, meta_data, &context).await
    }

    /// Create Trilateration Data with File
    async fn cache_trilateration_data(
        &self,
        version: f64,
        udid: String,
        source_time: Option<i64>,
        minimum_sample_size: Option<i32>,
        data: Option<String>,
        data_file: Option<swagger::ByteArray>,
        ) -> Result<CacheTrilaterationDataResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().cache_trilateration_data(version, udid, source_time, minimum_sample_size, data, data_file, &context).await
    }

    /// Create Trilateration Data with Rest
    async fn cache_trilateration_data_gzip(
        &self,
        version: f64,
        body: Option<models::TrilatCacheRequest>,
        ) -> Result<CacheTrilaterationDataGzipResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().cache_trilateration_data_gzip(version, body, &context).await
    }

    /// Get Location by IP
    async fn get_location_by_ip(
        &self,
        version: f64,
        ip: Option<String>,
        ) -> Result<GetLocationByIpResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_location_by_ip(version, ip, &context).await
    }

    /// Get Location by Trilateration
    async fn get_location_by_trilateration(
        &self,
        version: f64,
        account_id: Option<i64>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        data: Option<String>,
        response_filters: Option<String>,
        ) -> Result<GetLocationByTrilaterationResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_location_by_trilateration(version, account_id, latitude, longitude, data, response_filters, &context).await
    }

    /// Search Regions or Postal Codes
    async fn get_locations(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        currentlatitude: Option<f64>,
        currentlongitude: Option<f64>,
        current_latitude: Option<f64>,
        current_longitude: Option<f64>,
        query: Option<String>,
        zipcode: Option<String>,
        zip_code: Option<String>,
        selected_maplatitude: Option<f64>,
        selected_maplongitude: Option<f64>,
        selected_map_latitude: Option<f64>,
        selected_map_longitude: Option<f64>,
        search_range: Option<f64>,
        use_geocode: Option<bool>,
        _i: Option<i32>,
        start: Option<i32>,
        _l: Option<i32>,
        limit: Option<i32>,
        ) -> Result<GetLocationsResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_locations(version, device_id, account_id, currentlatitude, currentlongitude, current_latitude, current_longitude, query, zipcode, zip_code, selected_maplatitude, selected_maplongitude, selected_map_latitude, selected_map_longitude, search_range, use_geocode, _i, start, _l, limit, &context).await
    }

    /// Create new location
    async fn create_location_v2(
        &self,
        version: f64,
        body: Option<models::Location>,
        ) -> Result<CreateLocationV2Response, ApiError>
    {
        let context = self.context().clone();
        self.api().create_location_v2(version, body, &context).await
    }

    /// Update an existing location
    async fn update_location_v2(
        &self,
        version: f64,
        id: i64,
        body: Option<models::Location>,
        ) -> Result<UpdateLocationV2Response, ApiError>
    {
        let context = self.context().clone();
        self.api().update_location_v2(version, id, body, &context).await
    }

    /// Create Media
    async fn create_media(
        &self,
        version: f64,
        account_id: i64,
        title: String,
        barcode_type: models::CreateMediaBarcodeTypeParameter,
        no_expiration: bool,
        available_limit: i32,
        available_limit_per_user: i32,
        added_limit: i32,
        view_limit: i32,
        max_prints: i32,
        ticket_price: i64,
        full_price: f64,
        discount_price: f64,
        special_offer_type: models::CreateMediaSpecialOfferTypeParameter,
        offer_visibility: models::CreateMediaOfferVisibilityParameter,
        active: bool,
        retailer_location_ids: Option<String>,
        sub_title: Option<String>,
        details: Option<String>,
        sub_details: Option<String>,
        fine_print: Option<String>,
        barcode_entry: Option<String>,
        external_redeem_options: Option<String>,
        external_url: Option<String>,
        tickets_reward_type: Option<String>,
        tickets_reward: Option<i64>,
        activated: Option<i64>,
        expires: Option<i64>,
        ticket_price_type: Option<String>,
        show_remaining: Option<bool>,
        show_redeemed: Option<bool>,
        replaced: Option<bool>,
        featured: Option<bool>,
        category_ids: Option<String>,
        filter_ids: Option<String>,
        barcode_asset_id: Option<i64>,
        image_asset_id: Option<i64>,
        image_asset_id1: Option<i64>,
        image_asset_id2: Option<i64>,
        image_asset_id3: Option<i64>,
        image_asset_id4: Option<i64>,
        image_asset_id5: Option<i64>,
        publisher: Option<String>,
        redeemable_start: Option<i64>,
        redeemable_end: Option<i64>,
        condition_type: Option<models::CreateMediaConditionTypeParameter>,
        isbn: Option<String>,
        asin: Option<String>,
        catalog_numbers: Option<String>,
        parental_rating: Option<String>,
        availability_date: Option<i64>,
        media_type: Option<models::CreateMediaMediaTypeParameter>,
        duration: Option<i32>,
        author: Option<String>,
        release_date: Option<i64>,
        collection_ids: Option<String>,
        availability: Option<String>,
        availability_summary: Option<String>,
        ) -> Result<CreateMediaResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().create_media(version, account_id, title, barcode_type, no_expiration, available_limit, available_limit_per_user, added_limit, view_limit, max_prints, ticket_price, full_price, discount_price, special_offer_type, offer_visibility, active, retailer_location_ids, sub_title, details, sub_details, fine_print, barcode_entry, external_redeem_options, external_url, tickets_reward_type, tickets_reward, activated, expires, ticket_price_type, show_remaining, show_redeemed, replaced, featured, category_ids, filter_ids, barcode_asset_id, image_asset_id, image_asset_id1, image_asset_id2, image_asset_id3, image_asset_id4, image_asset_id5, publisher, redeemable_start, redeemable_end, condition_type, isbn, asin, catalog_numbers, parental_rating, availability_date, media_type, duration, author, release_date, collection_ids, availability, availability_summary, &context).await
    }

    /// Delete Media
    async fn delete_media(
        &self,
        version: f64,
        account_id: i64,
        media_id: i64,
        ) -> Result<DeleteMediaResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().delete_media(version, account_id, media_id, &context).await
    }

    /// Media Get
    async fn get_media(
        &self,
        version: f64,
        account_id: i64,
        media_id: i64,
        ) -> Result<GetMediaResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_media(version, account_id, media_id, &context).await
    }

    /// Search Media
    async fn search_media(
        &self,
        version: f64,
        account_id: i64,
        active_only: bool,
        sort_field: models::SearchEventsSortFieldParameter,
        descending: bool,
        keyword: Option<String>,
        category_ids: Option<String>,
        filter_ids: Option<String>,
        start: Option<i32>,
        limit: Option<i32>,
        ) -> Result<SearchMediaResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().search_media(version, account_id, active_only, sort_field, descending, keyword, category_ids, filter_ids, start, limit, &context).await
    }

    /// Update Media
    async fn update_media(
        &self,
        version: f64,
        account_id: i64,
        media_id: i64,
        retailer_location_ids: Option<String>,
        offer_locations: Option<String>,
        title: Option<String>,
        sub_title: Option<String>,
        details: Option<String>,
        sub_details: Option<String>,
        fine_print: Option<String>,
        barcode_type: Option<models::CreateMediaBarcodeTypeParameter>,
        barcode_entry: Option<String>,
        external_redeem_options: Option<String>,
        external_url: Option<String>,
        tickets_reward_type: Option<String>,
        tickets_reward: Option<i64>,
        activated: Option<i64>,
        expires: Option<i64>,
        no_expiration: Option<bool>,
        available_limit: Option<i32>,
        available_limit_per_user: Option<i32>,
        added_limit: Option<i32>,
        view_limit: Option<i32>,
        max_prints: Option<i32>,
        ticket_price_type: Option<String>,
        ticket_price: Option<i64>,
        full_price: Option<f64>,
        discount_price: Option<f64>,
        show_remaining: Option<bool>,
        show_redeemed: Option<bool>,
        replaced: Option<bool>,
        featured: Option<bool>,
        special_offer_type: Option<models::CreateMediaSpecialOfferTypeParameter>,
        offer_visibility: Option<models::CreateMediaOfferVisibilityParameter>,
        category_ids: Option<String>,
        filter_ids: Option<String>,
        active: Option<bool>,
        barcode_asset_id: Option<i64>,
        image_asset_id: Option<i64>,
        image_asset_id1: Option<i64>,
        image_asset_id2: Option<i64>,
        image_asset_id3: Option<i64>,
        image_asset_id4: Option<i64>,
        image_asset_id5: Option<i64>,
        publisher: Option<String>,
        redeemable_start: Option<i64>,
        redeemable_end: Option<i64>,
        condition_type: Option<models::CreateMediaConditionTypeParameter>,
        isbn: Option<String>,
        asin: Option<String>,
        catalog_numbers: Option<String>,
        availability_date: Option<i64>,
        parental_rating: Option<String>,
        media_type: Option<models::CreateMediaMediaTypeParameter>,
        duration: Option<i32>,
        author: Option<String>,
        release_date: Option<i64>,
        collection_ids: Option<String>,
        availability: Option<String>,
        availability_summary: Option<String>,
        ) -> Result<UpdateMediaResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().update_media(version, account_id, media_id, retailer_location_ids, offer_locations, title, sub_title, details, sub_details, fine_print, barcode_type, barcode_entry, external_redeem_options, external_url, tickets_reward_type, tickets_reward, activated, expires, no_expiration, available_limit, available_limit_per_user, added_limit, view_limit, max_prints, ticket_price_type, ticket_price, full_price, discount_price, show_remaining, show_redeemed, replaced, featured, special_offer_type, offer_visibility, category_ids, filter_ids, active, barcode_asset_id, image_asset_id, image_asset_id1, image_asset_id2, image_asset_id3, image_asset_id4, image_asset_id5, publisher, redeemable_start, redeemable_end, condition_type, isbn, asin, catalog_numbers, availability_date, parental_rating, media_type, duration, author, release_date, collection_ids, availability, availability_summary, &context).await
    }

    /// Create Mission
    async fn create_mission(
        &self,
        version: f64,
        account_id: i64,
        title: String,
        description: Option<String>,
        sub_type: Option<String>,
        start_date: Option<i64>,
        end_date: Option<i64>,
        active: Option<bool>,
        game_level_ids: Option<String>,
        creative_ids: Option<String>,
        audience_ids: Option<String>,
        mission_task: Option<String>,
        format_type: Option<String>,
        offer_id: Option<i64>,
        balance: Option<f64>,
        advanced_reporting: Option<bool>,
        allocate_tickets: Option<bool>,
        ticket_count: Option<i64>,
        ticket_type: Option<String>,
        points: Option<i64>,
        meta_data: Option<String>,
        application_ids: Option<String>,
        devices: Option<String>,
        device_ids: Option<String>,
        device_versions: Option<String>,
        locations: Option<String>,
        radius: Option<String>,
        ) -> Result<CreateMissionResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().create_mission(version, account_id, title, description, sub_type, start_date, end_date, active, game_level_ids, creative_ids, audience_ids, mission_task, format_type, offer_id, balance, advanced_reporting, allocate_tickets, ticket_count, ticket_type, points, meta_data, application_ids, devices, device_ids, device_versions, locations, radius, &context).await
    }

    /// Delete Mission
    async fn delete_mission(
        &self,
        version: f64,
        account_id: i64,
        mission_id: i64,
        ) -> Result<DeleteMissionResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().delete_mission(version, account_id, mission_id, &context).await
    }

    /// Find Missions
    async fn find_missions(
        &self,
        version: f64,
        app_key: String,
        suffix: Option<String>,
        param_type: Option<String>,
        account_id: Option<i64>,
        app_version: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        device: Option<String>,
        device_identifier: Option<i64>,
        device_version: Option<String>,
        start: Option<i32>,
        limit: Option<i32>,
        include_game_data: Option<bool>,
        include_audiences: Option<bool>,
        allocates_tickets: Option<bool>,
        randomize: Option<bool>,
        targeted_ads_only: Option<bool>,
        mission_ids: Option<String>,
        audience_operator: Option<String>,
        ) -> Result<FindMissionsResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().find_missions(version, app_key, suffix, param_type, account_id, app_version, latitude, longitude, device, device_identifier, device_version, start, limit, include_game_data, include_audiences, allocates_tickets, randomize, targeted_ads_only, mission_ids, audience_operator, &context).await
    }

    /// Get Mission
    async fn get_mission(
        &self,
        version: f64,
        account_id: i64,
        mission_id: i64,
        return_creative: Option<bool>,
        ) -> Result<GetMissionResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_mission(version, account_id, mission_id, return_creative, &context).await
    }

    /// Import Mission
    async fn import_mission(
        &self,
        version: f64,
        account_id: i64,
        latitude: f64,
        longitude: f64,
        app_key: String,
        keyword: Option<String>,
        start: Option<i32>,
        limit: Option<i32>,
        ad_size: Option<models::CreateApplicationPlacementSizeParameter>,
        ) -> Result<ImportMissionResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().import_mission(version, account_id, latitude, longitude, app_key, keyword, start, limit, ad_size, &context).await
    }

    /// Search Mission Formats
    async fn search_mission_formats(
        &self,
        version: f64,
        start: i32,
        limit: i32,
        active_only: bool,
        ) -> Result<SearchMissionFormatsResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().search_mission_formats(version, start, limit, active_only, &context).await
    }

    /// Search Missions
    async fn search_missions(
        &self,
        version: f64,
        account_id: i64,
        keyword: Option<String>,
        sub_type: Option<String>,
        start: Option<i32>,
        limit: Option<i32>,
        include_game_data: Option<bool>,
        include_audiences: Option<bool>,
        include_inactive: Option<bool>,
        suffix: Option<String>,
        sort_field: Option<String>,
        descending: Option<bool>,
        ) -> Result<SearchMissionsResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().search_missions(version, account_id, keyword, sub_type, start, limit, include_game_data, include_audiences, include_inactive, suffix, sort_field, descending, &context).await
    }

    /// Search Missions by Billable Entity
    async fn search_missions_by_billable_entity(
        &self,
        version: f64,
        account_id: i64,
        keyword: Option<String>,
        start: Option<i32>,
        limit: Option<i32>,
        include_game_data: Option<bool>,
        include_audiences: Option<bool>,
        include_inactive: Option<bool>,
        suffix: Option<String>,
        sort_field: Option<String>,
        descending: Option<bool>,
        ) -> Result<SearchMissionsByBillableEntityResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().search_missions_by_billable_entity(version, account_id, keyword, start, limit, include_game_data, include_audiences, include_inactive, suffix, sort_field, descending, &context).await
    }

    /// Update Mission
    async fn update_mission(
        &self,
        version: f64,
        account_id: i64,
        mission_id: i64,
        title: Option<String>,
        description: Option<String>,
        sub_type: Option<String>,
        meta_data: Option<String>,
        start_date: Option<i64>,
        end_date: Option<i64>,
        active: Option<bool>,
        game_level_ids: Option<String>,
        creative_ids: Option<String>,
        audience_ids: Option<String>,
        offer_id: Option<i64>,
        balance: Option<f64>,
        advanced_reporting: Option<bool>,
        allocate_tickets: Option<bool>,
        ticket_count: Option<i64>,
        ticket_type: Option<String>,
        points: Option<i64>,
        application_ids: Option<String>,
        devices: Option<String>,
        device_ids: Option<String>,
        device_versions: Option<String>,
        locations: Option<String>,
        radius: Option<String>,
        ) -> Result<UpdateMissionResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().update_mission(version, account_id, mission_id, title, description, sub_type, meta_data, start_date, end_date, active, game_level_ids, creative_ids, audience_ids, offer_id, balance, advanced_reporting, allocate_tickets, ticket_count, ticket_type, points, application_ids, devices, device_ids, device_versions, locations, radius, &context).await
    }

    /// Create Mission Invite
    async fn create_mission_invite(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        mission_id: Option<i64>,
        join_code: Option<String>,
        include_game_data: Option<bool>,
        ) -> Result<CreateMissionInviteResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().create_mission_invite(version, device_id, account_id, mission_id, join_code, include_game_data, &context).await
    }

    /// Delete Mission Invite
    async fn delete_mission_invite(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        mission_id: Option<i64>,
        mission_invite_id: Option<i64>,
        include_game_data: Option<bool>,
        ) -> Result<DeleteMissionInviteResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().delete_mission_invite(version, device_id, account_id, mission_id, mission_invite_id, include_game_data, &context).await
    }

    /// Get Mission Invite
    async fn get_mission_invite(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        mission_id: Option<i64>,
        mission_invite_id: Option<i64>,
        include_game_data: Option<bool>,
        include_scores: Option<String>,
        ) -> Result<GetMissionInviteResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_mission_invite(version, device_id, account_id, mission_id, mission_invite_id, include_game_data, include_scores, &context).await
    }

    /// Search Mission Invites
    async fn search_mission_invites(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        app_key: Option<String>,
        app_version: Option<String>,
        mission_id: Option<i64>,
        status: Option<String>,
        last_updated: Option<i64>,
        start: Option<i32>,
        limit: Option<i32>,
        keyword: Option<String>,
        mission_types: Option<String>,
        filter_by_billable: Option<bool>,
        include_game_data: Option<bool>,
        ) -> Result<SearchMissionInvitesResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().search_mission_invites(version, device_id, account_id, app_key, app_version, mission_id, status, last_updated, start, limit, keyword, mission_types, filter_by_billable, include_game_data, &context).await
    }

    /// Update Mission Invite
    async fn update_mission_invite(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        app_key: Option<String>,
        mission_id: Option<i64>,
        mission_invite_id: Option<i64>,
        pack_id: Option<i64>,
        game_level_id: Option<i64>,
        status: Option<String>,
        permissionable_type: Option<String>,
        permissionable_id: Option<i64>,
        include_game_data: Option<bool>,
        ) -> Result<UpdateMissionInviteResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().update_mission_invite(version, device_id, account_id, app_key, mission_id, mission_invite_id, pack_id, game_level_id, status, permissionable_type, permissionable_id, include_game_data, &context).await
    }

    /// Batch Note Operation
    async fn batch_operation(
        &self,
        version: f64,
        notable_id: i64,
        notable_type: String,
        device_id: Option<String>,
        account_id: Option<i64>,
        batch_operation: Option<String>,
        ) -> Result<BatchOperationResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().batch_operation(version, notable_id, notable_type, device_id, account_id, batch_operation, &context).await
    }

    /// Create Note
    async fn create_note(
        &self,
        version: f64,
        comment: String,
        device_id: Option<String>,
        account_id: Option<i64>,
        notable_type: Option<String>,
        notable_id: Option<i64>,
        note_type: Option<String>,
        asset_ids: Option<String>,
        tags: Option<String>,
        permissionable_type: Option<String>,
        permissionable_id: Option<i64>,
        app_key: Option<String>,
        location_description: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        meta_data: Option<String>,
        receiver_account_ids: Option<String>,
        return_full_response: Option<bool>,
        initialize_asset: Option<bool>,
        asset_return_nulls: Option<bool>,
        asset_album_id: Option<i64>,
        asset_collection_id: Option<i64>,
        asset_add_to_default_album: Option<String>,
        asset_add_to_media_library: Option<bool>,
        asset_version_code: Option<i32>,
        asset_version_name: Option<String>,
        asset_meta_data: Option<String>,
        asset_caption: Option<String>,
        asset_media: Option<swagger::ByteArray>,
        asset_media_url: Option<String>,
        asset_media_string: Option<String>,
        asset_media_string_file_name: Option<String>,
        asset_media_string_content_type: Option<String>,
        asset_attached_media: Option<swagger::ByteArray>,
        asset_attached_media_url: Option<String>,
        asset_attached_media_string: Option<String>,
        asset_attached_media_string_file_name: Option<String>,
        asset_attached_media_string_content_type: Option<String>,
        asset_location_description: Option<String>,
        asset_app: Option<String>,
        asset_search_tags: Option<String>,
        asset_latitude: Option<f64>,
        asset_longitude: Option<f64>,
        ) -> Result<CreateNoteResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().create_note(version, comment, device_id, account_id, notable_type, notable_id, note_type, asset_ids, tags, permissionable_type, permissionable_id, app_key, location_description, latitude, longitude, meta_data, receiver_account_ids, return_full_response, initialize_asset, asset_return_nulls, asset_album_id, asset_collection_id, asset_add_to_default_album, asset_add_to_media_library, asset_version_code, asset_version_name, asset_meta_data, asset_caption, asset_media, asset_media_url, asset_media_string, asset_media_string_file_name, asset_media_string_content_type, asset_attached_media, asset_attached_media_url, asset_attached_media_string, asset_attached_media_string_file_name, asset_attached_media_string_content_type, asset_location_description, asset_app, asset_search_tags, asset_latitude, asset_longitude, &context).await
    }

    /// Delete Note
    async fn delete_note(
        &self,
        version: f64,
        note_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        app_key: Option<String>,
        ) -> Result<DeleteNoteResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().delete_note(version, note_id, device_id, account_id, latitude, longitude, app_key, &context).await
    }

    /// Get Note
    async fn get_note(
        &self,
        version: f64,
        note_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        return_full_response: Option<bool>,
        ) -> Result<GetNoteResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_note(version, note_id, device_id, account_id, return_full_response, &context).await
    }

    /// Search Notes
    async fn search_notes(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        notable_type: Option<String>,
        notable_id: Option<i64>,
        note_types: Option<String>,
        app_key: Option<String>,
        keyword: Option<String>,
        flag_count_minimum: Option<i64>,
        flags_exceed_threshold: Option<bool>,
        include_inactive: Option<bool>,
        sort_field: Option<models::SearchNotesSortFieldParameter>,
        descending: Option<bool>,
        return_full_response: Option<bool>,
        updated_since: Option<i64>,
        updated_before: Option<i64>,
        start: Option<i32>,
        limit: Option<i32>,
        ) -> Result<SearchNotesResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().search_notes(version, device_id, account_id, notable_type, notable_id, note_types, app_key, keyword, flag_count_minimum, flags_exceed_threshold, include_inactive, sort_field, descending, return_full_response, updated_since, updated_before, start, limit, &context).await
    }

    /// Update Note
    async fn update_note(
        &self,
        version: f64,
        note_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        comment: Option<String>,
        note_type: Option<String>,
        asset_ids: Option<String>,
        tags: Option<String>,
        permissionable_type: Option<String>,
        permissionable_id: Option<i64>,
        app_key: Option<String>,
        location_description: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        meta_data: Option<String>,
        return_full_response: Option<bool>,
        active: Option<bool>,
        update_asset: Option<bool>,
        asset_return_nulls: Option<bool>,
        asset_album_id: Option<i64>,
        asset_collection_id: Option<i64>,
        asset_add_to_default_album: Option<String>,
        asset_add_to_media_library: Option<bool>,
        asset_version_code: Option<i32>,
        asset_version_name: Option<String>,
        asset_meta_data: Option<String>,
        asset_caption: Option<String>,
        asset_media: Option<swagger::ByteArray>,
        asset_media_url: Option<String>,
        asset_media_string: Option<String>,
        asset_media_string_file_name: Option<String>,
        asset_media_string_content_type: Option<String>,
        asset_attached_media: Option<swagger::ByteArray>,
        asset_attached_media_url: Option<String>,
        asset_attached_media_string: Option<String>,
        asset_attached_media_string_file_name: Option<String>,
        asset_attached_media_string_content_type: Option<String>,
        asset_location_description: Option<String>,
        asset_app: Option<String>,
        asset_search_tags: Option<String>,
        asset_latitude: Option<f64>,
        asset_longitude: Option<f64>,
        ) -> Result<UpdateNoteResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().update_note(version, note_id, device_id, account_id, comment, note_type, asset_ids, tags, permissionable_type, permissionable_id, app_key, location_description, latitude, longitude, meta_data, return_full_response, active, update_asset, asset_return_nulls, asset_album_id, asset_collection_id, asset_add_to_default_album, asset_add_to_media_library, asset_version_code, asset_version_name, asset_meta_data, asset_caption, asset_media, asset_media_url, asset_media_string, asset_media_string_file_name, asset_media_string_content_type, asset_attached_media, asset_attached_media_url, asset_attached_media_string, asset_attached_media_string_file_name, asset_attached_media_string_content_type, asset_location_description, asset_app, asset_search_tags, asset_latitude, asset_longitude, &context).await
    }

    /// Create Notification Template
    async fn create_notification_template(
        &self,
        version: f64,
        account_id: i64,
        conduit: String,
        title: String,
        body: String,
        app_key: Option<String>,
        event: Option<String>,
        tags: Option<String>,
        ) -> Result<CreateNotificationTemplateResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().create_notification_template(version, account_id, conduit, title, body, app_key, event, tags, &context).await
    }

    /// Create or update blocked notification settings
    async fn create_or_update_blocked_notifications(
        &self,
        version: f64,
        app_key: String,
        data: String,
        account_id: Option<i64>,
        ) -> Result<CreateOrUpdateBlockedNotificationsResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().create_or_update_blocked_notifications(version, app_key, data, account_id, &context).await
    }

    /// Delete Notification Template
    async fn delete_notification_template(
        &self,
        version: f64,
        account_id: i64,
        notification_template_id: i64,
        ) -> Result<DeleteNotificationTemplateResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().delete_notification_template(version, account_id, notification_template_id, &context).await
    }

    /// Get Notification Template
    async fn get_notification_template(
        &self,
        version: f64,
        account_id: i64,
        notification_template_id: i64,
        ) -> Result<GetNotificationTemplateResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_notification_template(version, account_id, notification_template_id, &context).await
    }

    /// Get Notifications
    async fn get_notifications(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        connection_account_id: Option<i64>,
        app_key: Option<String>,
        event_type: Option<String>,
        content_ids: Option<String>,
        content_types: Option<String>,
        parent_ids: Option<String>,
        parent_types: Option<String>,
        action_category: Option<String>,
        conduits: Option<String>,
        keyword: Option<String>,
        return_read_messages: Option<bool>,
        mark_as_read: Option<bool>,
        from_date: Option<i64>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        return_sent: Option<bool>,
        ignore_flagged: Option<bool>,
        start: Option<i32>,
        limit: Option<i32>,
        ) -> Result<GetNotificationsResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_notifications(version, device_id, account_id, connection_account_id, app_key, event_type, content_ids, content_types, parent_ids, parent_types, action_category, conduits, keyword, return_read_messages, mark_as_read, from_date, latitude, longitude, return_sent, ignore_flagged, start, limit, &context).await
    }

    /// Register Notification Token
    async fn register_notification_token(
        &self,
        version: f64,
        token: String,
        push_type: models::RegisterNotificationTokenPushTypeParameter,
        device_id: Option<String>,
        account_id: Option<i64>,
        environment: Option<String>,
        app_key: Option<String>,
        game_type: Option<String>,
        active: Option<bool>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        ) -> Result<RegisterNotificationTokenResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().register_notification_token(version, token, push_type, device_id, account_id, environment, app_key, game_type, active, latitude, longitude, &context).await
    }

    /// Search on the user's blocked notification settings
    async fn search_blocked_notifications(
        &self,
        version: f64,
        app_key: String,
        account_id: Option<i64>,
        search_tags: Option<String>,
        events: Option<String>,
        conduits: Option<String>,
        custom_types: Option<String>,
        content_types: Option<String>,
        content_ids: Option<String>,
        sort_field: Option<String>,
        descending: Option<bool>,
        start: Option<i32>,
        limit: Option<i32>,
        ) -> Result<SearchBlockedNotificationsResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().search_blocked_notifications(version, app_key, account_id, search_tags, events, conduits, custom_types, content_types, content_ids, sort_field, descending, start, limit, &context).await
    }

    /// Search Notification Templates
    async fn search_notification_template(
        &self,
        version: f64,
        account_id: i64,
        sort_field: String,
        descending: bool,
        start: i32,
        limit: i32,
        app_key: Option<String>,
        event: Option<String>,
        conduit: Option<String>,
        global_only: Option<bool>,
        reserved_only: Option<bool>,
        keyword: Option<String>,
        ) -> Result<SearchNotificationTemplateResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().search_notification_template(version, account_id, sort_field, descending, start, limit, app_key, event, conduit, global_only, reserved_only, keyword, &context).await
    }

    /// Search for Recipients
    async fn search_recipients(
        &self,
        version: f64,
        sort_field: models::SearchRecipientsSortFieldParameter,
        device_id: Option<String>,
        account_id: Option<i64>,
        app_key: Option<String>,
        conduit: Option<String>,
        keyword: Option<String>,
        audience_id: Option<i64>,
        audience_ids: Option<String>,
        connection_group_ids: Option<String>,
        recipient_account_ids: Option<String>,
        descending: Option<bool>,
        start: Option<i32>,
        limit: Option<i32>,
        ) -> Result<SearchRecipientsResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().search_recipients(version, sort_field, device_id, account_id, app_key, conduit, keyword, audience_id, audience_ids, connection_group_ids, recipient_account_ids, descending, start, limit, &context).await
    }

    /// Search for Recipients (Counts/Grouped)
    async fn search_recipients_count(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        app_key: Option<String>,
        conduit: Option<String>,
        keyword: Option<String>,
        audience_id: Option<i64>,
        audience_ids: Option<String>,
        connection_group_ids: Option<String>,
        sort_field: Option<String>,
        descending: Option<bool>,
        start: Option<i32>,
        limit: Option<i32>,
        ) -> Result<SearchRecipientsCountResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().search_recipients_count(version, device_id, account_id, app_key, conduit, keyword, audience_id, audience_ids, connection_group_ids, sort_field, descending, start, limit, &context).await
    }

    /// Send Batch Notifications
    async fn send_batch_notifications(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        custom_message: String,
        conduit: Option<String>,
        content_id: Option<i64>,
        content_name: Option<String>,
        content_type: Option<String>,
        parent_id: Option<i64>,
        parent_type: Option<String>,
        ) -> Result<SendBatchNotificationsResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().send_batch_notifications(version, account_id, app_key, custom_message, conduit, content_id, content_name, content_type, parent_id, parent_type, &context).await
    }

    /// Send Custom Notifications
    async fn send_custom_notifications(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        receiver_account_ids: Option<String>,
        include_friend_group: Option<bool>,
        app_key: Option<String>,
        game_type: Option<String>,
        conduit: Option<String>,
        content_id: Option<i64>,
        content_name: Option<String>,
        content_type: Option<String>,
        parent_id: Option<i64>,
        parent_type: Option<String>,
        action_category: Option<String>,
        subject: Option<String>,
        custom_message: Option<String>,
        friend_only_apns: Option<bool>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        ) -> Result<SendCustomNotificationsResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().send_custom_notifications(version, device_id, account_id, receiver_account_ids, include_friend_group, app_key, game_type, conduit, content_id, content_name, content_type, parent_id, parent_type, action_category, subject, custom_message, friend_only_apns, latitude, longitude, &context).await
    }

    /// Update Notification Template
    async fn update_notification_template(
        &self,
        version: f64,
        account_id: i64,
        notification_template_id: i64,
        title: Option<String>,
        body: Option<String>,
        tags: Option<String>,
        ) -> Result<UpdateNotificationTemplateResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().update_notification_template(version, account_id, notification_template_id, title, body, tags, &context).await
    }

    /// Create Field
    async fn add_field(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        object_name: String,
        field_name: String,
        field_type: String,
        ) -> Result<AddFieldResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().add_field(version, account_id, app_key, object_name, field_name, field_type, &context).await
    }

    /// Create Object
    async fn create_object(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        object_name: String,
        ) -> Result<CreateObjectResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().create_object(version, account_id, app_key, object_name, &context).await
    }

    /// Delete Field
    async fn delete_field(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        object_name: String,
        field_name: String,
        ) -> Result<DeleteFieldResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().delete_field(version, account_id, app_key, object_name, field_name, &context).await
    }

    /// Delete Object
    async fn delete_object(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        object_name: String,
        ) -> Result<DeleteObjectResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().delete_object(version, account_id, app_key, object_name, &context).await
    }

    /// Get Object
    async fn get_object(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        object_name: String,
        ) -> Result<GetObjectResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_object(version, account_id, app_key, object_name, &context).await
    }

    /// Search Objects
    async fn search_object(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        start: i64,
        limit: i64,
        keyword: Option<String>,
        ) -> Result<SearchObjectResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().search_object(version, account_id, app_key, start, limit, keyword, &context).await
    }

    /// Create Data
    async fn create_data(
        &self,
        version: f64,
        object_name: String,
        account_id: Option<i64>,
        body: Option<String>,
        ) -> Result<CreateDataResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().create_data(version, object_name, account_id, body, &context).await
    }

    /// Search Data
    async fn search_data(
        &self,
        version: f64,
        object_name: String,
        count: bool,
        start: i64,
        limit: i64,
        account_id: Option<i64>,
        criteria: Option<String>,
        order: Option<String>,
        include: Option<String>,
        ) -> Result<SearchDataResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().search_data(version, object_name, count, start, limit, account_id, criteria, order, include, &context).await
    }

    /// Delete Data
    async fn delete_data(
        &self,
        version: f64,
        object_name: String,
        object_id: String,
        account_id: Option<i64>,
        ) -> Result<DeleteDataResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().delete_data(version, object_name, object_id, account_id, &context).await
    }

    /// Get Data
    async fn get_data(
        &self,
        version: f64,
        object_name: String,
        object_id: String,
        account_id: Option<i64>,
        include: Option<String>,
        ) -> Result<GetDataResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_data(version, object_name, object_id, account_id, include, &context).await
    }

    /// Update Data
    async fn update_data(
        &self,
        version: f64,
        object_name: String,
        object_id: String,
        account_id: Option<i64>,
        body: Option<String>,
        ) -> Result<UpdateDataResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().update_data(version, object_name, object_id, account_id, body, &context).await
    }

    /// Update Offer Locations
    async fn batch_update_offer_locations(
        &self,
        version: f64,
        data: String,
        device_id: Option<String>,
        account_id: Option<i64>,
        ) -> Result<BatchUpdateOfferLocationsResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().batch_update_offer_locations(version, data, device_id, account_id, &context).await
    }

    /// Create Offer
    async fn create_offer(
        &self,
        version: f64,
        include_offer_locations: bool,
        title: String,
        barcode_type: models::CreateMediaBarcodeTypeParameter,
        no_expiration: bool,
        available_limit: i32,
        available_limit_per_user: i32,
        added_limit: i32,
        view_limit: i32,
        max_prints: i32,
        ticket_price: i64,
        full_price: f64,
        discount_price: f64,
        offer_type: models::CreateOfferOfferTypeParameter,
        special_offer_type: models::CreateMediaSpecialOfferTypeParameter,
        offer_visibility: models::CreateMediaOfferVisibilityParameter,
        active: bool,
        device_id: Option<String>,
        account_id: Option<i64>,
        tags: Option<String>,
        parent_offer_id: Option<i64>,
        retailer_location_ids: Option<String>,
        offer_locations: Option<String>,
        sub_title: Option<String>,
        details: Option<String>,
        sub_details: Option<String>,
        fine_print: Option<String>,
        barcode_entry: Option<String>,
        external_redeem_options: Option<String>,
        external_url: Option<String>,
        external_id: Option<String>,
        tickets_reward_type: Option<String>,
        tickets_reward: Option<i64>,
        activated: Option<i64>,
        expires: Option<i64>,
        ticket_price_type: Option<String>,
        show_remaining: Option<bool>,
        show_redeemed: Option<bool>,
        replaced: Option<bool>,
        featured: Option<bool>,
        category_ids: Option<String>,
        filter_ids: Option<String>,
        barcode_asset_id: Option<i64>,
        image_asset_id: Option<i64>,
        image_asset_id1: Option<i64>,
        image_asset_id2: Option<i64>,
        image_asset_id3: Option<i64>,
        image_asset_id4: Option<i64>,
        image_asset_id5: Option<i64>,
        publisher: Option<String>,
        redeemable_start: Option<i64>,
        redeemable_end: Option<i64>,
        brand: Option<String>,
        product_type: Option<models::CreateOfferProductTypeParameter>,
        condition_type: Option<models::CreateMediaConditionTypeParameter>,
        isbn: Option<String>,
        asin: Option<String>,
        catalog_numbers: Option<String>,
        department: Option<String>,
        features: Option<String>,
        minimum_price: Option<f64>,
        width: Option<f64>,
        height: Option<f64>,
        depth: Option<f64>,
        weight: Option<f64>,
        unit: Option<models::CreateOfferUnitParameter>,
        studio: Option<String>,
        parental_rating: Option<String>,
        publish_date: Option<i64>,
        availability_date: Option<i64>,
        size_id: Option<i64>,
        listing_id: Option<i64>,
        media_type: Option<models::CreateMediaMediaTypeParameter>,
        duration: Option<i32>,
        author: Option<String>,
        release_date: Option<i64>,
        collection_ids: Option<String>,
        reboot_time_hour: Option<i32>,
        reboot_time_minute: Option<i32>,
        idle_timeout_in_second: Option<i32>,
        serial_number: Option<String>,
        udid: Option<String>,
        device_type: Option<String>,
        device_power: Option<f64>,
        device_interference: Option<f64>,
        availability: Option<String>,
        availability_summary: Option<String>,
        ) -> Result<CreateOfferResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().create_offer(version, include_offer_locations, title, barcode_type, no_expiration, available_limit, available_limit_per_user, added_limit, view_limit, max_prints, ticket_price, full_price, discount_price, offer_type, special_offer_type, offer_visibility, active, device_id, account_id, tags, parent_offer_id, retailer_location_ids, offer_locations, sub_title, details, sub_details, fine_print, barcode_entry, external_redeem_options, external_url, external_id, tickets_reward_type, tickets_reward, activated, expires, ticket_price_type, show_remaining, show_redeemed, replaced, featured, category_ids, filter_ids, barcode_asset_id, image_asset_id, image_asset_id1, image_asset_id2, image_asset_id3, image_asset_id4, image_asset_id5, publisher, redeemable_start, redeemable_end, brand, product_type, condition_type, isbn, asin, catalog_numbers, department, features, minimum_price, width, height, depth, weight, unit, studio, parental_rating, publish_date, availability_date, size_id, listing_id, media_type, duration, author, release_date, collection_ids, reboot_time_hour, reboot_time_minute, idle_timeout_in_second, serial_number, udid, device_type, device_power, device_interference, availability, availability_summary, &context).await
    }

    /// Delete Offer
    async fn delete_offer(
        &self,
        version: f64,
        offer_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        ) -> Result<DeleteOfferResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().delete_offer(version, offer_id, device_id, account_id, &context).await
    }

    /// Delete Offer Location
    async fn delete_offer_location(
        &self,
        version: f64,
        offer_location_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        ) -> Result<DeleteOfferLocationResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().delete_offer_location(version, offer_location_id, device_id, account_id, &context).await
    }

    /// Get Offer
    async fn get_offer(
        &self,
        version: f64,
        offer_id: i64,
        include_offer_locations: bool,
        device_id: Option<String>,
        account_id: Option<i64>,
        ) -> Result<GetOfferResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_offer(version, offer_id, include_offer_locations, device_id, account_id, &context).await
    }

    /// Get Offer
    async fn get_offer_details(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        offer_id: Option<i64>,
        offer_location_id: Option<i64>,
        distance: Option<f64>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        include_offer_locations: Option<bool>,
        include_retailer_locations: Option<bool>,
        include_child_offers: Option<bool>,
        ) -> Result<GetOfferDetailsResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_offer_details(version, device_id, account_id, offer_id, offer_location_id, distance, latitude, longitude, include_offer_locations, include_retailer_locations, include_child_offers, &context).await
    }

    /// Get Offers (Counts)
    async fn get_offer_list_counts(
        &self,
        version: f64,
        latitude: f64,
        longitude: f64,
        search_range: Option<f64>,
        distance_unit: Option<models::GetOfferListCountsDistanceUnitParameter>,
        ) -> Result<GetOfferListCountsResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_offer_list_counts(version, latitude, longitude, search_range, distance_unit, &context).await
    }

    /// Get Offer Location
    async fn get_offer_location(
        &self,
        version: f64,
        offer_location_id: Option<i64>,
        udid: Option<String>,
        ) -> Result<GetOfferLocationResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_offer_location(version, offer_location_id, udid, &context).await
    }

    /// Search Offer Locations
    async fn get_offer_locations_for_retailers(
        &self,
        version: f64,
        sort_field: models::SearchOffersForConsumerGroupByParameter,
        descending: bool,
        start: i32,
        limit: i32,
        active_only: bool,
        include_retailer_location: bool,
        device_id: Option<String>,
        account_id: Option<i64>,
        keyword: Option<String>,
        retailer_id: Option<i64>,
        retailer_location_id: Option<i64>,
        offer_type: Option<models::CreateOfferOfferTypeParameter>,
        special_offer_type: Option<models::CreateMediaSpecialOfferTypeParameter>,
        barcode_type: Option<String>,
        barcode_entry: Option<String>,
        isbn: Option<String>,
        asin: Option<String>,
        device_status: Option<models::GetOfferLocationsForRetailersDeviceStatusParameter>,
        needs_notification_sent: Option<bool>,
        last_notification_sent: Option<i64>,
        ) -> Result<GetOfferLocationsForRetailersResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_offer_locations_for_retailers(version, sort_field, descending, start, limit, active_only, include_retailer_location, device_id, account_id, keyword, retailer_id, retailer_location_id, offer_type, special_offer_type, barcode_type, barcode_entry, isbn, asin, device_status, needs_notification_sent, last_notification_sent, &context).await
    }

    /// Search Offers
    async fn get_offers_for_retailers(
        &self,
        version: f64,
        offer_visibility: models::CreateMediaOfferVisibilityParameter,
        sort_field: models::SearchEventsSortFieldParameter,
        descending: bool,
        start: i32,
        limit: i32,
        available_only: bool,
        active_only: bool,
        include_categories: bool,
        include_filters: bool,
        include_offer_locations: bool,
        device_id: Option<String>,
        account_id: Option<i64>,
        category_ids: Option<String>,
        filter_ids: Option<String>,
        q: Option<String>,
        keyword: Option<String>,
        retailer_id: Option<i64>,
        retailer_location_id: Option<i64>,
        coupon_type: Option<models::CreateOfferOfferTypeParameter>,
        offer_type: Option<models::CreateOfferOfferTypeParameter>,
        offer_types: Option<String>,
        special_offer_type: Option<models::CreateMediaSpecialOfferTypeParameter>,
        _i: Option<i32>,
        _l: Option<i32>,
        barcode_type: Option<String>,
        barcode_entry: Option<String>,
        isbn: Option<String>,
        asin: Option<String>,
        device_status: Option<models::GetOfferLocationsForRetailersDeviceStatusParameter>,
        needs_notification_sent: Option<bool>,
        last_notification_sent: Option<i64>,
        ) -> Result<GetOffersForRetailersResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_offers_for_retailers(version, offer_visibility, sort_field, descending, start, limit, available_only, active_only, include_categories, include_filters, include_offer_locations, device_id, account_id, category_ids, filter_ids, q, keyword, retailer_id, retailer_location_id, coupon_type, offer_type, offer_types, special_offer_type, _i, _l, barcode_type, barcode_entry, isbn, asin, device_status, needs_notification_sent, last_notification_sent, &context).await
    }

    /// Update Offer Transaction
    async fn redeem_offer_transaction(
        &self,
        version: f64,
        offer_transaction_id: i64,
        status: i32,
        device_id: Option<String>,
        account_id: Option<i64>,
        offer_location_id: Option<i64>,
        ) -> Result<RedeemOfferTransactionResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().redeem_offer_transaction(version, offer_transaction_id, status, device_id, account_id, offer_location_id, &context).await
    }

    /// Search Offer Transactions
    async fn search_offer_transactions_for_retailers(
        &self,
        version: f64,
        sort_field: models::SearchEventTransactionsSortFieldParameter,
        descending: bool,
        start: i32,
        limit: i32,
        active_only: bool,
        device_id: Option<String>,
        account_id: Option<i64>,
        q: Option<String>,
        keyword: Option<String>,
        retailer_id: Option<i64>,
        retailer_location_id: Option<i64>,
        offer_id: Option<i64>,
        offer_location_id: Option<i64>,
        redeemed: Option<bool>,
        reservations_only: Option<bool>,
        coupon_type: Option<models::CreateOfferOfferTypeParameter>,
        offer_type: Option<models::CreateOfferOfferTypeParameter>,
        special_offer_type: Option<models::CreateMediaSpecialOfferTypeParameter>,
        customer_account_ids: Option<String>,
        category_ids: Option<String>,
        redeemable_start_date: Option<i64>,
        redeemable_end_date: Option<i64>,
        _i: Option<i32>,
        _l: Option<i32>,
        ) -> Result<SearchOfferTransactionsForRetailersResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().search_offer_transactions_for_retailers(version, sort_field, descending, start, limit, active_only, device_id, account_id, q, keyword, retailer_id, retailer_location_id, offer_id, offer_location_id, redeemed, reservations_only, coupon_type, offer_type, special_offer_type, customer_account_ids, category_ids, redeemable_start_date, redeemable_end_date, _i, _l, &context).await
    }

    /// Search Offers
    async fn search_offers_for_consumer(
        &self,
        version: f64,
        latitude: f64,
        longitude: f64,
        recommendation_type: models::SearchOffersForConsumerRecommendationTypeParameter,
        location_id: i64,
        start: i32,
        limit: i32,
        max_recommendations: i32,
        distance_unit: models::SearchOffersForConsumerDistanceUnitParameter,
        app_key: Option<String>,
        device_id: Option<String>,
        account_id: Option<i64>,
        search_range: Option<f64>,
        tags: Option<String>,
        supported_postal_codes: Option<String>,
        keyword: Option<String>,
        categories: Option<String>,
        filters: Option<String>,
        offer_types: Option<String>,
        param_type: Option<String>,
        sort_field: Option<String>,
        recommend_offer_ids: Option<String>,
        retailer_location_ids: Option<String>,
        offer_id: Option<i64>,
        include_mission: Option<bool>,
        include_categories: Option<bool>,
        include_filters: Option<bool>,
        include_expired: Option<bool>,
        include_favorite: Option<bool>,
        closest_offer_only: Option<bool>,
        search_expression: Option<String>,
        group_by: Option<models::SearchOffersForConsumerGroupByParameter>,
        ) -> Result<SearchOffersForConsumerResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().search_offers_for_consumer(version, latitude, longitude, recommendation_type, location_id, start, limit, max_recommendations, distance_unit, app_key, device_id, account_id, search_range, tags, supported_postal_codes, keyword, categories, filters, offer_types, param_type, sort_field, recommend_offer_ids, retailer_location_ids, offer_id, include_mission, include_categories, include_filters, include_expired, include_favorite, closest_offer_only, search_expression, group_by, &context).await
    }

    /// Get Offers (Top)
    async fn top_offer_transactions(
        &self,
        version: f64,
        start: Option<i32>,
        limit: Option<i32>,
        ) -> Result<TopOfferTransactionsResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().top_offer_transactions(version, start, limit, &context).await
    }

    /// Update Offer
    async fn update_offer(
        &self,
        version: f64,
        offer_id: i64,
        include_offer_locations: bool,
        device_id: Option<String>,
        account_id: Option<i64>,
        parent_offer_id: Option<i64>,
        retailer_location_ids: Option<String>,
        offer_locations: Option<String>,
        tags: Option<String>,
        title: Option<String>,
        sub_title: Option<String>,
        details: Option<String>,
        sub_details: Option<String>,
        fine_print: Option<String>,
        barcode_type: Option<models::CreateMediaBarcodeTypeParameter>,
        barcode_entry: Option<String>,
        external_redeem_options: Option<String>,
        external_url: Option<String>,
        external_id: Option<String>,
        tickets_reward_type: Option<String>,
        tickets_reward: Option<i64>,
        activated: Option<i64>,
        expires: Option<i64>,
        no_expiration: Option<bool>,
        available_limit: Option<i32>,
        available_limit_per_user: Option<i32>,
        added_limit: Option<i32>,
        view_limit: Option<i32>,
        max_prints: Option<i32>,
        ticket_price_type: Option<String>,
        ticket_price: Option<i64>,
        full_price: Option<f64>,
        discount_price: Option<f64>,
        show_remaining: Option<bool>,
        show_redeemed: Option<bool>,
        replaced: Option<bool>,
        featured: Option<bool>,
        offer_type: Option<models::CreateOfferOfferTypeParameter>,
        special_offer_type: Option<models::CreateMediaSpecialOfferTypeParameter>,
        offer_visibility: Option<models::CreateMediaOfferVisibilityParameter>,
        category_ids: Option<String>,
        filter_ids: Option<String>,
        active: Option<bool>,
        barcode_asset_id: Option<i64>,
        image_asset_id: Option<i64>,
        image_asset_id1: Option<i64>,
        image_asset_id2: Option<i64>,
        image_asset_id3: Option<i64>,
        image_asset_id4: Option<i64>,
        image_asset_id5: Option<i64>,
        publisher: Option<String>,
        redeemable_start: Option<i64>,
        redeemable_end: Option<i64>,
        brand: Option<String>,
        product_type: Option<models::CreateOfferProductTypeParameter>,
        condition_type: Option<models::CreateMediaConditionTypeParameter>,
        isbn: Option<String>,
        asin: Option<String>,
        catalog_numbers: Option<String>,
        department: Option<String>,
        features: Option<String>,
        minimum_price: Option<f64>,
        width: Option<f64>,
        height: Option<f64>,
        depth: Option<f64>,
        weight: Option<f64>,
        unit: Option<models::CreateOfferUnitParameter>,
        studio: Option<String>,
        parental_rating: Option<String>,
        publish_date: Option<i64>,
        availability_date: Option<i64>,
        size_id: Option<i64>,
        listing_id: Option<i64>,
        media_type: Option<models::CreateMediaMediaTypeParameter>,
        duration: Option<i32>,
        author: Option<String>,
        release_date: Option<i64>,
        collection_ids: Option<String>,
        reboot_time_hour: Option<i32>,
        reboot_time_minute: Option<i32>,
        idle_timeout_in_second: Option<i32>,
        serial_number: Option<String>,
        udid: Option<String>,
        device_type: Option<String>,
        device_power: Option<f64>,
        device_interference: Option<f64>,
        availability: Option<String>,
        availability_summary: Option<String>,
        ) -> Result<UpdateOfferResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().update_offer(version, offer_id, include_offer_locations, device_id, account_id, parent_offer_id, retailer_location_ids, offer_locations, tags, title, sub_title, details, sub_details, fine_print, barcode_type, barcode_entry, external_redeem_options, external_url, external_id, tickets_reward_type, tickets_reward, activated, expires, no_expiration, available_limit, available_limit_per_user, added_limit, view_limit, max_prints, ticket_price_type, ticket_price, full_price, discount_price, show_remaining, show_redeemed, replaced, featured, offer_type, special_offer_type, offer_visibility, category_ids, filter_ids, active, barcode_asset_id, image_asset_id, image_asset_id1, image_asset_id2, image_asset_id3, image_asset_id4, image_asset_id5, publisher, redeemable_start, redeemable_end, brand, product_type, condition_type, isbn, asin, catalog_numbers, department, features, minimum_price, width, height, depth, weight, unit, studio, parental_rating, publish_date, availability_date, size_id, listing_id, media_type, duration, author, release_date, collection_ids, reboot_time_hour, reboot_time_minute, idle_timeout_in_second, serial_number, udid, device_type, device_power, device_interference, availability, availability_summary, &context).await
    }

    /// Activate Offer
    async fn update_offer_status(
        &self,
        version: f64,
        offer_ids: String,
        active: bool,
        device_id: Option<String>,
        account_id: Option<i64>,
        ) -> Result<UpdateOfferStatusResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().update_offer_status(version, offer_ids, active, device_id, account_id, &context).await
    }

    /// Create Offer Status
    async fn create_offer_transaction_status(
        &self,
        version: f64,
        name: String,
        code: i32,
        device_id: Option<String>,
        account_id: Option<i64>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        description: Option<String>,
        role: Option<String>,
        active: Option<bool>,
        application_ids: Option<String>,
        ) -> Result<CreateOfferTransactionStatusResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().create_offer_transaction_status(version, name, code, device_id, account_id, latitude, longitude, description, role, active, application_ids, &context).await
    }

    /// Delete Offer Status
    async fn delete_offer_transaction_status(
        &self,
        version: f64,
        status_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        ) -> Result<DeleteOfferTransactionStatusResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().delete_offer_transaction_status(version, status_id, device_id, account_id, latitude, longitude, &context).await
    }

    /// Get Offer Status
    async fn get_offer_transaction_status(
        &self,
        version: f64,
        status_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        ) -> Result<GetOfferTransactionStatusResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_offer_transaction_status(version, status_id, device_id, account_id, latitude, longitude, &context).await
    }

    /// Search Offer Status
    async fn search_offer_transaction_statuses(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        keyword: Option<String>,
        role: Option<String>,
        app_key: Option<String>,
        sort_field: Option<models::SearchOfferTransactionStatusesSortFieldParameter>,
        descending: Option<bool>,
        start: Option<i32>,
        limit: Option<i32>,
        include_inactive: Option<bool>,
        ) -> Result<SearchOfferTransactionStatusesResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().search_offer_transaction_statuses(version, device_id, account_id, latitude, longitude, keyword, role, app_key, sort_field, descending, start, limit, include_inactive, &context).await
    }

    /// Update Offer Status
    async fn update_offer_transaction_status(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        status_id: Option<i64>,
        name: Option<String>,
        description: Option<String>,
        code: Option<i32>,
        role: Option<String>,
        active: Option<bool>,
        application_ids: Option<String>,
        ) -> Result<UpdateOfferTransactionStatusResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().update_offer_transaction_status(version, device_id, account_id, latitude, longitude, status_id, name, description, code, role, active, application_ids, &context).await
    }

    /// Generate images with OpenAI
    async fn image_generation(
        &self,
        version: f64,
        account_id: i64,
        post_body: String,
        return_raw_response: Option<bool>,
        ) -> Result<ImageGenerationResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().image_generation(version, account_id, post_body, return_raw_response, &context).await
    }

    /// Request Optimization
    async fn request_optimization(
        &self,
        version: f64,
        body: Option<models::Orders>,
        ) -> Result<RequestOptimizationResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().request_optimization(version, body, &context).await
    }

    /// Get Optimization Result
    async fn get_optimization_result(
        &self,
        version: f64,
        batch_id: String,
        start: i32,
        limit: i32,
        ) -> Result<GetOptimizationResultResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_optimization_result(version, batch_id, start, limit, &context).await
    }

    /// Add Movie
    async fn add_movie(
        &self,
        version: f64,
        account_id: i64,
        movie_name: String,
        third_party_account_id: Option<String>,
        tags: Option<String>,
        file: Option<swagger::ByteArray>,
        url: Option<String>,
        callback: Option<String>,
        ) -> Result<AddMovieResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().add_movie(version, account_id, movie_name, third_party_account_id, tags, file, url, callback, &context).await
    }

    /// Search Docs
    async fn ai_docs(
        &self,
        version: f64,
        account_id: i64,
        doc: String,
        return_topics: Option<bool>,
        limit: Option<i32>,
        offset: Option<i32>,
        ) -> Result<AiDocsResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().ai_docs(version, account_id, doc, return_topics, limit, offset, &context).await
    }

    /// Find images
    async fn ai_find_images(
        &self,
        version: f64,
        account_id: i64,
        text: String,
        parse_flag: Option<String>,
        fetch_flag: Option<String>,
        size: Option<String>,
        ) -> Result<AiFindImagesResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().ai_find_images(version, account_id, text, parse_flag, fetch_flag, size, &context).await
    }

    /// Search Tags
    async fn ai_tags(
        &self,
        version: f64,
        account_id: i64,
        tags: String,
        conditional: Option<String>,
        limit: Option<i32>,
        offset: Option<i32>,
        ) -> Result<AiTagsResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().ai_tags(version, account_id, tags, conditional, limit, offset, &context).await
    }

    /// Search Text
    async fn ai_text(
        &self,
        version: f64,
        account_id: i64,
        terms: String,
        conditional: Option<String>,
        limit: Option<i32>,
        offset: Option<i32>,
        ) -> Result<AiTextResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().ai_text(version, account_id, terms, conditional, limit, offset, &context).await
    }

    /// Batch Analysis
    async fn batch(
        &self,
        version: f64,
        account_id: i64,
        third_party_account_id: Option<String>,
        limit: Option<i32>,
        operations: Option<String>,
        file: Option<swagger::ByteArray>,
        url: Option<String>,
        callback: Option<String>,
        ) -> Result<BatchResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().batch(version, account_id, third_party_account_id, limit, operations, file, url, callback, &context).await
    }

    /// Creates an instant episode
    async fn create_instant_episode(
        &self,
        version: f64,
        account_id: i64,
        data: String,
        ) -> Result<CreateInstantEpisodeResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().create_instant_episode(version, account_id, data, &context).await
    }

    /// Create VoiceCanvas images
    async fn create_voice_canvas(
        &self,
        version: f64,
        account_id: i64,
        dimensions: String,
        third_party_account_id: Option<String>,
        text: Option<String>,
        file: Option<swagger::ByteArray>,
        url: Option<String>,
        parse_flag: Option<bool>,
        fetch_flag: Option<bool>,
        callback: Option<String>,
        ) -> Result<CreateVoiceCanvasResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().create_voice_canvas(version, account_id, dimensions, third_party_account_id, text, file, url, parse_flag, fetch_flag, callback, &context).await
    }

    /// Detect emotions
    async fn emotion(
        &self,
        version: f64,
        account_id: i64,
        third_party_account_id: Option<String>,
        file: Option<swagger::ByteArray>,
        url: Option<String>,
        callback: Option<String>,
        ) -> Result<EmotionResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().emotion(version, account_id, third_party_account_id, file, url, callback, &context).await
    }

    /// Starts a StoryStitch video render
    async fn start_video_render(
        &self,
        version: f64,
        account_id: i64,
        data: String,
        ) -> Result<StartVideoRenderResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().start_video_render(version, account_id, data, &context).await
    }

    /// Speach to Text
    async fn stt(
        &self,
        version: f64,
        account_id: i64,
        third_party_account_id: Option<String>,
        source_language: Option<String>,
        target_language: Option<String>,
        file: Option<swagger::ByteArray>,
        url: Option<String>,
        callback: Option<String>,
        ) -> Result<SttResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().stt(version, account_id, third_party_account_id, source_language, target_language, file, url, callback, &context).await
    }

    /// Summarize Topics
    async fn summarize_topics(
        &self,
        version: f64,
        account_id: i64,
        third_party_account_id: Option<String>,
        doc: Option<String>,
        file: Option<swagger::ByteArray>,
        url: Option<String>,
        limit: Option<i32>,
        offset: Option<i32>,
        callback: Option<String>,
        ) -> Result<SummarizeTopicsResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().summarize_topics(version, account_id, third_party_account_id, doc, file, url, limit, offset, callback, &context).await
    }

    /// Detect Technical Issues
    async fn tech_tune(
        &self,
        version: f64,
        account_id: i64,
        num_faces_expected: i32,
        third_party_account_id: Option<String>,
        file: Option<swagger::ByteArray>,
        url: Option<String>,
        callback: Option<String>,
        ) -> Result<TechTuneResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().tech_tune(version, account_id, num_faces_expected, third_party_account_id, file, url, callback, &context).await
    }

    /// Text to Speach
    async fn tts(
        &self,
        version: f64,
        account_id: i64,
        text: String,
        third_party_account_id: Option<String>,
        language: Option<String>,
        voice: Option<String>,
        callback: Option<String>,
        ) -> Result<TtsResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().tts(version, account_id, text, third_party_account_id, language, voice, callback, &context).await
    }

    /// Get Add Movie Result
    async fn get_add_movie_result(
        &self,
        version: f64,
        request_id: String,
        account_id: i64,
        ) -> Result<GetAddMovieResultResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_add_movie_result(version, request_id, account_id, &context).await
    }

    /// Get Batch Analysis Results
    async fn get_batch(
        &self,
        version: f64,
        request_id: String,
        account_id: i64,
        ) -> Result<GetBatchResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_batch(version, request_id, account_id, &context).await
    }

    /// Get Emotion Results
    async fn get_emotion(
        &self,
        version: f64,
        request_id: String,
        account_id: i64,
        ) -> Result<GetEmotionResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_emotion(version, request_id, account_id, &context).await
    }

    /// Check episode status
    async fn get_episode_status(
        &self,
        version: f64,
        episode_id: i64,
        account_id: i64,
        ) -> Result<GetEpisodeStatusResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_episode_status(version, episode_id, account_id, &context).await
    }

    /// Check episode status
    async fn get_render_status(
        &self,
        version: f64,
        render_id: String,
        account_id: i64,
        ) -> Result<GetRenderStatusResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_render_status(version, render_id, account_id, &context).await
    }

    /// Get Speach to Text Result
    async fn get_stt(
        &self,
        version: f64,
        request_id: String,
        account_id: i64,
        ) -> Result<GetSttResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_stt(version, request_id, account_id, &context).await
    }

    /// Get TechTune Results
    async fn get_tech_tune(
        &self,
        version: f64,
        request_id: String,
        account_id: i64,
        ) -> Result<GetTechTuneResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_tech_tune(version, request_id, account_id, &context).await
    }

    /// Get Topics
    async fn get_topics(
        &self,
        version: f64,
        request_id: String,
        account_id: i64,
        ) -> Result<GetTopicsResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_topics(version, request_id, account_id, &context).await
    }

    /// Get Text to Speach Result
    async fn get_tts(
        &self,
        version: f64,
        request_id: String,
        account_id: i64,
        ) -> Result<GetTtsResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_tts(version, request_id, account_id, &context).await
    }

    /// Get VoiceCanvas images
    async fn get_voice_canvas(
        &self,
        version: f64,
        request_id: String,
        account_id: i64,
        ) -> Result<GetVoiceCanvasResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_voice_canvas(version, request_id, account_id, &context).await
    }

    /// Create Pack
    async fn create_pack(
        &self,
        version: f64,
        account_id: i64,
        title: String,
        pack_order: i64,
        price: i32,
        highest: bool,
        allocate_tickets: bool,
        ticket_count: i64,
        description: Option<String>,
        search_tags: Option<String>,
        active: Option<bool>,
        game_type: Option<String>,
        app_key: Option<String>,
        pack_type: Option<models::CreatePackPackTypeParameter>,
        sequence_type: Option<models::CreatePackSequenceTypeParameter>,
        background_id: Option<i64>,
        image_id: Option<i64>,
        start_date: Option<i64>,
        end_date: Option<i64>,
        author_override: Option<String>,
        price_type: Option<String>,
        game_level_ids: Option<String>,
        in_game: Option<bool>,
        ticket_type: Option<String>,
        points: Option<i64>,
        ) -> Result<CreatePackResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().create_pack(version, account_id, title, pack_order, price, highest, allocate_tickets, ticket_count, description, search_tags, active, game_type, app_key, pack_type, sequence_type, background_id, image_id, start_date, end_date, author_override, price_type, game_level_ids, in_game, ticket_type, points, &context).await
    }

    /// Delete Pack
    async fn delete_pack(
        &self,
        version: f64,
        account_id: i64,
        pack_id: i64,
        ) -> Result<DeletePackResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().delete_pack(version, account_id, pack_id, &context).await
    }

    /// Get Pack
    async fn get_pack(
        &self,
        version: f64,
        account_id: i64,
        pack_id: i64,
        include_game_data: bool,
        ) -> Result<GetPackResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_pack(version, account_id, pack_id, include_game_data, &context).await
    }

    /// Search Packs
    async fn search_packs(
        &self,
        version: f64,
        account_id: i64,
        sort_field: models::SearchPacksSortFieldParameter,
        descending: bool,
        keyword: Option<String>,
        pack_type: Option<models::CreatePackPackTypeParameter>,
        start: Option<i32>,
        limit: Option<i32>,
        include_game_data: Option<bool>,
        include_inactive: Option<bool>,
        app_key: Option<String>,
        ) -> Result<SearchPacksResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().search_packs(version, account_id, sort_field, descending, keyword, pack_type, start, limit, include_game_data, include_inactive, app_key, &context).await
    }

    /// Update Pack
    async fn update_pack(
        &self,
        version: f64,
        account_id: i64,
        pack_id: i64,
        allocate_tickets: bool,
        ticket_count: i64,
        title: Option<String>,
        description: Option<String>,
        search_tags: Option<String>,
        active: Option<bool>,
        game_type: Option<String>,
        app_key: Option<String>,
        pack_type: Option<models::CreatePackPackTypeParameter>,
        pack_order: Option<i64>,
        sequence_type: Option<models::CreatePackSequenceTypeParameter>,
        background_id: Option<i64>,
        image_id: Option<i64>,
        start_date: Option<i64>,
        end_date: Option<i64>,
        author_override: Option<String>,
        price: Option<i32>,
        price_type: Option<String>,
        game_level_ids: Option<String>,
        in_game: Option<bool>,
        highest: Option<bool>,
        ticket_type: Option<String>,
        points: Option<i64>,
        ) -> Result<UpdatePackResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().update_pack(version, account_id, pack_id, allocate_tickets, ticket_count, title, description, search_tags, active, game_type, app_key, pack_type, pack_order, sequence_type, background_id, image_id, start_date, end_date, author_override, price, price_type, game_level_ids, in_game, highest, ticket_type, points, &context).await
    }

    /// Process All Participant Feeds
    async fn process_all_participants(
        &self,
        version: f64,
        account_id: i64,
        app_key: Option<String>,
        use_short_name_as_id: Option<bool>,
        ) -> Result<ProcessAllParticipantsResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().process_all_participants(version, account_id, app_key, use_short_name_as_id, &context).await
    }

    /// Process Participants Feed
    async fn process_participants(
        &self,
        version: f64,
        account_id: i64,
        league: String,
        app_key: Option<String>,
        use_short_name_as_id: Option<bool>,
        file: Option<swagger::ByteArray>,
        ) -> Result<ProcessParticipantsResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().process_participants(version, account_id, league, app_key, use_short_name_as_id, file, &context).await
    }

    /// Calculate Path
    async fn compute_path(
        &self,
        version: f64,
        data: String,
        units: models::ComputePathUnitsParameter,
        reduce_path: bool,
        directions: bool,
        ) -> Result<ComputePathResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().compute_path(version, data, units, reduce_path, directions, &context).await
    }

    /// Create Postal Code
    async fn create_postal_code(
        &self,
        version: f64,
        account_id: i64,
        code: String,
        latitude: f64,
        longitude: f64,
        state_code: Option<String>,
        city: Option<String>,
        active: Option<bool>,
        ) -> Result<CreatePostalCodeResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().create_postal_code(version, account_id, code, latitude, longitude, state_code, city, active, &context).await
    }

    /// Delete Postal Code
    async fn delete_postal_code(
        &self,
        version: f64,
        account_id: i64,
        postal_code_id: i64,
        ) -> Result<DeletePostalCodeResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().delete_postal_code(version, account_id, postal_code_id, &context).await
    }

    /// Get Postal Code
    async fn get_postal_code(
        &self,
        version: f64,
        postal_code_id: i64,
        ) -> Result<GetPostalCodeResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_postal_code(version, postal_code_id, &context).await
    }

    /// Search Postal Codes
    async fn get_postal_codes(
        &self,
        version: f64,
        sort_field: String,
        descending: bool,
        latitude: Option<f64>,
        longitude: Option<f64>,
        keyword: Option<String>,
        miles: Option<f64>,
        start: Option<i32>,
        limit: Option<i32>,
        ) -> Result<GetPostalCodesResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_postal_codes(version, sort_field, descending, latitude, longitude, keyword, miles, start, limit, &context).await
    }

    /// Update Postal Code
    async fn update_postal_code(
        &self,
        version: f64,
        account_id: i64,
        postal_code_id: i64,
        code: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        state_code: Option<String>,
        city: Option<String>,
        active: Option<bool>,
        ) -> Result<UpdatePostalCodeResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().update_postal_code(version, account_id, postal_code_id, code, latitude, longitude, state_code, city, active, &context).await
    }

    /// Create Persona
    async fn create_persona(
        &self,
        version: f64,
        account_id: i64,
        title: String,
        preview_accounts: Option<String>,
        date: Option<i64>,
        age: Option<i32>,
        gender: Option<String>,
        game_experience_level: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        ) -> Result<CreatePersonaResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().create_persona(version, account_id, title, preview_accounts, date, age, gender, game_experience_level, latitude, longitude, &context).await
    }

    /// Delete Persona
    async fn delete_persona(
        &self,
        version: f64,
        account_id: i64,
        persona_id: i64,
        ) -> Result<DeletePersonaResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().delete_persona(version, account_id, persona_id, &context).await
    }

    /// Get Persona
    async fn get_persona_list(
        &self,
        version: f64,
        account_id: i64,
        persona_id: i64,
        ) -> Result<GetPersonaListResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_persona_list(version, account_id, persona_id, &context).await
    }

    /// Search Personas
    async fn search_persona(
        &self,
        version: f64,
        account_id: i64,
        start: i32,
        limit: i32,
        ) -> Result<SearchPersonaResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().search_persona(version, account_id, start, limit, &context).await
    }

    /// Update Persona
    async fn update_persona(
        &self,
        version: f64,
        account_id: i64,
        persona_id: i64,
        title: Option<String>,
        preview_accounts: Option<String>,
        active: Option<bool>,
        date: Option<i64>,
        age: Option<i32>,
        gender: Option<String>,
        game_experience_level: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        ) -> Result<UpdatePersonaResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().update_persona(version, account_id, persona_id, title, preview_accounts, active, date, age, gender, game_experience_level, latitude, longitude, &context).await
    }

    /// Create Program
    async fn create_program(
        &self,
        version: f64,
        body: Option<models::Program>,
        ) -> Result<CreateProgramResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().create_program(version, body, &context).await
    }

    /// Search Programs
    async fn search_programs(
        &self,
        version: f64,
        sort_field: String,
        descending: bool,
        start: i32,
        limit: i32,
        active_only: bool,
        keyword: Option<String>,
        ) -> Result<SearchProgramsResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().search_programs(version, sort_field, descending, start, limit, active_only, keyword, &context).await
    }

    /// Delete Program
    async fn delete_program(
        &self,
        version: f64,
        id: i64,
        ) -> Result<DeleteProgramResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().delete_program(version, id, &context).await
    }

    /// Get Program
    async fn get_program(
        &self,
        version: f64,
        id: i64,
        ) -> Result<GetProgramResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_program(version, id, &context).await
    }

    /// Update Program
    async fn post_program(
        &self,
        version: f64,
        id: i64,
        body: Option<models::Program>,
        ) -> Result<PostProgramResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().post_program(version, id, body, &context).await
    }

    /// Update Program
    async fn put_program(
        &self,
        version: f64,
        id: i64,
        body: Option<models::Program>,
        ) -> Result<PutProgramResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().put_program(version, id, body, &context).await
    }

    /// Create Purchase
    async fn create_purchase_item(
        &self,
        version: f64,
        app_key: String,
        name: String,
        purchase_type: models::CreatePurchaseItemPurchaseTypeParameter,
        device_id: Option<String>,
        account_id: Option<i64>,
        description: Option<String>,
        tickets: Option<i32>,
        price: Option<f32>,
        purchase_code: Option<String>,
        secret_key: Option<String>,
        purchase_limit: Option<i32>,
        service_action: Option<models::CreatePurchaseItemServiceActionParameter>,
        cover_asset_id: Option<i64>,
        promo_asset_id: Option<i64>,
        giftable: Option<bool>,
        assetable: Option<bool>,
        allocate_tickets: Option<bool>,
        ticket_type: Option<String>,
        points: Option<i64>,
        offer_location_id: Option<i64>,
        ) -> Result<CreatePurchaseItemResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().create_purchase_item(version, app_key, name, purchase_type, device_id, account_id, description, tickets, price, purchase_code, secret_key, purchase_limit, service_action, cover_asset_id, promo_asset_id, giftable, assetable, allocate_tickets, ticket_type, points, offer_location_id, &context).await
    }

    /// Delete Purchase
    async fn delete_purchase_item(
        &self,
        version: f64,
        purchase_item_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        ) -> Result<DeletePurchaseItemResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().delete_purchase_item(version, purchase_item_id, device_id, account_id, &context).await
    }

    /// Get Purchase
    async fn get_purchase_item(
        &self,
        version: f64,
        purchase_item_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        ) -> Result<GetPurchaseItemResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_purchase_item(version, purchase_item_id, device_id, account_id, &context).await
    }

    /// Search Purchases
    async fn search_purchase_items(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        app_key: Option<String>,
        filter_by_billable: Option<bool>,
        purchase_type: Option<String>,
        service_action: Option<String>,
        keyword: Option<String>,
        sort_field: Option<models::SearchPurchaseItemsSortFieldParameter>,
        descending: Option<bool>,
        start: Option<i32>,
        limit: Option<i32>,
        active_only: Option<bool>,
        ) -> Result<SearchPurchaseItemsResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().search_purchase_items(version, device_id, account_id, app_key, filter_by_billable, purchase_type, service_action, keyword, sort_field, descending, start, limit, active_only, &context).await
    }

    /// Update Purchase
    async fn update_purchase_item(
        &self,
        version: f64,
        purchase_item_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        name: Option<String>,
        description: Option<String>,
        tickets: Option<i32>,
        price: Option<f32>,
        purchase_type: Option<models::CreatePurchaseItemPurchaseTypeParameter>,
        purchase_code: Option<String>,
        secret_key: Option<String>,
        purchase_limit: Option<i32>,
        service_action: Option<models::CreatePurchaseItemServiceActionParameter>,
        cover_asset_id: Option<i64>,
        promo_asset_id: Option<i64>,
        giftable: Option<bool>,
        assetable: Option<bool>,
        active: Option<bool>,
        allocate_tickets: Option<bool>,
        ticket_type: Option<String>,
        points: Option<i64>,
        offer_location_id: Option<i64>,
        ) -> Result<UpdatePurchaseItemResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().update_purchase_item(version, purchase_item_id, device_id, account_id, name, description, tickets, price, purchase_type, purchase_code, secret_key, purchase_limit, service_action, cover_asset_id, promo_asset_id, giftable, assetable, active, allocate_tickets, ticket_type, points, offer_location_id, &context).await
    }

    /// Create Order
    async fn create_order(
        &self,
        version: f64,
        app_key: String,
        cart: String,
        device_id: Option<String>,
        account_id: Option<i64>,
        description: Option<String>,
        currency_type: Option<models::CreateOrderCurrencyTypeParameter>,
        payment_method_id: Option<i64>,
        external_order_id: Option<String>,
        external_payment_id: Option<String>,
        remote_ref_type: Option<String>,
        external_date: Option<i64>,
        promo_code: Option<String>,
        ) -> Result<CreateOrderResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().create_order(version, app_key, cart, device_id, account_id, description, currency_type, payment_method_id, external_order_id, external_payment_id, remote_ref_type, external_date, promo_code, &context).await
    }

    /// Delete Order
    async fn delete_order(
        &self,
        version: f64,
        order_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        ) -> Result<DeleteOrderResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().delete_order(version, order_id, device_id, account_id, &context).await
    }

    /// Get Order
    async fn get_order(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        order_id: Option<i64>,
        external_order_id: Option<String>,
        ) -> Result<GetOrderResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_order(version, device_id, account_id, order_id, external_order_id, &context).await
    }

    /// Preview Order
    async fn preview_order(
        &self,
        version: f64,
        app_key: String,
        cart: String,
        device_id: Option<String>,
        account_id: Option<i64>,
        description: Option<String>,
        currency_type: Option<models::CreateOrderCurrencyTypeParameter>,
        payment_method_id: Option<i64>,
        external_order_id: Option<String>,
        external_payment_id: Option<String>,
        remote_ref_type: Option<String>,
        external_date: Option<i64>,
        promo_code: Option<String>,
        ) -> Result<PreviewOrderResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().preview_order(version, app_key, cart, device_id, account_id, description, currency_type, payment_method_id, external_order_id, external_payment_id, remote_ref_type, external_date, promo_code, &context).await
    }

    /// Search Orders
    async fn search_orders(
        &self,
        version: f64,
        app_key: String,
        device_id: Option<String>,
        account_id: Option<i64>,
        start: Option<i32>,
        limit: Option<i32>,
        descending: Option<bool>,
        active_only: Option<bool>,
        ignore_customer_filter: Option<bool>,
        order_item_types: Option<String>,
        order_item_ids: Option<String>,
        order_custom_types: Option<String>,
        order_custom_ids: Option<String>,
        sort_field: Option<String>,
        offer_types: Option<String>,
        special_offer_types: Option<String>,
        category_ids: Option<String>,
        filter_ids: Option<String>,
        offer_audience_ids: Option<String>,
        transaction_audience_ids: Option<String>,
        offer_ids: Option<String>,
        offer_location_ids: Option<String>,
        retailer_ids: Option<String>,
        retailer_location_ids: Option<String>,
        statuses: Option<String>,
        keyword: Option<String>,
        redeemable_start_date: Option<i64>,
        redeemable_end_date: Option<i64>,
        started_since: Option<i64>,
        started_before: Option<i64>,
        ended_since: Option<i64>,
        ended_before: Option<i64>,
        ) -> Result<SearchOrdersResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().search_orders(version, app_key, device_id, account_id, start, limit, descending, active_only, ignore_customer_filter, order_item_types, order_item_ids, order_custom_types, order_custom_ids, sort_field, offer_types, special_offer_types, category_ids, filter_ids, offer_audience_ids, transaction_audience_ids, offer_ids, offer_location_ids, retailer_ids, retailer_location_ids, statuses, keyword, redeemable_start_date, redeemable_end_date, started_since, started_before, ended_since, ended_before, &context).await
    }

    /// Update Order
    async fn update_order(
        &self,
        version: f64,
        order_id: i64,
        app_key: String,
        cart: String,
        device_id: Option<String>,
        account_id: Option<i64>,
        payment_transaction_id: Option<i64>,
        description: Option<String>,
        currency_type: Option<models::CreateOrderCurrencyTypeParameter>,
        payment_method_id: Option<i64>,
        external_payment_id: Option<String>,
        external_date: Option<i64>,
        ) -> Result<UpdateOrderResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().update_order(version, order_id, app_key, cart, device_id, account_id, payment_transaction_id, description, currency_type, payment_method_id, external_payment_id, external_date, &context).await
    }

    /// Create Question
    async fn create_question(
        &self,
        version: f64,
        account_id: i64,
        question: String,
        answers: String,
        active: bool,
        allocate_tickets: bool,
        ticket_count: i64,
        tags: Option<String>,
        video_url: Option<String>,
        asset_id: Option<i64>,
        ticket_type: Option<String>,
        points: Option<i64>,
        ) -> Result<CreateQuestionResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().create_question(version, account_id, question, answers, active, allocate_tickets, ticket_count, tags, video_url, asset_id, ticket_type, points, &context).await
    }

    /// Delete Question
    async fn delete_question(
        &self,
        version: f64,
        question_id: i64,
        account_id: i64,
        ) -> Result<DeleteQuestionResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().delete_question(version, question_id, account_id, &context).await
    }

    /// Get Question
    async fn get_question(
        &self,
        version: f64,
        question_id: i64,
        account_id: i64,
        ) -> Result<GetQuestionResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_question(version, question_id, account_id, &context).await
    }

    /// Search Questions
    async fn search_questions(
        &self,
        version: f64,
        account_id: i64,
        sort_field: String,
        descending: bool,
        active_only: bool,
        start: i32,
        limit: i32,
        keyword: Option<String>,
        ) -> Result<SearchQuestionsResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().search_questions(version, account_id, sort_field, descending, active_only, start, limit, keyword, &context).await
    }

    /// Update Question
    async fn update_question(
        &self,
        version: f64,
        question_id: i64,
        account_id: i64,
        ticket_count: i64,
        question: Option<String>,
        answers: Option<String>,
        tags: Option<String>,
        video_url: Option<String>,
        asset_id: Option<i64>,
        active: Option<bool>,
        allocate_tickets: Option<bool>,
        ticket_type: Option<String>,
        points: Option<i64>,
        ) -> Result<UpdateQuestionResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().update_question(version, question_id, account_id, ticket_count, question, answers, tags, video_url, asset_id, active, allocate_tickets, ticket_type, points, &context).await
    }

    /// Search Historical Rankings
    async fn get_historical_rankings(
        &self,
        version: f64,
        app_key: String,
        rank_type: String,
        start_date: i64,
        end_date: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        sort_field: Option<String>,
        descending: Option<bool>,
        start: Option<i32>,
        limit: Option<i32>,
        ) -> Result<GetHistoricalRankingsResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_historical_rankings(version, app_key, rank_type, start_date, end_date, device_id, account_id, sort_field, descending, start, limit, &context).await
    }

    /// Search Rankings
    async fn get_rankings(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        game_type: Option<String>,
        app_key: Option<String>,
        q: Option<String>,
        keyword: Option<String>,
        rank_type: Option<String>,
        leaderboard_mode: Option<String>,
        within_account_ids: Option<String>,
        return_user_rank: Option<bool>,
        album_id: Option<i64>,
        audience_id: Option<i64>,
        sort_field: Option<String>,
        descending: Option<bool>,
        _i: Option<i32>,
        start: Option<i32>,
        _l: Option<i32>,
        limit: Option<i32>,
        ) -> Result<GetRankingsResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_rankings(version, device_id, account_id, game_type, app_key, q, keyword, rank_type, leaderboard_mode, within_account_ids, return_user_rank, album_id, audience_id, sort_field, descending, _i, start, _l, limit, &context).await
    }

    /// Get Personal Rankings
    async fn get_user_rank(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        app_key: Option<String>,
        rank_type: Option<String>,
        return_user_rank: Option<bool>,
        leaderboard_mode: Option<String>,
        sort_field: Option<String>,
        keyword: Option<String>,
        descending: Option<bool>,
        start: Option<i32>,
        limit: Option<i32>,
        ) -> Result<GetUserRankResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_user_rank(version, device_id, account_id, app_key, rank_type, return_user_rank, leaderboard_mode, sort_field, keyword, descending, start, limit, &context).await
    }

    /// Override User Rank
    async fn override_user_rank(
        &self,
        version: f64,
        account_id: i64,
        owner_account_id: i64,
        app_key: String,
        rank_type: String,
        total_score: Option<i64>,
        total_count: Option<i64>,
        total_time: Option<i64>,
        daily_score: Option<i64>,
        daily_count: Option<i64>,
        daily_time: Option<i64>,
        weekly_score: Option<i64>,
        weekly_count: Option<i64>,
        weekly_time: Option<i64>,
        monthly_score: Option<i64>,
        monthly_count: Option<i64>,
        monthly_time: Option<i64>,
        top_score: Option<i64>,
        lowest_score: Option<i64>,
        streak_count: Option<i64>,
        streak_best_count: Option<i64>,
        start_date: Option<i64>,
        end_date: Option<i64>,
        ) -> Result<OverrideUserRankResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().override_user_rank(version, account_id, owner_account_id, app_key, rank_type, total_score, total_count, total_time, daily_score, daily_count, daily_time, weekly_score, weekly_count, weekly_time, monthly_score, monthly_count, monthly_time, top_score, lowest_score, streak_count, streak_best_count, start_date, end_date, &context).await
    }

    /// Update Ranking
    async fn update_rankings(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        rank_type: String,
        increment: Option<i64>,
        time_increment: Option<i64>,
        tag: Option<String>,
        start_date: Option<i64>,
        end_date: Option<i64>,
        update_global: Option<bool>,
        create_leaderboard: Option<bool>,
        ) -> Result<UpdateRankingsResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().update_rankings(version, account_id, app_key, rank_type, increment, time_increment, tag, start_date, end_date, update_global, create_leaderboard, &context).await
    }

    /// Create Rating
    async fn create_rating(
        &self,
        version: f64,
        ratable_type: String,
        ratable_id: i64,
        rating_value: i32,
        device_id: Option<String>,
        account_id: Option<i64>,
        category_id: Option<i64>,
        display: Option<String>,
        description: Option<String>,
        location_description: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        ) -> Result<CreateRatingResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().create_rating(version, ratable_type, ratable_id, rating_value, device_id, account_id, category_id, display, description, location_description, latitude, longitude, &context).await
    }

    /// Delete Rating
    async fn delete_rating(
        &self,
        version: f64,
        rating_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        ) -> Result<DeleteRatingResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().delete_rating(version, rating_id, device_id, account_id, &context).await
    }

    /// Search Location Rating Indexes
    async fn search_location_rating_indexes(
        &self,
        version: f64,
        category_ids: Option<String>,
        keyword: Option<String>,
        location_type: Option<String>,
        sort_field: Option<models::SearchRatingIndexesSortFieldParameter>,
        descending: Option<bool>,
        start: Option<i32>,
        limit: Option<i32>,
        search_range: Option<f64>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        return_overall_rating: Option<bool>,
        distance_unit: Option<models::SearchOffersForConsumerDistanceUnitParameter>,
        return_retailer: Option<bool>,
        return_assets: Option<bool>,
        return_offers: Option<bool>,
        return_categories: Option<bool>,
        return_filters: Option<bool>,
        ) -> Result<SearchLocationRatingIndexesResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().search_location_rating_indexes(version, category_ids, keyword, location_type, sort_field, descending, start, limit, search_range, latitude, longitude, return_overall_rating, distance_unit, return_retailer, return_assets, return_offers, return_categories, return_filters, &context).await
    }

    /// Search Rating Indexes
    async fn search_rating_indexes(
        &self,
        version: f64,
        ratable_type: models::SearchRatingIndexesRatableTypeParameter,
        ratable_ids: Option<String>,
        category_ids: Option<String>,
        secondary_type: Option<String>,
        keyword: Option<String>,
        sort_field: Option<models::SearchRatingIndexesSortFieldParameter>,
        descending: Option<bool>,
        start: Option<i32>,
        limit: Option<i32>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        return_ratable: Option<bool>,
        return_overall_rating: Option<bool>,
        ) -> Result<SearchRatingIndexesResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().search_rating_indexes(version, ratable_type, ratable_ids, category_ids, secondary_type, keyword, sort_field, descending, start, limit, latitude, longitude, return_ratable, return_overall_rating, &context).await
    }

    /// Search Ratings
    async fn search_ratings(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        filter_account_id: Option<i64>,
        ratable_type: Option<String>,
        ratable_id: Option<i64>,
        category_ids: Option<String>,
        keyword: Option<String>,
        sort_field: Option<models::SearchRatingsSortFieldParameter>,
        descending: Option<bool>,
        start: Option<i32>,
        limit: Option<i32>,
        ) -> Result<SearchRatingsResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().search_ratings(version, device_id, account_id, filter_account_id, ratable_type, ratable_id, category_ids, keyword, sort_field, descending, start, limit, &context).await
    }

    /// Update Rating
    async fn update_rating(
        &self,
        version: f64,
        rating_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        rating_value: Option<i32>,
        category_id: Option<i64>,
        display: Option<String>,
        description: Option<String>,
        location_description: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        ) -> Result<UpdateRatingResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().update_rating(version, rating_id, device_id, account_id, rating_value, category_id, display, description, location_description, latitude, longitude, &context).await
    }

    /// Create Region
    async fn create_region(
        &self,
        version: f64,
        account_id: i64,
        region_class: String,
        short_name: String,
        full_name: Option<String>,
        parent_ids: Option<String>,
        children_ids: Option<String>,
        postal_code_ids: Option<String>,
        locations: Option<String>,
        retailer_location_id: Option<i64>,
        visibility: Option<models::AddAlbumCollectionVisibilityParameter>,
        category_ids: Option<String>,
        filter_ids: Option<String>,
        start: Option<i64>,
        end: Option<i64>,
        polygon: Option<String>,
        meta_data: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        version_code: Option<i32>,
        root: Option<bool>,
        active: Option<bool>,
        ) -> Result<CreateRegionResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().create_region(version, account_id, region_class, short_name, full_name, parent_ids, children_ids, postal_code_ids, locations, retailer_location_id, visibility, category_ids, filter_ids, start, end, polygon, meta_data, latitude, longitude, version_code, root, active, &context).await
    }

    /// Delete Region
    async fn delete_region(
        &self,
        version: f64,
        account_id: i64,
        region_id: i64,
        ) -> Result<DeleteRegionResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().delete_region(version, account_id, region_id, &context).await
    }

    /// Get Region
    async fn get_region(
        &self,
        version: f64,
        region_id: i64,
        account_id: Option<i64>,
        ) -> Result<GetRegionResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_region(version, region_id, account_id, &context).await
    }

    /// Search Regions
    async fn search_regions(
        &self,
        version: f64,
        account_id: Option<i64>,
        query: Option<String>,
        keyword: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        range: Option<f64>,
        region_class: Option<models::SearchRegionsRegionClassParameter>,
        visibility: Option<models::AddAlbumCollectionVisibilityParameter>,
        search_mode: Option<models::SearchRegionsSearchModeParameter>,
        sort_field: Option<models::SearchRegionsSortFieldParameter>,
        descending: Option<bool>,
        include_parent: Option<bool>,
        include_children: Option<bool>,
        include_postal_codes: Option<bool>,
        category_ids: Option<String>,
        filter_ids: Option<String>,
        version_code: Option<i32>,
        active_only: Option<bool>,
        show_deleted: Option<bool>,
        last_updated_since: Option<i64>,
        start: Option<i32>,
        limit: Option<i32>,
        ) -> Result<SearchRegionsResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().search_regions(version, account_id, query, keyword, latitude, longitude, range, region_class, visibility, search_mode, sort_field, descending, include_parent, include_children, include_postal_codes, category_ids, filter_ids, version_code, active_only, show_deleted, last_updated_since, start, limit, &context).await
    }

    /// Update Region
    async fn update_region(
        &self,
        version: f64,
        account_id: i64,
        region_id: i64,
        region_class: Option<String>,
        short_name: Option<String>,
        full_name: Option<String>,
        parent_ids: Option<String>,
        children_ids: Option<String>,
        postal_code_ids: Option<String>,
        locations: Option<String>,
        retailer_location_id: Option<i64>,
        visibility: Option<models::AddAlbumCollectionVisibilityParameter>,
        category_ids: Option<String>,
        filter_ids: Option<String>,
        start: Option<i64>,
        end: Option<i64>,
        polygon: Option<String>,
        meta_data: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        version_code: Option<i32>,
        root: Option<bool>,
        active: Option<bool>,
        clear_lists: Option<bool>,
        ) -> Result<UpdateRegionResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().update_region(version, account_id, region_id, region_class, short_name, full_name, parent_ids, children_ids, postal_code_ids, locations, retailer_location_id, visibility, category_ids, filter_ids, start, end, polygon, meta_data, latitude, longitude, version_code, root, active, clear_lists, &context).await
    }

    /// Create Offline Report
    async fn create_batch(
        &self,
        version: f64,
        account_id: i64,
        status: models::CreateBatchStatusParameter,
        preview_limit: i32,
        app_key: Option<String>,
        endpoint: Option<String>,
        parameters: Option<String>,
        name: Option<String>,
        start_date: Option<i64>,
        end_date: Option<i64>,
        description: Option<String>,
        page_url: Option<String>,
        ) -> Result<CreateBatchResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().create_batch(version, account_id, status, preview_limit, app_key, endpoint, parameters, name, start_date, end_date, description, page_url, &context).await
    }

    /// Create Offline Report
    async fn create_region_leg_summary_batch<'a>(
        &self,
        version: f64,
        body: Option<&'a Vec<models::RegionLegSummary>>,
        ) -> Result<CreateRegionLegSummaryBatchResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().create_region_leg_summary_batch(version, body, &context).await
    }

    /// Delete Offline Report
    async fn delete_batch(
        &self,
        version: f64,
        account_id: i64,
        batch_id: i64,
        ) -> Result<DeleteBatchResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().delete_batch(version, account_id, batch_id, &context).await
    }

    /// Get Offline Report
    async fn get_report_batch(
        &self,
        version: f64,
        account_id: i64,
        batch_id: i64,
        all_results: bool,
        ) -> Result<GetReportBatchResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_report_batch(version, account_id, batch_id, all_results, &context).await
    }

    /// Run Report
    async fn run_report(
        &self,
        version: f64,
        desc: bool,
        account_id: Option<i64>,
        query: Option<String>,
        parameters: Option<String>,
        order: Option<String>,
        start: Option<i64>,
        limit: Option<i64>,
        response_format: Option<models::AggregatedFilteredUsageResponseFormatParameter>,
        ) -> Result<RunReportResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().run_report(version, desc, account_id, query, parameters, order, start, limit, response_format, &context).await
    }

    /// Search Offline Reports
    async fn search_batch(
        &self,
        version: f64,
        account_id: i64,
        start: i32,
        limit: i32,
        names: Option<String>,
        app_key: Option<String>,
        status: Option<models::CreateBatchStatusParameter>,
        global_app_search: Option<bool>,
        start_date: Option<i64>,
        end_date: Option<i64>,
        ) -> Result<SearchBatchResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().search_batch(version, account_id, start, limit, names, app_key, status, global_app_search, start_date, end_date, &context).await
    }

    /// Create Reservation
    async fn create_reservation(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        start_date: Option<i64>,
        end_date: Option<i64>,
        offer_id: Option<i64>,
        offer_location_id: Option<i64>,
        app_key: Option<String>,
        meta_data: Option<String>,
        ) -> Result<CreateReservationResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().create_reservation(version, device_id, account_id, start_date, end_date, offer_id, offer_location_id, app_key, meta_data, &context).await
    }

    /// Delete Reservation
    async fn delete_reservation(
        &self,
        version: f64,
        reservation_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        ) -> Result<DeleteReservationResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().delete_reservation(version, reservation_id, device_id, account_id, &context).await
    }

    /// Update Availability
    async fn reservable_availability(
        &self,
        version: f64,
        reservable_id: i64,
        reservable_type: models::SearchRatingIndexesRatableTypeParameter,
        device_id: Option<String>,
        account_id: Option<i64>,
        availability: Option<String>,
        availability_summary: Option<String>,
        ) -> Result<ReservableAvailabilityResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().reservable_availability(version, reservable_id, reservable_type, device_id, account_id, availability, availability_summary, &context).await
    }

    /// Search Availability
    async fn search_availability(
        &self,
        version: f64,
        reservable_id: i64,
        reservable_type: models::SearchRatingIndexesRatableTypeParameter,
        device_id: Option<String>,
        account_id: Option<i64>,
        start_date: Option<i64>,
        end_date: Option<i64>,
        start: Option<i32>,
        limit: Option<i32>,
        ) -> Result<SearchAvailabilityResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().search_availability(version, reservable_id, reservable_type, device_id, account_id, start_date, end_date, start, limit, &context).await
    }

    /// Search Reservations
    async fn search_reservations(
        &self,
        version: f64,
        device_id: Option<String>,
        app_key: Option<String>,
        account_id: Option<i64>,
        filter_account_id: Option<i64>,
        reservable_id: Option<i64>,
        reservable_type: Option<models::SearchRatingIndexesRatableTypeParameter>,
        keyword: Option<String>,
        start_date: Option<i64>,
        end_date: Option<i64>,
        start: Option<i32>,
        limit: Option<i32>,
        ) -> Result<SearchReservationsResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().search_reservations(version, device_id, app_key, account_id, filter_account_id, reservable_id, reservable_type, keyword, start_date, end_date, start, limit, &context).await
    }

    /// Search Schedule
    async fn search_schedule(
        &self,
        version: f64,
        reservable_id: i64,
        reservable_type: models::SearchRatingIndexesRatableTypeParameter,
        start_date: i64,
        end_date: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        time_bucket_mins: Option<i32>,
        ) -> Result<SearchScheduleResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().search_schedule(version, reservable_id, reservable_type, start_date, end_date, device_id, account_id, time_bucket_mins, &context).await
    }

    /// Create Retailer
    async fn create_retailer(
        &self,
        version: f64,
        name: String,
        device_id: Option<String>,
        account_id: Option<i64>,
        street_address: Option<String>,
        street_address2: Option<String>,
        city: Option<String>,
        state: Option<String>,
        postal_code: Option<String>,
        country: Option<String>,
        business_phone: Option<String>,
        business_phone_ext: Option<String>,
        website: Option<String>,
        email: Option<String>,
        facebook_url: Option<String>,
        twitter_url: Option<String>,
        logo: Option<swagger::ByteArray>,
        logo_asset_id: Option<i64>,
        picture1: Option<swagger::ByteArray>,
        picture1_asset_id: Option<i64>,
        picture2: Option<swagger::ByteArray>,
        picture2_asset_id: Option<i64>,
        category_ids: Option<String>,
        category_ids_to_add: Option<String>,
        category_ids_to_remove: Option<String>,
        filter_ids: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        meta_data: Option<String>,
        search_tags: Option<String>,
        retailer_type: Option<String>,
        visibility: Option<models::AddAlbumCollectionVisibilityParameter>,
        create_default_location: Option<bool>,
        response_format: Option<models::AggregatedFilteredUsageResponseFormatParameter>,
        ) -> Result<CreateRetailerResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().create_retailer(version, name, device_id, account_id, street_address, street_address2, city, state, postal_code, country, business_phone, business_phone_ext, website, email, facebook_url, twitter_url, logo, logo_asset_id, picture1, picture1_asset_id, picture2, picture2_asset_id, category_ids, category_ids_to_add, category_ids_to_remove, filter_ids, latitude, longitude, meta_data, search_tags, retailer_type, visibility, create_default_location, response_format, &context).await
    }

    /// Delete Retailer
    async fn delete_retailer(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        retailer_id: Option<i64>,
        ) -> Result<DeleteRetailerResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().delete_retailer(version, device_id, account_id, retailer_id, &context).await
    }

    /// Get Retailer
    async fn get_retailer(
        &self,
        version: f64,
        retailer_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        include_counts: Option<bool>,
        ) -> Result<GetRetailerResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_retailer(version, retailer_id, device_id, account_id, include_counts, &context).await
    }

    /// Search Retailers
    async fn get_retailers(
        &self,
        version: f64,
        visibility: models::AddAlbumCollectionVisibilityParameter,
        sort_field: models::GetRetailersSortFieldParameter,
        descending: bool,
        start: i32,
        limit: i32,
        active_only: bool,
        device_id: Option<String>,
        account_id: Option<i64>,
        q: Option<String>,
        keyword: Option<String>,
        category_ids: Option<String>,
        filter_ids: Option<String>,
        _i: Option<i32>,
        _l: Option<i32>,
        ) -> Result<GetRetailersResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_retailers(version, visibility, sort_field, descending, start, limit, active_only, device_id, account_id, q, keyword, category_ids, filter_ids, _i, _l, &context).await
    }

    /// Login Retailer
    async fn retailer_login_check(
        &self,
        version: f64,
        username: String,
        password: String,
        device_id: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        app_key: Option<String>,
        ) -> Result<RetailerLoginCheckResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().retailer_login_check(version, username, password, device_id, latitude, longitude, app_key, &context).await
    }

    /// Update Retailer
    async fn update_retailer(
        &self,
        version: f64,
        retailer_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        name: Option<String>,
        street_address: Option<String>,
        street_address2: Option<String>,
        city: Option<String>,
        state: Option<String>,
        postal_code: Option<String>,
        country: Option<String>,
        business_phone: Option<String>,
        business_phone_ext: Option<String>,
        website: Option<String>,
        email: Option<String>,
        facebook_url: Option<String>,
        twitter_url: Option<String>,
        logo: Option<swagger::ByteArray>,
        logo_asset_id: Option<i64>,
        picture1: Option<swagger::ByteArray>,
        picture1_asset_id: Option<i64>,
        picture2: Option<swagger::ByteArray>,
        picture2_asset_id: Option<i64>,
        category_ids: Option<String>,
        filter_ids: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        meta_data: Option<String>,
        search_tags: Option<String>,
        retailer_type: Option<String>,
        visibility: Option<models::AddAlbumCollectionVisibilityParameter>,
        active: Option<bool>,
        response_format: Option<models::AggregatedFilteredUsageResponseFormatParameter>,
        ) -> Result<UpdateRetailerResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().update_retailer(version, retailer_id, device_id, account_id, name, street_address, street_address2, city, state, postal_code, country, business_phone, business_phone_ext, website, email, facebook_url, twitter_url, logo, logo_asset_id, picture1, picture1_asset_id, picture2, picture2_asset_id, category_ids, filter_ids, latitude, longitude, meta_data, search_tags, retailer_type, visibility, active, response_format, &context).await
    }

    /// Create Retailer Location (Consumer)
    async fn create_retailer_location_consumer(
        &self,
        version: f64,
        app_key: String,
        name: String,
        device_id: Option<String>,
        account_id: Option<i64>,
        street_address: Option<String>,
        street_address2: Option<String>,
        city: Option<String>,
        state: Option<String>,
        postal_code: Option<String>,
        country: Option<String>,
        business_phone: Option<String>,
        business_phone_ext: Option<String>,
        website: Option<String>,
        email: Option<String>,
        details_header: Option<String>,
        details_body: Option<String>,
        hours: Option<String>,
        tags: Option<String>,
        logo_asset_id: Option<i64>,
        picture1_asset_id: Option<i64>,
        picture2_asset_id: Option<i64>,
        category_ids: Option<String>,
        filter_ids: Option<String>,
        meta_data: Option<String>,
        public_location: Option<bool>,
        active: Option<bool>,
        location_type: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        ) -> Result<CreateRetailerLocationConsumerResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().create_retailer_location_consumer(version, app_key, name, device_id, account_id, street_address, street_address2, city, state, postal_code, country, business_phone, business_phone_ext, website, email, details_header, details_body, hours, tags, logo_asset_id, picture1_asset_id, picture2_asset_id, category_ids, filter_ids, meta_data, public_location, active, location_type, latitude, longitude, &context).await
    }

    /// Create Retailer Location
    async fn create_retailer_locations(
        &self,
        version: f64,
        retailer_id: i64,
        name: String,
        street_address: String,
        city: String,
        state: String,
        postal_code: String,
        device_id: Option<String>,
        account_id: Option<i64>,
        street_address2: Option<String>,
        country: Option<String>,
        business_phone: Option<String>,
        business_phone_ext: Option<String>,
        website: Option<String>,
        email: Option<String>,
        internal_id: Option<String>,
        details_header: Option<String>,
        details_body: Option<String>,
        hours: Option<String>,
        logo: Option<swagger::ByteArray>,
        logo_asset_id: Option<i64>,
        picture1: Option<swagger::ByteArray>,
        picture1_asset_id: Option<i64>,
        picture2: Option<swagger::ByteArray>,
        picture2_asset_id: Option<i64>,
        category_ids: Option<String>,
        filter_ids: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        building: Option<String>,
        google_place_id: Option<String>,
        yelp_id: Option<String>,
        active: Option<bool>,
        public_location: Option<bool>,
        location_type: Option<String>,
        audience_ids: Option<String>,
        audience_ids_to_add: Option<String>,
        audience_ids_to_remove: Option<String>,
        response_format: Option<models::AggregatedFilteredUsageResponseFormatParameter>,
        response_includes: Option<String>,
        ) -> Result<CreateRetailerLocationsResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().create_retailer_locations(version, retailer_id, name, street_address, city, state, postal_code, device_id, account_id, street_address2, country, business_phone, business_phone_ext, website, email, internal_id, details_header, details_body, hours, logo, logo_asset_id, picture1, picture1_asset_id, picture2, picture2_asset_id, category_ids, filter_ids, latitude, longitude, building, google_place_id, yelp_id, active, public_location, location_type, audience_ids, audience_ids_to_add, audience_ids_to_remove, response_format, response_includes, &context).await
    }

    /// Delete Retailer Location
    async fn delete_retailer_location(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        retailer_location_id: Option<i64>,
        ) -> Result<DeleteRetailerLocationResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().delete_retailer_location(version, device_id, account_id, retailer_location_id, &context).await
    }

    /// Get Retailer Location
    async fn get_retailer_location(
        &self,
        version: f64,
        retailer_location_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        retailer_location_token: Option<String>,
        ) -> Result<GetRetailerLocationResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_retailer_location(version, retailer_location_id, device_id, account_id, retailer_location_token, &context).await
    }

    /// Get Retailer Location (Consumer)
    async fn get_retailer_location_consumer(
        &self,
        version: f64,
        retailer_location_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        ) -> Result<GetRetailerLocationConsumerResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_retailer_location_consumer(version, retailer_location_id, device_id, account_id, &context).await
    }

    /// Distance Search Retailer Locations (Indexed)
    async fn indexed_retailer_location_distance_search(
        &self,
        version: f64,
        latitude: f64,
        longitude: f64,
        search_range: f64,
        start: i32,
        limit: i32,
        account_id: Option<i64>,
        address: Option<String>,
        has_offers: Option<bool>,
        categories: Option<String>,
        filters: Option<String>,
        audiences: Option<String>,
        retailer_ids: Option<String>,
        retailer_location_ids: Option<String>,
        tags: Option<String>,
        location_type: Option<String>,
        sort_field: Option<String>,
        descending: Option<bool>,
        q: Option<String>,
        keyword: Option<String>,
        keyword_operator: Option<String>,
        search_expression: Option<String>,
        distance_unit: Option<models::SearchOffersForConsumerDistanceUnitParameter>,
        return_favorited: Option<bool>,
        return_retailer: Option<bool>,
        return_assets: Option<bool>,
        return_offers: Option<bool>,
        return_categories: Option<bool>,
        return_filters: Option<bool>,
        return_audiences: Option<bool>,
        return_qr_code: Option<bool>,
        return_external_category_data: Option<bool>,
        include_favorite: Option<bool>,
        include_liked: Option<bool>,
        include_rating: Option<bool>,
        ) -> Result<IndexedRetailerLocationDistanceSearchResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().indexed_retailer_location_distance_search(version, latitude, longitude, search_range, start, limit, account_id, address, has_offers, categories, filters, audiences, retailer_ids, retailer_location_ids, tags, location_type, sort_field, descending, q, keyword, keyword_operator, search_expression, distance_unit, return_favorited, return_retailer, return_assets, return_offers, return_categories, return_filters, return_audiences, return_qr_code, return_external_category_data, include_favorite, include_liked, include_rating, &context).await
    }

    /// Keyword Search Retailer Locations (Indexed)
    async fn indexed_retailer_location_search(
        &self,
        version: f64,
        account_id: Option<i64>,
        start: Option<i32>,
        limit: Option<i32>,
        has_offers: Option<bool>,
        categories: Option<String>,
        filters: Option<String>,
        audiences: Option<String>,
        retailer_ids: Option<String>,
        retailer_location_ids: Option<String>,
        tags: Option<String>,
        location_type: Option<String>,
        sort_field: Option<String>,
        descending: Option<bool>,
        q: Option<String>,
        keyword: Option<String>,
        keyword_operator: Option<String>,
        search_expression: Option<String>,
        return_retailer: Option<bool>,
        return_assets: Option<bool>,
        return_offers: Option<bool>,
        return_categories: Option<bool>,
        return_filters: Option<bool>,
        return_audiences: Option<bool>,
        return_qr_code: Option<bool>,
        return_external_category_data: Option<bool>,
        include_favorite: Option<bool>,
        include_liked: Option<bool>,
        include_rating: Option<bool>,
        ) -> Result<IndexedRetailerLocationSearchResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().indexed_retailer_location_search(version, account_id, start, limit, has_offers, categories, filters, audiences, retailer_ids, retailer_location_ids, tags, location_type, sort_field, descending, q, keyword, keyword_operator, search_expression, return_retailer, return_assets, return_offers, return_categories, return_filters, return_audiences, return_qr_code, return_external_category_data, include_favorite, include_liked, include_rating, &context).await
    }

    /// Search Retailer Locations (Owned)
    async fn search_retailer_locations(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        q: Option<String>,
        keyword: Option<String>,
        retailer_ids: Option<String>,
        retailer_location_ids: Option<String>,
        location_type: Option<String>,
        sort_field: Option<models::SearchRetailerLocationsSortFieldParameter>,
        descending: Option<bool>,
        _i: Option<i32>,
        start: Option<i32>,
        _l: Option<i32>,
        limit: Option<i32>,
        show_public_locations: Option<bool>,
        active_only: Option<bool>,
        return_retailer: Option<bool>,
        return_assets: Option<bool>,
        return_offers: Option<bool>,
        return_categories: Option<bool>,
        return_filters: Option<bool>,
        return_audiences: Option<bool>,
        return_qr_code: Option<bool>,
        include_favorite: Option<bool>,
        include_liked: Option<bool>,
        include_rating: Option<bool>,
        ) -> Result<SearchRetailerLocationsResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().search_retailer_locations(version, device_id, account_id, q, keyword, retailer_ids, retailer_location_ids, location_type, sort_field, descending, _i, start, _l, limit, show_public_locations, active_only, return_retailer, return_assets, return_offers, return_categories, return_filters, return_audiences, return_qr_code, include_favorite, include_liked, include_rating, &context).await
    }

    /// Update Retailer Location
    async fn update_retailer_locations(
        &self,
        version: f64,
        retailer_location_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        name: Option<String>,
        street_address: Option<String>,
        street_address2: Option<String>,
        city: Option<String>,
        state: Option<String>,
        postal_code: Option<String>,
        country: Option<String>,
        business_phone: Option<String>,
        business_phone_ext: Option<String>,
        website: Option<String>,
        email: Option<String>,
        internal_id: Option<String>,
        details_header: Option<String>,
        details_body: Option<String>,
        hours: Option<String>,
        logo: Option<swagger::ByteArray>,
        logo_asset_id: Option<i64>,
        picture1: Option<swagger::ByteArray>,
        picture1_asset_id: Option<i64>,
        picture2: Option<swagger::ByteArray>,
        picture2_asset_id: Option<i64>,
        category_ids: Option<String>,
        filter_ids: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        building: Option<String>,
        google_place_id: Option<String>,
        yelp_id: Option<String>,
        meta_data: Option<String>,
        payment_provider: Option<String>,
        active: Option<bool>,
        public_location: Option<bool>,
        location_type: Option<String>,
        audience_ids: Option<String>,
        audience_ids_to_add: Option<String>,
        audience_ids_to_remove: Option<String>,
        response_format: Option<models::AggregatedFilteredUsageResponseFormatParameter>,
        tags: Option<String>,
        ) -> Result<UpdateRetailerLocationsResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().update_retailer_locations(version, retailer_location_id, device_id, account_id, name, street_address, street_address2, city, state, postal_code, country, business_phone, business_phone_ext, website, email, internal_id, details_header, details_body, hours, logo, logo_asset_id, picture1, picture1_asset_id, picture2, picture2_asset_id, category_ids, filter_ids, latitude, longitude, building, google_place_id, yelp_id, meta_data, payment_provider, active, public_location, location_type, audience_ids, audience_ids_to_add, audience_ids_to_remove, response_format, tags, &context).await
    }

    /// Get Retailer
    async fn get_retaokiler(
        &self,
        version: f64,
        retailer_id: i64,
        active_only: bool,
        keyword: Option<String>,
        sort_field: Option<String>,
        start: Option<i64>,
        limit: Option<i64>,
        ) -> Result<GetRetaokilerResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_retaokiler(version, retailer_id, active_only, keyword, sort_field, start, limit, &context).await
    }

    /// Create Route
    async fn create_route(
        &self,
        version: f64,
        body: Option<models::Route>,
        ) -> Result<CreateRouteResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().create_route(version, body, &context).await
    }

    /// Search Routes
    async fn search_routes(
        &self,
        version: f64,
        sort_field: String,
        descending: bool,
        start: i32,
        limit: i32,
        active_only: bool,
        includes_empty: bool,
        root_only: bool,
        show_inherited_properties: bool,
        hub_id: Option<i64>,
        program_id: Option<i64>,
        scheduled_start: Option<i64>,
        scheduled_end: Option<i64>,
        updated_start: Option<i64>,
        updated_end: Option<i64>,
        featured: Option<bool>,
        seat_count: Option<i32>,
        approved: Option<bool>,
        started: Option<bool>,
        completed: Option<bool>,
        valid: Option<bool>,
        parent_id: Option<i64>,
        ) -> Result<SearchRoutesResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().search_routes(version, sort_field, descending, start, limit, active_only, includes_empty, root_only, show_inherited_properties, hub_id, program_id, scheduled_start, scheduled_end, updated_start, updated_end, featured, seat_count, approved, started, completed, valid, parent_id, &context).await
    }

    /// Approve Route
    async fn approve_route(
        &self,
        version: f64,
        route_id: i64,
        ) -> Result<ApproveRouteResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().approve_route(version, route_id, &context).await
    }

    /// Copy Route
    async fn copy_route(
        &self,
        version: f64,
        route_id: i64,
        body: Option<models::Route>,
        ) -> Result<CopyRouteResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().copy_route(version, route_id, body, &context).await
    }

    /// Update Route Directions
    async fn create_route_directions(
        &self,
        version: f64,
        route_id: i64,
        ) -> Result<CreateRouteDirectionsResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().create_route_directions(version, route_id, &context).await
    }

    /// Create Route Polyline
    async fn create_route_polyline(
        &self,
        version: f64,
        route_id: i64,
        ) -> Result<CreateRoutePolylineResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().create_route_polyline(version, route_id, &context).await
    }

    /// Delete Route
    async fn delete_route(
        &self,
        version: f64,
        route_id: i64,
        ) -> Result<DeleteRouteResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().delete_route(version, route_id, &context).await
    }

    /// Disapprove Route
    async fn disapprove_route(
        &self,
        version: f64,
        route_id: i64,
        ) -> Result<DisapproveRouteResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().disapprove_route(version, route_id, &context).await
    }

    /// Get Route
    async fn get_route(
        &self,
        version: f64,
        route_id: i64,
        show_inherited_properties: bool,
        ) -> Result<GetRouteResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_route(version, route_id, show_inherited_properties, &context).await
    }

    /// Get Route Directions
    async fn get_route_directions(
        &self,
        version: f64,
        route_id: i64,
        ) -> Result<GetRouteDirectionsResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_route_directions(version, route_id, &context).await
    }

    /// Get Route Shipments
    async fn get_route_shipments(
        &self,
        version: f64,
        route_id: i64,
        ) -> Result<GetRouteShipmentsResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_route_shipments(version, route_id, &context).await
    }

    /// Get Route Stops
    async fn get_route_stops(
        &self,
        version: f64,
        route_id: i64,
        confirmed_only: bool,
        ) -> Result<GetRouteStopsResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_route_stops(version, route_id, confirmed_only, &context).await
    }

    /// Optimize Route
    async fn optimize_route(
        &self,
        version: f64,
        route_id: i64,
        ) -> Result<OptimizeRouteResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().optimize_route(version, route_id, &context).await
    }

    /// Reorder Route Stops
    async fn reorder_route_stops_patch<'a>(
        &self,
        version: f64,
        route_id: i64,
        body: Option<&'a Vec<models::Stop>>,
        ) -> Result<ReorderRouteStopsPatchResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().reorder_route_stops_patch(version, route_id, body, &context).await
    }

    /// Reorder Route Stops
    async fn reorder_route_stops_post<'a>(
        &self,
        version: f64,
        route_id: i64,
        body: Option<&'a Vec<models::Stop>>,
        ) -> Result<ReorderRouteStopsPostResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().reorder_route_stops_post(version, route_id, body, &context).await
    }

    /// Update Route
    async fn update_route(
        &self,
        version: f64,
        route_id: i64,
        body: Option<models::Route>,
        ) -> Result<UpdateRouteResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().update_route(version, route_id, body, &context).await
    }

    /// Get Route Stop
    async fn get_route_stop(
        &self,
        version: f64,
        route_id: i64,
        stop_id: i64,
        ) -> Result<GetRouteStopResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_route_stop(version, route_id, stop_id, &context).await
    }

    /// Get Shipments At Stop
    async fn get_shipments_at_stop(
        &self,
        version: f64,
        route_id: i64,
        stop_id: i64,
        ) -> Result<GetShipmentsAtStopResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_shipments_at_stop(version, route_id, stop_id, &context).await
    }

    /// Delete Stop
    async fn remove_stop(
        &self,
        version: f64,
        route_id: i64,
        stop_id: i64,
        ) -> Result<RemoveStopResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().remove_stop(version, route_id, stop_id, &context).await
    }

    /// Set Driver
    async fn set_driver(
        &self,
        version: f64,
        id: i64,
        driver_id: i64,
        ) -> Result<SetDriverResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().set_driver(version, id, driver_id, &context).await
    }

    /// Update Route Stop
    async fn update_route_stop(
        &self,
        version: f64,
        route_id: i64,
        stop_id: i64,
        body: Option<models::Stop>,
        ) -> Result<UpdateRouteStopResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().update_route_stop(version, route_id, stop_id, body, &context).await
    }

    /// Create Route Setting
    async fn create_route_settings(
        &self,
        version: f64,
        body: Option<models::RouteSettings>,
        ) -> Result<CreateRouteSettingsResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().create_route_settings(version, body, &context).await
    }

    /// Search Route Settings
    async fn search_route_settings(
        &self,
        version: f64,
        sort_field: String,
        descending: bool,
        start: i32,
        limit: i32,
        active_only: bool,
        hub_id: Option<i64>,
        program_id: Option<i64>,
        keyword: Option<String>,
        ) -> Result<SearchRouteSettingsResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().search_route_settings(version, sort_field, descending, start, limit, active_only, hub_id, program_id, keyword, &context).await
    }

    /// Delete Route Setting
    async fn delete_route_settings(
        &self,
        version: f64,
        route_settings_id: i64,
        ) -> Result<DeleteRouteSettingsResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().delete_route_settings(version, route_settings_id, &context).await
    }

    /// Get Route Setting
    async fn get_route_settings(
        &self,
        version: f64,
        route_settings_id: i64,
        ) -> Result<GetRouteSettingsResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_route_settings(version, route_settings_id, &context).await
    }

    /// Update Route Setting
    async fn update_route_settings(
        &self,
        version: f64,
        route_settings_id: i64,
        body: Option<models::RouteSettings>,
        ) -> Result<UpdateRouteSettingsResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().update_route_settings(version, route_settings_id, body, &context).await
    }

    /// Compute Route
    async fn compute_routing(
        &self,
        version: f64,
        data: String,
        ) -> Result<ComputeRoutingResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().compute_routing(version, data, &context).await
    }

    /// Create Scheduled Notification
    async fn create_scheduled_notification(
        &self,
        version: f64,
        account_id: i64,
        name: String,
        param_type: String,
        message: String,
        content_id: Option<i64>,
        content_name: Option<String>,
        content_type: Option<String>,
        parent_id: Option<i64>,
        parent_type: Option<String>,
        app_key: Option<String>,
        grouping_id: Option<String>,
        connection_group_ids: Option<String>,
        connection_account_ids: Option<String>,
        audience_id: Option<i64>,
        audience_ids: Option<String>,
        album_ids: Option<String>,
        report_id: Option<i64>,
        report_params: Option<String>,
        endpoint_url: Option<String>,
        payload: Option<String>,
        scheduled_date: Option<i64>,
        start_date: Option<i64>,
        end_date: Option<i64>,
        cron_expression: Option<String>,
        cron_type: Option<String>,
        meta_data: Option<String>,
        conditional_input: Option<String>,
        template_type: Option<String>,
        visibility: Option<models::AddAlbumCollectionVisibilityParameter>,
        active: Option<bool>,
        send_now: Option<bool>,
        event_type: Option<String>,
        deep_link_uri: Option<String>,
        send_to_all: Option<bool>,
        ) -> Result<CreateScheduledNotificationResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().create_scheduled_notification(version, account_id, name, param_type, message, content_id, content_name, content_type, parent_id, parent_type, app_key, grouping_id, connection_group_ids, connection_account_ids, audience_id, audience_ids, album_ids, report_id, report_params, endpoint_url, payload, scheduled_date, start_date, end_date, cron_expression, cron_type, meta_data, conditional_input, template_type, visibility, active, send_now, event_type, deep_link_uri, send_to_all, &context).await
    }

    /// Delete Scheduled Notification
    async fn delete_scheduled_notification(
        &self,
        version: f64,
        account_id: i64,
        scheduled_notification_id: i64,
        delete_by_grouping_id: Option<bool>,
        ) -> Result<DeleteScheduledNotificationResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().delete_scheduled_notification(version, account_id, scheduled_notification_id, delete_by_grouping_id, &context).await
    }

    /// Get Scheduled Notification
    async fn get_scheduled_notification(
        &self,
        version: f64,
        account_id: i64,
        scheduled_notification_id: i64,
        ) -> Result<GetScheduledNotificationResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_scheduled_notification(version, account_id, scheduled_notification_id, &context).await
    }

    /// Generate Schedule Notifications
    async fn schedule_notification_listings(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        report_name: String,
        message: String,
        offset: i32,
        recipient_report_id: i64,
        report_params: Option<String>,
        param_type: Option<String>,
        ) -> Result<ScheduleNotificationListingsResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().schedule_notification_listings(version, account_id, app_key, report_name, message, offset, recipient_report_id, report_params, param_type, &context).await
    }

    /// Search Scheduled Notifications
    async fn search_scheduled_notifications(
        &self,
        version: f64,
        account_id: i64,
        grouping_id: Option<String>,
        audience_id: Option<i64>,
        filter: Option<String>,
        types: Option<String>,
        content_ids: Option<String>,
        content_types: Option<String>,
        parent_ids: Option<String>,
        parent_types: Option<String>,
        statuses: Option<String>,
        template_types: Option<String>,
        app_key: Option<String>,
        keyword: Option<String>,
        sort_field: Option<String>,
        descending: Option<bool>,
        start: Option<i32>,
        limit: Option<i32>,
        active_only: Option<bool>,
        group_by_grouping_id: Option<bool>,
        return_audience_account_count: Option<bool>,
        ) -> Result<SearchScheduledNotificationsResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().search_scheduled_notifications(version, account_id, grouping_id, audience_id, filter, types, content_ids, content_types, parent_ids, parent_types, statuses, template_types, app_key, keyword, sort_field, descending, start, limit, active_only, group_by_grouping_id, return_audience_account_count, &context).await
    }

    /// Update Scheduled Notification
    async fn update_scheduled_notification(
        &self,
        version: f64,
        scheduled_notification_id: i64,
        account_id: i64,
        name: Option<String>,
        param_type: Option<String>,
        message: Option<String>,
        payload: Option<String>,
        content_id: Option<i64>,
        content_name: Option<String>,
        content_type: Option<String>,
        parent_id: Option<i64>,
        parent_type: Option<String>,
        app_key: Option<String>,
        grouping_id: Option<String>,
        connection_group_ids: Option<String>,
        connection_account_ids: Option<String>,
        audience_id: Option<i64>,
        audience_ids: Option<String>,
        album_ids: Option<String>,
        report_id: Option<i64>,
        report_params: Option<String>,
        endpoint_url: Option<String>,
        scheduled_date: Option<i64>,
        start_date: Option<i64>,
        end_date: Option<i64>,
        cron_expression: Option<String>,
        cron_type: Option<String>,
        meta_data: Option<String>,
        conditional_input: Option<String>,
        template_type: Option<String>,
        visibility: Option<models::AddAlbumCollectionVisibilityParameter>,
        active: Option<bool>,
        error_message: Option<String>,
        status: Option<String>,
        update_by_grouping_id: Option<bool>,
        send_now: Option<bool>,
        event_type: Option<String>,
        deep_link_uri: Option<String>,
        send_to_all: Option<bool>,
        ) -> Result<UpdateScheduledNotificationResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().update_scheduled_notification(version, scheduled_notification_id, account_id, name, param_type, message, payload, content_id, content_name, content_type, parent_id, parent_type, app_key, grouping_id, connection_group_ids, connection_account_ids, audience_id, audience_ids, album_ids, report_id, report_params, endpoint_url, scheduled_date, start_date, end_date, cron_expression, cron_type, meta_data, conditional_input, template_type, visibility, active, error_message, status, update_by_grouping_id, send_now, event_type, deep_link_uri, send_to_all, &context).await
    }

    /// Create Score
    async fn create_score(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        points: i32,
        mission_id: Option<i64>,
        game_id: Option<i64>,
        pack_id: Option<i64>,
        game_level_id: Option<i64>,
        game_object_id: Option<i64>,
        time_taken: Option<i32>,
        highest: Option<bool>,
        ) -> Result<CreateScoreResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().create_score(version, account_id, app_key, points, mission_id, game_id, pack_id, game_level_id, game_object_id, time_taken, highest, &context).await
    }

    /// Get Score
    async fn get_score(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        mission_id: Option<i64>,
        game_id: Option<i64>,
        pack_id: Option<i64>,
        game_level_id: Option<i64>,
        game_object_id: Option<i64>,
        score_object_type: Option<String>,
        score_status: Option<String>,
        ) -> Result<GetScoreResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_score(version, account_id, app_key, mission_id, game_id, pack_id, game_level_id, game_object_id, score_object_type, score_status, &context).await
    }

    /// Search Score
    async fn search_scores(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        mission_id: Option<i64>,
        game_id: Option<i64>,
        pack_id: Option<i64>,
        game_level_id: Option<i64>,
        game_object_id: Option<i64>,
        ) -> Result<SearchScoresResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().search_scores(version, account_id, app_key, mission_id, game_id, pack_id, game_level_id, game_object_id, &context).await
    }

    /// Create Secure Application
    async fn create_secure_application(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        key_cert: swagger::ByteArray,
        trust_store: swagger::ByteArray,
        username: String,
        password: String,
        active: Option<bool>,
        biometric_type: Option<models::CreateSecureApplicationBiometricTypeParameter>,
        biometric_position: Option<models::CreateSecureApplicationBiometricPositionParameter>,
        biometric_position2: Option<models::CreateSecureApplicationBiometricPositionParameter>,
        ) -> Result<CreateSecureApplicationResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().create_secure_application(version, account_id, app_key, key_cert, trust_store, username, password, active, biometric_type, biometric_position, biometric_position2, &context).await
    }

    /// Delete Secure Application
    async fn delete_secure_application(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        ) -> Result<DeleteSecureApplicationResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().delete_secure_application(version, account_id, app_key, &context).await
    }

    /// Login Clear
    async fn login_secure(
        &self,
        version: f64,
        app_key: String,
        biometric_file: swagger::ByteArray,
        device_id: Option<String>,
        biometric_file2: Option<swagger::ByteArray>,
        age_restriction: Option<i32>,
        return_profile: Option<bool>,
        response_filters: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        ) -> Result<LoginSecureResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().login_secure(version, app_key, biometric_file, device_id, biometric_file2, age_restriction, return_profile, response_filters, latitude, longitude, &context).await
    }

    /// Purchase Clear
    async fn purchase_secure(
        &self,
        version: f64,
        body: models::PaymentRequest,
        ) -> Result<PurchaseSecureResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().purchase_secure(version, body, &context).await
    }

    /// Rest Secure Application
    async fn reset_secure(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        ) -> Result<ResetSecureResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().reset_secure(version, account_id, app_key, &context).await
    }

    /// Update Secure Application
    async fn update_secure_application(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        active: Option<bool>,
        key_cert: Option<swagger::ByteArray>,
        trust_store: Option<swagger::ByteArray>,
        username: Option<String>,
        password: Option<String>,
        biometric_type: Option<models::UpdateSecureApplicationBiometricTypeParameter>,
        biometric_position: Option<models::UpdateSecureApplicationBiometricPositionParameter>,
        biometric_position2: Option<models::UpdateSecureApplicationBiometricPositionParameter>,
        ) -> Result<UpdateSecureApplicationResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().update_secure_application(version, account_id, app_key, active, key_cert, trust_store, username, password, biometric_type, biometric_position, biometric_position2, &context).await
    }

    /// Create Service Hub
    async fn create_service_hub(
        &self,
        version: f64,
        body: Option<models::ServiceHub>,
        ) -> Result<CreateServiceHubResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().create_service_hub(version, body, &context).await
    }

    /// Search Service Hubs
    async fn search_service_hubs(
        &self,
        version: f64,
        sort_field: String,
        descending: bool,
        start: i32,
        limit: i32,
        active_only: bool,
        keyword: Option<String>,
        retailer_id: Option<i64>,
        ) -> Result<SearchServiceHubsResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().search_service_hubs(version, sort_field, descending, start, limit, active_only, keyword, retailer_id, &context).await
    }

    /// Delete Service Hub
    async fn delete_service_hub(
        &self,
        version: f64,
        id: i64,
        ) -> Result<DeleteServiceHubResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().delete_service_hub(version, id, &context).await
    }

    /// Get Service Hub
    async fn get_service_hub(
        &self,
        version: f64,
        id: i64,
        ) -> Result<GetServiceHubResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_service_hub(version, id, &context).await
    }

    /// Update Service Hub
    async fn post_service_hub(
        &self,
        version: f64,
        id: i64,
        body: Option<models::ServiceHub>,
        ) -> Result<PostServiceHubResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().post_service_hub(version, id, body, &context).await
    }

    /// Update Service Hub
    async fn put_service_hub(
        &self,
        version: f64,
        id: i64,
        body: Option<models::ServiceHub>,
        ) -> Result<PutServiceHubResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().put_service_hub(version, id, body, &context).await
    }

    /// Create Shipment
    async fn create_shipment(
        &self,
        version: f64,
        body: Option<models::Shipment>,
        ) -> Result<CreateShipmentResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().create_shipment(version, body, &context).await
    }

    /// Search Shipments
    async fn search_shipments(
        &self,
        version: f64,
        sort_field: String,
        descending: bool,
        start: i32,
        limit: i32,
        active_only: bool,
        owner_id: Option<i64>,
        rider_id: Option<i64>,
        route_id: Option<i64>,
        ) -> Result<SearchShipmentsResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().search_shipments(version, sort_field, descending, start, limit, active_only, owner_id, rider_id, route_id, &context).await
    }

    /// Cancel Shipment
    async fn cancel_shipment(
        &self,
        version: f64,
        id: i64,
        ) -> Result<CancelShipmentResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().cancel_shipment(version, id, &context).await
    }

    /// Delete Shipment
    async fn delete_shipment(
        &self,
        version: f64,
        id: i64,
        ) -> Result<DeleteShipmentResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().delete_shipment(version, id, &context).await
    }

    /// Get Shipment
    async fn get_shipment(
        &self,
        version: f64,
        id: i64,
        ) -> Result<GetShipmentResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_shipment(version, id, &context).await
    }

    /// Update Shipment
    async fn update_shipment(
        &self,
        version: f64,
        id: i64,
        body: Option<models::Shipment>,
        ) -> Result<UpdateShipmentResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().update_shipment(version, id, body, &context).await
    }

    /// Uupdate Shipment Status
    async fn update_shipment_status(
        &self,
        version: f64,
        id: i64,
        body: Option<std::collections::HashMap<String, bool>>,
        ) -> Result<UpdateShipmentStatusResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().update_shipment_status(version, id, body, &context).await
    }

    /// Create Shipment Batch
    async fn create_shipment_batch(
        &self,
        version: f64,
        body: Option<models::ShipmentBatch>,
        ) -> Result<CreateShipmentBatchResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().create_shipment_batch(version, body, &context).await
    }

    /// Search Shipment Batch
    async fn search_shipment_batch(
        &self,
        version: f64,
        hub_id: i64,
        sort_field: String,
        descending: bool,
        start: i32,
        limit: i32,
        ) -> Result<SearchShipmentBatchResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().search_shipment_batch(version, hub_id, sort_field, descending, start, limit, &context).await
    }

    /// Delete Shipment Batch
    async fn delete_shipment_batch(
        &self,
        version: f64,
        batch_id: i64,
        ) -> Result<DeleteShipmentBatchResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().delete_shipment_batch(version, batch_id, &context).await
    }

    /// Get Shipment Batch
    async fn get_shipment_batch(
        &self,
        version: f64,
        batch_id: i64,
        ) -> Result<GetShipmentBatchResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_shipment_batch(version, batch_id, &context).await
    }

    /// Get Shipment Batch Status
    async fn get_shipment_batch_status(
        &self,
        version: f64,
        batch_id: i64,
        account_id: i64,
        sort_field: String,
        descending: bool,
        start: i32,
        limit: i32,
        valid: Option<bool>,
        started: Option<bool>,
        completed: Option<bool>,
        has_shipment: Option<bool>,
        has_route: Option<bool>,
        keyword: Option<String>,
        ) -> Result<GetShipmentBatchStatusResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_shipment_batch_status(version, batch_id, account_id, sort_field, descending, start, limit, valid, started, completed, has_shipment, has_route, keyword, &context).await
    }

    /// Routing Simulation
    async fn simulation(
        &self,
        version: f64,
        data: String,
        real_time: bool,
        ) -> Result<SimulationResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().simulation(version, data, real_time, &context).await
    }

    /// Get Stop
    async fn get_stop(
        &self,
        version: f64,
        id: i64,
        ) -> Result<GetStopResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_stop(version, id, &context).await
    }

    /// Update Stop
    async fn update_stop(
        &self,
        version: f64,
        id: i64,
        body: Option<models::Stop>,
        ) -> Result<UpdateStopResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().update_stop(version, id, body, &context).await
    }

    /// Create Stripe Checkout Session
    async fn create_stripe_checkout_session(
        &self,
        version: f64,
        app_key: String,
        stripe_parameters: String,
        ) -> Result<CreateStripeCheckoutSessionResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().create_stripe_checkout_session(version, app_key, stripe_parameters, &context).await
    }

    /// Create Subscription
    async fn create_subscription(
        &self,
        version: f64,
        account_id: i64,
        plan_id: Option<i64>,
        promo_code: Option<String>,
        ) -> Result<CreateSubscriptionResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().create_subscription(version, account_id, plan_id, promo_code, &context).await
    }

    /// Delete Subscription
    async fn delete_subscription(
        &self,
        version: f64,
        account_id: i64,
        ) -> Result<DeleteSubscriptionResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().delete_subscription(version, account_id, &context).await
    }

    /// Get Subscription
    async fn get_subscription(
        &self,
        version: f64,
        account_id: i64,
        ) -> Result<GetSubscriptionResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_subscription(version, account_id, &context).await
    }

    /// Get Subscription Plan
    async fn get_subscription_plan(
        &self,
        version: f64,
        plan_id: i64,
        ) -> Result<GetSubscriptionPlanResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_subscription_plan(version, plan_id, &context).await
    }

    /// List Subscription Plans
    async fn get_subscription_plans(
        &self,
        version: f64,
        visible: Option<bool>,
        role: Option<String>,
        ) -> Result<GetSubscriptionPlansResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_subscription_plans(version, visible, role, &context).await
    }

    /// Get Subscription Usage
    async fn get_subscription_usage(
        &self,
        version: f64,
        account_id: i64,
        application_id: Option<i64>,
        start: Option<i64>,
        end: Option<i64>,
        ) -> Result<GetSubscriptionUsageResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_subscription_usage(version, account_id, application_id, start, end, &context).await
    }

    /// Update Subscription
    async fn update_subscription(
        &self,
        version: f64,
        account_id: i64,
        plan_id: Option<i64>,
        promo_code: Option<String>,
        active: Option<bool>,
        ) -> Result<UpdateSubscriptionResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().update_subscription(version, account_id, plan_id, promo_code, active, &context).await
    }

    /// Create Task
    async fn create_task(
        &self,
        version: f64,
        account_id: i64,
        name: String,
        app_key: Option<String>,
        grouping_id: Option<String>,
        endpoint_url: Option<String>,
        payload: Option<String>,
        scheduled_date: Option<i64>,
        start_date: Option<i64>,
        end_date: Option<i64>,
        cron_expression: Option<String>,
        visibility: Option<models::AddAlbumCollectionVisibilityParameter>,
        active: Option<bool>,
        ) -> Result<CreateTaskResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().create_task(version, account_id, name, app_key, grouping_id, endpoint_url, payload, scheduled_date, start_date, end_date, cron_expression, visibility, active, &context).await
    }

    /// Delete Task
    async fn delete_task(
        &self,
        version: f64,
        account_id: i64,
        task_id: i64,
        ) -> Result<DeleteTaskResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().delete_task(version, account_id, task_id, &context).await
    }

    /// Get Task
    async fn get_task(
        &self,
        version: f64,
        account_id: i64,
        task_id: i64,
        ) -> Result<GetTaskResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_task(version, account_id, task_id, &context).await
    }

    /// Search Tasks
    async fn search_tasks(
        &self,
        version: f64,
        account_id: i64,
        grouping_id: Option<String>,
        filter: Option<String>,
        statuses: Option<String>,
        template_types: Option<String>,
        app_key: Option<String>,
        keyword: Option<String>,
        sort_field: Option<String>,
        descending: Option<bool>,
        start: Option<i32>,
        limit: Option<i32>,
        active_only: Option<bool>,
        ) -> Result<SearchTasksResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().search_tasks(version, account_id, grouping_id, filter, statuses, template_types, app_key, keyword, sort_field, descending, start, limit, active_only, &context).await
    }

    /// Update Task
    async fn update_task(
        &self,
        version: f64,
        task_id: i64,
        account_id: i64,
        name: Option<String>,
        app_key: Option<String>,
        grouping_id: Option<String>,
        endpoint_url: Option<String>,
        payload: Option<String>,
        scheduled_date: Option<i64>,
        start_date: Option<i64>,
        end_date: Option<i64>,
        cron_expression: Option<String>,
        visibility: Option<models::AddAlbumCollectionVisibilityParameter>,
        active: Option<bool>,
        ) -> Result<UpdateTaskResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().update_task(version, task_id, account_id, name, app_key, grouping_id, endpoint_url, payload, scheduled_date, start_date, end_date, cron_expression, visibility, active, &context).await
    }

    /// Create Territory
    async fn create_territory(
        &self,
        version: f64,
        account_id: i64,
        name: String,
        active: Option<bool>,
        ) -> Result<CreateTerritoryResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().create_territory(version, account_id, name, active, &context).await
    }

    /// Delete Territory
    async fn delete_territory(
        &self,
        version: f64,
        account_id: i64,
        territory_id: i64,
        ) -> Result<DeleteTerritoryResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().delete_territory(version, account_id, territory_id, &context).await
    }

    /// Get Territory
    async fn get_territory(
        &self,
        version: f64,
        territory_id: i64,
        ) -> Result<GetTerritoryResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_territory(version, territory_id, &context).await
    }

    /// Search Territories
    async fn search_territories(
        &self,
        version: f64,
        sort_field: models::SearchTerritoriesSortFieldParameter,
        descending: bool,
        keyword: Option<String>,
        start: Option<i32>,
        limit: Option<i32>,
        ) -> Result<SearchTerritoriesResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().search_territories(version, sort_field, descending, keyword, start, limit, &context).await
    }

    /// Update Territory
    async fn update_territory(
        &self,
        version: f64,
        account_id: i64,
        territory_id: i64,
        name: Option<String>,
        active: Option<bool>,
        ) -> Result<UpdateTerritoryResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().update_territory(version, account_id, territory_id, name, active, &context).await
    }

    /// Create/Update Theme
    async fn add_or_update_theme_descriptor(
        &self,
        version: f64,
        public_read: bool,
        public_write: bool,
        public_delete: bool,
        public_add: bool,
        visibility: models::AddAlbumCollectionVisibilityParameter,
        include_friend_group: bool,
        complete_with_default_values: bool,
        device_id: Option<String>,
        account_id: Option<i64>,
        game_type: Option<String>,
        theme_descriptor_id: Option<i64>,
        title: Option<String>,
        description: Option<String>,
        connection_ids_to_add: Option<String>,
        connection_group_ids_to_add: Option<String>,
        app_version: Option<String>,
        color_value_json: Option<String>,
        string_replacer_json: Option<String>,
        custom_json_objects: Option<String>,
        icon_image: Option<swagger::ByteArray>,
        scene_atlas_image: Option<swagger::ByteArray>,
        bg_image: Option<swagger::ByteArray>,
        bg_sound: Option<swagger::ByteArray>,
        music_selection: Option<String>,
        location_description: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        ) -> Result<AddOrUpdateThemeDescriptorResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().add_or_update_theme_descriptor(version, public_read, public_write, public_delete, public_add, visibility, include_friend_group, complete_with_default_values, device_id, account_id, game_type, theme_descriptor_id, title, description, connection_ids_to_add, connection_group_ids_to_add, app_version, color_value_json, string_replacer_json, custom_json_objects, icon_image, scene_atlas_image, bg_image, bg_sound, music_selection, location_description, latitude, longitude, &context).await
    }

    /// Get Theme
    async fn get_theme_descriptor(
        &self,
        version: f64,
        theme_descriptor_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        game_type: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        ) -> Result<GetThemeDescriptorResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_theme_descriptor(version, theme_descriptor_id, device_id, account_id, game_type, latitude, longitude, &context).await
    }

    /// Search Themes
    async fn get_theme_descriptors(
        &self,
        version: f64,
        filter: String,
        sort_field: String,
        descending: bool,
        start: i32,
        limit: i32,
        device_id: Option<String>,
        account_id: Option<i64>,
        game_type: Option<String>,
        contest_type: Option<String>,
        owner_id: Option<i64>,
        q: Option<String>,
        keyword: Option<String>,
        _i: Option<i32>,
        _l: Option<i32>,
        date_created: Option<i64>,
        app_version: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        ) -> Result<GetThemeDescriptorsResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_theme_descriptors(version, filter, sort_field, descending, start, limit, device_id, account_id, game_type, contest_type, owner_id, q, keyword, _i, _l, date_created, app_version, latitude, longitude, &context).await
    }

    /// Delete Theme
    async fn remove_theme_descriptor(
        &self,
        version: f64,
        theme_descriptor_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        game_type: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        ) -> Result<RemoveThemeDescriptorResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().remove_theme_descriptor(version, theme_descriptor_id, device_id, account_id, game_type, latitude, longitude, &context).await
    }

    /// Create Credential
    async fn create_credential(
        &self,
        version: f64,
        third_party_id: String,
        third_party_token: String,
        network_uid: String,
        app_key: String,
        account_id: Option<i64>,
        device_id: Option<String>,
        session_id: Option<String>,
        third_party_name: Option<String>,
        email_address: Option<String>,
        signin_only_mode: Option<bool>,
        response_filters: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        meta_data: Option<String>,
        third_party_refresh_token: Option<String>,
        audience_ids_to_add: Option<String>,
        audience_ids_to_remove: Option<String>,
        ) -> Result<CreateCredentialResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().create_credential(version, third_party_id, third_party_token, network_uid, app_key, account_id, device_id, session_id, third_party_name, email_address, signin_only_mode, response_filters, latitude, longitude, meta_data, third_party_refresh_token, audience_ids_to_add, audience_ids_to_remove, &context).await
    }

    /// Create Network
    async fn create_network(
        &self,
        version: f64,
        account_id: i64,
        name: String,
        enable_introspection: bool,
        description: Option<String>,
        introspection_method: Option<String>,
        introspection_url: Option<String>,
        introspection_params: Option<String>,
        required_root_field: Option<String>,
        enable_mfa: Option<bool>,
        size_mfa: Option<i32>,
        shelf_life_mfa: Option<i32>,
        oauth_token_url: Option<String>,
        oauth_private_key: Option<swagger::ByteArray>,
        oauth_public_key: Option<swagger::ByteArray>,
        oauth_client_id: Option<String>,
        oauth_secret_key: Option<String>,
        body: Option<String>,
        ) -> Result<CreateNetworkResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().create_network(version, account_id, name, enable_introspection, description, introspection_method, introspection_url, introspection_params, required_root_field, enable_mfa, size_mfa, shelf_life_mfa, oauth_token_url, oauth_private_key, oauth_public_key, oauth_client_id, oauth_secret_key, body, &context).await
    }

    /// Delete Credential
    async fn delete_credential(
        &self,
        version: f64,
        account_id: i64,
        network_uid: String,
        third_party_id: String,
        app_key: String,
        ) -> Result<DeleteCredentialResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().delete_credential(version, account_id, network_uid, third_party_id, app_key, &context).await
    }

    /// Delete Network
    async fn delete_network(
        &self,
        version: f64,
        account_id: i64,
        network_uid: String,
        ) -> Result<DeleteNetworkResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().delete_network(version, account_id, network_uid, &context).await
    }

    /// Get Credential
    async fn get_credential(
        &self,
        version: f64,
        network_uid: String,
        app_key: String,
        account_id: Option<i64>,
        device_id: Option<String>,
        session_id: Option<String>,
        third_party_credential_id: Option<i64>,
        third_party_token: Option<String>,
        third_party_secret: Option<String>,
        create_new_account: Option<bool>,
        response_filters: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        audience_ids_to_add: Option<String>,
        audience_ids_to_remove: Option<String>,
        referral_account_id: Option<i64>,
        ) -> Result<GetCredentialResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_credential(version, network_uid, app_key, account_id, device_id, session_id, third_party_credential_id, third_party_token, third_party_secret, create_new_account, response_filters, latitude, longitude, audience_ids_to_add, audience_ids_to_remove, referral_account_id, &context).await
    }

    /// Get Network
    async fn get_network(
        &self,
        version: f64,
        account_id: i64,
        network_uid: String,
        ) -> Result<GetNetworkResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_network(version, account_id, network_uid, &context).await
    }

    /// Search Credentials
    async fn search_credentials(
        &self,
        version: f64,
        account_id: i64,
        keyword: Option<String>,
        network_uid: Option<String>,
        descending: Option<bool>,
        start: Option<i32>,
        limit: Option<i32>,
        ) -> Result<SearchCredentialsResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().search_credentials(version, account_id, keyword, network_uid, descending, start, limit, &context).await
    }

    /// Search Networks
    async fn search_networks(
        &self,
        version: f64,
        account_id: i64,
        sort_field: models::SearchNetworksSortFieldParameter,
        descending: bool,
        start: i32,
        limit: i32,
        active_only: bool,
        keyword: Option<String>,
        filter_billable: Option<bool>,
        ) -> Result<SearchNetworksResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().search_networks(version, account_id, sort_field, descending, start, limit, active_only, keyword, filter_billable, &context).await
    }

    /// Send MFA Challenge
    async fn send_mfa_challenge(
        &self,
        version: f64,
        network_uid: String,
        app_key: String,
        third_party_token: Option<String>,
        third_party_credential_id: Option<i64>,
        device_id: Option<String>,
        ) -> Result<SendMfaChallengeResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().send_mfa_challenge(version, network_uid, app_key, third_party_token, third_party_credential_id, device_id, &context).await
    }

    /// Update Credential
    async fn update_credential(
        &self,
        version: f64,
        network_uid: String,
        third_party_id: String,
        app_key: String,
        device_id: Option<String>,
        third_party_name: Option<String>,
        third_party_token: Option<String>,
        response_filters: Option<String>,
        meta_data: Option<String>,
        third_party_refresh_token: Option<String>,
        ) -> Result<UpdateCredentialResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().update_credential(version, network_uid, third_party_id, app_key, device_id, third_party_name, third_party_token, response_filters, meta_data, third_party_refresh_token, &context).await
    }

    /// Update Network
    async fn update_network(
        &self,
        version: f64,
        account_id: i64,
        network_uid: String,
        name: Option<String>,
        description: Option<String>,
        enable_introspection: Option<bool>,
        introspection_method: Option<String>,
        introspection_url: Option<String>,
        introspection_params: Option<String>,
        required_root_field: Option<String>,
        enable_mfa: Option<bool>,
        size_mfa: Option<i32>,
        shelf_life_mfa: Option<i32>,
        oauth_token_url: Option<String>,
        oauth_private_key: Option<swagger::ByteArray>,
        oauth_public_key: Option<swagger::ByteArray>,
        oauth_client_id: Option<String>,
        oauth_secret_key: Option<String>,
        body: Option<String>,
        ) -> Result<UpdateNetworkResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().update_network(version, account_id, network_uid, name, description, enable_introspection, introspection_method, introspection_url, introspection_params, required_root_field, enable_mfa, size_mfa, shelf_life_mfa, oauth_token_url, oauth_private_key, oauth_public_key, oauth_client_id, oauth_secret_key, body, &context).await
    }

    /// Get Ticket Count
    async fn get_ticket_count(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        game_type: Option<String>,
        app_key: Option<String>,
        ticket_type: Option<String>,
        ) -> Result<GetTicketCountResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_ticket_count(version, device_id, account_id, game_type, app_key, ticket_type, &context).await
    }

    /// Get Ticket List
    async fn get_ticket_list(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        ticket_object_type: Option<String>,
        action_type: Option<String>,
        ticket_ids: Option<String>,
        object_ids: Option<String>,
        receipt_tokens: Option<String>,
        game_type: Option<String>,
        app_key: Option<String>,
        ) -> Result<GetTicketListResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_ticket_list(version, device_id, account_id, ticket_object_type, action_type, ticket_ids, object_ids, receipt_tokens, game_type, app_key, &context).await
    }

    /// Gift Tickets
    async fn gift_purchase(
        &self,
        version: f64,
        receiver_account_id: i64,
        ticket_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        asset_id: Option<i64>,
        custom_message: Option<String>,
        game_type: Option<String>,
        app_key: Option<String>,
        ) -> Result<GiftPurchaseResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().gift_purchase(version, receiver_account_id, ticket_id, device_id, account_id, asset_id, custom_message, game_type, app_key, &context).await
    }

    /// Save Ticket
    async fn save_ticket(
        &self,
        version: f64,
        action_type: String,
        ticket_object_type: String,
        return_nulls: Option<bool>,
        device_id: Option<String>,
        account_id: Option<i64>,
        game_type: Option<String>,
        app_key: Option<String>,
        object_id: Option<i64>,
        purchase_code: Option<String>,
        receipt_token: Option<String>,
        receipt_data: Option<String>,
        count: Option<i64>,
        ticket_type: Option<String>,
        purchase_provider: Option<String>,
        purchase_type: Option<String>,
        return_profile_response: Option<bool>,
        include_profile_response: Option<bool>,
        app_version: Option<String>,
        ) -> Result<SaveTicketResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().save_ticket(version, action_type, ticket_object_type, return_nulls, device_id, account_id, game_type, app_key, object_id, purchase_code, receipt_token, receipt_data, count, ticket_type, purchase_provider, purchase_type, return_profile_response, include_profile_response, app_version, &context).await
    }

    /// Save Ticket with Reciept
    async fn save_ticket_via_file_upload(
        &self,
        version: f64,
        action_type: String,
        ticket_object_type: String,
        receipt_data: swagger::ByteArray,
        return_nulls: Option<bool>,
        device_id: Option<String>,
        account_id: Option<i64>,
        game_type: Option<String>,
        app_key: Option<String>,
        object_id: Option<i64>,
        purchase_code: Option<String>,
        receipt_token: Option<String>,
        count: Option<i64>,
        ticket_type: Option<String>,
        purchase_provider: Option<String>,
        purchase_type: Option<String>,
        return_profile_response: Option<bool>,
        include_profile_response: Option<bool>,
        app_version: Option<String>,
        ) -> Result<SaveTicketViaFileUploadResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().save_ticket_via_file_upload(version, action_type, ticket_object_type, receipt_data, return_nulls, device_id, account_id, game_type, app_key, object_id, purchase_code, receipt_token, count, ticket_type, purchase_provider, purchase_type, return_profile_response, include_profile_response, app_version, &context).await
    }

    /// Get Ticket Offers
    async fn ticket_offers(
        &self,
        version: f64,
        ) -> Result<TicketOffersResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().ticket_offers(version, &context).await
    }

    /// Create Tournament
    async fn create_tournament(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        title: String,
        cost_to_play: i32,
        start_date: i64,
        sub_type: Option<String>,
        image_asset_id: Option<i64>,
        seconds_between_levels: Option<i32>,
        seconds_for_tie_breaker: Option<i32>,
        seconds_between_packs: Option<i32>,
        maximum_level_length: Option<i32>,
        cost_to_play_type: Option<String>,
        minimum_to_play: Option<i32>,
        starting_limit: Option<i32>,
        available_limit: Option<i32>,
        description: Option<String>,
        meta_data: Option<String>,
        audience_ids: Option<String>,
        active: Option<bool>,
        enable_buy_back: Option<bool>,
        offer_ids: Option<String>,
        offer_asset_id: Option<i64>,
        fixed_reward: Option<bool>,
        split_reward: Option<models::CreateTournamentSplitRewardParameter>,
        allocate_tickets: Option<bool>,
        tournament_data: Option<String>,
        mission_type: Option<models::CreateTournamentMissionTypeParameter>,
        visibility: Option<models::CreateTournamentVisibilityParameter>,
        preliminary_groups: Option<i32>,
        preliminary_group_advancements: Option<String>,
        enable_multiple_entries: Option<bool>,
        enable_multiple_votes: Option<bool>,
        featured: Option<bool>,
        winner_tag: Option<String>,
        tie_tag: Option<String>,
        ) -> Result<CreateTournamentResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().create_tournament(version, account_id, app_key, title, cost_to_play, start_date, sub_type, image_asset_id, seconds_between_levels, seconds_for_tie_breaker, seconds_between_packs, maximum_level_length, cost_to_play_type, minimum_to_play, starting_limit, available_limit, description, meta_data, audience_ids, active, enable_buy_back, offer_ids, offer_asset_id, fixed_reward, split_reward, allocate_tickets, tournament_data, mission_type, visibility, preliminary_groups, preliminary_group_advancements, enable_multiple_entries, enable_multiple_votes, featured, winner_tag, tie_tag, &context).await
    }

    /// Delete Tournament
    async fn delete_tournament(
        &self,
        version: f64,
        account_id: i64,
        mission_id: i64,
        ) -> Result<DeleteTournamentResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().delete_tournament(version, account_id, mission_id, &context).await
    }

    /// Get Tournament
    async fn get_tournament(
        &self,
        version: f64,
        account_id: i64,
        mission_id: Option<i64>,
        join_code: Option<String>,
        include_scores: Option<models::GetTournamentIncludeScoresParameter>,
        object_preview_size: Option<i32>,
        ) -> Result<GetTournamentResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_tournament(version, account_id, mission_id, join_code, include_scores, object_preview_size, &context).await
    }

    /// Search Tournament Objects
    async fn search_objects(
        &self,
        version: f64,
        account_id: i64,
        game_level_id: i64,
        sort_field: Option<models::SearchObjectsSortFieldParameter>,
        descending: Option<bool>,
        start: Option<i32>,
        limit: Option<i32>,
        ) -> Result<SearchObjectsResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().search_objects(version, account_id, game_level_id, sort_field, descending, start, limit, &context).await
    }

    /// Search Tournament Rounds
    async fn search_rounds(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        status: Option<String>,
        mission_type: Option<models::SearchRoundsMissionTypeParameter>,
        current_only: Option<bool>,
        visibilities: Option<String>,
        start: Option<i32>,
        limit: Option<i32>,
        ) -> Result<SearchRoundsResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().search_rounds(version, account_id, app_key, status, mission_type, current_only, visibilities, start, limit, &context).await
    }

    /// Search Tournaments
    async fn search_tournaments(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        keyword: Option<String>,
        sub_type: Option<String>,
        include_inactive: Option<bool>,
        mission_types: Option<String>,
        filter: Option<models::SearchTournamentsFilterParameter>,
        sort_field: Option<models::SearchTournamentsSortFieldParameter>,
        descending: Option<bool>,
        visibility: Option<String>,
        start: Option<i32>,
        limit: Option<i32>,
        ) -> Result<SearchTournamentsResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().search_tournaments(version, account_id, app_key, keyword, sub_type, include_inactive, mission_types, filter, sort_field, descending, visibility, start, limit, &context).await
    }

    /// Submit Tournament Score
    async fn submit_tournament_score(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        mission_id: i64,
        game_id: i64,
        pack_id: i64,
        scores: String,
        game_level_id: Option<i64>,
        ) -> Result<SubmitTournamentScoreResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().submit_tournament_score(version, account_id, app_key, mission_id, game_id, pack_id, scores, game_level_id, &context).await
    }

    /// Submit a vote for a multi-stage album tournament.
    async fn submit_tournament_vote(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        mission_id: i64,
        game_object_id: i64,
        device_id: Option<String>,
        check_if_device_already_voted: Option<bool>,
        ) -> Result<SubmitTournamentVoteResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().submit_tournament_vote(version, account_id, app_key, mission_id, game_object_id, device_id, check_if_device_already_voted, &context).await
    }

    /// Substitute Tournament Player
    async fn substitute_tournament_player(
        &self,
        version: f64,
        account_id: i64,
        mission_id: i64,
        pack_id: i64,
        game_level_id: i64,
        ) -> Result<SubstituteTournamentPlayerResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().substitute_tournament_player(version, account_id, mission_id, pack_id, game_level_id, &context).await
    }

    /// Update Tournament
    async fn update_tournament(
        &self,
        version: f64,
        account_id: i64,
        mission_id: i64,
        title: Option<String>,
        sub_type: Option<String>,
        image_asset_id: Option<i64>,
        seconds_between_levels: Option<i32>,
        seconds_for_tie_breaker: Option<i32>,
        seconds_between_packs: Option<i32>,
        maximum_level_length: Option<i32>,
        cost_to_play: Option<i32>,
        cost_to_play_type: Option<String>,
        minimum_to_play: Option<i32>,
        starting_limit: Option<i32>,
        available_limit: Option<i32>,
        description: Option<String>,
        meta_data: Option<String>,
        start_date: Option<i64>,
        audience_ids: Option<String>,
        active: Option<bool>,
        enable_buy_back: Option<bool>,
        offer_ids: Option<String>,
        offer_asset_id: Option<i64>,
        fixed_reward: Option<bool>,
        split_reward: Option<models::UpdateTournamentSplitRewardParameter>,
        allocate_tickets: Option<bool>,
        tournament_data: Option<String>,
        visibility: Option<models::CreateMediaOfferVisibilityParameter>,
        preliminary_groups: Option<i32>,
        preliminary_group_advancements: Option<String>,
        enable_multiple_entries: Option<bool>,
        enable_multiple_votes: Option<bool>,
        featured: Option<bool>,
        winner_tag: Option<String>,
        tie_tag: Option<String>,
        ) -> Result<UpdateTournamentResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().update_tournament(version, account_id, mission_id, title, sub_type, image_asset_id, seconds_between_levels, seconds_for_tie_breaker, seconds_between_packs, maximum_level_length, cost_to_play, cost_to_play_type, minimum_to_play, starting_limit, available_limit, description, meta_data, start_date, audience_ids, active, enable_buy_back, offer_ids, offer_asset_id, fixed_reward, split_reward, allocate_tickets, tournament_data, visibility, preliminary_groups, preliminary_group_advancements, enable_multiple_entries, enable_multiple_votes, featured, winner_tag, tie_tag, &context).await
    }

    /// Create Batch Tracking
    async fn batch_save_tracking(
        &self,
        version: f64,
        data: String,
        device_id: Option<String>,
        account_id: Option<i64>,
        generate_accounts: Option<bool>,
        update_account_locations: Option<bool>,
        default_tag: Option<String>,
        slave_uid: Option<String>,
        ) -> Result<BatchSaveTrackingResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().batch_save_tracking(version, data, device_id, account_id, generate_accounts, update_account_locations, default_tag, slave_uid, &context).await
    }

    /// Get Predicted Locations
    async fn get_predicted_locations(
        &self,
        version: f64,
        account_id: i64,
        latitude: Option<f64>,
        longitude: Option<f64>,
        date_check: Option<i64>,
        hour_check: Option<String>,
        threshold: Option<i64>,
        distance_unit: Option<models::GetOfferListCountsDistanceUnitParameter>,
        search_range: Option<f64>,
        sort_order: Option<models::GetPredictedLocationsSortOrderParameter>,
        ) -> Result<GetPredictedLocationsResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_predicted_locations(version, account_id, latitude, longitude, date_check, hour_check, threshold, distance_unit, search_range, sort_order, &context).await
    }

    /// Get Tracking Path
    async fn get_predicted_path(
        &self,
        version: f64,
        account_id: i64,
        start_step_id: i64,
        end_step_id: i64,
        ) -> Result<GetPredictedPathResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_predicted_path(version, account_id, start_step_id, end_step_id, &context).await
    }

    /// Search Preferred Locations
    async fn get_preferred_locations(
        &self,
        version: f64,
        account_id: i64,
        latitude: Option<f64>,
        longitude: Option<f64>,
        date_check: Option<i64>,
        hour_check: Option<String>,
        sort_field: Option<String>,
        descending: Option<bool>,
        start: Option<i32>,
        limit: Option<i32>,
        search_range: Option<f64>,
        distance_unit: Option<models::GetOfferListCountsDistanceUnitParameter>,
        ) -> Result<GetPreferredLocationsResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_preferred_locations(version, account_id, latitude, longitude, date_check, hour_check, sort_field, descending, start, limit, search_range, distance_unit, &context).await
    }

    /// Search Tracking
    async fn get_tracking_legs(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        owner_id: Option<i64>,
        tracking_device_id: Option<String>,
        start_date: Option<i64>,
        end_date: Option<i64>,
        tags: Option<String>,
        get_last_point: Option<bool>,
        ) -> Result<GetTrackingLegsResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_tracking_legs(version, device_id, account_id, owner_id, tracking_device_id, start_date, end_date, tags, get_last_point, &context).await
    }

    /// Create Tracking Leg
    async fn save_tracking_leg(
        &self,
        version: f64,
        start_lat: f64,
        start_lng: f64,
        start_date: i64,
        end_lat: f64,
        end_lng: f64,
        end_date: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        distance: Option<f64>,
        duration: Option<i64>,
        steps: Option<String>,
        tags: Option<String>,
        ) -> Result<SaveTrackingLegResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().save_tracking_leg(version, start_lat, start_lng, start_date, end_lat, end_lng, end_date, device_id, account_id, distance, duration, steps, tags, &context).await
    }

    /// Create Tracking Step
    async fn save_tracking_step(
        &self,
        version: f64,
        leg_id: i64,
        start_lat: f64,
        start_lng: f64,
        start_date: i64,
        end_lat: f64,
        end_lng: f64,
        end_date: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        distance: Option<f64>,
        duration: Option<i64>,
        ) -> Result<SaveTrackingStepResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().save_tracking_step(version, leg_id, start_lat, start_lng, start_date, end_lat, end_lng, end_date, device_id, account_id, distance, duration, &context).await
    }

    /// List Tracking
    async fn search_accounts_with_tracking_legs(
        &self,
        version: f64,
        account_id: i64,
        keyword: Option<String>,
        start_date: Option<i64>,
        end_date: Option<i64>,
        tags: Option<String>,
        audience_ids: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        range: Option<f64>,
        sort_field: Option<String>,
        descending: Option<bool>,
        start: Option<i32>,
        limit: Option<i32>,
        active_only: Option<bool>,
        ) -> Result<SearchAccountsWithTrackingLegsResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().search_accounts_with_tracking_legs(version, account_id, keyword, start_date, end_date, tags, audience_ids, latitude, longitude, range, sort_field, descending, start, limit, active_only, &context).await
    }

    /// Search Tracking (Billable)
    async fn search_tracking_legs(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        tracking_device_id: Option<String>,
        start_date: Option<i64>,
        end_date: Option<i64>,
        tags: Option<String>,
        start: Option<i32>,
        limit: Option<i32>,
        ) -> Result<SearchTrackingLegsResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().search_tracking_legs(version, account_id, app_key, tracking_device_id, start_date, end_date, tags, start, limit, &context).await
    }

    /// Create Trigger
    async fn create_trigger(
        &self,
        version: f64,
        account_id: i64,
        name: String,
        app_key: Option<String>,
        grouping_id: Option<String>,
        endpoint_url: Option<String>,
        payload: Option<String>,
        scheduled_date: Option<i64>,
        start_date: Option<i64>,
        end_date: Option<i64>,
        cron_expression: Option<String>,
        conditional_input: Option<String>,
        visibility: Option<models::AddAlbumCollectionVisibilityParameter>,
        active: Option<bool>,
        ) -> Result<CreateTriggerResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().create_trigger(version, account_id, name, app_key, grouping_id, endpoint_url, payload, scheduled_date, start_date, end_date, cron_expression, conditional_input, visibility, active, &context).await
    }

    /// Delete Trigger
    async fn delete_trigger(
        &self,
        version: f64,
        account_id: i64,
        trigger_id: i64,
        ) -> Result<DeleteTriggerResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().delete_trigger(version, account_id, trigger_id, &context).await
    }

    /// Get Trigger
    async fn get_trigger(
        &self,
        version: f64,
        account_id: i64,
        trigger_id: i64,
        ) -> Result<GetTriggerResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_trigger(version, account_id, trigger_id, &context).await
    }

    /// Search Triggers
    async fn search_triggers(
        &self,
        version: f64,
        account_id: i64,
        grouping_id: Option<String>,
        filter: Option<String>,
        statuses: Option<String>,
        template_types: Option<String>,
        app_key: Option<String>,
        keyword: Option<String>,
        sort_field: Option<String>,
        descending: Option<bool>,
        start: Option<i32>,
        limit: Option<i32>,
        active_only: Option<bool>,
        ) -> Result<SearchTriggersResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().search_triggers(version, account_id, grouping_id, filter, statuses, template_types, app_key, keyword, sort_field, descending, start, limit, active_only, &context).await
    }

    /// Update Trigger
    async fn update_trigger(
        &self,
        version: f64,
        trigger_id: i64,
        account_id: i64,
        name: Option<String>,
        app_key: Option<String>,
        grouping_id: Option<String>,
        endpoint_url: Option<String>,
        payload: Option<String>,
        scheduled_date: Option<i64>,
        start_date: Option<i64>,
        end_date: Option<i64>,
        cron_expression: Option<String>,
        conditional_input: Option<String>,
        visibility: Option<models::AddAlbumCollectionVisibilityParameter>,
        active: Option<bool>,
        ) -> Result<UpdateTriggerResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().update_trigger(version, trigger_id, account_id, name, app_key, grouping_id, endpoint_url, payload, scheduled_date, start_date, end_date, cron_expression, conditional_input, visibility, active, &context).await
    }

    /// Create Trip
    async fn create_trip(
        &self,
        version: f64,
        body: Option<models::Trip>,
        ) -> Result<CreateTripResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().create_trip(version, body, &context).await
    }

    /// Process Trip Matches
    async fn process_trip_matches(
        &self,
        version: f64,
        start_date: Option<i64>,
        end_date: Option<i64>,
        trip_id: Option<i64>,
        ) -> Result<ProcessTripMatchesResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().process_trip_matches(version, start_date, end_date, trip_id, &context).await
    }

    /// Search Trips
    async fn search(
        &self,
        version: f64,
        account_id: i64,
        sort_field: String,
        descending: bool,
        start: i32,
        limit: i32,
        active_only: bool,
        start_date: Option<i64>,
        end_date: Option<i64>,
        has_notifications: Option<bool>,
        ) -> Result<SearchResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().search(version, account_id, sort_field, descending, start, limit, active_only, start_date, end_date, has_notifications, &context).await
    }

    /// Search Trips
    async fn search_trips(
        &self,
        version: f64,
        account_id: i64,
        sort_field: String,
        descending: bool,
        start: i32,
        limit: i32,
        active_only: bool,
        start_date: Option<i64>,
        end_date: Option<i64>,
        matched_has_route: Option<bool>,
        matched_has_driver: Option<bool>,
        ) -> Result<SearchTripsResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().search_trips(version, account_id, sort_field, descending, start, limit, active_only, start_date, end_date, matched_has_route, matched_has_driver, &context).await
    }

    /// Trip Notifications
    async fn update_trip_notifications(
        &self,
        version: f64,
        id: i64,
        notifications: Option<String>,
        ) -> Result<UpdateTripNotificationsResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().update_trip_notifications(version, id, notifications, &context).await
    }

    /// Delete Trip
    async fn delete(
        &self,
        version: f64,
        id: i64,
        ) -> Result<DeleteResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().delete(version, id, &context).await
    }

    /// Set Trip Preference Driver
    async fn drive_trip(
        &self,
        version: f64,
        id: i64,
        recurrence: bool,
        ) -> Result<DriveTripResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().drive_trip(version, id, recurrence, &context).await
    }

    /// Set Trip Preference Flexible
    async fn flexible_trip(
        &self,
        version: f64,
        id: i64,
        recurrence: bool,
        ) -> Result<FlexibleTripResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().flexible_trip(version, id, recurrence, &context).await
    }

    /// Get Trip
    async fn get_trip(
        &self,
        version: f64,
        id: i64,
        ) -> Result<GetTripResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_trip(version, id, &context).await
    }

    /// Get Trip Matches
    async fn get_trip_matches(
        &self,
        version: f64,
        id: i64,
        sort_field: String,
        descending: bool,
        start: i32,
        limit: i32,
        active_only: bool,
        matched_has_route: Option<bool>,
        matched_has_driver: Option<bool>,
        ) -> Result<GetTripMatchesResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_trip_matches(version, id, sort_field, descending, start, limit, active_only, matched_has_route, matched_has_driver, &context).await
    }

    /// Set Trip Preference Rider
    async fn ride(
        &self,
        version: f64,
        id: i64,
        recurrence: bool,
        ) -> Result<RideResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().ride(version, id, recurrence, &context).await
    }

    /// Update Trip Locations
    async fn update_locations(
        &self,
        version: f64,
        id: i64,
        body: Option<models::Trip>,
        ) -> Result<UpdateLocationsResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().update_locations(version, id, body, &context).await
    }

    /// Update Recurrence Locations
    async fn update_recurrence_locations(
        &self,
        version: f64,
        id: i64,
        body: Option<models::Trip>,
        ) -> Result<UpdateRecurrenceLocationsResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().update_recurrence_locations(version, id, body, &context).await
    }

    /// Update Recurrence Shipments
    async fn update_recurrence_shipments(
        &self,
        version: f64,
        id: i64,
        body: Option<models::Trip>,
        ) -> Result<UpdateRecurrenceShipmentsResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().update_recurrence_shipments(version, id, body, &context).await
    }

    /// Update Trip Shipments
    async fn update_shipments(
        &self,
        version: f64,
        id: i64,
        body: Option<models::Trip>,
        ) -> Result<UpdateShipmentsResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().update_shipments(version, id, body, &context).await
    }

    /// Update Trip
    async fn update_trip(
        &self,
        version: f64,
        id: i64,
        body: Option<models::Trip>,
        ) -> Result<UpdateTripResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().update_trip(version, id, body, &context).await
    }

    /// Buy Offer by SMS
    async fn sms_buy_offer(
        &self,
        version: f64,
        app_key: String,
        body: String,
        from: String,
        currency_type: String,
        ) -> Result<SmsBuyOfferResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().sms_buy_offer(version, app_key, body, from, currency_type, &context).await
    }

    /// Authorize Twitter
    async fn authorize_twitter(
        &self,
        version: f64,
        app_key: String,
        ) -> Result<AuthorizeTwitterResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().authorize_twitter(version, app_key, &context).await
    }

    /// Login Twitter
    async fn login_twitter(
        &self,
        version: f64,
        access_token: String,
        access_token_secret: String,
        app_key: String,
        response_filters: String,
        device_id: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        ) -> Result<LoginTwitterResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().login_twitter(version, access_token, access_token_secret, app_key, response_filters, device_id, latitude, longitude, &context).await
    }

    /// Add User
    async fn add_users_to_permissionable(
        &self,
        version: f64,
        permissionable_type: models::AddUsersToPermissionablePermissionableTypeParameter,
        permissionable_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        read: Option<bool>,
        write: Option<bool>,
        delete: Option<bool>,
        add: Option<bool>,
        connection_ids: Option<String>,
        connection_account_ids: Option<String>,
        connection_group_ids: Option<String>,
        pending: Option<bool>,
        admin: Option<bool>,
        include_friend_group: Option<bool>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        audience_ids: Option<String>,
        ) -> Result<AddUsersToPermissionableResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().add_users_to_permissionable(version, permissionable_type, permissionable_id, device_id, account_id, read, write, delete, add, connection_ids, connection_account_ids, connection_group_ids, pending, admin, include_friend_group, latitude, longitude, audience_ids, &context).await
    }

    /// Approve Permissionable
    async fn approve_permissionable(
        &self,
        version: f64,
        permissionable_type: models::AddUsersToPermissionablePermissionableTypeParameter,
        permissionable_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        approval_status: Option<models::ApprovePermissionableApprovalStatusParameter>,
        ) -> Result<ApprovePermissionableResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().approve_permissionable(version, permissionable_type, permissionable_id, device_id, account_id, approval_status, &context).await
    }

    /// Leave
    async fn leave_from_permissionable(
        &self,
        version: f64,
        permissionable_type: String,
        permissionable_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        ) -> Result<LeaveFromPermissionableResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().leave_from_permissionable(version, permissionable_type, permissionable_id, device_id, account_id, latitude, longitude, &context).await
    }

    /// Remove User
    async fn remove_users_from_permissionable(
        &self,
        version: f64,
        permissionable_type: models::AddUsersToPermissionablePermissionableTypeParameter,
        permissionable_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        connection_ids: Option<String>,
        connection_account_ids: Option<String>,
        connection_group_ids: Option<String>,
        remove_friend_group: Option<bool>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        audience_ids: Option<String>,
        ) -> Result<RemoveUsersFromPermissionableResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().remove_users_from_permissionable(version, permissionable_type, permissionable_id, device_id, account_id, connection_ids, connection_account_ids, connection_group_ids, remove_friend_group, latitude, longitude, audience_ids, &context).await
    }

    /// Search Permissionables
    async fn search_permissionables(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        connection_account_id: Option<i64>,
        connection_account_ids: Option<String>,
        permissionable_type: Option<models::AddUsersToPermissionablePermissionableTypeParameter>,
        permissionable_id: Option<i64>,
        keyword: Option<String>,
        sort_field: Option<String>,
        descending: Option<bool>,
        pending: Option<bool>,
        admin: Option<bool>,
        start: Option<i32>,
        limit: Option<i32>,
        ) -> Result<SearchPermissionablesResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().search_permissionables(version, device_id, account_id, connection_account_id, connection_account_ids, permissionable_type, permissionable_id, keyword, sort_field, descending, pending, admin, start, limit, &context).await
    }

    /// Search Permissionables by Distnace
    async fn search_permissionables_following_distance(
        &self,
        version: f64,
        latitude: f64,
        longitude: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        connection_account_id: Option<i64>,
        connection_account_ids: Option<String>,
        permissionable_type: Option<models::AddUsersToPermissionablePermissionableTypeParameter>,
        permissionable_id: Option<i64>,
        search_range: Option<f64>,
        keyword: Option<String>,
        pending: Option<bool>,
        admin: Option<bool>,
        start: Option<i32>,
        limit: Option<i32>,
        ) -> Result<SearchPermissionablesFollowingDistanceResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().search_permissionables_following_distance(version, latitude, longitude, device_id, account_id, connection_account_id, connection_account_ids, permissionable_type, permissionable_id, search_range, keyword, pending, admin, start, limit, &context).await
    }

    /// Create following
    async fn create_following(
        &self,
        version: f64,
        account_id: i64,
        vatom_parameters: String,
        return_raw_response: Option<bool>,
        ) -> Result<CreateFollowingResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().create_following(version, account_id, vatom_parameters, return_raw_response, &context).await
    }

    /// Create Vatom Space
    async fn create_space(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        vatom_parameters: String,
        return_raw_response: Option<bool>,
        ) -> Result<CreateSpaceResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().create_space(version, account_id, app_key, vatom_parameters, return_raw_response, &context).await
    }

    /// Create Vatom Event
    async fn create_vatom_event(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        vatom_parameters: String,
        return_raw_response: Option<bool>,
        ) -> Result<CreateVatomEventResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().create_vatom_event(version, account_id, app_key, vatom_parameters, return_raw_response, &context).await
    }

    /// Delete following
    async fn delete_following(
        &self,
        version: f64,
        account_id: i64,
        vatom_rels_key: String,
        return_raw_response: Option<bool>,
        ) -> Result<DeleteFollowingResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().delete_following(version, account_id, vatom_rels_key, return_raw_response, &context).await
    }

    /// Reset All Points Balance
    async fn delete_points_balance(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        vatom_campaign_id: String,
        return_raw_response: Option<bool>,
        ) -> Result<DeletePointsBalanceResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().delete_points_balance(version, account_id, app_key, vatom_campaign_id, return_raw_response, &context).await
    }

    /// Delete Vatom Space
    async fn delete_space(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        vatom_space_id: String,
        return_raw_response: Option<bool>,
        ) -> Result<DeleteSpaceResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().delete_space(version, account_id, app_key, vatom_space_id, return_raw_response, &context).await
    }

    /// Delete Vatom Event
    async fn delete_vatom_event(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        vatom_event_id: String,
        return_raw_response: Option<bool>,
        ) -> Result<DeleteVatomEventResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().delete_vatom_event(version, account_id, app_key, vatom_event_id, return_raw_response, &context).await
    }

    /// Delete Vatom NFT
    async fn delete_vatom_nft(
        &self,
        version: f64,
        account_id: i64,
        vatom_id: String,
        return_raw_response: Option<bool>,
        ) -> Result<DeleteVatomNftResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().delete_vatom_nft(version, account_id, vatom_id, return_raw_response, &context).await
    }

    /// Execute Action on NFT
    async fn execute_action_on_nft(
        &self,
        version: f64,
        account_id: i64,
        vatom_id: String,
        vatom_parameters: String,
        return_raw_response: Option<bool>,
        ) -> Result<ExecuteActionOnNftResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().execute_action_on_nft(version, account_id, vatom_id, vatom_parameters, return_raw_response, &context).await
    }

    /// Search Vatom Geo Map
    async fn geomap_search(
        &self,
        version: f64,
        account_id: i64,
        vatom_parameters: String,
        return_raw_response: Option<bool>,
        ) -> Result<GeomapSearchResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().geomap_search(version, account_id, vatom_parameters, return_raw_response, &context).await
    }

    /// Get Vatom Business Behaviors
    async fn get_business_behaviors(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        return_raw_response: Option<bool>,
        ) -> Result<GetBusinessBehaviorsResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_business_behaviors(version, account_id, app_key, return_raw_response, &context).await
    }

    /// Get the coins for a Business
    async fn get_business_coins_balance(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        return_raw_response: Option<bool>,
        ) -> Result<GetBusinessCoinsBalanceResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_business_coins_balance(version, account_id, app_key, return_raw_response, &context).await
    }

    /// Get the user business ids
    async fn get_business_ids(
        &self,
        version: f64,
        account_id: i64,
        return_raw_response: Option<bool>,
        ) -> Result<GetBusinessIdsResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_business_ids(version, account_id, return_raw_response, &context).await
    }

    /// Get Vatom Business Info
    async fn get_business_info(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        vatom_parameters: Option<String>,
        return_raw_response: Option<bool>,
        ) -> Result<GetBusinessInfoResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_business_info(version, account_id, app_key, vatom_parameters, return_raw_response, &context).await
    }

    /// Get Vatom Business Users
    async fn get_business_users(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        return_raw_response: Option<bool>,
        ) -> Result<GetBusinessUsersResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_business_users(version, account_id, app_key, return_raw_response, &context).await
    }

    /// Get Campaign Group Entities
    async fn get_campaign_group_entities(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        vatom_campaign_id: String,
        return_raw_response: Option<bool>,
        ) -> Result<GetCampaignGroupEntitiesResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_campaign_group_entities(version, account_id, app_key, vatom_campaign_id, return_raw_response, &context).await
    }

    /// Get Campaign Group Rules
    async fn get_campaign_group_rules(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        vatom_campaign_id: String,
        return_raw_response: Option<bool>,
        ) -> Result<GetCampaignGroupRulesResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_campaign_group_rules(version, account_id, app_key, vatom_campaign_id, return_raw_response, &context).await
    }

    /// Get Campaign Group Stats
    async fn get_campaign_group_stats(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        vatom_campaign_id: String,
        return_raw_response: Option<bool>,
        ) -> Result<GetCampaignGroupStatsResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_campaign_group_stats(version, account_id, app_key, vatom_campaign_id, return_raw_response, &context).await
    }

    /// Get Campaign Info
    async fn get_campaign_info(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        vatom_campaign_id: String,
        return_raw_response: Option<bool>,
        ) -> Result<GetCampaignInfoResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_campaign_info(version, account_id, app_key, vatom_campaign_id, return_raw_response, &context).await
    }

    /// Get Vatom Event Guest List
    async fn get_event_guest_list(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        vatom_event_id: String,
        return_raw_response: Option<bool>,
        ) -> Result<GetEventGuestListResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_event_guest_list(version, account_id, app_key, vatom_event_id, return_raw_response, &context).await
    }

    /// Get Vatom User's Inventory
    async fn get_inventory(
        &self,
        version: f64,
        account_id: i64,
        vatom_parameters: String,
        return_raw_response: Option<bool>,
        ) -> Result<GetInventoryResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_inventory(version, account_id, vatom_parameters, return_raw_response, &context).await
    }

    /// Get following
    async fn get_my_following(
        &self,
        version: f64,
        account_id: i64,
        return_raw_response: Option<bool>,
        ) -> Result<GetMyFollowingResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_my_following(version, account_id, return_raw_response, &context).await
    }

    /// Get Points Balance
    async fn get_points_balance(
        &self,
        version: f64,
        account_id: i64,
        vatom_user_id: String,
        vatom_campaign_id: String,
        return_raw_response: Option<bool>,
        ) -> Result<GetPointsBalanceResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_points_balance(version, account_id, vatom_user_id, vatom_campaign_id, return_raw_response, &context).await
    }

    /// Get Points Balance as Business
    async fn get_points_balance_as_business(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        vatom_user_id: String,
        vatom_campaign_id: String,
        return_raw_response: Option<bool>,
        ) -> Result<GetPointsBalanceAsBusinessResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_points_balance_as_business(version, account_id, app_key, vatom_user_id, vatom_campaign_id, return_raw_response, &context).await
    }

    /// Get Vatom Space
    async fn get_space(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        vatom_space_id: String,
        return_raw_response: Option<bool>,
        ) -> Result<GetSpaceResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_space(version, account_id, app_key, vatom_space_id, return_raw_response, &context).await
    }

    /// Get the coins for a user (as a Business)
    async fn get_user_coins_as_business(
        &self,
        version: f64,
        account_id: i64,
        vatom_user_id: String,
        app_key: String,
        return_raw_response: Option<bool>,
        ) -> Result<GetUserCoinsAsBusinessResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_user_coins_as_business(version, account_id, vatom_user_id, app_key, return_raw_response, &context).await
    }

    /// Gets the coins balance for a Vatom User
    async fn get_user_coins_balance(
        &self,
        version: f64,
        account_id: i64,
        vatom_user_id: String,
        vatom_parameters: Option<String>,
        return_raw_response: Option<bool>,
        ) -> Result<GetUserCoinsBalanceResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_user_coins_balance(version, account_id, vatom_user_id, vatom_parameters, return_raw_response, &context).await
    }

    /// Get user followers
    async fn get_user_followers(
        &self,
        version: f64,
        account_id: i64,
        vatom_user_id: String,
        return_raw_response: Option<bool>,
        ) -> Result<GetUserFollowersResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_user_followers(version, account_id, vatom_user_id, return_raw_response, &context).await
    }

    /// Get user following
    async fn get_user_following(
        &self,
        version: f64,
        account_id: i64,
        vatom_user_id: String,
        return_raw_response: Option<bool>,
        ) -> Result<GetUserFollowingResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_user_following(version, account_id, vatom_user_id, return_raw_response, &context).await
    }

    /// Get User Info
    async fn get_user_info(
        &self,
        version: f64,
        account_id: i64,
        vatom_user_id: String,
        return_raw_response: Option<bool>,
        ) -> Result<GetUserInfoResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_user_info(version, account_id, vatom_user_id, return_raw_response, &context).await
    }

    /// Get Vatom User Profile
    async fn get_user_profile(
        &self,
        version: f64,
        account_id: i64,
        return_raw_response: Option<bool>,
        ) -> Result<GetUserProfileResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_user_profile(version, account_id, return_raw_response, &context).await
    }

    /// Get Vatom Event
    async fn get_vatom_event(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        vatom_event_id: String,
        return_raw_response: Option<bool>,
        ) -> Result<GetVatomEventResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_vatom_event(version, account_id, app_key, vatom_event_id, return_raw_response, &context).await
    }

    /// Get Vatom NFT Details
    async fn get_vatom_nft(
        &self,
        version: f64,
        account_id: i64,
        vatom_id: String,
        return_raw_response: Option<bool>,
        ) -> Result<GetVatomNftResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_vatom_nft(version, account_id, vatom_id, return_raw_response, &context).await
    }

    /// List Vatom Communities
    async fn list_communities(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        vatom_parameters: Option<String>,
        return_raw_response: Option<bool>,
        ) -> Result<ListCommunitiesResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().list_communities(version, account_id, app_key, vatom_parameters, return_raw_response, &context).await
    }

    /// List Vatom Events
    async fn list_events(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        vatom_parameters: Option<String>,
        return_raw_response: Option<bool>,
        ) -> Result<ListEventsResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().list_events(version, account_id, app_key, vatom_parameters, return_raw_response, &context).await
    }

    /// List Vatom Spaces
    async fn list_spaces(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        vatom_parameters: Option<String>,
        return_raw_response: Option<bool>,
        ) -> Result<ListSpacesResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().list_spaces(version, account_id, app_key, vatom_parameters, return_raw_response, &context).await
    }

    /// List Coin Transactions for a Vatom User
    async fn list_user_coin_transactions(
        &self,
        version: f64,
        account_id: i64,
        vatom_user_id: String,
        vatom_parameters: Option<String>,
        return_raw_response: Option<bool>,
        ) -> Result<ListUserCoinTransactionsResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().list_user_coin_transactions(version, account_id, vatom_user_id, vatom_parameters, return_raw_response, &context).await
    }

    /// List coin transactions for a user (as a Business)
    async fn list_user_coin_transactions_as_business(
        &self,
        version: f64,
        account_id: i64,
        vatom_user_id: String,
        app_key: String,
        vatom_parameters: Option<String>,
        return_raw_response: Option<bool>,
        ) -> Result<ListUserCoinTransactionsAsBusinessResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().list_user_coin_transactions_as_business(version, account_id, vatom_user_id, app_key, vatom_parameters, return_raw_response, &context).await
    }

    /// Perform Action on NFT
    async fn perform_action_on_nft(
        &self,
        version: f64,
        account_id: i64,
        vatom_id: String,
        vatom_action: String,
        vatom_parameters: String,
        return_raw_response: Option<bool>,
        ) -> Result<PerformActionOnNftResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().perform_action_on_nft(version, account_id, vatom_id, vatom_action, vatom_parameters, return_raw_response, &context).await
    }

    /// Redeem NFT
    async fn redeem_nft(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        vatom_parameters: String,
        return_raw_response: Option<bool>,
        ) -> Result<RedeemNftResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().redeem_nft(version, account_id, app_key, vatom_parameters, return_raw_response, &context).await
    }

    /// Redeem the coins for a user (as a Business)
    async fn redeem_user_coins_as_business(
        &self,
        version: f64,
        account_id: i64,
        vatom_user_id: String,
        app_key: String,
        vatom_parameters: String,
        return_raw_response: Option<bool>,
        ) -> Result<RedeemUserCoinsAsBusinessResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().redeem_user_coins_as_business(version, account_id, vatom_user_id, app_key, vatom_parameters, return_raw_response, &context).await
    }

    /// Search for Vatom Businesses
    async fn search_businesses(
        &self,
        version: f64,
        account_id: i64,
        vatom_parameters: Option<String>,
        return_raw_response: Option<bool>,
        ) -> Result<SearchBusinessesResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().search_businesses(version, account_id, vatom_parameters, return_raw_response, &context).await
    }

    /// Search Campaign Groups
    async fn search_campaign_groups(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        return_raw_response: Option<bool>,
        ) -> Result<SearchCampaignGroupsResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().search_campaign_groups(version, account_id, app_key, return_raw_response, &context).await
    }

    /// Search User Identities
    async fn search_identities(
        &self,
        version: f64,
        account_id: i64,
        return_raw_response: Option<bool>,
        ) -> Result<SearchIdentitiesResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().search_identities(version, account_id, return_raw_response, &context).await
    }

    /// Search Vatom User's Inventory
    async fn search_inventory(
        &self,
        version: f64,
        account_id: i64,
        vatom_parameters: Option<String>,
        return_raw_response: Option<bool>,
        ) -> Result<SearchInventoryResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().search_inventory(version, account_id, vatom_parameters, return_raw_response, &context).await
    }

    /// Send NFT
    async fn send_nft(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        vatom_campaign_id: String,
        vatom_parameters: String,
        return_raw_response: Option<bool>,
        ) -> Result<SendNftResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().send_nft(version, account_id, app_key, vatom_campaign_id, vatom_parameters, return_raw_response, &context).await
    }

    /// Set Points Balance as Business
    async fn set_points_balance_as_business(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        vatom_user_id: String,
        vatom_campaign_id: String,
        vatom_parameters: String,
        return_raw_response: Option<bool>,
        ) -> Result<SetPointsBalanceAsBusinessResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().set_points_balance_as_business(version, account_id, app_key, vatom_user_id, vatom_campaign_id, vatom_parameters, return_raw_response, &context).await
    }

    /// Transfer coins from Vatom Users
    async fn transfer_user_coins(
        &self,
        version: f64,
        account_id: i64,
        vatom_user_id: String,
        vatom_parameters: String,
        return_raw_response: Option<bool>,
        ) -> Result<TransferUserCoinsResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().transfer_user_coins(version, account_id, vatom_user_id, vatom_parameters, return_raw_response, &context).await
    }

    /// Fund coins for a Business
    async fn update_business_coins(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        vatom_parameters: String,
        return_raw_response: Option<bool>,
        ) -> Result<UpdateBusinessCoinsResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().update_business_coins(version, account_id, app_key, vatom_parameters, return_raw_response, &context).await
    }

    /// Update Vatom Event Guest List
    async fn update_event_guest_list(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        vatom_event_id: String,
        vatom_parameters: String,
        return_raw_response: Option<bool>,
        ) -> Result<UpdateEventGuestListResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().update_event_guest_list(version, account_id, app_key, vatom_event_id, vatom_parameters, return_raw_response, &context).await
    }

    /// Update Vatom Space
    async fn update_space(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        vatom_space_id: String,
        vatom_parameters: String,
        return_raw_response: Option<bool>,
        ) -> Result<UpdateSpaceResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().update_space(version, account_id, app_key, vatom_space_id, vatom_parameters, return_raw_response, &context).await
    }

    /// Update the coins for a user (as a Business)
    async fn update_user_coins_as_business(
        &self,
        version: f64,
        account_id: i64,
        vatom_user_id: String,
        app_key: String,
        vatom_parameters: String,
        return_raw_response: Option<bool>,
        ) -> Result<UpdateUserCoinsAsBusinessResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().update_user_coins_as_business(version, account_id, vatom_user_id, app_key, vatom_parameters, return_raw_response, &context).await
    }

    /// Update Vatom User Profile
    async fn update_user_profile(
        &self,
        version: f64,
        account_id: i64,
        vatom_parameters: String,
        return_raw_response: Option<bool>,
        ) -> Result<UpdateUserProfileResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().update_user_profile(version, account_id, vatom_parameters, return_raw_response, &context).await
    }

    /// Update Vatom Event
    async fn update_vatom_event(
        &self,
        version: f64,
        account_id: i64,
        app_key: String,
        vatom_event_id: String,
        vatom_parameters: String,
        return_raw_response: Option<bool>,
        ) -> Result<UpdateVatomEventResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().update_vatom_event(version, account_id, app_key, vatom_event_id, vatom_parameters, return_raw_response, &context).await
    }

    /// Create Vehicle
    async fn create_vehicle(
        &self,
        version: f64,
        vehicle: String,
        body: Option<models::Vehicle>,
        ) -> Result<CreateVehicleResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().create_vehicle(version, vehicle, body, &context).await
    }

    /// Search Vehicle
    async fn search_vehicle(
        &self,
        version: f64,
        hub_id: i64,
        sort_field: String,
        descending: bool,
        start: i32,
        limit: i32,
        active_only: bool,
        keyword: Option<String>,
        ) -> Result<SearchVehicleResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().search_vehicle(version, hub_id, sort_field, descending, start, limit, active_only, keyword, &context).await
    }

    /// Delete Vehicle
    async fn delete_vehicle(
        &self,
        version: f64,
        id: i64,
        ) -> Result<DeleteVehicleResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().delete_vehicle(version, id, &context).await
    }

    /// Get Vehicle
    async fn get_vehicle(
        &self,
        version: f64,
        id: i64,
        ) -> Result<GetVehicleResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_vehicle(version, id, &context).await
    }

    /// Update Vehicle
    async fn update_vehicle(
        &self,
        version: f64,
        id: i64,
        vehicle: String,
        body: Option<models::Vehicle>,
        ) -> Result<UpdateVehicleResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().update_vehicle(version, id, vehicle, body, &context).await
    }

    /// Create Vehicle Type
    async fn create_vehicle_type(
        &self,
        version: f64,
        vehicle_type: String,
        body: Option<models::VehicleType>,
        ) -> Result<CreateVehicleTypeResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().create_vehicle_type(version, vehicle_type, body, &context).await
    }

    /// Search Vehicle Type
    async fn search_vehicle_types(
        &self,
        version: f64,
        sort_field: String,
        descending: bool,
        start: i32,
        limit: i32,
        active_only: bool,
        retailer_id: Option<i64>,
        hub_id: Option<i64>,
        ) -> Result<SearchVehicleTypesResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().search_vehicle_types(version, sort_field, descending, start, limit, active_only, retailer_id, hub_id, &context).await
    }

    /// Delete Vehicle Type
    async fn delete_vehicle_type(
        &self,
        version: f64,
        vehicle_type_id: i64,
        ) -> Result<DeleteVehicleTypeResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().delete_vehicle_type(version, vehicle_type_id, &context).await
    }

    /// Get Vehicle Type
    async fn get_vehicle_type(
        &self,
        version: f64,
        vehicle_type_id: i64,
        ) -> Result<GetVehicleTypeResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_vehicle_type(version, vehicle_type_id, &context).await
    }

    /// Update Vehicle Type
    async fn update_vehicle_type(
        &self,
        version: f64,
        vehicle_type_id: i64,
        vehicle_type: String,
        body: Option<models::VehicleType>,
        ) -> Result<UpdateVehicleTypeResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().update_vehicle_type(version, vehicle_type_id, vehicle_type, body, &context).await
    }

    /// Create Wallet Offers
    async fn create_offer_transaction(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        offer_id: Option<i64>,
        offer_location_id: Option<i64>,
        offer_cart: Option<String>,
        promo_code: Option<String>,
        currency_type: Option<String>,
        use_points: Option<bool>,
        meta_data: Option<String>,
        app_key: Option<String>,
        status: Option<i32>,
        ) -> Result<CreateOfferTransactionResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().create_offer_transaction(version, device_id, account_id, offer_id, offer_location_id, offer_cart, promo_code, currency_type, use_points, meta_data, app_key, status, &context).await
    }

    /// Delete Wallet Offer
    async fn delete_offer_transaction(
        &self,
        version: f64,
        transaction_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        ) -> Result<DeleteOfferTransactionResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().delete_offer_transaction(version, transaction_id, device_id, account_id, &context).await
    }

    /// Get Wallet Offer
    async fn get_offer_transaction(
        &self,
        version: f64,
        transaction_id: i64,
        device_id: Option<String>,
        account_id: Option<i64>,
        include_mission: Option<bool>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        return_full_response: Option<bool>,
        ) -> Result<GetOfferTransactionResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_offer_transaction(version, transaction_id, device_id, account_id, include_mission, latitude, longitude, return_full_response, &context).await
    }

    /// Preview Wallet Offers
    async fn preview_offer_transaction(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        offer_id: Option<i64>,
        offer_location_id: Option<i64>,
        offer_cart: Option<String>,
        promo_code: Option<String>,
        currency_type: Option<String>,
        use_points: Option<bool>,
        meta_data: Option<String>,
        app_key: Option<String>,
        ) -> Result<PreviewOfferTransactionResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().preview_offer_transaction(version, device_id, account_id, offer_id, offer_location_id, offer_cart, promo_code, currency_type, use_points, meta_data, app_key, &context).await
    }

    /// Search Wallet Offers
    async fn search_offer_transactions(
        &self,
        version: f64,
        device_id: Option<String>,
        account_id: Option<i64>,
        keyword: Option<String>,
        retailer_id: Option<i64>,
        retailer_ids: Option<String>,
        retailer_location_id: Option<i64>,
        retailer_location_ids: Option<String>,
        exclude_retailer_location_ids: Option<String>,
        offer_id: Option<i64>,
        offer_ids: Option<String>,
        offer_location_id: Option<i64>,
        offer_location_ids: Option<String>,
        offer_type: Option<models::CreateOfferOfferTypeParameter>,
        offer_types: Option<String>,
        special_offer_type: Option<String>,
        special_offer_types: Option<String>,
        category_ids: Option<String>,
        filter_ids: Option<String>,
        offer_audience_ids: Option<String>,
        sort_field: Option<models::SearchOfferTransactionsSortFieldParameter>,
        descending: Option<bool>,
        start: Option<i32>,
        limit: Option<i32>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        redeemable_start_date: Option<i64>,
        redeemable_end_date: Option<i64>,
        filter_by_parent_offer: Option<bool>,
        started_since: Option<i64>,
        started_before: Option<i64>,
        ended_since: Option<i64>,
        ended_before: Option<i64>,
        redeemed: Option<bool>,
        statuses: Option<String>,
        reservations_only: Option<bool>,
        active_only: Option<bool>,
        return_full_response: Option<bool>,
        recurring_started_since: Option<i64>,
        recurring_started_before: Option<i64>,
        recurring_expiration_since: Option<i64>,
        recurring_expiration_before: Option<i64>,
        ) -> Result<SearchOfferTransactionsResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().search_offer_transactions(version, device_id, account_id, keyword, retailer_id, retailer_ids, retailer_location_id, retailer_location_ids, exclude_retailer_location_ids, offer_id, offer_ids, offer_location_id, offer_location_ids, offer_type, offer_types, special_offer_type, special_offer_types, category_ids, filter_ids, offer_audience_ids, sort_field, descending, start, limit, latitude, longitude, redeemable_start_date, redeemable_end_date, filter_by_parent_offer, started_since, started_before, ended_since, ended_before, redeemed, statuses, reservations_only, active_only, return_full_response, recurring_started_since, recurring_started_before, recurring_expiration_since, recurring_expiration_before, &context).await
    }

    /// Update Wallet Offer
    async fn update_offer_transaction(
        &self,
        version: f64,
        transaction_id: i64,
        status: i32,
        device_id: Option<String>,
        account_id: Option<i64>,
        offer_location_id: Option<i64>,
        currency_type: Option<String>,
        use_points: Option<bool>,
        app_key: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        meta_data: Option<String>,
        return_full_response: Option<bool>,
        exception_membership_offer_ids: Option<String>,
        ) -> Result<UpdateOfferTransactionResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().update_offer_transaction(version, transaction_id, status, device_id, account_id, offer_location_id, currency_type, use_points, app_key, latitude, longitude, meta_data, return_full_response, exception_membership_offer_ids, &context).await
    }

    /// Search Weather
    async fn search_weather(
        &self,
        version: f64,
        region_id: Option<i64>,
        latitude: Option<f64>,
        longitude: Option<f64>,
        timezone_offset: Option<i64>,
        ) -> Result<SearchWeatherResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().search_weather(version, region_id, latitude, longitude, timezone_offset, &context).await
    }

    /// Create Word
    async fn create_word(
        &self,
        version: f64,
        account_id: i64,
        word: String,
        definition: String,
        active: bool,
        allocate_tickets: bool,
        ticket_count: i64,
        asset_id: Option<i64>,
        ticket_type: Option<String>,
        points: Option<i64>,
        ) -> Result<CreateWordResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().create_word(version, account_id, word, definition, active, allocate_tickets, ticket_count, asset_id, ticket_type, points, &context).await
    }

    /// Delete Word
    async fn delete_word(
        &self,
        version: f64,
        word_id: i64,
        account_id: i64,
        ) -> Result<DeleteWordResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().delete_word(version, word_id, account_id, &context).await
    }

    /// Get Word
    async fn get_word(
        &self,
        version: f64,
        word_id: i64,
        account_id: i64,
        ) -> Result<GetWordResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_word(version, word_id, account_id, &context).await
    }

    /// Search Words
    async fn get_words(
        &self,
        version: f64,
        account_id: i64,
        sort_field: String,
        descending: bool,
        active_only: bool,
        start: i32,
        limit: i32,
        keyword: Option<String>,
        ) -> Result<GetWordsResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().get_words(version, account_id, sort_field, descending, active_only, start, limit, keyword, &context).await
    }

    /// Update Word
    async fn update_word(
        &self,
        version: f64,
        word_id: i64,
        account_id: i64,
        ticket_count: i64,
        word_text: Option<String>,
        definition: Option<String>,
        asset_id: Option<i64>,
        active: Option<bool>,
        allocate_tickets: Option<bool>,
        ticket_type: Option<String>,
        points: Option<i64>,
        ) -> Result<UpdateWordResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().update_word(version, word_id, account_id, ticket_count, word_text, definition, asset_id, active, allocate_tickets, ticket_type, points, &context).await
    }

    /// Run Workflow
    async fn run_workflow(
        &self,
        version: f64,
        account_id: i64,
        workflow_id: i64,
        sku_id: Option<i64>,
        version_code: Option<i32>,
        parameters: Option<String>,
        ) -> Result<RunWorkflowResponse, ApiError>
    {
        let context = self.context().clone();
        self.api().run_workflow(version, account_id, workflow_id, sku_id, version_code, parameters, &context).await
    }

}


#[cfg(feature = "client")]
pub mod client;

// Re-export Client as a top-level name
#[cfg(feature = "client")]
pub use client::Client;

#[cfg(feature = "server")]
pub mod server;

// Re-export router() as a top-level name
#[cfg(feature = "server")]
pub use self::server::Service;

#[cfg(feature = "server")]
pub mod context;

pub mod models;

#[cfg(any(feature = "client", feature = "server"))]
pub(crate) mod header;
