use async_trait::async_trait;
use bytes::Bytes;
use futures::{Stream, future, future::BoxFuture, stream, future::TryFutureExt, future::FutureExt, stream::StreamExt};
use http_body_util::{combinators::BoxBody, Full};
use hyper::header::{HeaderName, HeaderValue, CONTENT_TYPE};
use hyper::{body::{Body, Incoming}, Request, Response, service::Service, Uri};
use percent_encoding::{utf8_percent_encode, AsciiSet};
use std::borrow::Cow;
use std::convert::{TryInto, Infallible};
use std::io::{ErrorKind, Read};
use std::error::Error;
use std::future::Future;
use std::fmt;
use std::marker::PhantomData;
use std::path::Path;
use std::sync::{Arc, Mutex};
use std::str;
use std::str::FromStr;
use std::string::ToString;
use std::task::{Context, Poll};
use swagger::{ApiError, AuthData, BodyExt, Connector, DropContextService, Has, XSpanIdString};
use url::form_urlencoded;
use tower_service::Service as _;


use crate::models;
use crate::header;

/// https://url.spec.whatwg.org/#fragment-percent-encode-set
#[allow(dead_code)]
const FRAGMENT_ENCODE_SET: &AsciiSet = &percent_encoding::CONTROLS
    .add(b' ').add(b'"').add(b'<').add(b'>').add(b'`');

/// This encode set is used for object IDs
///
/// Aside from the special characters defined in the `PATH_SEGMENT_ENCODE_SET`,
/// the vertical bar (|) is encoded.
#[allow(dead_code)]
const ID_ENCODE_SET: &AsciiSet = &FRAGMENT_ENCODE_SET.add(b'|');

use crate::{Api,
     ConsumerCreateResponse,
     ConsumerUpdateResponse,
     QueueCreateResponse,
     QueueDeleteResponse,
     QueueGetResponse,
     QueuePublishResponse,
     QueueSearchResponse,
     QueueUpdateResponse,
     AccountLocationSearchResponse,
     BlockAccountResponse,
     CreateAccountResponse,
     EditAccountResponse,
     EditUsernameResponse,
     GetAccountResponse,
     GetProfileAssetsResponse,
     GetReferralListResponse,
     GetSettingsResponse,
     LoginDelegateResponse,
     LoginGeneralResponse,
     LoginUsernameResponse,
     LogoutResponse,
     MergeAccountResponse,
     PasswordChangeResponse,
     PasswordResetResponse,
     RequestPasswordResetResponse,
     RequestValidateAccountResponse,
     SearchAccountsResponse,
     SecureLoginResponse,
     SecureSignupResponse,
     SetMatchTokenResponse,
     UpdateActveStatusResponse,
     UpdateLocationResponse,
     UpdateSettingsResponse,
     ValidateAccountSignupResponse,
     ValidatePasswordResetResponse,
     ApiVersionAchievementTierSearchPostResponse,
     CreateAchievementResponse,
     CreateAchievementTierResponse,
     DeleteAchievementResponse,
     DeleteAchievementTierResponse,
     GetAchievementResponse,
     GetAchievementTierResponse,
     GetUserAchievementsResponse,
     ListAchievementTagsResponse,
     ListAchievementsResponse,
     SearchAchievementsResponse,
     UpdateAchievementResponse,
     UpdateAchievementTierResponse,
     UpdateUserAchievementResponse,
     CreateEntityReferenceResponse,
     AddAlbumCollectionResponse,
     AddAlbumUsersResponse,
     ApproveAlbumResponse,
     GetAlbumCollectionResponse,
     LeaveAlbumResponse,
     RemoveAlbumResponse,
     RemoveAlbumUsersResponse,
     SearchAlbumsResponse,
     UpdateAlbumCollectionResponse,
     ActivitiesResponse,
     AggregatedFilteredUsageResponse,
     FilteredUsageResponse,
     UsageResponse,
     UsageBatchResponse,
     GetAppDataResponse,
     PostAppDataResponse,
     RegenAppDataResponse,
     CreateApplicationResponse,
     CreateApplicationPlacementResponse,
     DeleteApplicationResponse,
     DeleteApplicationPlacementResponse,
     GetApplicationResponse,
     GetApplicationPlacementResponse,
     GetApplicationVersionsResponse,
     GetUniqueUsersByAppResponse,
     ListApplicationsResponse,
     SearchApplicationPlacementResponse,
     SearchApplicationSettingsResponse,
     SearchApplicationsResponse,
     UpdateApplicationResponse,
     UpdateApplicationActiveResponse,
     UpdateApplicationPlacementResponse,
     UploadApplicationCertificateResponse,
     CreateApplicationConfigResponse,
     DeleteApplicationConfigResponse,
     GetApplicationConfigResponse,
     GetApplicationConfigByConfigVersionResponse,
     SearchApplicationConfigResponse,
     UpdateApplicationConfigResponse,
     AssetMorphResponse,
     CreateAssetResponse,
     DeleteAssetResponse,
     GetAssetResponse,
     RemoveAssetResponse,
     SearchAssetsResponse,
     UpdateAssetResponse,
     AssetDownloadResponse,
     AssigmentAssigneeAccountSearchResponse,
     AssignmentCreateResponse,
     AssignmentDeleteResponse,
     AssignmentGetResponse,
     AssignmentSearchResponse,
     AssignmentStatusCreateResponse,
     AssignmentStatusDeleteResponse,
     AssignmentStatusGetResponse,
     AssignmentStatusSearchResponse,
     AssignmentStatusUpdateResponse,
     AssignmentUpdateResponse,
     CreateAudienceResponse,
     DeleteAudienceResponse,
     GetAgeGroupsResponse,
     GetAudienceResponse,
     GetAudienceListResponse,
     GetDevicesResponse,
     GetExperiencesResponse,
     GetGroupedAudiencesResponse,
     ListByAccountResponse,
     ListByAudienceResponse,
     ListLastestByAccountResponse,
     SendByAccountResponse,
     UpdateAudienceResponse,
     CreateBidResponse,
     DeleteBidResponse,
     GetBidResponse,
     UpdateBidResponse,
     CreateBillableEntityResponse,
     DeleteBillableEntityResponse,
     GetBillableEntityResponse,
     UpdateBillableEntityResponse,
     AddPaymentMethodResponse,
     CreatePaymentMethodResponse,
     CreateSmartContractResponse,
     GetCryptoBalanceResponse,
     GetPaymentMethodResponse,
     SearchPaymentMethodResponse,
     GetStatusCsvResponse,
     ListStatusCsvResponse,
     StatusCsvResponse,
     UploadCsvResponse,
     CreateCargoTypeResponse,
     SearchCargoTypesResponse,
     DeleteCargoTypeResponse,
     GetCargoTypeResponse,
     UpdateCargoTypeResponse,
     SearchCarriersResponse,
     CategoryDistanceSearchResponse,
     CreateCategoryResponse,
     DeleteCategoryResponse,
     DuplicateCategoryResponse,
     GetCategoryResponse,
     SearchCategoriesResponse,
     UpdateCategoryResponse,
     AddConnectionToGroupResponse,
     AddConnectionsToGroupResponse,
     AddSubGroupsResponse,
     CreateOrUpdateConnectionResponse,
     CreateOrUpdateGroupResponse,
     FollowAcceptResponse,
     FollowRejectResponse,
     FollowRemoveResponse,
     FollowRequestResponse,
     FriendAcceptResponse,
     FriendRejectResponse,
     FriendRemoveResponse,
     FriendRequestResponse,
     GetConnectionSentFriendRequestsResponse,
     GetConnectionsResponse,
     GetGroupDetailsResponse,
     GroupSearchResponse,
     RemoveConnectionFromGroupResponse,
     RemoveConnectionsFromGroupResponse,
     RemoveGroupResponse,
     RemoveSubGroupsResponse,
     SearchConnectionsResponse,
     AddOrUpdateAlbumContestResponse,
     ApproveAlbumContestResponse,
     DeleteContestResponse,
     GetAlbumContestResponse,
     GetAlbumContestsResponse,
     VoteOnAlbumContestResponse,
     AddPreviewResponse,
     AdsFindResponse,
     CreateCreativeResponse,
     DeleteCreativeResponse,
     GetCreativeResponse,
     GetCreativesByApplicationResponse,
     RemovePreviewResponse,
     UpdateCreativeResponse,
     CreateResponse,
     GetDependentsResponse,
     RemoveDependentResponse,
     CheckDisbursementsResponse,
     CreateDisbursementResponse,
     GetDisbursementResponse,
     SearchDisbursementsResponse,
     UpdateDisbursementResponse,
     AssignEmployeeResponse,
     AssignToLocationEmployeeResponse,
     CreateEmployeeResponse,
     DeleteEmployeeResponse,
     GetEmployeeResponse,
     SearchEmployeesResponse,
     UnassignEmployeeResponse,
     UpdateEmployeeResponse,
     AttendEventResponse,
     CreateEventResponse,
     DeleteEventResponse,
     GetEventResponse,
     SearchEventTransactionsResponse,
     SearchEventsResponse,
     UpdateEventResponse,
     GetTokenResponse,
     GraphInterfaceResponse,
     AddFavoriteResponse,
     DeleteFavoriteResponse,
     GetFavoriteResponse,
     SearchFavoritesResponse,
     WhoHasFavoritedResponse,
     CreateFilterResponse,
     DeleteFilterResponse,
     GetFilterResponse,
     SearchFiltersResponse,
     UpdateFilterResponse,
     CreateFlagResponse,
     DeleteFlagResponse,
     GetFlagResponse,
     GetFlagThresholdResponse,
     UpdateFlagThresholdResponse,
     CreateGameResponse,
     DeleteGameResponse,
     GetGameResponse,
     SearchGamesResponse,
     UpdateGameResponse,
     CreateGameLevelResponse,
     DeleteGameLevelResponse,
     GetGameLevelResponse,
     GetGameLevelsByApplicationResponse,
     GetGameLevelsByBillableEntityResponse,
     GetQuestionsInLevelResponse,
     GetWordsInLevelResponse,
     UpdateGameLevelResponse,
     UpdateQuestionsInLevelResponse,
     UpdateWordsInLevelResponse,
     AcceptInviteResponse,
     AlbumContestInviteResponse,
     AlbumInviteResponse,
     EventInviteResponse,
     GameInviteResponse,
     GetInviteResponse,
     MissionInviteResponse,
     OfferInviteResponse,
     OfferLocationInviteResponse,
     RetailerLocationInviteResponse,
     CreateLeaderboardResponse,
     DeleteLeaderboardResponse,
     GetLeaderboardResponse,
     SearchLeaderboardsResponse,
     UpdateLeaderboardResponse,
     RegisterLikeResponse,
     RemoveLikeResponse,
     SearchLikesResponse,
     CreateListingResponse,
     DeleteListingResponse,
     GetListingResponse,
     SearchListingResponse,
     SummaryListingResponse,
     UpdateListingResponse,
     CacheTrilaterationDataResponse,
     CacheTrilaterationDataGzipResponse,
     GetLocationByIpResponse,
     GetLocationByTrilaterationResponse,
     GetLocationsResponse,
     CreateLocationV2Response,
     UpdateLocationV2Response,
     CreateMediaResponse,
     DeleteMediaResponse,
     GetMediaResponse,
     SearchMediaResponse,
     UpdateMediaResponse,
     CreateMissionResponse,
     DeleteMissionResponse,
     FindMissionsResponse,
     GetMissionResponse,
     ImportMissionResponse,
     SearchMissionFormatsResponse,
     SearchMissionsResponse,
     SearchMissionsByBillableEntityResponse,
     UpdateMissionResponse,
     CreateMissionInviteResponse,
     DeleteMissionInviteResponse,
     GetMissionInviteResponse,
     SearchMissionInvitesResponse,
     UpdateMissionInviteResponse,
     BatchOperationResponse,
     CreateNoteResponse,
     DeleteNoteResponse,
     GetNoteResponse,
     SearchNotesResponse,
     UpdateNoteResponse,
     CreateNotificationTemplateResponse,
     CreateOrUpdateBlockedNotificationsResponse,
     DeleteNotificationTemplateResponse,
     GetNotificationTemplateResponse,
     GetNotificationsResponse,
     RegisterNotificationTokenResponse,
     SearchBlockedNotificationsResponse,
     SearchNotificationTemplateResponse,
     SearchRecipientsResponse,
     SearchRecipientsCountResponse,
     SendBatchNotificationsResponse,
     SendCustomNotificationsResponse,
     UpdateNotificationTemplateResponse,
     AddFieldResponse,
     CreateObjectResponse,
     DeleteFieldResponse,
     DeleteObjectResponse,
     GetObjectResponse,
     SearchObjectResponse,
     CreateDataResponse,
     SearchDataResponse,
     DeleteDataResponse,
     GetDataResponse,
     UpdateDataResponse,
     BatchUpdateOfferLocationsResponse,
     CreateOfferResponse,
     DeleteOfferResponse,
     DeleteOfferLocationResponse,
     GetOfferResponse,
     GetOfferDetailsResponse,
     GetOfferListCountsResponse,
     GetOfferLocationResponse,
     GetOfferLocationsForRetailersResponse,
     GetOffersForRetailersResponse,
     RedeemOfferTransactionResponse,
     SearchOfferTransactionsForRetailersResponse,
     SearchOffersForConsumerResponse,
     TopOfferTransactionsResponse,
     UpdateOfferResponse,
     UpdateOfferStatusResponse,
     CreateOfferTransactionStatusResponse,
     DeleteOfferTransactionStatusResponse,
     GetOfferTransactionStatusResponse,
     SearchOfferTransactionStatusesResponse,
     UpdateOfferTransactionStatusResponse,
     ImageGenerationResponse,
     RequestOptimizationResponse,
     GetOptimizationResultResponse,
     AddMovieResponse,
     AiDocsResponse,
     AiFindImagesResponse,
     AiTagsResponse,
     AiTextResponse,
     BatchResponse,
     CreateInstantEpisodeResponse,
     CreateVoiceCanvasResponse,
     EmotionResponse,
     StartVideoRenderResponse,
     SttResponse,
     SummarizeTopicsResponse,
     TechTuneResponse,
     TtsResponse,
     GetAddMovieResultResponse,
     GetBatchResponse,
     GetEmotionResponse,
     GetEpisodeStatusResponse,
     GetRenderStatusResponse,
     GetSttResponse,
     GetTechTuneResponse,
     GetTopicsResponse,
     GetTtsResponse,
     GetVoiceCanvasResponse,
     CreatePackResponse,
     DeletePackResponse,
     GetPackResponse,
     SearchPacksResponse,
     UpdatePackResponse,
     ProcessAllParticipantsResponse,
     ProcessParticipantsResponse,
     ComputePathResponse,
     CreatePostalCodeResponse,
     DeletePostalCodeResponse,
     GetPostalCodeResponse,
     GetPostalCodesResponse,
     UpdatePostalCodeResponse,
     CreatePersonaResponse,
     DeletePersonaResponse,
     GetPersonaListResponse,
     SearchPersonaResponse,
     UpdatePersonaResponse,
     CreateProgramResponse,
     SearchProgramsResponse,
     DeleteProgramResponse,
     GetProgramResponse,
     PostProgramResponse,
     PutProgramResponse,
     CreatePurchaseItemResponse,
     DeletePurchaseItemResponse,
     GetPurchaseItemResponse,
     SearchPurchaseItemsResponse,
     UpdatePurchaseItemResponse,
     CreateOrderResponse,
     DeleteOrderResponse,
     GetOrderResponse,
     PreviewOrderResponse,
     SearchOrdersResponse,
     UpdateOrderResponse,
     CreateQuestionResponse,
     DeleteQuestionResponse,
     GetQuestionResponse,
     SearchQuestionsResponse,
     UpdateQuestionResponse,
     GetHistoricalRankingsResponse,
     GetRankingsResponse,
     GetUserRankResponse,
     OverrideUserRankResponse,
     UpdateRankingsResponse,
     CreateRatingResponse,
     DeleteRatingResponse,
     SearchLocationRatingIndexesResponse,
     SearchRatingIndexesResponse,
     SearchRatingsResponse,
     UpdateRatingResponse,
     CreateRegionResponse,
     DeleteRegionResponse,
     GetRegionResponse,
     SearchRegionsResponse,
     UpdateRegionResponse,
     CreateBatchResponse,
     CreateRegionLegSummaryBatchResponse,
     DeleteBatchResponse,
     GetReportBatchResponse,
     RunReportResponse,
     SearchBatchResponse,
     CreateReservationResponse,
     DeleteReservationResponse,
     ReservableAvailabilityResponse,
     SearchAvailabilityResponse,
     SearchReservationsResponse,
     SearchScheduleResponse,
     CreateRetailerResponse,
     DeleteRetailerResponse,
     GetRetailerResponse,
     GetRetailersResponse,
     RetailerLoginCheckResponse,
     UpdateRetailerResponse,
     CreateRetailerLocationConsumerResponse,
     CreateRetailerLocationsResponse,
     DeleteRetailerLocationResponse,
     GetRetailerLocationResponse,
     GetRetailerLocationConsumerResponse,
     IndexedRetailerLocationDistanceSearchResponse,
     IndexedRetailerLocationSearchResponse,
     SearchRetailerLocationsResponse,
     UpdateRetailerLocationsResponse,
     GetRetaokilerResponse,
     CreateRouteResponse,
     SearchRoutesResponse,
     ApproveRouteResponse,
     CopyRouteResponse,
     CreateRouteDirectionsResponse,
     CreateRoutePolylineResponse,
     DeleteRouteResponse,
     DisapproveRouteResponse,
     GetRouteResponse,
     GetRouteDirectionsResponse,
     GetRouteShipmentsResponse,
     GetRouteStopsResponse,
     OptimizeRouteResponse,
     ReorderRouteStopsPatchResponse,
     ReorderRouteStopsPostResponse,
     UpdateRouteResponse,
     GetRouteStopResponse,
     GetShipmentsAtStopResponse,
     RemoveStopResponse,
     SetDriverResponse,
     UpdateRouteStopResponse,
     CreateRouteSettingsResponse,
     SearchRouteSettingsResponse,
     DeleteRouteSettingsResponse,
     GetRouteSettingsResponse,
     UpdateRouteSettingsResponse,
     ComputeRoutingResponse,
     CreateScheduledNotificationResponse,
     DeleteScheduledNotificationResponse,
     GetScheduledNotificationResponse,
     ScheduleNotificationListingsResponse,
     SearchScheduledNotificationsResponse,
     UpdateScheduledNotificationResponse,
     CreateScoreResponse,
     GetScoreResponse,
     SearchScoresResponse,
     CreateSecureApplicationResponse,
     DeleteSecureApplicationResponse,
     LoginSecureResponse,
     PurchaseSecureResponse,
     ResetSecureResponse,
     UpdateSecureApplicationResponse,
     CreateServiceHubResponse,
     SearchServiceHubsResponse,
     DeleteServiceHubResponse,
     GetServiceHubResponse,
     PostServiceHubResponse,
     PutServiceHubResponse,
     CreateShipmentResponse,
     SearchShipmentsResponse,
     CancelShipmentResponse,
     DeleteShipmentResponse,
     GetShipmentResponse,
     UpdateShipmentResponse,
     UpdateShipmentStatusResponse,
     CreateShipmentBatchResponse,
     SearchShipmentBatchResponse,
     DeleteShipmentBatchResponse,
     GetShipmentBatchResponse,
     GetShipmentBatchStatusResponse,
     SimulationResponse,
     GetStopResponse,
     UpdateStopResponse,
     CreateStripeCheckoutSessionResponse,
     CreateSubscriptionResponse,
     DeleteSubscriptionResponse,
     GetSubscriptionResponse,
     GetSubscriptionPlanResponse,
     GetSubscriptionPlansResponse,
     GetSubscriptionUsageResponse,
     UpdateSubscriptionResponse,
     CreateTaskResponse,
     DeleteTaskResponse,
     GetTaskResponse,
     SearchTasksResponse,
     UpdateTaskResponse,
     CreateTerritoryResponse,
     DeleteTerritoryResponse,
     GetTerritoryResponse,
     SearchTerritoriesResponse,
     UpdateTerritoryResponse,
     AddOrUpdateThemeDescriptorResponse,
     GetThemeDescriptorResponse,
     GetThemeDescriptorsResponse,
     RemoveThemeDescriptorResponse,
     CreateCredentialResponse,
     CreateNetworkResponse,
     DeleteCredentialResponse,
     DeleteNetworkResponse,
     GetCredentialResponse,
     GetNetworkResponse,
     SearchCredentialsResponse,
     SearchNetworksResponse,
     SendMfaChallengeResponse,
     UpdateCredentialResponse,
     UpdateNetworkResponse,
     GetTicketCountResponse,
     GetTicketListResponse,
     GiftPurchaseResponse,
     SaveTicketResponse,
     SaveTicketViaFileUploadResponse,
     TicketOffersResponse,
     CreateTournamentResponse,
     DeleteTournamentResponse,
     GetTournamentResponse,
     SearchObjectsResponse,
     SearchRoundsResponse,
     SearchTournamentsResponse,
     SubmitTournamentScoreResponse,
     SubmitTournamentVoteResponse,
     SubstituteTournamentPlayerResponse,
     UpdateTournamentResponse,
     BatchSaveTrackingResponse,
     GetPredictedLocationsResponse,
     GetPredictedPathResponse,
     GetPreferredLocationsResponse,
     GetTrackingLegsResponse,
     SaveTrackingLegResponse,
     SaveTrackingStepResponse,
     SearchAccountsWithTrackingLegsResponse,
     SearchTrackingLegsResponse,
     CreateTriggerResponse,
     DeleteTriggerResponse,
     GetTriggerResponse,
     SearchTriggersResponse,
     UpdateTriggerResponse,
     CreateTripResponse,
     ProcessTripMatchesResponse,
     SearchResponse,
     SearchTripsResponse,
     UpdateTripNotificationsResponse,
     DeleteResponse,
     DriveTripResponse,
     FlexibleTripResponse,
     GetTripResponse,
     GetTripMatchesResponse,
     RideResponse,
     UpdateLocationsResponse,
     UpdateRecurrenceLocationsResponse,
     UpdateRecurrenceShipmentsResponse,
     UpdateShipmentsResponse,
     UpdateTripResponse,
     SmsBuyOfferResponse,
     AuthorizeTwitterResponse,
     LoginTwitterResponse,
     AddUsersToPermissionableResponse,
     ApprovePermissionableResponse,
     LeaveFromPermissionableResponse,
     RemoveUsersFromPermissionableResponse,
     SearchPermissionablesResponse,
     SearchPermissionablesFollowingDistanceResponse,
     CreateFollowingResponse,
     CreateSpaceResponse,
     CreateVatomEventResponse,
     DeleteFollowingResponse,
     DeletePointsBalanceResponse,
     DeleteSpaceResponse,
     DeleteVatomEventResponse,
     DeleteVatomNftResponse,
     ExecuteActionOnNftResponse,
     GeomapSearchResponse,
     GetBusinessBehaviorsResponse,
     GetBusinessCoinsBalanceResponse,
     GetBusinessIdsResponse,
     GetBusinessInfoResponse,
     GetBusinessUsersResponse,
     GetCampaignGroupEntitiesResponse,
     GetCampaignGroupRulesResponse,
     GetCampaignGroupStatsResponse,
     GetCampaignInfoResponse,
     GetEventGuestListResponse,
     GetInventoryResponse,
     GetMyFollowingResponse,
     GetPointsBalanceResponse,
     GetPointsBalanceAsBusinessResponse,
     GetSpaceResponse,
     GetUserCoinsAsBusinessResponse,
     GetUserCoinsBalanceResponse,
     GetUserFollowersResponse,
     GetUserFollowingResponse,
     GetUserInfoResponse,
     GetUserProfileResponse,
     GetVatomEventResponse,
     GetVatomNftResponse,
     ListCommunitiesResponse,
     ListEventsResponse,
     ListSpacesResponse,
     ListUserCoinTransactionsResponse,
     ListUserCoinTransactionsAsBusinessResponse,
     PerformActionOnNftResponse,
     RedeemNftResponse,
     RedeemUserCoinsAsBusinessResponse,
     SearchBusinessesResponse,
     SearchCampaignGroupsResponse,
     SearchIdentitiesResponse,
     SearchInventoryResponse,
     SendNftResponse,
     SetPointsBalanceAsBusinessResponse,
     TransferUserCoinsResponse,
     UpdateBusinessCoinsResponse,
     UpdateEventGuestListResponse,
     UpdateSpaceResponse,
     UpdateUserCoinsAsBusinessResponse,
     UpdateUserProfileResponse,
     UpdateVatomEventResponse,
     CreateVehicleResponse,
     SearchVehicleResponse,
     DeleteVehicleResponse,
     GetVehicleResponse,
     UpdateVehicleResponse,
     CreateVehicleTypeResponse,
     SearchVehicleTypesResponse,
     DeleteVehicleTypeResponse,
     GetVehicleTypeResponse,
     UpdateVehicleTypeResponse,
     CreateOfferTransactionResponse,
     DeleteOfferTransactionResponse,
     GetOfferTransactionResponse,
     PreviewOfferTransactionResponse,
     SearchOfferTransactionsResponse,
     UpdateOfferTransactionResponse,
     SearchWeatherResponse,
     CreateWordResponse,
     DeleteWordResponse,
     GetWordResponse,
     GetWordsResponse,
     UpdateWordResponse,
     RunWorkflowResponse
     };

/// Convert input into a base path, e.g. "http://example:123". Also checks the scheme as it goes.
fn into_base_path(input: impl TryInto<Uri, Error=hyper::http::uri::InvalidUri>, correct_scheme: Option<&'static str>) -> Result<String, ClientInitError> {
    // First convert to Uri, since a base path is a subset of Uri.
    let uri = input.try_into()?;

    let scheme = uri.scheme_str().ok_or(ClientInitError::InvalidScheme)?;

    // Check the scheme if necessary
    if let Some(correct_scheme) = correct_scheme {
        if scheme != correct_scheme {
            return Err(ClientInitError::InvalidScheme);
        }
    }

    let host = uri.host().ok_or(ClientInitError::MissingHost)?;
    let port = uri.port_u16().map(|x| format!(":{x}")).unwrap_or_default();
    Ok(format!("{scheme}://{host}{port}{}", uri.path().trim_end_matches('/')))
}

/// A client that implements the API by making HTTP calls out to a server.
pub struct Client<S, C> where
    S: Service<
           (Request<BoxBody<Bytes, Infallible>>, C)> + Clone + Sync + Send + 'static,
    S::Future: Send + 'static,
    S::Error: Into<crate::ServiceError> + fmt::Display,
    C: Clone + Send + Sync + 'static
{
    /// Inner service
    client_service: S,

    /// Base path of the API
    base_path: String,

    /// Marker
    marker: PhantomData<fn(C)>,
}

impl<S, C> fmt::Debug for Client<S, C> where
    S: Service<
           (Request<BoxBody<Bytes, Infallible>>, C)> + Clone + Sync + Send + 'static,
    S::Future: Send + 'static,
    S::Error: Into<crate::ServiceError> + fmt::Display,
    C: Clone + Send + Sync + 'static
{
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "Client {{ base_path: {} }}", self.base_path)
    }
}

impl<S, C> Clone for Client<S, C> where
    S: Service<
           (Request<BoxBody<Bytes, Infallible>>, C)> + Clone + Sync + Send + 'static,
    S::Future: Send + 'static,
    S::Error: Into<crate::ServiceError> + fmt::Display,
    C: Clone + Send + Sync + 'static
{
    fn clone(&self) -> Self {
        Self {
            client_service: self.client_service.clone(),
            base_path: self.base_path.clone(),
            marker: PhantomData,
        }
    }
}

impl<Connector, C> Client<
    DropContextService<
        hyper_util::service::TowerToHyperService<
            hyper_util::client::legacy::Client<
                Connector,
                BoxBody<Bytes, Infallible>
            >
        >,
        C
    >,
    C
> where
    Connector: hyper_util::client::legacy::connect::Connect + Clone + Send + Sync + 'static,
    C: Clone + Send + Sync + 'static,
{
    /// Create a client with a custom implementation of hyper::client::Connect.
    ///
    /// Intended for use with custom implementations of connect for e.g. protocol logging
    /// or similar functionality which requires wrapping the transport layer. When wrapping a TCP connection,
    /// this function should be used in conjunction with `swagger::Connector::builder()`.
    ///
    /// For ordinary tcp connections, prefer the use of `try_new_http`, `try_new_https`
    /// and `try_new_https_mutual`, to avoid introducing a dependency on the underlying transport layer.
    ///
    /// # Arguments
    ///
    /// * `base_path` - base path of the client API, i.e. "<http://www.my-api-implementation.com>"
    /// * `protocol` - Which protocol to use when constructing the request url, e.g. `Some("http")`
    /// * `connector` - Implementation of `hyper::client::Connect` to use for the client
    pub fn try_new_with_connector(
        base_path: &str,
        protocol: Option<&'static str>,
        connector: Connector,
    ) -> Result<Self, ClientInitError>
    {
        let client_service = hyper_util::client::legacy::Client::builder(hyper_util::rt::TokioExecutor::new()).build(connector);
        let client_service = DropContextService::new(hyper_util::service::TowerToHyperService::new(client_service));

        Ok(Self {
            client_service,
            base_path: into_base_path(base_path, protocol)?,
            marker: PhantomData,
        })
    }
}

#[cfg(all(feature = "client-tls", any(target_os = "macos", target_os = "windows", target_os = "ios")))]
type HyperHttpsConnector = hyper_tls::HttpsConnector<hyper_util::client::legacy::connect::HttpConnector>;

#[cfg(all(feature = "client-tls", not(any(target_os = "macos", target_os = "windows", target_os = "ios"))))]
type HyperHttpsConnector = hyper_openssl::client::legacy::HttpsConnector<hyper_util::client::legacy::connect::HttpConnector>;

#[derive(Debug, Clone)]
pub enum HyperClient {
    Http(hyper_util::client::legacy::Client<hyper_util::client::legacy::connect::HttpConnector, BoxBody<Bytes, Infallible>>),
    #[cfg(feature = "client-tls")]
    Https(hyper_util::client::legacy::Client<HyperHttpsConnector, BoxBody<Bytes, Infallible>>),
}

impl Service<Request<BoxBody<Bytes, Infallible>>> for HyperClient {
    type Response = Response<Incoming>;
    type Error = hyper_util::client::legacy::Error;
    type Future = hyper_util::client::legacy::ResponseFuture;

    fn call(&self, req: Request<BoxBody<Bytes, Infallible>>) -> Self::Future {
       match self {
          HyperClient::Http(client) => client.request(req),
          #[cfg(feature = "client-tls")]
          HyperClient::Https(client) => client.request(req),
       }
    }
}

impl<C> Client<DropContextService<HyperClient, C>, C> where
    C: Clone + Send + Sync + 'static,
{
    /// Create an HTTP client.
    ///
    /// # Arguments
    /// * `base_path` - base path of the client API, i.e. "<http://www.my-api-implementation.com>"
    pub fn try_new(
        base_path: &str,
    ) -> Result<Self, ClientInitError> {
        let uri = Uri::from_str(base_path)?;

        let scheme = uri.scheme_str().ok_or(ClientInitError::InvalidScheme)?;
        let scheme = scheme.to_ascii_lowercase();

        let connector = Connector::builder();

        let client_service = match scheme.as_str() {
            "http" => {
                HyperClient::Http(hyper_util::client::legacy::Client::builder(hyper_util::rt::TokioExecutor::new()).build(connector.build()))
            },
            #[cfg(feature = "client-tls")]
            "https" => {
                let https_connector = connector
                    .https()
                    .build()
                    .map_err(ClientInitError::SslError)?;
                HyperClient::Https(hyper_util::client::legacy::Client::builder(hyper_util::rt::TokioExecutor::new()).build(https_connector))
            },
            #[cfg(not(feature = "client-tls"))]
            "https" => {
                return Err(ClientInitError::TlsNotEnabled);
            },
            _ => {
                return Err(ClientInitError::InvalidScheme);
            }
        };

        let client_service = DropContextService::new(client_service);

        Ok(Self {
            client_service,
            base_path: into_base_path(base_path, None)?,
            marker: PhantomData,
        })
    }
}

impl<C> Client<
    DropContextService<
        hyper_util::service::TowerToHyperService<
            hyper_util::client::legacy::Client<
                hyper_util::client::legacy::connect::HttpConnector,
                BoxBody<Bytes, Infallible>
            >
        >,
        C
    >,
    C
> where
    C: Clone + Send + Sync + 'static
{
    /// Create an HTTP client.
    ///
    /// # Arguments
    /// * `base_path` - base path of the client API, i.e. "<http://www.my-api-implementation.com>"
    pub fn try_new_http(
        base_path: &str,
    ) -> Result<Self, ClientInitError> {
        let http_connector = Connector::builder().build();

        Self::try_new_with_connector(base_path, Some("http"), http_connector)
    }
}

#[cfg(all(feature = "client-tls", any(target_os = "macos", target_os = "windows", target_os = "ios")))]
type HttpsConnector = hyper_tls::HttpsConnector<hyper_util::client::legacy::connect::HttpConnector>;

#[cfg(all(feature = "client-tls", not(any(target_os = "macos", target_os = "windows", target_os = "ios"))))]
type HttpsConnector = hyper_openssl::client::legacy::HttpsConnector<hyper_util::client::legacy::connect::HttpConnector>;

#[cfg(feature = "client-tls")]
impl<C> Client<
    DropContextService<
        hyper_util::service::TowerToHyperService<
            hyper_util::client::legacy::Client<
                HttpsConnector,
                BoxBody<Bytes, Infallible>
            >
        >,
        C
    >,
    C
> where
    C: Clone + Send + Sync + 'static
{
    /// Create a client with a TLS connection to the server.
    ///
    /// # Arguments
    /// * `base_path` - base path of the client API, i.e. "<https://www.my-api-implementation.com>"
    #[cfg(any(target_os = "macos", target_os = "windows", target_os = "ios"))]
    pub fn try_new_https(base_path: &str) -> Result<Self, ClientInitError>
    {
        let https_connector = Connector::builder()
            .https()
            .build()
            .map_err(ClientInitError::SslError)?;
        Self::try_new_with_connector(base_path, Some("https"), https_connector)
    }

    /// Create a client with a TLS connection to the server using OpenSSL via swagger.
    ///
    /// # Arguments
    /// * `base_path` - base path of the client API, i.e. "<https://www.my-api-implementation.com>"
    #[cfg(not(any(target_os = "macos", target_os = "windows", target_os = "ios")))]
    pub fn try_new_https(base_path: &str) -> Result<Self, ClientInitError>
    {
        let https_connector = Connector::builder()
            .https()
            .build()
            .map_err(ClientInitError::SslError)?;
        Self::try_new_with_connector(base_path, Some("https"), https_connector)
    }

    /// Create a client with a TLS connection to the server using a pinned certificate.
    ///
    /// # Arguments
    /// * `base_path` - base path of the client API, i.e. "<https://www.my-api-implementation.com>"
    /// * `ca_certificate` - Path to CA certificate used to authenticate the server
    #[cfg(not(any(target_os = "macos", target_os = "windows", target_os = "ios")))]
    pub fn try_new_https_pinned<CA>(
        base_path: &str,
        ca_certificate: CA,
    ) -> Result<Self, ClientInitError>
    where
        CA: AsRef<Path>,
    {
        let https_connector = Connector::builder()
            .https()
            .pin_server_certificate(ca_certificate)
            .build()
            .map_err(ClientInitError::SslError)?;
        Self::try_new_with_connector(base_path, Some("https"), https_connector)
    }

    /// Create a client with a mutually authenticated TLS connection to the server.
    ///
    /// # Arguments
    /// * `base_path` - base path of the client API, i.e. "<https://www.my-api-implementation.com>"
    /// * `ca_certificate` - Path to CA certificate used to authenticate the server
    /// * `client_key` - Path to the client private key
    /// * `client_certificate` - Path to the client's public certificate associated with the private key
    #[cfg(not(any(target_os = "macos", target_os = "windows", target_os = "ios")))]
    pub fn try_new_https_mutual<CA, K, D>(
        base_path: &str,
        ca_certificate: CA,
        client_key: K,
        client_certificate: D,
    ) -> Result<Self, ClientInitError>
    where
        CA: AsRef<Path>,
        K: AsRef<Path>,
        D: AsRef<Path>,
    {
        let https_connector = Connector::builder()
            .https()
            .pin_server_certificate(ca_certificate)
            .client_authentication(client_key, client_certificate)
            .build()
            .map_err(ClientInitError::SslError)?;
        Self::try_new_with_connector(base_path, Some("https"), https_connector)
    }
}

impl<S, C> Client<S, C> where
    S: Service<
           (Request<BoxBody<Bytes, Infallible>>, C)> + Clone + Sync + Send + 'static,
    S::Future: Send + 'static,
    S::Error: Into<crate::ServiceError> + fmt::Display,
    C: Clone + Send + Sync + 'static
{
    /// Constructor for creating a `Client` by passing in a pre-made `hyper::service::Service` /
    /// `tower::Service`
    ///
    /// This allows adding custom wrappers around the underlying transport, for example for logging.
    pub fn try_new_with_client_service(
        client_service: S,
        base_path: &str,
    ) -> Result<Self, ClientInitError>
    {
        Ok(Self {
            client_service,
            base_path: into_base_path(base_path, None)?,
            marker: PhantomData,
        })
    }
}

/// Error type failing to create a Client
#[derive(Debug)]
pub enum ClientInitError {
    /// Invalid URL Scheme
    InvalidScheme,

    /// Invalid URI
    InvalidUri(hyper::http::uri::InvalidUri),

    /// Missing Hostname
    MissingHost,

    /// HTTPS requested but TLS features not enabled
    TlsNotEnabled,

    /// SSL Connection Error
    #[cfg(all(feature = "client-tls", any(target_os = "macos", target_os = "windows", target_os = "ios")))]
    SslError(native_tls::Error),

    /// SSL Connection Error
    #[cfg(all(feature = "client-tls", not(any(target_os = "macos", target_os = "windows", target_os = "ios"))))]
    SslError(openssl::error::ErrorStack),
}

impl From<hyper::http::uri::InvalidUri> for ClientInitError {
    fn from(err: hyper::http::uri::InvalidUri) -> ClientInitError {
        ClientInitError::InvalidUri(err)
    }
}

impl fmt::Display for ClientInitError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let s: &dyn fmt::Debug = self;
        s.fmt(f)
    }
}

impl Error for ClientInitError {
    fn description(&self) -> &str {
        "Failed to produce a hyper client."
    }
}

#[allow(dead_code)]
fn body_from_string(s: String) -> BoxBody<Bytes, Infallible> {
    BoxBody::new(Full::new(Bytes::from(s)))
}

#[async_trait]
impl<S, C, B> Api<C> for Client<S, C> where
    S: Service<
       (Request<BoxBody<Bytes, Infallible>>, C),
       Response=Response<B>> + Clone + Sync + Send + 'static,
    S::Future: Send + 'static,
    S::Error: Into<crate::ServiceError> + fmt::Display,
    C: Has<XSpanIdString> + Has<Option<AuthData>> + Clone + Send + Sync + 'static,
    B: hyper::body::Body + Send + 'static + Unpin,
    B::Data: Send,
    B::Error: Into<Box<dyn Error + Send + Sync>>,
{

    #[allow(clippy::vec_init_then_push)]
    async fn consumer_create(
        &self,
        param_version: f64,
        param_app_key: String,
        param_name: String,
        param_hostname: String,
        param_username: String,
        param_password: String,
        param_data_mapping: String,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_port: Option<i32>,
        param_virtual_host: Option<String>,
        param_exchanger: Option<String>,
        param_exchanger_type: Option<String>,
        param_workers: Option<i32>,
        param_use_ssl: Option<bool>,
        context: &C) -> Result<ConsumerCreateResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/queue/consumer/create",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
                query_string.append_pair("appKey",
                    &param_app_key);
                query_string.append_pair("name",
                    &param_name);
                query_string.append_pair("hostname",
                    &param_hostname);
            if let Some(param_port) = param_port {
                query_string.append_pair("port",
                    &param_port.to_string());
            }
                query_string.append_pair("username",
                    &param_username);
                query_string.append_pair("password",
                    &param_password);
            if let Some(param_virtual_host) = param_virtual_host {
                query_string.append_pair("virtualHost",
                    &param_virtual_host);
            }
            if let Some(param_exchanger) = param_exchanger {
                query_string.append_pair("exchanger",
                    &param_exchanger);
            }
            if let Some(param_exchanger_type) = param_exchanger_type {
                query_string.append_pair("exchangerType",
                    &param_exchanger_type);
            }
            if let Some(param_workers) = param_workers {
                query_string.append_pair("workers",
                    &param_workers.to_string());
            }
                query_string.append_pair("dataMapping",
                    &param_data_mapping);
            if let Some(param_use_ssl) = param_use_ssl {
                query_string.append_pair("useSSL",
                    &param_use_ssl.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::QueueResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(ConsumerCreateResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn consumer_update(
        &self,
        param_version: f64,
        param_app_key: String,
        param_queue_id: i64,
        param_data_mapping: String,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_use_ssl: Option<bool>,
        context: &C) -> Result<ConsumerUpdateResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/queue/consumer/update",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
                query_string.append_pair("appKey",
                    &param_app_key);
                query_string.append_pair("queueId",
                    &param_queue_id.to_string());
                query_string.append_pair("dataMapping",
                    &param_data_mapping);
            if let Some(param_use_ssl) = param_use_ssl {
                query_string.append_pair("useSSL",
                    &param_use_ssl.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::QueueResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(ConsumerUpdateResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn queue_create(
        &self,
        param_version: f64,
        param_app_key: String,
        param_name: String,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_workers: Option<i32>,
        param_analytic_tags: Option<String>,
        param_hostname: Option<String>,
        param_port: Option<i32>,
        param_username: Option<String>,
        param_password: Option<String>,
        param_virtual_host: Option<String>,
        param_use_ssl: Option<bool>,
        context: &C) -> Result<QueueCreateResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/queue/create",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
                query_string.append_pair("appKey",
                    &param_app_key);
                query_string.append_pair("name",
                    &param_name);
            if let Some(param_workers) = param_workers {
                query_string.append_pair("workers",
                    &param_workers.to_string());
            }
            if let Some(param_analytic_tags) = param_analytic_tags {
                query_string.append_pair("analyticTags",
                    &param_analytic_tags);
            }
            if let Some(param_hostname) = param_hostname {
                query_string.append_pair("hostname",
                    &param_hostname);
            }
            if let Some(param_port) = param_port {
                query_string.append_pair("port",
                    &param_port.to_string());
            }
            if let Some(param_username) = param_username {
                query_string.append_pair("username",
                    &param_username);
            }
            if let Some(param_password) = param_password {
                query_string.append_pair("password",
                    &param_password);
            }
            if let Some(param_virtual_host) = param_virtual_host {
                query_string.append_pair("virtualHost",
                    &param_virtual_host);
            }
            if let Some(param_use_ssl) = param_use_ssl {
                query_string.append_pair("useSSL",
                    &param_use_ssl.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::QueueResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(QueueCreateResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn queue_delete(
        &self,
        param_version: f64,
        param_queue_id: i64,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        context: &C) -> Result<QueueDeleteResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/queue/delete",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
                query_string.append_pair("queueId",
                    &param_queue_id.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(QueueDeleteResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn queue_get(
        &self,
        param_version: f64,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_queue_id: Option<i64>,
        param_app_key: Option<String>,
        param_name: Option<String>,
        param_hostname: Option<String>,
        param_virtual_host: Option<String>,
        context: &C) -> Result<QueueGetResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/queue/get",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_queue_id) = param_queue_id {
                query_string.append_pair("queueId",
                    &param_queue_id.to_string());
            }
            if let Some(param_app_key) = param_app_key {
                query_string.append_pair("appKey",
                    &param_app_key);
            }
            if let Some(param_name) = param_name {
                query_string.append_pair("name",
                    &param_name);
            }
            if let Some(param_hostname) = param_hostname {
                query_string.append_pair("hostname",
                    &param_hostname);
            }
            if let Some(param_virtual_host) = param_virtual_host {
                query_string.append_pair("virtualHost",
                    &param_virtual_host);
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::QueueResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(QueueGetResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn queue_publish(
        &self,
        param_version: f64,
        param_message: String,
        param_queue_id: Option<i64>,
        param_app_key: Option<String>,
        param_name: Option<String>,
        param_hostname: Option<String>,
        param_virtual_host: Option<String>,
        context: &C) -> Result<QueuePublishResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/queue/publish",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_queue_id) = param_queue_id {
                query_string.append_pair("queueId",
                    &param_queue_id.to_string());
            }
            if let Some(param_app_key) = param_app_key {
                query_string.append_pair("appKey",
                    &param_app_key);
            }
            if let Some(param_name) = param_name {
                query_string.append_pair("name",
                    &param_name);
            }
            if let Some(param_hostname) = param_hostname {
                query_string.append_pair("hostname",
                    &param_hostname);
            }
            if let Some(param_virtual_host) = param_virtual_host {
                query_string.append_pair("virtualHost",
                    &param_virtual_host);
            }
                query_string.append_pair("message",
                    &param_message);
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(QueuePublishResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn queue_search(
        &self,
        param_version: f64,
        param_queue_id: Option<i64>,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_name: Option<String>,
        param_start: Option<i32>,
        param_limit: Option<i32>,
        context: &C) -> Result<QueueSearchResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/queue/search",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_queue_id) = param_queue_id {
                query_string.append_pair("queueId",
                    &param_queue_id.to_string());
            }
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_name) = param_name {
                query_string.append_pair("name",
                    &param_name);
            }
            if let Some(param_start) = param_start {
                query_string.append_pair("start",
                    &param_start.to_string());
            }
            if let Some(param_limit) = param_limit {
                query_string.append_pair("limit",
                    &param_limit.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::QueueResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(QueueSearchResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn queue_update(
        &self,
        param_version: f64,
        param_queue_id: i64,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_app_key: Option<String>,
        param_workers: Option<i32>,
        param_analytic_tags: Option<String>,
        param_hostname: Option<String>,
        param_port: Option<i32>,
        param_username: Option<String>,
        param_password: Option<String>,
        param_virtual_host: Option<String>,
        param_use_ssl: Option<bool>,
        context: &C) -> Result<QueueUpdateResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/queue/update",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_app_key) = param_app_key {
                query_string.append_pair("appKey",
                    &param_app_key);
            }
                query_string.append_pair("queueId",
                    &param_queue_id.to_string());
            if let Some(param_workers) = param_workers {
                query_string.append_pair("workers",
                    &param_workers.to_string());
            }
            if let Some(param_analytic_tags) = param_analytic_tags {
                query_string.append_pair("analyticTags",
                    &param_analytic_tags);
            }
            if let Some(param_hostname) = param_hostname {
                query_string.append_pair("hostname",
                    &param_hostname);
            }
            if let Some(param_port) = param_port {
                query_string.append_pair("port",
                    &param_port.to_string());
            }
            if let Some(param_username) = param_username {
                query_string.append_pair("username",
                    &param_username);
            }
            if let Some(param_password) = param_password {
                query_string.append_pair("password",
                    &param_password);
            }
            if let Some(param_virtual_host) = param_virtual_host {
                query_string.append_pair("virtualHost",
                    &param_virtual_host);
            }
            if let Some(param_use_ssl) = param_use_ssl {
                query_string.append_pair("useSSL",
                    &param_use_ssl.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::QueueResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(QueueUpdateResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn account_location_search(
        &self,
        param_version: f64,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_q: Option<String>,
        param_keyword: Option<String>,
        param_postal_code: Option<String>,
        param_latitude: Option<f64>,
        param_longitude: Option<f64>,
        param_app_key: Option<String>,
        param_range: Option<f64>,
        param_location_last_updated: Option<i64>,
        param_gender: Option<String>,
        param_min_age: Option<i32>,
        param_max_age: Option<i32>,
        param_companionship_index: Option<i32>,
        param__i: Option<i32>,
        param_start: Option<i32>,
        param__l: Option<i32>,
        param_limit: Option<i32>,
        param_search_mode: Option<String>,
        param_sort_field: Option<String>,
        param_descending: Option<bool>,
        param_roles: Option<String>,
        param_tags: Option<String>,
        param_experience: Option<String>,
        param_category_ids: Option<String>,
        param_audience_ids: Option<String>,
        param_audience_operator: Option<String>,
        param_update_current_location: Option<bool>,
        param_update_preferred_settings: Option<bool>,
        param_show_exact_locations: Option<bool>,
        param_show_connection_to_searcher: Option<bool>,
        param_flag_count_minimum: Option<i64>,
        param_verified_user_only: Option<bool>,
        param_content_admin_only: Option<bool>,
        context: &C) -> Result<AccountLocationSearchResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/account/search",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_q) = param_q {
                query_string.append_pair("q",
                    &param_q);
            }
            if let Some(param_keyword) = param_keyword {
                query_string.append_pair("keyword",
                    &param_keyword);
            }
            if let Some(param_postal_code) = param_postal_code {
                query_string.append_pair("postalCode",
                    &param_postal_code);
            }
            if let Some(param_latitude) = param_latitude {
                query_string.append_pair("latitude",
                    &param_latitude.to_string());
            }
            if let Some(param_longitude) = param_longitude {
                query_string.append_pair("longitude",
                    &param_longitude.to_string());
            }
            if let Some(param_app_key) = param_app_key {
                query_string.append_pair("appKey",
                    &param_app_key);
            }
            if let Some(param_range) = param_range {
                query_string.append_pair("range",
                    &param_range.to_string());
            }
            if let Some(param_location_last_updated) = param_location_last_updated {
                query_string.append_pair("locationLastUpdated",
                    &param_location_last_updated.to_string());
            }
            if let Some(param_gender) = param_gender {
                query_string.append_pair("gender",
                    &param_gender);
            }
            if let Some(param_min_age) = param_min_age {
                query_string.append_pair("minAge",
                    &param_min_age.to_string());
            }
            if let Some(param_max_age) = param_max_age {
                query_string.append_pair("maxAge",
                    &param_max_age.to_string());
            }
            if let Some(param_companionship_index) = param_companionship_index {
                query_string.append_pair("companionshipIndex",
                    &param_companionship_index.to_string());
            }
            if let Some(param__i) = param__i {
                query_string.append_pair("_i",
                    &param__i.to_string());
            }
            if let Some(param_start) = param_start {
                query_string.append_pair("start",
                    &param_start.to_string());
            }
            if let Some(param__l) = param__l {
                query_string.append_pair("_l",
                    &param__l.to_string());
            }
            if let Some(param_limit) = param_limit {
                query_string.append_pair("limit",
                    &param_limit.to_string());
            }
            if let Some(param_search_mode) = param_search_mode {
                query_string.append_pair("searchMode",
                    &param_search_mode);
            }
            if let Some(param_sort_field) = param_sort_field {
                query_string.append_pair("sortField",
                    &param_sort_field);
            }
            if let Some(param_descending) = param_descending {
                query_string.append_pair("descending",
                    &param_descending.to_string());
            }
            if let Some(param_roles) = param_roles {
                query_string.append_pair("roles",
                    &param_roles);
            }
            if let Some(param_tags) = param_tags {
                query_string.append_pair("tags",
                    &param_tags);
            }
            if let Some(param_experience) = param_experience {
                query_string.append_pair("experience",
                    &param_experience);
            }
            if let Some(param_category_ids) = param_category_ids {
                query_string.append_pair("categoryIds",
                    &param_category_ids);
            }
            if let Some(param_audience_ids) = param_audience_ids {
                query_string.append_pair("audienceIds",
                    &param_audience_ids);
            }
            if let Some(param_audience_operator) = param_audience_operator {
                query_string.append_pair("audienceOperator",
                    &param_audience_operator);
            }
            if let Some(param_update_current_location) = param_update_current_location {
                query_string.append_pair("updateCurrentLocation",
                    &param_update_current_location.to_string());
            }
            if let Some(param_update_preferred_settings) = param_update_preferred_settings {
                query_string.append_pair("updatePreferredSettings",
                    &param_update_preferred_settings.to_string());
            }
            if let Some(param_show_exact_locations) = param_show_exact_locations {
                query_string.append_pair("showExactLocations",
                    &param_show_exact_locations.to_string());
            }
            if let Some(param_show_connection_to_searcher) = param_show_connection_to_searcher {
                query_string.append_pair("showConnectionToSearcher",
                    &param_show_connection_to_searcher.to_string());
            }
            if let Some(param_flag_count_minimum) = param_flag_count_minimum {
                query_string.append_pair("flagCountMinimum",
                    &param_flag_count_minimum.to_string());
            }
            if let Some(param_verified_user_only) = param_verified_user_only {
                query_string.append_pair("verifiedUserOnly",
                    &param_verified_user_only.to_string());
            }
            if let Some(param_content_admin_only) = param_content_admin_only {
                query_string.append_pair("contentAdminOnly",
                    &param_content_admin_only.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::UserLocationSearchResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(AccountLocationSearchResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn block_account(
        &self,
        param_version: f64,
        param_account_id_being_blocked: i64,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_block_flag_value: Option<bool>,
        param_remove_from_groups_if_blocked: Option<bool>,
        param_latitude: Option<f64>,
        param_longitude: Option<f64>,
        context: &C) -> Result<BlockAccountResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/account/block",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
                query_string.append_pair("accountIdBeingBlocked",
                    &param_account_id_being_blocked.to_string());
            if let Some(param_block_flag_value) = param_block_flag_value {
                query_string.append_pair("blockFlagValue",
                    &param_block_flag_value.to_string());
            }
            if let Some(param_remove_from_groups_if_blocked) = param_remove_from_groups_if_blocked {
                query_string.append_pair("removeFromGroupsIfBlocked",
                    &param_remove_from_groups_if_blocked.to_string());
            }
            if let Some(param_latitude) = param_latitude {
                query_string.append_pair("latitude",
                    &param_latitude.to_string());
            }
            if let Some(param_longitude) = param_longitude {
                query_string.append_pair("longitude",
                    &param_longitude.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(BlockAccountResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn create_account(
        &self,
        param_version: f64,
        param_username: String,
        param_password: String,
        param_name: Option<String>,
        param_prefix_name: Option<String>,
        param_first_name: Option<String>,
        param_middle_name: Option<String>,
        param_last_name: Option<String>,
        param_suffix_name: Option<String>,
        param_title: Option<String>,
        param_device_id: Option<String>,
        param_device_id_type: Option<String>,
        param_email_address: Option<String>,
        param_asset_id: Option<i64>,
        param_street_address: Option<String>,
        param_zipcode: Option<String>,
        param_gender: Option<String>,
        param_birthday: Option<i64>,
        param_home_phone: Option<String>,
        param_cell_phone: Option<String>,
        param_cell_phone_carrier: Option<String>,
        param_business_phone: Option<String>,
        param_role: Option<String>,
        param_platforms: Option<String>,
        param_tags: Option<String>,
        param_about_us: Option<String>,
        param_game_experience: Option<String>,
        param_category_ids: Option<String>,
        param_hometown: Option<String>,
        param_height: Option<String>,
        param_height_index: Option<i32>,
        param_ethnicity: Option<String>,
        param_body_type: Option<String>,
        param_marital_status: Option<String>,
        param_children: Option<String>,
        param_religion: Option<String>,
        param_education: Option<String>,
        param_education_index: Option<i32>,
        param_smoke: Option<String>,
        param_drink: Option<String>,
        param_companionship: Option<String>,
        param_companionship_index: Option<i32>,
        param_preferred_min_age: Option<i32>,
        param_preferred_max_age: Option<i32>,
        param_preferred_min_height: Option<i32>,
        param_preferred_max_height: Option<i32>,
        param_preferred_gender: Option<String>,
        param_preferred_education: Option<String>,
        param_preferred_education_index: Option<i32>,
        param_preferred_body_type: Option<String>,
        param_preferred_ethnicity: Option<String>,
        param_preferred_location: Option<String>,
        param_preferred_location_range: Option<f64>,
        param_latitude: Option<f64>,
        param_longitude: Option<f64>,
        param_accepted_terms: Option<bool>,
        param_invite_token: Option<String>,
        param_referral_account_id: Option<i64>,
        param_send_validation: Option<bool>,
        param_game_type: Option<String>,
        param_app_key: Option<String>,
        param_app_version: Option<String>,
        param_response_type: Option<String>,
        param_audience_ids_to_add: Option<String>,
        param_app_blob: Option<String>,
        param_app_enable_push: Option<bool>,
        param_app_enable_sms: Option<bool>,
        param_app_enable_email: Option<bool>,
        param_location_visibility: Option<String>,
        param_home_latitude: Option<f64>,
        param_home_longitude: Option<f64>,
        param_app_nickname: Option<String>,
        param_personal_audience_id: Option<i64>,
        context: &C) -> Result<CreateAccountResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/account/create",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_name) = param_name {
                query_string.append_pair("name",
                    &param_name);
            }
            if let Some(param_prefix_name) = param_prefix_name {
                query_string.append_pair("prefixName",
                    &param_prefix_name);
            }
            if let Some(param_first_name) = param_first_name {
                query_string.append_pair("firstName",
                    &param_first_name);
            }
            if let Some(param_middle_name) = param_middle_name {
                query_string.append_pair("middleName",
                    &param_middle_name);
            }
            if let Some(param_last_name) = param_last_name {
                query_string.append_pair("lastName",
                    &param_last_name);
            }
            if let Some(param_suffix_name) = param_suffix_name {
                query_string.append_pair("suffixName",
                    &param_suffix_name);
            }
            if let Some(param_title) = param_title {
                query_string.append_pair("title",
                    &param_title);
            }
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_device_id_type) = param_device_id_type {
                query_string.append_pair("deviceIdType",
                    &param_device_id_type);
            }
                query_string.append_pair("username",
                    &param_username);
                query_string.append_pair("password",
                    &param_password);
            if let Some(param_email_address) = param_email_address {
                query_string.append_pair("emailAddress",
                    &param_email_address);
            }
            if let Some(param_asset_id) = param_asset_id {
                query_string.append_pair("assetId",
                    &param_asset_id.to_string());
            }
            if let Some(param_street_address) = param_street_address {
                query_string.append_pair("streetAddress",
                    &param_street_address);
            }
            if let Some(param_zipcode) = param_zipcode {
                query_string.append_pair("zipcode",
                    &param_zipcode);
            }
            if let Some(param_gender) = param_gender {
                query_string.append_pair("gender",
                    &param_gender);
            }
            if let Some(param_birthday) = param_birthday {
                query_string.append_pair("birthday",
                    &param_birthday.to_string());
            }
            if let Some(param_home_phone) = param_home_phone {
                query_string.append_pair("homePhone",
                    &param_home_phone);
            }
            if let Some(param_cell_phone) = param_cell_phone {
                query_string.append_pair("cellPhone",
                    &param_cell_phone);
            }
            if let Some(param_cell_phone_carrier) = param_cell_phone_carrier {
                query_string.append_pair("cellPhoneCarrier",
                    &param_cell_phone_carrier);
            }
            if let Some(param_business_phone) = param_business_phone {
                query_string.append_pair("businessPhone",
                    &param_business_phone);
            }
            if let Some(param_role) = param_role {
                query_string.append_pair("role",
                    &param_role);
            }
            if let Some(param_platforms) = param_platforms {
                query_string.append_pair("platforms",
                    &param_platforms);
            }
            if let Some(param_tags) = param_tags {
                query_string.append_pair("tags",
                    &param_tags);
            }
            if let Some(param_about_us) = param_about_us {
                query_string.append_pair("aboutUs",
                    &param_about_us);
            }
            if let Some(param_game_experience) = param_game_experience {
                query_string.append_pair("gameExperience",
                    &param_game_experience);
            }
            if let Some(param_category_ids) = param_category_ids {
                query_string.append_pair("categoryIds",
                    &param_category_ids);
            }
            if let Some(param_hometown) = param_hometown {
                query_string.append_pair("hometown",
                    &param_hometown);
            }
            if let Some(param_height) = param_height {
                query_string.append_pair("height",
                    &param_height);
            }
            if let Some(param_height_index) = param_height_index {
                query_string.append_pair("heightIndex",
                    &param_height_index.to_string());
            }
            if let Some(param_ethnicity) = param_ethnicity {
                query_string.append_pair("ethnicity",
                    &param_ethnicity);
            }
            if let Some(param_body_type) = param_body_type {
                query_string.append_pair("bodyType",
                    &param_body_type);
            }
            if let Some(param_marital_status) = param_marital_status {
                query_string.append_pair("maritalStatus",
                    &param_marital_status);
            }
            if let Some(param_children) = param_children {
                query_string.append_pair("children",
                    &param_children);
            }
            if let Some(param_religion) = param_religion {
                query_string.append_pair("religion",
                    &param_religion);
            }
            if let Some(param_education) = param_education {
                query_string.append_pair("education",
                    &param_education);
            }
            if let Some(param_education_index) = param_education_index {
                query_string.append_pair("educationIndex",
                    &param_education_index.to_string());
            }
            if let Some(param_smoke) = param_smoke {
                query_string.append_pair("smoke",
                    &param_smoke);
            }
            if let Some(param_drink) = param_drink {
                query_string.append_pair("drink",
                    &param_drink);
            }
            if let Some(param_companionship) = param_companionship {
                query_string.append_pair("companionship",
                    &param_companionship);
            }
            if let Some(param_companionship_index) = param_companionship_index {
                query_string.append_pair("companionshipIndex",
                    &param_companionship_index.to_string());
            }
            if let Some(param_preferred_min_age) = param_preferred_min_age {
                query_string.append_pair("preferredMinAge",
                    &param_preferred_min_age.to_string());
            }
            if let Some(param_preferred_max_age) = param_preferred_max_age {
                query_string.append_pair("preferredMaxAge",
                    &param_preferred_max_age.to_string());
            }
            if let Some(param_preferred_min_height) = param_preferred_min_height {
                query_string.append_pair("preferredMinHeight",
                    &param_preferred_min_height.to_string());
            }
            if let Some(param_preferred_max_height) = param_preferred_max_height {
                query_string.append_pair("preferredMaxHeight",
                    &param_preferred_max_height.to_string());
            }
            if let Some(param_preferred_gender) = param_preferred_gender {
                query_string.append_pair("preferredGender",
                    &param_preferred_gender);
            }
            if let Some(param_preferred_education) = param_preferred_education {
                query_string.append_pair("preferredEducation",
                    &param_preferred_education);
            }
            if let Some(param_preferred_education_index) = param_preferred_education_index {
                query_string.append_pair("preferredEducationIndex",
                    &param_preferred_education_index.to_string());
            }
            if let Some(param_preferred_body_type) = param_preferred_body_type {
                query_string.append_pair("preferredBodyType",
                    &param_preferred_body_type);
            }
            if let Some(param_preferred_ethnicity) = param_preferred_ethnicity {
                query_string.append_pair("preferredEthnicity",
                    &param_preferred_ethnicity);
            }
            if let Some(param_preferred_location) = param_preferred_location {
                query_string.append_pair("preferredLocation",
                    &param_preferred_location);
            }
            if let Some(param_preferred_location_range) = param_preferred_location_range {
                query_string.append_pair("preferredLocationRange",
                    &param_preferred_location_range.to_string());
            }
            if let Some(param_latitude) = param_latitude {
                query_string.append_pair("latitude",
                    &param_latitude.to_string());
            }
            if let Some(param_longitude) = param_longitude {
                query_string.append_pair("longitude",
                    &param_longitude.to_string());
            }
            if let Some(param_accepted_terms) = param_accepted_terms {
                query_string.append_pair("acceptedTerms",
                    &param_accepted_terms.to_string());
            }
            if let Some(param_invite_token) = param_invite_token {
                query_string.append_pair("inviteToken",
                    &param_invite_token);
            }
            if let Some(param_referral_account_id) = param_referral_account_id {
                query_string.append_pair("referralAccountId",
                    &param_referral_account_id.to_string());
            }
            if let Some(param_send_validation) = param_send_validation {
                query_string.append_pair("sendValidation",
                    &param_send_validation.to_string());
            }
            if let Some(param_game_type) = param_game_type {
                query_string.append_pair("gameType",
                    &param_game_type);
            }
            if let Some(param_app_key) = param_app_key {
                query_string.append_pair("appKey",
                    &param_app_key);
            }
            if let Some(param_app_version) = param_app_version {
                query_string.append_pair("appVersion",
                    &param_app_version);
            }
            if let Some(param_response_type) = param_response_type {
                query_string.append_pair("responseType",
                    &param_response_type);
            }
            if let Some(param_audience_ids_to_add) = param_audience_ids_to_add {
                query_string.append_pair("audienceIdsToAdd",
                    &param_audience_ids_to_add);
            }
            if let Some(param_app_blob) = param_app_blob {
                query_string.append_pair("appBlob",
                    &param_app_blob);
            }
            if let Some(param_app_enable_push) = param_app_enable_push {
                query_string.append_pair("appEnablePush",
                    &param_app_enable_push.to_string());
            }
            if let Some(param_app_enable_sms) = param_app_enable_sms {
                query_string.append_pair("appEnableSMS",
                    &param_app_enable_sms.to_string());
            }
            if let Some(param_app_enable_email) = param_app_enable_email {
                query_string.append_pair("appEnableEmail",
                    &param_app_enable_email.to_string());
            }
            if let Some(param_location_visibility) = param_location_visibility {
                query_string.append_pair("locationVisibility",
                    &param_location_visibility);
            }
            if let Some(param_home_latitude) = param_home_latitude {
                query_string.append_pair("homeLatitude",
                    &param_home_latitude.to_string());
            }
            if let Some(param_home_longitude) = param_home_longitude {
                query_string.append_pair("homeLongitude",
                    &param_home_longitude.to_string());
            }
            if let Some(param_app_nickname) = param_app_nickname {
                query_string.append_pair("appNickname",
                    &param_app_nickname);
            }
            if let Some(param_personal_audience_id) = param_personal_audience_id {
                query_string.append_pair("personalAudienceId",
                    &param_personal_audience_id.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::AccountLoginResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(CreateAccountResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn edit_account(
        &self,
        param_version: f64,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_connection_account_id: Option<i64>,
        param_role: Option<String>,
        param_asset_id: Option<i64>,
        param_name: Option<String>,
        param_prefix_name: Option<String>,
        param_first_name: Option<String>,
        param_middle_name: Option<String>,
        param_last_name: Option<String>,
        param_suffix_name: Option<String>,
        param_title: Option<String>,
        param_gender: Option<String>,
        param_age: Option<i32>,
        param_birthday: Option<i64>,
        param_home_phone: Option<String>,
        param_cell_phone: Option<String>,
        param_cell_phone_carrier: Option<String>,
        param_business_phone: Option<String>,
        param_email_address: Option<String>,
        param_street_address: Option<String>,
        param_street_address2: Option<String>,
        param_city: Option<String>,
        param_state: Option<String>,
        param_zipcode: Option<String>,
        param_country: Option<String>,
        param_make_profile_info_public: Option<bool>,
        param_make_game_info_public: Option<bool>,
        param_make_friends_info_public: Option<bool>,
        param_hometown: Option<String>,
        param_height: Option<String>,
        param_height_index: Option<i32>,
        param_ethnicity: Option<String>,
        param_body_type: Option<String>,
        param_marital_status: Option<String>,
        param_children: Option<String>,
        param_religion: Option<String>,
        param_education: Option<String>,
        param_education_index: Option<i32>,
        param_smoke: Option<String>,
        param_drink: Option<String>,
        param_companionship: Option<String>,
        param_companionship_index: Option<i32>,
        param_preferred_min_age: Option<i32>,
        param_preferred_max_age: Option<i32>,
        param_preferred_min_height: Option<i32>,
        param_preferred_max_height: Option<i32>,
        param_preferred_gender: Option<String>,
        param_preferred_education: Option<String>,
        param_preferred_education_index: Option<i32>,
        param_preferred_body_type: Option<String>,
        param_preferred_ethnicity: Option<String>,
        param_preferred_location: Option<String>,
        param_preferred_location_range: Option<f64>,
        param_platforms: Option<String>,
        param_tags: Option<String>,
        param_about_us: Option<String>,
        param_match_token: Option<String>,
        param_game_experience: Option<String>,
        param_categories: Option<String>,
        param_category_ids: Option<String>,
        param_response_filters: Option<String>,
        param_show_as_zipcode: Option<bool>,
        param_show_exact_location: Option<bool>,
        param_show_others_exact_location: Option<bool>,
        param_accepted_terms: Option<bool>,
        param_location_visibility: Option<String>,
        param_app_blob: Option<String>,
        param_app_enable_push: Option<bool>,
        param_app_enable_sms: Option<bool>,
        param_app_enable_email: Option<bool>,
        param_game_type: Option<String>,
        param_app_key: Option<String>,
        param_latitude: Option<f64>,
        param_longitude: Option<f64>,
        param_return_profile: Option<bool>,
        param_audience_ids_to_add: Option<String>,
        param_audience_ids_to_remove: Option<String>,
        param_referral_account_id: Option<i64>,
        param_app_nickname: Option<String>,
        param_personal_audience_id: Option<i64>,
        param_non_guest_username: Option<String>,
        context: &C) -> Result<EditAccountResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/account/profile/update",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_connection_account_id) = param_connection_account_id {
                query_string.append_pair("connectionAccountId",
                    &param_connection_account_id.to_string());
            }
            if let Some(param_role) = param_role {
                query_string.append_pair("role",
                    &param_role);
            }
            if let Some(param_asset_id) = param_asset_id {
                query_string.append_pair("assetId",
                    &param_asset_id.to_string());
            }
            if let Some(param_name) = param_name {
                query_string.append_pair("name",
                    &param_name);
            }
            if let Some(param_prefix_name) = param_prefix_name {
                query_string.append_pair("prefixName",
                    &param_prefix_name);
            }
            if let Some(param_first_name) = param_first_name {
                query_string.append_pair("firstName",
                    &param_first_name);
            }
            if let Some(param_middle_name) = param_middle_name {
                query_string.append_pair("middleName",
                    &param_middle_name);
            }
            if let Some(param_last_name) = param_last_name {
                query_string.append_pair("lastName",
                    &param_last_name);
            }
            if let Some(param_suffix_name) = param_suffix_name {
                query_string.append_pair("suffixName",
                    &param_suffix_name);
            }
            if let Some(param_title) = param_title {
                query_string.append_pair("title",
                    &param_title);
            }
            if let Some(param_gender) = param_gender {
                query_string.append_pair("gender",
                    &param_gender);
            }
            if let Some(param_age) = param_age {
                query_string.append_pair("age",
                    &param_age.to_string());
            }
            if let Some(param_birthday) = param_birthday {
                query_string.append_pair("birthday",
                    &param_birthday.to_string());
            }
            if let Some(param_home_phone) = param_home_phone {
                query_string.append_pair("homePhone",
                    &param_home_phone);
            }
            if let Some(param_cell_phone) = param_cell_phone {
                query_string.append_pair("cellPhone",
                    &param_cell_phone);
            }
            if let Some(param_cell_phone_carrier) = param_cell_phone_carrier {
                query_string.append_pair("cellPhoneCarrier",
                    &param_cell_phone_carrier);
            }
            if let Some(param_business_phone) = param_business_phone {
                query_string.append_pair("businessPhone",
                    &param_business_phone);
            }
            if let Some(param_email_address) = param_email_address {
                query_string.append_pair("emailAddress",
                    &param_email_address);
            }
            if let Some(param_street_address) = param_street_address {
                query_string.append_pair("streetAddress",
                    &param_street_address);
            }
            if let Some(param_street_address2) = param_street_address2 {
                query_string.append_pair("streetAddress2",
                    &param_street_address2);
            }
            if let Some(param_city) = param_city {
                query_string.append_pair("city",
                    &param_city);
            }
            if let Some(param_state) = param_state {
                query_string.append_pair("state",
                    &param_state);
            }
            if let Some(param_zipcode) = param_zipcode {
                query_string.append_pair("zipcode",
                    &param_zipcode);
            }
            if let Some(param_country) = param_country {
                query_string.append_pair("country",
                    &param_country);
            }
            if let Some(param_make_profile_info_public) = param_make_profile_info_public {
                query_string.append_pair("makeProfileInfoPublic",
                    &param_make_profile_info_public.to_string());
            }
            if let Some(param_make_game_info_public) = param_make_game_info_public {
                query_string.append_pair("makeGameInfoPublic",
                    &param_make_game_info_public.to_string());
            }
            if let Some(param_make_friends_info_public) = param_make_friends_info_public {
                query_string.append_pair("makeFriendsInfoPublic",
                    &param_make_friends_info_public.to_string());
            }
            if let Some(param_hometown) = param_hometown {
                query_string.append_pair("hometown",
                    &param_hometown);
            }
            if let Some(param_height) = param_height {
                query_string.append_pair("height",
                    &param_height);
            }
            if let Some(param_height_index) = param_height_index {
                query_string.append_pair("heightIndex",
                    &param_height_index.to_string());
            }
            if let Some(param_ethnicity) = param_ethnicity {
                query_string.append_pair("ethnicity",
                    &param_ethnicity);
            }
            if let Some(param_body_type) = param_body_type {
                query_string.append_pair("bodyType",
                    &param_body_type);
            }
            if let Some(param_marital_status) = param_marital_status {
                query_string.append_pair("maritalStatus",
                    &param_marital_status);
            }
            if let Some(param_children) = param_children {
                query_string.append_pair("children",
                    &param_children);
            }
            if let Some(param_religion) = param_religion {
                query_string.append_pair("religion",
                    &param_religion);
            }
            if let Some(param_education) = param_education {
                query_string.append_pair("education",
                    &param_education);
            }
            if let Some(param_education_index) = param_education_index {
                query_string.append_pair("educationIndex",
                    &param_education_index.to_string());
            }
            if let Some(param_smoke) = param_smoke {
                query_string.append_pair("smoke",
                    &param_smoke);
            }
            if let Some(param_drink) = param_drink {
                query_string.append_pair("drink",
                    &param_drink);
            }
            if let Some(param_companionship) = param_companionship {
                query_string.append_pair("companionship",
                    &param_companionship);
            }
            if let Some(param_companionship_index) = param_companionship_index {
                query_string.append_pair("companionshipIndex",
                    &param_companionship_index.to_string());
            }
            if let Some(param_preferred_min_age) = param_preferred_min_age {
                query_string.append_pair("preferredMinAge",
                    &param_preferred_min_age.to_string());
            }
            if let Some(param_preferred_max_age) = param_preferred_max_age {
                query_string.append_pair("preferredMaxAge",
                    &param_preferred_max_age.to_string());
            }
            if let Some(param_preferred_min_height) = param_preferred_min_height {
                query_string.append_pair("preferredMinHeight",
                    &param_preferred_min_height.to_string());
            }
            if let Some(param_preferred_max_height) = param_preferred_max_height {
                query_string.append_pair("preferredMaxHeight",
                    &param_preferred_max_height.to_string());
            }
            if let Some(param_preferred_gender) = param_preferred_gender {
                query_string.append_pair("preferredGender",
                    &param_preferred_gender);
            }
            if let Some(param_preferred_education) = param_preferred_education {
                query_string.append_pair("preferredEducation",
                    &param_preferred_education);
            }
            if let Some(param_preferred_education_index) = param_preferred_education_index {
                query_string.append_pair("preferredEducationIndex",
                    &param_preferred_education_index.to_string());
            }
            if let Some(param_preferred_body_type) = param_preferred_body_type {
                query_string.append_pair("preferredBodyType",
                    &param_preferred_body_type);
            }
            if let Some(param_preferred_ethnicity) = param_preferred_ethnicity {
                query_string.append_pair("preferredEthnicity",
                    &param_preferred_ethnicity);
            }
            if let Some(param_preferred_location) = param_preferred_location {
                query_string.append_pair("preferredLocation",
                    &param_preferred_location);
            }
            if let Some(param_preferred_location_range) = param_preferred_location_range {
                query_string.append_pair("preferredLocationRange",
                    &param_preferred_location_range.to_string());
            }
            if let Some(param_platforms) = param_platforms {
                query_string.append_pair("platforms",
                    &param_platforms);
            }
            if let Some(param_tags) = param_tags {
                query_string.append_pair("tags",
                    &param_tags);
            }
            if let Some(param_about_us) = param_about_us {
                query_string.append_pair("aboutUs",
                    &param_about_us);
            }
            if let Some(param_match_token) = param_match_token {
                query_string.append_pair("matchToken",
                    &param_match_token);
            }
            if let Some(param_game_experience) = param_game_experience {
                query_string.append_pair("gameExperience",
                    &param_game_experience);
            }
            if let Some(param_categories) = param_categories {
                query_string.append_pair("categories",
                    &param_categories);
            }
            if let Some(param_category_ids) = param_category_ids {
                query_string.append_pair("categoryIds",
                    &param_category_ids);
            }
            if let Some(param_response_filters) = param_response_filters {
                query_string.append_pair("responseFilters",
                    &param_response_filters);
            }
            if let Some(param_show_as_zipcode) = param_show_as_zipcode {
                query_string.append_pair("showAsZipcode",
                    &param_show_as_zipcode.to_string());
            }
            if let Some(param_show_exact_location) = param_show_exact_location {
                query_string.append_pair("showExactLocation",
                    &param_show_exact_location.to_string());
            }
            if let Some(param_show_others_exact_location) = param_show_others_exact_location {
                query_string.append_pair("showOthersExactLocation",
                    &param_show_others_exact_location.to_string());
            }
            if let Some(param_accepted_terms) = param_accepted_terms {
                query_string.append_pair("acceptedTerms",
                    &param_accepted_terms.to_string());
            }
            if let Some(param_location_visibility) = param_location_visibility {
                query_string.append_pair("locationVisibility",
                    &param_location_visibility);
            }
            if let Some(param_app_blob) = param_app_blob {
                query_string.append_pair("appBlob",
                    &param_app_blob);
            }
            if let Some(param_app_enable_push) = param_app_enable_push {
                query_string.append_pair("appEnablePush",
                    &param_app_enable_push.to_string());
            }
            if let Some(param_app_enable_sms) = param_app_enable_sms {
                query_string.append_pair("appEnableSMS",
                    &param_app_enable_sms.to_string());
            }
            if let Some(param_app_enable_email) = param_app_enable_email {
                query_string.append_pair("appEnableEmail",
                    &param_app_enable_email.to_string());
            }
            if let Some(param_game_type) = param_game_type {
                query_string.append_pair("gameType",
                    &param_game_type);
            }
            if let Some(param_app_key) = param_app_key {
                query_string.append_pair("appKey",
                    &param_app_key);
            }
            if let Some(param_latitude) = param_latitude {
                query_string.append_pair("latitude",
                    &param_latitude.to_string());
            }
            if let Some(param_longitude) = param_longitude {
                query_string.append_pair("longitude",
                    &param_longitude.to_string());
            }
            if let Some(param_return_profile) = param_return_profile {
                query_string.append_pair("returnProfile",
                    &param_return_profile.to_string());
            }
            if let Some(param_audience_ids_to_add) = param_audience_ids_to_add {
                query_string.append_pair("audienceIdsToAdd",
                    &param_audience_ids_to_add);
            }
            if let Some(param_audience_ids_to_remove) = param_audience_ids_to_remove {
                query_string.append_pair("audienceIdsToRemove",
                    &param_audience_ids_to_remove);
            }
            if let Some(param_referral_account_id) = param_referral_account_id {
                query_string.append_pair("referralAccountId",
                    &param_referral_account_id.to_string());
            }
            if let Some(param_app_nickname) = param_app_nickname {
                query_string.append_pair("appNickname",
                    &param_app_nickname);
            }
            if let Some(param_personal_audience_id) = param_personal_audience_id {
                query_string.append_pair("personalAudienceId",
                    &param_personal_audience_id.to_string());
            }
            if let Some(param_non_guest_username) = param_non_guest_username {
                query_string.append_pair("nonGuestUsername",
                    &param_non_guest_username);
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::ProfileInfoResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(EditAccountResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn edit_username(
        &self,
        param_version: f64,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_email_address: Option<String>,
        param_username: Option<String>,
        context: &C) -> Result<EditUsernameResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/account/username/update",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_email_address) = param_email_address {
                query_string.append_pair("emailAddress",
                    &param_email_address);
            }
            if let Some(param_username) = param_username {
                query_string.append_pair("username",
                    &param_username);
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(EditUsernameResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_account(
        &self,
        param_version: f64,
        param_return_nulls: Option<bool>,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_connection_account_email: Option<String>,
        param_connection_account_id: Option<i64>,
        param_response_filters: Option<String>,
        param_game_type: Option<String>,
        param_app_key: Option<String>,
        param_purchase_type: Option<String>,
        param_update_viewed_date: Option<bool>,
        param_latitude: Option<f64>,
        param_longitude: Option<f64>,
        context: &C) -> Result<GetAccountResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/account/profile/get",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_return_nulls) = param_return_nulls {
                query_string.append_pair("returnNulls",
                    &param_return_nulls.to_string());
            }
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_connection_account_email) = param_connection_account_email {
                query_string.append_pair("connectionAccountEmail",
                    &param_connection_account_email);
            }
            if let Some(param_connection_account_id) = param_connection_account_id {
                query_string.append_pair("connectionAccountId",
                    &param_connection_account_id.to_string());
            }
            if let Some(param_response_filters) = param_response_filters {
                query_string.append_pair("responseFilters",
                    &param_response_filters);
            }
            if let Some(param_game_type) = param_game_type {
                query_string.append_pair("gameType",
                    &param_game_type);
            }
            if let Some(param_app_key) = param_app_key {
                query_string.append_pair("appKey",
                    &param_app_key);
            }
            if let Some(param_purchase_type) = param_purchase_type {
                query_string.append_pair("purchaseType",
                    &param_purchase_type);
            }
            if let Some(param_update_viewed_date) = param_update_viewed_date {
                query_string.append_pair("updateViewedDate",
                    &param_update_viewed_date.to_string());
            }
            if let Some(param_latitude) = param_latitude {
                query_string.append_pair("latitude",
                    &param_latitude.to_string());
            }
            if let Some(param_longitude) = param_longitude {
                query_string.append_pair("longitude",
                    &param_longitude.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::ProfileResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetAccountResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_profile_assets(
        &self,
        param_version: f64,
        param_return_nulls: Option<bool>,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_owner_id: Option<i64>,
        param_media_types: Option<String>,
        param_mime_types: Option<String>,
        param_sort_field: Option<String>,
        param_descending: Option<bool>,
        param_latitude: Option<f64>,
        param_longitude: Option<f64>,
        param__i: Option<i32>,
        param_start: Option<i32>,
        param__l: Option<i32>,
        param_limit: Option<i32>,
        context: &C) -> Result<GetProfileAssetsResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/account/profile/assets",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_return_nulls) = param_return_nulls {
                query_string.append_pair("returnNulls",
                    &param_return_nulls.to_string());
            }
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_owner_id) = param_owner_id {
                query_string.append_pair("ownerId",
                    &param_owner_id.to_string());
            }
            if let Some(param_media_types) = param_media_types {
                query_string.append_pair("mediaTypes",
                    &param_media_types);
            }
            if let Some(param_mime_types) = param_mime_types {
                query_string.append_pair("mimeTypes",
                    &param_mime_types);
            }
            if let Some(param_sort_field) = param_sort_field {
                query_string.append_pair("sortField",
                    &param_sort_field);
            }
            if let Some(param_descending) = param_descending {
                query_string.append_pair("descending",
                    &param_descending.to_string());
            }
            if let Some(param_latitude) = param_latitude {
                query_string.append_pair("latitude",
                    &param_latitude.to_string());
            }
            if let Some(param_longitude) = param_longitude {
                query_string.append_pair("longitude",
                    &param_longitude.to_string());
            }
            if let Some(param__i) = param__i {
                query_string.append_pair("_i",
                    &param__i.to_string());
            }
            if let Some(param_start) = param_start {
                query_string.append_pair("start",
                    &param_start.to_string());
            }
            if let Some(param__l) = param__l {
                query_string.append_pair("_l",
                    &param__l.to_string());
            }
            if let Some(param_limit) = param_limit {
                query_string.append_pair("limit",
                    &param_limit.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::AssetListResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetProfileAssetsResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_referral_list(
        &self,
        param_version: f64,
        param_account_id: Option<i64>,
        param_app_key: Option<String>,
        param_retrieve_type: Option<String>,
        param_level_limit: Option<f64>,
        param_ancestor_level_limit: Option<f64>,
        param_children_level_limit: Option<f64>,
        param_ancestor_list_start: Option<f64>,
        param_ancestor_list_limit: Option<f64>,
        param_children_list_start: Option<f64>,
        param_children_list_limit: Option<f64>,
        param_children_children: Option<bool>,
        context: &C) -> Result<GetReferralListResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/account/referral/list",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_app_key) = param_app_key {
                query_string.append_pair("appKey",
                    &param_app_key);
            }
            if let Some(param_retrieve_type) = param_retrieve_type {
                query_string.append_pair("retrieveType",
                    &param_retrieve_type);
            }
            if let Some(param_level_limit) = param_level_limit {
                query_string.append_pair("levelLimit",
                    &param_level_limit.to_string());
            }
            if let Some(param_ancestor_level_limit) = param_ancestor_level_limit {
                query_string.append_pair("ancestorLevelLimit",
                    &param_ancestor_level_limit.to_string());
            }
            if let Some(param_children_level_limit) = param_children_level_limit {
                query_string.append_pair("childrenLevelLimit",
                    &param_children_level_limit.to_string());
            }
            if let Some(param_ancestor_list_start) = param_ancestor_list_start {
                query_string.append_pair("ancestorListStart",
                    &param_ancestor_list_start.to_string());
            }
            if let Some(param_ancestor_list_limit) = param_ancestor_list_limit {
                query_string.append_pair("ancestorListLimit",
                    &param_ancestor_list_limit.to_string());
            }
            if let Some(param_children_list_start) = param_children_list_start {
                query_string.append_pair("childrenListStart",
                    &param_children_list_start.to_string());
            }
            if let Some(param_children_list_limit) = param_children_list_limit {
                query_string.append_pair("childrenListLimit",
                    &param_children_list_limit.to_string());
            }
            if let Some(param_children_children) = param_children_children {
                query_string.append_pair("childrenChildren",
                    &param_children_children.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                Ok(
                    GetReferralListResponse::SuccessfulOperation
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_settings(
        &self,
        param_version: f64,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_latitude: Option<f64>,
        param_longitude: Option<f64>,
        context: &C) -> Result<GetSettingsResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/account/settings/get",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_latitude) = param_latitude {
                query_string.append_pair("latitude",
                    &param_latitude.to_string());
            }
            if let Some(param_longitude) = param_longitude {
                query_string.append_pair("longitude",
                    &param_longitude.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::UserSettingsResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetSettingsResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn login_delegate(
        &self,
        param_version: f64,
        param_access_token: String,
        param_app_key: String,
        param_device_id: Option<String>,
        param_access_token_secret: Option<String>,
        param_delegated_account_id: Option<i64>,
        param_delegated_username: Option<String>,
        param_network_uid: Option<String>,
        param_age_restriction: Option<i32>,
        param_response_filters: Option<String>,
        param_latitude: Option<f64>,
        param_longitude: Option<f64>,
        context: &C) -> Result<LoginDelegateResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/account/login/delegate",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
                query_string.append_pair("accessToken",
                    &param_access_token);
            if let Some(param_access_token_secret) = param_access_token_secret {
                query_string.append_pair("accessTokenSecret",
                    &param_access_token_secret);
            }
            if let Some(param_delegated_account_id) = param_delegated_account_id {
                query_string.append_pair("delegatedAccountId",
                    &param_delegated_account_id.to_string());
            }
            if let Some(param_delegated_username) = param_delegated_username {
                query_string.append_pair("delegatedUsername",
                    &param_delegated_username);
            }
            if let Some(param_network_uid) = param_network_uid {
                query_string.append_pair("networkUID",
                    &param_network_uid);
            }
                query_string.append_pair("appKey",
                    &param_app_key);
            if let Some(param_age_restriction) = param_age_restriction {
                query_string.append_pair("ageRestriction",
                    &param_age_restriction.to_string());
            }
            if let Some(param_response_filters) = param_response_filters {
                query_string.append_pair("responseFilters",
                    &param_response_filters);
            }
            if let Some(param_latitude) = param_latitude {
                query_string.append_pair("latitude",
                    &param_latitude.to_string());
            }
            if let Some(param_longitude) = param_longitude {
                query_string.append_pair("longitude",
                    &param_longitude.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::ProfileResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(LoginDelegateResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn login_general(
        &self,
        param_version: f64,
        param_access_token: String,
        param_network_uid: String,
        param_app_key: String,
        param_device_id: Option<String>,
        param_device_id_type: Option<String>,
        param_access_token_secret: Option<String>,
        param_age_restriction: Option<i32>,
        param_response_filters: Option<String>,
        param_latitude: Option<f64>,
        param_longitude: Option<f64>,
        param_email_match: Option<bool>,
        param_chosen_account_id: Option<i64>,
        param_third_party_credential_id: Option<i64>,
        context: &C) -> Result<LoginGeneralResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/account/login",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_device_id_type) = param_device_id_type {
                query_string.append_pair("deviceIdType",
                    &param_device_id_type);
            }
                query_string.append_pair("accessToken",
                    &param_access_token);
            if let Some(param_access_token_secret) = param_access_token_secret {
                query_string.append_pair("accessTokenSecret",
                    &param_access_token_secret);
            }
                query_string.append_pair("networkUID",
                    &param_network_uid);
                query_string.append_pair("appKey",
                    &param_app_key);
            if let Some(param_age_restriction) = param_age_restriction {
                query_string.append_pair("ageRestriction",
                    &param_age_restriction.to_string());
            }
            if let Some(param_response_filters) = param_response_filters {
                query_string.append_pair("responseFilters",
                    &param_response_filters);
            }
            if let Some(param_latitude) = param_latitude {
                query_string.append_pair("latitude",
                    &param_latitude.to_string());
            }
            if let Some(param_longitude) = param_longitude {
                query_string.append_pair("longitude",
                    &param_longitude.to_string());
            }
            if let Some(param_email_match) = param_email_match {
                query_string.append_pair("emailMatch",
                    &param_email_match.to_string());
            }
            if let Some(param_chosen_account_id) = param_chosen_account_id {
                query_string.append_pair("chosenAccountId",
                    &param_chosen_account_id.to_string());
            }
            if let Some(param_third_party_credential_id) = param_third_party_credential_id {
                query_string.append_pair("thirdPartyCredentialId",
                    &param_third_party_credential_id.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::ProfileResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(LoginGeneralResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn login_username(
        &self,
        param_version: f64,
        param_username: String,
        param_password: String,
        param_device_id: Option<String>,
        param_latitude: Option<f64>,
        param_longitude: Option<f64>,
        param_app: Option<String>,
        param_game_type: Option<String>,
        param_app_key: Option<String>,
        param_return_profile: Option<bool>,
        param_response_filters: Option<String>,
        context: &C) -> Result<LoginUsernameResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/account/get",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
                query_string.append_pair("username",
                    &param_username);
                query_string.append_pair("password",
                    &param_password);
            if let Some(param_latitude) = param_latitude {
                query_string.append_pair("latitude",
                    &param_latitude.to_string());
            }
            if let Some(param_longitude) = param_longitude {
                query_string.append_pair("longitude",
                    &param_longitude.to_string());
            }
            if let Some(param_app) = param_app {
                query_string.append_pair("app",
                    &param_app);
            }
            if let Some(param_game_type) = param_game_type {
                query_string.append_pair("gameType",
                    &param_game_type);
            }
            if let Some(param_app_key) = param_app_key {
                query_string.append_pair("appKey",
                    &param_app_key);
            }
            if let Some(param_return_profile) = param_return_profile {
                query_string.append_pair("returnProfile",
                    &param_return_profile.to_string());
            }
            if let Some(param_response_filters) = param_response_filters {
                query_string.append_pair("responseFilters",
                    &param_response_filters);
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::ProfileResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(LoginUsernameResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn logout(
        &self,
        param_version: f64,
        param_device_id: Option<String>,
        param_device_id_type: Option<String>,
        param_account_id: Option<i64>,
        param_latitude: Option<f64>,
        param_longitude: Option<f64>,
        context: &C) -> Result<LogoutResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/account/logout",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_device_id_type) = param_device_id_type {
                query_string.append_pair("deviceIdType",
                    &param_device_id_type);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_latitude) = param_latitude {
                query_string.append_pair("latitude",
                    &param_latitude.to_string());
            }
            if let Some(param_longitude) = param_longitude {
                query_string.append_pair("longitude",
                    &param_longitude.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(LogoutResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn merge_account(
        &self,
        param_version: f64,
        param_merge_account_id: i64,
        param_app_key: String,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        context: &C) -> Result<MergeAccountResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/account/merge",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
                query_string.append_pair("mergeAccountId",
                    &param_merge_account_id.to_string());
                query_string.append_pair("appKey",
                    &param_app_key);
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(MergeAccountResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn password_change(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_old_password: String,
        param_new_password: String,
        param_confirm_password: String,
        context: &C) -> Result<PasswordChangeResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/account/passwordchange",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("oldPassword",
                    &param_old_password);
                query_string.append_pair("newPassword",
                    &param_new_password);
                query_string.append_pair("confirmPassword",
                    &param_confirm_password);
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(PasswordChangeResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn password_reset(
        &self,
        param_version: f64,
        param_token: String,
        param_password: String,
        param_confirm: String,
        context: &C) -> Result<PasswordResetResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/account/passwordreset",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("token",
                    &param_token);
                query_string.append_pair("password",
                    &param_password);
                query_string.append_pair("confirm",
                    &param_confirm);
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(PasswordResetResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn request_password_reset(
        &self,
        param_version: f64,
        param_email: String,
        param_from: Option<String>,
        param_domain: Option<String>,
        param_sub_url: Option<String>,
        param_referer: Option<String>,
        context: &C) -> Result<RequestPasswordResetResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/account/requestpasswordreset",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("email",
                    &param_email);
            if let Some(param_from) = param_from {
                query_string.append_pair("from",
                    &param_from);
            }
            if let Some(param_domain) = param_domain {
                query_string.append_pair("domain",
                    &param_domain);
            }
            if let Some(param_sub_url) = param_sub_url {
                query_string.append_pair("subUrl",
                    &param_sub_url);
            }
            if let Some(param_referer) = param_referer {
                query_string.append_pair("referer",
                    &param_referer);
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(RequestPasswordResetResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn request_validate_account(
        &self,
        param_version: f64,
        param_account_id: i64,
        context: &C) -> Result<RequestValidateAccountResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/account/requestValidateAccount",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(RequestValidateAccountResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn search_accounts(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_app_key: String,
        param_keyword: Option<String>,
        param_latitude: Option<f64>,
        param_longitude: Option<f64>,
        param_radius: Option<f64>,
        param_gender: Option<models::SearchAccountsGenderParameter>,
        param_game_experience: Option<models::SearchAccountsGameExperienceParameter>,
        param_age: Option<i32>,
        param_category_ids: Option<String>,
        param_return_nulls: Option<bool>,
        param_response_filters: Option<String>,
        param_purchase_type: Option<String>,
        param_sort_field: Option<String>,
        param_descending: Option<bool>,
        param_start: Option<i32>,
        param_limit: Option<i32>,
        param_active_only: Option<bool>,
        context: &C) -> Result<SearchAccountsResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/account/profile/search",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("appKey",
                    &param_app_key);
            if let Some(param_keyword) = param_keyword {
                query_string.append_pair("keyword",
                    &param_keyword);
            }
            if let Some(param_latitude) = param_latitude {
                query_string.append_pair("latitude",
                    &param_latitude.to_string());
            }
            if let Some(param_longitude) = param_longitude {
                query_string.append_pair("longitude",
                    &param_longitude.to_string());
            }
            if let Some(param_radius) = param_radius {
                query_string.append_pair("radius",
                    &param_radius.to_string());
            }
            if let Some(param_gender) = param_gender {
                query_string.append_pair("gender",
                    &param_gender.to_string());
            }
            if let Some(param_game_experience) = param_game_experience {
                query_string.append_pair("gameExperience",
                    &param_game_experience.to_string());
            }
            if let Some(param_age) = param_age {
                query_string.append_pair("age",
                    &param_age.to_string());
            }
            if let Some(param_category_ids) = param_category_ids {
                query_string.append_pair("categoryIds",
                    &param_category_ids);
            }
            if let Some(param_return_nulls) = param_return_nulls {
                query_string.append_pair("returnNulls",
                    &param_return_nulls.to_string());
            }
            if let Some(param_response_filters) = param_response_filters {
                query_string.append_pair("responseFilters",
                    &param_response_filters);
            }
            if let Some(param_purchase_type) = param_purchase_type {
                query_string.append_pair("purchaseType",
                    &param_purchase_type);
            }
            if let Some(param_sort_field) = param_sort_field {
                query_string.append_pair("sortField",
                    &param_sort_field);
            }
            if let Some(param_descending) = param_descending {
                query_string.append_pair("descending",
                    &param_descending.to_string());
            }
            if let Some(param_start) = param_start {
                query_string.append_pair("start",
                    &param_start.to_string());
            }
            if let Some(param_limit) = param_limit {
                query_string.append_pair("limit",
                    &param_limit.to_string());
            }
            if let Some(param_active_only) = param_active_only {
                query_string.append_pair("activeOnly",
                    &param_active_only.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<Vec<models::ProfileResponse>>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(SearchAccountsResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn secure_login(
        &self,
        param_version: f64,
        param_username: String,
        param_password: String,
        param_game_type: String,
        param_device_id: Option<String>,
        param_charset_name: Option<String>,
        param_latitude: Option<f64>,
        param_longitude: Option<f64>,
        param_return_profile: Option<bool>,
        param_response_filters: Option<String>,
        context: &C) -> Result<SecureLoginResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/account/login/validate",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
                query_string.append_pair("username",
                    &param_username);
                query_string.append_pair("password",
                    &param_password);
                query_string.append_pair("gameType",
                    &param_game_type);
            if let Some(param_charset_name) = param_charset_name {
                query_string.append_pair("charsetName",
                    &param_charset_name);
            }
            if let Some(param_latitude) = param_latitude {
                query_string.append_pair("latitude",
                    &param_latitude.to_string());
            }
            if let Some(param_longitude) = param_longitude {
                query_string.append_pair("longitude",
                    &param_longitude.to_string());
            }
            if let Some(param_return_profile) = param_return_profile {
                query_string.append_pair("returnProfile",
                    &param_return_profile.to_string());
            }
            if let Some(param_response_filters) = param_response_filters {
                query_string.append_pair("responseFilters",
                    &param_response_filters);
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::ProfileResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(SecureLoginResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn secure_signup(
        &self,
        param_version: f64,
        param_device_id: String,
        param_username: String,
        param_password: String,
        param_name: Option<String>,
        param_invite_token: Option<String>,
        param_prefix_name: Option<String>,
        param_first_name: Option<String>,
        param_middle_name: Option<String>,
        param_last_name: Option<String>,
        param_suffix_name: Option<String>,
        param_title: Option<String>,
        param_device_id_type: Option<String>,
        param_email_address: Option<String>,
        param_asset_id: Option<i64>,
        param_address: Option<String>,
        param_zipcode: Option<String>,
        param_gender: Option<String>,
        param_birthday: Option<i64>,
        param_home_phone: Option<String>,
        param_cell_phone: Option<String>,
        param_cell_phone_carrier: Option<String>,
        param_business_phone: Option<String>,
        param_role: Option<String>,
        param_platforms: Option<String>,
        param_tags: Option<String>,
        param_about_us: Option<String>,
        param_game_experience: Option<String>,
        param_category_ids: Option<String>,
        param_hometown: Option<String>,
        param_height: Option<String>,
        param_height_index: Option<i32>,
        param_ethnicity: Option<String>,
        param_body_type: Option<String>,
        param_marital_status: Option<String>,
        param_children: Option<String>,
        param_religion: Option<String>,
        param_education: Option<String>,
        param_education_index: Option<i32>,
        param_smoke: Option<String>,
        param_drink: Option<String>,
        param_companionship: Option<String>,
        param_companionship_index: Option<i32>,
        param_preferred_min_age: Option<i32>,
        param_preferred_max_age: Option<i32>,
        param_preferred_min_height: Option<i32>,
        param_preferred_max_height: Option<i32>,
        param_preferred_gender: Option<String>,
        param_preferred_education: Option<String>,
        param_preferred_education_index: Option<i32>,
        param_preferred_body_type: Option<String>,
        param_preferred_ethnicity: Option<String>,
        param_preferred_location: Option<String>,
        param_preferred_location_range: Option<f64>,
        param_latitude: Option<f64>,
        param_longitude: Option<f64>,
        param_accepted_terms: Option<bool>,
        param_charset_name: Option<String>,
        param_game_type: Option<String>,
        param_app_key: Option<String>,
        param_app_version: Option<String>,
        param_response_type: Option<String>,
        context: &C) -> Result<SecureSignupResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/account/create/validate",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_name) = param_name {
                query_string.append_pair("name",
                    &param_name);
            }
            if let Some(param_invite_token) = param_invite_token {
                query_string.append_pair("inviteToken",
                    &param_invite_token);
            }
            if let Some(param_prefix_name) = param_prefix_name {
                query_string.append_pair("prefixName",
                    &param_prefix_name);
            }
            if let Some(param_first_name) = param_first_name {
                query_string.append_pair("firstName",
                    &param_first_name);
            }
            if let Some(param_middle_name) = param_middle_name {
                query_string.append_pair("middleName",
                    &param_middle_name);
            }
            if let Some(param_last_name) = param_last_name {
                query_string.append_pair("lastName",
                    &param_last_name);
            }
            if let Some(param_suffix_name) = param_suffix_name {
                query_string.append_pair("suffixName",
                    &param_suffix_name);
            }
            if let Some(param_title) = param_title {
                query_string.append_pair("title",
                    &param_title);
            }
                query_string.append_pair("deviceId",
                    &param_device_id);
            if let Some(param_device_id_type) = param_device_id_type {
                query_string.append_pair("deviceIdType",
                    &param_device_id_type);
            }
                query_string.append_pair("username",
                    &param_username);
                query_string.append_pair("password",
                    &param_password);
            if let Some(param_email_address) = param_email_address {
                query_string.append_pair("emailAddress",
                    &param_email_address);
            }
            if let Some(param_asset_id) = param_asset_id {
                query_string.append_pair("assetId",
                    &param_asset_id.to_string());
            }
            if let Some(param_address) = param_address {
                query_string.append_pair("address",
                    &param_address);
            }
            if let Some(param_zipcode) = param_zipcode {
                query_string.append_pair("zipcode",
                    &param_zipcode);
            }
            if let Some(param_gender) = param_gender {
                query_string.append_pair("gender",
                    &param_gender);
            }
            if let Some(param_birthday) = param_birthday {
                query_string.append_pair("birthday",
                    &param_birthday.to_string());
            }
            if let Some(param_home_phone) = param_home_phone {
                query_string.append_pair("homePhone",
                    &param_home_phone);
            }
            if let Some(param_cell_phone) = param_cell_phone {
                query_string.append_pair("cellPhone",
                    &param_cell_phone);
            }
            if let Some(param_cell_phone_carrier) = param_cell_phone_carrier {
                query_string.append_pair("cellPhoneCarrier",
                    &param_cell_phone_carrier);
            }
            if let Some(param_business_phone) = param_business_phone {
                query_string.append_pair("businessPhone",
                    &param_business_phone);
            }
            if let Some(param_role) = param_role {
                query_string.append_pair("role",
                    &param_role);
            }
            if let Some(param_platforms) = param_platforms {
                query_string.append_pair("platforms",
                    &param_platforms);
            }
            if let Some(param_tags) = param_tags {
                query_string.append_pair("tags",
                    &param_tags);
            }
            if let Some(param_about_us) = param_about_us {
                query_string.append_pair("aboutUs",
                    &param_about_us);
            }
            if let Some(param_game_experience) = param_game_experience {
                query_string.append_pair("gameExperience",
                    &param_game_experience);
            }
            if let Some(param_category_ids) = param_category_ids {
                query_string.append_pair("categoryIds",
                    &param_category_ids);
            }
            if let Some(param_hometown) = param_hometown {
                query_string.append_pair("hometown",
                    &param_hometown);
            }
            if let Some(param_height) = param_height {
                query_string.append_pair("height",
                    &param_height);
            }
            if let Some(param_height_index) = param_height_index {
                query_string.append_pair("heightIndex",
                    &param_height_index.to_string());
            }
            if let Some(param_ethnicity) = param_ethnicity {
                query_string.append_pair("ethnicity",
                    &param_ethnicity);
            }
            if let Some(param_body_type) = param_body_type {
                query_string.append_pair("bodyType",
                    &param_body_type);
            }
            if let Some(param_marital_status) = param_marital_status {
                query_string.append_pair("maritalStatus",
                    &param_marital_status);
            }
            if let Some(param_children) = param_children {
                query_string.append_pair("children",
                    &param_children);
            }
            if let Some(param_religion) = param_religion {
                query_string.append_pair("religion",
                    &param_religion);
            }
            if let Some(param_education) = param_education {
                query_string.append_pair("education",
                    &param_education);
            }
            if let Some(param_education_index) = param_education_index {
                query_string.append_pair("educationIndex",
                    &param_education_index.to_string());
            }
            if let Some(param_smoke) = param_smoke {
                query_string.append_pair("smoke",
                    &param_smoke);
            }
            if let Some(param_drink) = param_drink {
                query_string.append_pair("drink",
                    &param_drink);
            }
            if let Some(param_companionship) = param_companionship {
                query_string.append_pair("companionship",
                    &param_companionship);
            }
            if let Some(param_companionship_index) = param_companionship_index {
                query_string.append_pair("companionshipIndex",
                    &param_companionship_index.to_string());
            }
            if let Some(param_preferred_min_age) = param_preferred_min_age {
                query_string.append_pair("preferredMinAge",
                    &param_preferred_min_age.to_string());
            }
            if let Some(param_preferred_max_age) = param_preferred_max_age {
                query_string.append_pair("preferredMaxAge",
                    &param_preferred_max_age.to_string());
            }
            if let Some(param_preferred_min_height) = param_preferred_min_height {
                query_string.append_pair("preferredMinHeight",
                    &param_preferred_min_height.to_string());
            }
            if let Some(param_preferred_max_height) = param_preferred_max_height {
                query_string.append_pair("preferredMaxHeight",
                    &param_preferred_max_height.to_string());
            }
            if let Some(param_preferred_gender) = param_preferred_gender {
                query_string.append_pair("preferredGender",
                    &param_preferred_gender);
            }
            if let Some(param_preferred_education) = param_preferred_education {
                query_string.append_pair("preferredEducation",
                    &param_preferred_education);
            }
            if let Some(param_preferred_education_index) = param_preferred_education_index {
                query_string.append_pair("preferredEducationIndex",
                    &param_preferred_education_index.to_string());
            }
            if let Some(param_preferred_body_type) = param_preferred_body_type {
                query_string.append_pair("preferredBodyType",
                    &param_preferred_body_type);
            }
            if let Some(param_preferred_ethnicity) = param_preferred_ethnicity {
                query_string.append_pair("preferredEthnicity",
                    &param_preferred_ethnicity);
            }
            if let Some(param_preferred_location) = param_preferred_location {
                query_string.append_pair("preferredLocation",
                    &param_preferred_location);
            }
            if let Some(param_preferred_location_range) = param_preferred_location_range {
                query_string.append_pair("preferredLocationRange",
                    &param_preferred_location_range.to_string());
            }
            if let Some(param_latitude) = param_latitude {
                query_string.append_pair("latitude",
                    &param_latitude.to_string());
            }
            if let Some(param_longitude) = param_longitude {
                query_string.append_pair("longitude",
                    &param_longitude.to_string());
            }
            if let Some(param_accepted_terms) = param_accepted_terms {
                query_string.append_pair("acceptedTerms",
                    &param_accepted_terms.to_string());
            }
            if let Some(param_charset_name) = param_charset_name {
                query_string.append_pair("charsetName",
                    &param_charset_name);
            }
            if let Some(param_game_type) = param_game_type {
                query_string.append_pair("gameType",
                    &param_game_type);
            }
            if let Some(param_app_key) = param_app_key {
                query_string.append_pair("appKey",
                    &param_app_key);
            }
            if let Some(param_app_version) = param_app_version {
                query_string.append_pair("appVersion",
                    &param_app_version);
            }
            if let Some(param_response_type) = param_response_type {
                query_string.append_pair("responseType",
                    &param_response_type);
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::ProfileInfoResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(SecureSignupResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn set_match_token(
        &self,
        param_version: f64,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_match_token: Option<String>,
        param_game_type: Option<String>,
        param_app_key: Option<String>,
        param_latitude: Option<f64>,
        param_longitude: Option<f64>,
        context: &C) -> Result<SetMatchTokenResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/consumer/profile/matchToken",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_match_token) = param_match_token {
                query_string.append_pair("matchToken",
                    &param_match_token);
            }
            if let Some(param_game_type) = param_game_type {
                query_string.append_pair("gameType",
                    &param_game_type);
            }
            if let Some(param_app_key) = param_app_key {
                query_string.append_pair("appKey",
                    &param_app_key);
            }
            if let Some(param_latitude) = param_latitude {
                query_string.append_pair("latitude",
                    &param_latitude.to_string());
            }
            if let Some(param_longitude) = param_longitude {
                query_string.append_pair("longitude",
                    &param_longitude.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(SetMatchTokenResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn update_actve_status(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_connection_account_id: i64,
        param_active: bool,
        param_device_id: Option<String>,
        param_app_key: Option<String>,
        context: &C) -> Result<UpdateActveStatusResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/account/active/update",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("connectionAccountId",
                    &param_connection_account_id.to_string());
            if let Some(param_app_key) = param_app_key {
                query_string.append_pair("appKey",
                    &param_app_key);
            }
                query_string.append_pair("active",
                    &param_active.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(UpdateActveStatusResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn update_location(
        &self,
        param_version: f64,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_latitude: Option<f64>,
        param_longitude: Option<f64>,
        param_client_time: Option<i64>,
        context: &C) -> Result<UpdateLocationResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/account/location/update",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_latitude) = param_latitude {
                query_string.append_pair("latitude",
                    &param_latitude.to_string());
            }
            if let Some(param_longitude) = param_longitude {
                query_string.append_pair("longitude",
                    &param_longitude.to_string());
            }
            if let Some(param_client_time) = param_client_time {
                query_string.append_pair("clientTime",
                    &param_client_time.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(UpdateLocationResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn update_settings(
        &self,
        param_version: f64,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_blocked_notifications: Option<String>,
        param_suggestion_method: Option<String>,
        param_suggestion_count: Option<i32>,
        param_suggestion_time_frame: Option<i32>,
        param_show_others_exact_location: Option<bool>,
        param_show_as_zipcode: Option<bool>,
        param_show_exact_location: Option<bool>,
        param_favorite_visibility: Option<String>,
        param_latitude: Option<f64>,
        param_longitude: Option<f64>,
        context: &C) -> Result<UpdateSettingsResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/account/settings/update",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_blocked_notifications) = param_blocked_notifications {
                query_string.append_pair("blockedNotifications",
                    &param_blocked_notifications);
            }
            if let Some(param_suggestion_method) = param_suggestion_method {
                query_string.append_pair("suggestionMethod",
                    &param_suggestion_method);
            }
            if let Some(param_suggestion_count) = param_suggestion_count {
                query_string.append_pair("suggestionCount",
                    &param_suggestion_count.to_string());
            }
            if let Some(param_suggestion_time_frame) = param_suggestion_time_frame {
                query_string.append_pair("suggestionTimeFrame",
                    &param_suggestion_time_frame.to_string());
            }
            if let Some(param_show_others_exact_location) = param_show_others_exact_location {
                query_string.append_pair("showOthersExactLocation",
                    &param_show_others_exact_location.to_string());
            }
            if let Some(param_show_as_zipcode) = param_show_as_zipcode {
                query_string.append_pair("showAsZipcode",
                    &param_show_as_zipcode.to_string());
            }
            if let Some(param_show_exact_location) = param_show_exact_location {
                query_string.append_pair("showExactLocation",
                    &param_show_exact_location.to_string());
            }
            if let Some(param_favorite_visibility) = param_favorite_visibility {
                query_string.append_pair("favoriteVisibility",
                    &param_favorite_visibility);
            }
            if let Some(param_latitude) = param_latitude {
                query_string.append_pair("latitude",
                    &param_latitude.to_string());
            }
            if let Some(param_longitude) = param_longitude {
                query_string.append_pair("longitude",
                    &param_longitude.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::UserSettingsResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(UpdateSettingsResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn validate_account_signup(
        &self,
        param_version: f64,
        param_token: String,
        context: &C) -> Result<ValidateAccountSignupResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/account/validateAccountSignup",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("token",
                    &param_token);
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::AccountLoginResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(ValidateAccountSignupResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn validate_password_reset(
        &self,
        param_version: f64,
        param_token: String,
        context: &C) -> Result<ValidatePasswordResetResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/account/validatepasswordreset",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("token",
                    &param_token);
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(ValidatePasswordResetResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn api_version_achievement_tier_search_post(
        &self,
        param_version: f64,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_app_key: Option<String>,
        param_keyword: Option<String>,
        param_achievement_type: Option<i64>,
        param_rank_type: Option<String>,
        param_sort_field: Option<String>,
        param_descending: Option<bool>,
        param_descending_goal: Option<bool>,
        param_start: Option<i64>,
        param_limit: Option<i64>,
        context: &C) -> Result<ApiVersionAchievementTierSearchPostResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/achievement/tier/search",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_app_key) = param_app_key {
                query_string.append_pair("appKey",
                    &param_app_key);
            }
            if let Some(param_keyword) = param_keyword {
                query_string.append_pair("keyword",
                    &param_keyword);
            }
            if let Some(param_achievement_type) = param_achievement_type {
                query_string.append_pair("achievementType",
                    &param_achievement_type.to_string());
            }
            if let Some(param_rank_type) = param_rank_type {
                query_string.append_pair("rankType",
                    &param_rank_type);
            }
            if let Some(param_sort_field) = param_sort_field {
                query_string.append_pair("sortField",
                    &param_sort_field);
            }
            if let Some(param_descending) = param_descending {
                query_string.append_pair("descending",
                    &param_descending.to_string());
            }
            if let Some(param_descending_goal) = param_descending_goal {
                query_string.append_pair("descendingGoal",
                    &param_descending_goal.to_string());
            }
            if let Some(param_start) = param_start {
                query_string.append_pair("start",
                    &param_start.to_string());
            }
            if let Some(param_limit) = param_limit {
                query_string.append_pair("limit",
                    &param_limit.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::AchievementTierResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(ApiVersionAchievementTierSearchPostResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn create_achievement(
        &self,
        param_version: f64,
        param_app_key: String,
        param_title: String,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_analytics_tag: Option<String>,
        param_description: Option<String>,
        param_rank_type: Option<String>,
        param_rank_increment: Option<i32>,
        param_min_increment: Option<i32>,
        param_max_increment: Option<i32>,
        param_validate: Option<bool>,
        param_active: Option<bool>,
        param_trigger_definition: Option<String>,
        context: &C) -> Result<CreateAchievementResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/achievement/create",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
                query_string.append_pair("appKey",
                    &param_app_key);
            if let Some(param_analytics_tag) = param_analytics_tag {
                query_string.append_pair("analyticsTag",
                    &param_analytics_tag);
            }
                query_string.append_pair("title",
                    &param_title);
            if let Some(param_description) = param_description {
                query_string.append_pair("description",
                    &param_description);
            }
            if let Some(param_rank_type) = param_rank_type {
                query_string.append_pair("rankType",
                    &param_rank_type);
            }
            if let Some(param_rank_increment) = param_rank_increment {
                query_string.append_pair("rankIncrement",
                    &param_rank_increment.to_string());
            }
            if let Some(param_min_increment) = param_min_increment {
                query_string.append_pair("minIncrement",
                    &param_min_increment.to_string());
            }
            if let Some(param_max_increment) = param_max_increment {
                query_string.append_pair("maxIncrement",
                    &param_max_increment.to_string());
            }
            if let Some(param_validate) = param_validate {
                query_string.append_pair("validate",
                    &param_validate.to_string());
            }
            if let Some(param_active) = param_active {
                query_string.append_pair("active",
                    &param_active.to_string());
            }
            if let Some(param_trigger_definition) = param_trigger_definition {
                query_string.append_pair("triggerDefinition",
                    &param_trigger_definition);
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::AchievementResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(CreateAchievementResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn create_achievement_tier(
        &self,
        param_version: f64,
        param_achievement_id: i64,
        param_score_all_instances: bool,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_icon: Option<swagger::ByteArray>,
        param_icon_asset_id: Option<i64>,
        param_title: Option<String>,
        param_description: Option<String>,
        param_goal_count: Option<i64>,
        param_mission_id: Option<i64>,
        param_game_id: Option<i64>,
        param_pack_id: Option<i64>,
        param_game_level_id: Option<i64>,
        param_game_object_id: Option<i32>,
        context: &C) -> Result<CreateAchievementTierResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/achievement/tier/create",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
                query_string.append_pair("achievementId",
                    &param_achievement_id.to_string());
            if let Some(param_icon) = param_icon {
                query_string.append_pair("icon",
                    &param_icon.to_string());
            }
            if let Some(param_icon_asset_id) = param_icon_asset_id {
                query_string.append_pair("iconAssetId",
                    &param_icon_asset_id.to_string());
            }
            if let Some(param_title) = param_title {
                query_string.append_pair("title",
                    &param_title);
            }
            if let Some(param_description) = param_description {
                query_string.append_pair("description",
                    &param_description);
            }
            if let Some(param_goal_count) = param_goal_count {
                query_string.append_pair("goalCount",
                    &param_goal_count.to_string());
            }
            if let Some(param_mission_id) = param_mission_id {
                query_string.append_pair("missionId",
                    &param_mission_id.to_string());
            }
            if let Some(param_game_id) = param_game_id {
                query_string.append_pair("gameId",
                    &param_game_id.to_string());
            }
            if let Some(param_pack_id) = param_pack_id {
                query_string.append_pair("packId",
                    &param_pack_id.to_string());
            }
            if let Some(param_game_level_id) = param_game_level_id {
                query_string.append_pair("gameLevelId",
                    &param_game_level_id.to_string());
            }
            if let Some(param_game_object_id) = param_game_object_id {
                query_string.append_pair("gameObjectId",
                    &param_game_object_id.to_string());
            }
                query_string.append_pair("scoreAllInstances",
                    &param_score_all_instances.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::AchievementTierResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(CreateAchievementTierResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn delete_achievement(
        &self,
        param_version: f64,
        param_achievement_id: i64,
        param_account_id: Option<i64>,
        context: &C) -> Result<DeleteAchievementResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/achievement/delete",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
                query_string.append_pair("achievementId",
                    &param_achievement_id.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(DeleteAchievementResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn delete_achievement_tier(
        &self,
        param_version: f64,
        param_achievement_tier_id: i64,
        param_account_id: Option<i64>,
        context: &C) -> Result<DeleteAchievementTierResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/achievement/tier/delete",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
                query_string.append_pair("achievementTierId",
                    &param_achievement_tier_id.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(DeleteAchievementTierResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_achievement(
        &self,
        param_version: f64,
        param_achievement_id: i64,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_achievement_type: Option<String>,
        context: &C) -> Result<GetAchievementResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/achievement/get",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
                query_string.append_pair("achievementId",
                    &param_achievement_id.to_string());
            if let Some(param_achievement_type) = param_achievement_type {
                query_string.append_pair("achievementType",
                    &param_achievement_type);
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::AchievementTierResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetAchievementResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_achievement_tier(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_achievement_tier_id: i64,
        context: &C) -> Result<GetAchievementTierResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/achievement/tier/get",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("achievementTierId",
                    &param_achievement_tier_id.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::AchievementTierResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetAchievementTierResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_user_achievements(
        &self,
        param_version: f64,
        param_return_nulls: bool,
        param_app_key: String,
        param_include_undiscovered: bool,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_connection_account_email: Option<String>,
        param_connection_account_id: Option<i64>,
        param_rank_type: Option<String>,
        param_achievement_type: Option<String>,
        param_latitude: Option<f64>,
        param_longitude: Option<f64>,
        context: &C) -> Result<GetUserAchievementsResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/achievement/progress/get",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("returnNulls",
                    &param_return_nulls.to_string());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_connection_account_email) = param_connection_account_email {
                query_string.append_pair("connectionAccountEmail",
                    &param_connection_account_email);
            }
            if let Some(param_connection_account_id) = param_connection_account_id {
                query_string.append_pair("connectionAccountId",
                    &param_connection_account_id.to_string());
            }
                query_string.append_pair("appKey",
                    &param_app_key);
            if let Some(param_rank_type) = param_rank_type {
                query_string.append_pair("rankType",
                    &param_rank_type);
            }
            if let Some(param_achievement_type) = param_achievement_type {
                query_string.append_pair("achievementType",
                    &param_achievement_type);
            }
                query_string.append_pair("includeUndiscovered",
                    &param_include_undiscovered.to_string());
            if let Some(param_latitude) = param_latitude {
                query_string.append_pair("latitude",
                    &param_latitude.to_string());
            }
            if let Some(param_longitude) = param_longitude {
                query_string.append_pair("longitude",
                    &param_longitude.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<Vec<models::AchievementProgressResponse>>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetUserAchievementsResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn list_achievement_tags(
        &self,
        param_version: f64,
        param_app_key: Option<String>,
        context: &C) -> Result<ListAchievementTagsResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/achievement/tag/list",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_app_key) = param_app_key {
                query_string.append_pair("appKey",
                    &param_app_key);
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(ListAchievementTagsResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn list_achievements(
        &self,
        param_version: f64,
        param_sort_field: models::ListAchievementsSortFieldParameter,
        param_descending: bool,
        param_start: i32,
        param_limit: i32,
        param_active_only: bool,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_app_key: Option<String>,
        param_keyword: Option<String>,
        param_achievement_type: Option<String>,
        param_rank_type: Option<String>,
        context: &C) -> Result<ListAchievementsResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/achievement/list",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_app_key) = param_app_key {
                query_string.append_pair("appKey",
                    &param_app_key);
            }
            if let Some(param_keyword) = param_keyword {
                query_string.append_pair("keyword",
                    &param_keyword);
            }
            if let Some(param_achievement_type) = param_achievement_type {
                query_string.append_pair("achievementType",
                    &param_achievement_type);
            }
            if let Some(param_rank_type) = param_rank_type {
                query_string.append_pair("rankType",
                    &param_rank_type);
            }
                query_string.append_pair("sortField",
                    &param_sort_field.to_string());
                query_string.append_pair("descending",
                    &param_descending.to_string());
                query_string.append_pair("start",
                    &param_start.to_string());
                query_string.append_pair("limit",
                    &param_limit.to_string());
                query_string.append_pair("activeOnly",
                    &param_active_only.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<Vec<models::AchievementShortResponse>>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(ListAchievementsResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn search_achievements(
        &self,
        param_version: f64,
        param_app_key: String,
        param_sort_field: models::SearchAchievementsSortFieldParameter,
        param_descending: bool,
        param_include_tiers: bool,
        param_include_inactive_tiers: bool,
        param_start: i32,
        param_limit: i32,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_keyword: Option<String>,
        param_achievement_type: Option<String>,
        param_rank_type: Option<String>,
        context: &C) -> Result<SearchAchievementsResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/achievement/search",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
                query_string.append_pair("appKey",
                    &param_app_key);
            if let Some(param_keyword) = param_keyword {
                query_string.append_pair("keyword",
                    &param_keyword);
            }
            if let Some(param_achievement_type) = param_achievement_type {
                query_string.append_pair("achievementType",
                    &param_achievement_type);
            }
            if let Some(param_rank_type) = param_rank_type {
                query_string.append_pair("rankType",
                    &param_rank_type);
            }
                query_string.append_pair("sortField",
                    &param_sort_field.to_string());
                query_string.append_pair("descending",
                    &param_descending.to_string());
                query_string.append_pair("includeTiers",
                    &param_include_tiers.to_string());
                query_string.append_pair("includeInactiveTiers",
                    &param_include_inactive_tiers.to_string());
                query_string.append_pair("start",
                    &param_start.to_string());
                query_string.append_pair("limit",
                    &param_limit.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<Vec<models::AchievementShortResponse>>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(SearchAchievementsResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn update_achievement(
        &self,
        param_version: f64,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_achievement_id: Option<i64>,
        param_analytics_tag: Option<String>,
        param_title: Option<String>,
        param_description: Option<String>,
        param_rank_type: Option<String>,
        param_rank_increment: Option<i32>,
        param_min_increment: Option<i32>,
        param_null_min_increment: Option<bool>,
        param_max_increment: Option<i32>,
        param_null_max_increment: Option<bool>,
        param_validate: Option<bool>,
        param_active: Option<bool>,
        param_trigger_definition: Option<String>,
        context: &C) -> Result<UpdateAchievementResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/achievement/update",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_achievement_id) = param_achievement_id {
                query_string.append_pair("achievementId",
                    &param_achievement_id.to_string());
            }
            if let Some(param_analytics_tag) = param_analytics_tag {
                query_string.append_pair("analyticsTag",
                    &param_analytics_tag);
            }
            if let Some(param_title) = param_title {
                query_string.append_pair("title",
                    &param_title);
            }
            if let Some(param_description) = param_description {
                query_string.append_pair("description",
                    &param_description);
            }
            if let Some(param_rank_type) = param_rank_type {
                query_string.append_pair("rankType",
                    &param_rank_type);
            }
            if let Some(param_rank_increment) = param_rank_increment {
                query_string.append_pair("rankIncrement",
                    &param_rank_increment.to_string());
            }
            if let Some(param_min_increment) = param_min_increment {
                query_string.append_pair("minIncrement",
                    &param_min_increment.to_string());
            }
            if let Some(param_null_min_increment) = param_null_min_increment {
                query_string.append_pair("nullMinIncrement",
                    &param_null_min_increment.to_string());
            }
            if let Some(param_max_increment) = param_max_increment {
                query_string.append_pair("maxIncrement",
                    &param_max_increment.to_string());
            }
            if let Some(param_null_max_increment) = param_null_max_increment {
                query_string.append_pair("nullMaxIncrement",
                    &param_null_max_increment.to_string());
            }
            if let Some(param_validate) = param_validate {
                query_string.append_pair("validate",
                    &param_validate.to_string());
            }
            if let Some(param_active) = param_active {
                query_string.append_pair("active",
                    &param_active.to_string());
            }
            if let Some(param_trigger_definition) = param_trigger_definition {
                query_string.append_pair("triggerDefinition",
                    &param_trigger_definition);
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::AchievementResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(UpdateAchievementResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn update_achievement_tier(
        &self,
        param_version: f64,
        param_achievement_tier_id: i64,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_icon: Option<swagger::ByteArray>,
        param_icon_asset_id: Option<i64>,
        param_title: Option<String>,
        param_description: Option<String>,
        param_goal_count: Option<i64>,
        param_mission_id: Option<i64>,
        param_game_id: Option<i64>,
        param_pack_id: Option<i64>,
        param_game_level_id: Option<i64>,
        param_game_object_id: Option<i64>,
        param_score_all_instances: Option<bool>,
        context: &C) -> Result<UpdateAchievementTierResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/achievement/tier/update",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
                query_string.append_pair("achievementTierId",
                    &param_achievement_tier_id.to_string());
            if let Some(param_icon) = param_icon {
                query_string.append_pair("icon",
                    &param_icon.to_string());
            }
            if let Some(param_icon_asset_id) = param_icon_asset_id {
                query_string.append_pair("iconAssetId",
                    &param_icon_asset_id.to_string());
            }
            if let Some(param_title) = param_title {
                query_string.append_pair("title",
                    &param_title);
            }
            if let Some(param_description) = param_description {
                query_string.append_pair("description",
                    &param_description);
            }
            if let Some(param_goal_count) = param_goal_count {
                query_string.append_pair("goalCount",
                    &param_goal_count.to_string());
            }
            if let Some(param_mission_id) = param_mission_id {
                query_string.append_pair("missionId",
                    &param_mission_id.to_string());
            }
            if let Some(param_game_id) = param_game_id {
                query_string.append_pair("gameId",
                    &param_game_id.to_string());
            }
            if let Some(param_pack_id) = param_pack_id {
                query_string.append_pair("packId",
                    &param_pack_id.to_string());
            }
            if let Some(param_game_level_id) = param_game_level_id {
                query_string.append_pair("gameLevelId",
                    &param_game_level_id.to_string());
            }
            if let Some(param_game_object_id) = param_game_object_id {
                query_string.append_pair("gameObjectId",
                    &param_game_object_id.to_string());
            }
            if let Some(param_score_all_instances) = param_score_all_instances {
                query_string.append_pair("scoreAllInstances",
                    &param_score_all_instances.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::AchievementTierResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(UpdateAchievementTierResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn update_user_achievement(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_achievement_id: Option<i64>,
        param_tag: Option<String>,
        param_custom_id: Option<i64>,
        param_increment: Option<i64>,
        param_start_date: Option<i64>,
        param_end_date: Option<i64>,
        param_return_progress: Option<bool>,
        context: &C) -> Result<UpdateUserAchievementResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/achievement/progress/update",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            if let Some(param_achievement_id) = param_achievement_id {
                query_string.append_pair("achievementId",
                    &param_achievement_id.to_string());
            }
            if let Some(param_tag) = param_tag {
                query_string.append_pair("tag",
                    &param_tag);
            }
            if let Some(param_custom_id) = param_custom_id {
                query_string.append_pair("customId",
                    &param_custom_id.to_string());
            }
            if let Some(param_increment) = param_increment {
                query_string.append_pair("increment",
                    &param_increment.to_string());
            }
            if let Some(param_start_date) = param_start_date {
                query_string.append_pair("startDate",
                    &param_start_date.to_string());
            }
            if let Some(param_end_date) = param_end_date {
                query_string.append_pair("endDate",
                    &param_end_date.to_string());
            }
            if let Some(param_return_progress) = param_return_progress {
                query_string.append_pair("returnProgress",
                    &param_return_progress.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(UpdateUserAchievementResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn create_entity_reference(
        &self,
        param_version: f64,
        param_body: models::EntityReference,
        context: &C) -> Result<CreateEntityReferenceResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/entity/reference",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        // Consumes basic body
        // Body parameter
        let body = serde_json::to_string(&param_body).expect("impossible to fail to serialize");
        *request.body_mut() = body_from_string(body);

        let header = "application/json";
        request.headers_mut().insert(CONTENT_TYPE, HeaderValue::from_static(header));

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::ActivityResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(CreateEntityReferenceResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn add_album_collection(
        &self,
        param_version: f64,
        param_title: String,
        param_cover_asset_nullable: bool,
        param_include_cover_in_asset_list: bool,
        param_public_read: bool,
        param_public_write: bool,
        param_public_delete: bool,
        param_public_add: bool,
        param_anonymous: bool,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_assets_to_add: Option<String>,
        param_media: Option<swagger::ByteArray>,
        param_media_url: Option<String>,
        param_asset_id: Option<i64>,
        param_attached_media: Option<swagger::ByteArray>,
        param_attached_media_url: Option<String>,
        param_start_date: Option<i64>,
        param_end_date: Option<i64>,
        param_tags: Option<String>,
        param_description: Option<String>,
        param_album_type: Option<String>,
        param_album_type_id: Option<i64>,
        param_sub_type: Option<String>,
        param_latitude: Option<f64>,
        param_longitude: Option<f64>,
        param_location_description: Option<String>,
        param_visibility: Option<models::AddAlbumCollectionVisibilityParameter>,
        param_game_type: Option<String>,
        param_app_key: Option<String>,
        param_cell_phone: Option<String>,
        param_street_address: Option<String>,
        param_street_address2: Option<String>,
        param_city: Option<String>,
        param_state: Option<String>,
        param_postal_code: Option<String>,
        param_full_address: Option<String>,
        param_meta_data: Option<String>,
        param_category_ids: Option<String>,
        param_category_filter_ids: Option<String>,
        param_audience_ids: Option<String>,
        param_include_all_app_users_as_members: Option<bool>,
        param_include_audiences_as_members: Option<bool>,
        param_audience_operator: Option<String>,
        param_approval_status: Option<models::ApproveAlbumApprovalStatusParameter>,
        param_linked_object_type: Option<String>,
        param_linked_object_id: Option<i64>,
        context: &C) -> Result<AddAlbumCollectionResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/album/create",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
                query_string.append_pair("title",
                    &param_title);
            if let Some(param_assets_to_add) = param_assets_to_add {
                query_string.append_pair("assetsToAdd",
                    &param_assets_to_add);
            }
            if let Some(param_media) = param_media {
                query_string.append_pair("media",
                    &param_media.to_string());
            }
            if let Some(param_media_url) = param_media_url {
                query_string.append_pair("mediaURL",
                    &param_media_url);
            }
            if let Some(param_asset_id) = param_asset_id {
                query_string.append_pair("assetId",
                    &param_asset_id.to_string());
            }
            if let Some(param_attached_media) = param_attached_media {
                query_string.append_pair("attachedMedia",
                    &param_attached_media.to_string());
            }
            if let Some(param_attached_media_url) = param_attached_media_url {
                query_string.append_pair("attachedMediaURL",
                    &param_attached_media_url);
            }
                query_string.append_pair("coverAssetNullable",
                    &param_cover_asset_nullable.to_string());
                query_string.append_pair("includeCoverInAssetList",
                    &param_include_cover_in_asset_list.to_string());
            if let Some(param_start_date) = param_start_date {
                query_string.append_pair("startDate",
                    &param_start_date.to_string());
            }
            if let Some(param_end_date) = param_end_date {
                query_string.append_pair("endDate",
                    &param_end_date.to_string());
            }
            if let Some(param_tags) = param_tags {
                query_string.append_pair("tags",
                    &param_tags);
            }
            if let Some(param_description) = param_description {
                query_string.append_pair("description",
                    &param_description);
            }
            if let Some(param_album_type) = param_album_type {
                query_string.append_pair("albumType",
                    &param_album_type);
            }
            if let Some(param_album_type_id) = param_album_type_id {
                query_string.append_pair("albumTypeId",
                    &param_album_type_id.to_string());
            }
            if let Some(param_sub_type) = param_sub_type {
                query_string.append_pair("subType",
                    &param_sub_type);
            }
                query_string.append_pair("publicRead",
                    &param_public_read.to_string());
                query_string.append_pair("publicWrite",
                    &param_public_write.to_string());
                query_string.append_pair("publicDelete",
                    &param_public_delete.to_string());
                query_string.append_pair("publicAdd",
                    &param_public_add.to_string());
            if let Some(param_latitude) = param_latitude {
                query_string.append_pair("latitude",
                    &param_latitude.to_string());
            }
            if let Some(param_longitude) = param_longitude {
                query_string.append_pair("longitude",
                    &param_longitude.to_string());
            }
            if let Some(param_location_description) = param_location_description {
                query_string.append_pair("locationDescription",
                    &param_location_description);
            }
            if let Some(param_visibility) = param_visibility {
                query_string.append_pair("visibility",
                    &param_visibility.to_string());
            }
            if let Some(param_game_type) = param_game_type {
                query_string.append_pair("gameType",
                    &param_game_type);
            }
            if let Some(param_app_key) = param_app_key {
                query_string.append_pair("appKey",
                    &param_app_key);
            }
            if let Some(param_cell_phone) = param_cell_phone {
                query_string.append_pair("cellPhone",
                    &param_cell_phone);
            }
            if let Some(param_street_address) = param_street_address {
                query_string.append_pair("streetAddress",
                    &param_street_address);
            }
            if let Some(param_street_address2) = param_street_address2 {
                query_string.append_pair("streetAddress2",
                    &param_street_address2);
            }
            if let Some(param_city) = param_city {
                query_string.append_pair("city",
                    &param_city);
            }
            if let Some(param_state) = param_state {
                query_string.append_pair("state",
                    &param_state);
            }
            if let Some(param_postal_code) = param_postal_code {
                query_string.append_pair("postalCode",
                    &param_postal_code);
            }
            if let Some(param_full_address) = param_full_address {
                query_string.append_pair("fullAddress",
                    &param_full_address);
            }
                query_string.append_pair("anonymous",
                    &param_anonymous.to_string());
            if let Some(param_meta_data) = param_meta_data {
                query_string.append_pair("metaData",
                    &param_meta_data);
            }
            if let Some(param_category_ids) = param_category_ids {
                query_string.append_pair("categoryIds",
                    &param_category_ids);
            }
            if let Some(param_category_filter_ids) = param_category_filter_ids {
                query_string.append_pair("categoryFilterIds",
                    &param_category_filter_ids);
            }
            if let Some(param_audience_ids) = param_audience_ids {
                query_string.append_pair("audienceIds",
                    &param_audience_ids);
            }
            if let Some(param_include_all_app_users_as_members) = param_include_all_app_users_as_members {
                query_string.append_pair("includeAllAppUsersAsMembers",
                    &param_include_all_app_users_as_members.to_string());
            }
            if let Some(param_include_audiences_as_members) = param_include_audiences_as_members {
                query_string.append_pair("includeAudiencesAsMembers",
                    &param_include_audiences_as_members.to_string());
            }
            if let Some(param_audience_operator) = param_audience_operator {
                query_string.append_pair("audienceOperator",
                    &param_audience_operator);
            }
            if let Some(param_approval_status) = param_approval_status {
                query_string.append_pair("approvalStatus",
                    &param_approval_status.to_string());
            }
            if let Some(param_linked_object_type) = param_linked_object_type {
                query_string.append_pair("linkedObjectType",
                    &param_linked_object_type);
            }
            if let Some(param_linked_object_id) = param_linked_object_id {
                query_string.append_pair("linkedObjectId",
                    &param_linked_object_id.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SearchResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(AddAlbumCollectionResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn add_album_users(
        &self,
        param_version: f64,
        param_album_id: i64,
        param_include_friend_group: bool,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_read: Option<bool>,
        param_write: Option<bool>,
        param_delete: Option<bool>,
        param_add: Option<bool>,
        param_connections: Option<String>,
        param_connection_groups: Option<String>,
        context: &C) -> Result<AddAlbumUsersResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/album/user/add",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
                query_string.append_pair("albumId",
                    &param_album_id.to_string());
            if let Some(param_read) = param_read {
                query_string.append_pair("read",
                    &param_read.to_string());
            }
            if let Some(param_write) = param_write {
                query_string.append_pair("write",
                    &param_write.to_string());
            }
            if let Some(param_delete) = param_delete {
                query_string.append_pair("delete",
                    &param_delete.to_string());
            }
            if let Some(param_add) = param_add {
                query_string.append_pair("add",
                    &param_add.to_string());
            }
            if let Some(param_connections) = param_connections {
                query_string.append_pair("connections",
                    &param_connections);
            }
            if let Some(param_connection_groups) = param_connection_groups {
                query_string.append_pair("connectionGroups",
                    &param_connection_groups);
            }
                query_string.append_pair("includeFriendGroup",
                    &param_include_friend_group.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(AddAlbumUsersResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn approve_album(
        &self,
        param_version: f64,
        param_album_id: i64,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_approval_status: Option<models::ApproveAlbumApprovalStatusParameter>,
        param_verified: Option<bool>,
        context: &C) -> Result<ApproveAlbumResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/album/approve",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
                query_string.append_pair("albumId",
                    &param_album_id.to_string());
            if let Some(param_approval_status) = param_approval_status {
                query_string.append_pair("approvalStatus",
                    &param_approval_status.to_string());
            }
            if let Some(param_verified) = param_verified {
                query_string.append_pair("verified",
                    &param_verified.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(ApproveAlbumResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_album_collection(
        &self,
        param_version: f64,
        param_return_nulls: bool,
        param_album_id: i64,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_like_preview_size: Option<i32>,
        param_asset_preview_size: Option<i32>,
        param_note_preview_size: Option<i32>,
        param_connection_preview_size: Option<i32>,
        param_audience_preview_size: Option<i32>,
        context: &C) -> Result<GetAlbumCollectionResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/album/get",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("returnNulls",
                    &param_return_nulls.to_string());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
                query_string.append_pair("albumId",
                    &param_album_id.to_string());
            if let Some(param_like_preview_size) = param_like_preview_size {
                query_string.append_pair("likePreviewSize",
                    &param_like_preview_size.to_string());
            }
            if let Some(param_asset_preview_size) = param_asset_preview_size {
                query_string.append_pair("assetPreviewSize",
                    &param_asset_preview_size.to_string());
            }
            if let Some(param_note_preview_size) = param_note_preview_size {
                query_string.append_pair("notePreviewSize",
                    &param_note_preview_size.to_string());
            }
            if let Some(param_connection_preview_size) = param_connection_preview_size {
                query_string.append_pair("connectionPreviewSize",
                    &param_connection_preview_size.to_string());
            }
            if let Some(param_audience_preview_size) = param_audience_preview_size {
                query_string.append_pair("audiencePreviewSize",
                    &param_audience_preview_size.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::AlbumFullResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetAlbumCollectionResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn leave_album(
        &self,
        param_version: f64,
        param_album_id: i64,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        context: &C) -> Result<LeaveAlbumResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/album/user/leave",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
                query_string.append_pair("albumId",
                    &param_album_id.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(LeaveAlbumResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn remove_album(
        &self,
        param_version: f64,
        param_album_id: i64,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        context: &C) -> Result<RemoveAlbumResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/album/delete",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
                query_string.append_pair("albumId",
                    &param_album_id.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(RemoveAlbumResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn remove_album_users(
        &self,
        param_version: f64,
        param_album_id: i64,
        param_remove_friend_group: bool,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_connections: Option<String>,
        param_connection_groups: Option<String>,
        context: &C) -> Result<RemoveAlbumUsersResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/album/user/delete",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
                query_string.append_pair("albumId",
                    &param_album_id.to_string());
            if let Some(param_connections) = param_connections {
                query_string.append_pair("connections",
                    &param_connections);
            }
            if let Some(param_connection_groups) = param_connection_groups {
                query_string.append_pair("connectionGroups",
                    &param_connection_groups);
            }
                query_string.append_pair("removeFriendGroup",
                    &param_remove_friend_group.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(RemoveAlbumUsersResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn search_albums(
        &self,
        param_version: f64,
        param_filter: String,
        param_album_type_id: i64,
        param_sub_type: String,
        param_include_inactive: bool,
        param_sort_field: String,
        param_descending: bool,
        param_start: i32,
        param_limit: i32,
        param_range: f64,
        param_include_liked: bool,
        param_include_favorited: bool,
        param_include_permissions: bool,
        param_like_preview_size: i32,
        param_asset_preview_size: i32,
        param_note_preview_size: i32,
        param_connection_preview_size: i32,
        param_audience_preview_size: i32,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_connection_account_id: Option<i64>,
        param_owner_id: Option<i64>,
        param_album_ids: Option<String>,
        param_exclude_album_ids: Option<String>,
        param_media_id: Option<i64>,
        param_keyword: Option<String>,
        param_album_type: Option<String>,
        param_limit_per_album_type: Option<i32>,
        param_date_created: Option<i64>,
        param_updated_since: Option<i64>,
        param_updated_before: Option<i64>,
        param_created_since: Option<i64>,
        param_created_before: Option<i64>,
        param_started_since: Option<i64>,
        param_started_before: Option<i64>,
        param_ended_since: Option<i64>,
        param_ended_before: Option<i64>,
        param_latitude: Option<f64>,
        param_longitude: Option<f64>,
        param_app_key: Option<String>,
        param_category_ids: Option<String>,
        param_category_filter_ids: Option<String>,
        param_audience_ids: Option<String>,
        param_exclude_audience_ids: Option<String>,
        param_include_completable: Option<bool>,
        param_include_rating: Option<bool>,
        param_search_mode: Option<String>,
        param_stack_search: Option<bool>,
        param_stack_window_size: Option<i32>,
        param_min_stack_per_page: Option<i32>,
        param_stack_pagination_identifier: Option<String>,
        param_stack_details: Option<bool>,
        param_flag_count_minimum: Option<i64>,
        param_remove_flagged_content: Option<bool>,
        param_verified_filter: Option<bool>,
        param_linked_object_type: Option<String>,
        param_linked_object_id: Option<i64>,
        param_order_audience_id: Option<i64>,
        param_ignore_default_app_filter: Option<bool>,
        param_search_expression: Option<String>,
        param_generate_albums: Option<bool>,
        context: &C) -> Result<SearchAlbumsResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/album/search",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_connection_account_id) = param_connection_account_id {
                query_string.append_pair("connectionAccountId",
                    &param_connection_account_id.to_string());
            }
            if let Some(param_owner_id) = param_owner_id {
                query_string.append_pair("ownerId",
                    &param_owner_id.to_string());
            }
            if let Some(param_album_ids) = param_album_ids {
                query_string.append_pair("albumIds",
                    &param_album_ids);
            }
            if let Some(param_exclude_album_ids) = param_exclude_album_ids {
                query_string.append_pair("excludeAlbumIds",
                    &param_exclude_album_ids);
            }
            if let Some(param_media_id) = param_media_id {
                query_string.append_pair("mediaId",
                    &param_media_id.to_string());
            }
            if let Some(param_keyword) = param_keyword {
                query_string.append_pair("keyword",
                    &param_keyword);
            }
                query_string.append_pair("filter",
                    &param_filter);
            if let Some(param_album_type) = param_album_type {
                query_string.append_pair("albumType",
                    &param_album_type);
            }
                query_string.append_pair("albumTypeId",
                    &param_album_type_id.to_string());
                query_string.append_pair("subType",
                    &param_sub_type);
                query_string.append_pair("includeInactive",
                    &param_include_inactive.to_string());
                query_string.append_pair("sortField",
                    &param_sort_field);
                query_string.append_pair("descending",
                    &param_descending.to_string());
                query_string.append_pair("start",
                    &param_start.to_string());
                query_string.append_pair("limit",
                    &param_limit.to_string());
            if let Some(param_limit_per_album_type) = param_limit_per_album_type {
                query_string.append_pair("limitPerAlbumType",
                    &param_limit_per_album_type.to_string());
            }
            if let Some(param_date_created) = param_date_created {
                query_string.append_pair("dateCreated",
                    &param_date_created.to_string());
            }
            if let Some(param_updated_since) = param_updated_since {
                query_string.append_pair("updatedSince",
                    &param_updated_since.to_string());
            }
            if let Some(param_updated_before) = param_updated_before {
                query_string.append_pair("updatedBefore",
                    &param_updated_before.to_string());
            }
            if let Some(param_created_since) = param_created_since {
                query_string.append_pair("createdSince",
                    &param_created_since.to_string());
            }
            if let Some(param_created_before) = param_created_before {
                query_string.append_pair("createdBefore",
                    &param_created_before.to_string());
            }
            if let Some(param_started_since) = param_started_since {
                query_string.append_pair("startedSince",
                    &param_started_since.to_string());
            }
            if let Some(param_started_before) = param_started_before {
                query_string.append_pair("startedBefore",
                    &param_started_before.to_string());
            }
            if let Some(param_ended_since) = param_ended_since {
                query_string.append_pair("endedSince",
                    &param_ended_since.to_string());
            }
            if let Some(param_ended_before) = param_ended_before {
                query_string.append_pair("endedBefore",
                    &param_ended_before.to_string());
            }
            if let Some(param_latitude) = param_latitude {
                query_string.append_pair("latitude",
                    &param_latitude.to_string());
            }
            if let Some(param_longitude) = param_longitude {
                query_string.append_pair("longitude",
                    &param_longitude.to_string());
            }
                query_string.append_pair("range",
                    &param_range.to_string());
            if let Some(param_app_key) = param_app_key {
                query_string.append_pair("appKey",
                    &param_app_key);
            }
            if let Some(param_category_ids) = param_category_ids {
                query_string.append_pair("categoryIds",
                    &param_category_ids);
            }
            if let Some(param_category_filter_ids) = param_category_filter_ids {
                query_string.append_pair("categoryFilterIds",
                    &param_category_filter_ids);
            }
            if let Some(param_audience_ids) = param_audience_ids {
                query_string.append_pair("audienceIds",
                    &param_audience_ids);
            }
            if let Some(param_exclude_audience_ids) = param_exclude_audience_ids {
                query_string.append_pair("excludeAudienceIds",
                    &param_exclude_audience_ids);
            }
                query_string.append_pair("includeLiked",
                    &param_include_liked.to_string());
                query_string.append_pair("includeFavorited",
                    &param_include_favorited.to_string());
                query_string.append_pair("includePermissions",
                    &param_include_permissions.to_string());
            if let Some(param_include_completable) = param_include_completable {
                query_string.append_pair("includeCompletable",
                    &param_include_completable.to_string());
            }
            if let Some(param_include_rating) = param_include_rating {
                query_string.append_pair("includeRating",
                    &param_include_rating.to_string());
            }
                query_string.append_pair("likePreviewSize",
                    &param_like_preview_size.to_string());
                query_string.append_pair("assetPreviewSize",
                    &param_asset_preview_size.to_string());
                query_string.append_pair("notePreviewSize",
                    &param_note_preview_size.to_string());
                query_string.append_pair("connectionPreviewSize",
                    &param_connection_preview_size.to_string());
                query_string.append_pair("audiencePreviewSize",
                    &param_audience_preview_size.to_string());
            if let Some(param_search_mode) = param_search_mode {
                query_string.append_pair("searchMode",
                    &param_search_mode);
            }
            if let Some(param_stack_search) = param_stack_search {
                query_string.append_pair("stackSearch",
                    &param_stack_search.to_string());
            }
            if let Some(param_stack_window_size) = param_stack_window_size {
                query_string.append_pair("stackWindowSize",
                    &param_stack_window_size.to_string());
            }
            if let Some(param_min_stack_per_page) = param_min_stack_per_page {
                query_string.append_pair("minStackPerPage",
                    &param_min_stack_per_page.to_string());
            }
            if let Some(param_stack_pagination_identifier) = param_stack_pagination_identifier {
                query_string.append_pair("stackPaginationIdentifier",
                    &param_stack_pagination_identifier);
            }
            if let Some(param_stack_details) = param_stack_details {
                query_string.append_pair("stackDetails",
                    &param_stack_details.to_string());
            }
            if let Some(param_flag_count_minimum) = param_flag_count_minimum {
                query_string.append_pair("flagCountMinimum",
                    &param_flag_count_minimum.to_string());
            }
            if let Some(param_remove_flagged_content) = param_remove_flagged_content {
                query_string.append_pair("removeFlaggedContent",
                    &param_remove_flagged_content.to_string());
            }
            if let Some(param_verified_filter) = param_verified_filter {
                query_string.append_pair("verifiedFilter",
                    &param_verified_filter.to_string());
            }
            if let Some(param_linked_object_type) = param_linked_object_type {
                query_string.append_pair("linkedObjectType",
                    &param_linked_object_type);
            }
            if let Some(param_linked_object_id) = param_linked_object_id {
                query_string.append_pair("linkedObjectId",
                    &param_linked_object_id.to_string());
            }
            if let Some(param_order_audience_id) = param_order_audience_id {
                query_string.append_pair("orderAudienceId",
                    &param_order_audience_id.to_string());
            }
            if let Some(param_ignore_default_app_filter) = param_ignore_default_app_filter {
                query_string.append_pair("ignoreDefaultAppFilter",
                    &param_ignore_default_app_filter.to_string());
            }
            if let Some(param_search_expression) = param_search_expression {
                query_string.append_pair("searchExpression",
                    &param_search_expression);
            }
            if let Some(param_generate_albums) = param_generate_albums {
                query_string.append_pair("generateAlbums",
                    &param_generate_albums.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<Vec<models::AlbumFullResponse>>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(SearchAlbumsResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn update_album_collection(
        &self,
        param_version: f64,
        param_album_id: i64,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_assets_to_add: Option<String>,
        param_assets_to_remove: Option<String>,
        param_asset_id: Option<i64>,
        param_media: Option<swagger::ByteArray>,
        param_media_url: Option<String>,
        param_active: Option<bool>,
        param_title: Option<String>,
        param_start_date: Option<i64>,
        param_end_date: Option<i64>,
        param_tags: Option<String>,
        param_description: Option<String>,
        param_album_type: Option<String>,
        param_album_type_id: Option<i64>,
        param_sub_type: Option<String>,
        param_public_read: Option<bool>,
        param_public_write: Option<bool>,
        param_public_delete: Option<bool>,
        param_public_add: Option<bool>,
        param_latitude: Option<f64>,
        param_longitude: Option<f64>,
        param_location_description: Option<String>,
        param_visibility: Option<models::AddAlbumCollectionVisibilityParameter>,
        param_cell_phone: Option<String>,
        param_street_address: Option<String>,
        param_street_address2: Option<String>,
        param_city: Option<String>,
        param_state: Option<String>,
        param_postal_code: Option<String>,
        param_full_address: Option<String>,
        param_anonymous: Option<bool>,
        param_meta_data: Option<String>,
        param_category_ids: Option<String>,
        param_category_filter_ids: Option<String>,
        param_audience_ids: Option<String>,
        param_audience_ids_to_add: Option<String>,
        param_audience_ids_to_remove: Option<String>,
        param_include_all_app_users_as_members: Option<bool>,
        param_include_audiences_as_members: Option<bool>,
        param_audience_operator: Option<String>,
        param_linked_object_type: Option<String>,
        param_linked_object_id: Option<i64>,
        param_index_now: Option<bool>,
        context: &C) -> Result<UpdateAlbumCollectionResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/album/update",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
                query_string.append_pair("albumId",
                    &param_album_id.to_string());
            if let Some(param_assets_to_add) = param_assets_to_add {
                query_string.append_pair("assetsToAdd",
                    &param_assets_to_add);
            }
            if let Some(param_assets_to_remove) = param_assets_to_remove {
                query_string.append_pair("assetsToRemove",
                    &param_assets_to_remove);
            }
            if let Some(param_asset_id) = param_asset_id {
                query_string.append_pair("assetId",
                    &param_asset_id.to_string());
            }
            if let Some(param_media) = param_media {
                query_string.append_pair("media",
                    &param_media.to_string());
            }
            if let Some(param_media_url) = param_media_url {
                query_string.append_pair("mediaURL",
                    &param_media_url);
            }
            if let Some(param_active) = param_active {
                query_string.append_pair("active",
                    &param_active.to_string());
            }
            if let Some(param_title) = param_title {
                query_string.append_pair("title",
                    &param_title);
            }
            if let Some(param_start_date) = param_start_date {
                query_string.append_pair("startDate",
                    &param_start_date.to_string());
            }
            if let Some(param_end_date) = param_end_date {
                query_string.append_pair("endDate",
                    &param_end_date.to_string());
            }
            if let Some(param_tags) = param_tags {
                query_string.append_pair("tags",
                    &param_tags);
            }
            if let Some(param_description) = param_description {
                query_string.append_pair("description",
                    &param_description);
            }
            if let Some(param_album_type) = param_album_type {
                query_string.append_pair("albumType",
                    &param_album_type);
            }
            if let Some(param_album_type_id) = param_album_type_id {
                query_string.append_pair("albumTypeId",
                    &param_album_type_id.to_string());
            }
            if let Some(param_sub_type) = param_sub_type {
                query_string.append_pair("subType",
                    &param_sub_type);
            }
            if let Some(param_public_read) = param_public_read {
                query_string.append_pair("publicRead",
                    &param_public_read.to_string());
            }
            if let Some(param_public_write) = param_public_write {
                query_string.append_pair("publicWrite",
                    &param_public_write.to_string());
            }
            if let Some(param_public_delete) = param_public_delete {
                query_string.append_pair("publicDelete",
                    &param_public_delete.to_string());
            }
            if let Some(param_public_add) = param_public_add {
                query_string.append_pair("publicAdd",
                    &param_public_add.to_string());
            }
            if let Some(param_latitude) = param_latitude {
                query_string.append_pair("latitude",
                    &param_latitude.to_string());
            }
            if let Some(param_longitude) = param_longitude {
                query_string.append_pair("longitude",
                    &param_longitude.to_string());
            }
            if let Some(param_location_description) = param_location_description {
                query_string.append_pair("locationDescription",
                    &param_location_description);
            }
            if let Some(param_visibility) = param_visibility {
                query_string.append_pair("visibility",
                    &param_visibility.to_string());
            }
            if let Some(param_cell_phone) = param_cell_phone {
                query_string.append_pair("cellPhone",
                    &param_cell_phone);
            }
            if let Some(param_street_address) = param_street_address {
                query_string.append_pair("streetAddress",
                    &param_street_address);
            }
            if let Some(param_street_address2) = param_street_address2 {
                query_string.append_pair("streetAddress2",
                    &param_street_address2);
            }
            if let Some(param_city) = param_city {
                query_string.append_pair("city",
                    &param_city);
            }
            if let Some(param_state) = param_state {
                query_string.append_pair("state",
                    &param_state);
            }
            if let Some(param_postal_code) = param_postal_code {
                query_string.append_pair("postalCode",
                    &param_postal_code);
            }
            if let Some(param_full_address) = param_full_address {
                query_string.append_pair("fullAddress",
                    &param_full_address);
            }
            if let Some(param_anonymous) = param_anonymous {
                query_string.append_pair("anonymous",
                    &param_anonymous.to_string());
            }
            if let Some(param_meta_data) = param_meta_data {
                query_string.append_pair("metaData",
                    &param_meta_data);
            }
            if let Some(param_category_ids) = param_category_ids {
                query_string.append_pair("categoryIds",
                    &param_category_ids);
            }
            if let Some(param_category_filter_ids) = param_category_filter_ids {
                query_string.append_pair("categoryFilterIds",
                    &param_category_filter_ids);
            }
            if let Some(param_audience_ids) = param_audience_ids {
                query_string.append_pair("audienceIds",
                    &param_audience_ids);
            }
            if let Some(param_audience_ids_to_add) = param_audience_ids_to_add {
                query_string.append_pair("audienceIdsToAdd",
                    &param_audience_ids_to_add);
            }
            if let Some(param_audience_ids_to_remove) = param_audience_ids_to_remove {
                query_string.append_pair("audienceIdsToRemove",
                    &param_audience_ids_to_remove);
            }
            if let Some(param_include_all_app_users_as_members) = param_include_all_app_users_as_members {
                query_string.append_pair("includeAllAppUsersAsMembers",
                    &param_include_all_app_users_as_members.to_string());
            }
            if let Some(param_include_audiences_as_members) = param_include_audiences_as_members {
                query_string.append_pair("includeAudiencesAsMembers",
                    &param_include_audiences_as_members.to_string());
            }
            if let Some(param_audience_operator) = param_audience_operator {
                query_string.append_pair("audienceOperator",
                    &param_audience_operator);
            }
            if let Some(param_linked_object_type) = param_linked_object_type {
                query_string.append_pair("linkedObjectType",
                    &param_linked_object_type);
            }
            if let Some(param_linked_object_id) = param_linked_object_id {
                query_string.append_pair("linkedObjectId",
                    &param_linked_object_id.to_string());
            }
            if let Some(param_index_now) = param_index_now {
                query_string.append_pair("indexNow",
                    &param_index_now.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::AlbumResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(UpdateAlbumCollectionResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn activities(
        &self,
        param_version: f64,
        param_start: i32,
        param_limit: i32,
        param_account_id: i64,
        context: &C) -> Result<ActivitiesResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/analytics/useractivity",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("start",
                    &param_start.to_string());
                query_string.append_pair("limit",
                    &param_limit.to_string());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<Vec<models::UserActivityResponse>>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(ActivitiesResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn aggregated_filtered_usage(
        &self,
        param_version: f64,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_application_id: Option<i64>,
        param_app_key: Option<String>,
        param_start_date: Option<i64>,
        param_end_date: Option<i64>,
        param_device_type: Option<String>,
        param_device: Option<String>,
        param_device_os: Option<String>,
        param_gender: Option<String>,
        param_age_group: Option<String>,
        param_country: Option<String>,
        param_state: Option<String>,
        param_city: Option<String>,
        param_zip: Option<String>,
        param_model: Option<String>,
        param_tag: Option<String>,
        param_user_account_id: Option<i64>,
        param_user_account_display: Option<String>,
        param_user_account_username: Option<String>,
        param_group_by_root: Option<models::AggregatedFilteredUsageGroupByRootParameter>,
        param_group_by: Option<models::AggregatedFilteredUsageGroupByRootParameter>,
        param_distinct_count: Option<models::AggregatedFilteredUsageGroupByRootParameter>,
        param_sort_field: Option<models::AggregatedFilteredUsageGroupByRootParameter>,
        param_descending: Option<bool>,
        param_hide_unknown: Option<bool>,
        param_response_format: Option<models::AggregatedFilteredUsageResponseFormatParameter>,
        param__l: Option<i32>,
        param_limit: Option<i32>,
        param_latitude: Option<f64>,
        param_longitude: Option<f64>,
        context: &C) -> Result<AggregatedFilteredUsageResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/analytics/aggregatedFilteredUsage",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_application_id) = param_application_id {
                query_string.append_pair("applicationId",
                    &param_application_id.to_string());
            }
            if let Some(param_app_key) = param_app_key {
                query_string.append_pair("appKey",
                    &param_app_key);
            }
            if let Some(param_start_date) = param_start_date {
                query_string.append_pair("startDate",
                    &param_start_date.to_string());
            }
            if let Some(param_end_date) = param_end_date {
                query_string.append_pair("endDate",
                    &param_end_date.to_string());
            }
            if let Some(param_device_type) = param_device_type {
                query_string.append_pair("deviceType",
                    &param_device_type);
            }
            if let Some(param_device) = param_device {
                query_string.append_pair("device",
                    &param_device);
            }
            if let Some(param_device_os) = param_device_os {
                query_string.append_pair("deviceOS",
                    &param_device_os);
            }
            if let Some(param_gender) = param_gender {
                query_string.append_pair("gender",
                    &param_gender);
            }
            if let Some(param_age_group) = param_age_group {
                query_string.append_pair("ageGroup",
                    &param_age_group);
            }
            if let Some(param_country) = param_country {
                query_string.append_pair("country",
                    &param_country);
            }
            if let Some(param_state) = param_state {
                query_string.append_pair("state",
                    &param_state);
            }
            if let Some(param_city) = param_city {
                query_string.append_pair("city",
                    &param_city);
            }
            if let Some(param_zip) = param_zip {
                query_string.append_pair("zip",
                    &param_zip);
            }
            if let Some(param_model) = param_model {
                query_string.append_pair("model",
                    &param_model);
            }
            if let Some(param_tag) = param_tag {
                query_string.append_pair("tag",
                    &param_tag);
            }
            if let Some(param_user_account_id) = param_user_account_id {
                query_string.append_pair("userAccountId",
                    &param_user_account_id.to_string());
            }
            if let Some(param_user_account_display) = param_user_account_display {
                query_string.append_pair("userAccountDisplay",
                    &param_user_account_display);
            }
            if let Some(param_user_account_username) = param_user_account_username {
                query_string.append_pair("userAccountUsername",
                    &param_user_account_username);
            }
            if let Some(param_group_by_root) = param_group_by_root {
                query_string.append_pair("groupByRoot",
                    &param_group_by_root.to_string());
            }
            if let Some(param_group_by) = param_group_by {
                query_string.append_pair("groupBy",
                    &param_group_by.to_string());
            }
            if let Some(param_distinct_count) = param_distinct_count {
                query_string.append_pair("distinctCount",
                    &param_distinct_count.to_string());
            }
            if let Some(param_sort_field) = param_sort_field {
                query_string.append_pair("sortField",
                    &param_sort_field.to_string());
            }
            if let Some(param_descending) = param_descending {
                query_string.append_pair("descending",
                    &param_descending.to_string());
            }
            if let Some(param_hide_unknown) = param_hide_unknown {
                query_string.append_pair("hideUnknown",
                    &param_hide_unknown.to_string());
            }
            if let Some(param_response_format) = param_response_format {
                query_string.append_pair("responseFormat",
                    &param_response_format.to_string());
            }
            if let Some(param__l) = param__l {
                query_string.append_pair("_l",
                    &param__l.to_string());
            }
            if let Some(param_limit) = param_limit {
                query_string.append_pair("limit",
                    &param_limit.to_string());
            }
            if let Some(param_latitude) = param_latitude {
                query_string.append_pair("latitude",
                    &param_latitude.to_string());
            }
            if let Some(param_longitude) = param_longitude {
                query_string.append_pair("longitude",
                    &param_longitude.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::ChartData>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(AggregatedFilteredUsageResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn filtered_usage(
        &self,
        param_version: f64,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_application_id: Option<i64>,
        param_app_key: Option<String>,
        param_start_date: Option<i64>,
        param_end_date: Option<i64>,
        param_device_type: Option<String>,
        param_device: Option<String>,
        param_device_os: Option<String>,
        param_gender: Option<String>,
        param_age_group: Option<String>,
        param_country: Option<String>,
        param_state: Option<String>,
        param_city: Option<String>,
        param_zip: Option<String>,
        param_model: Option<String>,
        param_tag: Option<String>,
        param_user_account_id: Option<i64>,
        param_user_account_display: Option<String>,
        param_user_account_username: Option<String>,
        param_custom_id: Option<i64>,
        param_custom_type: Option<String>,
        param_custom_value: Option<f64>,
        param_custom_value2: Option<f64>,
        param_custom_long: Option<i64>,
        param_custom_long2: Option<i64>,
        param_custom_message: Option<String>,
        param_custom_message2: Option<String>,
        param_group_by: Option<models::AggregatedFilteredUsageGroupByRootParameter>,
        param_distinct_count: Option<models::AggregatedFilteredUsageGroupByRootParameter>,
        param_sum_column: Option<models::AggregatedFilteredUsageGroupByRootParameter>,
        param_sort_field: Option<models::AggregatedFilteredUsageGroupByRootParameter>,
        param_descending: Option<bool>,
        param_hide_unknown: Option<bool>,
        param_response_format: Option<models::AggregatedFilteredUsageResponseFormatParameter>,
        param__l: Option<i32>,
        param_limit: Option<i32>,
        param_latitude: Option<f64>,
        param_longitude: Option<f64>,
        context: &C) -> Result<FilteredUsageResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/analytics/filteredUsage",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_application_id) = param_application_id {
                query_string.append_pair("applicationId",
                    &param_application_id.to_string());
            }
            if let Some(param_app_key) = param_app_key {
                query_string.append_pair("appKey",
                    &param_app_key);
            }
            if let Some(param_start_date) = param_start_date {
                query_string.append_pair("startDate",
                    &param_start_date.to_string());
            }
            if let Some(param_end_date) = param_end_date {
                query_string.append_pair("endDate",
                    &param_end_date.to_string());
            }
            if let Some(param_device_type) = param_device_type {
                query_string.append_pair("deviceType",
                    &param_device_type);
            }
            if let Some(param_device) = param_device {
                query_string.append_pair("device",
                    &param_device);
            }
            if let Some(param_device_os) = param_device_os {
                query_string.append_pair("deviceOS",
                    &param_device_os);
            }
            if let Some(param_gender) = param_gender {
                query_string.append_pair("gender",
                    &param_gender);
            }
            if let Some(param_age_group) = param_age_group {
                query_string.append_pair("ageGroup",
                    &param_age_group);
            }
            if let Some(param_country) = param_country {
                query_string.append_pair("country",
                    &param_country);
            }
            if let Some(param_state) = param_state {
                query_string.append_pair("state",
                    &param_state);
            }
            if let Some(param_city) = param_city {
                query_string.append_pair("city",
                    &param_city);
            }
            if let Some(param_zip) = param_zip {
                query_string.append_pair("zip",
                    &param_zip);
            }
            if let Some(param_model) = param_model {
                query_string.append_pair("model",
                    &param_model);
            }
            if let Some(param_tag) = param_tag {
                query_string.append_pair("tag",
                    &param_tag);
            }
            if let Some(param_user_account_id) = param_user_account_id {
                query_string.append_pair("userAccountId",
                    &param_user_account_id.to_string());
            }
            if let Some(param_user_account_display) = param_user_account_display {
                query_string.append_pair("userAccountDisplay",
                    &param_user_account_display);
            }
            if let Some(param_user_account_username) = param_user_account_username {
                query_string.append_pair("userAccountUsername",
                    &param_user_account_username);
            }
            if let Some(param_custom_id) = param_custom_id {
                query_string.append_pair("customId",
                    &param_custom_id.to_string());
            }
            if let Some(param_custom_type) = param_custom_type {
                query_string.append_pair("customType",
                    &param_custom_type);
            }
            if let Some(param_custom_value) = param_custom_value {
                query_string.append_pair("customValue",
                    &param_custom_value.to_string());
            }
            if let Some(param_custom_value2) = param_custom_value2 {
                query_string.append_pair("customValue2",
                    &param_custom_value2.to_string());
            }
            if let Some(param_custom_long) = param_custom_long {
                query_string.append_pair("customLong",
                    &param_custom_long.to_string());
            }
            if let Some(param_custom_long2) = param_custom_long2 {
                query_string.append_pair("customLong2",
                    &param_custom_long2.to_string());
            }
            if let Some(param_custom_message) = param_custom_message {
                query_string.append_pair("customMessage",
                    &param_custom_message);
            }
            if let Some(param_custom_message2) = param_custom_message2 {
                query_string.append_pair("customMessage2",
                    &param_custom_message2);
            }
            if let Some(param_group_by) = param_group_by {
                query_string.append_pair("groupBy",
                    &param_group_by.to_string());
            }
            if let Some(param_distinct_count) = param_distinct_count {
                query_string.append_pair("distinctCount",
                    &param_distinct_count.to_string());
            }
            if let Some(param_sum_column) = param_sum_column {
                query_string.append_pair("sumColumn",
                    &param_sum_column.to_string());
            }
            if let Some(param_sort_field) = param_sort_field {
                query_string.append_pair("sortField",
                    &param_sort_field.to_string());
            }
            if let Some(param_descending) = param_descending {
                query_string.append_pair("descending",
                    &param_descending.to_string());
            }
            if let Some(param_hide_unknown) = param_hide_unknown {
                query_string.append_pair("hideUnknown",
                    &param_hide_unknown.to_string());
            }
            if let Some(param_response_format) = param_response_format {
                query_string.append_pair("responseFormat",
                    &param_response_format.to_string());
            }
            if let Some(param__l) = param__l {
                query_string.append_pair("_l",
                    &param__l.to_string());
            }
            if let Some(param_limit) = param_limit {
                query_string.append_pair("limit",
                    &param_limit.to_string());
            }
            if let Some(param_latitude) = param_latitude {
                query_string.append_pair("latitude",
                    &param_latitude.to_string());
            }
            if let Some(param_longitude) = param_longitude {
                query_string.append_pair("longitude",
                    &param_longitude.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::ChartData>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(FilteredUsageResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn usage(
        &self,
        param_version: f64,
        param_tag: String,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_application_id: Option<i64>,
        param_app_key: Option<String>,
        param_app_version: Option<String>,
        param_device: Option<String>,
        param_device_type: Option<String>,
        param_device_os: Option<String>,
        param_model: Option<String>,
        param_latitude: Option<f64>,
        param_longitude: Option<f64>,
        param_custom_id: Option<i64>,
        param_custom_type: Option<String>,
        param_achievement_increment: Option<i64>,
        param_city: Option<String>,
        param_state: Option<String>,
        param_country: Option<String>,
        param_zip: Option<String>,
        param_location_description: Option<String>,
        param_client_time: Option<i64>,
        param_error_message: Option<String>,
        param_ip: Option<String>,
        param_user_agent: Option<String>,
        param_background_event: Option<bool>,
        param_custom_message: Option<String>,
        param_custom_message2: Option<String>,
        param_custom_value: Option<f64>,
        param_custom_value2: Option<f64>,
        param_custom_long: Option<i64>,
        param_custom_long2: Option<i64>,
        context: &C) -> Result<UsageResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/analytics/usage",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("tag",
                    &param_tag);
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_application_id) = param_application_id {
                query_string.append_pair("applicationId",
                    &param_application_id.to_string());
            }
            if let Some(param_app_key) = param_app_key {
                query_string.append_pair("appKey",
                    &param_app_key);
            }
            if let Some(param_app_version) = param_app_version {
                query_string.append_pair("appVersion",
                    &param_app_version);
            }
            if let Some(param_device) = param_device {
                query_string.append_pair("device",
                    &param_device);
            }
            if let Some(param_device_type) = param_device_type {
                query_string.append_pair("deviceType",
                    &param_device_type);
            }
            if let Some(param_device_os) = param_device_os {
                query_string.append_pair("deviceOS",
                    &param_device_os);
            }
            if let Some(param_model) = param_model {
                query_string.append_pair("model",
                    &param_model);
            }
            if let Some(param_latitude) = param_latitude {
                query_string.append_pair("latitude",
                    &param_latitude.to_string());
            }
            if let Some(param_longitude) = param_longitude {
                query_string.append_pair("longitude",
                    &param_longitude.to_string());
            }
            if let Some(param_custom_id) = param_custom_id {
                query_string.append_pair("customId",
                    &param_custom_id.to_string());
            }
            if let Some(param_custom_type) = param_custom_type {
                query_string.append_pair("customType",
                    &param_custom_type);
            }
            if let Some(param_achievement_increment) = param_achievement_increment {
                query_string.append_pair("achievementIncrement",
                    &param_achievement_increment.to_string());
            }
            if let Some(param_city) = param_city {
                query_string.append_pair("city",
                    &param_city);
            }
            if let Some(param_state) = param_state {
                query_string.append_pair("state",
                    &param_state);
            }
            if let Some(param_country) = param_country {
                query_string.append_pair("country",
                    &param_country);
            }
            if let Some(param_zip) = param_zip {
                query_string.append_pair("zip",
                    &param_zip);
            }
            if let Some(param_location_description) = param_location_description {
                query_string.append_pair("locationDescription",
                    &param_location_description);
            }
            if let Some(param_client_time) = param_client_time {
                query_string.append_pair("clientTime",
                    &param_client_time.to_string());
            }
            if let Some(param_error_message) = param_error_message {
                query_string.append_pair("errorMessage",
                    &param_error_message);
            }
            if let Some(param_ip) = param_ip {
                query_string.append_pair("ip",
                    &param_ip);
            }
            if let Some(param_user_agent) = param_user_agent {
                query_string.append_pair("userAgent",
                    &param_user_agent);
            }
            if let Some(param_background_event) = param_background_event {
                query_string.append_pair("backgroundEvent",
                    &param_background_event.to_string());
            }
            if let Some(param_custom_message) = param_custom_message {
                query_string.append_pair("customMessage",
                    &param_custom_message);
            }
            if let Some(param_custom_message2) = param_custom_message2 {
                query_string.append_pair("customMessage2",
                    &param_custom_message2);
            }
            if let Some(param_custom_value) = param_custom_value {
                query_string.append_pair("customValue",
                    &param_custom_value.to_string());
            }
            if let Some(param_custom_value2) = param_custom_value2 {
                query_string.append_pair("customValue2",
                    &param_custom_value2.to_string());
            }
            if let Some(param_custom_long) = param_custom_long {
                query_string.append_pair("customLong",
                    &param_custom_long.to_string());
            }
            if let Some(param_custom_long2) = param_custom_long2 {
                query_string.append_pair("customLong2",
                    &param_custom_long2.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(UsageResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn usage_batch(
        &self,
        param_version: f64,
        param_app_key: String,
        param_device: String,
        param_data: String,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_app_version: Option<String>,
        param_device_type: Option<String>,
        param_device_os: Option<String>,
        param_model: Option<String>,
        param_update_ranking: Option<bool>,
        param_return_summary_response: Option<bool>,
        context: &C) -> Result<UsageBatchResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/analytics/usage/batch",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
                query_string.append_pair("appKey",
                    &param_app_key);
            if let Some(param_app_version) = param_app_version {
                query_string.append_pair("appVersion",
                    &param_app_version);
            }
                query_string.append_pair("device",
                    &param_device);
            if let Some(param_device_type) = param_device_type {
                query_string.append_pair("deviceType",
                    &param_device_type);
            }
            if let Some(param_device_os) = param_device_os {
                query_string.append_pair("deviceOS",
                    &param_device_os);
            }
            if let Some(param_model) = param_model {
                query_string.append_pair("model",
                    &param_model);
            }
                query_string.append_pair("data",
                    &param_data);
            if let Some(param_update_ranking) = param_update_ranking {
                query_string.append_pair("updateRanking",
                    &param_update_ranking.to_string());
            }
            if let Some(param_return_summary_response) = param_return_summary_response {
                query_string.append_pair("returnSummaryResponse",
                    &param_return_summary_response.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(UsageBatchResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_app_data(
        &self,
        param_version: f64,
        param_start: i32,
        param_limit: i32,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_game_type: Option<String>,
        param_include_game_data: Option<bool>,
        param_q: Option<String>,
        param_keyword: Option<String>,
        param_sort_field: Option<String>,
        param_descending: Option<bool>,
        param__i: Option<i32>,
        param__l: Option<i32>,
        param_game_object_count: Option<bool>,
        param_filter: Option<String>,
        param_date_created: Option<i64>,
        param_owner_id: Option<i64>,
        param_mission_ids: Option<String>,
        param_game_ids: Option<String>,
        param_pack_ids: Option<String>,
        param_game_level_ids: Option<String>,
        param_app_version: Option<String>,
        param_include_higher_version_packs: Option<bool>,
        param_include_higher_version_levels: Option<bool>,
        param_response_groups: Option<String>,
        param_purchase_type: Option<String>,
        context: &C) -> Result<GetAppDataResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/app/get",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_game_type) = param_game_type {
                query_string.append_pair("gameType",
                    &param_game_type);
            }
            if let Some(param_include_game_data) = param_include_game_data {
                query_string.append_pair("includeGameData",
                    &param_include_game_data.to_string());
            }
            if let Some(param_q) = param_q {
                query_string.append_pair("q",
                    &param_q);
            }
            if let Some(param_keyword) = param_keyword {
                query_string.append_pair("keyword",
                    &param_keyword);
            }
            if let Some(param_sort_field) = param_sort_field {
                query_string.append_pair("sortField",
                    &param_sort_field);
            }
            if let Some(param_descending) = param_descending {
                query_string.append_pair("descending",
                    &param_descending.to_string());
            }
            if let Some(param__i) = param__i {
                query_string.append_pair("_i",
                    &param__i.to_string());
            }
                query_string.append_pair("start",
                    &param_start.to_string());
            if let Some(param__l) = param__l {
                query_string.append_pair("_l",
                    &param__l.to_string());
            }
                query_string.append_pair("limit",
                    &param_limit.to_string());
            if let Some(param_game_object_count) = param_game_object_count {
                query_string.append_pair("gameObjectCount",
                    &param_game_object_count.to_string());
            }
            if let Some(param_filter) = param_filter {
                query_string.append_pair("filter",
                    &param_filter);
            }
            if let Some(param_date_created) = param_date_created {
                query_string.append_pair("dateCreated",
                    &param_date_created.to_string());
            }
            if let Some(param_owner_id) = param_owner_id {
                query_string.append_pair("ownerId",
                    &param_owner_id.to_string());
            }
            if let Some(param_mission_ids) = param_mission_ids {
                query_string.append_pair("missionIds",
                    &param_mission_ids);
            }
            if let Some(param_game_ids) = param_game_ids {
                query_string.append_pair("gameIds",
                    &param_game_ids);
            }
            if let Some(param_pack_ids) = param_pack_ids {
                query_string.append_pair("packIds",
                    &param_pack_ids);
            }
            if let Some(param_game_level_ids) = param_game_level_ids {
                query_string.append_pair("gameLevelIds",
                    &param_game_level_ids);
            }
            if let Some(param_app_version) = param_app_version {
                query_string.append_pair("appVersion",
                    &param_app_version);
            }
            if let Some(param_include_higher_version_packs) = param_include_higher_version_packs {
                query_string.append_pair("includeHigherVersionPacks",
                    &param_include_higher_version_packs.to_string());
            }
            if let Some(param_include_higher_version_levels) = param_include_higher_version_levels {
                query_string.append_pair("includeHigherVersionLevels",
                    &param_include_higher_version_levels.to_string());
            }
            if let Some(param_response_groups) = param_response_groups {
                query_string.append_pair("responseGroups",
                    &param_response_groups);
            }
            if let Some(param_purchase_type) = param_purchase_type {
                query_string.append_pair("purchaseType",
                    &param_purchase_type);
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::AppResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetAppDataResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn post_app_data(
        &self,
        param_version: f64,
        param_game_type: String,
        param_start: i32,
        param_limit: i32,
        param_data: String,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_include_game_data: Option<bool>,
        param_q: Option<String>,
        param_keyword: Option<String>,
        param_sort_field: Option<String>,
        param_descending: Option<bool>,
        param__i: Option<i32>,
        param__l: Option<i32>,
        param_game_object_count: Option<bool>,
        param_filter: Option<String>,
        param_date_created: Option<i64>,
        param_owner_id: Option<i64>,
        param_mission_ids: Option<String>,
        param_game_ids: Option<String>,
        param_pack_ids: Option<String>,
        param_game_level_ids: Option<String>,
        param_app_version: Option<String>,
        param_include_higher_version_packs: Option<bool>,
        param_include_higher_version_levels: Option<bool>,
        param_response_groups: Option<String>,
        param_purchase_type: Option<String>,
        context: &C) -> Result<PostAppDataResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/app/post",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
                query_string.append_pair("gameType",
                    &param_game_type);
            if let Some(param_include_game_data) = param_include_game_data {
                query_string.append_pair("includeGameData",
                    &param_include_game_data.to_string());
            }
            if let Some(param_q) = param_q {
                query_string.append_pair("q",
                    &param_q);
            }
            if let Some(param_keyword) = param_keyword {
                query_string.append_pair("keyword",
                    &param_keyword);
            }
            if let Some(param_sort_field) = param_sort_field {
                query_string.append_pair("sortField",
                    &param_sort_field);
            }
            if let Some(param_descending) = param_descending {
                query_string.append_pair("descending",
                    &param_descending.to_string());
            }
            if let Some(param__i) = param__i {
                query_string.append_pair("_i",
                    &param__i.to_string());
            }
                query_string.append_pair("start",
                    &param_start.to_string());
            if let Some(param__l) = param__l {
                query_string.append_pair("_l",
                    &param__l.to_string());
            }
                query_string.append_pair("limit",
                    &param_limit.to_string());
            if let Some(param_game_object_count) = param_game_object_count {
                query_string.append_pair("gameObjectCount",
                    &param_game_object_count.to_string());
            }
            if let Some(param_filter) = param_filter {
                query_string.append_pair("filter",
                    &param_filter);
            }
            if let Some(param_date_created) = param_date_created {
                query_string.append_pair("dateCreated",
                    &param_date_created.to_string());
            }
            if let Some(param_owner_id) = param_owner_id {
                query_string.append_pair("ownerId",
                    &param_owner_id.to_string());
            }
            if let Some(param_mission_ids) = param_mission_ids {
                query_string.append_pair("missionIds",
                    &param_mission_ids);
            }
            if let Some(param_game_ids) = param_game_ids {
                query_string.append_pair("gameIds",
                    &param_game_ids);
            }
            if let Some(param_pack_ids) = param_pack_ids {
                query_string.append_pair("packIds",
                    &param_pack_ids);
            }
            if let Some(param_game_level_ids) = param_game_level_ids {
                query_string.append_pair("gameLevelIds",
                    &param_game_level_ids);
            }
            if let Some(param_app_version) = param_app_version {
                query_string.append_pair("appVersion",
                    &param_app_version);
            }
            if let Some(param_include_higher_version_packs) = param_include_higher_version_packs {
                query_string.append_pair("includeHigherVersionPacks",
                    &param_include_higher_version_packs.to_string());
            }
            if let Some(param_include_higher_version_levels) = param_include_higher_version_levels {
                query_string.append_pair("includeHigherVersionLevels",
                    &param_include_higher_version_levels.to_string());
            }
            if let Some(param_response_groups) = param_response_groups {
                query_string.append_pair("responseGroups",
                    &param_response_groups);
            }
            if let Some(param_purchase_type) = param_purchase_type {
                query_string.append_pair("purchaseType",
                    &param_purchase_type);
            }
                query_string.append_pair("data",
                    &param_data);
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::AppResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(PostAppDataResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn regen_app_data(
        &self,
        param_version: f64,
        param_account_id: Option<i64>,
        param_app_key: Option<String>,
        param_build_version: Option<String>,
        param_api_version: Option<String>,
        context: &C) -> Result<RegenAppDataResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/app/regen",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_app_key) = param_app_key {
                query_string.append_pair("appKey",
                    &param_app_key);
            }
            if let Some(param_build_version) = param_build_version {
                query_string.append_pair("buildVersion",
                    &param_build_version);
            }
            if let Some(param_api_version) = param_api_version {
                query_string.append_pair("apiVersion",
                    &param_api_version);
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(RegenAppDataResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn create_application(
        &self,
        param_version: f64,
        param_app_name: String,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_about: Option<String>,
        param_bundle_id: Option<String>,
        param_app_icon_asset_id: Option<i64>,
        param_app_logo_asset_id: Option<i64>,
        param_facebook_app_id: Option<String>,
        param_facebook_app_secret: Option<String>,
        param_google_api_key: Option<String>,
        param_update_eula_date: Option<bool>,
        param_eula_version: Option<String>,
        param_landing_page_url: Option<String>,
        param_show_in_activities: Option<bool>,
        param_activity_description: Option<String>,
        param_invite_welcome_text: Option<String>,
        param_invite_page_url: Option<String>,
        param_url_scheme: Option<String>,
        param_platforms: Option<String>,
        param_download_urls: Option<String>,
        param_category_ids: Option<String>,
        param_scoring_type: Option<models::CreateApplicationScoringTypeParameter>,
        param_hint_cost: Option<i32>,
        param_max_score: Option<i32>,
        param_tickets_per_point: Option<f32>,
        param_has_game_data: Option<bool>,
        param_public_notifications: Option<bool>,
        param_use_matching_algorithm: Option<bool>,
        param_global_tickets: Option<bool>,
        param_build_version: Option<f32>,
        param_api_version: Option<f32>,
        param_placement_name: Option<String>,
        param_placement_description: Option<String>,
        param_placement_size: Option<models::CreateApplicationPlacementSizeParameter>,
        param_placement_height: Option<i32>,
        param_placement_width: Option<i32>,
        param_placement_refresh_interval: Option<i32>,
        param_create_object_store: Option<bool>,
        param_public_content_approval: Option<bool>,
        param_production_mode: Option<bool>,
        param_minimum_session_length: Option<i32>,
        param_session_gap_length: Option<i32>,
        param_local_ads_enabled: Option<bool>,
        param_sqoot_api_key: Option<String>,
        param_trilat_processing_type: Option<models::CreateApplicationTrilatProcessingTypeParameter>,
        param_max_sample_size: Option<i32>,
        param_min_rssi: Option<f64>,
        param_modules: Option<String>,
        param_authorized_count: Option<i32>,
        param_authorized_servers: Option<String>,
        param_default_timezone: Option<String>,
        param_smtp_pass: Option<String>,
        param_meta_data: Option<String>,
        param_placement_meta_data: Option<String>,
        param_ips_floor: Option<bool>,
        param_enable_apns_badge: Option<bool>,
        param_include_in_report: Option<bool>,
        param_default_app_filter_id: Option<i64>,
        param_enable_welcome_email: Option<bool>,
        param_apple_app_id: Option<String>,
        param_apple_team_id: Option<String>,
        param_apple_auth_key_id: Option<String>,
        param_apple_auth_key: Option<swagger::ByteArray>,
        param_apple_issuer_id: Option<String>,
        param_app_store_key_id: Option<String>,
        param_app_store_key: Option<swagger::ByteArray>,
        param_google_private_key_file: Option<swagger::ByteArray>,
        param_authorize_net_api_key: Option<String>,
        param_authorize_net_transaction_key: Option<String>,
        param_email_sender: Option<String>,
        param_smtp_user: Option<String>,
        param_smtp_host: Option<String>,
        param_vatom_business_id: Option<String>,
        param_vatom_rest_client_id: Option<String>,
        param_vatom_rest_secret_key: Option<String>,
        param_twilio_account_sid: Option<String>,
        param_twilio_auth_token: Option<String>,
        param_twilio_sender_phone_number: Option<String>,
        param_open_ai_secret_key: Option<String>,
        context: &C) -> Result<CreateApplicationResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/application/create",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
                query_string.append_pair("appName",
                    &param_app_name);
            if let Some(param_about) = param_about {
                query_string.append_pair("about",
                    &param_about);
            }
            if let Some(param_bundle_id) = param_bundle_id {
                query_string.append_pair("bundleId",
                    &param_bundle_id);
            }
            if let Some(param_app_icon_asset_id) = param_app_icon_asset_id {
                query_string.append_pair("appIconAssetId",
                    &param_app_icon_asset_id.to_string());
            }
            if let Some(param_app_logo_asset_id) = param_app_logo_asset_id {
                query_string.append_pair("appLogoAssetId",
                    &param_app_logo_asset_id.to_string());
            }
            if let Some(param_facebook_app_id) = param_facebook_app_id {
                query_string.append_pair("facebookAppId",
                    &param_facebook_app_id);
            }
            if let Some(param_facebook_app_secret) = param_facebook_app_secret {
                query_string.append_pair("facebookAppSecret",
                    &param_facebook_app_secret);
            }
            if let Some(param_google_api_key) = param_google_api_key {
                query_string.append_pair("googleApiKey",
                    &param_google_api_key);
            }
            if let Some(param_update_eula_date) = param_update_eula_date {
                query_string.append_pair("updateEULADate",
                    &param_update_eula_date.to_string());
            }
            if let Some(param_eula_version) = param_eula_version {
                query_string.append_pair("eulaVersion",
                    &param_eula_version);
            }
            if let Some(param_landing_page_url) = param_landing_page_url {
                query_string.append_pair("landingPageUrl",
                    &param_landing_page_url);
            }
            if let Some(param_show_in_activities) = param_show_in_activities {
                query_string.append_pair("showInActivities",
                    &param_show_in_activities.to_string());
            }
            if let Some(param_activity_description) = param_activity_description {
                query_string.append_pair("activityDescription",
                    &param_activity_description);
            }
            if let Some(param_invite_welcome_text) = param_invite_welcome_text {
                query_string.append_pair("inviteWelcomeText",
                    &param_invite_welcome_text);
            }
            if let Some(param_invite_page_url) = param_invite_page_url {
                query_string.append_pair("invitePageUrl",
                    &param_invite_page_url);
            }
            if let Some(param_url_scheme) = param_url_scheme {
                query_string.append_pair("urlScheme",
                    &param_url_scheme);
            }
            if let Some(param_platforms) = param_platforms {
                query_string.append_pair("platforms",
                    &param_platforms);
            }
            if let Some(param_download_urls) = param_download_urls {
                query_string.append_pair("downloadUrls",
                    &param_download_urls);
            }
            if let Some(param_category_ids) = param_category_ids {
                query_string.append_pair("categoryIds",
                    &param_category_ids);
            }
            if let Some(param_scoring_type) = param_scoring_type {
                query_string.append_pair("scoringType",
                    &param_scoring_type.to_string());
            }
            if let Some(param_hint_cost) = param_hint_cost {
                query_string.append_pair("hintCost",
                    &param_hint_cost.to_string());
            }
            if let Some(param_max_score) = param_max_score {
                query_string.append_pair("maxScore",
                    &param_max_score.to_string());
            }
            if let Some(param_tickets_per_point) = param_tickets_per_point {
                query_string.append_pair("ticketsPerPoint",
                    &param_tickets_per_point.to_string());
            }
            if let Some(param_has_game_data) = param_has_game_data {
                query_string.append_pair("hasGameData",
                    &param_has_game_data.to_string());
            }
            if let Some(param_public_notifications) = param_public_notifications {
                query_string.append_pair("publicNotifications",
                    &param_public_notifications.to_string());
            }
            if let Some(param_use_matching_algorithm) = param_use_matching_algorithm {
                query_string.append_pair("useMatchingAlgorithm",
                    &param_use_matching_algorithm.to_string());
            }
            if let Some(param_global_tickets) = param_global_tickets {
                query_string.append_pair("globalTickets",
                    &param_global_tickets.to_string());
            }
            if let Some(param_build_version) = param_build_version {
                query_string.append_pair("buildVersion",
                    &param_build_version.to_string());
            }
            if let Some(param_api_version) = param_api_version {
                query_string.append_pair("apiVersion",
                    &param_api_version.to_string());
            }
            if let Some(param_placement_name) = param_placement_name {
                query_string.append_pair("placementName",
                    &param_placement_name);
            }
            if let Some(param_placement_description) = param_placement_description {
                query_string.append_pair("placementDescription",
                    &param_placement_description);
            }
            if let Some(param_placement_size) = param_placement_size {
                query_string.append_pair("placementSize",
                    &param_placement_size.to_string());
            }
            if let Some(param_placement_height) = param_placement_height {
                query_string.append_pair("placementHeight",
                    &param_placement_height.to_string());
            }
            if let Some(param_placement_width) = param_placement_width {
                query_string.append_pair("placementWidth",
                    &param_placement_width.to_string());
            }
            if let Some(param_placement_refresh_interval) = param_placement_refresh_interval {
                query_string.append_pair("placementRefreshInterval",
                    &param_placement_refresh_interval.to_string());
            }
            if let Some(param_create_object_store) = param_create_object_store {
                query_string.append_pair("createObjectStore",
                    &param_create_object_store.to_string());
            }
            if let Some(param_public_content_approval) = param_public_content_approval {
                query_string.append_pair("publicContentApproval",
                    &param_public_content_approval.to_string());
            }
            if let Some(param_production_mode) = param_production_mode {
                query_string.append_pair("productionMode",
                    &param_production_mode.to_string());
            }
            if let Some(param_minimum_session_length) = param_minimum_session_length {
                query_string.append_pair("minimumSessionLength",
                    &param_minimum_session_length.to_string());
            }
            if let Some(param_session_gap_length) = param_session_gap_length {
                query_string.append_pair("sessionGapLength",
                    &param_session_gap_length.to_string());
            }
            if let Some(param_local_ads_enabled) = param_local_ads_enabled {
                query_string.append_pair("localAdsEnabled",
                    &param_local_ads_enabled.to_string());
            }
            if let Some(param_sqoot_api_key) = param_sqoot_api_key {
                query_string.append_pair("sqootApiKey",
                    &param_sqoot_api_key);
            }
            if let Some(param_trilat_processing_type) = param_trilat_processing_type {
                query_string.append_pair("trilatProcessingType",
                    &param_trilat_processing_type.to_string());
            }
            if let Some(param_max_sample_size) = param_max_sample_size {
                query_string.append_pair("maxSampleSize",
                    &param_max_sample_size.to_string());
            }
            if let Some(param_min_rssi) = param_min_rssi {
                query_string.append_pair("minRSSI",
                    &param_min_rssi.to_string());
            }
            if let Some(param_modules) = param_modules {
                query_string.append_pair("modules",
                    &param_modules);
            }
            if let Some(param_authorized_count) = param_authorized_count {
                query_string.append_pair("authorizedCount",
                    &param_authorized_count.to_string());
            }
            if let Some(param_authorized_servers) = param_authorized_servers {
                query_string.append_pair("authorizedServers",
                    &param_authorized_servers);
            }
            if let Some(param_default_timezone) = param_default_timezone {
                query_string.append_pair("defaultTimezone",
                    &param_default_timezone);
            }
            if let Some(param_smtp_pass) = param_smtp_pass {
                query_string.append_pair("smtpPass",
                    &param_smtp_pass);
            }
            if let Some(param_meta_data) = param_meta_data {
                query_string.append_pair("metaData",
                    &param_meta_data);
            }
            if let Some(param_placement_meta_data) = param_placement_meta_data {
                query_string.append_pair("placementMetaData",
                    &param_placement_meta_data);
            }
            if let Some(param_ips_floor) = param_ips_floor {
                query_string.append_pair("ipsFloor",
                    &param_ips_floor.to_string());
            }
            if let Some(param_enable_apns_badge) = param_enable_apns_badge {
                query_string.append_pair("enableAPNSBadge",
                    &param_enable_apns_badge.to_string());
            }
            if let Some(param_include_in_report) = param_include_in_report {
                query_string.append_pair("includeInReport",
                    &param_include_in_report.to_string());
            }
            if let Some(param_default_app_filter_id) = param_default_app_filter_id {
                query_string.append_pair("defaultAppFilterId",
                    &param_default_app_filter_id.to_string());
            }
            if let Some(param_enable_welcome_email) = param_enable_welcome_email {
                query_string.append_pair("enableWelcomeEmail",
                    &param_enable_welcome_email.to_string());
            }
            if let Some(param_apple_app_id) = param_apple_app_id {
                query_string.append_pair("appleAppId",
                    &param_apple_app_id);
            }
            if let Some(param_apple_team_id) = param_apple_team_id {
                query_string.append_pair("appleTeamId",
                    &param_apple_team_id);
            }
            if let Some(param_apple_auth_key_id) = param_apple_auth_key_id {
                query_string.append_pair("appleAuthKeyId",
                    &param_apple_auth_key_id);
            }
            if let Some(param_apple_auth_key) = param_apple_auth_key {
                query_string.append_pair("appleAuthKey",
                    &param_apple_auth_key.to_string());
            }
            if let Some(param_apple_issuer_id) = param_apple_issuer_id {
                query_string.append_pair("appleIssuerId",
                    &param_apple_issuer_id);
            }
            if let Some(param_app_store_key_id) = param_app_store_key_id {
                query_string.append_pair("appStoreKeyId",
                    &param_app_store_key_id);
            }
            if let Some(param_app_store_key) = param_app_store_key {
                query_string.append_pair("appStoreKey",
                    &param_app_store_key.to_string());
            }
            if let Some(param_google_private_key_file) = param_google_private_key_file {
                query_string.append_pair("googlePrivateKeyFile",
                    &param_google_private_key_file.to_string());
            }
            if let Some(param_authorize_net_api_key) = param_authorize_net_api_key {
                query_string.append_pair("authorizeNetApiKey",
                    &param_authorize_net_api_key);
            }
            if let Some(param_authorize_net_transaction_key) = param_authorize_net_transaction_key {
                query_string.append_pair("authorizeNetTransactionKey",
                    &param_authorize_net_transaction_key);
            }
            if let Some(param_email_sender) = param_email_sender {
                query_string.append_pair("emailSender",
                    &param_email_sender);
            }
            if let Some(param_smtp_user) = param_smtp_user {
                query_string.append_pair("smtpUser",
                    &param_smtp_user);
            }
            if let Some(param_smtp_host) = param_smtp_host {
                query_string.append_pair("smtpHost",
                    &param_smtp_host);
            }
            if let Some(param_vatom_business_id) = param_vatom_business_id {
                query_string.append_pair("vatomBusinessId",
                    &param_vatom_business_id);
            }
            if let Some(param_vatom_rest_client_id) = param_vatom_rest_client_id {
                query_string.append_pair("vatomRestClientId",
                    &param_vatom_rest_client_id);
            }
            if let Some(param_vatom_rest_secret_key) = param_vatom_rest_secret_key {
                query_string.append_pair("vatomRestSecretKey",
                    &param_vatom_rest_secret_key);
            }
            if let Some(param_twilio_account_sid) = param_twilio_account_sid {
                query_string.append_pair("twilioAccountSID",
                    &param_twilio_account_sid);
            }
            if let Some(param_twilio_auth_token) = param_twilio_auth_token {
                query_string.append_pair("twilioAuthToken",
                    &param_twilio_auth_token);
            }
            if let Some(param_twilio_sender_phone_number) = param_twilio_sender_phone_number {
                query_string.append_pair("twilioSenderPhoneNumber",
                    &param_twilio_sender_phone_number);
            }
            if let Some(param_open_ai_secret_key) = param_open_ai_secret_key {
                query_string.append_pair("openAISecretKey",
                    &param_open_ai_secret_key);
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::ApplicationResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(CreateApplicationResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn create_application_placement(
        &self,
        param_version: f64,
        param_app_key: String,
        param_size: models::CreateApplicationPlacementSizeParameter,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_name: Option<String>,
        param_description: Option<String>,
        param_height: Option<i32>,
        param_width: Option<i32>,
        param_refresh_interval: Option<i32>,
        param_default_image_id: Option<i64>,
        param_active: Option<bool>,
        context: &C) -> Result<CreateApplicationPlacementResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/application/placement/create",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
                query_string.append_pair("appKey",
                    &param_app_key);
            if let Some(param_name) = param_name {
                query_string.append_pair("name",
                    &param_name);
            }
            if let Some(param_description) = param_description {
                query_string.append_pair("description",
                    &param_description);
            }
                query_string.append_pair("size",
                    &param_size.to_string());
            if let Some(param_height) = param_height {
                query_string.append_pair("height",
                    &param_height.to_string());
            }
            if let Some(param_width) = param_width {
                query_string.append_pair("width",
                    &param_width.to_string());
            }
            if let Some(param_refresh_interval) = param_refresh_interval {
                query_string.append_pair("refreshInterval",
                    &param_refresh_interval.to_string());
            }
            if let Some(param_default_image_id) = param_default_image_id {
                query_string.append_pair("defaultImageId",
                    &param_default_image_id.to_string());
            }
            if let Some(param_active) = param_active {
                query_string.append_pair("active",
                    &param_active.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::PlacementResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(CreateApplicationPlacementResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn delete_application(
        &self,
        param_version: f64,
        param_account_id: Option<i64>,
        param_app_key: Option<String>,
        context: &C) -> Result<DeleteApplicationResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/application/delete",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_app_key) = param_app_key {
                query_string.append_pair("appKey",
                    &param_app_key);
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(DeleteApplicationResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn delete_application_placement(
        &self,
        param_version: f64,
        param_placement_id: i64,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        context: &C) -> Result<DeleteApplicationPlacementResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/application/placement/delete",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
                query_string.append_pair("placementId",
                    &param_placement_id.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::PlacementResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(DeleteApplicationPlacementResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_application(
        &self,
        param_version: f64,
        param_app_key: Option<String>,
        param_application_id: Option<i64>,
        context: &C) -> Result<GetApplicationResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/application/get",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_app_key) = param_app_key {
                query_string.append_pair("appKey",
                    &param_app_key);
            }
            if let Some(param_application_id) = param_application_id {
                query_string.append_pair("applicationId",
                    &param_application_id.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::ApplicationResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetApplicationResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_application_placement(
        &self,
        param_version: f64,
        param_placement_id: i64,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        context: &C) -> Result<GetApplicationPlacementResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/application/placement/get",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
                query_string.append_pair("placementId",
                    &param_placement_id.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::PlacementResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetApplicationPlacementResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_application_versions(
        &self,
        param_version: f64,
        context: &C) -> Result<GetApplicationVersionsResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/application/versions",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetApplicationVersionsResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_unique_users_by_app(
        &self,
        param_version: f64,
        param_app_key: String,
        param_q: Option<String>,
        param_keyword: Option<String>,
        param_since: Option<i64>,
        param__i: Option<i32>,
        param_start: Option<i32>,
        param__l: Option<i32>,
        param_limit: Option<i32>,
        context: &C) -> Result<GetUniqueUsersByAppResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/application/users",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("appKey",
                    &param_app_key);
            if let Some(param_q) = param_q {
                query_string.append_pair("q",
                    &param_q);
            }
            if let Some(param_keyword) = param_keyword {
                query_string.append_pair("keyword",
                    &param_keyword);
            }
            if let Some(param_since) = param_since {
                query_string.append_pair("since",
                    &param_since.to_string());
            }
            if let Some(param__i) = param__i {
                query_string.append_pair("_i",
                    &param__i.to_string());
            }
            if let Some(param_start) = param_start {
                query_string.append_pair("start",
                    &param_start.to_string());
            }
            if let Some(param__l) = param__l {
                query_string.append_pair("_l",
                    &param__l.to_string());
            }
            if let Some(param_limit) = param_limit {
                query_string.append_pair("limit",
                    &param_limit.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::AccountListResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetUniqueUsersByAppResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn list_applications(
        &self,
        param_version: f64,
        param_account_id: Option<i64>,
        param_q: Option<String>,
        param_keyword: Option<String>,
        param_platforms: Option<String>,
        param_device_ids: Option<String>,
        param_device_versions: Option<String>,
        param_category_ids: Option<String>,
        param_sort_field: Option<models::ListApplicationsSortFieldParameter>,
        param_has_ads: Option<bool>,
        param_public_notifications: Option<bool>,
        param_filter_billable: Option<bool>,
        param_filter_content_admin: Option<bool>,
        param_descending: Option<bool>,
        param__i: Option<i32>,
        param_start: Option<i32>,
        param__l: Option<i32>,
        param_limit: Option<i32>,
        param_application_ids: Option<String>,
        param_has_object_store: Option<bool>,
        param_active_only: Option<bool>,
        context: &C) -> Result<ListApplicationsResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/application/list",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_q) = param_q {
                query_string.append_pair("q",
                    &param_q);
            }
            if let Some(param_keyword) = param_keyword {
                query_string.append_pair("keyword",
                    &param_keyword);
            }
            if let Some(param_platforms) = param_platforms {
                query_string.append_pair("platforms",
                    &param_platforms);
            }
            if let Some(param_device_ids) = param_device_ids {
                query_string.append_pair("deviceIds",
                    &param_device_ids);
            }
            if let Some(param_device_versions) = param_device_versions {
                query_string.append_pair("deviceVersions",
                    &param_device_versions);
            }
            if let Some(param_category_ids) = param_category_ids {
                query_string.append_pair("categoryIds",
                    &param_category_ids);
            }
            if let Some(param_sort_field) = param_sort_field {
                query_string.append_pair("sortField",
                    &param_sort_field.to_string());
            }
            if let Some(param_has_ads) = param_has_ads {
                query_string.append_pair("hasAds",
                    &param_has_ads.to_string());
            }
            if let Some(param_public_notifications) = param_public_notifications {
                query_string.append_pair("publicNotifications",
                    &param_public_notifications.to_string());
            }
            if let Some(param_filter_billable) = param_filter_billable {
                query_string.append_pair("filterBillable",
                    &param_filter_billable.to_string());
            }
            if let Some(param_filter_content_admin) = param_filter_content_admin {
                query_string.append_pair("filterContentAdmin",
                    &param_filter_content_admin.to_string());
            }
            if let Some(param_descending) = param_descending {
                query_string.append_pair("descending",
                    &param_descending.to_string());
            }
            if let Some(param__i) = param__i {
                query_string.append_pair("_i",
                    &param__i.to_string());
            }
            if let Some(param_start) = param_start {
                query_string.append_pair("start",
                    &param_start.to_string());
            }
            if let Some(param__l) = param__l {
                query_string.append_pair("_l",
                    &param__l.to_string());
            }
            if let Some(param_limit) = param_limit {
                query_string.append_pair("limit",
                    &param_limit.to_string());
            }
            if let Some(param_application_ids) = param_application_ids {
                query_string.append_pair("applicationIds",
                    &param_application_ids);
            }
            if let Some(param_has_object_store) = param_has_object_store {
                query_string.append_pair("hasObjectStore",
                    &param_has_object_store.to_string());
            }
            if let Some(param_active_only) = param_active_only {
                query_string.append_pair("activeOnly",
                    &param_active_only.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<Vec<models::ApplicationShortResponse>>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(ListApplicationsResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn search_application_placement(
        &self,
        param_version: f64,
        param_app_key: String,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_start: Option<i32>,
        param_limit: Option<i32>,
        context: &C) -> Result<SearchApplicationPlacementResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/application/placement/search",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
                query_string.append_pair("appKey",
                    &param_app_key);
            if let Some(param_start) = param_start {
                query_string.append_pair("start",
                    &param_start.to_string());
            }
            if let Some(param_limit) = param_limit {
                query_string.append_pair("limit",
                    &param_limit.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<Vec<models::PlacementResponse>>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(SearchApplicationPlacementResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn search_application_settings(
        &self,
        param_version: f64,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_connection_account_id: Option<i64>,
        param_keyword: Option<String>,
        param_sort_field: Option<String>,
        param_descending: Option<bool>,
        param_start: Option<i32>,
        param_limit: Option<i32>,
        context: &C) -> Result<SearchApplicationSettingsResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/application/settings/search",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_connection_account_id) = param_connection_account_id {
                query_string.append_pair("connectionAccountId",
                    &param_connection_account_id.to_string());
            }
            if let Some(param_keyword) = param_keyword {
                query_string.append_pair("keyword",
                    &param_keyword);
            }
            if let Some(param_sort_field) = param_sort_field {
                query_string.append_pair("sortField",
                    &param_sort_field);
            }
            if let Some(param_descending) = param_descending {
                query_string.append_pair("descending",
                    &param_descending.to_string());
            }
            if let Some(param_start) = param_start {
                query_string.append_pair("start",
                    &param_start.to_string());
            }
            if let Some(param_limit) = param_limit {
                query_string.append_pair("limit",
                    &param_limit.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::ApplicationSettingsResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(SearchApplicationSettingsResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn search_applications(
        &self,
        param_version: f64,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_latitude: Option<f64>,
        param_longitude: Option<f64>,
        param_q: Option<String>,
        param_keyword: Option<String>,
        param_q_search_fields: Option<String>,
        param_sort_field: Option<models::SearchApplicationsSortFieldParameter>,
        param_descending: Option<bool>,
        param__i: Option<i32>,
        param_start: Option<i32>,
        param__l: Option<i32>,
        param_limit: Option<i32>,
        param_has_ads: Option<bool>,
        param_public_notifications: Option<bool>,
        param_active_only: Option<bool>,
        context: &C) -> Result<SearchApplicationsResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/application/search",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_latitude) = param_latitude {
                query_string.append_pair("latitude",
                    &param_latitude.to_string());
            }
            if let Some(param_longitude) = param_longitude {
                query_string.append_pair("longitude",
                    &param_longitude.to_string());
            }
            if let Some(param_q) = param_q {
                query_string.append_pair("q",
                    &param_q);
            }
            if let Some(param_keyword) = param_keyword {
                query_string.append_pair("keyword",
                    &param_keyword);
            }
            if let Some(param_q_search_fields) = param_q_search_fields {
                query_string.append_pair("qSearchFields",
                    &param_q_search_fields);
            }
            if let Some(param_sort_field) = param_sort_field {
                query_string.append_pair("sortField",
                    &param_sort_field.to_string());
            }
            if let Some(param_descending) = param_descending {
                query_string.append_pair("descending",
                    &param_descending.to_string());
            }
            if let Some(param__i) = param__i {
                query_string.append_pair("_i",
                    &param__i.to_string());
            }
            if let Some(param_start) = param_start {
                query_string.append_pair("start",
                    &param_start.to_string());
            }
            if let Some(param__l) = param__l {
                query_string.append_pair("_l",
                    &param__l.to_string());
            }
            if let Some(param_limit) = param_limit {
                query_string.append_pair("limit",
                    &param_limit.to_string());
            }
            if let Some(param_has_ads) = param_has_ads {
                query_string.append_pair("hasAds",
                    &param_has_ads.to_string());
            }
            if let Some(param_public_notifications) = param_public_notifications {
                query_string.append_pair("publicNotifications",
                    &param_public_notifications.to_string());
            }
            if let Some(param_active_only) = param_active_only {
                query_string.append_pair("activeOnly",
                    &param_active_only.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<Vec<models::ApplicationResponse>>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(SearchApplicationsResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn update_application(
        &self,
        param_version: f64,
        param_app_key: String,
        param_app_name: String,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_about: Option<String>,
        param_bundle_id: Option<String>,
        param_app_icon_asset_id: Option<i64>,
        param_app_logo_asset_id: Option<i64>,
        param_facebook_app_id: Option<String>,
        param_facebook_app_secret: Option<String>,
        param_google_api_key: Option<String>,
        param_update_eula_date: Option<bool>,
        param_eula_version: Option<String>,
        param_landing_page_url: Option<String>,
        param_show_in_activities: Option<bool>,
        param_activity_description: Option<String>,
        param_invite_welcome_text: Option<String>,
        param_invite_page_url: Option<String>,
        param_url_scheme: Option<String>,
        param_platforms: Option<String>,
        param_download_urls: Option<String>,
        param_category_ids: Option<String>,
        param_scoring_type: Option<models::CreateApplicationScoringTypeParameter>,
        param_hint_cost: Option<i32>,
        param_max_score: Option<i32>,
        param_tickets_per_point: Option<f32>,
        param_has_game_data: Option<bool>,
        param_public_notifications: Option<bool>,
        param_use_matching_algorithm: Option<bool>,
        param_global_tickets: Option<bool>,
        param_build_version: Option<f32>,
        param_api_version: Option<f32>,
        param_placement_name: Option<String>,
        param_placement_description: Option<String>,
        param_placement_size: Option<models::CreateApplicationPlacementSizeParameter>,
        param_placement_height: Option<i32>,
        param_placement_width: Option<i32>,
        param_placement_refresh_interval: Option<i32>,
        param_create_object_store: Option<bool>,
        param_public_content_approval: Option<bool>,
        param_production_mode: Option<bool>,
        param_minimum_session_length: Option<i32>,
        param_session_gap_length: Option<i32>,
        param_local_ads_enabled: Option<bool>,
        param_sqoot_api_key: Option<String>,
        param_trilat_processing_type: Option<models::CreateApplicationTrilatProcessingTypeParameter>,
        param_max_sample_size: Option<i32>,
        param_min_rssi: Option<f64>,
        param_modules: Option<String>,
        param_authorized_count: Option<i32>,
        param_authorized_servers: Option<String>,
        param_default_timezone: Option<String>,
        param_smtp_pass: Option<String>,
        param_meta_data: Option<String>,
        param_placement_meta_data: Option<String>,
        param_ips_floor: Option<bool>,
        param_enable_apns_badge: Option<bool>,
        param_include_in_report: Option<bool>,
        param_default_app_filter_id: Option<i64>,
        param_enable_welcome_email: Option<bool>,
        param_apple_app_id: Option<String>,
        param_apple_team_id: Option<String>,
        param_apple_auth_key_id: Option<String>,
        param_apple_auth_key: Option<swagger::ByteArray>,
        param_apple_issuer_id: Option<String>,
        param_app_store_key_id: Option<String>,
        param_app_store_key: Option<swagger::ByteArray>,
        param_google_private_key_file: Option<swagger::ByteArray>,
        param_authorize_net_api_key: Option<String>,
        param_authorize_net_transaction_key: Option<String>,
        param_email_sender: Option<String>,
        param_smtp_user: Option<String>,
        param_smtp_host: Option<String>,
        param_vatom_business_id: Option<String>,
        param_vatom_rest_client_id: Option<String>,
        param_vatom_rest_secret_key: Option<String>,
        param_twilio_account_sid: Option<String>,
        param_twilio_auth_token: Option<String>,
        param_twilio_sender_phone_number: Option<String>,
        param_open_ai_secret_key: Option<String>,
        context: &C) -> Result<UpdateApplicationResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/application/update",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
                query_string.append_pair("appKey",
                    &param_app_key);
                query_string.append_pair("appName",
                    &param_app_name);
            if let Some(param_about) = param_about {
                query_string.append_pair("about",
                    &param_about);
            }
            if let Some(param_bundle_id) = param_bundle_id {
                query_string.append_pair("bundleId",
                    &param_bundle_id);
            }
            if let Some(param_app_icon_asset_id) = param_app_icon_asset_id {
                query_string.append_pair("appIconAssetId",
                    &param_app_icon_asset_id.to_string());
            }
            if let Some(param_app_logo_asset_id) = param_app_logo_asset_id {
                query_string.append_pair("appLogoAssetId",
                    &param_app_logo_asset_id.to_string());
            }
            if let Some(param_facebook_app_id) = param_facebook_app_id {
                query_string.append_pair("facebookAppId",
                    &param_facebook_app_id);
            }
            if let Some(param_facebook_app_secret) = param_facebook_app_secret {
                query_string.append_pair("facebookAppSecret",
                    &param_facebook_app_secret);
            }
            if let Some(param_google_api_key) = param_google_api_key {
                query_string.append_pair("googleApiKey",
                    &param_google_api_key);
            }
            if let Some(param_update_eula_date) = param_update_eula_date {
                query_string.append_pair("updateEULADate",
                    &param_update_eula_date.to_string());
            }
            if let Some(param_eula_version) = param_eula_version {
                query_string.append_pair("eulaVersion",
                    &param_eula_version);
            }
            if let Some(param_landing_page_url) = param_landing_page_url {
                query_string.append_pair("landingPageUrl",
                    &param_landing_page_url);
            }
            if let Some(param_show_in_activities) = param_show_in_activities {
                query_string.append_pair("showInActivities",
                    &param_show_in_activities.to_string());
            }
            if let Some(param_activity_description) = param_activity_description {
                query_string.append_pair("activityDescription",
                    &param_activity_description);
            }
            if let Some(param_invite_welcome_text) = param_invite_welcome_text {
                query_string.append_pair("inviteWelcomeText",
                    &param_invite_welcome_text);
            }
            if let Some(param_invite_page_url) = param_invite_page_url {
                query_string.append_pair("invitePageUrl",
                    &param_invite_page_url);
            }
            if let Some(param_url_scheme) = param_url_scheme {
                query_string.append_pair("urlScheme",
                    &param_url_scheme);
            }
            if let Some(param_platforms) = param_platforms {
                query_string.append_pair("platforms",
                    &param_platforms);
            }
            if let Some(param_download_urls) = param_download_urls {
                query_string.append_pair("downloadUrls",
                    &param_download_urls);
            }
            if let Some(param_category_ids) = param_category_ids {
                query_string.append_pair("categoryIds",
                    &param_category_ids);
            }
            if let Some(param_scoring_type) = param_scoring_type {
                query_string.append_pair("scoringType",
                    &param_scoring_type.to_string());
            }
            if let Some(param_hint_cost) = param_hint_cost {
                query_string.append_pair("hintCost",
                    &param_hint_cost.to_string());
            }
            if let Some(param_max_score) = param_max_score {
                query_string.append_pair("maxScore",
                    &param_max_score.to_string());
            }
            if let Some(param_tickets_per_point) = param_tickets_per_point {
                query_string.append_pair("ticketsPerPoint",
                    &param_tickets_per_point.to_string());
            }
            if let Some(param_has_game_data) = param_has_game_data {
                query_string.append_pair("hasGameData",
                    &param_has_game_data.to_string());
            }
            if let Some(param_public_notifications) = param_public_notifications {
                query_string.append_pair("publicNotifications",
                    &param_public_notifications.to_string());
            }
            if let Some(param_use_matching_algorithm) = param_use_matching_algorithm {
                query_string.append_pair("useMatchingAlgorithm",
                    &param_use_matching_algorithm.to_string());
            }
            if let Some(param_global_tickets) = param_global_tickets {
                query_string.append_pair("globalTickets",
                    &param_global_tickets.to_string());
            }
            if let Some(param_build_version) = param_build_version {
                query_string.append_pair("buildVersion",
                    &param_build_version.to_string());
            }
            if let Some(param_api_version) = param_api_version {
                query_string.append_pair("apiVersion",
                    &param_api_version.to_string());
            }
            if let Some(param_placement_name) = param_placement_name {
                query_string.append_pair("placementName",
                    &param_placement_name);
            }
            if let Some(param_placement_description) = param_placement_description {
                query_string.append_pair("placementDescription",
                    &param_placement_description);
            }
            if let Some(param_placement_size) = param_placement_size {
                query_string.append_pair("placementSize",
                    &param_placement_size.to_string());
            }
            if let Some(param_placement_height) = param_placement_height {
                query_string.append_pair("placementHeight",
                    &param_placement_height.to_string());
            }
            if let Some(param_placement_width) = param_placement_width {
                query_string.append_pair("placementWidth",
                    &param_placement_width.to_string());
            }
            if let Some(param_placement_refresh_interval) = param_placement_refresh_interval {
                query_string.append_pair("placementRefreshInterval",
                    &param_placement_refresh_interval.to_string());
            }
            if let Some(param_create_object_store) = param_create_object_store {
                query_string.append_pair("createObjectStore",
                    &param_create_object_store.to_string());
            }
            if let Some(param_public_content_approval) = param_public_content_approval {
                query_string.append_pair("publicContentApproval",
                    &param_public_content_approval.to_string());
            }
            if let Some(param_production_mode) = param_production_mode {
                query_string.append_pair("productionMode",
                    &param_production_mode.to_string());
            }
            if let Some(param_minimum_session_length) = param_minimum_session_length {
                query_string.append_pair("minimumSessionLength",
                    &param_minimum_session_length.to_string());
            }
            if let Some(param_session_gap_length) = param_session_gap_length {
                query_string.append_pair("sessionGapLength",
                    &param_session_gap_length.to_string());
            }
            if let Some(param_local_ads_enabled) = param_local_ads_enabled {
                query_string.append_pair("localAdsEnabled",
                    &param_local_ads_enabled.to_string());
            }
            if let Some(param_sqoot_api_key) = param_sqoot_api_key {
                query_string.append_pair("sqootApiKey",
                    &param_sqoot_api_key);
            }
            if let Some(param_trilat_processing_type) = param_trilat_processing_type {
                query_string.append_pair("trilatProcessingType",
                    &param_trilat_processing_type.to_string());
            }
            if let Some(param_max_sample_size) = param_max_sample_size {
                query_string.append_pair("maxSampleSize",
                    &param_max_sample_size.to_string());
            }
            if let Some(param_min_rssi) = param_min_rssi {
                query_string.append_pair("minRSSI",
                    &param_min_rssi.to_string());
            }
            if let Some(param_modules) = param_modules {
                query_string.append_pair("modules",
                    &param_modules);
            }
            if let Some(param_authorized_count) = param_authorized_count {
                query_string.append_pair("authorizedCount",
                    &param_authorized_count.to_string());
            }
            if let Some(param_authorized_servers) = param_authorized_servers {
                query_string.append_pair("authorizedServers",
                    &param_authorized_servers);
            }
            if let Some(param_default_timezone) = param_default_timezone {
                query_string.append_pair("defaultTimezone",
                    &param_default_timezone);
            }
            if let Some(param_smtp_pass) = param_smtp_pass {
                query_string.append_pair("smtpPass",
                    &param_smtp_pass);
            }
            if let Some(param_meta_data) = param_meta_data {
                query_string.append_pair("metaData",
                    &param_meta_data);
            }
            if let Some(param_placement_meta_data) = param_placement_meta_data {
                query_string.append_pair("placementMetaData",
                    &param_placement_meta_data);
            }
            if let Some(param_ips_floor) = param_ips_floor {
                query_string.append_pair("ipsFloor",
                    &param_ips_floor.to_string());
            }
            if let Some(param_enable_apns_badge) = param_enable_apns_badge {
                query_string.append_pair("enableAPNSBadge",
                    &param_enable_apns_badge.to_string());
            }
            if let Some(param_include_in_report) = param_include_in_report {
                query_string.append_pair("includeInReport",
                    &param_include_in_report.to_string());
            }
            if let Some(param_default_app_filter_id) = param_default_app_filter_id {
                query_string.append_pair("defaultAppFilterId",
                    &param_default_app_filter_id.to_string());
            }
            if let Some(param_enable_welcome_email) = param_enable_welcome_email {
                query_string.append_pair("enableWelcomeEmail",
                    &param_enable_welcome_email.to_string());
            }
            if let Some(param_apple_app_id) = param_apple_app_id {
                query_string.append_pair("appleAppId",
                    &param_apple_app_id);
            }
            if let Some(param_apple_team_id) = param_apple_team_id {
                query_string.append_pair("appleTeamId",
                    &param_apple_team_id);
            }
            if let Some(param_apple_auth_key_id) = param_apple_auth_key_id {
                query_string.append_pair("appleAuthKeyId",
                    &param_apple_auth_key_id);
            }
            if let Some(param_apple_auth_key) = param_apple_auth_key {
                query_string.append_pair("appleAuthKey",
                    &param_apple_auth_key.to_string());
            }
            if let Some(param_apple_issuer_id) = param_apple_issuer_id {
                query_string.append_pair("appleIssuerId",
                    &param_apple_issuer_id);
            }
            if let Some(param_app_store_key_id) = param_app_store_key_id {
                query_string.append_pair("appStoreKeyId",
                    &param_app_store_key_id);
            }
            if let Some(param_app_store_key) = param_app_store_key {
                query_string.append_pair("appStoreKey",
                    &param_app_store_key.to_string());
            }
            if let Some(param_google_private_key_file) = param_google_private_key_file {
                query_string.append_pair("googlePrivateKeyFile",
                    &param_google_private_key_file.to_string());
            }
            if let Some(param_authorize_net_api_key) = param_authorize_net_api_key {
                query_string.append_pair("authorizeNetApiKey",
                    &param_authorize_net_api_key);
            }
            if let Some(param_authorize_net_transaction_key) = param_authorize_net_transaction_key {
                query_string.append_pair("authorizeNetTransactionKey",
                    &param_authorize_net_transaction_key);
            }
            if let Some(param_email_sender) = param_email_sender {
                query_string.append_pair("emailSender",
                    &param_email_sender);
            }
            if let Some(param_smtp_user) = param_smtp_user {
                query_string.append_pair("smtpUser",
                    &param_smtp_user);
            }
            if let Some(param_smtp_host) = param_smtp_host {
                query_string.append_pair("smtpHost",
                    &param_smtp_host);
            }
            if let Some(param_vatom_business_id) = param_vatom_business_id {
                query_string.append_pair("vatomBusinessId",
                    &param_vatom_business_id);
            }
            if let Some(param_vatom_rest_client_id) = param_vatom_rest_client_id {
                query_string.append_pair("vatomRestClientId",
                    &param_vatom_rest_client_id);
            }
            if let Some(param_vatom_rest_secret_key) = param_vatom_rest_secret_key {
                query_string.append_pair("vatomRestSecretKey",
                    &param_vatom_rest_secret_key);
            }
            if let Some(param_twilio_account_sid) = param_twilio_account_sid {
                query_string.append_pair("twilioAccountSID",
                    &param_twilio_account_sid);
            }
            if let Some(param_twilio_auth_token) = param_twilio_auth_token {
                query_string.append_pair("twilioAuthToken",
                    &param_twilio_auth_token);
            }
            if let Some(param_twilio_sender_phone_number) = param_twilio_sender_phone_number {
                query_string.append_pair("twilioSenderPhoneNumber",
                    &param_twilio_sender_phone_number);
            }
            if let Some(param_open_ai_secret_key) = param_open_ai_secret_key {
                query_string.append_pair("openAISecretKey",
                    &param_open_ai_secret_key);
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::ApplicationResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(UpdateApplicationResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn update_application_active(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_app_key: String,
        param_active: bool,
        context: &C) -> Result<UpdateApplicationActiveResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/application/active",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("appKey",
                    &param_app_key);
                query_string.append_pair("active",
                    &param_active.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(UpdateApplicationActiveResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn update_application_placement(
        &self,
        param_version: f64,
        param_placement_id: i64,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_name: Option<String>,
        param_description: Option<String>,
        param_size: Option<models::CreateApplicationPlacementSizeParameter>,
        param_height: Option<i32>,
        param_width: Option<i32>,
        param_refresh_interval: Option<i32>,
        param_default_image_id: Option<i64>,
        param_active: Option<bool>,
        context: &C) -> Result<UpdateApplicationPlacementResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/application/placement/update",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
                query_string.append_pair("placementId",
                    &param_placement_id.to_string());
            if let Some(param_name) = param_name {
                query_string.append_pair("name",
                    &param_name);
            }
            if let Some(param_description) = param_description {
                query_string.append_pair("description",
                    &param_description);
            }
            if let Some(param_size) = param_size {
                query_string.append_pair("size",
                    &param_size.to_string());
            }
            if let Some(param_height) = param_height {
                query_string.append_pair("height",
                    &param_height.to_string());
            }
            if let Some(param_width) = param_width {
                query_string.append_pair("width",
                    &param_width.to_string());
            }
            if let Some(param_refresh_interval) = param_refresh_interval {
                query_string.append_pair("refreshInterval",
                    &param_refresh_interval.to_string());
            }
            if let Some(param_default_image_id) = param_default_image_id {
                query_string.append_pair("defaultImageId",
                    &param_default_image_id.to_string());
            }
            if let Some(param_active) = param_active {
                query_string.append_pair("active",
                    &param_active.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::PlacementResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(UpdateApplicationPlacementResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn upload_application_certificate(
        &self,
        param_version: f64,
        param_app_key: String,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_certificate: Option<swagger::ByteArray>,
        context: &C) -> Result<UploadApplicationCertificateResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/application/certificate/create",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
                query_string.append_pair("appKey",
                    &param_app_key);
            if let Some(param_certificate) = param_certificate {
                query_string.append_pair("certificate",
                    &param_certificate.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(UploadApplicationCertificateResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn create_application_config(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_app_key: String,
        param_config_version: String,
        param_asset_id: i64,
        param_retailer_id: Option<i64>,
        param_retailer_location_id: Option<i64>,
        param_udid: Option<String>,
        context: &C) -> Result<CreateApplicationConfigResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/appconfig/create",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("appKey",
                    &param_app_key);
                query_string.append_pair("configVersion",
                    &param_config_version);
                query_string.append_pair("assetId",
                    &param_asset_id.to_string());
            if let Some(param_retailer_id) = param_retailer_id {
                query_string.append_pair("retailerId",
                    &param_retailer_id.to_string());
            }
            if let Some(param_retailer_location_id) = param_retailer_location_id {
                query_string.append_pair("retailerLocationId",
                    &param_retailer_location_id.to_string());
            }
            if let Some(param_udid) = param_udid {
                query_string.append_pair("udid",
                    &param_udid);
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::ApplicationConfigResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(CreateApplicationConfigResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn delete_application_config(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_config_id: i64,
        context: &C) -> Result<DeleteApplicationConfigResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/appconfig/delete",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("configId",
                    &param_config_id.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(DeleteApplicationConfigResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_application_config(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_config_id: i64,
        context: &C) -> Result<GetApplicationConfigResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/appconfig/get",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("configId",
                    &param_config_id.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::ApplicationConfigResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetApplicationConfigResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_application_config_by_config_version(
        &self,
        param_version: f64,
        param_app_key: String,
        param_config_version: String,
        param_retailer_id: Option<i64>,
        param_retailer_location_id: Option<i64>,
        param_udid: Option<String>,
        param_allow_older_versions: Option<bool>,
        context: &C) -> Result<GetApplicationConfigByConfigVersionResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/appconfig/getbyversion",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("appKey",
                    &param_app_key);
                query_string.append_pair("configVersion",
                    &param_config_version);
            if let Some(param_retailer_id) = param_retailer_id {
                query_string.append_pair("retailerId",
                    &param_retailer_id.to_string());
            }
            if let Some(param_retailer_location_id) = param_retailer_location_id {
                query_string.append_pair("retailerLocationId",
                    &param_retailer_location_id.to_string());
            }
            if let Some(param_udid) = param_udid {
                query_string.append_pair("udid",
                    &param_udid);
            }
            if let Some(param_allow_older_versions) = param_allow_older_versions {
                query_string.append_pair("allowOlderVersions",
                    &param_allow_older_versions.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::ApplicationConfigResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetApplicationConfigByConfigVersionResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn search_application_config(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_app_key: Option<String>,
        param_retailer_id: Option<i64>,
        param_retailer_location_id: Option<i64>,
        param_udid: Option<String>,
        param_config_version: Option<String>,
        param_sort_field: Option<String>,
        param_descending: Option<bool>,
        param_start: Option<i32>,
        param_limit: Option<i32>,
        context: &C) -> Result<SearchApplicationConfigResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/appconfig/search",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            if let Some(param_app_key) = param_app_key {
                query_string.append_pair("appKey",
                    &param_app_key);
            }
            if let Some(param_retailer_id) = param_retailer_id {
                query_string.append_pair("retailerId",
                    &param_retailer_id.to_string());
            }
            if let Some(param_retailer_location_id) = param_retailer_location_id {
                query_string.append_pair("retailerLocationId",
                    &param_retailer_location_id.to_string());
            }
            if let Some(param_udid) = param_udid {
                query_string.append_pair("udid",
                    &param_udid);
            }
            if let Some(param_config_version) = param_config_version {
                query_string.append_pair("configVersion",
                    &param_config_version);
            }
            if let Some(param_sort_field) = param_sort_field {
                query_string.append_pair("sortField",
                    &param_sort_field);
            }
            if let Some(param_descending) = param_descending {
                query_string.append_pair("descending",
                    &param_descending.to_string());
            }
            if let Some(param_start) = param_start {
                query_string.append_pair("start",
                    &param_start.to_string());
            }
            if let Some(param_limit) = param_limit {
                query_string.append_pair("limit",
                    &param_limit.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<Vec<models::ApplicationConfigResponse>>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(SearchApplicationConfigResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn update_application_config(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_config_id: i64,
        param_app_key: Option<String>,
        param_config_version: Option<String>,
        param_asset_id: Option<i64>,
        param_retailer_id: Option<i64>,
        param_retailer_location_id: Option<i64>,
        param_udid: Option<String>,
        context: &C) -> Result<UpdateApplicationConfigResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/appconfig/update",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("configId",
                    &param_config_id.to_string());
            if let Some(param_app_key) = param_app_key {
                query_string.append_pair("appKey",
                    &param_app_key);
            }
            if let Some(param_config_version) = param_config_version {
                query_string.append_pair("configVersion",
                    &param_config_version);
            }
            if let Some(param_asset_id) = param_asset_id {
                query_string.append_pair("assetId",
                    &param_asset_id.to_string());
            }
            if let Some(param_retailer_id) = param_retailer_id {
                query_string.append_pair("retailerId",
                    &param_retailer_id.to_string());
            }
            if let Some(param_retailer_location_id) = param_retailer_location_id {
                query_string.append_pair("retailerLocationId",
                    &param_retailer_location_id.to_string());
            }
            if let Some(param_udid) = param_udid {
                query_string.append_pair("udid",
                    &param_udid);
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::ApplicationConfigResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(UpdateApplicationConfigResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn asset_morph(
        &self,
        param_version: f64,
        param_offer_id: i64,
        param_ad_size: models::CreateApplicationPlacementSizeParameter,
        param_creative_id: Option<i64>,
        param_width: Option<i32>,
        param_height: Option<i32>,
        param_background_size: Option<String>,
        param_template: Option<String>,
        context: &C) -> Result<AssetMorphResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/asset/morph",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("offerId",
                    &param_offer_id.to_string());
            if let Some(param_creative_id) = param_creative_id {
                query_string.append_pair("creativeId",
                    &param_creative_id.to_string());
            }
                query_string.append_pair("adSize",
                    &param_ad_size.to_string());
            if let Some(param_width) = param_width {
                query_string.append_pair("width",
                    &param_width.to_string());
            }
            if let Some(param_height) = param_height {
                query_string.append_pair("height",
                    &param_height.to_string());
            }
            if let Some(param_background_size) = param_background_size {
                query_string.append_pair("backgroundSize",
                    &param_background_size);
            }
            if let Some(param_template) = param_template {
                query_string.append_pair("template",
                    &param_template);
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::AssetShortResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(AssetMorphResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn create_asset(
        &self,
        param_version: f64,
        param_return_nulls: Option<bool>,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_album_id: Option<i64>,
        param_collection_id: Option<i64>,
        param_add_to_default_album: Option<String>,
        param_add_to_media_library: Option<bool>,
        param_version_code: Option<i32>,
        param_version_name: Option<String>,
        param_meta_data: Option<String>,
        param_caption: Option<String>,
        param_asset_type: Option<String>,
        param_approval_status: Option<String>,
        param_assigned_account_id: Option<i64>,
        param_media: Option<swagger::ByteArray>,
        param_media_url: Option<String>,
        param_media_string: Option<String>,
        param_media_string_file_name: Option<String>,
        param_media_string_content_type: Option<String>,
        param_media_height: Option<i32>,
        param_media_width: Option<i32>,
        param_attached_media: Option<swagger::ByteArray>,
        param_attached_media_url: Option<String>,
        param_attached_media_string: Option<String>,
        param_attached_media_string_file_name: Option<String>,
        param_attached_media_string_content_type: Option<String>,
        param_attached_media_height: Option<i32>,
        param_attached_media_width: Option<i32>,
        param_location_description: Option<String>,
        param_app: Option<String>,
        param_app_key: Option<String>,
        param_search_tags: Option<String>,
        param_latitude: Option<f64>,
        param_longitude: Option<f64>,
        context: &C) -> Result<CreateAssetResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/asset/create",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_return_nulls) = param_return_nulls {
                query_string.append_pair("returnNulls",
                    &param_return_nulls.to_string());
            }
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_album_id) = param_album_id {
                query_string.append_pair("albumId",
                    &param_album_id.to_string());
            }
            if let Some(param_collection_id) = param_collection_id {
                query_string.append_pair("collectionId",
                    &param_collection_id.to_string());
            }
            if let Some(param_add_to_default_album) = param_add_to_default_album {
                query_string.append_pair("addToDefaultAlbum",
                    &param_add_to_default_album);
            }
            if let Some(param_add_to_media_library) = param_add_to_media_library {
                query_string.append_pair("addToMediaLibrary",
                    &param_add_to_media_library.to_string());
            }
            if let Some(param_version_code) = param_version_code {
                query_string.append_pair("versionCode",
                    &param_version_code.to_string());
            }
            if let Some(param_version_name) = param_version_name {
                query_string.append_pair("versionName",
                    &param_version_name);
            }
            if let Some(param_meta_data) = param_meta_data {
                query_string.append_pair("metaData",
                    &param_meta_data);
            }
            if let Some(param_caption) = param_caption {
                query_string.append_pair("caption",
                    &param_caption);
            }
            if let Some(param_asset_type) = param_asset_type {
                query_string.append_pair("assetType",
                    &param_asset_type);
            }
            if let Some(param_approval_status) = param_approval_status {
                query_string.append_pair("approvalStatus",
                    &param_approval_status);
            }
            if let Some(param_assigned_account_id) = param_assigned_account_id {
                query_string.append_pair("assignedAccountId",
                    &param_assigned_account_id.to_string());
            }
            if let Some(param_media) = param_media {
                query_string.append_pair("media",
                    &param_media.to_string());
            }
            if let Some(param_media_url) = param_media_url {
                query_string.append_pair("mediaUrl",
                    &param_media_url);
            }
            if let Some(param_media_string) = param_media_string {
                query_string.append_pair("mediaString",
                    &param_media_string);
            }
            if let Some(param_media_string_file_name) = param_media_string_file_name {
                query_string.append_pair("mediaStringFileName",
                    &param_media_string_file_name);
            }
            if let Some(param_media_string_content_type) = param_media_string_content_type {
                query_string.append_pair("mediaStringContentType",
                    &param_media_string_content_type);
            }
            if let Some(param_media_height) = param_media_height {
                query_string.append_pair("mediaHeight",
                    &param_media_height.to_string());
            }
            if let Some(param_media_width) = param_media_width {
                query_string.append_pair("mediaWidth",
                    &param_media_width.to_string());
            }
            if let Some(param_attached_media) = param_attached_media {
                query_string.append_pair("attachedMedia",
                    &param_attached_media.to_string());
            }
            if let Some(param_attached_media_url) = param_attached_media_url {
                query_string.append_pair("attachedMediaUrl",
                    &param_attached_media_url);
            }
            if let Some(param_attached_media_string) = param_attached_media_string {
                query_string.append_pair("attachedMediaString",
                    &param_attached_media_string);
            }
            if let Some(param_attached_media_string_file_name) = param_attached_media_string_file_name {
                query_string.append_pair("attachedMediaStringFileName",
                    &param_attached_media_string_file_name);
            }
            if let Some(param_attached_media_string_content_type) = param_attached_media_string_content_type {
                query_string.append_pair("attachedMediaStringContentType",
                    &param_attached_media_string_content_type);
            }
            if let Some(param_attached_media_height) = param_attached_media_height {
                query_string.append_pair("attachedMediaHeight",
                    &param_attached_media_height.to_string());
            }
            if let Some(param_attached_media_width) = param_attached_media_width {
                query_string.append_pair("attachedMediaWidth",
                    &param_attached_media_width.to_string());
            }
            if let Some(param_location_description) = param_location_description {
                query_string.append_pair("locationDescription",
                    &param_location_description);
            }
            if let Some(param_app) = param_app {
                query_string.append_pair("app",
                    &param_app);
            }
            if let Some(param_app_key) = param_app_key {
                query_string.append_pair("appKey",
                    &param_app_key);
            }
            if let Some(param_search_tags) = param_search_tags {
                query_string.append_pair("searchTags",
                    &param_search_tags);
            }
            if let Some(param_latitude) = param_latitude {
                query_string.append_pair("latitude",
                    &param_latitude.to_string());
            }
            if let Some(param_longitude) = param_longitude {
                query_string.append_pair("longitude",
                    &param_longitude.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::AssetResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(CreateAssetResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn delete_asset(
        &self,
        param_version: f64,
        param_asset_id: String,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_latitude: Option<f64>,
        param_longitude: Option<f64>,
        context: &C) -> Result<DeleteAssetResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/asset/delete",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
                query_string.append_pair("assetId",
                    &param_asset_id);
            if let Some(param_latitude) = param_latitude {
                query_string.append_pair("latitude",
                    &param_latitude.to_string());
            }
            if let Some(param_longitude) = param_longitude {
                query_string.append_pair("longitude",
                    &param_longitude.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(DeleteAssetResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_asset(
        &self,
        param_version: f64,
        param_asset_id: i64,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_note_descending: Option<bool>,
        context: &C) -> Result<GetAssetResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/asset/get",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
                query_string.append_pair("assetId",
                    &param_asset_id.to_string());
            if let Some(param_note_descending) = param_note_descending {
                query_string.append_pair("noteDescending",
                    &param_note_descending.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::AssetFullResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetAssetResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn remove_asset(
        &self,
        param_version: f64,
        param_asset_id: String,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_album_id: Option<i64>,
        param_collection_id: Option<i64>,
        param_remove_from_default_albums: Option<bool>,
        param_latitude: Option<f64>,
        param_longitude: Option<f64>,
        context: &C) -> Result<RemoveAssetResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/asset/remove",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_album_id) = param_album_id {
                query_string.append_pair("albumId",
                    &param_album_id.to_string());
            }
            if let Some(param_collection_id) = param_collection_id {
                query_string.append_pair("collectionId",
                    &param_collection_id.to_string());
            }
                query_string.append_pair("assetId",
                    &param_asset_id);
            if let Some(param_remove_from_default_albums) = param_remove_from_default_albums {
                query_string.append_pair("removeFromDefaultAlbums",
                    &param_remove_from_default_albums.to_string());
            }
            if let Some(param_latitude) = param_latitude {
                query_string.append_pair("latitude",
                    &param_latitude.to_string());
            }
            if let Some(param_longitude) = param_longitude {
                query_string.append_pair("longitude",
                    &param_longitude.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(RemoveAssetResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn search_assets(
        &self,
        param_version: f64,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_album_ids: Option<String>,
        param_asset_ids: Option<String>,
        param_app_key: Option<String>,
        param_media_type: Option<String>,
        param_mime_type: Option<String>,
        param_keyword: Option<String>,
        param_version_code: Option<i32>,
        param_version_name: Option<String>,
        param_updated_since: Option<i64>,
        param_updated_before: Option<i64>,
        param_sort_field: Option<String>,
        param_descending: Option<bool>,
        param_search_media_library: Option<bool>,
        param_filter_by_billable: Option<bool>,
        param_active_only: Option<bool>,
        param_return_app: Option<bool>,
        param_start: Option<i32>,
        param_limit: Option<i32>,
        param_search_mode: Option<String>,
        param_asset_type: Option<String>,
        param_approval_status: Option<String>,
        param_assigned_account_id: Option<i64>,
        context: &C) -> Result<SearchAssetsResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/asset/search",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_album_ids) = param_album_ids {
                query_string.append_pair("albumIds",
                    &param_album_ids);
            }
            if let Some(param_asset_ids) = param_asset_ids {
                query_string.append_pair("assetIds",
                    &param_asset_ids);
            }
            if let Some(param_app_key) = param_app_key {
                query_string.append_pair("appKey",
                    &param_app_key);
            }
            if let Some(param_media_type) = param_media_type {
                query_string.append_pair("mediaType",
                    &param_media_type);
            }
            if let Some(param_mime_type) = param_mime_type {
                query_string.append_pair("mimeType",
                    &param_mime_type);
            }
            if let Some(param_keyword) = param_keyword {
                query_string.append_pair("keyword",
                    &param_keyword);
            }
            if let Some(param_version_code) = param_version_code {
                query_string.append_pair("versionCode",
                    &param_version_code.to_string());
            }
            if let Some(param_version_name) = param_version_name {
                query_string.append_pair("versionName",
                    &param_version_name);
            }
            if let Some(param_updated_since) = param_updated_since {
                query_string.append_pair("updatedSince",
                    &param_updated_since.to_string());
            }
            if let Some(param_updated_before) = param_updated_before {
                query_string.append_pair("updatedBefore",
                    &param_updated_before.to_string());
            }
            if let Some(param_sort_field) = param_sort_field {
                query_string.append_pair("sortField",
                    &param_sort_field);
            }
            if let Some(param_descending) = param_descending {
                query_string.append_pair("descending",
                    &param_descending.to_string());
            }
            if let Some(param_search_media_library) = param_search_media_library {
                query_string.append_pair("searchMediaLibrary",
                    &param_search_media_library.to_string());
            }
            if let Some(param_filter_by_billable) = param_filter_by_billable {
                query_string.append_pair("filterByBillable",
                    &param_filter_by_billable.to_string());
            }
            if let Some(param_active_only) = param_active_only {
                query_string.append_pair("activeOnly",
                    &param_active_only.to_string());
            }
            if let Some(param_return_app) = param_return_app {
                query_string.append_pair("returnApp",
                    &param_return_app.to_string());
            }
            if let Some(param_start) = param_start {
                query_string.append_pair("start",
                    &param_start.to_string());
            }
            if let Some(param_limit) = param_limit {
                query_string.append_pair("limit",
                    &param_limit.to_string());
            }
            if let Some(param_search_mode) = param_search_mode {
                query_string.append_pair("searchMode",
                    &param_search_mode);
            }
            if let Some(param_asset_type) = param_asset_type {
                query_string.append_pair("assetType",
                    &param_asset_type);
            }
            if let Some(param_approval_status) = param_approval_status {
                query_string.append_pair("approvalStatus",
                    &param_approval_status);
            }
            if let Some(param_assigned_account_id) = param_assigned_account_id {
                query_string.append_pair("assignedAccountId",
                    &param_assigned_account_id.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<Vec<models::AssetResponse>>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(SearchAssetsResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn update_asset(
        &self,
        param_version: f64,
        param_asset_id: i64,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_album_id: Option<i64>,
        param_attached_asset_id: Option<i64>,
        param_version_code: Option<i32>,
        param_version_name: Option<String>,
        param_meta_data: Option<String>,
        param_caption: Option<String>,
        param_asset_type: Option<String>,
        param_approval_status: Option<String>,
        param_assigned_account_id: Option<i64>,
        param_media: Option<swagger::ByteArray>,
        param_media_url: Option<String>,
        param_media_string: Option<String>,
        param_media_string_file_name: Option<String>,
        param_media_string_content_type: Option<String>,
        param_media_height: Option<i32>,
        param_media_width: Option<i32>,
        param_attached_media: Option<swagger::ByteArray>,
        param_attached_media_url: Option<String>,
        param_attached_media_string: Option<String>,
        param_attached_media_string_file_name: Option<String>,
        param_attached_media_string_content_type: Option<String>,
        param_attached_media_height: Option<i32>,
        param_attached_media_width: Option<i32>,
        param_location_description: Option<String>,
        param_search_tags: Option<String>,
        param_app_key: Option<String>,
        param_latitude: Option<f64>,
        param_longitude: Option<f64>,
        context: &C) -> Result<UpdateAssetResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/asset/update",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
                query_string.append_pair("assetId",
                    &param_asset_id.to_string());
            if let Some(param_album_id) = param_album_id {
                query_string.append_pair("albumId",
                    &param_album_id.to_string());
            }
            if let Some(param_attached_asset_id) = param_attached_asset_id {
                query_string.append_pair("attachedAssetId",
                    &param_attached_asset_id.to_string());
            }
            if let Some(param_version_code) = param_version_code {
                query_string.append_pair("versionCode",
                    &param_version_code.to_string());
            }
            if let Some(param_version_name) = param_version_name {
                query_string.append_pair("versionName",
                    &param_version_name);
            }
            if let Some(param_meta_data) = param_meta_data {
                query_string.append_pair("metaData",
                    &param_meta_data);
            }
            if let Some(param_caption) = param_caption {
                query_string.append_pair("caption",
                    &param_caption);
            }
            if let Some(param_asset_type) = param_asset_type {
                query_string.append_pair("assetType",
                    &param_asset_type);
            }
            if let Some(param_approval_status) = param_approval_status {
                query_string.append_pair("approvalStatus",
                    &param_approval_status);
            }
            if let Some(param_assigned_account_id) = param_assigned_account_id {
                query_string.append_pair("assignedAccountId",
                    &param_assigned_account_id.to_string());
            }
            if let Some(param_media) = param_media {
                query_string.append_pair("media",
                    &param_media.to_string());
            }
            if let Some(param_media_url) = param_media_url {
                query_string.append_pair("mediaUrl",
                    &param_media_url);
            }
            if let Some(param_media_string) = param_media_string {
                query_string.append_pair("mediaString",
                    &param_media_string);
            }
            if let Some(param_media_string_file_name) = param_media_string_file_name {
                query_string.append_pair("mediaStringFileName",
                    &param_media_string_file_name);
            }
            if let Some(param_media_string_content_type) = param_media_string_content_type {
                query_string.append_pair("mediaStringContentType",
                    &param_media_string_content_type);
            }
            if let Some(param_media_height) = param_media_height {
                query_string.append_pair("mediaHeight",
                    &param_media_height.to_string());
            }
            if let Some(param_media_width) = param_media_width {
                query_string.append_pair("mediaWidth",
                    &param_media_width.to_string());
            }
            if let Some(param_attached_media) = param_attached_media {
                query_string.append_pair("attachedMedia",
                    &param_attached_media.to_string());
            }
            if let Some(param_attached_media_url) = param_attached_media_url {
                query_string.append_pair("attachedMediaUrl",
                    &param_attached_media_url);
            }
            if let Some(param_attached_media_string) = param_attached_media_string {
                query_string.append_pair("attachedMediaString",
                    &param_attached_media_string);
            }
            if let Some(param_attached_media_string_file_name) = param_attached_media_string_file_name {
                query_string.append_pair("attachedMediaStringFileName",
                    &param_attached_media_string_file_name);
            }
            if let Some(param_attached_media_string_content_type) = param_attached_media_string_content_type {
                query_string.append_pair("attachedMediaStringContentType",
                    &param_attached_media_string_content_type);
            }
            if let Some(param_attached_media_height) = param_attached_media_height {
                query_string.append_pair("attachedMediaHeight",
                    &param_attached_media_height.to_string());
            }
            if let Some(param_attached_media_width) = param_attached_media_width {
                query_string.append_pair("attachedMediaWidth",
                    &param_attached_media_width.to_string());
            }
            if let Some(param_location_description) = param_location_description {
                query_string.append_pair("locationDescription",
                    &param_location_description);
            }
            if let Some(param_search_tags) = param_search_tags {
                query_string.append_pair("searchTags",
                    &param_search_tags);
            }
            if let Some(param_app_key) = param_app_key {
                query_string.append_pair("appKey",
                    &param_app_key);
            }
            if let Some(param_latitude) = param_latitude {
                query_string.append_pair("latitude",
                    &param_latitude.to_string());
            }
            if let Some(param_longitude) = param_longitude {
                query_string.append_pair("longitude",
                    &param_longitude.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(UpdateAssetResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn asset_download(
        &self,
        param_version: f64,
        param_filename: String,
        context: &C) -> Result<AssetDownloadResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/asset/download/{filename}",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
            ,filename=utf8_percent_encode(&param_filename.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(AssetDownloadResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn assigment_assignee_account_search(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_keyword: Option<String>,
        context: &C) -> Result<AssigmentAssigneeAccountSearchResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/assignment/assignee/search",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            if let Some(param_keyword) = param_keyword {
                query_string.append_pair("keyword",
                    &param_keyword);
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<Vec<models::AccountMiniResponse>>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(AssigmentAssigneeAccountSearchResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn assignment_create(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_name: String,
        param_assignee_account_id: i64,
        param_description: Option<String>,
        param_retailer_location_id: Option<i64>,
        param_tags: Option<String>,
        param_active: Option<bool>,
        context: &C) -> Result<AssignmentCreateResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/assignment/create",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("name",
                    &param_name);
            if let Some(param_description) = param_description {
                query_string.append_pair("description",
                    &param_description);
            }
                query_string.append_pair("assigneeAccountId",
                    &param_assignee_account_id.to_string());
            if let Some(param_retailer_location_id) = param_retailer_location_id {
                query_string.append_pair("retailerLocationId",
                    &param_retailer_location_id.to_string());
            }
            if let Some(param_tags) = param_tags {
                query_string.append_pair("tags",
                    &param_tags);
            }
            if let Some(param_active) = param_active {
                query_string.append_pair("active",
                    &param_active.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::AssignmentResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(AssignmentCreateResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn assignment_delete(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_assignment_id: i64,
        context: &C) -> Result<AssignmentDeleteResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/assignment/delete",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("assignmentId",
                    &param_assignment_id.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(AssignmentDeleteResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn assignment_get(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_assignment_id: i64,
        context: &C) -> Result<AssignmentGetResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/assignment/get",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("assignmentId",
                    &param_assignment_id.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::AssignmentResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(AssignmentGetResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn assignment_search(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_sort_field: models::AssignmentSearchSortFieldParameter,
        param_descending: bool,
        param_active_only: bool,
        param_start: i32,
        param_limit: i32,
        param_creator_account_id: Option<i64>,
        param_assignee_account_ids: Option<String>,
        param_retailer_location_ids: Option<String>,
        param_current_status_type: Option<models::AssignmentSearchCurrentStatusTypeParameter>,
        param_keyword: Option<String>,
        context: &C) -> Result<AssignmentSearchResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/assignment/search",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            if let Some(param_creator_account_id) = param_creator_account_id {
                query_string.append_pair("creatorAccountId",
                    &param_creator_account_id.to_string());
            }
            if let Some(param_assignee_account_ids) = param_assignee_account_ids {
                query_string.append_pair("assigneeAccountIds",
                    &param_assignee_account_ids);
            }
            if let Some(param_retailer_location_ids) = param_retailer_location_ids {
                query_string.append_pair("retailerLocationIds",
                    &param_retailer_location_ids);
            }
            if let Some(param_current_status_type) = param_current_status_type {
                query_string.append_pair("currentStatusType",
                    &param_current_status_type.to_string());
            }
            if let Some(param_keyword) = param_keyword {
                query_string.append_pair("keyword",
                    &param_keyword);
            }
                query_string.append_pair("sortField",
                    &param_sort_field.to_string());
                query_string.append_pair("descending",
                    &param_descending.to_string());
                query_string.append_pair("activeOnly",
                    &param_active_only.to_string());
                query_string.append_pair("start",
                    &param_start.to_string());
                query_string.append_pair("limit",
                    &param_limit.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<Vec<models::AssignmentResponse>>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(AssignmentSearchResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn assignment_status_create(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_assignment_id: i64,
        param_scheduled_notification_id: Option<i64>,
        param_to_do: Option<models::AssignmentStatusCreateToDoParameter>,
        param_connection: Option<models::AssignmentStatusCreateConnectionParameter>,
        param_method: Option<models::AssignmentStatusCreateMethodParameter>,
        param_status: Option<models::AssignmentStatusCreateStatusParameter>,
        param_closure: Option<models::AssignmentStatusCreateClosureParameter>,
        param_message: Option<String>,
        param_follow_up: Option<i64>,
        param_active: Option<bool>,
        context: &C) -> Result<AssignmentStatusCreateResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/assignment/status/create",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("assignmentId",
                    &param_assignment_id.to_string());
            if let Some(param_scheduled_notification_id) = param_scheduled_notification_id {
                query_string.append_pair("scheduledNotificationId",
                    &param_scheduled_notification_id.to_string());
            }
            if let Some(param_to_do) = param_to_do {
                query_string.append_pair("toDo",
                    &param_to_do.to_string());
            }
            if let Some(param_connection) = param_connection {
                query_string.append_pair("connection",
                    &param_connection.to_string());
            }
            if let Some(param_method) = param_method {
                query_string.append_pair("method",
                    &param_method.to_string());
            }
            if let Some(param_status) = param_status {
                query_string.append_pair("status",
                    &param_status.to_string());
            }
            if let Some(param_closure) = param_closure {
                query_string.append_pair("closure",
                    &param_closure.to_string());
            }
            if let Some(param_message) = param_message {
                query_string.append_pair("message",
                    &param_message);
            }
            if let Some(param_follow_up) = param_follow_up {
                query_string.append_pair("followUp",
                    &param_follow_up.to_string());
            }
            if let Some(param_active) = param_active {
                query_string.append_pair("active",
                    &param_active.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::AssignmentStatusResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(AssignmentStatusCreateResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn assignment_status_delete(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_assignment_status_id: i64,
        context: &C) -> Result<AssignmentStatusDeleteResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/assignment/status/delete",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("assignmentStatusId",
                    &param_assignment_status_id.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(AssignmentStatusDeleteResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn assignment_status_get(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_assignment_status_id: i64,
        context: &C) -> Result<AssignmentStatusGetResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/assignment/status/get",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("assignmentStatusId",
                    &param_assignment_status_id.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::AssignmentStatusResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(AssignmentStatusGetResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn assignment_status_search(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_sort_field: models::AssignmentStatusSearchSortFieldParameter,
        param_descending: bool,
        param_active_only: bool,
        param_start: i32,
        param_limit: i32,
        param_assignment_id: Option<i64>,
        param_creator_account_id: Option<i64>,
        param_assignee_account_id: Option<i64>,
        param_retailer_location_id: Option<i64>,
        param_status_type: Option<models::AssignmentStatusCreateStatusParameter>,
        param_keyword: Option<String>,
        context: &C) -> Result<AssignmentStatusSearchResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/assignment/status/search",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            if let Some(param_assignment_id) = param_assignment_id {
                query_string.append_pair("assignmentId",
                    &param_assignment_id.to_string());
            }
            if let Some(param_creator_account_id) = param_creator_account_id {
                query_string.append_pair("creatorAccountId",
                    &param_creator_account_id.to_string());
            }
            if let Some(param_assignee_account_id) = param_assignee_account_id {
                query_string.append_pair("assigneeAccountId",
                    &param_assignee_account_id.to_string());
            }
            if let Some(param_retailer_location_id) = param_retailer_location_id {
                query_string.append_pair("retailerLocationId",
                    &param_retailer_location_id.to_string());
            }
            if let Some(param_status_type) = param_status_type {
                query_string.append_pair("statusType",
                    &param_status_type.to_string());
            }
            if let Some(param_keyword) = param_keyword {
                query_string.append_pair("keyword",
                    &param_keyword);
            }
                query_string.append_pair("sortField",
                    &param_sort_field.to_string());
                query_string.append_pair("descending",
                    &param_descending.to_string());
                query_string.append_pair("activeOnly",
                    &param_active_only.to_string());
                query_string.append_pair("start",
                    &param_start.to_string());
                query_string.append_pair("limit",
                    &param_limit.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<Vec<models::AssignmentStatusResponse>>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(AssignmentStatusSearchResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn assignment_status_update(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_assignment_status_id: i64,
        param_scheduled_notification_id: Option<i64>,
        param_to_do: Option<models::AssignmentStatusCreateToDoParameter>,
        param_connection: Option<models::AssignmentStatusCreateConnectionParameter>,
        param_method: Option<models::AssignmentStatusCreateMethodParameter>,
        param_status: Option<models::AssignmentStatusCreateStatusParameter>,
        param_closure: Option<models::AssignmentStatusCreateClosureParameter>,
        param_message: Option<String>,
        param_follow_up: Option<i64>,
        param_active: Option<bool>,
        context: &C) -> Result<AssignmentStatusUpdateResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/assignment/status/update",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("assignmentStatusId",
                    &param_assignment_status_id.to_string());
            if let Some(param_scheduled_notification_id) = param_scheduled_notification_id {
                query_string.append_pair("scheduledNotificationId",
                    &param_scheduled_notification_id.to_string());
            }
            if let Some(param_to_do) = param_to_do {
                query_string.append_pair("toDo",
                    &param_to_do.to_string());
            }
            if let Some(param_connection) = param_connection {
                query_string.append_pair("connection",
                    &param_connection.to_string());
            }
            if let Some(param_method) = param_method {
                query_string.append_pair("method",
                    &param_method.to_string());
            }
            if let Some(param_status) = param_status {
                query_string.append_pair("status",
                    &param_status.to_string());
            }
            if let Some(param_closure) = param_closure {
                query_string.append_pair("closure",
                    &param_closure.to_string());
            }
            if let Some(param_message) = param_message {
                query_string.append_pair("message",
                    &param_message);
            }
            if let Some(param_follow_up) = param_follow_up {
                query_string.append_pair("followUp",
                    &param_follow_up.to_string());
            }
            if let Some(param_active) = param_active {
                query_string.append_pair("active",
                    &param_active.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::AssignmentStatusResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(AssignmentStatusUpdateResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn assignment_update(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_assignment_id: i64,
        param_name: Option<String>,
        param_description: Option<String>,
        param_assignee_account_id: Option<i64>,
        param_retailer_location_id: Option<i64>,
        param_tags: Option<String>,
        param_active: Option<bool>,
        context: &C) -> Result<AssignmentUpdateResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/assignment/update",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("assignmentId",
                    &param_assignment_id.to_string());
            if let Some(param_name) = param_name {
                query_string.append_pair("name",
                    &param_name);
            }
            if let Some(param_description) = param_description {
                query_string.append_pair("description",
                    &param_description);
            }
            if let Some(param_assignee_account_id) = param_assignee_account_id {
                query_string.append_pair("assigneeAccountId",
                    &param_assignee_account_id.to_string());
            }
            if let Some(param_retailer_location_id) = param_retailer_location_id {
                query_string.append_pair("retailerLocationId",
                    &param_retailer_location_id.to_string());
            }
            if let Some(param_tags) = param_tags {
                query_string.append_pair("tags",
                    &param_tags);
            }
            if let Some(param_active) = param_active {
                query_string.append_pair("active",
                    &param_active.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::AssignmentResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(AssignmentUpdateResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn create_audience(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_name: String,
        param_description: Option<String>,
        param_search_tags: Option<String>,
        param_gender: Option<String>,
        param_age_groups: Option<String>,
        param_category_ids: Option<String>,
        param_application_ids: Option<String>,
        param_game_experience_level: Option<String>,
        param_devices: Option<String>,
        param_device_ids: Option<String>,
        param_device_versions: Option<String>,
        param_locations: Option<String>,
        param_radius: Option<String>,
        param_start_time_offset: Option<i32>,
        param_end_time_offset: Option<i32>,
        param_send_suggestion: Option<bool>,
        param_associate_description: Option<String>,
        param_associate_type: Option<String>,
        param_associate_id: Option<i64>,
        param_grouping_id: Option<String>,
        param_meta_data: Option<String>,
        param_visibility: Option<String>,
        param_audience_type: Option<String>,
        param_use_order: Option<bool>,
        param_cohort_regions_data: Option<String>,
        param_app_key: Option<String>,
        param_trilateration_types: Option<String>,
        param_unique_name: Option<bool>,
        context: &C) -> Result<CreateAudienceResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/audience/create",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("name",
                    &param_name);
            if let Some(param_description) = param_description {
                query_string.append_pair("description",
                    &param_description);
            }
            if let Some(param_search_tags) = param_search_tags {
                query_string.append_pair("searchTags",
                    &param_search_tags);
            }
            if let Some(param_gender) = param_gender {
                query_string.append_pair("gender",
                    &param_gender);
            }
            if let Some(param_age_groups) = param_age_groups {
                query_string.append_pair("ageGroups",
                    &param_age_groups);
            }
            if let Some(param_category_ids) = param_category_ids {
                query_string.append_pair("categoryIds",
                    &param_category_ids);
            }
            if let Some(param_application_ids) = param_application_ids {
                query_string.append_pair("applicationIds",
                    &param_application_ids);
            }
            if let Some(param_game_experience_level) = param_game_experience_level {
                query_string.append_pair("gameExperienceLevel",
                    &param_game_experience_level);
            }
            if let Some(param_devices) = param_devices {
                query_string.append_pair("devices",
                    &param_devices);
            }
            if let Some(param_device_ids) = param_device_ids {
                query_string.append_pair("deviceIds",
                    &param_device_ids);
            }
            if let Some(param_device_versions) = param_device_versions {
                query_string.append_pair("deviceVersions",
                    &param_device_versions);
            }
            if let Some(param_locations) = param_locations {
                query_string.append_pair("locations",
                    &param_locations);
            }
            if let Some(param_radius) = param_radius {
                query_string.append_pair("radius",
                    &param_radius);
            }
            if let Some(param_start_time_offset) = param_start_time_offset {
                query_string.append_pair("startTimeOffset",
                    &param_start_time_offset.to_string());
            }
            if let Some(param_end_time_offset) = param_end_time_offset {
                query_string.append_pair("endTimeOffset",
                    &param_end_time_offset.to_string());
            }
            if let Some(param_send_suggestion) = param_send_suggestion {
                query_string.append_pair("sendSuggestion",
                    &param_send_suggestion.to_string());
            }
            if let Some(param_associate_description) = param_associate_description {
                query_string.append_pair("associateDescription",
                    &param_associate_description);
            }
            if let Some(param_associate_type) = param_associate_type {
                query_string.append_pair("associateType",
                    &param_associate_type);
            }
            if let Some(param_associate_id) = param_associate_id {
                query_string.append_pair("associateId",
                    &param_associate_id.to_string());
            }
            if let Some(param_grouping_id) = param_grouping_id {
                query_string.append_pair("groupingId",
                    &param_grouping_id);
            }
            if let Some(param_meta_data) = param_meta_data {
                query_string.append_pair("metaData",
                    &param_meta_data);
            }
            if let Some(param_visibility) = param_visibility {
                query_string.append_pair("visibility",
                    &param_visibility);
            }
            if let Some(param_audience_type) = param_audience_type {
                query_string.append_pair("audienceType",
                    &param_audience_type);
            }
            if let Some(param_use_order) = param_use_order {
                query_string.append_pair("useOrder",
                    &param_use_order.to_string());
            }
            if let Some(param_cohort_regions_data) = param_cohort_regions_data {
                query_string.append_pair("cohortRegionsData",
                    &param_cohort_regions_data);
            }
            if let Some(param_app_key) = param_app_key {
                query_string.append_pair("appKey",
                    &param_app_key);
            }
            if let Some(param_trilateration_types) = param_trilateration_types {
                query_string.append_pair("trilaterationTypes",
                    &param_trilateration_types);
            }
            if let Some(param_unique_name) = param_unique_name {
                query_string.append_pair("uniqueName",
                    &param_unique_name.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::AudienceResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(CreateAudienceResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn delete_audience(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_audience_id: i64,
        context: &C) -> Result<DeleteAudienceResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/audience/delete",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("audienceId",
                    &param_audience_id.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(DeleteAudienceResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_age_groups(
        &self,
        param_version: f64,
        context: &C) -> Result<GetAgeGroupsResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/audience/ageGroups",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<Vec<models::AgeGroupResponse>>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetAgeGroupsResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_audience(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_audience_id: i64,
        param_app_key: Option<String>,
        param_return_account_count: Option<bool>,
        param_return_album_count: Option<bool>,
        param_album_types_for_count: Option<String>,
        context: &C) -> Result<GetAudienceResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/audience/get",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("audienceId",
                    &param_audience_id.to_string());
            if let Some(param_app_key) = param_app_key {
                query_string.append_pair("appKey",
                    &param_app_key);
            }
            if let Some(param_return_account_count) = param_return_account_count {
                query_string.append_pair("returnAccountCount",
                    &param_return_account_count.to_string());
            }
            if let Some(param_return_album_count) = param_return_album_count {
                query_string.append_pair("returnAlbumCount",
                    &param_return_album_count.to_string());
            }
            if let Some(param_album_types_for_count) = param_album_types_for_count {
                query_string.append_pair("albumTypesForCount",
                    &param_album_types_for_count);
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::AudienceResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetAudienceResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_audience_list(
        &self,
        param_version: f64,
        param_account_id: Option<i64>,
        param_album_ids: Option<String>,
        param_keyword: Option<String>,
        param_keyword_fields: Option<String>,
        param_sort_field: Option<models::GetAudienceListSortFieldParameter>,
        param_descending: Option<bool>,
        param_start: Option<i32>,
        param_limit: Option<i32>,
        param_send_suggestion: Option<bool>,
        param_active_only: Option<bool>,
        param_group_by_grouping_id: Option<bool>,
        param_app_key: Option<String>,
        param_return_global: Option<bool>,
        param_exact_keyword: Option<bool>,
        param_audience_type: Option<String>,
        param_audience_types: Option<String>,
        param_return_account_count: Option<bool>,
        param_return_album_count: Option<bool>,
        param_album_types_for_count: Option<String>,
        context: &C) -> Result<GetAudienceListResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/audience/search",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_album_ids) = param_album_ids {
                query_string.append_pair("albumIds",
                    &param_album_ids);
            }
            if let Some(param_keyword) = param_keyword {
                query_string.append_pair("keyword",
                    &param_keyword);
            }
            if let Some(param_keyword_fields) = param_keyword_fields {
                query_string.append_pair("keywordFields",
                    &param_keyword_fields);
            }
            if let Some(param_sort_field) = param_sort_field {
                query_string.append_pair("sortField",
                    &param_sort_field.to_string());
            }
            if let Some(param_descending) = param_descending {
                query_string.append_pair("descending",
                    &param_descending.to_string());
            }
            if let Some(param_start) = param_start {
                query_string.append_pair("start",
                    &param_start.to_string());
            }
            if let Some(param_limit) = param_limit {
                query_string.append_pair("limit",
                    &param_limit.to_string());
            }
            if let Some(param_send_suggestion) = param_send_suggestion {
                query_string.append_pair("sendSuggestion",
                    &param_send_suggestion.to_string());
            }
            if let Some(param_active_only) = param_active_only {
                query_string.append_pair("activeOnly",
                    &param_active_only.to_string());
            }
            if let Some(param_group_by_grouping_id) = param_group_by_grouping_id {
                query_string.append_pair("groupByGroupingId",
                    &param_group_by_grouping_id.to_string());
            }
            if let Some(param_app_key) = param_app_key {
                query_string.append_pair("appKey",
                    &param_app_key);
            }
            if let Some(param_return_global) = param_return_global {
                query_string.append_pair("returnGlobal",
                    &param_return_global.to_string());
            }
            if let Some(param_exact_keyword) = param_exact_keyword {
                query_string.append_pair("exactKeyword",
                    &param_exact_keyword.to_string());
            }
            if let Some(param_audience_type) = param_audience_type {
                query_string.append_pair("audienceType",
                    &param_audience_type);
            }
            if let Some(param_audience_types) = param_audience_types {
                query_string.append_pair("audienceTypes",
                    &param_audience_types);
            }
            if let Some(param_return_account_count) = param_return_account_count {
                query_string.append_pair("returnAccountCount",
                    &param_return_account_count.to_string());
            }
            if let Some(param_return_album_count) = param_return_album_count {
                query_string.append_pair("returnAlbumCount",
                    &param_return_album_count.to_string());
            }
            if let Some(param_album_types_for_count) = param_album_types_for_count {
                query_string.append_pair("albumTypesForCount",
                    &param_album_types_for_count);
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<Vec<models::SearchResponse>>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetAudienceListResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_devices(
        &self,
        param_version: f64,
        param_include_inactive: bool,
        context: &C) -> Result<GetDevicesResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/audience/devices",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("includeInactive",
                    &param_include_inactive.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<Vec<models::AudienceDeviceResponse>>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetDevicesResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_experiences(
        &self,
        param_version: f64,
        context: &C) -> Result<GetExperiencesResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/audience/experiences",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetExperiencesResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_grouped_audiences(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_audience_grouping_id: String,
        context: &C) -> Result<GetGroupedAudiencesResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/audience/grouped/get",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("audienceGroupingId",
                    &param_audience_grouping_id);
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::AudienceResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetGroupedAudiencesResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn list_by_account(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_limit: i32,
        param_suggestion_type: String,
        context: &C) -> Result<ListByAccountResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/audience/suggestion/list",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("limit",
                    &param_limit.to_string());
                query_string.append_pair("suggestionType",
                    &param_suggestion_type);
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::OfferListResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(ListByAccountResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn list_by_audience(
        &self,
        param_version: f64,
        param_limit: i32,
        param_gender: Option<String>,
        param_age: Option<i32>,
        param_category_ids: Option<String>,
        param_latitude: Option<f64>,
        param_longitude: Option<f64>,
        context: &C) -> Result<ListByAudienceResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/audience/suggestion/offersByAudience",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_gender) = param_gender {
                query_string.append_pair("gender",
                    &param_gender);
            }
            if let Some(param_age) = param_age {
                query_string.append_pair("age",
                    &param_age.to_string());
            }
            if let Some(param_category_ids) = param_category_ids {
                query_string.append_pair("categoryIds",
                    &param_category_ids);
            }
            if let Some(param_latitude) = param_latitude {
                query_string.append_pair("latitude",
                    &param_latitude.to_string());
            }
            if let Some(param_longitude) = param_longitude {
                query_string.append_pair("longitude",
                    &param_longitude.to_string());
            }
                query_string.append_pair("limit",
                    &param_limit.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::OfferListResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(ListByAudienceResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn list_lastest_by_account(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_timeframe: i32,
        param_suggestion_type: String,
        context: &C) -> Result<ListLastestByAccountResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/audience/suggestion/latest",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("timeframe",
                    &param_timeframe.to_string());
                query_string.append_pair("suggestionType",
                    &param_suggestion_type);
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::OfferListResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(ListLastestByAccountResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn send_by_account(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_latitude: f64,
        param_longitude: f64,
        context: &C) -> Result<SendByAccountResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/audience/suggestion/send",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("latitude",
                    &param_latitude.to_string());
                query_string.append_pair("longitude",
                    &param_longitude.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(SendByAccountResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn update_audience(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_audience_id: i64,
        param_name: Option<String>,
        param_description: Option<String>,
        param_search_tags: Option<String>,
        param_gender: Option<String>,
        param_age_groups: Option<String>,
        param_category_ids: Option<String>,
        param_application_ids: Option<String>,
        param_game_experience_level: Option<String>,
        param_devices: Option<String>,
        param_device_ids: Option<String>,
        param_device_versions: Option<String>,
        param_locations: Option<String>,
        param_radius: Option<String>,
        param_active: Option<bool>,
        param_send_suggestion: Option<bool>,
        param_start_time_offset: Option<i32>,
        param_end_time_offset: Option<i32>,
        param_associate_description: Option<String>,
        param_associate_type: Option<String>,
        param_associate_id: Option<i64>,
        param_grouping_id: Option<String>,
        param_meta_data: Option<String>,
        param_visibility: Option<String>,
        param_audience_type: Option<String>,
        param_use_order: Option<bool>,
        param_cohort_regions_data: Option<String>,
        param_app_key: Option<String>,
        param_trilateration_types: Option<String>,
        param_unique_name: Option<bool>,
        context: &C) -> Result<UpdateAudienceResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/audience/update",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("audienceId",
                    &param_audience_id.to_string());
            if let Some(param_name) = param_name {
                query_string.append_pair("name",
                    &param_name);
            }
            if let Some(param_description) = param_description {
                query_string.append_pair("description",
                    &param_description);
            }
            if let Some(param_search_tags) = param_search_tags {
                query_string.append_pair("searchTags",
                    &param_search_tags);
            }
            if let Some(param_gender) = param_gender {
                query_string.append_pair("gender",
                    &param_gender);
            }
            if let Some(param_age_groups) = param_age_groups {
                query_string.append_pair("ageGroups",
                    &param_age_groups);
            }
            if let Some(param_category_ids) = param_category_ids {
                query_string.append_pair("categoryIds",
                    &param_category_ids);
            }
            if let Some(param_application_ids) = param_application_ids {
                query_string.append_pair("applicationIds",
                    &param_application_ids);
            }
            if let Some(param_game_experience_level) = param_game_experience_level {
                query_string.append_pair("gameExperienceLevel",
                    &param_game_experience_level);
            }
            if let Some(param_devices) = param_devices {
                query_string.append_pair("devices",
                    &param_devices);
            }
            if let Some(param_device_ids) = param_device_ids {
                query_string.append_pair("deviceIds",
                    &param_device_ids);
            }
            if let Some(param_device_versions) = param_device_versions {
                query_string.append_pair("deviceVersions",
                    &param_device_versions);
            }
            if let Some(param_locations) = param_locations {
                query_string.append_pair("locations",
                    &param_locations);
            }
            if let Some(param_radius) = param_radius {
                query_string.append_pair("radius",
                    &param_radius);
            }
            if let Some(param_active) = param_active {
                query_string.append_pair("active",
                    &param_active.to_string());
            }
            if let Some(param_send_suggestion) = param_send_suggestion {
                query_string.append_pair("sendSuggestion",
                    &param_send_suggestion.to_string());
            }
            if let Some(param_start_time_offset) = param_start_time_offset {
                query_string.append_pair("startTimeOffset",
                    &param_start_time_offset.to_string());
            }
            if let Some(param_end_time_offset) = param_end_time_offset {
                query_string.append_pair("endTimeOffset",
                    &param_end_time_offset.to_string());
            }
            if let Some(param_associate_description) = param_associate_description {
                query_string.append_pair("associateDescription",
                    &param_associate_description);
            }
            if let Some(param_associate_type) = param_associate_type {
                query_string.append_pair("associateType",
                    &param_associate_type);
            }
            if let Some(param_associate_id) = param_associate_id {
                query_string.append_pair("associateId",
                    &param_associate_id.to_string());
            }
            if let Some(param_grouping_id) = param_grouping_id {
                query_string.append_pair("groupingId",
                    &param_grouping_id);
            }
            if let Some(param_meta_data) = param_meta_data {
                query_string.append_pair("metaData",
                    &param_meta_data);
            }
            if let Some(param_visibility) = param_visibility {
                query_string.append_pair("visibility",
                    &param_visibility);
            }
            if let Some(param_audience_type) = param_audience_type {
                query_string.append_pair("audienceType",
                    &param_audience_type);
            }
            if let Some(param_use_order) = param_use_order {
                query_string.append_pair("useOrder",
                    &param_use_order.to_string());
            }
            if let Some(param_cohort_regions_data) = param_cohort_regions_data {
                query_string.append_pair("cohortRegionsData",
                    &param_cohort_regions_data);
            }
            if let Some(param_app_key) = param_app_key {
                query_string.append_pair("appKey",
                    &param_app_key);
            }
            if let Some(param_trilateration_types) = param_trilateration_types {
                query_string.append_pair("trilaterationTypes",
                    &param_trilateration_types);
            }
            if let Some(param_unique_name) = param_unique_name {
                query_string.append_pair("uniqueName",
                    &param_unique_name.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::AudienceResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(UpdateAudienceResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn create_bid(
        &self,
        param_version: f64,
        param_biddable_type: String,
        param_biddable_id: i64,
        param_amount_per_view: f64,
        param_amount_per_action: f64,
        param_budget_amount: f64,
        param_budget_schedule: String,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        context: &C) -> Result<CreateBidResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/bid/create",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
                query_string.append_pair("biddableType",
                    &param_biddable_type);
                query_string.append_pair("biddableId",
                    &param_biddable_id.to_string());
                query_string.append_pair("amountPerView",
                    &param_amount_per_view.to_string());
                query_string.append_pair("amountPerAction",
                    &param_amount_per_action.to_string());
                query_string.append_pair("budgetAmount",
                    &param_budget_amount.to_string());
                query_string.append_pair("budgetSchedule",
                    &param_budget_schedule);
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::BidResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(CreateBidResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn delete_bid(
        &self,
        param_version: f64,
        param_bid_id: i64,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        context: &C) -> Result<DeleteBidResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/bid/delete",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
                query_string.append_pair("bidId",
                    &param_bid_id.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(DeleteBidResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_bid(
        &self,
        param_version: f64,
        param_bid_id: i64,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        context: &C) -> Result<GetBidResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/bid/get",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
                query_string.append_pair("bidId",
                    &param_bid_id.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::BidResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetBidResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn update_bid(
        &self,
        param_version: f64,
        param_bid_id: i64,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_amount_per_view: Option<f64>,
        param_amount_per_action: Option<f64>,
        param_budget_amount: Option<f64>,
        param_budget_schedule: Option<String>,
        context: &C) -> Result<UpdateBidResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/bid/update",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
                query_string.append_pair("bidId",
                    &param_bid_id.to_string());
            if let Some(param_amount_per_view) = param_amount_per_view {
                query_string.append_pair("amountPerView",
                    &param_amount_per_view.to_string());
            }
            if let Some(param_amount_per_action) = param_amount_per_action {
                query_string.append_pair("amountPerAction",
                    &param_amount_per_action.to_string());
            }
            if let Some(param_budget_amount) = param_budget_amount {
                query_string.append_pair("budgetAmount",
                    &param_budget_amount.to_string());
            }
            if let Some(param_budget_schedule) = param_budget_schedule {
                query_string.append_pair("budgetSchedule",
                    &param_budget_schedule);
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::BidResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(UpdateBidResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn create_billable_entity(
        &self,
        param_version: f64,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_name: Option<String>,
        param_street_address: Option<String>,
        param_street_address2: Option<String>,
        param_city: Option<String>,
        param_state: Option<String>,
        param_postal_code: Option<String>,
        param_business_phone: Option<String>,
        param_business_phone_ext: Option<String>,
        param_authorize_net_api_key: Option<String>,
        param_authorize_net_transaction_key: Option<String>,
        context: &C) -> Result<CreateBillableEntityResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/billable/create",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_name) = param_name {
                query_string.append_pair("name",
                    &param_name);
            }
            if let Some(param_street_address) = param_street_address {
                query_string.append_pair("streetAddress",
                    &param_street_address);
            }
            if let Some(param_street_address2) = param_street_address2 {
                query_string.append_pair("streetAddress2",
                    &param_street_address2);
            }
            if let Some(param_city) = param_city {
                query_string.append_pair("city",
                    &param_city);
            }
            if let Some(param_state) = param_state {
                query_string.append_pair("state",
                    &param_state);
            }
            if let Some(param_postal_code) = param_postal_code {
                query_string.append_pair("postalCode",
                    &param_postal_code);
            }
            if let Some(param_business_phone) = param_business_phone {
                query_string.append_pair("businessPhone",
                    &param_business_phone);
            }
            if let Some(param_business_phone_ext) = param_business_phone_ext {
                query_string.append_pair("businessPhoneExt",
                    &param_business_phone_ext);
            }
            if let Some(param_authorize_net_api_key) = param_authorize_net_api_key {
                query_string.append_pair("authorizeNetApiKey",
                    &param_authorize_net_api_key);
            }
            if let Some(param_authorize_net_transaction_key) = param_authorize_net_transaction_key {
                query_string.append_pair("authorizeNetTransactionKey",
                    &param_authorize_net_transaction_key);
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::BillableEntityResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(CreateBillableEntityResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn delete_billable_entity(
        &self,
        param_version: f64,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        context: &C) -> Result<DeleteBillableEntityResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/billable/delete",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(DeleteBillableEntityResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_billable_entity(
        &self,
        param_version: f64,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_include_counts: Option<bool>,
        param_include_payments: Option<bool>,
        context: &C) -> Result<GetBillableEntityResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/billable/get",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_include_counts) = param_include_counts {
                query_string.append_pair("includeCounts",
                    &param_include_counts.to_string());
            }
            if let Some(param_include_payments) = param_include_payments {
                query_string.append_pair("includePayments",
                    &param_include_payments.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::BillableEntityResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetBillableEntityResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn update_billable_entity(
        &self,
        param_version: f64,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_name: Option<String>,
        param_street_address: Option<String>,
        param_street_address2: Option<String>,
        param_city: Option<String>,
        param_state: Option<String>,
        param_postal_code: Option<String>,
        param_business_phone: Option<String>,
        param_business_phone_ext: Option<String>,
        param_authorize_net_api_key: Option<String>,
        param_authorize_net_transaction_key: Option<String>,
        context: &C) -> Result<UpdateBillableEntityResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/billable/update",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_name) = param_name {
                query_string.append_pair("name",
                    &param_name);
            }
            if let Some(param_street_address) = param_street_address {
                query_string.append_pair("streetAddress",
                    &param_street_address);
            }
            if let Some(param_street_address2) = param_street_address2 {
                query_string.append_pair("streetAddress2",
                    &param_street_address2);
            }
            if let Some(param_city) = param_city {
                query_string.append_pair("city",
                    &param_city);
            }
            if let Some(param_state) = param_state {
                query_string.append_pair("state",
                    &param_state);
            }
            if let Some(param_postal_code) = param_postal_code {
                query_string.append_pair("postalCode",
                    &param_postal_code);
            }
            if let Some(param_business_phone) = param_business_phone {
                query_string.append_pair("businessPhone",
                    &param_business_phone);
            }
            if let Some(param_business_phone_ext) = param_business_phone_ext {
                query_string.append_pair("businessPhoneExt",
                    &param_business_phone_ext);
            }
            if let Some(param_authorize_net_api_key) = param_authorize_net_api_key {
                query_string.append_pair("authorizeNetApiKey",
                    &param_authorize_net_api_key);
            }
            if let Some(param_authorize_net_transaction_key) = param_authorize_net_transaction_key {
                query_string.append_pair("authorizeNetTransactionKey",
                    &param_authorize_net_transaction_key);
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::BillableEntityResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(UpdateBillableEntityResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn add_payment_method(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_payment_method_id: Option<i64>,
        param_account_name: Option<String>,
        param_first_name: Option<String>,
        param_last_name: Option<String>,
        param_address: Option<String>,
        param_city: Option<String>,
        param_state: Option<String>,
        param_postal_code: Option<String>,
        param_country: Option<String>,
        param_phone: Option<String>,
        param_credit_card_number: Option<String>,
        param_expiration_date: Option<String>,
        param_ccv: Option<String>,
        param_account_number: Option<String>,
        param_bank_name: Option<String>,
        param_routing_number: Option<String>,
        param_default_payment_method: Option<bool>,
        param_payment_method_nickname: Option<String>,
        param_tax_id: Option<String>,
        param_provider_customer_profile_id: Option<String>,
        param_provider_payment_profile_id: Option<String>,
        param_meta_data: Option<String>,
        context: &C) -> Result<AddPaymentMethodResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/billing/update",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            if let Some(param_payment_method_id) = param_payment_method_id {
                query_string.append_pair("paymentMethodId",
                    &param_payment_method_id.to_string());
            }
            if let Some(param_account_name) = param_account_name {
                query_string.append_pair("accountName",
                    &param_account_name);
            }
            if let Some(param_first_name) = param_first_name {
                query_string.append_pair("firstName",
                    &param_first_name);
            }
            if let Some(param_last_name) = param_last_name {
                query_string.append_pair("lastName",
                    &param_last_name);
            }
            if let Some(param_address) = param_address {
                query_string.append_pair("address",
                    &param_address);
            }
            if let Some(param_city) = param_city {
                query_string.append_pair("city",
                    &param_city);
            }
            if let Some(param_state) = param_state {
                query_string.append_pair("state",
                    &param_state);
            }
            if let Some(param_postal_code) = param_postal_code {
                query_string.append_pair("postalCode",
                    &param_postal_code);
            }
            if let Some(param_country) = param_country {
                query_string.append_pair("country",
                    &param_country);
            }
            if let Some(param_phone) = param_phone {
                query_string.append_pair("phone",
                    &param_phone);
            }
            if let Some(param_credit_card_number) = param_credit_card_number {
                query_string.append_pair("creditCardNumber",
                    &param_credit_card_number);
            }
            if let Some(param_expiration_date) = param_expiration_date {
                query_string.append_pair("expirationDate",
                    &param_expiration_date);
            }
            if let Some(param_ccv) = param_ccv {
                query_string.append_pair("ccv",
                    &param_ccv);
            }
            if let Some(param_account_number) = param_account_number {
                query_string.append_pair("accountNumber",
                    &param_account_number);
            }
            if let Some(param_bank_name) = param_bank_name {
                query_string.append_pair("bankName",
                    &param_bank_name);
            }
            if let Some(param_routing_number) = param_routing_number {
                query_string.append_pair("routingNumber",
                    &param_routing_number);
            }
            if let Some(param_default_payment_method) = param_default_payment_method {
                query_string.append_pair("defaultPaymentMethod",
                    &param_default_payment_method.to_string());
            }
            if let Some(param_payment_method_nickname) = param_payment_method_nickname {
                query_string.append_pair("paymentMethodNickname",
                    &param_payment_method_nickname);
            }
            if let Some(param_tax_id) = param_tax_id {
                query_string.append_pair("taxId",
                    &param_tax_id);
            }
            if let Some(param_provider_customer_profile_id) = param_provider_customer_profile_id {
                query_string.append_pair("providerCustomerProfileId",
                    &param_provider_customer_profile_id);
            }
            if let Some(param_provider_payment_profile_id) = param_provider_payment_profile_id {
                query_string.append_pair("providerPaymentProfileId",
                    &param_provider_payment_profile_id);
            }
            if let Some(param_meta_data) = param_meta_data {
                query_string.append_pair("metaData",
                    &param_meta_data);
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::PaymentTypesResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(AddPaymentMethodResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn create_payment_method(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_account_name: Option<String>,
        param_first_name: Option<String>,
        param_last_name: Option<String>,
        param_address: Option<String>,
        param_city: Option<String>,
        param_state: Option<String>,
        param_postal_code: Option<String>,
        param_country: Option<String>,
        param_phone: Option<String>,
        param_credit_card_number: Option<String>,
        param_expiration_date: Option<String>,
        param_ccv: Option<String>,
        param_account_number: Option<String>,
        param_bank_name: Option<String>,
        param_routing_number: Option<String>,
        param_payment_method_nickname: Option<String>,
        param_tax_id: Option<String>,
        param_default_payment_method: Option<bool>,
        param_auth_token: Option<String>,
        param_provider: Option<String>,
        param_provider_customer_profile_id: Option<String>,
        param_provider_payment_profile_id: Option<String>,
        param_meta_data: Option<String>,
        param_app_key: Option<String>,
        context: &C) -> Result<CreatePaymentMethodResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/billing/create",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            if let Some(param_account_name) = param_account_name {
                query_string.append_pair("accountName",
                    &param_account_name);
            }
            if let Some(param_first_name) = param_first_name {
                query_string.append_pair("firstName",
                    &param_first_name);
            }
            if let Some(param_last_name) = param_last_name {
                query_string.append_pair("lastName",
                    &param_last_name);
            }
            if let Some(param_address) = param_address {
                query_string.append_pair("address",
                    &param_address);
            }
            if let Some(param_city) = param_city {
                query_string.append_pair("city",
                    &param_city);
            }
            if let Some(param_state) = param_state {
                query_string.append_pair("state",
                    &param_state);
            }
            if let Some(param_postal_code) = param_postal_code {
                query_string.append_pair("postalCode",
                    &param_postal_code);
            }
            if let Some(param_country) = param_country {
                query_string.append_pair("country",
                    &param_country);
            }
            if let Some(param_phone) = param_phone {
                query_string.append_pair("phone",
                    &param_phone);
            }
            if let Some(param_credit_card_number) = param_credit_card_number {
                query_string.append_pair("creditCardNumber",
                    &param_credit_card_number);
            }
            if let Some(param_expiration_date) = param_expiration_date {
                query_string.append_pair("expirationDate",
                    &param_expiration_date);
            }
            if let Some(param_ccv) = param_ccv {
                query_string.append_pair("ccv",
                    &param_ccv);
            }
            if let Some(param_account_number) = param_account_number {
                query_string.append_pair("accountNumber",
                    &param_account_number);
            }
            if let Some(param_bank_name) = param_bank_name {
                query_string.append_pair("bankName",
                    &param_bank_name);
            }
            if let Some(param_routing_number) = param_routing_number {
                query_string.append_pair("routingNumber",
                    &param_routing_number);
            }
            if let Some(param_payment_method_nickname) = param_payment_method_nickname {
                query_string.append_pair("paymentMethodNickname",
                    &param_payment_method_nickname);
            }
            if let Some(param_tax_id) = param_tax_id {
                query_string.append_pair("taxId",
                    &param_tax_id);
            }
            if let Some(param_default_payment_method) = param_default_payment_method {
                query_string.append_pair("defaultPaymentMethod",
                    &param_default_payment_method.to_string());
            }
            if let Some(param_auth_token) = param_auth_token {
                query_string.append_pair("authToken",
                    &param_auth_token);
            }
            if let Some(param_provider) = param_provider {
                query_string.append_pair("provider",
                    &param_provider);
            }
            if let Some(param_provider_customer_profile_id) = param_provider_customer_profile_id {
                query_string.append_pair("providerCustomerProfileId",
                    &param_provider_customer_profile_id);
            }
            if let Some(param_provider_payment_profile_id) = param_provider_payment_profile_id {
                query_string.append_pair("providerPaymentProfileId",
                    &param_provider_payment_profile_id);
            }
            if let Some(param_meta_data) = param_meta_data {
                query_string.append_pair("metaData",
                    &param_meta_data);
            }
            if let Some(param_app_key) = param_app_key {
                query_string.append_pair("appKey",
                    &param_app_key);
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::PaymentTypesResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(CreatePaymentMethodResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn create_smart_contract(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_token_name: String,
        param_token_symbol: String,
        param_payment_method_id: Option<i64>,
        context: &C) -> Result<CreateSmartContractResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/billing/crypto/transfer",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            if let Some(param_payment_method_id) = param_payment_method_id {
                query_string.append_pair("paymentMethodId",
                    &param_payment_method_id.to_string());
            }
                query_string.append_pair("tokenName",
                    &param_token_name);
                query_string.append_pair("tokenSymbol",
                    &param_token_symbol);
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::PaymentTypesResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(CreateSmartContractResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_crypto_balance(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_owner_account_id: Option<i64>,
        param_payment_method_id: Option<i64>,
        context: &C) -> Result<GetCryptoBalanceResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/billing/crypto/get",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            if let Some(param_owner_account_id) = param_owner_account_id {
                query_string.append_pair("ownerAccountId",
                    &param_owner_account_id.to_string());
            }
            if let Some(param_payment_method_id) = param_payment_method_id {
                query_string.append_pair("paymentMethodId",
                    &param_payment_method_id.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::PaymentTypesResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetCryptoBalanceResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_payment_method(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_payment_method_id: Option<i64>,
        param_get_current_balance: Option<bool>,
        context: &C) -> Result<GetPaymentMethodResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/billing/get",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            if let Some(param_payment_method_id) = param_payment_method_id {
                query_string.append_pair("paymentMethodId",
                    &param_payment_method_id.to_string());
            }
            if let Some(param_get_current_balance) = param_get_current_balance {
                query_string.append_pair("getCurrentBalance",
                    &param_get_current_balance.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::PaymentTypesResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetPaymentMethodResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn search_payment_method(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_provider: Option<String>,
        param_param_type: Option<String>,
        param_keyword: Option<String>,
        param_sort_field: Option<String>,
        param_descending: Option<bool>,
        param_start: Option<i32>,
        param_limit: Option<i32>,
        context: &C) -> Result<SearchPaymentMethodResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/billing/search",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            if let Some(param_provider) = param_provider {
                query_string.append_pair("provider",
                    &param_provider);
            }
            if let Some(param_param_type) = param_param_type {
                query_string.append_pair("type",
                    &param_param_type);
            }
            if let Some(param_keyword) = param_keyword {
                query_string.append_pair("keyword",
                    &param_keyword);
            }
            if let Some(param_sort_field) = param_sort_field {
                query_string.append_pair("sortField",
                    &param_sort_field);
            }
            if let Some(param_descending) = param_descending {
                query_string.append_pair("descending",
                    &param_descending.to_string());
            }
            if let Some(param_start) = param_start {
                query_string.append_pair("start",
                    &param_start.to_string());
            }
            if let Some(param_limit) = param_limit {
                query_string.append_pair("limit",
                    &param_limit.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::PaymentTypesResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(SearchPaymentMethodResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_status_csv(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_batch_id: i64,
        param_response_group: models::GetStatusCsvResponseGroupParameter,
        param_start: i64,
        param_limit: i64,
        context: &C) -> Result<GetStatusCsvResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/csvimport/batch/status/details",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("batchId",
                    &param_batch_id.to_string());
                query_string.append_pair("responseGroup",
                    &param_response_group.to_string());
                query_string.append_pair("start",
                    &param_start.to_string());
                query_string.append_pair("limit",
                    &param_limit.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetStatusCsvResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn list_status_csv(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_start: i32,
        param_limit: i32,
        context: &C) -> Result<ListStatusCsvResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/csvimport/batch/list",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("start",
                    &param_start.to_string());
                query_string.append_pair("limit",
                    &param_limit.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::CsvImportResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(ListStatusCsvResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn status_csv(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_batch_id: i64,
        context: &C) -> Result<StatusCsvResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/csvimport/batch/status",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("batchId",
                    &param_batch_id.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::CsvImportResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(StatusCsvResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn upload_csv(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_upload_type: models::UploadCsvUploadTypeParameter,
        param_import_file: swagger::ByteArray,
        param_file_format: models::UploadCsvFileFormatParameter,
        param_app_key: Option<String>,
        context: &C) -> Result<UploadCsvResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/csvimport/upload",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("uploadType",
                    &param_upload_type.to_string());
                query_string.append_pair("importFile",
                    &param_import_file.to_string());
            if let Some(param_app_key) = param_app_key {
                query_string.append_pair("appKey",
                    &param_app_key);
            }
                query_string.append_pair("fileFormat",
                    &param_file_format.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::CsvImportResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(UploadCsvResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn create_cargo_type(
        &self,
        param_version: f64,
        param_body: Option<models::CargoType>,
        context: &C) -> Result<CreateCargoTypeResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/cargo/type",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        // Consumes basic body
        // Body parameter
        if let Some(param_body) = param_body {
        let body = serde_json::to_string(&param_body).expect("impossible to fail to serialize");
        *request.body_mut() = body_from_string(body);
        }

        let header = "application/json";
        request.headers_mut().insert(CONTENT_TYPE, HeaderValue::from_static(header));

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::CargoType>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(CreateCargoTypeResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn search_cargo_types(
        &self,
        param_version: f64,
        param_sort_field: String,
        param_descending: bool,
        param_start: i32,
        param_limit: i32,
        param_active_only: bool,
        param_retailer_id: Option<i64>,
        param_hub_id: Option<i64>,
        context: &C) -> Result<SearchCargoTypesResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/cargo/type",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_retailer_id) = param_retailer_id {
                query_string.append_pair("retailerId",
                    &param_retailer_id.to_string());
            }
            if let Some(param_hub_id) = param_hub_id {
                query_string.append_pair("hubId",
                    &param_hub_id.to_string());
            }
                query_string.append_pair("sortField",
                    &param_sort_field);
                query_string.append_pair("descending",
                    &param_descending.to_string());
                query_string.append_pair("start",
                    &param_start.to_string());
                query_string.append_pair("limit",
                    &param_limit.to_string());
                query_string.append_pair("activeOnly",
                    &param_active_only.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<Vec<models::CargoType>>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(SearchCargoTypesResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn delete_cargo_type(
        &self,
        param_version: f64,
        param_cargo_type_id: i64,
        context: &C) -> Result<DeleteCargoTypeResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/cargo/type/{cargo_type_id}",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
            ,cargo_type_id=utf8_percent_encode(&param_cargo_type_id.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("DELETE")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            0 => {
                Ok(
                    DeleteCargoTypeResponse::SuccessfulOperation
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_cargo_type(
        &self,
        param_version: f64,
        param_cargo_type_id: i64,
        context: &C) -> Result<GetCargoTypeResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/cargo/type/{cargo_type_id}",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
            ,cargo_type_id=utf8_percent_encode(&param_cargo_type_id.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::CargoType>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetCargoTypeResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn update_cargo_type(
        &self,
        param_version: f64,
        param_cargo_type_id: i64,
        param_body: Option<models::CargoType>,
        context: &C) -> Result<UpdateCargoTypeResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/cargo/type/{cargo_type_id}",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
            ,cargo_type_id=utf8_percent_encode(&param_cargo_type_id.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("PUT")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        // Consumes basic body
        // Body parameter
        if let Some(param_body) = param_body {
        let body = serde_json::to_string(&param_body).expect("impossible to fail to serialize");
        *request.body_mut() = body_from_string(body);
        }

        let header = "application/json";
        request.headers_mut().insert(CONTENT_TYPE, HeaderValue::from_static(header));

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::CargoType>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(UpdateCargoTypeResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn search_carriers(
        &self,
        param_version: f64,
        param_keyword: Option<String>,
        param_descending: Option<bool>,
        param_start: Option<i32>,
        param_limit: Option<i32>,
        param_active_only: Option<bool>,
        context: &C) -> Result<SearchCarriersResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/carrier/search",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_keyword) = param_keyword {
                query_string.append_pair("keyword",
                    &param_keyword);
            }
            if let Some(param_descending) = param_descending {
                query_string.append_pair("descending",
                    &param_descending.to_string());
            }
            if let Some(param_start) = param_start {
                query_string.append_pair("start",
                    &param_start.to_string());
            }
            if let Some(param_limit) = param_limit {
                query_string.append_pair("limit",
                    &param_limit.to_string());
            }
            if let Some(param_active_only) = param_active_only {
                query_string.append_pair("activeOnly",
                    &param_active_only.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<Vec<models::CellCarrierResponse>>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(SearchCarriersResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn category_distance_search(
        &self,
        param_version: f64,
        param_account_id: Option<i64>,
        param_keyword: Option<String>,
        param_app_key: Option<String>,
        param_category_ids: Option<String>,
        param_parent_category_ids: Option<String>,
        param_root_only: Option<bool>,
        param_sort_field: Option<models::SearchCategoriesSortFieldParameter>,
        param_response_group: Option<models::SearchCategoriesResponseGroupParameter>,
        param_descending: Option<bool>,
        param_start: Option<i32>,
        param_limit: Option<i32>,
        param_active_only: Option<bool>,
        param_return_external: Option<bool>,
        param_exact_match: Option<bool>,
        param_param_type: Option<String>,
        param_external_type: Option<String>,
        param_min_offer_count: Option<i32>,
        param_latitude: Option<f64>,
        param_longitude: Option<f64>,
        param_range: Option<f64>,
        context: &C) -> Result<CategoryDistanceSearchResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/category/distancesearch",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_keyword) = param_keyword {
                query_string.append_pair("keyword",
                    &param_keyword);
            }
            if let Some(param_app_key) = param_app_key {
                query_string.append_pair("appKey",
                    &param_app_key);
            }
            if let Some(param_category_ids) = param_category_ids {
                query_string.append_pair("categoryIds",
                    &param_category_ids);
            }
            if let Some(param_parent_category_ids) = param_parent_category_ids {
                query_string.append_pair("parentCategoryIds",
                    &param_parent_category_ids);
            }
            if let Some(param_root_only) = param_root_only {
                query_string.append_pair("rootOnly",
                    &param_root_only.to_string());
            }
            if let Some(param_sort_field) = param_sort_field {
                query_string.append_pair("sortField",
                    &param_sort_field.to_string());
            }
            if let Some(param_response_group) = param_response_group {
                query_string.append_pair("responseGroup",
                    &param_response_group.to_string());
            }
            if let Some(param_descending) = param_descending {
                query_string.append_pair("descending",
                    &param_descending.to_string());
            }
            if let Some(param_start) = param_start {
                query_string.append_pair("start",
                    &param_start.to_string());
            }
            if let Some(param_limit) = param_limit {
                query_string.append_pair("limit",
                    &param_limit.to_string());
            }
            if let Some(param_active_only) = param_active_only {
                query_string.append_pair("activeOnly",
                    &param_active_only.to_string());
            }
            if let Some(param_return_external) = param_return_external {
                query_string.append_pair("returnExternal",
                    &param_return_external.to_string());
            }
            if let Some(param_exact_match) = param_exact_match {
                query_string.append_pair("exactMatch",
                    &param_exact_match.to_string());
            }
            if let Some(param_param_type) = param_param_type {
                query_string.append_pair("type",
                    &param_param_type);
            }
            if let Some(param_external_type) = param_external_type {
                query_string.append_pair("externalType",
                    &param_external_type);
            }
            if let Some(param_min_offer_count) = param_min_offer_count {
                query_string.append_pair("minOfferCount",
                    &param_min_offer_count.to_string());
            }
            if let Some(param_latitude) = param_latitude {
                query_string.append_pair("latitude",
                    &param_latitude.to_string());
            }
            if let Some(param_longitude) = param_longitude {
                query_string.append_pair("longitude",
                    &param_longitude.to_string());
            }
            if let Some(param_range) = param_range {
                query_string.append_pair("range",
                    &param_range.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<Vec<models::CategoryResponse>>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(CategoryDistanceSearchResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn create_category(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_name: String,
        param_app_key: Option<String>,
        param_parent_category_id: Option<i64>,
        param_description: Option<String>,
        param_param_type: Option<String>,
        param_asset_id: Option<i64>,
        param_external_id: Option<String>,
        param_external_type: Option<String>,
        param_external_category_slug: Option<String>,
        param_sqoot_slug: Option<String>,
        param_active: Option<bool>,
        param_meta_data: Option<String>,
        param_search_tags: Option<String>,
        context: &C) -> Result<CreateCategoryResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/category/create",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_app_key) = param_app_key {
                query_string.append_pair("appKey",
                    &param_app_key);
            }
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            if let Some(param_parent_category_id) = param_parent_category_id {
                query_string.append_pair("parentCategoryId",
                    &param_parent_category_id.to_string());
            }
                query_string.append_pair("name",
                    &param_name);
            if let Some(param_description) = param_description {
                query_string.append_pair("description",
                    &param_description);
            }
            if let Some(param_param_type) = param_param_type {
                query_string.append_pair("type",
                    &param_param_type);
            }
            if let Some(param_asset_id) = param_asset_id {
                query_string.append_pair("assetId",
                    &param_asset_id.to_string());
            }
            if let Some(param_external_id) = param_external_id {
                query_string.append_pair("externalId",
                    &param_external_id);
            }
            if let Some(param_external_type) = param_external_type {
                query_string.append_pair("externalType",
                    &param_external_type);
            }
            if let Some(param_external_category_slug) = param_external_category_slug {
                query_string.append_pair("externalCategorySlug",
                    &param_external_category_slug);
            }
            if let Some(param_sqoot_slug) = param_sqoot_slug {
                query_string.append_pair("sqootSlug",
                    &param_sqoot_slug);
            }
            if let Some(param_active) = param_active {
                query_string.append_pair("active",
                    &param_active.to_string());
            }
            if let Some(param_meta_data) = param_meta_data {
                query_string.append_pair("metaData",
                    &param_meta_data);
            }
            if let Some(param_search_tags) = param_search_tags {
                query_string.append_pair("searchTags",
                    &param_search_tags);
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::CategoryTreeResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(CreateCategoryResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn delete_category(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_category_id: i64,
        context: &C) -> Result<DeleteCategoryResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/category/delete",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("categoryId",
                    &param_category_id.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(DeleteCategoryResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn duplicate_category(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_category_id: i64,
        param_app_key: Option<String>,
        param_parent_category_id: Option<i64>,
        context: &C) -> Result<DuplicateCategoryResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/category/duplicate",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_app_key) = param_app_key {
                query_string.append_pair("appKey",
                    &param_app_key);
            }
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("categoryId",
                    &param_category_id.to_string());
            if let Some(param_parent_category_id) = param_parent_category_id {
                query_string.append_pair("parentCategoryId",
                    &param_parent_category_id.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::CategoryTreeResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(DuplicateCategoryResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_category(
        &self,
        param_version: f64,
        param_category_id: i64,
        param_return_external: Option<bool>,
        context: &C) -> Result<GetCategoryResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/category/get",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("categoryId",
                    &param_category_id.to_string());
            if let Some(param_return_external) = param_return_external {
                query_string.append_pair("returnExternal",
                    &param_return_external.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::CategoryTreeResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetCategoryResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn search_categories(
        &self,
        param_version: f64,
        param_account_id: Option<i64>,
        param_keyword: Option<String>,
        param_app_key: Option<String>,
        param_category_id: Option<String>,
        param_category_ids: Option<String>,
        param_parent_category_ids: Option<String>,
        param_root_only: Option<bool>,
        param_sort_field: Option<models::SearchCategoriesSortFieldParameter>,
        param_response_group: Option<models::SearchCategoriesResponseGroupParameter>,
        param_descending: Option<bool>,
        param_start: Option<i32>,
        param_limit: Option<i32>,
        param_active_only: Option<bool>,
        param_return_external: Option<bool>,
        param_exact_match: Option<bool>,
        param_param_type: Option<String>,
        param_external_type: Option<String>,
        param_exclude_external_type: Option<bool>,
        param_min_offer_count: Option<i32>,
        param_search_depth: Option<i32>,
        param_search_mode: Option<String>,
        context: &C) -> Result<SearchCategoriesResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/category/search",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_keyword) = param_keyword {
                query_string.append_pair("keyword",
                    &param_keyword);
            }
            if let Some(param_app_key) = param_app_key {
                query_string.append_pair("appKey",
                    &param_app_key);
            }
            if let Some(param_category_id) = param_category_id {
                query_string.append_pair("categoryId",
                    &param_category_id);
            }
            if let Some(param_category_ids) = param_category_ids {
                query_string.append_pair("categoryIds",
                    &param_category_ids);
            }
            if let Some(param_parent_category_ids) = param_parent_category_ids {
                query_string.append_pair("parentCategoryIds",
                    &param_parent_category_ids);
            }
            if let Some(param_root_only) = param_root_only {
                query_string.append_pair("rootOnly",
                    &param_root_only.to_string());
            }
            if let Some(param_sort_field) = param_sort_field {
                query_string.append_pair("sortField",
                    &param_sort_field.to_string());
            }
            if let Some(param_response_group) = param_response_group {
                query_string.append_pair("responseGroup",
                    &param_response_group.to_string());
            }
            if let Some(param_descending) = param_descending {
                query_string.append_pair("descending",
                    &param_descending.to_string());
            }
            if let Some(param_start) = param_start {
                query_string.append_pair("start",
                    &param_start.to_string());
            }
            if let Some(param_limit) = param_limit {
                query_string.append_pair("limit",
                    &param_limit.to_string());
            }
            if let Some(param_active_only) = param_active_only {
                query_string.append_pair("activeOnly",
                    &param_active_only.to_string());
            }
            if let Some(param_return_external) = param_return_external {
                query_string.append_pair("returnExternal",
                    &param_return_external.to_string());
            }
            if let Some(param_exact_match) = param_exact_match {
                query_string.append_pair("exactMatch",
                    &param_exact_match.to_string());
            }
            if let Some(param_param_type) = param_param_type {
                query_string.append_pair("type",
                    &param_param_type);
            }
            if let Some(param_external_type) = param_external_type {
                query_string.append_pair("externalType",
                    &param_external_type);
            }
            if let Some(param_exclude_external_type) = param_exclude_external_type {
                query_string.append_pair("excludeExternalType",
                    &param_exclude_external_type.to_string());
            }
            if let Some(param_min_offer_count) = param_min_offer_count {
                query_string.append_pair("minOfferCount",
                    &param_min_offer_count.to_string());
            }
            if let Some(param_search_depth) = param_search_depth {
                query_string.append_pair("searchDepth",
                    &param_search_depth.to_string());
            }
            if let Some(param_search_mode) = param_search_mode {
                query_string.append_pair("searchMode",
                    &param_search_mode);
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<Vec<models::CategoryResponse>>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(SearchCategoriesResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn update_category(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_category_id: i64,
        param_parent_category_id: Option<i64>,
        param_name: Option<String>,
        param_description: Option<String>,
        param_param_type: Option<String>,
        param_asset_id: Option<i64>,
        param_external_id: Option<String>,
        param_external_type: Option<String>,
        param_external_category_slug: Option<String>,
        param_sqoot_slug: Option<String>,
        param_active: Option<bool>,
        param_meta_data: Option<String>,
        param_search_tags: Option<String>,
        context: &C) -> Result<UpdateCategoryResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/category/update",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("categoryId",
                    &param_category_id.to_string());
            if let Some(param_parent_category_id) = param_parent_category_id {
                query_string.append_pair("parentCategoryId",
                    &param_parent_category_id.to_string());
            }
            if let Some(param_name) = param_name {
                query_string.append_pair("name",
                    &param_name);
            }
            if let Some(param_description) = param_description {
                query_string.append_pair("description",
                    &param_description);
            }
            if let Some(param_param_type) = param_param_type {
                query_string.append_pair("type",
                    &param_param_type);
            }
            if let Some(param_asset_id) = param_asset_id {
                query_string.append_pair("assetId",
                    &param_asset_id.to_string());
            }
            if let Some(param_external_id) = param_external_id {
                query_string.append_pair("externalId",
                    &param_external_id);
            }
            if let Some(param_external_type) = param_external_type {
                query_string.append_pair("externalType",
                    &param_external_type);
            }
            if let Some(param_external_category_slug) = param_external_category_slug {
                query_string.append_pair("externalCategorySlug",
                    &param_external_category_slug);
            }
            if let Some(param_sqoot_slug) = param_sqoot_slug {
                query_string.append_pair("sqootSlug",
                    &param_sqoot_slug);
            }
            if let Some(param_active) = param_active {
                query_string.append_pair("active",
                    &param_active.to_string());
            }
            if let Some(param_meta_data) = param_meta_data {
                query_string.append_pair("metaData",
                    &param_meta_data);
            }
            if let Some(param_search_tags) = param_search_tags {
                query_string.append_pair("searchTags",
                    &param_search_tags);
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::CategoryTreeResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(UpdateCategoryResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn add_connection_to_group(
        &self,
        param_version: f64,
        param_return_nulls: bool,
        param_group_id: i64,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_connection_id: Option<i64>,
        param_connection_account_id: Option<i64>,
        param_pending_id: Option<i64>,
        param_latitude: Option<f64>,
        param_longitude: Option<f64>,
        context: &C) -> Result<AddConnectionToGroupResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/consumer/connection/group/addConnection",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("returnNulls",
                    &param_return_nulls.to_string());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_connection_id) = param_connection_id {
                query_string.append_pair("connectionId",
                    &param_connection_id.to_string());
            }
            if let Some(param_connection_account_id) = param_connection_account_id {
                query_string.append_pair("connectionAccountId",
                    &param_connection_account_id.to_string());
            }
            if let Some(param_pending_id) = param_pending_id {
                query_string.append_pair("pendingId",
                    &param_pending_id.to_string());
            }
                query_string.append_pair("groupId",
                    &param_group_id.to_string());
            if let Some(param_latitude) = param_latitude {
                query_string.append_pair("latitude",
                    &param_latitude.to_string());
            }
            if let Some(param_longitude) = param_longitude {
                query_string.append_pair("longitude",
                    &param_longitude.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(AddConnectionToGroupResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn add_connections_to_group(
        &self,
        param_version: f64,
        param_connection_group_id: i64,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_connection_ids: Option<String>,
        param_connection_account_ids: Option<String>,
        param_latitude: Option<f64>,
        param_longitude: Option<f64>,
        context: &C) -> Result<AddConnectionsToGroupResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/connection/group/addConnections",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_connection_ids) = param_connection_ids {
                query_string.append_pair("connectionIds",
                    &param_connection_ids);
            }
            if let Some(param_connection_account_ids) = param_connection_account_ids {
                query_string.append_pair("connectionAccountIds",
                    &param_connection_account_ids);
            }
                query_string.append_pair("connectionGroupId",
                    &param_connection_group_id.to_string());
            if let Some(param_latitude) = param_latitude {
                query_string.append_pair("latitude",
                    &param_latitude.to_string());
            }
            if let Some(param_longitude) = param_longitude {
                query_string.append_pair("longitude",
                    &param_longitude.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(AddConnectionsToGroupResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn add_sub_groups(
        &self,
        param_version: f64,
        param_return_nulls: bool,
        param_group_id: i64,
        param_sub_group_ids: String,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_latitude: Option<f64>,
        param_longitude: Option<f64>,
        context: &C) -> Result<AddSubGroupsResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/consumer/connection/group/addSubGroup",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("returnNulls",
                    &param_return_nulls.to_string());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
                query_string.append_pair("groupId",
                    &param_group_id.to_string());
                query_string.append_pair("subGroupIds",
                    &param_sub_group_ids);
            if let Some(param_latitude) = param_latitude {
                query_string.append_pair("latitude",
                    &param_latitude.to_string());
            }
            if let Some(param_longitude) = param_longitude {
                query_string.append_pair("longitude",
                    &param_longitude.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::ConnectionGroupResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(AddSubGroupsResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn create_or_update_connection(
        &self,
        param_version: f64,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_connection_id: Option<i64>,
        param_connection_account_id: Option<i64>,
        param_pending_id: Option<i64>,
        param_group_id: Option<i64>,
        param_game_type: Option<String>,
        param_app_key: Option<String>,
        param_is_trusted: Option<bool>,
        param_ignore_friend_request: Option<bool>,
        param_is_contact: Option<bool>,
        param_is_blocked: Option<bool>,
        param_is_following: Option<bool>,
        param_connection_response: Option<bool>,
        context: &C) -> Result<CreateOrUpdateConnectionResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/consumer/connection/add",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_connection_id) = param_connection_id {
                query_string.append_pair("connectionId",
                    &param_connection_id.to_string());
            }
            if let Some(param_connection_account_id) = param_connection_account_id {
                query_string.append_pair("connectionAccountId",
                    &param_connection_account_id.to_string());
            }
            if let Some(param_pending_id) = param_pending_id {
                query_string.append_pair("pendingId",
                    &param_pending_id.to_string());
            }
            if let Some(param_group_id) = param_group_id {
                query_string.append_pair("groupId",
                    &param_group_id.to_string());
            }
            if let Some(param_game_type) = param_game_type {
                query_string.append_pair("gameType",
                    &param_game_type);
            }
            if let Some(param_app_key) = param_app_key {
                query_string.append_pair("appKey",
                    &param_app_key);
            }
            if let Some(param_is_trusted) = param_is_trusted {
                query_string.append_pair("isTrusted",
                    &param_is_trusted.to_string());
            }
            if let Some(param_ignore_friend_request) = param_ignore_friend_request {
                query_string.append_pair("ignoreFriendRequest",
                    &param_ignore_friend_request.to_string());
            }
            if let Some(param_is_contact) = param_is_contact {
                query_string.append_pair("isContact",
                    &param_is_contact.to_string());
            }
            if let Some(param_is_blocked) = param_is_blocked {
                query_string.append_pair("isBlocked",
                    &param_is_blocked.to_string());
            }
            if let Some(param_is_following) = param_is_following {
                query_string.append_pair("isFollowing",
                    &param_is_following.to_string());
            }
            if let Some(param_connection_response) = param_connection_response {
                query_string.append_pair("connectionResponse",
                    &param_connection_response.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::ConnectionResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(CreateOrUpdateConnectionResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn create_or_update_group(
        &self,
        param_version: f64,
        param_return_nulls: bool,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_name: Option<String>,
        param_group_id: Option<i64>,
        param_asset_id: Option<i64>,
        param_connections: Option<String>,
        param_description: Option<String>,
        param_can_view_profile_info: Option<bool>,
        param_can_view_game_info: Option<bool>,
        param_can_view_friend_info: Option<bool>,
        param_active: Option<bool>,
        param_latitude: Option<f64>,
        param_longitude: Option<f64>,
        context: &C) -> Result<CreateOrUpdateGroupResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/consumer/connection/group",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("returnNulls",
                    &param_return_nulls.to_string());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_name) = param_name {
                query_string.append_pair("name",
                    &param_name);
            }
            if let Some(param_group_id) = param_group_id {
                query_string.append_pair("groupId",
                    &param_group_id.to_string());
            }
            if let Some(param_asset_id) = param_asset_id {
                query_string.append_pair("assetId",
                    &param_asset_id.to_string());
            }
            if let Some(param_connections) = param_connections {
                query_string.append_pair("connections",
                    &param_connections);
            }
            if let Some(param_description) = param_description {
                query_string.append_pair("description",
                    &param_description);
            }
            if let Some(param_can_view_profile_info) = param_can_view_profile_info {
                query_string.append_pair("canViewProfileInfo",
                    &param_can_view_profile_info.to_string());
            }
            if let Some(param_can_view_game_info) = param_can_view_game_info {
                query_string.append_pair("canViewGameInfo",
                    &param_can_view_game_info.to_string());
            }
            if let Some(param_can_view_friend_info) = param_can_view_friend_info {
                query_string.append_pair("canViewFriendInfo",
                    &param_can_view_friend_info.to_string());
            }
            if let Some(param_active) = param_active {
                query_string.append_pair("active",
                    &param_active.to_string());
            }
            if let Some(param_latitude) = param_latitude {
                query_string.append_pair("latitude",
                    &param_latitude.to_string());
            }
            if let Some(param_longitude) = param_longitude {
                query_string.append_pair("longitude",
                    &param_longitude.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(CreateOrUpdateGroupResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn follow_accept(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_connection_account_id: i64,
        param_app_key: String,
        context: &C) -> Result<FollowAcceptResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/consumer/follow/accept",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("connectionAccountId",
                    &param_connection_account_id.to_string());
                query_string.append_pair("appKey",
                    &param_app_key);
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(FollowAcceptResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn follow_reject(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_connection_account_id: i64,
        param_app_key: String,
        context: &C) -> Result<FollowRejectResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/consumer/follow/reject",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("connectionAccountId",
                    &param_connection_account_id.to_string());
                query_string.append_pair("appKey",
                    &param_app_key);
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(FollowRejectResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn follow_remove(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_connection_account_id: i64,
        param_app_key: String,
        context: &C) -> Result<FollowRemoveResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/consumer/follow/remove",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("connectionAccountId",
                    &param_connection_account_id.to_string());
                query_string.append_pair("appKey",
                    &param_app_key);
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(FollowRemoveResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn follow_request(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_connection_account_id: i64,
        param_app_key: String,
        param_approval_needed: Option<bool>,
        context: &C) -> Result<FollowRequestResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/consumer/follow/request",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("connectionAccountId",
                    &param_connection_account_id.to_string());
                query_string.append_pair("appKey",
                    &param_app_key);
            if let Some(param_approval_needed) = param_approval_needed {
                query_string.append_pair("approvalNeeded",
                    &param_approval_needed.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(FollowRequestResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn friend_accept(
        &self,
        param_version: f64,
        param_friend_account_id: i64,
        param_notify_friend: bool,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_game_type: Option<String>,
        param_app_key: Option<String>,
        param_notification_message: Option<String>,
        context: &C) -> Result<FriendAcceptResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/consumer/friend/accept",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
                query_string.append_pair("friendAccountId",
                    &param_friend_account_id.to_string());
            if let Some(param_game_type) = param_game_type {
                query_string.append_pair("gameType",
                    &param_game_type);
            }
            if let Some(param_app_key) = param_app_key {
                query_string.append_pair("appKey",
                    &param_app_key);
            }
                query_string.append_pair("notifyFriend",
                    &param_notify_friend.to_string());
            if let Some(param_notification_message) = param_notification_message {
                query_string.append_pair("notificationMessage",
                    &param_notification_message);
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(FriendAcceptResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn friend_reject(
        &self,
        param_version: f64,
        param_friend_account_id: i64,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_game_type: Option<String>,
        param_app_key: Option<String>,
        param_notify_friend: Option<bool>,
        param_notification_message: Option<String>,
        context: &C) -> Result<FriendRejectResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/consumer/friend/reject",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
                query_string.append_pair("friendAccountId",
                    &param_friend_account_id.to_string());
            if let Some(param_game_type) = param_game_type {
                query_string.append_pair("gameType",
                    &param_game_type);
            }
            if let Some(param_app_key) = param_app_key {
                query_string.append_pair("appKey",
                    &param_app_key);
            }
            if let Some(param_notify_friend) = param_notify_friend {
                query_string.append_pair("notifyFriend",
                    &param_notify_friend.to_string());
            }
            if let Some(param_notification_message) = param_notification_message {
                query_string.append_pair("notificationMessage",
                    &param_notification_message);
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(FriendRejectResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn friend_remove(
        &self,
        param_version: f64,
        param_friend_account_id: i64,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_notify_friend: Option<bool>,
        param_remove_from_groups: Option<bool>,
        context: &C) -> Result<FriendRemoveResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/consumer/friend/remove",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
                query_string.append_pair("friendAccountId",
                    &param_friend_account_id.to_string());
            if let Some(param_notify_friend) = param_notify_friend {
                query_string.append_pair("notifyFriend",
                    &param_notify_friend.to_string());
            }
            if let Some(param_remove_from_groups) = param_remove_from_groups {
                query_string.append_pair("removeFromGroups",
                    &param_remove_from_groups.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(FriendRemoveResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn friend_request(
        &self,
        param_version: f64,
        param_friend_account_id: i64,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_game_type: Option<String>,
        param_app_key: Option<String>,
        param_notification_message: Option<String>,
        context: &C) -> Result<FriendRequestResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/consumer/friend/request",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
                query_string.append_pair("friendAccountId",
                    &param_friend_account_id.to_string());
            if let Some(param_game_type) = param_game_type {
                query_string.append_pair("gameType",
                    &param_game_type);
            }
            if let Some(param_app_key) = param_app_key {
                query_string.append_pair("appKey",
                    &param_app_key);
            }
            if let Some(param_notification_message) = param_notification_message {
                query_string.append_pair("notificationMessage",
                    &param_notification_message);
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(FriendRequestResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_connection_sent_friend_requests(
        &self,
        param_version: f64,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        context: &C) -> Result<GetConnectionSentFriendRequestsResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/consumer/connection/getRequested",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::ConnectionListResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetConnectionSentFriendRequestsResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_connections(
        &self,
        param_version: f64,
        param_return_nulls: bool,
        param_filter: String,
        param_sort_field: String,
        param_descending: bool,
        param_start: i32,
        param_limit: i32,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_connection_account_id: Option<i64>,
        param_q: Option<String>,
        param_keyword: Option<String>,
        param__i: Option<i32>,
        param__l: Option<i32>,
        param_latitude: Option<f64>,
        param_longitude: Option<f64>,
        context: &C) -> Result<GetConnectionsResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/consumer/connection/get",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("returnNulls",
                    &param_return_nulls.to_string());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_connection_account_id) = param_connection_account_id {
                query_string.append_pair("connectionAccountId",
                    &param_connection_account_id.to_string());
            }
                query_string.append_pair("filter",
                    &param_filter);
            if let Some(param_q) = param_q {
                query_string.append_pair("q",
                    &param_q);
            }
            if let Some(param_keyword) = param_keyword {
                query_string.append_pair("keyword",
                    &param_keyword);
            }
                query_string.append_pair("sortField",
                    &param_sort_field);
                query_string.append_pair("descending",
                    &param_descending.to_string());
            if let Some(param__i) = param__i {
                query_string.append_pair("_i",
                    &param__i.to_string());
            }
                query_string.append_pair("start",
                    &param_start.to_string());
            if let Some(param__l) = param__l {
                query_string.append_pair("_l",
                    &param__l.to_string());
            }
                query_string.append_pair("limit",
                    &param_limit.to_string());
            if let Some(param_latitude) = param_latitude {
                query_string.append_pair("latitude",
                    &param_latitude.to_string());
            }
            if let Some(param_longitude) = param_longitude {
                query_string.append_pair("longitude",
                    &param_longitude.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::ConnectionListResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetConnectionsResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_group_details(
        &self,
        param_version: f64,
        param_combine_connections: bool,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_group_id: Option<i64>,
        param_latitude: Option<f64>,
        param_longitude: Option<f64>,
        context: &C) -> Result<GetGroupDetailsResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/consumer/connection/group/details/get",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_group_id) = param_group_id {
                query_string.append_pair("groupId",
                    &param_group_id.to_string());
            }
                query_string.append_pair("combineConnections",
                    &param_combine_connections.to_string());
            if let Some(param_latitude) = param_latitude {
                query_string.append_pair("latitude",
                    &param_latitude.to_string());
            }
            if let Some(param_longitude) = param_longitude {
                query_string.append_pair("longitude",
                    &param_longitude.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::ConnectionGroupResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetGroupDetailsResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn group_search(
        &self,
        param_version: f64,
        param_sort_field: models::GroupSearchSortFieldParameter,
        param_descending: bool,
        param_active_only: bool,
        param_start: i32,
        param_limit: i32,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_latitude: Option<f64>,
        param_longitude: Option<f64>,
        param_keyword: Option<String>,
        context: &C) -> Result<GroupSearchResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/connection/group/search",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_latitude) = param_latitude {
                query_string.append_pair("latitude",
                    &param_latitude.to_string());
            }
            if let Some(param_longitude) = param_longitude {
                query_string.append_pair("longitude",
                    &param_longitude.to_string());
            }
            if let Some(param_keyword) = param_keyword {
                query_string.append_pair("keyword",
                    &param_keyword);
            }
                query_string.append_pair("sortField",
                    &param_sort_field.to_string());
                query_string.append_pair("descending",
                    &param_descending.to_string());
                query_string.append_pair("activeOnly",
                    &param_active_only.to_string());
                query_string.append_pair("start",
                    &param_start.to_string());
                query_string.append_pair("limit",
                    &param_limit.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<Vec<models::ConnectionInfoResponse>>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GroupSearchResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn remove_connection_from_group(
        &self,
        param_version: f64,
        param_return_nulls: bool,
        param_group_id: i64,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_connection_id: Option<i64>,
        param_connection_account_id: Option<i64>,
        param_pending_id: Option<i64>,
        param_latitude: Option<f64>,
        param_longitude: Option<f64>,
        context: &C) -> Result<RemoveConnectionFromGroupResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/consumer/connection/group/removeConnection",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("returnNulls",
                    &param_return_nulls.to_string());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_connection_id) = param_connection_id {
                query_string.append_pair("connectionId",
                    &param_connection_id.to_string());
            }
            if let Some(param_connection_account_id) = param_connection_account_id {
                query_string.append_pair("connectionAccountId",
                    &param_connection_account_id.to_string());
            }
            if let Some(param_pending_id) = param_pending_id {
                query_string.append_pair("pendingId",
                    &param_pending_id.to_string());
            }
                query_string.append_pair("groupId",
                    &param_group_id.to_string());
            if let Some(param_latitude) = param_latitude {
                query_string.append_pair("latitude",
                    &param_latitude.to_string());
            }
            if let Some(param_longitude) = param_longitude {
                query_string.append_pair("longitude",
                    &param_longitude.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(RemoveConnectionFromGroupResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn remove_connections_from_group(
        &self,
        param_version: f64,
        param_connection_group_id: i64,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_connection_ids: Option<String>,
        param_connection_account_ids: Option<String>,
        param_latitude: Option<f64>,
        param_longitude: Option<f64>,
        context: &C) -> Result<RemoveConnectionsFromGroupResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/connection/group/removeConnections",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_connection_ids) = param_connection_ids {
                query_string.append_pair("connectionIds",
                    &param_connection_ids);
            }
            if let Some(param_connection_account_ids) = param_connection_account_ids {
                query_string.append_pair("connectionAccountIds",
                    &param_connection_account_ids);
            }
                query_string.append_pair("connectionGroupId",
                    &param_connection_group_id.to_string());
            if let Some(param_latitude) = param_latitude {
                query_string.append_pair("latitude",
                    &param_latitude.to_string());
            }
            if let Some(param_longitude) = param_longitude {
                query_string.append_pair("longitude",
                    &param_longitude.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(RemoveConnectionsFromGroupResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn remove_group(
        &self,
        param_version: f64,
        param_return_nulls: bool,
        param_group_id: i64,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_latitude: Option<f64>,
        param_longitude: Option<f64>,
        context: &C) -> Result<RemoveGroupResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/consumer/connection/group/remove",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("returnNulls",
                    &param_return_nulls.to_string());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
                query_string.append_pair("groupId",
                    &param_group_id.to_string());
            if let Some(param_latitude) = param_latitude {
                query_string.append_pair("latitude",
                    &param_latitude.to_string());
            }
            if let Some(param_longitude) = param_longitude {
                query_string.append_pair("longitude",
                    &param_longitude.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(RemoveGroupResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn remove_sub_groups(
        &self,
        param_version: f64,
        param_return_nulls: bool,
        param_group_id: i64,
        param_sub_group_ids: String,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_latitude: Option<f64>,
        param_longitude: Option<f64>,
        context: &C) -> Result<RemoveSubGroupsResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/consumer/connection/group/removeSubGroup",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("returnNulls",
                    &param_return_nulls.to_string());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
                query_string.append_pair("groupId",
                    &param_group_id.to_string());
                query_string.append_pair("subGroupIds",
                    &param_sub_group_ids);
            if let Some(param_latitude) = param_latitude {
                query_string.append_pair("latitude",
                    &param_latitude.to_string());
            }
            if let Some(param_longitude) = param_longitude {
                query_string.append_pair("longitude",
                    &param_longitude.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(RemoveSubGroupsResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn search_connections(
        &self,
        param_version: f64,
        param_return_nulls: bool,
        param_start: i32,
        param_limit: i32,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_q: Option<String>,
        param_keyword: Option<String>,
        param_latitude: Option<f64>,
        param_longitude: Option<f64>,
        param_game_type: Option<String>,
        param_app_key: Option<String>,
        param__i: Option<i32>,
        param__l: Option<i32>,
        param_sort_field: Option<String>,
        param_has_location: Option<bool>,
        context: &C) -> Result<SearchConnectionsResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/connection/search",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("returnNulls",
                    &param_return_nulls.to_string());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_q) = param_q {
                query_string.append_pair("q",
                    &param_q);
            }
            if let Some(param_keyword) = param_keyword {
                query_string.append_pair("keyword",
                    &param_keyword);
            }
            if let Some(param_latitude) = param_latitude {
                query_string.append_pair("latitude",
                    &param_latitude.to_string());
            }
            if let Some(param_longitude) = param_longitude {
                query_string.append_pair("longitude",
                    &param_longitude.to_string());
            }
            if let Some(param_game_type) = param_game_type {
                query_string.append_pair("gameType",
                    &param_game_type);
            }
            if let Some(param_app_key) = param_app_key {
                query_string.append_pair("appKey",
                    &param_app_key);
            }
            if let Some(param__i) = param__i {
                query_string.append_pair("_i",
                    &param__i.to_string());
            }
                query_string.append_pair("start",
                    &param_start.to_string());
            if let Some(param__l) = param__l {
                query_string.append_pair("_l",
                    &param__l.to_string());
            }
                query_string.append_pair("limit",
                    &param_limit.to_string());
            if let Some(param_sort_field) = param_sort_field {
                query_string.append_pair("sortField",
                    &param_sort_field);
            }
            if let Some(param_has_location) = param_has_location {
                query_string.append_pair("hasLocation",
                    &param_has_location.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::ConnectionListResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(SearchConnectionsResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn add_or_update_album_contest(
        &self,
        param_version: f64,
        param_public_read: bool,
        param_public_write: bool,
        param_public_delete: bool,
        param_public_add: bool,
        param_visibility: models::AddAlbumCollectionVisibilityParameter,
        param_include_friend_group: bool,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_game_type: Option<String>,
        param_app_key: Option<String>,
        param_contest_type: Option<String>,
        param_album_contest_id: Option<i64>,
        param_title: Option<String>,
        param_description: Option<String>,
        param_album_id1: Option<i64>,
        param_remove_album1: Option<bool>,
        param_album_id2: Option<i64>,
        param_remove_album2: Option<bool>,
        param_start_date: Option<i64>,
        param_end_date: Option<i64>,
        param_location_description: Option<String>,
        param_connection_ids_to_add: Option<String>,
        param_connection_group_ids_to_add: Option<String>,
        param_latitude: Option<f64>,
        param_longitude: Option<f64>,
        context: &C) -> Result<AddOrUpdateAlbumContestResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/consumer/album/contest",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_game_type) = param_game_type {
                query_string.append_pair("gameType",
                    &param_game_type);
            }
            if let Some(param_app_key) = param_app_key {
                query_string.append_pair("appKey",
                    &param_app_key);
            }
            if let Some(param_contest_type) = param_contest_type {
                query_string.append_pair("contestType",
                    &param_contest_type);
            }
            if let Some(param_album_contest_id) = param_album_contest_id {
                query_string.append_pair("albumContestId",
                    &param_album_contest_id.to_string());
            }
            if let Some(param_title) = param_title {
                query_string.append_pair("title",
                    &param_title);
            }
            if let Some(param_description) = param_description {
                query_string.append_pair("description",
                    &param_description);
            }
            if let Some(param_album_id1) = param_album_id1 {
                query_string.append_pair("albumId1",
                    &param_album_id1.to_string());
            }
            if let Some(param_remove_album1) = param_remove_album1 {
                query_string.append_pair("removeAlbum1",
                    &param_remove_album1.to_string());
            }
            if let Some(param_album_id2) = param_album_id2 {
                query_string.append_pair("albumId2",
                    &param_album_id2.to_string());
            }
            if let Some(param_remove_album2) = param_remove_album2 {
                query_string.append_pair("removeAlbum2",
                    &param_remove_album2.to_string());
            }
            if let Some(param_start_date) = param_start_date {
                query_string.append_pair("startDate",
                    &param_start_date.to_string());
            }
            if let Some(param_end_date) = param_end_date {
                query_string.append_pair("endDate",
                    &param_end_date.to_string());
            }
                query_string.append_pair("publicRead",
                    &param_public_read.to_string());
                query_string.append_pair("publicWrite",
                    &param_public_write.to_string());
                query_string.append_pair("publicDelete",
                    &param_public_delete.to_string());
                query_string.append_pair("publicAdd",
                    &param_public_add.to_string());
            if let Some(param_location_description) = param_location_description {
                query_string.append_pair("locationDescription",
                    &param_location_description);
            }
                query_string.append_pair("visibility",
                    &param_visibility.to_string());
            if let Some(param_connection_ids_to_add) = param_connection_ids_to_add {
                query_string.append_pair("connectionIdsToAdd",
                    &param_connection_ids_to_add);
            }
            if let Some(param_connection_group_ids_to_add) = param_connection_group_ids_to_add {
                query_string.append_pair("connectionGroupIdsToAdd",
                    &param_connection_group_ids_to_add);
            }
                query_string.append_pair("includeFriendGroup",
                    &param_include_friend_group.to_string());
            if let Some(param_latitude) = param_latitude {
                query_string.append_pair("latitude",
                    &param_latitude.to_string());
            }
            if let Some(param_longitude) = param_longitude {
                query_string.append_pair("longitude",
                    &param_longitude.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::AlbumContestResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(AddOrUpdateAlbumContestResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn approve_album_contest(
        &self,
        param_version: f64,
        param_album_contest_id: i64,
        param_approval_status: models::ApproveAlbumApprovalStatusParameter,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        context: &C) -> Result<ApproveAlbumContestResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/consumer/album/contest/approve",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
                query_string.append_pair("albumContestId",
                    &param_album_contest_id.to_string());
                query_string.append_pair("approvalStatus",
                    &param_approval_status.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(ApproveAlbumContestResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn delete_contest(
        &self,
        param_version: f64,
        param_album_contest_id: i64,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_latitude: Option<f64>,
        param_longitude: Option<f64>,
        context: &C) -> Result<DeleteContestResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/consumer/album/contest/remove",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
                query_string.append_pair("albumContestId",
                    &param_album_contest_id.to_string());
            if let Some(param_latitude) = param_latitude {
                query_string.append_pair("latitude",
                    &param_latitude.to_string());
            }
            if let Some(param_longitude) = param_longitude {
                query_string.append_pair("longitude",
                    &param_longitude.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(DeleteContestResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_album_contest(
        &self,
        param_version: f64,
        param_album_contest_id: i64,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_latitude: Option<f64>,
        param_longitude: Option<f64>,
        context: &C) -> Result<GetAlbumContestResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/consumer/album/contest/get",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
                query_string.append_pair("albumContestId",
                    &param_album_contest_id.to_string());
            if let Some(param_latitude) = param_latitude {
                query_string.append_pair("latitude",
                    &param_latitude.to_string());
            }
            if let Some(param_longitude) = param_longitude {
                query_string.append_pair("longitude",
                    &param_longitude.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::AlbumContestResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetAlbumContestResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_album_contests(
        &self,
        param_version: f64,
        param_filter: String,
        param_sort_field: String,
        param_descending: bool,
        param_start: i32,
        param_limit: i32,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_game_type: Option<String>,
        param_app_key: Option<String>,
        param_app_type: Option<String>,
        param_contest_type: Option<String>,
        param_owner_id: Option<i64>,
        param_q: Option<String>,
        param_keyword: Option<String>,
        param__i: Option<i32>,
        param__l: Option<i32>,
        param_date_created: Option<i64>,
        param_latitude: Option<f64>,
        param_longitude: Option<f64>,
        context: &C) -> Result<GetAlbumContestsResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/consumer/album/contest/search",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_game_type) = param_game_type {
                query_string.append_pair("gameType",
                    &param_game_type);
            }
            if let Some(param_app_key) = param_app_key {
                query_string.append_pair("appKey",
                    &param_app_key);
            }
            if let Some(param_app_type) = param_app_type {
                query_string.append_pair("appType",
                    &param_app_type);
            }
            if let Some(param_contest_type) = param_contest_type {
                query_string.append_pair("contestType",
                    &param_contest_type);
            }
            if let Some(param_owner_id) = param_owner_id {
                query_string.append_pair("ownerId",
                    &param_owner_id.to_string());
            }
            if let Some(param_q) = param_q {
                query_string.append_pair("q",
                    &param_q);
            }
            if let Some(param_keyword) = param_keyword {
                query_string.append_pair("keyword",
                    &param_keyword);
            }
                query_string.append_pair("filter",
                    &param_filter);
                query_string.append_pair("sortField",
                    &param_sort_field);
                query_string.append_pair("descending",
                    &param_descending.to_string());
            if let Some(param__i) = param__i {
                query_string.append_pair("_i",
                    &param__i.to_string());
            }
                query_string.append_pair("start",
                    &param_start.to_string());
            if let Some(param__l) = param__l {
                query_string.append_pair("_l",
                    &param__l.to_string());
            }
                query_string.append_pair("limit",
                    &param_limit.to_string());
            if let Some(param_date_created) = param_date_created {
                query_string.append_pair("dateCreated",
                    &param_date_created.to_string());
            }
            if let Some(param_latitude) = param_latitude {
                query_string.append_pair("latitude",
                    &param_latitude.to_string());
            }
            if let Some(param_longitude) = param_longitude {
                query_string.append_pair("longitude",
                    &param_longitude.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::AlbumContestListResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetAlbumContestsResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn vote_on_album_contest(
        &self,
        param_version: f64,
        param_album_contest_id: i64,
        param_album_id: i64,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_contest_type: Option<String>,
        param_latitude: Option<f64>,
        param_longitude: Option<f64>,
        context: &C) -> Result<VoteOnAlbumContestResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/consumer/album/contest/vote",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
                query_string.append_pair("albumContestId",
                    &param_album_contest_id.to_string());
                query_string.append_pair("albumId",
                    &param_album_id.to_string());
            if let Some(param_contest_type) = param_contest_type {
                query_string.append_pair("contestType",
                    &param_contest_type);
            }
            if let Some(param_latitude) = param_latitude {
                query_string.append_pair("latitude",
                    &param_latitude.to_string());
            }
            if let Some(param_longitude) = param_longitude {
                query_string.append_pair("longitude",
                    &param_longitude.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::AlbumContestResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(VoteOnAlbumContestResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn add_preview(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_creative_id: i64,
        context: &C) -> Result<AddPreviewResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/creative/addpreview",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("creativeId",
                    &param_creative_id.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(AddPreviewResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn ads_find(
        &self,
        param_version: f64,
        param_app_key: String,
        param_randomize: bool,
        param_targeted_ads_only: bool,
        param_param_type: Option<String>,
        param_account_id: Option<i64>,
        param_app_version: Option<String>,
        param_latitude: Option<f64>,
        param_longitude: Option<f64>,
        param_device: Option<String>,
        param_device_identifier: Option<i64>,
        param_device_version: Option<String>,
        param_start: Option<i32>,
        param_limit: Option<i32>,
        param_include_audiences: Option<bool>,
        param_allocates_tickets: Option<bool>,
        param_mission_ids: Option<String>,
        context: &C) -> Result<AdsFindResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/ads/find",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("appKey",
                    &param_app_key);
            if let Some(param_param_type) = param_param_type {
                query_string.append_pair("type",
                    &param_param_type);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_app_version) = param_app_version {
                query_string.append_pair("appVersion",
                    &param_app_version);
            }
            if let Some(param_latitude) = param_latitude {
                query_string.append_pair("latitude",
                    &param_latitude.to_string());
            }
            if let Some(param_longitude) = param_longitude {
                query_string.append_pair("longitude",
                    &param_longitude.to_string());
            }
            if let Some(param_device) = param_device {
                query_string.append_pair("device",
                    &param_device);
            }
            if let Some(param_device_identifier) = param_device_identifier {
                query_string.append_pair("deviceIdentifier",
                    &param_device_identifier.to_string());
            }
            if let Some(param_device_version) = param_device_version {
                query_string.append_pair("deviceVersion",
                    &param_device_version);
            }
            if let Some(param_start) = param_start {
                query_string.append_pair("start",
                    &param_start.to_string());
            }
            if let Some(param_limit) = param_limit {
                query_string.append_pair("limit",
                    &param_limit.to_string());
            }
            if let Some(param_include_audiences) = param_include_audiences {
                query_string.append_pair("includeAudiences",
                    &param_include_audiences.to_string());
            }
            if let Some(param_allocates_tickets) = param_allocates_tickets {
                query_string.append_pair("allocatesTickets",
                    &param_allocates_tickets.to_string());
            }
                query_string.append_pair("randomize",
                    &param_randomize.to_string());
                query_string.append_pair("targetedAdsOnly",
                    &param_targeted_ads_only.to_string());
            if let Some(param_mission_ids) = param_mission_ids {
                query_string.append_pair("missionIds",
                    &param_mission_ids);
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<Vec<models::MissionResponse>>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(AdsFindResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn create_creative(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_name: String,
        param_active: bool,
        param_wait_for_asset: bool,
        param_description: Option<String>,
        param_asset_image_id: Option<i64>,
        param_action: Option<String>,
        param_data: Option<String>,
        param_suffix: Option<String>,
        param_param_type: Option<String>,
        param_balance: Option<f64>,
        param_reference_id: Option<i64>,
        param_app_version: Option<String>,
        param_mission_id: Option<i64>,
        param_offer_id: Option<i64>,
        context: &C) -> Result<CreateCreativeResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/creative/create",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("name",
                    &param_name);
            if let Some(param_description) = param_description {
                query_string.append_pair("description",
                    &param_description);
            }
            if let Some(param_asset_image_id) = param_asset_image_id {
                query_string.append_pair("assetImageId",
                    &param_asset_image_id.to_string());
            }
            if let Some(param_action) = param_action {
                query_string.append_pair("action",
                    &param_action);
            }
            if let Some(param_data) = param_data {
                query_string.append_pair("data",
                    &param_data);
            }
            if let Some(param_suffix) = param_suffix {
                query_string.append_pair("suffix",
                    &param_suffix);
            }
            if let Some(param_param_type) = param_param_type {
                query_string.append_pair("type",
                    &param_param_type);
            }
            if let Some(param_balance) = param_balance {
                query_string.append_pair("balance",
                    &param_balance.to_string());
            }
                query_string.append_pair("active",
                    &param_active.to_string());
            if let Some(param_reference_id) = param_reference_id {
                query_string.append_pair("referenceId",
                    &param_reference_id.to_string());
            }
            if let Some(param_app_version) = param_app_version {
                query_string.append_pair("appVersion",
                    &param_app_version);
            }
            if let Some(param_mission_id) = param_mission_id {
                query_string.append_pair("missionId",
                    &param_mission_id.to_string());
            }
            if let Some(param_offer_id) = param_offer_id {
                query_string.append_pair("offerId",
                    &param_offer_id.to_string());
            }
                query_string.append_pair("waitForAsset",
                    &param_wait_for_asset.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::CreativeResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(CreateCreativeResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn delete_creative(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_creative_id: i64,
        context: &C) -> Result<DeleteCreativeResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/creative/delete",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("creativeId",
                    &param_creative_id.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(DeleteCreativeResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_creative(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_creative_id: i64,
        context: &C) -> Result<GetCreativeResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/creative/get",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("creativeId",
                    &param_creative_id.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::CreativeResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetCreativeResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_creatives_by_application(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_app_key: String,
        param_start: i32,
        param_limit: i32,
        param_mission_id: Option<i64>,
        param_keyword: Option<String>,
        context: &C) -> Result<GetCreativesByApplicationResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/creative/search",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("appKey",
                    &param_app_key);
            if let Some(param_mission_id) = param_mission_id {
                query_string.append_pair("missionId",
                    &param_mission_id.to_string());
            }
            if let Some(param_keyword) = param_keyword {
                query_string.append_pair("keyword",
                    &param_keyword);
            }
                query_string.append_pair("start",
                    &param_start.to_string());
                query_string.append_pair("limit",
                    &param_limit.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<Vec<models::CreativeResponse>>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetCreativesByApplicationResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn remove_preview(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_creative_id: i64,
        context: &C) -> Result<RemovePreviewResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/creative/removepreview",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("creativeId",
                    &param_creative_id.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(RemovePreviewResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn update_creative(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_creative_id: i64,
        param_name: Option<String>,
        param_description: Option<String>,
        param_asset_image_id: Option<i64>,
        param_action: Option<String>,
        param_data: Option<String>,
        param_suffix: Option<String>,
        param_param_type: Option<String>,
        param_balance: Option<f64>,
        param_active: Option<bool>,
        param_reference_id: Option<i64>,
        param_app_version: Option<String>,
        param_mission_id: Option<i64>,
        context: &C) -> Result<UpdateCreativeResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/creative/update",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("creativeId",
                    &param_creative_id.to_string());
            if let Some(param_name) = param_name {
                query_string.append_pair("name",
                    &param_name);
            }
            if let Some(param_description) = param_description {
                query_string.append_pair("description",
                    &param_description);
            }
            if let Some(param_asset_image_id) = param_asset_image_id {
                query_string.append_pair("assetImageId",
                    &param_asset_image_id.to_string());
            }
            if let Some(param_action) = param_action {
                query_string.append_pair("action",
                    &param_action);
            }
            if let Some(param_data) = param_data {
                query_string.append_pair("data",
                    &param_data);
            }
            if let Some(param_suffix) = param_suffix {
                query_string.append_pair("suffix",
                    &param_suffix);
            }
            if let Some(param_param_type) = param_param_type {
                query_string.append_pair("type",
                    &param_param_type);
            }
            if let Some(param_balance) = param_balance {
                query_string.append_pair("balance",
                    &param_balance.to_string());
            }
            if let Some(param_active) = param_active {
                query_string.append_pair("active",
                    &param_active.to_string());
            }
            if let Some(param_reference_id) = param_reference_id {
                query_string.append_pair("referenceId",
                    &param_reference_id.to_string());
            }
            if let Some(param_app_version) = param_app_version {
                query_string.append_pair("appVersion",
                    &param_app_version);
            }
            if let Some(param_mission_id) = param_mission_id {
                query_string.append_pair("missionId",
                    &param_mission_id.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::CreativeResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(UpdateCreativeResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn create(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_body: Option<models::Account>,
        context: &C) -> Result<CreateResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/cargo/dependent/{account_id}",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
            ,account_id=utf8_percent_encode(&param_account_id.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("PUT")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        // Consumes basic body
        // Body parameter
        if let Some(param_body) = param_body {
        let body = serde_json::to_string(&param_body).expect("impossible to fail to serialize");
        *request.body_mut() = body_from_string(body);
        }

        let header = "application/json";
        request.headers_mut().insert(CONTENT_TYPE, HeaderValue::from_static(header));

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(CreateResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_dependents(
        &self,
        param_version: f64,
        param_account_id: i64,
        context: &C) -> Result<GetDependentsResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/cargo/dependent/{account_id}",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
            ,account_id=utf8_percent_encode(&param_account_id.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetDependentsResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn remove_dependent(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_dependent_id: i64,
        context: &C) -> Result<RemoveDependentResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/cargo/dependent/{account_id}",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
            ,account_id=utf8_percent_encode(&param_account_id.to_string(), ID_ENCODE_SET)
            ,dependent_id=utf8_percent_encode(&param_dependent_id.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("DELETE")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            0 => {
                Ok(
                    RemoveDependentResponse::SuccessfulOperation
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn check_disbursements(
        &self,
        param_version: f64,
        param_disbursement_id: i64,
        context: &C) -> Result<CheckDisbursementsResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/disbursement/check",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("disbursementId",
                    &param_disbursement_id.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::DisbursementResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(CheckDisbursementsResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn create_disbursement(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_receiver_account_id: i64,
        param_original_sender_account_id: i64,
        param_amount: f64,
        param_provider: models::CreateDisbursementProviderParameter,
        param_scheduled_date: Option<i64>,
        param_title: Option<String>,
        param_comment: Option<String>,
        param_external_id: Option<String>,
        param_introspection_params: Option<String>,
        context: &C) -> Result<CreateDisbursementResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/disbursement/create",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("receiverAccountId",
                    &param_receiver_account_id.to_string());
                query_string.append_pair("originalSenderAccountId",
                    &param_original_sender_account_id.to_string());
                query_string.append_pair("amount",
                    &param_amount.to_string());
                query_string.append_pair("provider",
                    &param_provider.to_string());
            if let Some(param_scheduled_date) = param_scheduled_date {
                query_string.append_pair("scheduledDate",
                    &param_scheduled_date.to_string());
            }
            if let Some(param_title) = param_title {
                query_string.append_pair("title",
                    &param_title);
            }
            if let Some(param_comment) = param_comment {
                query_string.append_pair("comment",
                    &param_comment);
            }
            if let Some(param_external_id) = param_external_id {
                query_string.append_pair("externalId",
                    &param_external_id);
            }
            if let Some(param_introspection_params) = param_introspection_params {
                query_string.append_pair("introspectionParams",
                    &param_introspection_params);
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::DisbursementResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(CreateDisbursementResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_disbursement(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_disbursement_id: i64,
        context: &C) -> Result<GetDisbursementResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/disbursement/get",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("disbursementId",
                    &param_disbursement_id.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::DisbursementResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetDisbursementResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn search_disbursements(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_receiver_account_id: Option<i64>,
        param_statuses: Option<String>,
        param_providers: Option<String>,
        param_before_date: Option<i64>,
        param_after_date: Option<i64>,
        param_start: Option<i32>,
        param_limit: Option<i32>,
        param_active_only: Option<bool>,
        param_external_id: Option<String>,
        context: &C) -> Result<SearchDisbursementsResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/disbursement/search",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            if let Some(param_receiver_account_id) = param_receiver_account_id {
                query_string.append_pair("receiverAccountId",
                    &param_receiver_account_id.to_string());
            }
            if let Some(param_statuses) = param_statuses {
                query_string.append_pair("statuses",
                    &param_statuses);
            }
            if let Some(param_providers) = param_providers {
                query_string.append_pair("providers",
                    &param_providers);
            }
            if let Some(param_before_date) = param_before_date {
                query_string.append_pair("beforeDate",
                    &param_before_date.to_string());
            }
            if let Some(param_after_date) = param_after_date {
                query_string.append_pair("afterDate",
                    &param_after_date.to_string());
            }
            if let Some(param_start) = param_start {
                query_string.append_pair("start",
                    &param_start.to_string());
            }
            if let Some(param_limit) = param_limit {
                query_string.append_pair("limit",
                    &param_limit.to_string());
            }
            if let Some(param_active_only) = param_active_only {
                query_string.append_pair("activeOnly",
                    &param_active_only.to_string());
            }
            if let Some(param_external_id) = param_external_id {
                query_string.append_pair("externalId",
                    &param_external_id);
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<Vec<models::DisbursementResponse>>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(SearchDisbursementsResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn update_disbursement(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_disbursement_id: i64,
        param_amount: Option<f64>,
        param_provider: Option<models::CreateDisbursementProviderParameter>,
        param_scheduled_date: Option<i64>,
        param_title: Option<String>,
        param_comment: Option<String>,
        param_external_id: Option<String>,
        param_retry: Option<bool>,
        param_introspection_params: Option<String>,
        context: &C) -> Result<UpdateDisbursementResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/disbursement/update",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("disbursementId",
                    &param_disbursement_id.to_string());
            if let Some(param_amount) = param_amount {
                query_string.append_pair("amount",
                    &param_amount.to_string());
            }
            if let Some(param_provider) = param_provider {
                query_string.append_pair("provider",
                    &param_provider.to_string());
            }
            if let Some(param_scheduled_date) = param_scheduled_date {
                query_string.append_pair("scheduledDate",
                    &param_scheduled_date.to_string());
            }
            if let Some(param_title) = param_title {
                query_string.append_pair("title",
                    &param_title);
            }
            if let Some(param_comment) = param_comment {
                query_string.append_pair("comment",
                    &param_comment);
            }
            if let Some(param_external_id) = param_external_id {
                query_string.append_pair("externalId",
                    &param_external_id);
            }
            if let Some(param_retry) = param_retry {
                query_string.append_pair("retry",
                    &param_retry.to_string());
            }
            if let Some(param_introspection_params) = param_introspection_params {
                query_string.append_pair("introspectionParams",
                    &param_introspection_params);
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::DisbursementResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(UpdateDisbursementResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn assign_employee(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_manager_account_id: i64,
        param_employee_account_id: i64,
        param_role: Option<String>,
        context: &C) -> Result<AssignEmployeeResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/employee/assign",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("managerAccountId",
                    &param_manager_account_id.to_string());
                query_string.append_pair("employeeAccountId",
                    &param_employee_account_id.to_string());
            if let Some(param_role) = param_role {
                query_string.append_pair("role",
                    &param_role);
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::EmployeeResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(AssignEmployeeResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn assign_to_location_employee(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_retailer_location_id: i64,
        param_employee_account_id: Option<i64>,
        param_assign: Option<bool>,
        context: &C) -> Result<AssignToLocationEmployeeResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/employee/assignToLocation",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            if let Some(param_employee_account_id) = param_employee_account_id {
                query_string.append_pair("employeeAccountId",
                    &param_employee_account_id.to_string());
            }
                query_string.append_pair("retailerLocationId",
                    &param_retailer_location_id.to_string());
            if let Some(param_assign) = param_assign {
                query_string.append_pair("assign",
                    &param_assign.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(AssignToLocationEmployeeResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn create_employee(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_manager_account_id: i64,
        param_username: String,
        param_password: String,
        param_name: Option<String>,
        param_prefix_name: Option<String>,
        param_first_name: Option<String>,
        param_middle_name: Option<String>,
        param_last_name: Option<String>,
        param_suffix_name: Option<String>,
        param_title: Option<String>,
        param_about_us: Option<String>,
        param_asset_id: Option<i64>,
        param_gender: Option<models::SearchAccountsGenderParameter>,
        param_home_phone: Option<String>,
        param_cell_phone: Option<String>,
        param_cell_phone_carrier: Option<String>,
        param_business_phone: Option<String>,
        param_email_address: Option<String>,
        param_street_address: Option<String>,
        param_street_address2: Option<String>,
        param_city: Option<String>,
        param_state: Option<String>,
        param_zipcode: Option<String>,
        param_country: Option<String>,
        param_role: Option<String>,
        param_retailer_location_ids: Option<String>,
        param_settings_app_key: Option<String>,
        param_app_blob: Option<String>,
        param_assigned_device_id: Option<String>,
        context: &C) -> Result<CreateEmployeeResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/employee/create",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("managerAccountId",
                    &param_manager_account_id.to_string());
                query_string.append_pair("username",
                    &param_username);
                query_string.append_pair("password",
                    &param_password);
            if let Some(param_name) = param_name {
                query_string.append_pair("name",
                    &param_name);
            }
            if let Some(param_prefix_name) = param_prefix_name {
                query_string.append_pair("prefixName",
                    &param_prefix_name);
            }
            if let Some(param_first_name) = param_first_name {
                query_string.append_pair("firstName",
                    &param_first_name);
            }
            if let Some(param_middle_name) = param_middle_name {
                query_string.append_pair("middleName",
                    &param_middle_name);
            }
            if let Some(param_last_name) = param_last_name {
                query_string.append_pair("lastName",
                    &param_last_name);
            }
            if let Some(param_suffix_name) = param_suffix_name {
                query_string.append_pair("suffixName",
                    &param_suffix_name);
            }
            if let Some(param_title) = param_title {
                query_string.append_pair("title",
                    &param_title);
            }
            if let Some(param_about_us) = param_about_us {
                query_string.append_pair("aboutUs",
                    &param_about_us);
            }
            if let Some(param_asset_id) = param_asset_id {
                query_string.append_pair("assetId",
                    &param_asset_id.to_string());
            }
            if let Some(param_gender) = param_gender {
                query_string.append_pair("gender",
                    &param_gender.to_string());
            }
            if let Some(param_home_phone) = param_home_phone {
                query_string.append_pair("homePhone",
                    &param_home_phone);
            }
            if let Some(param_cell_phone) = param_cell_phone {
                query_string.append_pair("cellPhone",
                    &param_cell_phone);
            }
            if let Some(param_cell_phone_carrier) = param_cell_phone_carrier {
                query_string.append_pair("cellPhoneCarrier",
                    &param_cell_phone_carrier);
            }
            if let Some(param_business_phone) = param_business_phone {
                query_string.append_pair("businessPhone",
                    &param_business_phone);
            }
            if let Some(param_email_address) = param_email_address {
                query_string.append_pair("emailAddress",
                    &param_email_address);
            }
            if let Some(param_street_address) = param_street_address {
                query_string.append_pair("streetAddress",
                    &param_street_address);
            }
            if let Some(param_street_address2) = param_street_address2 {
                query_string.append_pair("streetAddress2",
                    &param_street_address2);
            }
            if let Some(param_city) = param_city {
                query_string.append_pair("city",
                    &param_city);
            }
            if let Some(param_state) = param_state {
                query_string.append_pair("state",
                    &param_state);
            }
            if let Some(param_zipcode) = param_zipcode {
                query_string.append_pair("zipcode",
                    &param_zipcode);
            }
            if let Some(param_country) = param_country {
                query_string.append_pair("country",
                    &param_country);
            }
            if let Some(param_role) = param_role {
                query_string.append_pair("role",
                    &param_role);
            }
            if let Some(param_retailer_location_ids) = param_retailer_location_ids {
                query_string.append_pair("retailerLocationIds",
                    &param_retailer_location_ids);
            }
            if let Some(param_settings_app_key) = param_settings_app_key {
                query_string.append_pair("settingsAppKey",
                    &param_settings_app_key);
            }
            if let Some(param_app_blob) = param_app_blob {
                query_string.append_pair("appBlob",
                    &param_app_blob);
            }
            if let Some(param_assigned_device_id) = param_assigned_device_id {
                query_string.append_pair("assignedDeviceId",
                    &param_assigned_device_id);
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::EmployeeResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(CreateEmployeeResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn delete_employee(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_employee_account_id: i64,
        context: &C) -> Result<DeleteEmployeeResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/employee/delete",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("employeeAccountId",
                    &param_employee_account_id.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(DeleteEmployeeResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_employee(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_employee_account_id: i64,
        param_settings_app_key: Option<String>,
        context: &C) -> Result<GetEmployeeResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/employee/get",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("employeeAccountId",
                    &param_employee_account_id.to_string());
            if let Some(param_settings_app_key) = param_settings_app_key {
                query_string.append_pair("settingsAppKey",
                    &param_settings_app_key);
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::EmployeeResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetEmployeeResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn search_employees(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_role: Option<String>,
        param_retailer_id: Option<i64>,
        param_retailer_location_id: Option<i64>,
        param_q: Option<String>,
        param_keyword: Option<String>,
        param_sort_field: Option<models::SearchEmployeesSortFieldParameter>,
        param_descending: Option<bool>,
        param__i: Option<i32>,
        param_start: Option<i32>,
        param__l: Option<i32>,
        param_limit: Option<i32>,
        param_active_only: Option<bool>,
        param_managed_only: Option<bool>,
        param_settings_app_key: Option<String>,
        param_category_ids: Option<String>,
        param_query: Option<String>,
        context: &C) -> Result<SearchEmployeesResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/employee/search",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            if let Some(param_role) = param_role {
                query_string.append_pair("role",
                    &param_role);
            }
            if let Some(param_retailer_id) = param_retailer_id {
                query_string.append_pair("retailerId",
                    &param_retailer_id.to_string());
            }
            if let Some(param_retailer_location_id) = param_retailer_location_id {
                query_string.append_pair("retailerLocationId",
                    &param_retailer_location_id.to_string());
            }
            if let Some(param_q) = param_q {
                query_string.append_pair("q",
                    &param_q);
            }
            if let Some(param_keyword) = param_keyword {
                query_string.append_pair("keyword",
                    &param_keyword);
            }
            if let Some(param_sort_field) = param_sort_field {
                query_string.append_pair("sortField",
                    &param_sort_field.to_string());
            }
            if let Some(param_descending) = param_descending {
                query_string.append_pair("descending",
                    &param_descending.to_string());
            }
            if let Some(param__i) = param__i {
                query_string.append_pair("_i",
                    &param__i.to_string());
            }
            if let Some(param_start) = param_start {
                query_string.append_pair("start",
                    &param_start.to_string());
            }
            if let Some(param__l) = param__l {
                query_string.append_pair("_l",
                    &param__l.to_string());
            }
            if let Some(param_limit) = param_limit {
                query_string.append_pair("limit",
                    &param_limit.to_string());
            }
            if let Some(param_active_only) = param_active_only {
                query_string.append_pair("activeOnly",
                    &param_active_only.to_string());
            }
            if let Some(param_managed_only) = param_managed_only {
                query_string.append_pair("managedOnly",
                    &param_managed_only.to_string());
            }
            if let Some(param_settings_app_key) = param_settings_app_key {
                query_string.append_pair("settingsAppKey",
                    &param_settings_app_key);
            }
            if let Some(param_category_ids) = param_category_ids {
                query_string.append_pair("categoryIds",
                    &param_category_ids);
            }
            if let Some(param_query) = param_query {
                query_string.append_pair("query",
                    &param_query);
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<Vec<models::EmployeeResponse>>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(SearchEmployeesResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn unassign_employee(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_employee_account_id: i64,
        context: &C) -> Result<UnassignEmployeeResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/employee/unassign",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("employeeAccountId",
                    &param_employee_account_id.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::EmployeeResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(UnassignEmployeeResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn update_employee(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_employee_account_id: i64,
        param_manager_account_id: Option<i64>,
        param_name: Option<String>,
        param_prefix_name: Option<String>,
        param_first_name: Option<String>,
        param_middle_name: Option<String>,
        param_last_name: Option<String>,
        param_suffix_name: Option<String>,
        param_title: Option<String>,
        param_asset_id: Option<i64>,
        param_gender: Option<models::SearchAccountsGenderParameter>,
        param_home_phone: Option<String>,
        param_cell_phone: Option<String>,
        param_cell_phone_carrier: Option<String>,
        param_business_phone: Option<String>,
        param_email_address: Option<String>,
        param_street_address: Option<String>,
        param_street_address2: Option<String>,
        param_city: Option<String>,
        param_state: Option<String>,
        param_zipcode: Option<String>,
        param_country: Option<String>,
        param_role: Option<String>,
        param_active: Option<bool>,
        param_password: Option<String>,
        param_retailer_location_ids: Option<String>,
        param_settings_app_key: Option<String>,
        param_app_blob: Option<String>,
        param_assigned_device_id: Option<String>,
        context: &C) -> Result<UpdateEmployeeResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/employee/update",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("employeeAccountId",
                    &param_employee_account_id.to_string());
            if let Some(param_manager_account_id) = param_manager_account_id {
                query_string.append_pair("managerAccountId",
                    &param_manager_account_id.to_string());
            }
            if let Some(param_name) = param_name {
                query_string.append_pair("name",
                    &param_name);
            }
            if let Some(param_prefix_name) = param_prefix_name {
                query_string.append_pair("prefixName",
                    &param_prefix_name);
            }
            if let Some(param_first_name) = param_first_name {
                query_string.append_pair("firstName",
                    &param_first_name);
            }
            if let Some(param_middle_name) = param_middle_name {
                query_string.append_pair("middleName",
                    &param_middle_name);
            }
            if let Some(param_last_name) = param_last_name {
                query_string.append_pair("lastName",
                    &param_last_name);
            }
            if let Some(param_suffix_name) = param_suffix_name {
                query_string.append_pair("suffixName",
                    &param_suffix_name);
            }
            if let Some(param_title) = param_title {
                query_string.append_pair("title",
                    &param_title);
            }
            if let Some(param_asset_id) = param_asset_id {
                query_string.append_pair("assetId",
                    &param_asset_id.to_string());
            }
            if let Some(param_gender) = param_gender {
                query_string.append_pair("gender",
                    &param_gender.to_string());
            }
            if let Some(param_home_phone) = param_home_phone {
                query_string.append_pair("homePhone",
                    &param_home_phone);
            }
            if let Some(param_cell_phone) = param_cell_phone {
                query_string.append_pair("cellPhone",
                    &param_cell_phone);
            }
            if let Some(param_cell_phone_carrier) = param_cell_phone_carrier {
                query_string.append_pair("cellPhoneCarrier",
                    &param_cell_phone_carrier);
            }
            if let Some(param_business_phone) = param_business_phone {
                query_string.append_pair("businessPhone",
                    &param_business_phone);
            }
            if let Some(param_email_address) = param_email_address {
                query_string.append_pair("emailAddress",
                    &param_email_address);
            }
            if let Some(param_street_address) = param_street_address {
                query_string.append_pair("streetAddress",
                    &param_street_address);
            }
            if let Some(param_street_address2) = param_street_address2 {
                query_string.append_pair("streetAddress2",
                    &param_street_address2);
            }
            if let Some(param_city) = param_city {
                query_string.append_pair("city",
                    &param_city);
            }
            if let Some(param_state) = param_state {
                query_string.append_pair("state",
                    &param_state);
            }
            if let Some(param_zipcode) = param_zipcode {
                query_string.append_pair("zipcode",
                    &param_zipcode);
            }
            if let Some(param_country) = param_country {
                query_string.append_pair("country",
                    &param_country);
            }
            if let Some(param_role) = param_role {
                query_string.append_pair("role",
                    &param_role);
            }
            if let Some(param_active) = param_active {
                query_string.append_pair("active",
                    &param_active.to_string());
            }
            if let Some(param_password) = param_password {
                query_string.append_pair("password",
                    &param_password);
            }
            if let Some(param_retailer_location_ids) = param_retailer_location_ids {
                query_string.append_pair("retailerLocationIds",
                    &param_retailer_location_ids);
            }
            if let Some(param_settings_app_key) = param_settings_app_key {
                query_string.append_pair("settingsAppKey",
                    &param_settings_app_key);
            }
            if let Some(param_app_blob) = param_app_blob {
                query_string.append_pair("appBlob",
                    &param_app_blob);
            }
            if let Some(param_assigned_device_id) = param_assigned_device_id {
                query_string.append_pair("assignedDeviceId",
                    &param_assigned_device_id);
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::EmployeeResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(UpdateEmployeeResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn attend_event(
        &self,
        param_version: f64,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_app_key: Option<String>,
        param_listing_id: Option<i64>,
        param_retailer_location_id: Option<i64>,
        param_offer_location_id: Option<i64>,
        param_transaction_id: Option<i64>,
        param_status: Option<i32>,
        param_latitude: Option<f64>,
        param_longitude: Option<f64>,
        context: &C) -> Result<AttendEventResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/event/attend",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_app_key) = param_app_key {
                query_string.append_pair("appKey",
                    &param_app_key);
            }
            if let Some(param_listing_id) = param_listing_id {
                query_string.append_pair("listingId",
                    &param_listing_id.to_string());
            }
            if let Some(param_retailer_location_id) = param_retailer_location_id {
                query_string.append_pair("retailerLocationId",
                    &param_retailer_location_id.to_string());
            }
            if let Some(param_offer_location_id) = param_offer_location_id {
                query_string.append_pair("offerLocationId",
                    &param_offer_location_id.to_string());
            }
            if let Some(param_transaction_id) = param_transaction_id {
                query_string.append_pair("transactionId",
                    &param_transaction_id.to_string());
            }
            if let Some(param_status) = param_status {
                query_string.append_pair("status",
                    &param_status.to_string());
            }
            if let Some(param_latitude) = param_latitude {
                query_string.append_pair("latitude",
                    &param_latitude.to_string());
            }
            if let Some(param_longitude) = param_longitude {
                query_string.append_pair("longitude",
                    &param_longitude.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::OfferResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(AttendEventResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn create_event(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_title: String,
        param_retailer_location_ids: Option<String>,
        param_sub_title: Option<String>,
        param_details: Option<String>,
        param_category_ids: Option<String>,
        param_filter_ids: Option<String>,
        param_active: Option<bool>,
        param_image_asset_id: Option<i64>,
        param_redeemable_start: Option<i64>,
        param_redeemable_end: Option<i64>,
        param_meta_data: Option<String>,
        context: &C) -> Result<CreateEventResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/event/create",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            if let Some(param_retailer_location_ids) = param_retailer_location_ids {
                query_string.append_pair("retailerLocationIds",
                    &param_retailer_location_ids);
            }
                query_string.append_pair("title",
                    &param_title);
            if let Some(param_sub_title) = param_sub_title {
                query_string.append_pair("subTitle",
                    &param_sub_title);
            }
            if let Some(param_details) = param_details {
                query_string.append_pair("details",
                    &param_details);
            }
            if let Some(param_category_ids) = param_category_ids {
                query_string.append_pair("categoryIds",
                    &param_category_ids);
            }
            if let Some(param_filter_ids) = param_filter_ids {
                query_string.append_pair("filterIds",
                    &param_filter_ids);
            }
            if let Some(param_active) = param_active {
                query_string.append_pair("active",
                    &param_active.to_string());
            }
            if let Some(param_image_asset_id) = param_image_asset_id {
                query_string.append_pair("imageAssetId",
                    &param_image_asset_id.to_string());
            }
            if let Some(param_redeemable_start) = param_redeemable_start {
                query_string.append_pair("redeemableStart",
                    &param_redeemable_start.to_string());
            }
            if let Some(param_redeemable_end) = param_redeemable_end {
                query_string.append_pair("redeemableEnd",
                    &param_redeemable_end.to_string());
            }
            if let Some(param_meta_data) = param_meta_data {
                query_string.append_pair("metaData",
                    &param_meta_data);
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::OfferResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(CreateEventResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn delete_event(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_event_id: i64,
        context: &C) -> Result<DeleteEventResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/event/delete",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("eventId",
                    &param_event_id.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(DeleteEventResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_event(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_event_id: i64,
        context: &C) -> Result<GetEventResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/event/get",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("eventId",
                    &param_event_id.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::OfferResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetEventResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn search_event_transactions(
        &self,
        param_version: f64,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_app_key: Option<String>,
        param_keyword: Option<String>,
        param_retailer_id: Option<i64>,
        param_retailer_location_id: Option<i64>,
        param_exclude_retailer_location_id: Option<i64>,
        param_listing_id: Option<i64>,
        param_offer_id: Option<i64>,
        param_offer_location_id: Option<i64>,
        param_customer_account_ids: Option<String>,
        param_affiliated_category_ids: Option<String>,
        param_start_date: Option<i64>,
        param_end_date: Option<i64>,
        param_statuses: Option<String>,
        param_sort_field: Option<models::SearchEventTransactionsSortFieldParameter>,
        param_descending: Option<bool>,
        param_start: Option<i32>,
        param_limit: Option<i32>,
        context: &C) -> Result<SearchEventTransactionsResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/event/attendance/search",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_app_key) = param_app_key {
                query_string.append_pair("appKey",
                    &param_app_key);
            }
            if let Some(param_keyword) = param_keyword {
                query_string.append_pair("keyword",
                    &param_keyword);
            }
            if let Some(param_retailer_id) = param_retailer_id {
                query_string.append_pair("retailerId",
                    &param_retailer_id.to_string());
            }
            if let Some(param_retailer_location_id) = param_retailer_location_id {
                query_string.append_pair("retailerLocationId",
                    &param_retailer_location_id.to_string());
            }
            if let Some(param_exclude_retailer_location_id) = param_exclude_retailer_location_id {
                query_string.append_pair("excludeRetailerLocationId",
                    &param_exclude_retailer_location_id.to_string());
            }
            if let Some(param_listing_id) = param_listing_id {
                query_string.append_pair("listingId",
                    &param_listing_id.to_string());
            }
            if let Some(param_offer_id) = param_offer_id {
                query_string.append_pair("offerId",
                    &param_offer_id.to_string());
            }
            if let Some(param_offer_location_id) = param_offer_location_id {
                query_string.append_pair("offerLocationId",
                    &param_offer_location_id.to_string());
            }
            if let Some(param_customer_account_ids) = param_customer_account_ids {
                query_string.append_pair("customerAccountIds",
                    &param_customer_account_ids);
            }
            if let Some(param_affiliated_category_ids) = param_affiliated_category_ids {
                query_string.append_pair("affiliatedCategoryIds",
                    &param_affiliated_category_ids);
            }
            if let Some(param_start_date) = param_start_date {
                query_string.append_pair("startDate",
                    &param_start_date.to_string());
            }
            if let Some(param_end_date) = param_end_date {
                query_string.append_pair("endDate",
                    &param_end_date.to_string());
            }
            if let Some(param_statuses) = param_statuses {
                query_string.append_pair("statuses",
                    &param_statuses);
            }
            if let Some(param_sort_field) = param_sort_field {
                query_string.append_pair("sortField",
                    &param_sort_field.to_string());
            }
            if let Some(param_descending) = param_descending {
                query_string.append_pair("descending",
                    &param_descending.to_string());
            }
            if let Some(param_start) = param_start {
                query_string.append_pair("start",
                    &param_start.to_string());
            }
            if let Some(param_limit) = param_limit {
                query_string.append_pair("limit",
                    &param_limit.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<Vec<models::EventAttendanceResponse>>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(SearchEventTransactionsResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn search_events(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_keyword: Option<String>,
        param_active_only: Option<bool>,
        param_category_ids: Option<String>,
        param_filter_ids: Option<String>,
        param_offer_audience_ids: Option<String>,
        param_transaction_audience_ids: Option<String>,
        param_sort_field: Option<models::SearchEventsSortFieldParameter>,
        param_descending: Option<bool>,
        param_start_date: Option<i64>,
        param_end_date: Option<i64>,
        param_start: Option<i32>,
        param_limit: Option<i32>,
        context: &C) -> Result<SearchEventsResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/event/search",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            if let Some(param_keyword) = param_keyword {
                query_string.append_pair("keyword",
                    &param_keyword);
            }
            if let Some(param_active_only) = param_active_only {
                query_string.append_pair("activeOnly",
                    &param_active_only.to_string());
            }
            if let Some(param_category_ids) = param_category_ids {
                query_string.append_pair("categoryIds",
                    &param_category_ids);
            }
            if let Some(param_filter_ids) = param_filter_ids {
                query_string.append_pair("filterIds",
                    &param_filter_ids);
            }
            if let Some(param_offer_audience_ids) = param_offer_audience_ids {
                query_string.append_pair("offerAudienceIds",
                    &param_offer_audience_ids);
            }
            if let Some(param_transaction_audience_ids) = param_transaction_audience_ids {
                query_string.append_pair("transactionAudienceIds",
                    &param_transaction_audience_ids);
            }
            if let Some(param_sort_field) = param_sort_field {
                query_string.append_pair("sortField",
                    &param_sort_field.to_string());
            }
            if let Some(param_descending) = param_descending {
                query_string.append_pair("descending",
                    &param_descending.to_string());
            }
            if let Some(param_start_date) = param_start_date {
                query_string.append_pair("startDate",
                    &param_start_date.to_string());
            }
            if let Some(param_end_date) = param_end_date {
                query_string.append_pair("endDate",
                    &param_end_date.to_string());
            }
            if let Some(param_start) = param_start {
                query_string.append_pair("start",
                    &param_start.to_string());
            }
            if let Some(param_limit) = param_limit {
                query_string.append_pair("limit",
                    &param_limit.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<Vec<models::OfferShortResponse>>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(SearchEventsResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn update_event(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_event_id: i64,
        param_retailer_location_ids: Option<String>,
        param_title: Option<String>,
        param_sub_title: Option<String>,
        param_details: Option<String>,
        param_category_ids: Option<String>,
        param_filter_ids: Option<String>,
        param_active: Option<bool>,
        param_image_asset_id: Option<i64>,
        param_redeemable_start: Option<i64>,
        param_redeemable_end: Option<i64>,
        context: &C) -> Result<UpdateEventResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/event/update",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("eventId",
                    &param_event_id.to_string());
            if let Some(param_retailer_location_ids) = param_retailer_location_ids {
                query_string.append_pair("retailerLocationIds",
                    &param_retailer_location_ids);
            }
            if let Some(param_title) = param_title {
                query_string.append_pair("title",
                    &param_title);
            }
            if let Some(param_sub_title) = param_sub_title {
                query_string.append_pair("subTitle",
                    &param_sub_title);
            }
            if let Some(param_details) = param_details {
                query_string.append_pair("details",
                    &param_details);
            }
            if let Some(param_category_ids) = param_category_ids {
                query_string.append_pair("categoryIds",
                    &param_category_ids);
            }
            if let Some(param_filter_ids) = param_filter_ids {
                query_string.append_pair("filterIds",
                    &param_filter_ids);
            }
            if let Some(param_active) = param_active {
                query_string.append_pair("active",
                    &param_active.to_string());
            }
            if let Some(param_image_asset_id) = param_image_asset_id {
                query_string.append_pair("imageAssetId",
                    &param_image_asset_id.to_string());
            }
            if let Some(param_redeemable_start) = param_redeemable_start {
                query_string.append_pair("redeemableStart",
                    &param_redeemable_start.to_string());
            }
            if let Some(param_redeemable_end) = param_redeemable_end {
                query_string.append_pair("redeemableEnd",
                    &param_redeemable_end.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::OfferResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(UpdateEventResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_token(
        &self,
        param_version: f64,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_latitude: Option<f64>,
        param_longitude: Option<f64>,
        context: &C) -> Result<GetTokenResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/facebook/getfbtoken",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_latitude) = param_latitude {
                query_string.append_pair("latitude",
                    &param_latitude.to_string());
            }
            if let Some(param_longitude) = param_longitude {
                query_string.append_pair("longitude",
                    &param_longitude.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::TokenResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetTokenResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn graph_interface(
        &self,
        param_version: f64,
        param_event: String,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_permissionable_type: Option<String>,
        param_permissionable_id: Option<i64>,
        param_asset_id: Option<i64>,
        param_game_type: Option<String>,
        param_app_key: Option<String>,
        param_latitude: Option<f64>,
        param_longitude: Option<f64>,
        context: &C) -> Result<GraphInterfaceResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/facebook/graph",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
                query_string.append_pair("event",
                    &param_event);
            if let Some(param_permissionable_type) = param_permissionable_type {
                query_string.append_pair("permissionableType",
                    &param_permissionable_type);
            }
            if let Some(param_permissionable_id) = param_permissionable_id {
                query_string.append_pair("permissionableId",
                    &param_permissionable_id.to_string());
            }
            if let Some(param_asset_id) = param_asset_id {
                query_string.append_pair("assetId",
                    &param_asset_id.to_string());
            }
            if let Some(param_game_type) = param_game_type {
                query_string.append_pair("gameType",
                    &param_game_type);
            }
            if let Some(param_app_key) = param_app_key {
                query_string.append_pair("appKey",
                    &param_app_key);
            }
            if let Some(param_latitude) = param_latitude {
                query_string.append_pair("latitude",
                    &param_latitude.to_string());
            }
            if let Some(param_longitude) = param_longitude {
                query_string.append_pair("longitude",
                    &param_longitude.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GraphInterfaceResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn add_favorite(
        &self,
        param_version: f64,
        param_favoritable_id: i64,
        param_favoritable_type: String,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_latitude: Option<f64>,
        param_longitude: Option<f64>,
        context: &C) -> Result<AddFavoriteResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/favorite/create",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
                query_string.append_pair("favoritableId",
                    &param_favoritable_id.to_string());
                query_string.append_pair("favoritableType",
                    &param_favoritable_type);
            if let Some(param_latitude) = param_latitude {
                query_string.append_pair("latitude",
                    &param_latitude.to_string());
            }
            if let Some(param_longitude) = param_longitude {
                query_string.append_pair("longitude",
                    &param_longitude.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::WrappedResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(AddFavoriteResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn delete_favorite(
        &self,
        param_version: f64,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_favorite_id: Option<i64>,
        param_favoritable_id: Option<i64>,
        param_favoritable_type: Option<String>,
        context: &C) -> Result<DeleteFavoriteResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/favorite/delete",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_favorite_id) = param_favorite_id {
                query_string.append_pair("favoriteId",
                    &param_favorite_id.to_string());
            }
            if let Some(param_favoritable_id) = param_favoritable_id {
                query_string.append_pair("favoritableId",
                    &param_favoritable_id.to_string());
            }
            if let Some(param_favoritable_type) = param_favoritable_type {
                query_string.append_pair("favoritableType",
                    &param_favoritable_type);
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(DeleteFavoriteResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_favorite(
        &self,
        param_version: f64,
        param_favorite_id: i64,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_latitude: Option<f64>,
        param_longitude: Option<f64>,
        context: &C) -> Result<GetFavoriteResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/favorite/get",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
                query_string.append_pair("favoriteId",
                    &param_favorite_id.to_string());
            if let Some(param_latitude) = param_latitude {
                query_string.append_pair("latitude",
                    &param_latitude.to_string());
            }
            if let Some(param_longitude) = param_longitude {
                query_string.append_pair("longitude",
                    &param_longitude.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::WrappedResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetFavoriteResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn search_favorites(
        &self,
        param_version: f64,
        param_favoritable_type: String,
        param_sort_field: models::SearchFavoritesSortFieldParameter,
        param_descending: bool,
        param_start: i32,
        param_limit: i32,
        param_active_only: bool,
        param_return_full_response: bool,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_connection_account_id: Option<i64>,
        param_secondary_type: Option<String>,
        param_keyword: Option<String>,
        param_latitude: Option<f64>,
        param_longitude: Option<f64>,
        context: &C) -> Result<SearchFavoritesResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/favorite/search",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_connection_account_id) = param_connection_account_id {
                query_string.append_pair("connectionAccountId",
                    &param_connection_account_id.to_string());
            }
                query_string.append_pair("favoritableType",
                    &param_favoritable_type);
            if let Some(param_secondary_type) = param_secondary_type {
                query_string.append_pair("secondaryType",
                    &param_secondary_type);
            }
            if let Some(param_keyword) = param_keyword {
                query_string.append_pair("keyword",
                    &param_keyword);
            }
                query_string.append_pair("sortField",
                    &param_sort_field.to_string());
                query_string.append_pair("descending",
                    &param_descending.to_string());
                query_string.append_pair("start",
                    &param_start.to_string());
                query_string.append_pair("limit",
                    &param_limit.to_string());
                query_string.append_pair("activeOnly",
                    &param_active_only.to_string());
                query_string.append_pair("returnFullResponse",
                    &param_return_full_response.to_string());
            if let Some(param_latitude) = param_latitude {
                query_string.append_pair("latitude",
                    &param_latitude.to_string());
            }
            if let Some(param_longitude) = param_longitude {
                query_string.append_pair("longitude",
                    &param_longitude.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SearchResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(SearchFavoritesResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn who_has_favorited(
        &self,
        param_version: f64,
        param_favoritable_id: i64,
        param_favoritable_type: String,
        param_start: i32,
        param_limit: i32,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_latitude: Option<f64>,
        param_longitude: Option<f64>,
        param_keyword: Option<String>,
        context: &C) -> Result<WhoHasFavoritedResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/favorite/whois",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_latitude) = param_latitude {
                query_string.append_pair("latitude",
                    &param_latitude.to_string());
            }
            if let Some(param_longitude) = param_longitude {
                query_string.append_pair("longitude",
                    &param_longitude.to_string());
            }
                query_string.append_pair("favoritableId",
                    &param_favoritable_id.to_string());
                query_string.append_pair("favoritableType",
                    &param_favoritable_type);
            if let Some(param_keyword) = param_keyword {
                query_string.append_pair("keyword",
                    &param_keyword);
            }
                query_string.append_pair("start",
                    &param_start.to_string());
                query_string.append_pair("limit",
                    &param_limit.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<Vec<models::AccountResponse>>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(WhoHasFavoritedResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn create_filter(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_name: String,
        param_app_key: Option<String>,
        param_parent_filter_id: Option<i64>,
        param_description: Option<String>,
        param_external_id: Option<String>,
        param_external_type: Option<String>,
        param_active: Option<bool>,
        param_meta_data: Option<String>,
        context: &C) -> Result<CreateFilterResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/filter/create",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            if let Some(param_app_key) = param_app_key {
                query_string.append_pair("appKey",
                    &param_app_key);
            }
            if let Some(param_parent_filter_id) = param_parent_filter_id {
                query_string.append_pair("parentFilterId",
                    &param_parent_filter_id.to_string());
            }
                query_string.append_pair("name",
                    &param_name);
            if let Some(param_description) = param_description {
                query_string.append_pair("description",
                    &param_description);
            }
            if let Some(param_external_id) = param_external_id {
                query_string.append_pair("externalId",
                    &param_external_id);
            }
            if let Some(param_external_type) = param_external_type {
                query_string.append_pair("externalType",
                    &param_external_type);
            }
            if let Some(param_active) = param_active {
                query_string.append_pair("active",
                    &param_active.to_string());
            }
            if let Some(param_meta_data) = param_meta_data {
                query_string.append_pair("metaData",
                    &param_meta_data);
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::FilterTreeResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(CreateFilterResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn delete_filter(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_filter_id: i64,
        context: &C) -> Result<DeleteFilterResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/filter/delete",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("filterId",
                    &param_filter_id.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(DeleteFilterResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_filter(
        &self,
        param_version: f64,
        param_filter_id: i64,
        context: &C) -> Result<GetFilterResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/filter/get",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("filterId",
                    &param_filter_id.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::FilterTreeResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetFilterResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn search_filters(
        &self,
        param_version: f64,
        param_account_id: Option<i64>,
        param_keyword: Option<String>,
        param_app_key: Option<String>,
        param_response_group: Option<models::SearchCategoriesResponseGroupParameter>,
        param_root_only: Option<bool>,
        param_sort_field: Option<models::SearchCategoriesSortFieldParameter>,
        param_descending: Option<bool>,
        param_start: Option<i32>,
        param_limit: Option<i32>,
        param_active_only: Option<bool>,
        context: &C) -> Result<SearchFiltersResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/filter/search",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_keyword) = param_keyword {
                query_string.append_pair("keyword",
                    &param_keyword);
            }
            if let Some(param_app_key) = param_app_key {
                query_string.append_pair("appKey",
                    &param_app_key);
            }
            if let Some(param_response_group) = param_response_group {
                query_string.append_pair("responseGroup",
                    &param_response_group.to_string());
            }
            if let Some(param_root_only) = param_root_only {
                query_string.append_pair("rootOnly",
                    &param_root_only.to_string());
            }
            if let Some(param_sort_field) = param_sort_field {
                query_string.append_pair("sortField",
                    &param_sort_field.to_string());
            }
            if let Some(param_descending) = param_descending {
                query_string.append_pair("descending",
                    &param_descending.to_string());
            }
            if let Some(param_start) = param_start {
                query_string.append_pair("start",
                    &param_start.to_string());
            }
            if let Some(param_limit) = param_limit {
                query_string.append_pair("limit",
                    &param_limit.to_string());
            }
            if let Some(param_active_only) = param_active_only {
                query_string.append_pair("activeOnly",
                    &param_active_only.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<Vec<models::FilterResponse>>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(SearchFiltersResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn update_filter(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_filter_id: i64,
        param_parent_filter_id: Option<i64>,
        param_name: Option<String>,
        param_description: Option<String>,
        param_external_id: Option<String>,
        param_external_type: Option<String>,
        param_active: Option<bool>,
        param_meta_data: Option<String>,
        context: &C) -> Result<UpdateFilterResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/filter/update",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("filterId",
                    &param_filter_id.to_string());
            if let Some(param_parent_filter_id) = param_parent_filter_id {
                query_string.append_pair("parentFilterId",
                    &param_parent_filter_id.to_string());
            }
            if let Some(param_name) = param_name {
                query_string.append_pair("name",
                    &param_name);
            }
            if let Some(param_description) = param_description {
                query_string.append_pair("description",
                    &param_description);
            }
            if let Some(param_external_id) = param_external_id {
                query_string.append_pair("externalId",
                    &param_external_id);
            }
            if let Some(param_external_type) = param_external_type {
                query_string.append_pair("externalType",
                    &param_external_type);
            }
            if let Some(param_active) = param_active {
                query_string.append_pair("active",
                    &param_active.to_string());
            }
            if let Some(param_meta_data) = param_meta_data {
                query_string.append_pair("metaData",
                    &param_meta_data);
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::FilterTreeResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(UpdateFilterResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn create_flag(
        &self,
        param_version: f64,
        param_flagable_type: String,
        param_flagable_id: i64,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_flag_description: Option<String>,
        param_latitude: Option<f64>,
        param_longitude: Option<f64>,
        context: &C) -> Result<CreateFlagResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/flag/create",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
                query_string.append_pair("flagableType",
                    &param_flagable_type);
                query_string.append_pair("flagableId",
                    &param_flagable_id.to_string());
            if let Some(param_flag_description) = param_flag_description {
                query_string.append_pair("flagDescription",
                    &param_flag_description);
            }
            if let Some(param_latitude) = param_latitude {
                query_string.append_pair("latitude",
                    &param_latitude.to_string());
            }
            if let Some(param_longitude) = param_longitude {
                query_string.append_pair("longitude",
                    &param_longitude.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(CreateFlagResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn delete_flag(
        &self,
        param_version: f64,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_item_being_flagged_type: Option<String>,
        param_item_being_flagged_id: Option<i64>,
        param_flagable_type: Option<String>,
        param_flagable_id: Option<i64>,
        context: &C) -> Result<DeleteFlagResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/flag/delete",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_item_being_flagged_type) = param_item_being_flagged_type {
                query_string.append_pair("itemBeingFlaggedType",
                    &param_item_being_flagged_type);
            }
            if let Some(param_item_being_flagged_id) = param_item_being_flagged_id {
                query_string.append_pair("itemBeingFlaggedId",
                    &param_item_being_flagged_id.to_string());
            }
            if let Some(param_flagable_type) = param_flagable_type {
                query_string.append_pair("flagableType",
                    &param_flagable_type);
            }
            if let Some(param_flagable_id) = param_flagable_id {
                query_string.append_pair("flagableId",
                    &param_flagable_id.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(DeleteFlagResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_flag(
        &self,
        param_version: f64,
        param_flagable_type: String,
        param_flagable_id: i64,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_latitude: Option<f64>,
        param_longitude: Option<f64>,
        context: &C) -> Result<GetFlagResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/flag/get",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
                query_string.append_pair("flagableType",
                    &param_flagable_type);
                query_string.append_pair("flagableId",
                    &param_flagable_id.to_string());
            if let Some(param_latitude) = param_latitude {
                query_string.append_pair("latitude",
                    &param_latitude.to_string());
            }
            if let Some(param_longitude) = param_longitude {
                query_string.append_pair("longitude",
                    &param_longitude.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::FlagResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetFlagResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_flag_threshold(
        &self,
        param_version: f64,
        param_item_being_flagged_type: String,
        param_app_key: String,
        context: &C) -> Result<GetFlagThresholdResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/flag/threshold/get",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("itemBeingFlaggedType",
                    &param_item_being_flagged_type);
                query_string.append_pair("appKey",
                    &param_app_key);
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::CountResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetFlagThresholdResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn update_flag_threshold(
        &self,
        param_version: f64,
        param_item_being_flagged_type: String,
        param_threshold: i64,
        param_app_key: String,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        context: &C) -> Result<UpdateFlagThresholdResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/flag/threshold/update",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
                query_string.append_pair("itemBeingFlaggedType",
                    &param_item_being_flagged_type);
                query_string.append_pair("threshold",
                    &param_threshold.to_string());
                query_string.append_pair("appKey",
                    &param_app_key);
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::CountResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(UpdateFlagThresholdResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn create_game(
        &self,
        param_version: f64,
        param_account_id: Option<i64>,
        param_app_key: Option<String>,
        param_title: Option<String>,
        param_description: Option<String>,
        param_meta_data: Option<String>,
        param_pack_ids: Option<String>,
        param_include_game_data: Option<bool>,
        context: &C) -> Result<CreateGameResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/game/create",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_app_key) = param_app_key {
                query_string.append_pair("appKey",
                    &param_app_key);
            }
            if let Some(param_title) = param_title {
                query_string.append_pair("title",
                    &param_title);
            }
            if let Some(param_description) = param_description {
                query_string.append_pair("description",
                    &param_description);
            }
            if let Some(param_meta_data) = param_meta_data {
                query_string.append_pair("metaData",
                    &param_meta_data);
            }
            if let Some(param_pack_ids) = param_pack_ids {
                query_string.append_pair("packIds",
                    &param_pack_ids);
            }
            if let Some(param_include_game_data) = param_include_game_data {
                query_string.append_pair("includeGameData",
                    &param_include_game_data.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::GameResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(CreateGameResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn delete_game(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_game_id: i64,
        context: &C) -> Result<DeleteGameResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/game/delete",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("gameId",
                    &param_game_id.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(DeleteGameResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_game(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_game_id: i64,
        param_include_game_data: Option<bool>,
        context: &C) -> Result<GetGameResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/game/get",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("gameId",
                    &param_game_id.to_string());
            if let Some(param_include_game_data) = param_include_game_data {
                query_string.append_pair("includeGameData",
                    &param_include_game_data.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::GameResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetGameResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn search_games(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_app_key: String,
        param_start: i32,
        param_limit: i32,
        param_keyword: Option<String>,
        param_app_version: Option<String>,
        param_include_game_data: Option<bool>,
        param_include_inactive: Option<bool>,
        context: &C) -> Result<SearchGamesResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/game/search",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("appKey",
                    &param_app_key);
            if let Some(param_keyword) = param_keyword {
                query_string.append_pair("keyword",
                    &param_keyword);
            }
                query_string.append_pair("start",
                    &param_start.to_string());
                query_string.append_pair("limit",
                    &param_limit.to_string());
            if let Some(param_app_version) = param_app_version {
                query_string.append_pair("appVersion",
                    &param_app_version);
            }
            if let Some(param_include_game_data) = param_include_game_data {
                query_string.append_pair("includeGameData",
                    &param_include_game_data.to_string());
            }
            if let Some(param_include_inactive) = param_include_inactive {
                query_string.append_pair("includeInactive",
                    &param_include_inactive.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::GameResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(SearchGamesResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn update_game(
        &self,
        param_version: f64,
        param_account_id: Option<i64>,
        param_game_id: Option<i64>,
        param_app_key: Option<String>,
        param_title: Option<String>,
        param_description: Option<String>,
        param_meta_data: Option<String>,
        param_pack_ids: Option<String>,
        param_include_game_data: Option<bool>,
        context: &C) -> Result<UpdateGameResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/game/update",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_game_id) = param_game_id {
                query_string.append_pair("gameId",
                    &param_game_id.to_string());
            }
            if let Some(param_app_key) = param_app_key {
                query_string.append_pair("appKey",
                    &param_app_key);
            }
            if let Some(param_title) = param_title {
                query_string.append_pair("title",
                    &param_title);
            }
            if let Some(param_description) = param_description {
                query_string.append_pair("description",
                    &param_description);
            }
            if let Some(param_meta_data) = param_meta_data {
                query_string.append_pair("metaData",
                    &param_meta_data);
            }
            if let Some(param_pack_ids) = param_pack_ids {
                query_string.append_pair("packIds",
                    &param_pack_ids);
            }
            if let Some(param_include_game_data) = param_include_game_data {
                query_string.append_pair("includeGameData",
                    &param_include_game_data.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::GameResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(UpdateGameResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn create_game_level(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_name: String,
        param_game_data: String,
        param_game_data_suffix: String,
        param_app_key: Option<String>,
        param_description: Option<String>,
        param_difficulty: Option<String>,
        param_app_version: Option<String>,
        param_asset_image_id: Option<i64>,
        param_asset_icon_id: Option<i64>,
        param_visibility: Option<String>,
        param_friend_group: Option<bool>,
        param_connection_ids: Option<String>,
        param_connection_group_ids: Option<String>,
        param_balance: Option<f64>,
        param_active: Option<bool>,
        param_allocate_tickets: Option<bool>,
        param_ticket_count: Option<i64>,
        param_ticket_type: Option<String>,
        param_points: Option<i64>,
        param_tutorial_title: Option<String>,
        param_tutorial_message: Option<String>,
        param_tutorial_alignment: Option<String>,
        param_tutorial_image_asset_id: Option<i64>,
        param_offer_id: Option<i64>,
        param_meta_data: Option<String>,
        context: &C) -> Result<CreateGameLevelResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/level/create",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            if let Some(param_app_key) = param_app_key {
                query_string.append_pair("appKey",
                    &param_app_key);
            }
                query_string.append_pair("name",
                    &param_name);
            if let Some(param_description) = param_description {
                query_string.append_pair("description",
                    &param_description);
            }
            if let Some(param_difficulty) = param_difficulty {
                query_string.append_pair("difficulty",
                    &param_difficulty);
            }
            if let Some(param_app_version) = param_app_version {
                query_string.append_pair("appVersion",
                    &param_app_version);
            }
            if let Some(param_asset_image_id) = param_asset_image_id {
                query_string.append_pair("assetImageId",
                    &param_asset_image_id.to_string());
            }
            if let Some(param_asset_icon_id) = param_asset_icon_id {
                query_string.append_pair("assetIconId",
                    &param_asset_icon_id.to_string());
            }
                query_string.append_pair("gameData",
                    &param_game_data);
                query_string.append_pair("gameDataSuffix",
                    &param_game_data_suffix);
            if let Some(param_visibility) = param_visibility {
                query_string.append_pair("visibility",
                    &param_visibility);
            }
            if let Some(param_friend_group) = param_friend_group {
                query_string.append_pair("friendGroup",
                    &param_friend_group.to_string());
            }
            if let Some(param_connection_ids) = param_connection_ids {
                query_string.append_pair("connectionIds",
                    &param_connection_ids);
            }
            if let Some(param_connection_group_ids) = param_connection_group_ids {
                query_string.append_pair("connectionGroupIds",
                    &param_connection_group_ids);
            }
            if let Some(param_balance) = param_balance {
                query_string.append_pair("balance",
                    &param_balance.to_string());
            }
            if let Some(param_active) = param_active {
                query_string.append_pair("active",
                    &param_active.to_string());
            }
            if let Some(param_allocate_tickets) = param_allocate_tickets {
                query_string.append_pair("allocateTickets",
                    &param_allocate_tickets.to_string());
            }
            if let Some(param_ticket_count) = param_ticket_count {
                query_string.append_pair("ticketCount",
                    &param_ticket_count.to_string());
            }
            if let Some(param_ticket_type) = param_ticket_type {
                query_string.append_pair("ticketType",
                    &param_ticket_type);
            }
            if let Some(param_points) = param_points {
                query_string.append_pair("points",
                    &param_points.to_string());
            }
            if let Some(param_tutorial_title) = param_tutorial_title {
                query_string.append_pair("tutorialTitle",
                    &param_tutorial_title);
            }
            if let Some(param_tutorial_message) = param_tutorial_message {
                query_string.append_pair("tutorialMessage",
                    &param_tutorial_message);
            }
            if let Some(param_tutorial_alignment) = param_tutorial_alignment {
                query_string.append_pair("tutorialAlignment",
                    &param_tutorial_alignment);
            }
            if let Some(param_tutorial_image_asset_id) = param_tutorial_image_asset_id {
                query_string.append_pair("tutorialImageAssetId",
                    &param_tutorial_image_asset_id.to_string());
            }
            if let Some(param_offer_id) = param_offer_id {
                query_string.append_pair("offerId",
                    &param_offer_id.to_string());
            }
            if let Some(param_meta_data) = param_meta_data {
                query_string.append_pair("metaData",
                    &param_meta_data);
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::GameLevelResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(CreateGameLevelResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn delete_game_level(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_level_id: i64,
        context: &C) -> Result<DeleteGameLevelResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/level/delete",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("levelId",
                    &param_level_id.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(DeleteGameLevelResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_game_level(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_level_id: i64,
        param_include_game_data: Option<bool>,
        context: &C) -> Result<GetGameLevelResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/level/get",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("levelId",
                    &param_level_id.to_string());
            if let Some(param_include_game_data) = param_include_game_data {
                query_string.append_pair("includeGameData",
                    &param_include_game_data.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::GameLevelResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetGameLevelResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_game_levels_by_application(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_app_key: String,
        param_keyword: Option<String>,
        param_sort_field: Option<String>,
        param_descending: Option<bool>,
        param_start: Option<i32>,
        param_limit: Option<i32>,
        param_app_version: Option<String>,
        param_include_game_data: Option<bool>,
        param_filters: Option<String>,
        context: &C) -> Result<GetGameLevelsByApplicationResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/level/search",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("appKey",
                    &param_app_key);
            if let Some(param_keyword) = param_keyword {
                query_string.append_pair("keyword",
                    &param_keyword);
            }
            if let Some(param_sort_field) = param_sort_field {
                query_string.append_pair("sortField",
                    &param_sort_field);
            }
            if let Some(param_descending) = param_descending {
                query_string.append_pair("descending",
                    &param_descending.to_string());
            }
            if let Some(param_start) = param_start {
                query_string.append_pair("start",
                    &param_start.to_string());
            }
            if let Some(param_limit) = param_limit {
                query_string.append_pair("limit",
                    &param_limit.to_string());
            }
            if let Some(param_app_version) = param_app_version {
                query_string.append_pair("appVersion",
                    &param_app_version);
            }
            if let Some(param_include_game_data) = param_include_game_data {
                query_string.append_pair("includeGameData",
                    &param_include_game_data.to_string());
            }
            if let Some(param_filters) = param_filters {
                query_string.append_pair("filters",
                    &param_filters);
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::GameLevelListResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetGameLevelsByApplicationResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_game_levels_by_billable_entity(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_app_key: Option<String>,
        param_keyword: Option<String>,
        param_sort_field: Option<models::GetGameLevelsByBillableEntitySortFieldParameter>,
        param_descending: Option<bool>,
        param_active_only: Option<bool>,
        param_start: Option<i64>,
        param_limit: Option<i64>,
        context: &C) -> Result<GetGameLevelsByBillableEntityResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/level/searchByBillableEntity",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            if let Some(param_app_key) = param_app_key {
                query_string.append_pair("appKey",
                    &param_app_key);
            }
            if let Some(param_keyword) = param_keyword {
                query_string.append_pair("keyword",
                    &param_keyword);
            }
            if let Some(param_sort_field) = param_sort_field {
                query_string.append_pair("sortField",
                    &param_sort_field.to_string());
            }
            if let Some(param_descending) = param_descending {
                query_string.append_pair("descending",
                    &param_descending.to_string());
            }
            if let Some(param_active_only) = param_active_only {
                query_string.append_pair("activeOnly",
                    &param_active_only.to_string());
            }
            if let Some(param_start) = param_start {
                query_string.append_pair("start",
                    &param_start.to_string());
            }
            if let Some(param_limit) = param_limit {
                query_string.append_pair("limit",
                    &param_limit.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::GameLevelResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetGameLevelsByBillableEntityResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_questions_in_level(
        &self,
        param_version: f64,
        param_level_id: i64,
        param_account_id: i64,
        context: &C) -> Result<GetQuestionsInLevelResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/level/questions/get",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("levelId",
                    &param_level_id.to_string());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::QuestionResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetQuestionsInLevelResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_words_in_level(
        &self,
        param_version: f64,
        param_level_id: i64,
        param_account_id: i64,
        context: &C) -> Result<GetWordsInLevelResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/level/words/get",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("levelId",
                    &param_level_id.to_string());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::WordzWordResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetWordsInLevelResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn update_game_level(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_level_id: i64,
        param_app_key: Option<String>,
        param_name: Option<String>,
        param_description: Option<String>,
        param_difficulty: Option<String>,
        param_app_version: Option<String>,
        param_asset_image_id: Option<i64>,
        param_asset_icon_id: Option<i64>,
        param_game_data: Option<String>,
        param_game_data_suffix: Option<String>,
        param_visibility: Option<String>,
        param_friend_group: Option<bool>,
        param_connection_ids: Option<String>,
        param_connection_group_ids: Option<String>,
        param_balance: Option<f64>,
        param_active: Option<bool>,
        param_allocate_tickets: Option<bool>,
        param_ticket_count: Option<i64>,
        param_ticket_type: Option<String>,
        param_points: Option<i64>,
        param_tutorial_title: Option<String>,
        param_tutorial_message: Option<String>,
        param_tutorial_alignment: Option<String>,
        param_tutorial_image_asset_id: Option<i64>,
        param_offer_id: Option<i64>,
        param_meta_data: Option<String>,
        context: &C) -> Result<UpdateGameLevelResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/level/update",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            if let Some(param_app_key) = param_app_key {
                query_string.append_pair("appKey",
                    &param_app_key);
            }
                query_string.append_pair("levelId",
                    &param_level_id.to_string());
            if let Some(param_name) = param_name {
                query_string.append_pair("name",
                    &param_name);
            }
            if let Some(param_description) = param_description {
                query_string.append_pair("description",
                    &param_description);
            }
            if let Some(param_difficulty) = param_difficulty {
                query_string.append_pair("difficulty",
                    &param_difficulty);
            }
            if let Some(param_app_version) = param_app_version {
                query_string.append_pair("appVersion",
                    &param_app_version);
            }
            if let Some(param_asset_image_id) = param_asset_image_id {
                query_string.append_pair("assetImageId",
                    &param_asset_image_id.to_string());
            }
            if let Some(param_asset_icon_id) = param_asset_icon_id {
                query_string.append_pair("assetIconId",
                    &param_asset_icon_id.to_string());
            }
            if let Some(param_game_data) = param_game_data {
                query_string.append_pair("gameData",
                    &param_game_data);
            }
            if let Some(param_game_data_suffix) = param_game_data_suffix {
                query_string.append_pair("gameDataSuffix",
                    &param_game_data_suffix);
            }
            if let Some(param_visibility) = param_visibility {
                query_string.append_pair("visibility",
                    &param_visibility);
            }
            if let Some(param_friend_group) = param_friend_group {
                query_string.append_pair("friendGroup",
                    &param_friend_group.to_string());
            }
            if let Some(param_connection_ids) = param_connection_ids {
                query_string.append_pair("connectionIds",
                    &param_connection_ids);
            }
            if let Some(param_connection_group_ids) = param_connection_group_ids {
                query_string.append_pair("connectionGroupIds",
                    &param_connection_group_ids);
            }
            if let Some(param_balance) = param_balance {
                query_string.append_pair("balance",
                    &param_balance.to_string());
            }
            if let Some(param_active) = param_active {
                query_string.append_pair("active",
                    &param_active.to_string());
            }
            if let Some(param_allocate_tickets) = param_allocate_tickets {
                query_string.append_pair("allocateTickets",
                    &param_allocate_tickets.to_string());
            }
            if let Some(param_ticket_count) = param_ticket_count {
                query_string.append_pair("ticketCount",
                    &param_ticket_count.to_string());
            }
            if let Some(param_ticket_type) = param_ticket_type {
                query_string.append_pair("ticketType",
                    &param_ticket_type);
            }
            if let Some(param_points) = param_points {
                query_string.append_pair("points",
                    &param_points.to_string());
            }
            if let Some(param_tutorial_title) = param_tutorial_title {
                query_string.append_pair("tutorialTitle",
                    &param_tutorial_title);
            }
            if let Some(param_tutorial_message) = param_tutorial_message {
                query_string.append_pair("tutorialMessage",
                    &param_tutorial_message);
            }
            if let Some(param_tutorial_alignment) = param_tutorial_alignment {
                query_string.append_pair("tutorialAlignment",
                    &param_tutorial_alignment);
            }
            if let Some(param_tutorial_image_asset_id) = param_tutorial_image_asset_id {
                query_string.append_pair("tutorialImageAssetId",
                    &param_tutorial_image_asset_id.to_string());
            }
            if let Some(param_offer_id) = param_offer_id {
                query_string.append_pair("offerId",
                    &param_offer_id.to_string());
            }
            if let Some(param_meta_data) = param_meta_data {
                query_string.append_pair("metaData",
                    &param_meta_data);
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::GameLevelResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(UpdateGameLevelResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn update_questions_in_level(
        &self,
        param_version: f64,
        param_level_id: i64,
        param_account_id: i64,
        param_question_ids: String,
        context: &C) -> Result<UpdateQuestionsInLevelResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/level/questions/update",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("levelId",
                    &param_level_id.to_string());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("questionIds",
                    &param_question_ids);
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(UpdateQuestionsInLevelResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn update_words_in_level(
        &self,
        param_version: f64,
        param_level_id: i64,
        param_account_id: i64,
        param_word_ids: String,
        context: &C) -> Result<UpdateWordsInLevelResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/level/words/update",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("levelId",
                    &param_level_id.to_string());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("wordIds",
                    &param_word_ids);
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(UpdateWordsInLevelResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn accept_invite(
        &self,
        param_version: f64,
        param_token: String,
        param_account_id: i64,
        param_album_id: Option<i64>,
        param_mission_id: Option<i64>,
        param_album_contest_id: Option<i64>,
        param_offer_id: Option<i64>,
        param_offer_location_id: Option<i64>,
        param_retailer_location_id: Option<i64>,
        param_app_key: Option<String>,
        param_auto_friend: Option<bool>,
        param_auto_attend_event: Option<bool>,
        param_auto_favorite_offer: Option<bool>,
        param_auto_favorite_offer_location: Option<bool>,
        param_auto_favorite_retailer_location: Option<bool>,
        context: &C) -> Result<AcceptInviteResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/invite/accept",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("token",
                    &param_token);
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            if let Some(param_album_id) = param_album_id {
                query_string.append_pair("albumId",
                    &param_album_id.to_string());
            }
            if let Some(param_mission_id) = param_mission_id {
                query_string.append_pair("missionId",
                    &param_mission_id.to_string());
            }
            if let Some(param_album_contest_id) = param_album_contest_id {
                query_string.append_pair("albumContestId",
                    &param_album_contest_id.to_string());
            }
            if let Some(param_offer_id) = param_offer_id {
                query_string.append_pair("offerId",
                    &param_offer_id.to_string());
            }
            if let Some(param_offer_location_id) = param_offer_location_id {
                query_string.append_pair("offerLocationId",
                    &param_offer_location_id.to_string());
            }
            if let Some(param_retailer_location_id) = param_retailer_location_id {
                query_string.append_pair("retailerLocationId",
                    &param_retailer_location_id.to_string());
            }
            if let Some(param_app_key) = param_app_key {
                query_string.append_pair("appKey",
                    &param_app_key);
            }
            if let Some(param_auto_friend) = param_auto_friend {
                query_string.append_pair("autoFriend",
                    &param_auto_friend.to_string());
            }
            if let Some(param_auto_attend_event) = param_auto_attend_event {
                query_string.append_pair("autoAttendEvent",
                    &param_auto_attend_event.to_string());
            }
            if let Some(param_auto_favorite_offer) = param_auto_favorite_offer {
                query_string.append_pair("autoFavoriteOffer",
                    &param_auto_favorite_offer.to_string());
            }
            if let Some(param_auto_favorite_offer_location) = param_auto_favorite_offer_location {
                query_string.append_pair("autoFavoriteOfferLocation",
                    &param_auto_favorite_offer_location.to_string());
            }
            if let Some(param_auto_favorite_retailer_location) = param_auto_favorite_retailer_location {
                query_string.append_pair("autoFavoriteRetailerLocation",
                    &param_auto_favorite_retailer_location.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::ConsumerInviteResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(AcceptInviteResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn album_contest_invite(
        &self,
        param_version: f64,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_app_id: Option<i64>,
        param_app_key: Option<String>,
        param_album_contest_id: Option<i64>,
        param_latitude: Option<f64>,
        param_longitude: Option<f64>,
        context: &C) -> Result<AlbumContestInviteResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/invite/albumContest",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_app_id) = param_app_id {
                query_string.append_pair("appId",
                    &param_app_id.to_string());
            }
            if let Some(param_app_key) = param_app_key {
                query_string.append_pair("appKey",
                    &param_app_key);
            }
            if let Some(param_album_contest_id) = param_album_contest_id {
                query_string.append_pair("albumContestId",
                    &param_album_contest_id.to_string());
            }
            if let Some(param_latitude) = param_latitude {
                query_string.append_pair("latitude",
                    &param_latitude.to_string());
            }
            if let Some(param_longitude) = param_longitude {
                query_string.append_pair("longitude",
                    &param_longitude.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::InviteResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(AlbumContestInviteResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn album_invite(
        &self,
        param_version: f64,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_app_id: Option<i64>,
        param_app_key: Option<String>,
        param_album_id: Option<i64>,
        param_latitude: Option<f64>,
        param_longitude: Option<f64>,
        context: &C) -> Result<AlbumInviteResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/invite/album",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_app_id) = param_app_id {
                query_string.append_pair("appId",
                    &param_app_id.to_string());
            }
            if let Some(param_app_key) = param_app_key {
                query_string.append_pair("appKey",
                    &param_app_key);
            }
            if let Some(param_album_id) = param_album_id {
                query_string.append_pair("albumId",
                    &param_album_id.to_string());
            }
            if let Some(param_latitude) = param_latitude {
                query_string.append_pair("latitude",
                    &param_latitude.to_string());
            }
            if let Some(param_longitude) = param_longitude {
                query_string.append_pair("longitude",
                    &param_longitude.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::InviteResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(AlbumInviteResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn event_invite(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_app_key: String,
        param_listing_id: i64,
        param_receiver_account_ids: Option<String>,
        param_retailer_location_id: Option<i64>,
        context: &C) -> Result<EventInviteResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/invite/event",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            if let Some(param_receiver_account_ids) = param_receiver_account_ids {
                query_string.append_pair("receiverAccountIds",
                    &param_receiver_account_ids);
            }
                query_string.append_pair("appKey",
                    &param_app_key);
                query_string.append_pair("listingId",
                    &param_listing_id.to_string());
            if let Some(param_retailer_location_id) = param_retailer_location_id {
                query_string.append_pair("retailerLocationId",
                    &param_retailer_location_id.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::InviteResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(EventInviteResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn game_invite(
        &self,
        param_version: f64,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_app_id: Option<i64>,
        param_app_key: Option<String>,
        param_game_level_id: Option<i64>,
        param_latitude: Option<f64>,
        param_longitude: Option<f64>,
        context: &C) -> Result<GameInviteResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/invite/gameLevel",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_app_id) = param_app_id {
                query_string.append_pair("appId",
                    &param_app_id.to_string());
            }
            if let Some(param_app_key) = param_app_key {
                query_string.append_pair("appKey",
                    &param_app_key);
            }
            if let Some(param_game_level_id) = param_game_level_id {
                query_string.append_pair("gameLevelId",
                    &param_game_level_id.to_string());
            }
            if let Some(param_latitude) = param_latitude {
                query_string.append_pair("latitude",
                    &param_latitude.to_string());
            }
            if let Some(param_longitude) = param_longitude {
                query_string.append_pair("longitude",
                    &param_longitude.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::InviteResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GameInviteResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_invite(
        &self,
        param_version: f64,
        param_account_id: Option<i64>,
        param_token: Option<String>,
        param_album_id: Option<i64>,
        param_mission_id: Option<i64>,
        param_album_contest_id: Option<i64>,
        param_offer_id: Option<i64>,
        param_offer_location_id: Option<i64>,
        param_retailer_location_id: Option<i64>,
        param_app_key: Option<String>,
        context: &C) -> Result<GetInviteResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/invite/get",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_token) = param_token {
                query_string.append_pair("token",
                    &param_token);
            }
            if let Some(param_album_id) = param_album_id {
                query_string.append_pair("albumId",
                    &param_album_id.to_string());
            }
            if let Some(param_mission_id) = param_mission_id {
                query_string.append_pair("missionId",
                    &param_mission_id.to_string());
            }
            if let Some(param_album_contest_id) = param_album_contest_id {
                query_string.append_pair("albumContestId",
                    &param_album_contest_id.to_string());
            }
            if let Some(param_offer_id) = param_offer_id {
                query_string.append_pair("offerId",
                    &param_offer_id.to_string());
            }
            if let Some(param_offer_location_id) = param_offer_location_id {
                query_string.append_pair("offerLocationId",
                    &param_offer_location_id.to_string());
            }
            if let Some(param_retailer_location_id) = param_retailer_location_id {
                query_string.append_pair("retailerLocationId",
                    &param_retailer_location_id.to_string());
            }
            if let Some(param_app_key) = param_app_key {
                query_string.append_pair("appKey",
                    &param_app_key);
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetInviteResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn mission_invite(
        &self,
        param_version: f64,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_app_id: Option<i64>,
        param_app_key: Option<String>,
        param_mission_id: Option<i64>,
        param_latitude: Option<f64>,
        param_longitude: Option<f64>,
        context: &C) -> Result<MissionInviteResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/invite/mission",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_app_id) = param_app_id {
                query_string.append_pair("appId",
                    &param_app_id.to_string());
            }
            if let Some(param_app_key) = param_app_key {
                query_string.append_pair("appKey",
                    &param_app_key);
            }
            if let Some(param_mission_id) = param_mission_id {
                query_string.append_pair("missionId",
                    &param_mission_id.to_string());
            }
            if let Some(param_latitude) = param_latitude {
                query_string.append_pair("latitude",
                    &param_latitude.to_string());
            }
            if let Some(param_longitude) = param_longitude {
                query_string.append_pair("longitude",
                    &param_longitude.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::InviteResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(MissionInviteResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn offer_invite(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_app_key: String,
        param_offer_id: i64,
        context: &C) -> Result<OfferInviteResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/invite/offer",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("appKey",
                    &param_app_key);
                query_string.append_pair("offerId",
                    &param_offer_id.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::InviteResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(OfferInviteResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn offer_location_invite(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_app_key: String,
        param_offer_location_id: i64,
        context: &C) -> Result<OfferLocationInviteResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/invite/offerLocation",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("appKey",
                    &param_app_key);
                query_string.append_pair("offerLocationId",
                    &param_offer_location_id.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::InviteResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(OfferLocationInviteResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn retailer_location_invite(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_app_key: String,
        param_retailer_location_id: i64,
        param_album_id: Option<i64>,
        context: &C) -> Result<RetailerLocationInviteResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/invite/retailerLocation",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("appKey",
                    &param_app_key);
                query_string.append_pair("retailerLocationId",
                    &param_retailer_location_id.to_string());
            if let Some(param_album_id) = param_album_id {
                query_string.append_pair("albumId",
                    &param_album_id.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::InviteResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(RetailerLocationInviteResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn create_leaderboard(
        &self,
        param_version: f64,
        param_account_id: Option<i64>,
        param_app_key: Option<String>,
        param_rank_type: Option<String>,
        param_leaderboard_mode: Option<String>,
        param_icon_media: Option<swagger::ByteArray>,
        param_icon_asset_id: Option<i64>,
        param_banner_media: Option<swagger::ByteArray>,
        param_banner_asset_id: Option<i64>,
        param_limitation: Option<i32>,
        param_sort_field: Option<String>,
        param_title: Option<String>,
        param_description: Option<String>,
        param_meta_data: Option<String>,
        context: &C) -> Result<CreateLeaderboardResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/leaderboard/create",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_app_key) = param_app_key {
                query_string.append_pair("appKey",
                    &param_app_key);
            }
            if let Some(param_rank_type) = param_rank_type {
                query_string.append_pair("rankType",
                    &param_rank_type);
            }
            if let Some(param_leaderboard_mode) = param_leaderboard_mode {
                query_string.append_pair("leaderboardMode",
                    &param_leaderboard_mode);
            }
            if let Some(param_icon_media) = param_icon_media {
                query_string.append_pair("iconMedia",
                    &param_icon_media.to_string());
            }
            if let Some(param_icon_asset_id) = param_icon_asset_id {
                query_string.append_pair("iconAssetId",
                    &param_icon_asset_id.to_string());
            }
            if let Some(param_banner_media) = param_banner_media {
                query_string.append_pair("bannerMedia",
                    &param_banner_media.to_string());
            }
            if let Some(param_banner_asset_id) = param_banner_asset_id {
                query_string.append_pair("bannerAssetId",
                    &param_banner_asset_id.to_string());
            }
            if let Some(param_limitation) = param_limitation {
                query_string.append_pair("limitation",
                    &param_limitation.to_string());
            }
            if let Some(param_sort_field) = param_sort_field {
                query_string.append_pair("sortField",
                    &param_sort_field);
            }
            if let Some(param_title) = param_title {
                query_string.append_pair("title",
                    &param_title);
            }
            if let Some(param_description) = param_description {
                query_string.append_pair("description",
                    &param_description);
            }
            if let Some(param_meta_data) = param_meta_data {
                query_string.append_pair("metaData",
                    &param_meta_data);
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::LeaderboardResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(CreateLeaderboardResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn delete_leaderboard(
        &self,
        param_version: f64,
        param_leaderboard_id: i64,
        param_account_id: Option<i64>,
        context: &C) -> Result<DeleteLeaderboardResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/leaderboard/delete",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
                query_string.append_pair("leaderboardId",
                    &param_leaderboard_id.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(DeleteLeaderboardResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_leaderboard(
        &self,
        param_version: f64,
        param_leaderboard_id: i64,
        param_account_id: Option<i64>,
        param_include_full_ranking_list: Option<bool>,
        context: &C) -> Result<GetLeaderboardResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/leaderboard/get",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
                query_string.append_pair("leaderboardId",
                    &param_leaderboard_id.to_string());
            if let Some(param_include_full_ranking_list) = param_include_full_ranking_list {
                query_string.append_pair("includeFullRankingList",
                    &param_include_full_ranking_list.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::LeaderboardResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetLeaderboardResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn search_leaderboards(
        &self,
        param_version: f64,
        param_account_id: Option<i64>,
        param_app_key: Option<String>,
        param_global_only: Option<bool>,
        param_keyword: Option<String>,
        param_leaderboard_ids: Option<String>,
        param_rank_types: Option<String>,
        param_sort_field: Option<String>,
        param_descending: Option<bool>,
        param_include_inactive: Option<bool>,
        param_include_app_response: Option<bool>,
        param_start: Option<i32>,
        param_limit: Option<i32>,
        context: &C) -> Result<SearchLeaderboardsResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/leaderboard/search",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_app_key) = param_app_key {
                query_string.append_pair("appKey",
                    &param_app_key);
            }
            if let Some(param_global_only) = param_global_only {
                query_string.append_pair("globalOnly",
                    &param_global_only.to_string());
            }
            if let Some(param_keyword) = param_keyword {
                query_string.append_pair("keyword",
                    &param_keyword);
            }
            if let Some(param_leaderboard_ids) = param_leaderboard_ids {
                query_string.append_pair("leaderboardIds",
                    &param_leaderboard_ids);
            }
            if let Some(param_rank_types) = param_rank_types {
                query_string.append_pair("rankTypes",
                    &param_rank_types);
            }
            if let Some(param_sort_field) = param_sort_field {
                query_string.append_pair("sortField",
                    &param_sort_field);
            }
            if let Some(param_descending) = param_descending {
                query_string.append_pair("descending",
                    &param_descending.to_string());
            }
            if let Some(param_include_inactive) = param_include_inactive {
                query_string.append_pair("includeInactive",
                    &param_include_inactive.to_string());
            }
            if let Some(param_include_app_response) = param_include_app_response {
                query_string.append_pair("includeAppResponse",
                    &param_include_app_response.to_string());
            }
            if let Some(param_start) = param_start {
                query_string.append_pair("start",
                    &param_start.to_string());
            }
            if let Some(param_limit) = param_limit {
                query_string.append_pair("limit",
                    &param_limit.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::LeaderboardResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(SearchLeaderboardsResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn update_leaderboard(
        &self,
        param_version: f64,
        param_leaderboard_id: i64,
        param_account_id: Option<i64>,
        param_app_key: Option<String>,
        param_rank_type: Option<String>,
        param_leaderboard_mode: Option<String>,
        param_sort_field: Option<String>,
        param_icon_media: Option<swagger::ByteArray>,
        param_icon_asset_id: Option<i64>,
        param_banner_media: Option<swagger::ByteArray>,
        param_banner_asset_id: Option<i64>,
        param_limitation: Option<i32>,
        param_active: Option<bool>,
        param_title: Option<String>,
        param_description: Option<String>,
        param_meta_data: Option<String>,
        context: &C) -> Result<UpdateLeaderboardResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/leaderboard/update",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_app_key) = param_app_key {
                query_string.append_pair("appKey",
                    &param_app_key);
            }
                query_string.append_pair("leaderboardId",
                    &param_leaderboard_id.to_string());
            if let Some(param_rank_type) = param_rank_type {
                query_string.append_pair("rankType",
                    &param_rank_type);
            }
            if let Some(param_leaderboard_mode) = param_leaderboard_mode {
                query_string.append_pair("leaderboardMode",
                    &param_leaderboard_mode);
            }
            if let Some(param_sort_field) = param_sort_field {
                query_string.append_pair("sortField",
                    &param_sort_field);
            }
            if let Some(param_icon_media) = param_icon_media {
                query_string.append_pair("iconMedia",
                    &param_icon_media.to_string());
            }
            if let Some(param_icon_asset_id) = param_icon_asset_id {
                query_string.append_pair("iconAssetId",
                    &param_icon_asset_id.to_string());
            }
            if let Some(param_banner_media) = param_banner_media {
                query_string.append_pair("bannerMedia",
                    &param_banner_media.to_string());
            }
            if let Some(param_banner_asset_id) = param_banner_asset_id {
                query_string.append_pair("bannerAssetId",
                    &param_banner_asset_id.to_string());
            }
            if let Some(param_limitation) = param_limitation {
                query_string.append_pair("limitation",
                    &param_limitation.to_string());
            }
            if let Some(param_active) = param_active {
                query_string.append_pair("active",
                    &param_active.to_string());
            }
            if let Some(param_title) = param_title {
                query_string.append_pair("title",
                    &param_title);
            }
            if let Some(param_description) = param_description {
                query_string.append_pair("description",
                    &param_description);
            }
            if let Some(param_meta_data) = param_meta_data {
                query_string.append_pair("metaData",
                    &param_meta_data);
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::LeaderboardResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(UpdateLeaderboardResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn register_like(
        &self,
        param_version: f64,
        param_likable_type: String,
        param_likable_id: i64,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_permissionable_type: Option<String>,
        param_permissionable_id: Option<i64>,
        param_like: Option<bool>,
        param_app: Option<String>,
        param_game_type: Option<String>,
        param_app_key: Option<String>,
        param_latitude: Option<f64>,
        param_longitude: Option<f64>,
        context: &C) -> Result<RegisterLikeResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/like",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
                query_string.append_pair("likableType",
                    &param_likable_type);
                query_string.append_pair("likableId",
                    &param_likable_id.to_string());
            if let Some(param_permissionable_type) = param_permissionable_type {
                query_string.append_pair("permissionableType",
                    &param_permissionable_type);
            }
            if let Some(param_permissionable_id) = param_permissionable_id {
                query_string.append_pair("permissionableId",
                    &param_permissionable_id.to_string());
            }
            if let Some(param_like) = param_like {
                query_string.append_pair("like",
                    &param_like.to_string());
            }
            if let Some(param_app) = param_app {
                query_string.append_pair("app",
                    &param_app);
            }
            if let Some(param_game_type) = param_game_type {
                query_string.append_pair("gameType",
                    &param_game_type);
            }
            if let Some(param_app_key) = param_app_key {
                query_string.append_pair("appKey",
                    &param_app_key);
            }
            if let Some(param_latitude) = param_latitude {
                query_string.append_pair("latitude",
                    &param_latitude.to_string());
            }
            if let Some(param_longitude) = param_longitude {
                query_string.append_pair("longitude",
                    &param_longitude.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::LikableResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(RegisterLikeResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn remove_like(
        &self,
        param_version: f64,
        param_likable_type: String,
        param_likable_id: i64,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_latitude: Option<f64>,
        param_longitude: Option<f64>,
        context: &C) -> Result<RemoveLikeResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/like/delete",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
                query_string.append_pair("likableType",
                    &param_likable_type);
                query_string.append_pair("likableId",
                    &param_likable_id.to_string());
            if let Some(param_latitude) = param_latitude {
                query_string.append_pair("latitude",
                    &param_latitude.to_string());
            }
            if let Some(param_longitude) = param_longitude {
                query_string.append_pair("longitude",
                    &param_longitude.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::LikableResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(RemoveLikeResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn search_likes(
        &self,
        param_version: f64,
        param_likable_type: String,
        param_likable_id: i64,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_connection_account_ids: Option<String>,
        param_sort_field: Option<String>,
        param_descending: Option<bool>,
        param_updated_since: Option<i64>,
        param_updated_before: Option<i64>,
        param_start: Option<i32>,
        param_limit: Option<i32>,
        context: &C) -> Result<SearchLikesResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/like/search",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_connection_account_ids) = param_connection_account_ids {
                query_string.append_pair("connectionAccountIds",
                    &param_connection_account_ids);
            }
                query_string.append_pair("likableType",
                    &param_likable_type);
                query_string.append_pair("likableId",
                    &param_likable_id.to_string());
            if let Some(param_sort_field) = param_sort_field {
                query_string.append_pair("sortField",
                    &param_sort_field);
            }
            if let Some(param_descending) = param_descending {
                query_string.append_pair("descending",
                    &param_descending.to_string());
            }
            if let Some(param_updated_since) = param_updated_since {
                query_string.append_pair("updatedSince",
                    &param_updated_since.to_string());
            }
            if let Some(param_updated_before) = param_updated_before {
                query_string.append_pair("updatedBefore",
                    &param_updated_before.to_string());
            }
            if let Some(param_start) = param_start {
                query_string.append_pair("start",
                    &param_start.to_string());
            }
            if let Some(param_limit) = param_limit {
                query_string.append_pair("limit",
                    &param_limit.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SearchResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(SearchLikesResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn create_listing(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_name: String,
        param_filter_ids: Option<String>,
        param_description: Option<String>,
        param_start: Option<i64>,
        param_end: Option<i64>,
        param_location_name: Option<String>,
        param_location_description: Option<String>,
        param_is_private: Option<bool>,
        param_external_id: Option<String>,
        param_external_id2: Option<String>,
        param_external_group_id: Option<String>,
        param_active: Option<bool>,
        param_meta_data: Option<String>,
        context: &C) -> Result<CreateListingResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/listing/create",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("name",
                    &param_name);
            if let Some(param_filter_ids) = param_filter_ids {
                query_string.append_pair("filterIds",
                    &param_filter_ids);
            }
            if let Some(param_description) = param_description {
                query_string.append_pair("description",
                    &param_description);
            }
            if let Some(param_start) = param_start {
                query_string.append_pair("start",
                    &param_start.to_string());
            }
            if let Some(param_end) = param_end {
                query_string.append_pair("end",
                    &param_end.to_string());
            }
            if let Some(param_location_name) = param_location_name {
                query_string.append_pair("locationName",
                    &param_location_name);
            }
            if let Some(param_location_description) = param_location_description {
                query_string.append_pair("locationDescription",
                    &param_location_description);
            }
            if let Some(param_is_private) = param_is_private {
                query_string.append_pair("isPrivate",
                    &param_is_private.to_string());
            }
            if let Some(param_external_id) = param_external_id {
                query_string.append_pair("externalId",
                    &param_external_id);
            }
            if let Some(param_external_id2) = param_external_id2 {
                query_string.append_pair("externalId2",
                    &param_external_id2);
            }
            if let Some(param_external_group_id) = param_external_group_id {
                query_string.append_pair("externalGroupId",
                    &param_external_group_id);
            }
            if let Some(param_active) = param_active {
                query_string.append_pair("active",
                    &param_active.to_string());
            }
            if let Some(param_meta_data) = param_meta_data {
                query_string.append_pair("metaData",
                    &param_meta_data);
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::ListingFullResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(CreateListingResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn delete_listing(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_listing_id: i64,
        context: &C) -> Result<DeleteListingResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/listing/delete",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("listingId",
                    &param_listing_id.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(DeleteListingResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_listing(
        &self,
        param_version: f64,
        param_listing_id: i64,
        context: &C) -> Result<GetListingResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/listing/get",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("listingId",
                    &param_listing_id.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::ListingFullResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetListingResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn search_listing(
        &self,
        param_version: f64,
        param_account_id: Option<i64>,
        param_keyword: Option<String>,
        param_start: Option<i32>,
        param_limit: Option<i32>,
        param_active_only: Option<bool>,
        param_latitude: Option<f64>,
        param_longitude: Option<f64>,
        param_start_date: Option<i64>,
        param_end_date: Option<i64>,
        param_category_ids: Option<String>,
        param_filter_ids: Option<String>,
        param_use_listing_order_ids: Option<bool>,
        param_external_id: Option<String>,
        param_external_id2: Option<String>,
        param_external_group_id: Option<String>,
        context: &C) -> Result<SearchListingResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/listing/search",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_keyword) = param_keyword {
                query_string.append_pair("keyword",
                    &param_keyword);
            }
            if let Some(param_start) = param_start {
                query_string.append_pair("start",
                    &param_start.to_string());
            }
            if let Some(param_limit) = param_limit {
                query_string.append_pair("limit",
                    &param_limit.to_string());
            }
            if let Some(param_active_only) = param_active_only {
                query_string.append_pair("activeOnly",
                    &param_active_only.to_string());
            }
            if let Some(param_latitude) = param_latitude {
                query_string.append_pair("latitude",
                    &param_latitude.to_string());
            }
            if let Some(param_longitude) = param_longitude {
                query_string.append_pair("longitude",
                    &param_longitude.to_string());
            }
            if let Some(param_start_date) = param_start_date {
                query_string.append_pair("startDate",
                    &param_start_date.to_string());
            }
            if let Some(param_end_date) = param_end_date {
                query_string.append_pair("endDate",
                    &param_end_date.to_string());
            }
            if let Some(param_category_ids) = param_category_ids {
                query_string.append_pair("categoryIds",
                    &param_category_ids);
            }
            if let Some(param_filter_ids) = param_filter_ids {
                query_string.append_pair("filterIds",
                    &param_filter_ids);
            }
            if let Some(param_use_listing_order_ids) = param_use_listing_order_ids {
                query_string.append_pair("useListingOrderIds",
                    &param_use_listing_order_ids.to_string());
            }
            if let Some(param_external_id) = param_external_id {
                query_string.append_pair("externalId",
                    &param_external_id);
            }
            if let Some(param_external_id2) = param_external_id2 {
                query_string.append_pair("externalId2",
                    &param_external_id2);
            }
            if let Some(param_external_group_id) = param_external_group_id {
                query_string.append_pair("externalGroupId",
                    &param_external_group_id);
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<Vec<models::ListingResponse>>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(SearchListingResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn summary_listing(
        &self,
        param_version: f64,
        param_account_id: Option<i64>,
        param_start_date: Option<i64>,
        param_category_ids: Option<String>,
        param_days_to_include: Option<i32>,
        param_use_listing_order_ids: Option<bool>,
        context: &C) -> Result<SummaryListingResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/listing/summary",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_start_date) = param_start_date {
                query_string.append_pair("startDate",
                    &param_start_date.to_string());
            }
            if let Some(param_category_ids) = param_category_ids {
                query_string.append_pair("categoryIds",
                    &param_category_ids);
            }
            if let Some(param_days_to_include) = param_days_to_include {
                query_string.append_pair("daysToInclude",
                    &param_days_to_include.to_string());
            }
            if let Some(param_use_listing_order_ids) = param_use_listing_order_ids {
                query_string.append_pair("useListingOrderIds",
                    &param_use_listing_order_ids.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<Vec<models::ListingGroupResponse>>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(SummaryListingResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn update_listing(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_listing_id: i64,
        param_filter_ids: Option<String>,
        param_name: Option<String>,
        param_description: Option<String>,
        param_start: Option<i64>,
        param_end: Option<i64>,
        param_location_name: Option<String>,
        param_location_description: Option<String>,
        param_is_private: Option<bool>,
        param_external_id: Option<String>,
        param_external_id2: Option<String>,
        param_external_group_id: Option<String>,
        param_active: Option<bool>,
        param_meta_data: Option<String>,
        context: &C) -> Result<UpdateListingResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/listing/update",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("listingId",
                    &param_listing_id.to_string());
            if let Some(param_filter_ids) = param_filter_ids {
                query_string.append_pair("filterIds",
                    &param_filter_ids);
            }
            if let Some(param_name) = param_name {
                query_string.append_pair("name",
                    &param_name);
            }
            if let Some(param_description) = param_description {
                query_string.append_pair("description",
                    &param_description);
            }
            if let Some(param_start) = param_start {
                query_string.append_pair("start",
                    &param_start.to_string());
            }
            if let Some(param_end) = param_end {
                query_string.append_pair("end",
                    &param_end.to_string());
            }
            if let Some(param_location_name) = param_location_name {
                query_string.append_pair("locationName",
                    &param_location_name);
            }
            if let Some(param_location_description) = param_location_description {
                query_string.append_pair("locationDescription",
                    &param_location_description);
            }
            if let Some(param_is_private) = param_is_private {
                query_string.append_pair("isPrivate",
                    &param_is_private.to_string());
            }
            if let Some(param_external_id) = param_external_id {
                query_string.append_pair("externalId",
                    &param_external_id);
            }
            if let Some(param_external_id2) = param_external_id2 {
                query_string.append_pair("externalId2",
                    &param_external_id2);
            }
            if let Some(param_external_group_id) = param_external_group_id {
                query_string.append_pair("externalGroupId",
                    &param_external_group_id);
            }
            if let Some(param_active) = param_active {
                query_string.append_pair("active",
                    &param_active.to_string());
            }
            if let Some(param_meta_data) = param_meta_data {
                query_string.append_pair("metaData",
                    &param_meta_data);
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::ListingFullResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(UpdateListingResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn cache_trilateration_data(
        &self,
        param_version: f64,
        param_udid: String,
        param_source_time: Option<i64>,
        param_minimum_sample_size: Option<i32>,
        param_data: Option<String>,
        param_data_file: Option<swagger::ByteArray>,
        context: &C) -> Result<CacheTrilaterationDataResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/location/trilaterate/cache",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("udid",
                    &param_udid);
            if let Some(param_source_time) = param_source_time {
                query_string.append_pair("sourceTime",
                    &param_source_time.to_string());
            }
            if let Some(param_minimum_sample_size) = param_minimum_sample_size {
                query_string.append_pair("minimumSampleSize",
                    &param_minimum_sample_size.to_string());
            }
            if let Some(param_data) = param_data {
                query_string.append_pair("data",
                    &param_data);
            }
            if let Some(param_data_file) = param_data_file {
                query_string.append_pair("dataFile",
                    &param_data_file.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(CacheTrilaterationDataResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn cache_trilateration_data_gzip(
        &self,
        param_version: f64,
        param_body: Option<models::TrilatCacheRequest>,
        context: &C) -> Result<CacheTrilaterationDataGzipResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/location/trilaterate/cache/submit",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        // Consumes basic body
        // Body parameter
        if let Some(param_body) = param_body {
        let body = serde_json::to_string(&param_body).expect("impossible to fail to serialize");
        *request.body_mut() = body_from_string(body);
        }

        let header = "application/json";
        request.headers_mut().insert(CONTENT_TYPE, HeaderValue::from_static(header));

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(CacheTrilaterationDataGzipResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_location_by_ip(
        &self,
        param_version: f64,
        param_ip: Option<String>,
        context: &C) -> Result<GetLocationByIpResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/location/ip",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_ip) = param_ip {
                query_string.append_pair("ip",
                    &param_ip);
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::CoordsResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetLocationByIpResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_location_by_trilateration(
        &self,
        param_version: f64,
        param_account_id: Option<i64>,
        param_latitude: Option<f64>,
        param_longitude: Option<f64>,
        param_data: Option<String>,
        param_response_filters: Option<String>,
        context: &C) -> Result<GetLocationByTrilaterationResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/account/location/trilaterate",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_latitude) = param_latitude {
                query_string.append_pair("latitude",
                    &param_latitude.to_string());
            }
            if let Some(param_longitude) = param_longitude {
                query_string.append_pair("longitude",
                    &param_longitude.to_string());
            }
            if let Some(param_data) = param_data {
                query_string.append_pair("data",
                    &param_data);
            }
            if let Some(param_response_filters) = param_response_filters {
                query_string.append_pair("responseFilters",
                    &param_response_filters);
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::GeoPointResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetLocationByTrilaterationResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_locations(
        &self,
        param_version: f64,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_currentlatitude: Option<f64>,
        param_currentlongitude: Option<f64>,
        param_current_latitude: Option<f64>,
        param_current_longitude: Option<f64>,
        param_query: Option<String>,
        param_zipcode: Option<String>,
        param_zip_code: Option<String>,
        param_selected_maplatitude: Option<f64>,
        param_selected_maplongitude: Option<f64>,
        param_selected_map_latitude: Option<f64>,
        param_selected_map_longitude: Option<f64>,
        param_search_range: Option<f64>,
        param_use_geocode: Option<bool>,
        param__i: Option<i32>,
        param_start: Option<i32>,
        param__l: Option<i32>,
        param_limit: Option<i32>,
        context: &C) -> Result<GetLocationsResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/location/search",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_currentlatitude) = param_currentlatitude {
                query_string.append_pair("currentlatitude",
                    &param_currentlatitude.to_string());
            }
            if let Some(param_currentlongitude) = param_currentlongitude {
                query_string.append_pair("currentlongitude",
                    &param_currentlongitude.to_string());
            }
            if let Some(param_current_latitude) = param_current_latitude {
                query_string.append_pair("currentLatitude",
                    &param_current_latitude.to_string());
            }
            if let Some(param_current_longitude) = param_current_longitude {
                query_string.append_pair("currentLongitude",
                    &param_current_longitude.to_string());
            }
            if let Some(param_query) = param_query {
                query_string.append_pair("query",
                    &param_query);
            }
            if let Some(param_zipcode) = param_zipcode {
                query_string.append_pair("zipcode",
                    &param_zipcode);
            }
            if let Some(param_zip_code) = param_zip_code {
                query_string.append_pair("zipCode",
                    &param_zip_code);
            }
            if let Some(param_selected_maplatitude) = param_selected_maplatitude {
                query_string.append_pair("selectedMaplatitude",
                    &param_selected_maplatitude.to_string());
            }
            if let Some(param_selected_maplongitude) = param_selected_maplongitude {
                query_string.append_pair("selectedMaplongitude",
                    &param_selected_maplongitude.to_string());
            }
            if let Some(param_selected_map_latitude) = param_selected_map_latitude {
                query_string.append_pair("selectedMapLatitude",
                    &param_selected_map_latitude.to_string());
            }
            if let Some(param_selected_map_longitude) = param_selected_map_longitude {
                query_string.append_pair("selectedMapLongitude",
                    &param_selected_map_longitude.to_string());
            }
            if let Some(param_search_range) = param_search_range {
                query_string.append_pair("searchRange",
                    &param_search_range.to_string());
            }
            if let Some(param_use_geocode) = param_use_geocode {
                query_string.append_pair("useGeocode",
                    &param_use_geocode.to_string());
            }
            if let Some(param__i) = param__i {
                query_string.append_pair("_i",
                    &param__i.to_string());
            }
            if let Some(param_start) = param_start {
                query_string.append_pair("start",
                    &param_start.to_string());
            }
            if let Some(param__l) = param__l {
                query_string.append_pair("_l",
                    &param__l.to_string());
            }
            if let Some(param_limit) = param_limit {
                query_string.append_pair("limit",
                    &param_limit.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::LocationSearchResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetLocationsResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn create_location_v2(
        &self,
        param_version: f64,
        param_body: Option<models::Location>,
        context: &C) -> Result<CreateLocationV2Response, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/location",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        // Consumes basic body
        // Body parameter
        if let Some(param_body) = param_body {
        let body = serde_json::to_string(&param_body).expect("impossible to fail to serialize");
        *request.body_mut() = body_from_string(body);
        }

        let header = "application/json";
        request.headers_mut().insert(CONTENT_TYPE, HeaderValue::from_static(header));

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(CreateLocationV2Response::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn update_location_v2(
        &self,
        param_version: f64,
        param_id: i64,
        param_body: Option<models::Location>,
        context: &C) -> Result<UpdateLocationV2Response, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/location/{id}",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
            ,id=utf8_percent_encode(&param_id.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        // Consumes basic body
        // Body parameter
        if let Some(param_body) = param_body {
        let body = serde_json::to_string(&param_body).expect("impossible to fail to serialize");
        *request.body_mut() = body_from_string(body);
        }

        let header = "application/json";
        request.headers_mut().insert(CONTENT_TYPE, HeaderValue::from_static(header));

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(UpdateLocationV2Response::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn create_media(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_title: String,
        param_barcode_type: models::CreateMediaBarcodeTypeParameter,
        param_no_expiration: bool,
        param_available_limit: i32,
        param_available_limit_per_user: i32,
        param_added_limit: i32,
        param_view_limit: i32,
        param_max_prints: i32,
        param_ticket_price: i64,
        param_full_price: f64,
        param_discount_price: f64,
        param_special_offer_type: models::CreateMediaSpecialOfferTypeParameter,
        param_offer_visibility: models::CreateMediaOfferVisibilityParameter,
        param_active: bool,
        param_retailer_location_ids: Option<String>,
        param_sub_title: Option<String>,
        param_details: Option<String>,
        param_sub_details: Option<String>,
        param_fine_print: Option<String>,
        param_barcode_entry: Option<String>,
        param_external_redeem_options: Option<String>,
        param_external_url: Option<String>,
        param_tickets_reward_type: Option<String>,
        param_tickets_reward: Option<i64>,
        param_activated: Option<i64>,
        param_expires: Option<i64>,
        param_ticket_price_type: Option<String>,
        param_show_remaining: Option<bool>,
        param_show_redeemed: Option<bool>,
        param_replaced: Option<bool>,
        param_featured: Option<bool>,
        param_category_ids: Option<String>,
        param_filter_ids: Option<String>,
        param_barcode_asset_id: Option<i64>,
        param_image_asset_id: Option<i64>,
        param_image_asset_id1: Option<i64>,
        param_image_asset_id2: Option<i64>,
        param_image_asset_id3: Option<i64>,
        param_image_asset_id4: Option<i64>,
        param_image_asset_id5: Option<i64>,
        param_publisher: Option<String>,
        param_redeemable_start: Option<i64>,
        param_redeemable_end: Option<i64>,
        param_condition_type: Option<models::CreateMediaConditionTypeParameter>,
        param_isbn: Option<String>,
        param_asin: Option<String>,
        param_catalog_numbers: Option<String>,
        param_parental_rating: Option<String>,
        param_availability_date: Option<i64>,
        param_media_type: Option<models::CreateMediaMediaTypeParameter>,
        param_duration: Option<i32>,
        param_author: Option<String>,
        param_release_date: Option<i64>,
        param_collection_ids: Option<String>,
        param_availability: Option<String>,
        param_availability_summary: Option<String>,
        context: &C) -> Result<CreateMediaResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/media/create",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            if let Some(param_retailer_location_ids) = param_retailer_location_ids {
                query_string.append_pair("retailerLocationIds",
                    &param_retailer_location_ids);
            }
                query_string.append_pair("title",
                    &param_title);
            if let Some(param_sub_title) = param_sub_title {
                query_string.append_pair("subTitle",
                    &param_sub_title);
            }
            if let Some(param_details) = param_details {
                query_string.append_pair("details",
                    &param_details);
            }
            if let Some(param_sub_details) = param_sub_details {
                query_string.append_pair("subDetails",
                    &param_sub_details);
            }
            if let Some(param_fine_print) = param_fine_print {
                query_string.append_pair("finePrint",
                    &param_fine_print);
            }
                query_string.append_pair("barcodeType",
                    &param_barcode_type.to_string());
            if let Some(param_barcode_entry) = param_barcode_entry {
                query_string.append_pair("barcodeEntry",
                    &param_barcode_entry);
            }
            if let Some(param_external_redeem_options) = param_external_redeem_options {
                query_string.append_pair("externalRedeemOptions",
                    &param_external_redeem_options);
            }
            if let Some(param_external_url) = param_external_url {
                query_string.append_pair("externalUrl",
                    &param_external_url);
            }
            if let Some(param_tickets_reward_type) = param_tickets_reward_type {
                query_string.append_pair("ticketsRewardType",
                    &param_tickets_reward_type);
            }
            if let Some(param_tickets_reward) = param_tickets_reward {
                query_string.append_pair("ticketsReward",
                    &param_tickets_reward.to_string());
            }
            if let Some(param_activated) = param_activated {
                query_string.append_pair("activated",
                    &param_activated.to_string());
            }
            if let Some(param_expires) = param_expires {
                query_string.append_pair("expires",
                    &param_expires.to_string());
            }
                query_string.append_pair("noExpiration",
                    &param_no_expiration.to_string());
                query_string.append_pair("availableLimit",
                    &param_available_limit.to_string());
                query_string.append_pair("availableLimitPerUser",
                    &param_available_limit_per_user.to_string());
                query_string.append_pair("addedLimit",
                    &param_added_limit.to_string());
                query_string.append_pair("viewLimit",
                    &param_view_limit.to_string());
                query_string.append_pair("maxPrints",
                    &param_max_prints.to_string());
            if let Some(param_ticket_price_type) = param_ticket_price_type {
                query_string.append_pair("ticketPriceType",
                    &param_ticket_price_type);
            }
                query_string.append_pair("ticketPrice",
                    &param_ticket_price.to_string());
                query_string.append_pair("fullPrice",
                    &param_full_price.to_string());
                query_string.append_pair("discountPrice",
                    &param_discount_price.to_string());
            if let Some(param_show_remaining) = param_show_remaining {
                query_string.append_pair("showRemaining",
                    &param_show_remaining.to_string());
            }
            if let Some(param_show_redeemed) = param_show_redeemed {
                query_string.append_pair("showRedeemed",
                    &param_show_redeemed.to_string());
            }
            if let Some(param_replaced) = param_replaced {
                query_string.append_pair("replaced",
                    &param_replaced.to_string());
            }
            if let Some(param_featured) = param_featured {
                query_string.append_pair("featured",
                    &param_featured.to_string());
            }
                query_string.append_pair("specialOfferType",
                    &param_special_offer_type.to_string());
                query_string.append_pair("offerVisibility",
                    &param_offer_visibility.to_string());
            if let Some(param_category_ids) = param_category_ids {
                query_string.append_pair("categoryIds",
                    &param_category_ids);
            }
            if let Some(param_filter_ids) = param_filter_ids {
                query_string.append_pair("filterIds",
                    &param_filter_ids);
            }
                query_string.append_pair("active",
                    &param_active.to_string());
            if let Some(param_barcode_asset_id) = param_barcode_asset_id {
                query_string.append_pair("barcodeAssetId",
                    &param_barcode_asset_id.to_string());
            }
            if let Some(param_image_asset_id) = param_image_asset_id {
                query_string.append_pair("imageAssetId",
                    &param_image_asset_id.to_string());
            }
            if let Some(param_image_asset_id1) = param_image_asset_id1 {
                query_string.append_pair("imageAssetId1",
                    &param_image_asset_id1.to_string());
            }
            if let Some(param_image_asset_id2) = param_image_asset_id2 {
                query_string.append_pair("imageAssetId2",
                    &param_image_asset_id2.to_string());
            }
            if let Some(param_image_asset_id3) = param_image_asset_id3 {
                query_string.append_pair("imageAssetId3",
                    &param_image_asset_id3.to_string());
            }
            if let Some(param_image_asset_id4) = param_image_asset_id4 {
                query_string.append_pair("imageAssetId4",
                    &param_image_asset_id4.to_string());
            }
            if let Some(param_image_asset_id5) = param_image_asset_id5 {
                query_string.append_pair("imageAssetId5",
                    &param_image_asset_id5.to_string());
            }
            if let Some(param_publisher) = param_publisher {
                query_string.append_pair("publisher",
                    &param_publisher);
            }
            if let Some(param_redeemable_start) = param_redeemable_start {
                query_string.append_pair("redeemableStart",
                    &param_redeemable_start.to_string());
            }
            if let Some(param_redeemable_end) = param_redeemable_end {
                query_string.append_pair("redeemableEnd",
                    &param_redeemable_end.to_string());
            }
            if let Some(param_condition_type) = param_condition_type {
                query_string.append_pair("conditionType",
                    &param_condition_type.to_string());
            }
            if let Some(param_isbn) = param_isbn {
                query_string.append_pair("isbn",
                    &param_isbn);
            }
            if let Some(param_asin) = param_asin {
                query_string.append_pair("asin",
                    &param_asin);
            }
            if let Some(param_catalog_numbers) = param_catalog_numbers {
                query_string.append_pair("catalogNumbers",
                    &param_catalog_numbers);
            }
            if let Some(param_parental_rating) = param_parental_rating {
                query_string.append_pair("parentalRating",
                    &param_parental_rating);
            }
            if let Some(param_availability_date) = param_availability_date {
                query_string.append_pair("availabilityDate",
                    &param_availability_date.to_string());
            }
            if let Some(param_media_type) = param_media_type {
                query_string.append_pair("mediaType",
                    &param_media_type.to_string());
            }
            if let Some(param_duration) = param_duration {
                query_string.append_pair("duration",
                    &param_duration.to_string());
            }
            if let Some(param_author) = param_author {
                query_string.append_pair("author",
                    &param_author);
            }
            if let Some(param_release_date) = param_release_date {
                query_string.append_pair("releaseDate",
                    &param_release_date.to_string());
            }
            if let Some(param_collection_ids) = param_collection_ids {
                query_string.append_pair("collectionIds",
                    &param_collection_ids);
            }
            if let Some(param_availability) = param_availability {
                query_string.append_pair("availability",
                    &param_availability);
            }
            if let Some(param_availability_summary) = param_availability_summary {
                query_string.append_pair("availabilitySummary",
                    &param_availability_summary);
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::MediaOfferResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(CreateMediaResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn delete_media(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_media_id: i64,
        context: &C) -> Result<DeleteMediaResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/media/delete",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("mediaId",
                    &param_media_id.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(DeleteMediaResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_media(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_media_id: i64,
        context: &C) -> Result<GetMediaResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/media/get",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("mediaId",
                    &param_media_id.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::MediaOfferResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetMediaResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn search_media(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_active_only: bool,
        param_sort_field: models::SearchEventsSortFieldParameter,
        param_descending: bool,
        param_keyword: Option<String>,
        param_category_ids: Option<String>,
        param_filter_ids: Option<String>,
        param_start: Option<i32>,
        param_limit: Option<i32>,
        context: &C) -> Result<SearchMediaResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/media/search",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            if let Some(param_keyword) = param_keyword {
                query_string.append_pair("keyword",
                    &param_keyword);
            }
                query_string.append_pair("activeOnly",
                    &param_active_only.to_string());
            if let Some(param_category_ids) = param_category_ids {
                query_string.append_pair("categoryIds",
                    &param_category_ids);
            }
            if let Some(param_filter_ids) = param_filter_ids {
                query_string.append_pair("filterIds",
                    &param_filter_ids);
            }
                query_string.append_pair("sortField",
                    &param_sort_field.to_string());
                query_string.append_pair("descending",
                    &param_descending.to_string());
            if let Some(param_start) = param_start {
                query_string.append_pair("start",
                    &param_start.to_string());
            }
            if let Some(param_limit) = param_limit {
                query_string.append_pair("limit",
                    &param_limit.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<Vec<models::MediaOfferResponse>>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(SearchMediaResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn update_media(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_media_id: i64,
        param_retailer_location_ids: Option<String>,
        param_offer_locations: Option<String>,
        param_title: Option<String>,
        param_sub_title: Option<String>,
        param_details: Option<String>,
        param_sub_details: Option<String>,
        param_fine_print: Option<String>,
        param_barcode_type: Option<models::CreateMediaBarcodeTypeParameter>,
        param_barcode_entry: Option<String>,
        param_external_redeem_options: Option<String>,
        param_external_url: Option<String>,
        param_tickets_reward_type: Option<String>,
        param_tickets_reward: Option<i64>,
        param_activated: Option<i64>,
        param_expires: Option<i64>,
        param_no_expiration: Option<bool>,
        param_available_limit: Option<i32>,
        param_available_limit_per_user: Option<i32>,
        param_added_limit: Option<i32>,
        param_view_limit: Option<i32>,
        param_max_prints: Option<i32>,
        param_ticket_price_type: Option<String>,
        param_ticket_price: Option<i64>,
        param_full_price: Option<f64>,
        param_discount_price: Option<f64>,
        param_show_remaining: Option<bool>,
        param_show_redeemed: Option<bool>,
        param_replaced: Option<bool>,
        param_featured: Option<bool>,
        param_special_offer_type: Option<models::CreateMediaSpecialOfferTypeParameter>,
        param_offer_visibility: Option<models::CreateMediaOfferVisibilityParameter>,
        param_category_ids: Option<String>,
        param_filter_ids: Option<String>,
        param_active: Option<bool>,
        param_barcode_asset_id: Option<i64>,
        param_image_asset_id: Option<i64>,
        param_image_asset_id1: Option<i64>,
        param_image_asset_id2: Option<i64>,
        param_image_asset_id3: Option<i64>,
        param_image_asset_id4: Option<i64>,
        param_image_asset_id5: Option<i64>,
        param_publisher: Option<String>,
        param_redeemable_start: Option<i64>,
        param_redeemable_end: Option<i64>,
        param_condition_type: Option<models::CreateMediaConditionTypeParameter>,
        param_isbn: Option<String>,
        param_asin: Option<String>,
        param_catalog_numbers: Option<String>,
        param_availability_date: Option<i64>,
        param_parental_rating: Option<String>,
        param_media_type: Option<models::CreateMediaMediaTypeParameter>,
        param_duration: Option<i32>,
        param_author: Option<String>,
        param_release_date: Option<i64>,
        param_collection_ids: Option<String>,
        param_availability: Option<String>,
        param_availability_summary: Option<String>,
        context: &C) -> Result<UpdateMediaResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/media/update",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("mediaId",
                    &param_media_id.to_string());
            if let Some(param_retailer_location_ids) = param_retailer_location_ids {
                query_string.append_pair("retailerLocationIds",
                    &param_retailer_location_ids);
            }
            if let Some(param_offer_locations) = param_offer_locations {
                query_string.append_pair("offerLocations",
                    &param_offer_locations);
            }
            if let Some(param_title) = param_title {
                query_string.append_pair("title",
                    &param_title);
            }
            if let Some(param_sub_title) = param_sub_title {
                query_string.append_pair("subTitle",
                    &param_sub_title);
            }
            if let Some(param_details) = param_details {
                query_string.append_pair("details",
                    &param_details);
            }
            if let Some(param_sub_details) = param_sub_details {
                query_string.append_pair("subDetails",
                    &param_sub_details);
            }
            if let Some(param_fine_print) = param_fine_print {
                query_string.append_pair("finePrint",
                    &param_fine_print);
            }
            if let Some(param_barcode_type) = param_barcode_type {
                query_string.append_pair("barcodeType",
                    &param_barcode_type.to_string());
            }
            if let Some(param_barcode_entry) = param_barcode_entry {
                query_string.append_pair("barcodeEntry",
                    &param_barcode_entry);
            }
            if let Some(param_external_redeem_options) = param_external_redeem_options {
                query_string.append_pair("externalRedeemOptions",
                    &param_external_redeem_options);
            }
            if let Some(param_external_url) = param_external_url {
                query_string.append_pair("externalUrl",
                    &param_external_url);
            }
            if let Some(param_tickets_reward_type) = param_tickets_reward_type {
                query_string.append_pair("ticketsRewardType",
                    &param_tickets_reward_type);
            }
            if let Some(param_tickets_reward) = param_tickets_reward {
                query_string.append_pair("ticketsReward",
                    &param_tickets_reward.to_string());
            }
            if let Some(param_activated) = param_activated {
                query_string.append_pair("activated",
                    &param_activated.to_string());
            }
            if let Some(param_expires) = param_expires {
                query_string.append_pair("expires",
                    &param_expires.to_string());
            }
            if let Some(param_no_expiration) = param_no_expiration {
                query_string.append_pair("noExpiration",
                    &param_no_expiration.to_string());
            }
            if let Some(param_available_limit) = param_available_limit {
                query_string.append_pair("availableLimit",
                    &param_available_limit.to_string());
            }
            if let Some(param_available_limit_per_user) = param_available_limit_per_user {
                query_string.append_pair("availableLimitPerUser",
                    &param_available_limit_per_user.to_string());
            }
            if let Some(param_added_limit) = param_added_limit {
                query_string.append_pair("addedLimit",
                    &param_added_limit.to_string());
            }
            if let Some(param_view_limit) = param_view_limit {
                query_string.append_pair("viewLimit",
                    &param_view_limit.to_string());
            }
            if let Some(param_max_prints) = param_max_prints {
                query_string.append_pair("maxPrints",
                    &param_max_prints.to_string());
            }
            if let Some(param_ticket_price_type) = param_ticket_price_type {
                query_string.append_pair("ticketPriceType",
                    &param_ticket_price_type);
            }
            if let Some(param_ticket_price) = param_ticket_price {
                query_string.append_pair("ticketPrice",
                    &param_ticket_price.to_string());
            }
            if let Some(param_full_price) = param_full_price {
                query_string.append_pair("fullPrice",
                    &param_full_price.to_string());
            }
            if let Some(param_discount_price) = param_discount_price {
                query_string.append_pair("discountPrice",
                    &param_discount_price.to_string());
            }
            if let Some(param_show_remaining) = param_show_remaining {
                query_string.append_pair("showRemaining",
                    &param_show_remaining.to_string());
            }
            if let Some(param_show_redeemed) = param_show_redeemed {
                query_string.append_pair("showRedeemed",
                    &param_show_redeemed.to_string());
            }
            if let Some(param_replaced) = param_replaced {
                query_string.append_pair("replaced",
                    &param_replaced.to_string());
            }
            if let Some(param_featured) = param_featured {
                query_string.append_pair("featured",
                    &param_featured.to_string());
            }
            if let Some(param_special_offer_type) = param_special_offer_type {
                query_string.append_pair("specialOfferType",
                    &param_special_offer_type.to_string());
            }
            if let Some(param_offer_visibility) = param_offer_visibility {
                query_string.append_pair("offerVisibility",
                    &param_offer_visibility.to_string());
            }
            if let Some(param_category_ids) = param_category_ids {
                query_string.append_pair("categoryIds",
                    &param_category_ids);
            }
            if let Some(param_filter_ids) = param_filter_ids {
                query_string.append_pair("filterIds",
                    &param_filter_ids);
            }
            if let Some(param_active) = param_active {
                query_string.append_pair("active",
                    &param_active.to_string());
            }
            if let Some(param_barcode_asset_id) = param_barcode_asset_id {
                query_string.append_pair("barcodeAssetId",
                    &param_barcode_asset_id.to_string());
            }
            if let Some(param_image_asset_id) = param_image_asset_id {
                query_string.append_pair("imageAssetId",
                    &param_image_asset_id.to_string());
            }
            if let Some(param_image_asset_id1) = param_image_asset_id1 {
                query_string.append_pair("imageAssetId1",
                    &param_image_asset_id1.to_string());
            }
            if let Some(param_image_asset_id2) = param_image_asset_id2 {
                query_string.append_pair("imageAssetId2",
                    &param_image_asset_id2.to_string());
            }
            if let Some(param_image_asset_id3) = param_image_asset_id3 {
                query_string.append_pair("imageAssetId3",
                    &param_image_asset_id3.to_string());
            }
            if let Some(param_image_asset_id4) = param_image_asset_id4 {
                query_string.append_pair("imageAssetId4",
                    &param_image_asset_id4.to_string());
            }
            if let Some(param_image_asset_id5) = param_image_asset_id5 {
                query_string.append_pair("imageAssetId5",
                    &param_image_asset_id5.to_string());
            }
            if let Some(param_publisher) = param_publisher {
                query_string.append_pair("publisher",
                    &param_publisher);
            }
            if let Some(param_redeemable_start) = param_redeemable_start {
                query_string.append_pair("redeemableStart",
                    &param_redeemable_start.to_string());
            }
            if let Some(param_redeemable_end) = param_redeemable_end {
                query_string.append_pair("redeemableEnd",
                    &param_redeemable_end.to_string());
            }
            if let Some(param_condition_type) = param_condition_type {
                query_string.append_pair("conditionType",
                    &param_condition_type.to_string());
            }
            if let Some(param_isbn) = param_isbn {
                query_string.append_pair("isbn",
                    &param_isbn);
            }
            if let Some(param_asin) = param_asin {
                query_string.append_pair("asin",
                    &param_asin);
            }
            if let Some(param_catalog_numbers) = param_catalog_numbers {
                query_string.append_pair("catalogNumbers",
                    &param_catalog_numbers);
            }
            if let Some(param_availability_date) = param_availability_date {
                query_string.append_pair("availabilityDate",
                    &param_availability_date.to_string());
            }
            if let Some(param_parental_rating) = param_parental_rating {
                query_string.append_pair("parentalRating",
                    &param_parental_rating);
            }
            if let Some(param_media_type) = param_media_type {
                query_string.append_pair("mediaType",
                    &param_media_type.to_string());
            }
            if let Some(param_duration) = param_duration {
                query_string.append_pair("duration",
                    &param_duration.to_string());
            }
            if let Some(param_author) = param_author {
                query_string.append_pair("author",
                    &param_author);
            }
            if let Some(param_release_date) = param_release_date {
                query_string.append_pair("releaseDate",
                    &param_release_date.to_string());
            }
            if let Some(param_collection_ids) = param_collection_ids {
                query_string.append_pair("collectionIds",
                    &param_collection_ids);
            }
            if let Some(param_availability) = param_availability {
                query_string.append_pair("availability",
                    &param_availability);
            }
            if let Some(param_availability_summary) = param_availability_summary {
                query_string.append_pair("availabilitySummary",
                    &param_availability_summary);
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::MediaOfferResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(UpdateMediaResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn create_mission(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_title: String,
        param_description: Option<String>,
        param_sub_type: Option<String>,
        param_start_date: Option<i64>,
        param_end_date: Option<i64>,
        param_active: Option<bool>,
        param_game_level_ids: Option<String>,
        param_creative_ids: Option<String>,
        param_audience_ids: Option<String>,
        param_mission_task: Option<String>,
        param_format_type: Option<String>,
        param_offer_id: Option<i64>,
        param_balance: Option<f64>,
        param_advanced_reporting: Option<bool>,
        param_allocate_tickets: Option<bool>,
        param_ticket_count: Option<i64>,
        param_ticket_type: Option<String>,
        param_points: Option<i64>,
        param_meta_data: Option<String>,
        param_application_ids: Option<String>,
        param_devices: Option<String>,
        param_device_ids: Option<String>,
        param_device_versions: Option<String>,
        param_locations: Option<String>,
        param_radius: Option<String>,
        context: &C) -> Result<CreateMissionResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/mission/create",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("title",
                    &param_title);
            if let Some(param_description) = param_description {
                query_string.append_pair("description",
                    &param_description);
            }
            if let Some(param_sub_type) = param_sub_type {
                query_string.append_pair("subType",
                    &param_sub_type);
            }
            if let Some(param_start_date) = param_start_date {
                query_string.append_pair("startDate",
                    &param_start_date.to_string());
            }
            if let Some(param_end_date) = param_end_date {
                query_string.append_pair("endDate",
                    &param_end_date.to_string());
            }
            if let Some(param_active) = param_active {
                query_string.append_pair("active",
                    &param_active.to_string());
            }
            if let Some(param_game_level_ids) = param_game_level_ids {
                query_string.append_pair("gameLevelIds",
                    &param_game_level_ids);
            }
            if let Some(param_creative_ids) = param_creative_ids {
                query_string.append_pair("creativeIds",
                    &param_creative_ids);
            }
            if let Some(param_audience_ids) = param_audience_ids {
                query_string.append_pair("audienceIds",
                    &param_audience_ids);
            }
            if let Some(param_mission_task) = param_mission_task {
                query_string.append_pair("missionTask",
                    &param_mission_task);
            }
            if let Some(param_format_type) = param_format_type {
                query_string.append_pair("formatType",
                    &param_format_type);
            }
            if let Some(param_offer_id) = param_offer_id {
                query_string.append_pair("offerId",
                    &param_offer_id.to_string());
            }
            if let Some(param_balance) = param_balance {
                query_string.append_pair("balance",
                    &param_balance.to_string());
            }
            if let Some(param_advanced_reporting) = param_advanced_reporting {
                query_string.append_pair("advancedReporting",
                    &param_advanced_reporting.to_string());
            }
            if let Some(param_allocate_tickets) = param_allocate_tickets {
                query_string.append_pair("allocateTickets",
                    &param_allocate_tickets.to_string());
            }
            if let Some(param_ticket_count) = param_ticket_count {
                query_string.append_pair("ticketCount",
                    &param_ticket_count.to_string());
            }
            if let Some(param_ticket_type) = param_ticket_type {
                query_string.append_pair("ticketType",
                    &param_ticket_type);
            }
            if let Some(param_points) = param_points {
                query_string.append_pair("points",
                    &param_points.to_string());
            }
            if let Some(param_meta_data) = param_meta_data {
                query_string.append_pair("metaData",
                    &param_meta_data);
            }
            if let Some(param_application_ids) = param_application_ids {
                query_string.append_pair("applicationIds",
                    &param_application_ids);
            }
            if let Some(param_devices) = param_devices {
                query_string.append_pair("devices",
                    &param_devices);
            }
            if let Some(param_device_ids) = param_device_ids {
                query_string.append_pair("deviceIds",
                    &param_device_ids);
            }
            if let Some(param_device_versions) = param_device_versions {
                query_string.append_pair("deviceVersions",
                    &param_device_versions);
            }
            if let Some(param_locations) = param_locations {
                query_string.append_pair("locations",
                    &param_locations);
            }
            if let Some(param_radius) = param_radius {
                query_string.append_pair("radius",
                    &param_radius);
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::MissionResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(CreateMissionResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn delete_mission(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_mission_id: i64,
        context: &C) -> Result<DeleteMissionResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/mission/delete",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("missionId",
                    &param_mission_id.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(DeleteMissionResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn find_missions(
        &self,
        param_version: f64,
        param_app_key: String,
        param_suffix: Option<String>,
        param_param_type: Option<String>,
        param_account_id: Option<i64>,
        param_app_version: Option<String>,
        param_latitude: Option<f64>,
        param_longitude: Option<f64>,
        param_device: Option<String>,
        param_device_identifier: Option<i64>,
        param_device_version: Option<String>,
        param_start: Option<i32>,
        param_limit: Option<i32>,
        param_include_game_data: Option<bool>,
        param_include_audiences: Option<bool>,
        param_allocates_tickets: Option<bool>,
        param_randomize: Option<bool>,
        param_targeted_ads_only: Option<bool>,
        param_mission_ids: Option<String>,
        param_audience_operator: Option<String>,
        context: &C) -> Result<FindMissionsResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/mission/find",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("appKey",
                    &param_app_key);
            if let Some(param_suffix) = param_suffix {
                query_string.append_pair("suffix",
                    &param_suffix);
            }
            if let Some(param_param_type) = param_param_type {
                query_string.append_pair("type",
                    &param_param_type);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_app_version) = param_app_version {
                query_string.append_pair("appVersion",
                    &param_app_version);
            }
            if let Some(param_latitude) = param_latitude {
                query_string.append_pair("latitude",
                    &param_latitude.to_string());
            }
            if let Some(param_longitude) = param_longitude {
                query_string.append_pair("longitude",
                    &param_longitude.to_string());
            }
            if let Some(param_device) = param_device {
                query_string.append_pair("device",
                    &param_device);
            }
            if let Some(param_device_identifier) = param_device_identifier {
                query_string.append_pair("deviceIdentifier",
                    &param_device_identifier.to_string());
            }
            if let Some(param_device_version) = param_device_version {
                query_string.append_pair("deviceVersion",
                    &param_device_version);
            }
            if let Some(param_start) = param_start {
                query_string.append_pair("start",
                    &param_start.to_string());
            }
            if let Some(param_limit) = param_limit {
                query_string.append_pair("limit",
                    &param_limit.to_string());
            }
            if let Some(param_include_game_data) = param_include_game_data {
                query_string.append_pair("includeGameData",
                    &param_include_game_data.to_string());
            }
            if let Some(param_include_audiences) = param_include_audiences {
                query_string.append_pair("includeAudiences",
                    &param_include_audiences.to_string());
            }
            if let Some(param_allocates_tickets) = param_allocates_tickets {
                query_string.append_pair("allocatesTickets",
                    &param_allocates_tickets.to_string());
            }
            if let Some(param_randomize) = param_randomize {
                query_string.append_pair("randomize",
                    &param_randomize.to_string());
            }
            if let Some(param_targeted_ads_only) = param_targeted_ads_only {
                query_string.append_pair("targetedAdsOnly",
                    &param_targeted_ads_only.to_string());
            }
            if let Some(param_mission_ids) = param_mission_ids {
                query_string.append_pair("missionIds",
                    &param_mission_ids);
            }
            if let Some(param_audience_operator) = param_audience_operator {
                query_string.append_pair("audienceOperator",
                    &param_audience_operator);
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::MissionResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(FindMissionsResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_mission(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_mission_id: i64,
        param_return_creative: Option<bool>,
        context: &C) -> Result<GetMissionResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/mission/get",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("missionId",
                    &param_mission_id.to_string());
            if let Some(param_return_creative) = param_return_creative {
                query_string.append_pair("returnCreative",
                    &param_return_creative.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::MissionResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetMissionResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn import_mission(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_latitude: f64,
        param_longitude: f64,
        param_app_key: String,
        param_keyword: Option<String>,
        param_start: Option<i32>,
        param_limit: Option<i32>,
        param_ad_size: Option<models::CreateApplicationPlacementSizeParameter>,
        context: &C) -> Result<ImportMissionResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/mission/import",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("latitude",
                    &param_latitude.to_string());
                query_string.append_pair("longitude",
                    &param_longitude.to_string());
            if let Some(param_keyword) = param_keyword {
                query_string.append_pair("keyword",
                    &param_keyword);
            }
            if let Some(param_start) = param_start {
                query_string.append_pair("start",
                    &param_start.to_string());
            }
            if let Some(param_limit) = param_limit {
                query_string.append_pair("limit",
                    &param_limit.to_string());
            }
                query_string.append_pair("appKey",
                    &param_app_key);
            if let Some(param_ad_size) = param_ad_size {
                query_string.append_pair("adSize",
                    &param_ad_size.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(ImportMissionResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn search_mission_formats(
        &self,
        param_version: f64,
        param_start: i32,
        param_limit: i32,
        param_active_only: bool,
        context: &C) -> Result<SearchMissionFormatsResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/mission/format/search",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("start",
                    &param_start.to_string());
                query_string.append_pair("limit",
                    &param_limit.to_string());
                query_string.append_pair("activeOnly",
                    &param_active_only.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<Vec<models::MissionFormatResponse>>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(SearchMissionFormatsResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn search_missions(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_keyword: Option<String>,
        param_sub_type: Option<String>,
        param_start: Option<i32>,
        param_limit: Option<i32>,
        param_include_game_data: Option<bool>,
        param_include_audiences: Option<bool>,
        param_include_inactive: Option<bool>,
        param_suffix: Option<String>,
        param_sort_field: Option<String>,
        param_descending: Option<bool>,
        context: &C) -> Result<SearchMissionsResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/mission/search",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            if let Some(param_keyword) = param_keyword {
                query_string.append_pair("keyword",
                    &param_keyword);
            }
            if let Some(param_sub_type) = param_sub_type {
                query_string.append_pair("subType",
                    &param_sub_type);
            }
            if let Some(param_start) = param_start {
                query_string.append_pair("start",
                    &param_start.to_string());
            }
            if let Some(param_limit) = param_limit {
                query_string.append_pair("limit",
                    &param_limit.to_string());
            }
            if let Some(param_include_game_data) = param_include_game_data {
                query_string.append_pair("includeGameData",
                    &param_include_game_data.to_string());
            }
            if let Some(param_include_audiences) = param_include_audiences {
                query_string.append_pair("includeAudiences",
                    &param_include_audiences.to_string());
            }
            if let Some(param_include_inactive) = param_include_inactive {
                query_string.append_pair("includeInactive",
                    &param_include_inactive.to_string());
            }
            if let Some(param_suffix) = param_suffix {
                query_string.append_pair("suffix",
                    &param_suffix);
            }
            if let Some(param_sort_field) = param_sort_field {
                query_string.append_pair("sortField",
                    &param_sort_field);
            }
            if let Some(param_descending) = param_descending {
                query_string.append_pair("descending",
                    &param_descending.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<Vec<models::MissionResponse>>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(SearchMissionsResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn search_missions_by_billable_entity(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_keyword: Option<String>,
        param_start: Option<i32>,
        param_limit: Option<i32>,
        param_include_game_data: Option<bool>,
        param_include_audiences: Option<bool>,
        param_include_inactive: Option<bool>,
        param_suffix: Option<String>,
        param_sort_field: Option<String>,
        param_descending: Option<bool>,
        context: &C) -> Result<SearchMissionsByBillableEntityResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/mission/searchByBillableEntity",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            if let Some(param_keyword) = param_keyword {
                query_string.append_pair("keyword",
                    &param_keyword);
            }
            if let Some(param_start) = param_start {
                query_string.append_pair("start",
                    &param_start.to_string());
            }
            if let Some(param_limit) = param_limit {
                query_string.append_pair("limit",
                    &param_limit.to_string());
            }
            if let Some(param_include_game_data) = param_include_game_data {
                query_string.append_pair("includeGameData",
                    &param_include_game_data.to_string());
            }
            if let Some(param_include_audiences) = param_include_audiences {
                query_string.append_pair("includeAudiences",
                    &param_include_audiences.to_string());
            }
            if let Some(param_include_inactive) = param_include_inactive {
                query_string.append_pair("includeInactive",
                    &param_include_inactive.to_string());
            }
            if let Some(param_suffix) = param_suffix {
                query_string.append_pair("suffix",
                    &param_suffix);
            }
            if let Some(param_sort_field) = param_sort_field {
                query_string.append_pair("sortField",
                    &param_sort_field);
            }
            if let Some(param_descending) = param_descending {
                query_string.append_pair("descending",
                    &param_descending.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<Vec<models::MissionResponse>>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(SearchMissionsByBillableEntityResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn update_mission(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_mission_id: i64,
        param_title: Option<String>,
        param_description: Option<String>,
        param_sub_type: Option<String>,
        param_meta_data: Option<String>,
        param_start_date: Option<i64>,
        param_end_date: Option<i64>,
        param_active: Option<bool>,
        param_game_level_ids: Option<String>,
        param_creative_ids: Option<String>,
        param_audience_ids: Option<String>,
        param_offer_id: Option<i64>,
        param_balance: Option<f64>,
        param_advanced_reporting: Option<bool>,
        param_allocate_tickets: Option<bool>,
        param_ticket_count: Option<i64>,
        param_ticket_type: Option<String>,
        param_points: Option<i64>,
        param_application_ids: Option<String>,
        param_devices: Option<String>,
        param_device_ids: Option<String>,
        param_device_versions: Option<String>,
        param_locations: Option<String>,
        param_radius: Option<String>,
        context: &C) -> Result<UpdateMissionResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/mission/update",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("missionId",
                    &param_mission_id.to_string());
            if let Some(param_title) = param_title {
                query_string.append_pair("title",
                    &param_title);
            }
            if let Some(param_description) = param_description {
                query_string.append_pair("description",
                    &param_description);
            }
            if let Some(param_sub_type) = param_sub_type {
                query_string.append_pair("subType",
                    &param_sub_type);
            }
            if let Some(param_meta_data) = param_meta_data {
                query_string.append_pair("metaData",
                    &param_meta_data);
            }
            if let Some(param_start_date) = param_start_date {
                query_string.append_pair("startDate",
                    &param_start_date.to_string());
            }
            if let Some(param_end_date) = param_end_date {
                query_string.append_pair("endDate",
                    &param_end_date.to_string());
            }
            if let Some(param_active) = param_active {
                query_string.append_pair("active",
                    &param_active.to_string());
            }
            if let Some(param_game_level_ids) = param_game_level_ids {
                query_string.append_pair("gameLevelIds",
                    &param_game_level_ids);
            }
            if let Some(param_creative_ids) = param_creative_ids {
                query_string.append_pair("creativeIds",
                    &param_creative_ids);
            }
            if let Some(param_audience_ids) = param_audience_ids {
                query_string.append_pair("audienceIds",
                    &param_audience_ids);
            }
            if let Some(param_offer_id) = param_offer_id {
                query_string.append_pair("offerId",
                    &param_offer_id.to_string());
            }
            if let Some(param_balance) = param_balance {
                query_string.append_pair("balance",
                    &param_balance.to_string());
            }
            if let Some(param_advanced_reporting) = param_advanced_reporting {
                query_string.append_pair("advancedReporting",
                    &param_advanced_reporting.to_string());
            }
            if let Some(param_allocate_tickets) = param_allocate_tickets {
                query_string.append_pair("allocateTickets",
                    &param_allocate_tickets.to_string());
            }
            if let Some(param_ticket_count) = param_ticket_count {
                query_string.append_pair("ticketCount",
                    &param_ticket_count.to_string());
            }
            if let Some(param_ticket_type) = param_ticket_type {
                query_string.append_pair("ticketType",
                    &param_ticket_type);
            }
            if let Some(param_points) = param_points {
                query_string.append_pair("points",
                    &param_points.to_string());
            }
            if let Some(param_application_ids) = param_application_ids {
                query_string.append_pair("applicationIds",
                    &param_application_ids);
            }
            if let Some(param_devices) = param_devices {
                query_string.append_pair("devices",
                    &param_devices);
            }
            if let Some(param_device_ids) = param_device_ids {
                query_string.append_pair("deviceIds",
                    &param_device_ids);
            }
            if let Some(param_device_versions) = param_device_versions {
                query_string.append_pair("deviceVersions",
                    &param_device_versions);
            }
            if let Some(param_locations) = param_locations {
                query_string.append_pair("locations",
                    &param_locations);
            }
            if let Some(param_radius) = param_radius {
                query_string.append_pair("radius",
                    &param_radius);
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::MissionResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(UpdateMissionResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn create_mission_invite(
        &self,
        param_version: f64,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_mission_id: Option<i64>,
        param_join_code: Option<String>,
        param_include_game_data: Option<bool>,
        context: &C) -> Result<CreateMissionInviteResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/mission/invite/create",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_mission_id) = param_mission_id {
                query_string.append_pair("missionId",
                    &param_mission_id.to_string());
            }
            if let Some(param_join_code) = param_join_code {
                query_string.append_pair("joinCode",
                    &param_join_code);
            }
            if let Some(param_include_game_data) = param_include_game_data {
                query_string.append_pair("includeGameData",
                    &param_include_game_data.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::MissionResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(CreateMissionInviteResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn delete_mission_invite(
        &self,
        param_version: f64,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_mission_id: Option<i64>,
        param_mission_invite_id: Option<i64>,
        param_include_game_data: Option<bool>,
        context: &C) -> Result<DeleteMissionInviteResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/mission/invite/delete",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_mission_id) = param_mission_id {
                query_string.append_pair("missionId",
                    &param_mission_id.to_string());
            }
            if let Some(param_mission_invite_id) = param_mission_invite_id {
                query_string.append_pair("missionInviteId",
                    &param_mission_invite_id.to_string());
            }
            if let Some(param_include_game_data) = param_include_game_data {
                query_string.append_pair("includeGameData",
                    &param_include_game_data.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(DeleteMissionInviteResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_mission_invite(
        &self,
        param_version: f64,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_mission_id: Option<i64>,
        param_mission_invite_id: Option<i64>,
        param_include_game_data: Option<bool>,
        param_include_scores: Option<String>,
        context: &C) -> Result<GetMissionInviteResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/mission/invite/get",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_mission_id) = param_mission_id {
                query_string.append_pair("missionId",
                    &param_mission_id.to_string());
            }
            if let Some(param_mission_invite_id) = param_mission_invite_id {
                query_string.append_pair("missionInviteId",
                    &param_mission_invite_id.to_string());
            }
            if let Some(param_include_game_data) = param_include_game_data {
                query_string.append_pair("includeGameData",
                    &param_include_game_data.to_string());
            }
            if let Some(param_include_scores) = param_include_scores {
                query_string.append_pair("includeScores",
                    &param_include_scores);
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::MissionResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetMissionInviteResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn search_mission_invites(
        &self,
        param_version: f64,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_app_key: Option<String>,
        param_app_version: Option<String>,
        param_mission_id: Option<i64>,
        param_status: Option<String>,
        param_last_updated: Option<i64>,
        param_start: Option<i32>,
        param_limit: Option<i32>,
        param_keyword: Option<String>,
        param_mission_types: Option<String>,
        param_filter_by_billable: Option<bool>,
        param_include_game_data: Option<bool>,
        context: &C) -> Result<SearchMissionInvitesResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/mission/invite/search",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_app_key) = param_app_key {
                query_string.append_pair("appKey",
                    &param_app_key);
            }
            if let Some(param_app_version) = param_app_version {
                query_string.append_pair("appVersion",
                    &param_app_version);
            }
            if let Some(param_mission_id) = param_mission_id {
                query_string.append_pair("missionId",
                    &param_mission_id.to_string());
            }
            if let Some(param_status) = param_status {
                query_string.append_pair("status",
                    &param_status);
            }
            if let Some(param_last_updated) = param_last_updated {
                query_string.append_pair("lastUpdated",
                    &param_last_updated.to_string());
            }
            if let Some(param_start) = param_start {
                query_string.append_pair("start",
                    &param_start.to_string());
            }
            if let Some(param_limit) = param_limit {
                query_string.append_pair("limit",
                    &param_limit.to_string());
            }
            if let Some(param_keyword) = param_keyword {
                query_string.append_pair("keyword",
                    &param_keyword);
            }
            if let Some(param_mission_types) = param_mission_types {
                query_string.append_pair("missionTypes",
                    &param_mission_types);
            }
            if let Some(param_filter_by_billable) = param_filter_by_billable {
                query_string.append_pair("filterByBillable",
                    &param_filter_by_billable.to_string());
            }
            if let Some(param_include_game_data) = param_include_game_data {
                query_string.append_pair("includeGameData",
                    &param_include_game_data.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<Vec<models::MissionResponse>>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(SearchMissionInvitesResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn update_mission_invite(
        &self,
        param_version: f64,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_app_key: Option<String>,
        param_mission_id: Option<i64>,
        param_mission_invite_id: Option<i64>,
        param_pack_id: Option<i64>,
        param_game_level_id: Option<i64>,
        param_status: Option<String>,
        param_permissionable_type: Option<String>,
        param_permissionable_id: Option<i64>,
        param_include_game_data: Option<bool>,
        context: &C) -> Result<UpdateMissionInviteResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/mission/invite/update",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_app_key) = param_app_key {
                query_string.append_pair("appKey",
                    &param_app_key);
            }
            if let Some(param_mission_id) = param_mission_id {
                query_string.append_pair("missionId",
                    &param_mission_id.to_string());
            }
            if let Some(param_mission_invite_id) = param_mission_invite_id {
                query_string.append_pair("missionInviteId",
                    &param_mission_invite_id.to_string());
            }
            if let Some(param_pack_id) = param_pack_id {
                query_string.append_pair("packId",
                    &param_pack_id.to_string());
            }
            if let Some(param_game_level_id) = param_game_level_id {
                query_string.append_pair("gameLevelId",
                    &param_game_level_id.to_string());
            }
            if let Some(param_status) = param_status {
                query_string.append_pair("status",
                    &param_status);
            }
            if let Some(param_permissionable_type) = param_permissionable_type {
                query_string.append_pair("permissionableType",
                    &param_permissionable_type);
            }
            if let Some(param_permissionable_id) = param_permissionable_id {
                query_string.append_pair("permissionableId",
                    &param_permissionable_id.to_string());
            }
            if let Some(param_include_game_data) = param_include_game_data {
                query_string.append_pair("includeGameData",
                    &param_include_game_data.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::MissionResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(UpdateMissionInviteResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn batch_operation(
        &self,
        param_version: f64,
        param_notable_id: i64,
        param_notable_type: String,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_batch_operation: Option<String>,
        context: &C) -> Result<BatchOperationResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/note/batch",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
                query_string.append_pair("notableId",
                    &param_notable_id.to_string());
                query_string.append_pair("notableType",
                    &param_notable_type);
            if let Some(param_batch_operation) = param_batch_operation {
                query_string.append_pair("batchOperation",
                    &param_batch_operation);
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(BatchOperationResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn create_note(
        &self,
        param_version: f64,
        param_comment: String,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_notable_type: Option<String>,
        param_notable_id: Option<i64>,
        param_note_type: Option<String>,
        param_asset_ids: Option<String>,
        param_tags: Option<String>,
        param_permissionable_type: Option<String>,
        param_permissionable_id: Option<i64>,
        param_app_key: Option<String>,
        param_location_description: Option<String>,
        param_latitude: Option<f64>,
        param_longitude: Option<f64>,
        param_meta_data: Option<String>,
        param_receiver_account_ids: Option<String>,
        param_return_full_response: Option<bool>,
        param_initialize_asset: Option<bool>,
        param_asset_return_nulls: Option<bool>,
        param_asset_album_id: Option<i64>,
        param_asset_collection_id: Option<i64>,
        param_asset_add_to_default_album: Option<String>,
        param_asset_add_to_media_library: Option<bool>,
        param_asset_version_code: Option<i32>,
        param_asset_version_name: Option<String>,
        param_asset_meta_data: Option<String>,
        param_asset_caption: Option<String>,
        param_asset_media: Option<swagger::ByteArray>,
        param_asset_media_url: Option<String>,
        param_asset_media_string: Option<String>,
        param_asset_media_string_file_name: Option<String>,
        param_asset_media_string_content_type: Option<String>,
        param_asset_attached_media: Option<swagger::ByteArray>,
        param_asset_attached_media_url: Option<String>,
        param_asset_attached_media_string: Option<String>,
        param_asset_attached_media_string_file_name: Option<String>,
        param_asset_attached_media_string_content_type: Option<String>,
        param_asset_location_description: Option<String>,
        param_asset_app: Option<String>,
        param_asset_search_tags: Option<String>,
        param_asset_latitude: Option<f64>,
        param_asset_longitude: Option<f64>,
        context: &C) -> Result<CreateNoteResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/note/create",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_notable_type) = param_notable_type {
                query_string.append_pair("notableType",
                    &param_notable_type);
            }
            if let Some(param_notable_id) = param_notable_id {
                query_string.append_pair("notableId",
                    &param_notable_id.to_string());
            }
                query_string.append_pair("comment",
                    &param_comment);
            if let Some(param_note_type) = param_note_type {
                query_string.append_pair("noteType",
                    &param_note_type);
            }
            if let Some(param_asset_ids) = param_asset_ids {
                query_string.append_pair("assetIds",
                    &param_asset_ids);
            }
            if let Some(param_tags) = param_tags {
                query_string.append_pair("tags",
                    &param_tags);
            }
            if let Some(param_permissionable_type) = param_permissionable_type {
                query_string.append_pair("permissionableType",
                    &param_permissionable_type);
            }
            if let Some(param_permissionable_id) = param_permissionable_id {
                query_string.append_pair("permissionableId",
                    &param_permissionable_id.to_string());
            }
            if let Some(param_app_key) = param_app_key {
                query_string.append_pair("appKey",
                    &param_app_key);
            }
            if let Some(param_location_description) = param_location_description {
                query_string.append_pair("locationDescription",
                    &param_location_description);
            }
            if let Some(param_latitude) = param_latitude {
                query_string.append_pair("latitude",
                    &param_latitude.to_string());
            }
            if let Some(param_longitude) = param_longitude {
                query_string.append_pair("longitude",
                    &param_longitude.to_string());
            }
            if let Some(param_meta_data) = param_meta_data {
                query_string.append_pair("metaData",
                    &param_meta_data);
            }
            if let Some(param_receiver_account_ids) = param_receiver_account_ids {
                query_string.append_pair("receiverAccountIds",
                    &param_receiver_account_ids);
            }
            if let Some(param_return_full_response) = param_return_full_response {
                query_string.append_pair("returnFullResponse",
                    &param_return_full_response.to_string());
            }
            if let Some(param_initialize_asset) = param_initialize_asset {
                query_string.append_pair("initializeAsset",
                    &param_initialize_asset.to_string());
            }
            if let Some(param_asset_return_nulls) = param_asset_return_nulls {
                query_string.append_pair("assetReturnNulls",
                    &param_asset_return_nulls.to_string());
            }
            if let Some(param_asset_album_id) = param_asset_album_id {
                query_string.append_pair("assetAlbumId",
                    &param_asset_album_id.to_string());
            }
            if let Some(param_asset_collection_id) = param_asset_collection_id {
                query_string.append_pair("assetCollectionId",
                    &param_asset_collection_id.to_string());
            }
            if let Some(param_asset_add_to_default_album) = param_asset_add_to_default_album {
                query_string.append_pair("assetAddToDefaultAlbum",
                    &param_asset_add_to_default_album);
            }
            if let Some(param_asset_add_to_media_library) = param_asset_add_to_media_library {
                query_string.append_pair("assetAddToMediaLibrary",
                    &param_asset_add_to_media_library.to_string());
            }
            if let Some(param_asset_version_code) = param_asset_version_code {
                query_string.append_pair("assetVersionCode",
                    &param_asset_version_code.to_string());
            }
            if let Some(param_asset_version_name) = param_asset_version_name {
                query_string.append_pair("assetVersionName",
                    &param_asset_version_name);
            }
            if let Some(param_asset_meta_data) = param_asset_meta_data {
                query_string.append_pair("assetMetaData",
                    &param_asset_meta_data);
            }
            if let Some(param_asset_caption) = param_asset_caption {
                query_string.append_pair("assetCaption",
                    &param_asset_caption);
            }
            if let Some(param_asset_media) = param_asset_media {
                query_string.append_pair("assetMedia",
                    &param_asset_media.to_string());
            }
            if let Some(param_asset_media_url) = param_asset_media_url {
                query_string.append_pair("assetMediaUrl",
                    &param_asset_media_url);
            }
            if let Some(param_asset_media_string) = param_asset_media_string {
                query_string.append_pair("assetMediaString",
                    &param_asset_media_string);
            }
            if let Some(param_asset_media_string_file_name) = param_asset_media_string_file_name {
                query_string.append_pair("assetMediaStringFileName",
                    &param_asset_media_string_file_name);
            }
            if let Some(param_asset_media_string_content_type) = param_asset_media_string_content_type {
                query_string.append_pair("assetMediaStringContentType",
                    &param_asset_media_string_content_type);
            }
            if let Some(param_asset_attached_media) = param_asset_attached_media {
                query_string.append_pair("assetAttachedMedia",
                    &param_asset_attached_media.to_string());
            }
            if let Some(param_asset_attached_media_url) = param_asset_attached_media_url {
                query_string.append_pair("assetAttachedMediaUrl",
                    &param_asset_attached_media_url);
            }
            if let Some(param_asset_attached_media_string) = param_asset_attached_media_string {
                query_string.append_pair("assetAttachedMediaString",
                    &param_asset_attached_media_string);
            }
            if let Some(param_asset_attached_media_string_file_name) = param_asset_attached_media_string_file_name {
                query_string.append_pair("assetAttachedMediaStringFileName",
                    &param_asset_attached_media_string_file_name);
            }
            if let Some(param_asset_attached_media_string_content_type) = param_asset_attached_media_string_content_type {
                query_string.append_pair("assetAttachedMediaStringContentType",
                    &param_asset_attached_media_string_content_type);
            }
            if let Some(param_asset_location_description) = param_asset_location_description {
                query_string.append_pair("assetLocationDescription",
                    &param_asset_location_description);
            }
            if let Some(param_asset_app) = param_asset_app {
                query_string.append_pair("assetApp",
                    &param_asset_app);
            }
            if let Some(param_asset_search_tags) = param_asset_search_tags {
                query_string.append_pair("assetSearchTags",
                    &param_asset_search_tags);
            }
            if let Some(param_asset_latitude) = param_asset_latitude {
                query_string.append_pair("assetLatitude",
                    &param_asset_latitude.to_string());
            }
            if let Some(param_asset_longitude) = param_asset_longitude {
                query_string.append_pair("assetLongitude",
                    &param_asset_longitude.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::NoteResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(CreateNoteResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn delete_note(
        &self,
        param_version: f64,
        param_note_id: i64,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_latitude: Option<f64>,
        param_longitude: Option<f64>,
        param_app_key: Option<String>,
        context: &C) -> Result<DeleteNoteResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/note/delete",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
                query_string.append_pair("noteId",
                    &param_note_id.to_string());
            if let Some(param_latitude) = param_latitude {
                query_string.append_pair("latitude",
                    &param_latitude.to_string());
            }
            if let Some(param_longitude) = param_longitude {
                query_string.append_pair("longitude",
                    &param_longitude.to_string());
            }
            if let Some(param_app_key) = param_app_key {
                query_string.append_pair("appKey",
                    &param_app_key);
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(DeleteNoteResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_note(
        &self,
        param_version: f64,
        param_note_id: i64,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_return_full_response: Option<bool>,
        context: &C) -> Result<GetNoteResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/note/get",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_return_full_response) = param_return_full_response {
                query_string.append_pair("returnFullResponse",
                    &param_return_full_response.to_string());
            }
                query_string.append_pair("noteId",
                    &param_note_id.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetNoteResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn search_notes(
        &self,
        param_version: f64,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_notable_type: Option<String>,
        param_notable_id: Option<i64>,
        param_note_types: Option<String>,
        param_app_key: Option<String>,
        param_keyword: Option<String>,
        param_flag_count_minimum: Option<i64>,
        param_flags_exceed_threshold: Option<bool>,
        param_include_inactive: Option<bool>,
        param_sort_field: Option<models::SearchNotesSortFieldParameter>,
        param_descending: Option<bool>,
        param_return_full_response: Option<bool>,
        param_updated_since: Option<i64>,
        param_updated_before: Option<i64>,
        param_start: Option<i32>,
        param_limit: Option<i32>,
        context: &C) -> Result<SearchNotesResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/note/search",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_notable_type) = param_notable_type {
                query_string.append_pair("notableType",
                    &param_notable_type);
            }
            if let Some(param_notable_id) = param_notable_id {
                query_string.append_pair("notableId",
                    &param_notable_id.to_string());
            }
            if let Some(param_note_types) = param_note_types {
                query_string.append_pair("noteTypes",
                    &param_note_types);
            }
            if let Some(param_app_key) = param_app_key {
                query_string.append_pair("appKey",
                    &param_app_key);
            }
            if let Some(param_keyword) = param_keyword {
                query_string.append_pair("keyword",
                    &param_keyword);
            }
            if let Some(param_flag_count_minimum) = param_flag_count_minimum {
                query_string.append_pair("flagCountMinimum",
                    &param_flag_count_minimum.to_string());
            }
            if let Some(param_flags_exceed_threshold) = param_flags_exceed_threshold {
                query_string.append_pair("flagsExceedThreshold",
                    &param_flags_exceed_threshold.to_string());
            }
            if let Some(param_include_inactive) = param_include_inactive {
                query_string.append_pair("includeInactive",
                    &param_include_inactive.to_string());
            }
            if let Some(param_sort_field) = param_sort_field {
                query_string.append_pair("sortField",
                    &param_sort_field.to_string());
            }
            if let Some(param_descending) = param_descending {
                query_string.append_pair("descending",
                    &param_descending.to_string());
            }
            if let Some(param_return_full_response) = param_return_full_response {
                query_string.append_pair("returnFullResponse",
                    &param_return_full_response.to_string());
            }
            if let Some(param_updated_since) = param_updated_since {
                query_string.append_pair("updatedSince",
                    &param_updated_since.to_string());
            }
            if let Some(param_updated_before) = param_updated_before {
                query_string.append_pair("updatedBefore",
                    &param_updated_before.to_string());
            }
            if let Some(param_start) = param_start {
                query_string.append_pair("start",
                    &param_start.to_string());
            }
            if let Some(param_limit) = param_limit {
                query_string.append_pair("limit",
                    &param_limit.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<Vec<models::NoteResponse>>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(SearchNotesResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn update_note(
        &self,
        param_version: f64,
        param_note_id: i64,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_comment: Option<String>,
        param_note_type: Option<String>,
        param_asset_ids: Option<String>,
        param_tags: Option<String>,
        param_permissionable_type: Option<String>,
        param_permissionable_id: Option<i64>,
        param_app_key: Option<String>,
        param_location_description: Option<String>,
        param_latitude: Option<f64>,
        param_longitude: Option<f64>,
        param_meta_data: Option<String>,
        param_return_full_response: Option<bool>,
        param_active: Option<bool>,
        param_update_asset: Option<bool>,
        param_asset_return_nulls: Option<bool>,
        param_asset_album_id: Option<i64>,
        param_asset_collection_id: Option<i64>,
        param_asset_add_to_default_album: Option<String>,
        param_asset_add_to_media_library: Option<bool>,
        param_asset_version_code: Option<i32>,
        param_asset_version_name: Option<String>,
        param_asset_meta_data: Option<String>,
        param_asset_caption: Option<String>,
        param_asset_media: Option<swagger::ByteArray>,
        param_asset_media_url: Option<String>,
        param_asset_media_string: Option<String>,
        param_asset_media_string_file_name: Option<String>,
        param_asset_media_string_content_type: Option<String>,
        param_asset_attached_media: Option<swagger::ByteArray>,
        param_asset_attached_media_url: Option<String>,
        param_asset_attached_media_string: Option<String>,
        param_asset_attached_media_string_file_name: Option<String>,
        param_asset_attached_media_string_content_type: Option<String>,
        param_asset_location_description: Option<String>,
        param_asset_app: Option<String>,
        param_asset_search_tags: Option<String>,
        param_asset_latitude: Option<f64>,
        param_asset_longitude: Option<f64>,
        context: &C) -> Result<UpdateNoteResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/note/update",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
                query_string.append_pair("noteId",
                    &param_note_id.to_string());
            if let Some(param_comment) = param_comment {
                query_string.append_pair("comment",
                    &param_comment);
            }
            if let Some(param_note_type) = param_note_type {
                query_string.append_pair("noteType",
                    &param_note_type);
            }
            if let Some(param_asset_ids) = param_asset_ids {
                query_string.append_pair("assetIds",
                    &param_asset_ids);
            }
            if let Some(param_tags) = param_tags {
                query_string.append_pair("tags",
                    &param_tags);
            }
            if let Some(param_permissionable_type) = param_permissionable_type {
                query_string.append_pair("permissionableType",
                    &param_permissionable_type);
            }
            if let Some(param_permissionable_id) = param_permissionable_id {
                query_string.append_pair("permissionableId",
                    &param_permissionable_id.to_string());
            }
            if let Some(param_app_key) = param_app_key {
                query_string.append_pair("appKey",
                    &param_app_key);
            }
            if let Some(param_location_description) = param_location_description {
                query_string.append_pair("locationDescription",
                    &param_location_description);
            }
            if let Some(param_latitude) = param_latitude {
                query_string.append_pair("latitude",
                    &param_latitude.to_string());
            }
            if let Some(param_longitude) = param_longitude {
                query_string.append_pair("longitude",
                    &param_longitude.to_string());
            }
            if let Some(param_meta_data) = param_meta_data {
                query_string.append_pair("metaData",
                    &param_meta_data);
            }
            if let Some(param_return_full_response) = param_return_full_response {
                query_string.append_pair("returnFullResponse",
                    &param_return_full_response.to_string());
            }
            if let Some(param_active) = param_active {
                query_string.append_pair("active",
                    &param_active.to_string());
            }
            if let Some(param_update_asset) = param_update_asset {
                query_string.append_pair("updateAsset",
                    &param_update_asset.to_string());
            }
            if let Some(param_asset_return_nulls) = param_asset_return_nulls {
                query_string.append_pair("assetReturnNulls",
                    &param_asset_return_nulls.to_string());
            }
            if let Some(param_asset_album_id) = param_asset_album_id {
                query_string.append_pair("assetAlbumId",
                    &param_asset_album_id.to_string());
            }
            if let Some(param_asset_collection_id) = param_asset_collection_id {
                query_string.append_pair("assetCollectionId",
                    &param_asset_collection_id.to_string());
            }
            if let Some(param_asset_add_to_default_album) = param_asset_add_to_default_album {
                query_string.append_pair("assetAddToDefaultAlbum",
                    &param_asset_add_to_default_album);
            }
            if let Some(param_asset_add_to_media_library) = param_asset_add_to_media_library {
                query_string.append_pair("assetAddToMediaLibrary",
                    &param_asset_add_to_media_library.to_string());
            }
            if let Some(param_asset_version_code) = param_asset_version_code {
                query_string.append_pair("assetVersionCode",
                    &param_asset_version_code.to_string());
            }
            if let Some(param_asset_version_name) = param_asset_version_name {
                query_string.append_pair("assetVersionName",
                    &param_asset_version_name);
            }
            if let Some(param_asset_meta_data) = param_asset_meta_data {
                query_string.append_pair("assetMetaData",
                    &param_asset_meta_data);
            }
            if let Some(param_asset_caption) = param_asset_caption {
                query_string.append_pair("assetCaption",
                    &param_asset_caption);
            }
            if let Some(param_asset_media) = param_asset_media {
                query_string.append_pair("assetMedia",
                    &param_asset_media.to_string());
            }
            if let Some(param_asset_media_url) = param_asset_media_url {
                query_string.append_pair("assetMediaUrl",
                    &param_asset_media_url);
            }
            if let Some(param_asset_media_string) = param_asset_media_string {
                query_string.append_pair("assetMediaString",
                    &param_asset_media_string);
            }
            if let Some(param_asset_media_string_file_name) = param_asset_media_string_file_name {
                query_string.append_pair("assetMediaStringFileName",
                    &param_asset_media_string_file_name);
            }
            if let Some(param_asset_media_string_content_type) = param_asset_media_string_content_type {
                query_string.append_pair("assetMediaStringContentType",
                    &param_asset_media_string_content_type);
            }
            if let Some(param_asset_attached_media) = param_asset_attached_media {
                query_string.append_pair("assetAttachedMedia",
                    &param_asset_attached_media.to_string());
            }
            if let Some(param_asset_attached_media_url) = param_asset_attached_media_url {
                query_string.append_pair("assetAttachedMediaUrl",
                    &param_asset_attached_media_url);
            }
            if let Some(param_asset_attached_media_string) = param_asset_attached_media_string {
                query_string.append_pair("assetAttachedMediaString",
                    &param_asset_attached_media_string);
            }
            if let Some(param_asset_attached_media_string_file_name) = param_asset_attached_media_string_file_name {
                query_string.append_pair("assetAttachedMediaStringFileName",
                    &param_asset_attached_media_string_file_name);
            }
            if let Some(param_asset_attached_media_string_content_type) = param_asset_attached_media_string_content_type {
                query_string.append_pair("assetAttachedMediaStringContentType",
                    &param_asset_attached_media_string_content_type);
            }
            if let Some(param_asset_location_description) = param_asset_location_description {
                query_string.append_pair("assetLocationDescription",
                    &param_asset_location_description);
            }
            if let Some(param_asset_app) = param_asset_app {
                query_string.append_pair("assetApp",
                    &param_asset_app);
            }
            if let Some(param_asset_search_tags) = param_asset_search_tags {
                query_string.append_pair("assetSearchTags",
                    &param_asset_search_tags);
            }
            if let Some(param_asset_latitude) = param_asset_latitude {
                query_string.append_pair("assetLatitude",
                    &param_asset_latitude.to_string());
            }
            if let Some(param_asset_longitude) = param_asset_longitude {
                query_string.append_pair("assetLongitude",
                    &param_asset_longitude.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::NoteResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(UpdateNoteResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn create_notification_template(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_conduit: String,
        param_title: String,
        param_body: String,
        param_app_key: Option<String>,
        param_event: Option<String>,
        param_tags: Option<String>,
        context: &C) -> Result<CreateNotificationTemplateResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/notification/template/create",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            if let Some(param_app_key) = param_app_key {
                query_string.append_pair("appKey",
                    &param_app_key);
            }
            if let Some(param_event) = param_event {
                query_string.append_pair("event",
                    &param_event);
            }
                query_string.append_pair("conduit",
                    &param_conduit);
                query_string.append_pair("title",
                    &param_title);
                query_string.append_pair("body",
                    &param_body);
            if let Some(param_tags) = param_tags {
                query_string.append_pair("tags",
                    &param_tags);
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::NotificationTemplateResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(CreateNotificationTemplateResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn create_or_update_blocked_notifications(
        &self,
        param_version: f64,
        param_app_key: String,
        param_data: String,
        param_account_id: Option<i64>,
        context: &C) -> Result<CreateOrUpdateBlockedNotificationsResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/notification/blocked/batch",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
                query_string.append_pair("appKey",
                    &param_app_key);
                query_string.append_pair("data",
                    &param_data);
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::BlockedNotificationResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(CreateOrUpdateBlockedNotificationsResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn delete_notification_template(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_notification_template_id: i64,
        context: &C) -> Result<DeleteNotificationTemplateResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/notification/template/delete",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("notificationTemplateId",
                    &param_notification_template_id.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::NotificationTemplateResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(DeleteNotificationTemplateResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_notification_template(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_notification_template_id: i64,
        context: &C) -> Result<GetNotificationTemplateResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/notification/template/get",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("notificationTemplateId",
                    &param_notification_template_id.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::NotificationTemplateResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetNotificationTemplateResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_notifications(
        &self,
        param_version: f64,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_connection_account_id: Option<i64>,
        param_app_key: Option<String>,
        param_event_type: Option<String>,
        param_content_ids: Option<String>,
        param_content_types: Option<String>,
        param_parent_ids: Option<String>,
        param_parent_types: Option<String>,
        param_action_category: Option<String>,
        param_conduits: Option<String>,
        param_keyword: Option<String>,
        param_return_read_messages: Option<bool>,
        param_mark_as_read: Option<bool>,
        param_from_date: Option<i64>,
        param_latitude: Option<f64>,
        param_longitude: Option<f64>,
        param_return_sent: Option<bool>,
        param_ignore_flagged: Option<bool>,
        param_start: Option<i32>,
        param_limit: Option<i32>,
        context: &C) -> Result<GetNotificationsResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/notification/search",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_connection_account_id) = param_connection_account_id {
                query_string.append_pair("connectionAccountId",
                    &param_connection_account_id.to_string());
            }
            if let Some(param_app_key) = param_app_key {
                query_string.append_pair("appKey",
                    &param_app_key);
            }
            if let Some(param_event_type) = param_event_type {
                query_string.append_pair("eventType",
                    &param_event_type);
            }
            if let Some(param_content_ids) = param_content_ids {
                query_string.append_pair("contentIds",
                    &param_content_ids);
            }
            if let Some(param_content_types) = param_content_types {
                query_string.append_pair("contentTypes",
                    &param_content_types);
            }
            if let Some(param_parent_ids) = param_parent_ids {
                query_string.append_pair("parentIds",
                    &param_parent_ids);
            }
            if let Some(param_parent_types) = param_parent_types {
                query_string.append_pair("parentTypes",
                    &param_parent_types);
            }
            if let Some(param_action_category) = param_action_category {
                query_string.append_pair("actionCategory",
                    &param_action_category);
            }
            if let Some(param_conduits) = param_conduits {
                query_string.append_pair("conduits",
                    &param_conduits);
            }
            if let Some(param_keyword) = param_keyword {
                query_string.append_pair("keyword",
                    &param_keyword);
            }
            if let Some(param_return_read_messages) = param_return_read_messages {
                query_string.append_pair("returnReadMessages",
                    &param_return_read_messages.to_string());
            }
            if let Some(param_mark_as_read) = param_mark_as_read {
                query_string.append_pair("markAsRead",
                    &param_mark_as_read.to_string());
            }
            if let Some(param_from_date) = param_from_date {
                query_string.append_pair("fromDate",
                    &param_from_date.to_string());
            }
            if let Some(param_latitude) = param_latitude {
                query_string.append_pair("latitude",
                    &param_latitude.to_string());
            }
            if let Some(param_longitude) = param_longitude {
                query_string.append_pair("longitude",
                    &param_longitude.to_string());
            }
            if let Some(param_return_sent) = param_return_sent {
                query_string.append_pair("returnSent",
                    &param_return_sent.to_string());
            }
            if let Some(param_ignore_flagged) = param_ignore_flagged {
                query_string.append_pair("ignoreFlagged",
                    &param_ignore_flagged.to_string());
            }
            if let Some(param_start) = param_start {
                query_string.append_pair("start",
                    &param_start.to_string());
            }
            if let Some(param_limit) = param_limit {
                query_string.append_pair("limit",
                    &param_limit.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::NotificationMessageListResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetNotificationsResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn register_notification_token(
        &self,
        param_version: f64,
        param_token: String,
        param_push_type: models::RegisterNotificationTokenPushTypeParameter,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_environment: Option<String>,
        param_app_key: Option<String>,
        param_game_type: Option<String>,
        param_active: Option<bool>,
        param_latitude: Option<f64>,
        param_longitude: Option<f64>,
        context: &C) -> Result<RegisterNotificationTokenResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/notification/token",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
                query_string.append_pair("token",
                    &param_token);
                query_string.append_pair("pushType",
                    &param_push_type.to_string());
            if let Some(param_environment) = param_environment {
                query_string.append_pair("environment",
                    &param_environment);
            }
            if let Some(param_app_key) = param_app_key {
                query_string.append_pair("appKey",
                    &param_app_key);
            }
            if let Some(param_game_type) = param_game_type {
                query_string.append_pair("gameType",
                    &param_game_type);
            }
            if let Some(param_active) = param_active {
                query_string.append_pair("active",
                    &param_active.to_string());
            }
            if let Some(param_latitude) = param_latitude {
                query_string.append_pair("latitude",
                    &param_latitude.to_string());
            }
            if let Some(param_longitude) = param_longitude {
                query_string.append_pair("longitude",
                    &param_longitude.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(RegisterNotificationTokenResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn search_blocked_notifications(
        &self,
        param_version: f64,
        param_app_key: String,
        param_account_id: Option<i64>,
        param_search_tags: Option<String>,
        param_events: Option<String>,
        param_conduits: Option<String>,
        param_custom_types: Option<String>,
        param_content_types: Option<String>,
        param_content_ids: Option<String>,
        param_sort_field: Option<String>,
        param_descending: Option<bool>,
        param_start: Option<i32>,
        param_limit: Option<i32>,
        context: &C) -> Result<SearchBlockedNotificationsResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/notification/blocked/search",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
                query_string.append_pair("appKey",
                    &param_app_key);
            if let Some(param_search_tags) = param_search_tags {
                query_string.append_pair("searchTags",
                    &param_search_tags);
            }
            if let Some(param_events) = param_events {
                query_string.append_pair("events",
                    &param_events);
            }
            if let Some(param_conduits) = param_conduits {
                query_string.append_pair("conduits",
                    &param_conduits);
            }
            if let Some(param_custom_types) = param_custom_types {
                query_string.append_pair("customTypes",
                    &param_custom_types);
            }
            if let Some(param_content_types) = param_content_types {
                query_string.append_pair("contentTypes",
                    &param_content_types);
            }
            if let Some(param_content_ids) = param_content_ids {
                query_string.append_pair("contentIds",
                    &param_content_ids);
            }
            if let Some(param_sort_field) = param_sort_field {
                query_string.append_pair("sortField",
                    &param_sort_field);
            }
            if let Some(param_descending) = param_descending {
                query_string.append_pair("descending",
                    &param_descending.to_string());
            }
            if let Some(param_start) = param_start {
                query_string.append_pair("start",
                    &param_start.to_string());
            }
            if let Some(param_limit) = param_limit {
                query_string.append_pair("limit",
                    &param_limit.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::BlockedNotificationResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(SearchBlockedNotificationsResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn search_notification_template(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_sort_field: String,
        param_descending: bool,
        param_start: i32,
        param_limit: i32,
        param_app_key: Option<String>,
        param_event: Option<String>,
        param_conduit: Option<String>,
        param_global_only: Option<bool>,
        param_reserved_only: Option<bool>,
        param_keyword: Option<String>,
        context: &C) -> Result<SearchNotificationTemplateResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/notification/template/search",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            if let Some(param_app_key) = param_app_key {
                query_string.append_pair("appKey",
                    &param_app_key);
            }
            if let Some(param_event) = param_event {
                query_string.append_pair("event",
                    &param_event);
            }
            if let Some(param_conduit) = param_conduit {
                query_string.append_pair("conduit",
                    &param_conduit);
            }
            if let Some(param_global_only) = param_global_only {
                query_string.append_pair("globalOnly",
                    &param_global_only.to_string());
            }
            if let Some(param_reserved_only) = param_reserved_only {
                query_string.append_pair("reservedOnly",
                    &param_reserved_only.to_string());
            }
            if let Some(param_keyword) = param_keyword {
                query_string.append_pair("keyword",
                    &param_keyword);
            }
                query_string.append_pair("sortField",
                    &param_sort_field);
                query_string.append_pair("descending",
                    &param_descending.to_string());
                query_string.append_pair("start",
                    &param_start.to_string());
                query_string.append_pair("limit",
                    &param_limit.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::NotificationTemplateResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(SearchNotificationTemplateResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn search_recipients(
        &self,
        param_version: f64,
        param_sort_field: models::SearchRecipientsSortFieldParameter,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_app_key: Option<String>,
        param_conduit: Option<String>,
        param_keyword: Option<String>,
        param_audience_id: Option<i64>,
        param_audience_ids: Option<String>,
        param_connection_group_ids: Option<String>,
        param_recipient_account_ids: Option<String>,
        param_descending: Option<bool>,
        param_start: Option<i32>,
        param_limit: Option<i32>,
        context: &C) -> Result<SearchRecipientsResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/notification/recipient/search",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_app_key) = param_app_key {
                query_string.append_pair("appKey",
                    &param_app_key);
            }
            if let Some(param_conduit) = param_conduit {
                query_string.append_pair("conduit",
                    &param_conduit);
            }
            if let Some(param_keyword) = param_keyword {
                query_string.append_pair("keyword",
                    &param_keyword);
            }
            if let Some(param_audience_id) = param_audience_id {
                query_string.append_pair("audienceId",
                    &param_audience_id.to_string());
            }
            if let Some(param_audience_ids) = param_audience_ids {
                query_string.append_pair("audienceIds",
                    &param_audience_ids);
            }
            if let Some(param_connection_group_ids) = param_connection_group_ids {
                query_string.append_pair("connectionGroupIds",
                    &param_connection_group_ids);
            }
            if let Some(param_recipient_account_ids) = param_recipient_account_ids {
                query_string.append_pair("recipientAccountIds",
                    &param_recipient_account_ids);
            }
                query_string.append_pair("sortField",
                    &param_sort_field.to_string());
            if let Some(param_descending) = param_descending {
                query_string.append_pair("descending",
                    &param_descending.to_string());
            }
            if let Some(param_start) = param_start {
                query_string.append_pair("start",
                    &param_start.to_string());
            }
            if let Some(param_limit) = param_limit {
                query_string.append_pair("limit",
                    &param_limit.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<Vec<models::NotificationRecipientResponse>>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(SearchRecipientsResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn search_recipients_count(
        &self,
        param_version: f64,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_app_key: Option<String>,
        param_conduit: Option<String>,
        param_keyword: Option<String>,
        param_audience_id: Option<i64>,
        param_audience_ids: Option<String>,
        param_connection_group_ids: Option<String>,
        param_sort_field: Option<String>,
        param_descending: Option<bool>,
        param_start: Option<i32>,
        param_limit: Option<i32>,
        context: &C) -> Result<SearchRecipientsCountResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/notification/recipient/search/count",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_app_key) = param_app_key {
                query_string.append_pair("appKey",
                    &param_app_key);
            }
            if let Some(param_conduit) = param_conduit {
                query_string.append_pair("conduit",
                    &param_conduit);
            }
            if let Some(param_keyword) = param_keyword {
                query_string.append_pair("keyword",
                    &param_keyword);
            }
            if let Some(param_audience_id) = param_audience_id {
                query_string.append_pair("audienceId",
                    &param_audience_id.to_string());
            }
            if let Some(param_audience_ids) = param_audience_ids {
                query_string.append_pair("audienceIds",
                    &param_audience_ids);
            }
            if let Some(param_connection_group_ids) = param_connection_group_ids {
                query_string.append_pair("connectionGroupIds",
                    &param_connection_group_ids);
            }
            if let Some(param_sort_field) = param_sort_field {
                query_string.append_pair("sortField",
                    &param_sort_field);
            }
            if let Some(param_descending) = param_descending {
                query_string.append_pair("descending",
                    &param_descending.to_string());
            }
            if let Some(param_start) = param_start {
                query_string.append_pair("start",
                    &param_start.to_string());
            }
            if let Some(param_limit) = param_limit {
                query_string.append_pair("limit",
                    &param_limit.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::NotificationRecipientResponseListResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(SearchRecipientsCountResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn send_batch_notifications(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_app_key: String,
        param_custom_message: String,
        param_conduit: Option<String>,
        param_content_id: Option<i64>,
        param_content_name: Option<String>,
        param_content_type: Option<String>,
        param_parent_id: Option<i64>,
        param_parent_type: Option<String>,
        context: &C) -> Result<SendBatchNotificationsResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/notification/batch",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("appKey",
                    &param_app_key);
            if let Some(param_conduit) = param_conduit {
                query_string.append_pair("conduit",
                    &param_conduit);
            }
                query_string.append_pair("customMessage",
                    &param_custom_message);
            if let Some(param_content_id) = param_content_id {
                query_string.append_pair("contentId",
                    &param_content_id.to_string());
            }
            if let Some(param_content_name) = param_content_name {
                query_string.append_pair("contentName",
                    &param_content_name);
            }
            if let Some(param_content_type) = param_content_type {
                query_string.append_pair("contentType",
                    &param_content_type);
            }
            if let Some(param_parent_id) = param_parent_id {
                query_string.append_pair("parentId",
                    &param_parent_id.to_string());
            }
            if let Some(param_parent_type) = param_parent_type {
                query_string.append_pair("parentType",
                    &param_parent_type);
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(SendBatchNotificationsResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn send_custom_notifications(
        &self,
        param_version: f64,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_receiver_account_ids: Option<String>,
        param_include_friend_group: Option<bool>,
        param_app_key: Option<String>,
        param_game_type: Option<String>,
        param_conduit: Option<String>,
        param_content_id: Option<i64>,
        param_content_name: Option<String>,
        param_content_type: Option<String>,
        param_parent_id: Option<i64>,
        param_parent_type: Option<String>,
        param_action_category: Option<String>,
        param_subject: Option<String>,
        param_custom_message: Option<String>,
        param_friend_only_apns: Option<bool>,
        param_latitude: Option<f64>,
        param_longitude: Option<f64>,
        context: &C) -> Result<SendCustomNotificationsResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/notification/custom",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_receiver_account_ids) = param_receiver_account_ids {
                query_string.append_pair("receiverAccountIds",
                    &param_receiver_account_ids);
            }
            if let Some(param_include_friend_group) = param_include_friend_group {
                query_string.append_pair("includeFriendGroup",
                    &param_include_friend_group.to_string());
            }
            if let Some(param_app_key) = param_app_key {
                query_string.append_pair("appKey",
                    &param_app_key);
            }
            if let Some(param_game_type) = param_game_type {
                query_string.append_pair("gameType",
                    &param_game_type);
            }
            if let Some(param_conduit) = param_conduit {
                query_string.append_pair("conduit",
                    &param_conduit);
            }
            if let Some(param_content_id) = param_content_id {
                query_string.append_pair("contentId",
                    &param_content_id.to_string());
            }
            if let Some(param_content_name) = param_content_name {
                query_string.append_pair("contentName",
                    &param_content_name);
            }
            if let Some(param_content_type) = param_content_type {
                query_string.append_pair("contentType",
                    &param_content_type);
            }
            if let Some(param_parent_id) = param_parent_id {
                query_string.append_pair("parentId",
                    &param_parent_id.to_string());
            }
            if let Some(param_parent_type) = param_parent_type {
                query_string.append_pair("parentType",
                    &param_parent_type);
            }
            if let Some(param_action_category) = param_action_category {
                query_string.append_pair("actionCategory",
                    &param_action_category);
            }
            if let Some(param_subject) = param_subject {
                query_string.append_pair("subject",
                    &param_subject);
            }
            if let Some(param_custom_message) = param_custom_message {
                query_string.append_pair("customMessage",
                    &param_custom_message);
            }
            if let Some(param_friend_only_apns) = param_friend_only_apns {
                query_string.append_pair("friendOnlyAPNS",
                    &param_friend_only_apns.to_string());
            }
            if let Some(param_latitude) = param_latitude {
                query_string.append_pair("latitude",
                    &param_latitude.to_string());
            }
            if let Some(param_longitude) = param_longitude {
                query_string.append_pair("longitude",
                    &param_longitude.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(SendCustomNotificationsResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn update_notification_template(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_notification_template_id: i64,
        param_title: Option<String>,
        param_body: Option<String>,
        param_tags: Option<String>,
        context: &C) -> Result<UpdateNotificationTemplateResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/notification/template/update",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("notificationTemplateId",
                    &param_notification_template_id.to_string());
            if let Some(param_title) = param_title {
                query_string.append_pair("title",
                    &param_title);
            }
            if let Some(param_body) = param_body {
                query_string.append_pair("body",
                    &param_body);
            }
            if let Some(param_tags) = param_tags {
                query_string.append_pair("tags",
                    &param_tags);
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::NotificationTemplateResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(UpdateNotificationTemplateResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn add_field(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_app_key: String,
        param_object_name: String,
        param_field_name: String,
        param_field_type: String,
        context: &C) -> Result<AddFieldResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/object/field/add",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("appKey",
                    &param_app_key);
                query_string.append_pair("objectName",
                    &param_object_name);
                query_string.append_pair("fieldName",
                    &param_field_name);
                query_string.append_pair("fieldType",
                    &param_field_type);
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::ObjectStoreResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(AddFieldResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn create_object(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_app_key: String,
        param_object_name: String,
        context: &C) -> Result<CreateObjectResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/object/create",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("appKey",
                    &param_app_key);
                query_string.append_pair("objectName",
                    &param_object_name);
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::ObjectStoreResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(CreateObjectResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn delete_field(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_app_key: String,
        param_object_name: String,
        param_field_name: String,
        context: &C) -> Result<DeleteFieldResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/object/field/delete",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("appKey",
                    &param_app_key);
                query_string.append_pair("objectName",
                    &param_object_name);
                query_string.append_pair("fieldName",
                    &param_field_name);
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::ObjectStoreResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(DeleteFieldResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn delete_object(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_app_key: String,
        param_object_name: String,
        context: &C) -> Result<DeleteObjectResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/object/delete",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("appKey",
                    &param_app_key);
                query_string.append_pair("objectName",
                    &param_object_name);
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::ObjectStoreResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(DeleteObjectResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_object(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_app_key: String,
        param_object_name: String,
        context: &C) -> Result<GetObjectResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/object/get",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("appKey",
                    &param_app_key);
                query_string.append_pair("objectName",
                    &param_object_name);
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::ObjectStoreResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetObjectResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn search_object(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_app_key: String,
        param_start: i64,
        param_limit: i64,
        param_keyword: Option<String>,
        context: &C) -> Result<SearchObjectResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/object/search",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("appKey",
                    &param_app_key);
            if let Some(param_keyword) = param_keyword {
                query_string.append_pair("keyword",
                    &param_keyword);
            }
                query_string.append_pair("start",
                    &param_start.to_string());
                query_string.append_pair("limit",
                    &param_limit.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::ObjectStoreResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(SearchObjectResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn create_data(
        &self,
        param_version: f64,
        param_object_name: String,
        param_account_id: Option<i64>,
        param_body: Option<String>,
        context: &C) -> Result<CreateDataResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/object/data/{object_name}",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
            ,object_name=utf8_percent_encode(&param_object_name.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        // Consumes basic body
        // Body parameter
        if let Some(param_body) = param_body {
        let body = serde_json::to_string(&param_body).expect("impossible to fail to serialize");
        *request.body_mut() = body_from_string(body);
        }

        let header = "application/json";
        request.headers_mut().insert(CONTENT_TYPE, HeaderValue::from_static(header));

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::ObjectStoreResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(CreateDataResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn search_data(
        &self,
        param_version: f64,
        param_object_name: String,
        param_count: bool,
        param_start: i64,
        param_limit: i64,
        param_account_id: Option<i64>,
        param_criteria: Option<String>,
        param_order: Option<String>,
        param_include: Option<String>,
        context: &C) -> Result<SearchDataResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/object/data/{object_name}",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
            ,object_name=utf8_percent_encode(&param_object_name.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_criteria) = param_criteria {
                query_string.append_pair("criteria",
                    &param_criteria);
            }
                query_string.append_pair("count",
                    &param_count.to_string());
                query_string.append_pair("start",
                    &param_start.to_string());
                query_string.append_pair("limit",
                    &param_limit.to_string());
            if let Some(param_order) = param_order {
                query_string.append_pair("order",
                    &param_order);
            }
            if let Some(param_include) = param_include {
                query_string.append_pair("include",
                    &param_include);
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::ObjectStoreResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(SearchDataResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn delete_data(
        &self,
        param_version: f64,
        param_object_name: String,
        param_object_id: String,
        param_account_id: Option<i64>,
        context: &C) -> Result<DeleteDataResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/object/data/{object_name}/{object_id}",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
            ,object_name=utf8_percent_encode(&param_object_name.to_string(), ID_ENCODE_SET)
            ,object_id=utf8_percent_encode(&param_object_id.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("DELETE")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::ObjectStoreResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(DeleteDataResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_data(
        &self,
        param_version: f64,
        param_object_name: String,
        param_object_id: String,
        param_account_id: Option<i64>,
        param_include: Option<String>,
        context: &C) -> Result<GetDataResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/object/data/{object_name}/{object_id}",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
            ,object_name=utf8_percent_encode(&param_object_name.to_string(), ID_ENCODE_SET)
            ,object_id=utf8_percent_encode(&param_object_id.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_include) = param_include {
                query_string.append_pair("include",
                    &param_include);
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::ObjectStoreResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetDataResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn update_data(
        &self,
        param_version: f64,
        param_object_name: String,
        param_object_id: String,
        param_account_id: Option<i64>,
        param_body: Option<String>,
        context: &C) -> Result<UpdateDataResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/object/data/{object_name}/{object_id}",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
            ,object_name=utf8_percent_encode(&param_object_name.to_string(), ID_ENCODE_SET)
            ,object_id=utf8_percent_encode(&param_object_id.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("PUT")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        // Consumes basic body
        // Body parameter
        if let Some(param_body) = param_body {
        let body = serde_json::to_string(&param_body).expect("impossible to fail to serialize");
        *request.body_mut() = body_from_string(body);
        }

        let header = "application/json";
        request.headers_mut().insert(CONTENT_TYPE, HeaderValue::from_static(header));

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::ObjectStoreResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(UpdateDataResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn batch_update_offer_locations(
        &self,
        param_version: f64,
        param_data: String,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        context: &C) -> Result<BatchUpdateOfferLocationsResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/retailer/offer/location/batchUpdate",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
                query_string.append_pair("data",
                    &param_data);
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(BatchUpdateOfferLocationsResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn create_offer(
        &self,
        param_version: f64,
        param_include_offer_locations: bool,
        param_title: String,
        param_barcode_type: models::CreateMediaBarcodeTypeParameter,
        param_no_expiration: bool,
        param_available_limit: i32,
        param_available_limit_per_user: i32,
        param_added_limit: i32,
        param_view_limit: i32,
        param_max_prints: i32,
        param_ticket_price: i64,
        param_full_price: f64,
        param_discount_price: f64,
        param_offer_type: models::CreateOfferOfferTypeParameter,
        param_special_offer_type: models::CreateMediaSpecialOfferTypeParameter,
        param_offer_visibility: models::CreateMediaOfferVisibilityParameter,
        param_active: bool,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_tags: Option<String>,
        param_parent_offer_id: Option<i64>,
        param_retailer_location_ids: Option<String>,
        param_offer_locations: Option<String>,
        param_sub_title: Option<String>,
        param_details: Option<String>,
        param_sub_details: Option<String>,
        param_fine_print: Option<String>,
        param_barcode_entry: Option<String>,
        param_external_redeem_options: Option<String>,
        param_external_url: Option<String>,
        param_external_id: Option<String>,
        param_tickets_reward_type: Option<String>,
        param_tickets_reward: Option<i64>,
        param_activated: Option<i64>,
        param_expires: Option<i64>,
        param_ticket_price_type: Option<String>,
        param_show_remaining: Option<bool>,
        param_show_redeemed: Option<bool>,
        param_replaced: Option<bool>,
        param_featured: Option<bool>,
        param_category_ids: Option<String>,
        param_filter_ids: Option<String>,
        param_barcode_asset_id: Option<i64>,
        param_image_asset_id: Option<i64>,
        param_image_asset_id1: Option<i64>,
        param_image_asset_id2: Option<i64>,
        param_image_asset_id3: Option<i64>,
        param_image_asset_id4: Option<i64>,
        param_image_asset_id5: Option<i64>,
        param_publisher: Option<String>,
        param_redeemable_start: Option<i64>,
        param_redeemable_end: Option<i64>,
        param_brand: Option<String>,
        param_product_type: Option<models::CreateOfferProductTypeParameter>,
        param_condition_type: Option<models::CreateMediaConditionTypeParameter>,
        param_isbn: Option<String>,
        param_asin: Option<String>,
        param_catalog_numbers: Option<String>,
        param_department: Option<String>,
        param_features: Option<String>,
        param_minimum_price: Option<f64>,
        param_width: Option<f64>,
        param_height: Option<f64>,
        param_depth: Option<f64>,
        param_weight: Option<f64>,
        param_unit: Option<models::CreateOfferUnitParameter>,
        param_studio: Option<String>,
        param_parental_rating: Option<String>,
        param_publish_date: Option<i64>,
        param_availability_date: Option<i64>,
        param_size_id: Option<i64>,
        param_listing_id: Option<i64>,
        param_media_type: Option<models::CreateMediaMediaTypeParameter>,
        param_duration: Option<i32>,
        param_author: Option<String>,
        param_release_date: Option<i64>,
        param_collection_ids: Option<String>,
        param_reboot_time_hour: Option<i32>,
        param_reboot_time_minute: Option<i32>,
        param_idle_timeout_in_second: Option<i32>,
        param_serial_number: Option<String>,
        param_udid: Option<String>,
        param_device_type: Option<String>,
        param_device_power: Option<f64>,
        param_device_interference: Option<f64>,
        param_availability: Option<String>,
        param_availability_summary: Option<String>,
        context: &C) -> Result<CreateOfferResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/retailer/offer/create",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_tags) = param_tags {
                query_string.append_pair("tags",
                    &param_tags);
            }
            if let Some(param_parent_offer_id) = param_parent_offer_id {
                query_string.append_pair("parentOfferId",
                    &param_parent_offer_id.to_string());
            }
                query_string.append_pair("includeOfferLocations",
                    &param_include_offer_locations.to_string());
            if let Some(param_retailer_location_ids) = param_retailer_location_ids {
                query_string.append_pair("retailerLocationIds",
                    &param_retailer_location_ids);
            }
            if let Some(param_offer_locations) = param_offer_locations {
                query_string.append_pair("offerLocations",
                    &param_offer_locations);
            }
                query_string.append_pair("title",
                    &param_title);
            if let Some(param_sub_title) = param_sub_title {
                query_string.append_pair("subTitle",
                    &param_sub_title);
            }
            if let Some(param_details) = param_details {
                query_string.append_pair("details",
                    &param_details);
            }
            if let Some(param_sub_details) = param_sub_details {
                query_string.append_pair("subDetails",
                    &param_sub_details);
            }
            if let Some(param_fine_print) = param_fine_print {
                query_string.append_pair("finePrint",
                    &param_fine_print);
            }
                query_string.append_pair("barcodeType",
                    &param_barcode_type.to_string());
            if let Some(param_barcode_entry) = param_barcode_entry {
                query_string.append_pair("barcodeEntry",
                    &param_barcode_entry);
            }
            if let Some(param_external_redeem_options) = param_external_redeem_options {
                query_string.append_pair("externalRedeemOptions",
                    &param_external_redeem_options);
            }
            if let Some(param_external_url) = param_external_url {
                query_string.append_pair("externalUrl",
                    &param_external_url);
            }
            if let Some(param_external_id) = param_external_id {
                query_string.append_pair("externalId",
                    &param_external_id);
            }
            if let Some(param_tickets_reward_type) = param_tickets_reward_type {
                query_string.append_pair("ticketsRewardType",
                    &param_tickets_reward_type);
            }
            if let Some(param_tickets_reward) = param_tickets_reward {
                query_string.append_pair("ticketsReward",
                    &param_tickets_reward.to_string());
            }
            if let Some(param_activated) = param_activated {
                query_string.append_pair("activated",
                    &param_activated.to_string());
            }
            if let Some(param_expires) = param_expires {
                query_string.append_pair("expires",
                    &param_expires.to_string());
            }
                query_string.append_pair("noExpiration",
                    &param_no_expiration.to_string());
                query_string.append_pair("availableLimit",
                    &param_available_limit.to_string());
                query_string.append_pair("availableLimitPerUser",
                    &param_available_limit_per_user.to_string());
                query_string.append_pair("addedLimit",
                    &param_added_limit.to_string());
                query_string.append_pair("viewLimit",
                    &param_view_limit.to_string());
                query_string.append_pair("maxPrints",
                    &param_max_prints.to_string());
            if let Some(param_ticket_price_type) = param_ticket_price_type {
                query_string.append_pair("ticketPriceType",
                    &param_ticket_price_type);
            }
                query_string.append_pair("ticketPrice",
                    &param_ticket_price.to_string());
                query_string.append_pair("fullPrice",
                    &param_full_price.to_string());
                query_string.append_pair("discountPrice",
                    &param_discount_price.to_string());
            if let Some(param_show_remaining) = param_show_remaining {
                query_string.append_pair("showRemaining",
                    &param_show_remaining.to_string());
            }
            if let Some(param_show_redeemed) = param_show_redeemed {
                query_string.append_pair("showRedeemed",
                    &param_show_redeemed.to_string());
            }
            if let Some(param_replaced) = param_replaced {
                query_string.append_pair("replaced",
                    &param_replaced.to_string());
            }
            if let Some(param_featured) = param_featured {
                query_string.append_pair("featured",
                    &param_featured.to_string());
            }
                query_string.append_pair("offerType",
                    &param_offer_type.to_string());
                query_string.append_pair("specialOfferType",
                    &param_special_offer_type.to_string());
                query_string.append_pair("offerVisibility",
                    &param_offer_visibility.to_string());
            if let Some(param_category_ids) = param_category_ids {
                query_string.append_pair("categoryIds",
                    &param_category_ids);
            }
            if let Some(param_filter_ids) = param_filter_ids {
                query_string.append_pair("filterIds",
                    &param_filter_ids);
            }
                query_string.append_pair("active",
                    &param_active.to_string());
            if let Some(param_barcode_asset_id) = param_barcode_asset_id {
                query_string.append_pair("barcodeAssetId",
                    &param_barcode_asset_id.to_string());
            }
            if let Some(param_image_asset_id) = param_image_asset_id {
                query_string.append_pair("imageAssetId",
                    &param_image_asset_id.to_string());
            }
            if let Some(param_image_asset_id1) = param_image_asset_id1 {
                query_string.append_pair("imageAssetId1",
                    &param_image_asset_id1.to_string());
            }
            if let Some(param_image_asset_id2) = param_image_asset_id2 {
                query_string.append_pair("imageAssetId2",
                    &param_image_asset_id2.to_string());
            }
            if let Some(param_image_asset_id3) = param_image_asset_id3 {
                query_string.append_pair("imageAssetId3",
                    &param_image_asset_id3.to_string());
            }
            if let Some(param_image_asset_id4) = param_image_asset_id4 {
                query_string.append_pair("imageAssetId4",
                    &param_image_asset_id4.to_string());
            }
            if let Some(param_image_asset_id5) = param_image_asset_id5 {
                query_string.append_pair("imageAssetId5",
                    &param_image_asset_id5.to_string());
            }
            if let Some(param_publisher) = param_publisher {
                query_string.append_pair("publisher",
                    &param_publisher);
            }
            if let Some(param_redeemable_start) = param_redeemable_start {
                query_string.append_pair("redeemableStart",
                    &param_redeemable_start.to_string());
            }
            if let Some(param_redeemable_end) = param_redeemable_end {
                query_string.append_pair("redeemableEnd",
                    &param_redeemable_end.to_string());
            }
            if let Some(param_brand) = param_brand {
                query_string.append_pair("brand",
                    &param_brand);
            }
            if let Some(param_product_type) = param_product_type {
                query_string.append_pair("productType",
                    &param_product_type.to_string());
            }
            if let Some(param_condition_type) = param_condition_type {
                query_string.append_pair("conditionType",
                    &param_condition_type.to_string());
            }
            if let Some(param_isbn) = param_isbn {
                query_string.append_pair("isbn",
                    &param_isbn);
            }
            if let Some(param_asin) = param_asin {
                query_string.append_pair("asin",
                    &param_asin);
            }
            if let Some(param_catalog_numbers) = param_catalog_numbers {
                query_string.append_pair("catalogNumbers",
                    &param_catalog_numbers);
            }
            if let Some(param_department) = param_department {
                query_string.append_pair("department",
                    &param_department);
            }
            if let Some(param_features) = param_features {
                query_string.append_pair("features",
                    &param_features);
            }
            if let Some(param_minimum_price) = param_minimum_price {
                query_string.append_pair("minimumPrice",
                    &param_minimum_price.to_string());
            }
            if let Some(param_width) = param_width {
                query_string.append_pair("width",
                    &param_width.to_string());
            }
            if let Some(param_height) = param_height {
                query_string.append_pair("height",
                    &param_height.to_string());
            }
            if let Some(param_depth) = param_depth {
                query_string.append_pair("depth",
                    &param_depth.to_string());
            }
            if let Some(param_weight) = param_weight {
                query_string.append_pair("weight",
                    &param_weight.to_string());
            }
            if let Some(param_unit) = param_unit {
                query_string.append_pair("unit",
                    &param_unit.to_string());
            }
            if let Some(param_studio) = param_studio {
                query_string.append_pair("studio",
                    &param_studio);
            }
            if let Some(param_parental_rating) = param_parental_rating {
                query_string.append_pair("parentalRating",
                    &param_parental_rating);
            }
            if let Some(param_publish_date) = param_publish_date {
                query_string.append_pair("publishDate",
                    &param_publish_date.to_string());
            }
            if let Some(param_availability_date) = param_availability_date {
                query_string.append_pair("availabilityDate",
                    &param_availability_date.to_string());
            }
            if let Some(param_size_id) = param_size_id {
                query_string.append_pair("sizeId",
                    &param_size_id.to_string());
            }
            if let Some(param_listing_id) = param_listing_id {
                query_string.append_pair("listingId",
                    &param_listing_id.to_string());
            }
            if let Some(param_media_type) = param_media_type {
                query_string.append_pair("mediaType",
                    &param_media_type.to_string());
            }
            if let Some(param_duration) = param_duration {
                query_string.append_pair("duration",
                    &param_duration.to_string());
            }
            if let Some(param_author) = param_author {
                query_string.append_pair("author",
                    &param_author);
            }
            if let Some(param_release_date) = param_release_date {
                query_string.append_pair("releaseDate",
                    &param_release_date.to_string());
            }
            if let Some(param_collection_ids) = param_collection_ids {
                query_string.append_pair("collectionIds",
                    &param_collection_ids);
            }
            if let Some(param_reboot_time_hour) = param_reboot_time_hour {
                query_string.append_pair("rebootTimeHour",
                    &param_reboot_time_hour.to_string());
            }
            if let Some(param_reboot_time_minute) = param_reboot_time_minute {
                query_string.append_pair("rebootTimeMinute",
                    &param_reboot_time_minute.to_string());
            }
            if let Some(param_idle_timeout_in_second) = param_idle_timeout_in_second {
                query_string.append_pair("idleTimeoutInSecond",
                    &param_idle_timeout_in_second.to_string());
            }
            if let Some(param_serial_number) = param_serial_number {
                query_string.append_pair("serialNumber",
                    &param_serial_number);
            }
            if let Some(param_udid) = param_udid {
                query_string.append_pair("udid",
                    &param_udid);
            }
            if let Some(param_device_type) = param_device_type {
                query_string.append_pair("deviceType",
                    &param_device_type);
            }
            if let Some(param_device_power) = param_device_power {
                query_string.append_pair("devicePower",
                    &param_device_power.to_string());
            }
            if let Some(param_device_interference) = param_device_interference {
                query_string.append_pair("deviceInterference",
                    &param_device_interference.to_string());
            }
            if let Some(param_availability) = param_availability {
                query_string.append_pair("availability",
                    &param_availability);
            }
            if let Some(param_availability_summary) = param_availability_summary {
                query_string.append_pair("availabilitySummary",
                    &param_availability_summary);
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::RetailerOfferResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(CreateOfferResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn delete_offer(
        &self,
        param_version: f64,
        param_offer_id: i64,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        context: &C) -> Result<DeleteOfferResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/retailer/offer/delete",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
                query_string.append_pair("offerId",
                    &param_offer_id.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(DeleteOfferResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn delete_offer_location(
        &self,
        param_version: f64,
        param_offer_location_id: i64,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        context: &C) -> Result<DeleteOfferLocationResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/retailer/offer/location/delete",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
                query_string.append_pair("offerLocationId",
                    &param_offer_location_id.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(DeleteOfferLocationResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_offer(
        &self,
        param_version: f64,
        param_offer_id: i64,
        param_include_offer_locations: bool,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        context: &C) -> Result<GetOfferResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/retailer/offer/get",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
                query_string.append_pair("offerId",
                    &param_offer_id.to_string());
                query_string.append_pair("includeOfferLocations",
                    &param_include_offer_locations.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::RetailerOfferResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetOfferResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_offer_details(
        &self,
        param_version: f64,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_offer_id: Option<i64>,
        param_offer_location_id: Option<i64>,
        param_distance: Option<f64>,
        param_latitude: Option<f64>,
        param_longitude: Option<f64>,
        param_include_offer_locations: Option<bool>,
        param_include_retailer_locations: Option<bool>,
        param_include_child_offers: Option<bool>,
        context: &C) -> Result<GetOfferDetailsResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/offer/get",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_offer_id) = param_offer_id {
                query_string.append_pair("offerId",
                    &param_offer_id.to_string());
            }
            if let Some(param_offer_location_id) = param_offer_location_id {
                query_string.append_pair("offerLocationId",
                    &param_offer_location_id.to_string());
            }
            if let Some(param_distance) = param_distance {
                query_string.append_pair("distance",
                    &param_distance.to_string());
            }
            if let Some(param_latitude) = param_latitude {
                query_string.append_pair("latitude",
                    &param_latitude.to_string());
            }
            if let Some(param_longitude) = param_longitude {
                query_string.append_pair("longitude",
                    &param_longitude.to_string());
            }
            if let Some(param_include_offer_locations) = param_include_offer_locations {
                query_string.append_pair("includeOfferLocations",
                    &param_include_offer_locations.to_string());
            }
            if let Some(param_include_retailer_locations) = param_include_retailer_locations {
                query_string.append_pair("includeRetailerLocations",
                    &param_include_retailer_locations.to_string());
            }
            if let Some(param_include_child_offers) = param_include_child_offers {
                query_string.append_pair("includeChildOffers",
                    &param_include_child_offers.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::OfferResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetOfferDetailsResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_offer_list_counts(
        &self,
        param_version: f64,
        param_latitude: f64,
        param_longitude: f64,
        param_search_range: Option<f64>,
        param_distance_unit: Option<models::GetOfferListCountsDistanceUnitParameter>,
        context: &C) -> Result<GetOfferListCountsResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/offer/lists/count",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("latitude",
                    &param_latitude.to_string());
                query_string.append_pair("longitude",
                    &param_longitude.to_string());
            if let Some(param_search_range) = param_search_range {
                query_string.append_pair("searchRange",
                    &param_search_range.to_string());
            }
            if let Some(param_distance_unit) = param_distance_unit {
                query_string.append_pair("distanceUnit",
                    &param_distance_unit.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::ListCountResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetOfferListCountsResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_offer_location(
        &self,
        param_version: f64,
        param_offer_location_id: Option<i64>,
        param_udid: Option<String>,
        context: &C) -> Result<GetOfferLocationResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/offer/location/get",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_offer_location_id) = param_offer_location_id {
                query_string.append_pair("offerLocationId",
                    &param_offer_location_id.to_string());
            }
            if let Some(param_udid) = param_udid {
                query_string.append_pair("udid",
                    &param_udid);
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::OfferShortResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetOfferLocationResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_offer_locations_for_retailers(
        &self,
        param_version: f64,
        param_sort_field: models::SearchOffersForConsumerGroupByParameter,
        param_descending: bool,
        param_start: i32,
        param_limit: i32,
        param_active_only: bool,
        param_include_retailer_location: bool,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_keyword: Option<String>,
        param_retailer_id: Option<i64>,
        param_retailer_location_id: Option<i64>,
        param_offer_type: Option<models::CreateOfferOfferTypeParameter>,
        param_special_offer_type: Option<models::CreateMediaSpecialOfferTypeParameter>,
        param_barcode_type: Option<String>,
        param_barcode_entry: Option<String>,
        param_isbn: Option<String>,
        param_asin: Option<String>,
        param_device_status: Option<models::GetOfferLocationsForRetailersDeviceStatusParameter>,
        param_needs_notification_sent: Option<bool>,
        param_last_notification_sent: Option<i64>,
        context: &C) -> Result<GetOfferLocationsForRetailersResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/retailer/offer/location/search",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_keyword) = param_keyword {
                query_string.append_pair("keyword",
                    &param_keyword);
            }
            if let Some(param_retailer_id) = param_retailer_id {
                query_string.append_pair("retailerId",
                    &param_retailer_id.to_string());
            }
            if let Some(param_retailer_location_id) = param_retailer_location_id {
                query_string.append_pair("retailerLocationId",
                    &param_retailer_location_id.to_string());
            }
            if let Some(param_offer_type) = param_offer_type {
                query_string.append_pair("offerType",
                    &param_offer_type.to_string());
            }
            if let Some(param_special_offer_type) = param_special_offer_type {
                query_string.append_pair("specialOfferType",
                    &param_special_offer_type.to_string());
            }
                query_string.append_pair("sortField",
                    &param_sort_field.to_string());
                query_string.append_pair("descending",
                    &param_descending.to_string());
                query_string.append_pair("start",
                    &param_start.to_string());
                query_string.append_pair("limit",
                    &param_limit.to_string());
                query_string.append_pair("activeOnly",
                    &param_active_only.to_string());
                query_string.append_pair("includeRetailerLocation",
                    &param_include_retailer_location.to_string());
            if let Some(param_barcode_type) = param_barcode_type {
                query_string.append_pair("barcodeType",
                    &param_barcode_type);
            }
            if let Some(param_barcode_entry) = param_barcode_entry {
                query_string.append_pair("barcodeEntry",
                    &param_barcode_entry);
            }
            if let Some(param_isbn) = param_isbn {
                query_string.append_pair("isbn",
                    &param_isbn);
            }
            if let Some(param_asin) = param_asin {
                query_string.append_pair("asin",
                    &param_asin);
            }
            if let Some(param_device_status) = param_device_status {
                query_string.append_pair("deviceStatus",
                    &param_device_status.to_string());
            }
            if let Some(param_needs_notification_sent) = param_needs_notification_sent {
                query_string.append_pair("needsNotificationSent",
                    &param_needs_notification_sent.to_string());
            }
            if let Some(param_last_notification_sent) = param_last_notification_sent {
                query_string.append_pair("lastNotificationSent",
                    &param_last_notification_sent.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<Vec<models::OfferShortResponse>>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetOfferLocationsForRetailersResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_offers_for_retailers(
        &self,
        param_version: f64,
        param_offer_visibility: models::CreateMediaOfferVisibilityParameter,
        param_sort_field: models::SearchEventsSortFieldParameter,
        param_descending: bool,
        param_start: i32,
        param_limit: i32,
        param_available_only: bool,
        param_active_only: bool,
        param_include_categories: bool,
        param_include_filters: bool,
        param_include_offer_locations: bool,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_category_ids: Option<String>,
        param_filter_ids: Option<String>,
        param_q: Option<String>,
        param_keyword: Option<String>,
        param_retailer_id: Option<i64>,
        param_retailer_location_id: Option<i64>,
        param_coupon_type: Option<models::CreateOfferOfferTypeParameter>,
        param_offer_type: Option<models::CreateOfferOfferTypeParameter>,
        param_offer_types: Option<String>,
        param_special_offer_type: Option<models::CreateMediaSpecialOfferTypeParameter>,
        param__i: Option<i32>,
        param__l: Option<i32>,
        param_barcode_type: Option<String>,
        param_barcode_entry: Option<String>,
        param_isbn: Option<String>,
        param_asin: Option<String>,
        param_device_status: Option<models::GetOfferLocationsForRetailersDeviceStatusParameter>,
        param_needs_notification_sent: Option<bool>,
        param_last_notification_sent: Option<i64>,
        context: &C) -> Result<GetOffersForRetailersResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/retailer/offer/search",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_category_ids) = param_category_ids {
                query_string.append_pair("categoryIds",
                    &param_category_ids);
            }
            if let Some(param_filter_ids) = param_filter_ids {
                query_string.append_pair("filterIds",
                    &param_filter_ids);
            }
            if let Some(param_q) = param_q {
                query_string.append_pair("q",
                    &param_q);
            }
            if let Some(param_keyword) = param_keyword {
                query_string.append_pair("keyword",
                    &param_keyword);
            }
            if let Some(param_retailer_id) = param_retailer_id {
                query_string.append_pair("retailerId",
                    &param_retailer_id.to_string());
            }
            if let Some(param_retailer_location_id) = param_retailer_location_id {
                query_string.append_pair("retailerLocationId",
                    &param_retailer_location_id.to_string());
            }
            if let Some(param_coupon_type) = param_coupon_type {
                query_string.append_pair("couponType",
                    &param_coupon_type.to_string());
            }
            if let Some(param_offer_type) = param_offer_type {
                query_string.append_pair("offerType",
                    &param_offer_type.to_string());
            }
            if let Some(param_offer_types) = param_offer_types {
                query_string.append_pair("offerTypes",
                    &param_offer_types);
            }
            if let Some(param_special_offer_type) = param_special_offer_type {
                query_string.append_pair("specialOfferType",
                    &param_special_offer_type.to_string());
            }
                query_string.append_pair("offerVisibility",
                    &param_offer_visibility.to_string());
                query_string.append_pair("sortField",
                    &param_sort_field.to_string());
                query_string.append_pair("descending",
                    &param_descending.to_string());
            if let Some(param__i) = param__i {
                query_string.append_pair("_i",
                    &param__i.to_string());
            }
                query_string.append_pair("start",
                    &param_start.to_string());
            if let Some(param__l) = param__l {
                query_string.append_pair("_l",
                    &param__l.to_string());
            }
                query_string.append_pair("limit",
                    &param_limit.to_string());
                query_string.append_pair("availableOnly",
                    &param_available_only.to_string());
                query_string.append_pair("activeOnly",
                    &param_active_only.to_string());
                query_string.append_pair("includeCategories",
                    &param_include_categories.to_string());
                query_string.append_pair("includeFilters",
                    &param_include_filters.to_string());
                query_string.append_pair("includeOfferLocations",
                    &param_include_offer_locations.to_string());
            if let Some(param_barcode_type) = param_barcode_type {
                query_string.append_pair("barcodeType",
                    &param_barcode_type);
            }
            if let Some(param_barcode_entry) = param_barcode_entry {
                query_string.append_pair("barcodeEntry",
                    &param_barcode_entry);
            }
            if let Some(param_isbn) = param_isbn {
                query_string.append_pair("isbn",
                    &param_isbn);
            }
            if let Some(param_asin) = param_asin {
                query_string.append_pair("asin",
                    &param_asin);
            }
            if let Some(param_device_status) = param_device_status {
                query_string.append_pair("deviceStatus",
                    &param_device_status.to_string());
            }
            if let Some(param_needs_notification_sent) = param_needs_notification_sent {
                query_string.append_pair("needsNotificationSent",
                    &param_needs_notification_sent.to_string());
            }
            if let Some(param_last_notification_sent) = param_last_notification_sent {
                query_string.append_pair("lastNotificationSent",
                    &param_last_notification_sent.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<Vec<models::OfferResponse>>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetOffersForRetailersResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn redeem_offer_transaction(
        &self,
        param_version: f64,
        param_offer_transaction_id: i64,
        param_status: i32,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_offer_location_id: Option<i64>,
        context: &C) -> Result<RedeemOfferTransactionResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/retailer/offer/transaction/update",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
                query_string.append_pair("offerTransactionId",
                    &param_offer_transaction_id.to_string());
            if let Some(param_offer_location_id) = param_offer_location_id {
                query_string.append_pair("offerLocationId",
                    &param_offer_location_id.to_string());
            }
                query_string.append_pair("status",
                    &param_status.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(RedeemOfferTransactionResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn search_offer_transactions_for_retailers(
        &self,
        param_version: f64,
        param_sort_field: models::SearchEventTransactionsSortFieldParameter,
        param_descending: bool,
        param_start: i32,
        param_limit: i32,
        param_active_only: bool,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_q: Option<String>,
        param_keyword: Option<String>,
        param_retailer_id: Option<i64>,
        param_retailer_location_id: Option<i64>,
        param_offer_id: Option<i64>,
        param_offer_location_id: Option<i64>,
        param_redeemed: Option<bool>,
        param_reservations_only: Option<bool>,
        param_coupon_type: Option<models::CreateOfferOfferTypeParameter>,
        param_offer_type: Option<models::CreateOfferOfferTypeParameter>,
        param_special_offer_type: Option<models::CreateMediaSpecialOfferTypeParameter>,
        param_customer_account_ids: Option<String>,
        param_category_ids: Option<String>,
        param_redeemable_start_date: Option<i64>,
        param_redeemable_end_date: Option<i64>,
        param__i: Option<i32>,
        param__l: Option<i32>,
        context: &C) -> Result<SearchOfferTransactionsForRetailersResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/retailer/offer/transaction/search",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_q) = param_q {
                query_string.append_pair("q",
                    &param_q);
            }
            if let Some(param_keyword) = param_keyword {
                query_string.append_pair("keyword",
                    &param_keyword);
            }
            if let Some(param_retailer_id) = param_retailer_id {
                query_string.append_pair("retailerId",
                    &param_retailer_id.to_string());
            }
            if let Some(param_retailer_location_id) = param_retailer_location_id {
                query_string.append_pair("retailerLocationId",
                    &param_retailer_location_id.to_string());
            }
            if let Some(param_offer_id) = param_offer_id {
                query_string.append_pair("offerId",
                    &param_offer_id.to_string());
            }
            if let Some(param_offer_location_id) = param_offer_location_id {
                query_string.append_pair("offerLocationId",
                    &param_offer_location_id.to_string());
            }
            if let Some(param_redeemed) = param_redeemed {
                query_string.append_pair("redeemed",
                    &param_redeemed.to_string());
            }
            if let Some(param_reservations_only) = param_reservations_only {
                query_string.append_pair("reservationsOnly",
                    &param_reservations_only.to_string());
            }
            if let Some(param_coupon_type) = param_coupon_type {
                query_string.append_pair("couponType",
                    &param_coupon_type.to_string());
            }
            if let Some(param_offer_type) = param_offer_type {
                query_string.append_pair("offerType",
                    &param_offer_type.to_string());
            }
            if let Some(param_special_offer_type) = param_special_offer_type {
                query_string.append_pair("specialOfferType",
                    &param_special_offer_type.to_string());
            }
            if let Some(param_customer_account_ids) = param_customer_account_ids {
                query_string.append_pair("customerAccountIds",
                    &param_customer_account_ids);
            }
            if let Some(param_category_ids) = param_category_ids {
                query_string.append_pair("categoryIds",
                    &param_category_ids);
            }
            if let Some(param_redeemable_start_date) = param_redeemable_start_date {
                query_string.append_pair("redeemableStartDate",
                    &param_redeemable_start_date.to_string());
            }
            if let Some(param_redeemable_end_date) = param_redeemable_end_date {
                query_string.append_pair("redeemableEndDate",
                    &param_redeemable_end_date.to_string());
            }
                query_string.append_pair("sortField",
                    &param_sort_field.to_string());
                query_string.append_pair("descending",
                    &param_descending.to_string());
            if let Some(param__i) = param__i {
                query_string.append_pair("_i",
                    &param__i.to_string());
            }
                query_string.append_pair("start",
                    &param_start.to_string());
            if let Some(param__l) = param__l {
                query_string.append_pair("_l",
                    &param__l.to_string());
            }
                query_string.append_pair("limit",
                    &param_limit.to_string());
                query_string.append_pair("activeOnly",
                    &param_active_only.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<Vec<models::OfferTransactionResponse>>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(SearchOfferTransactionsForRetailersResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn search_offers_for_consumer(
        &self,
        param_version: f64,
        param_latitude: f64,
        param_longitude: f64,
        param_recommendation_type: models::SearchOffersForConsumerRecommendationTypeParameter,
        param_location_id: i64,
        param_start: i32,
        param_limit: i32,
        param_max_recommendations: i32,
        param_distance_unit: models::SearchOffersForConsumerDistanceUnitParameter,
        param_app_key: Option<String>,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_search_range: Option<f64>,
        param_tags: Option<String>,
        param_supported_postal_codes: Option<String>,
        param_keyword: Option<String>,
        param_categories: Option<String>,
        param_filters: Option<String>,
        param_offer_types: Option<String>,
        param_param_type: Option<String>,
        param_sort_field: Option<String>,
        param_recommend_offer_ids: Option<String>,
        param_retailer_location_ids: Option<String>,
        param_offer_id: Option<i64>,
        param_include_mission: Option<bool>,
        param_include_categories: Option<bool>,
        param_include_filters: Option<bool>,
        param_include_expired: Option<bool>,
        param_include_favorite: Option<bool>,
        param_closest_offer_only: Option<bool>,
        param_search_expression: Option<String>,
        param_group_by: Option<models::SearchOffersForConsumerGroupByParameter>,
        context: &C) -> Result<SearchOffersForConsumerResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/offer/lists",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_app_key) = param_app_key {
                query_string.append_pair("appKey",
                    &param_app_key);
            }
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
                query_string.append_pair("latitude",
                    &param_latitude.to_string());
                query_string.append_pair("longitude",
                    &param_longitude.to_string());
            if let Some(param_search_range) = param_search_range {
                query_string.append_pair("searchRange",
                    &param_search_range.to_string());
            }
            if let Some(param_tags) = param_tags {
                query_string.append_pair("tags",
                    &param_tags);
            }
            if let Some(param_supported_postal_codes) = param_supported_postal_codes {
                query_string.append_pair("supportedPostalCodes",
                    &param_supported_postal_codes);
            }
            if let Some(param_keyword) = param_keyword {
                query_string.append_pair("keyword",
                    &param_keyword);
            }
            if let Some(param_categories) = param_categories {
                query_string.append_pair("categories",
                    &param_categories);
            }
            if let Some(param_filters) = param_filters {
                query_string.append_pair("filters",
                    &param_filters);
            }
            if let Some(param_offer_types) = param_offer_types {
                query_string.append_pair("offerTypes",
                    &param_offer_types);
            }
            if let Some(param_param_type) = param_param_type {
                query_string.append_pair("type",
                    &param_param_type);
            }
            if let Some(param_sort_field) = param_sort_field {
                query_string.append_pair("sortField",
                    &param_sort_field);
            }
            if let Some(param_recommend_offer_ids) = param_recommend_offer_ids {
                query_string.append_pair("recommendOfferIds",
                    &param_recommend_offer_ids);
            }
                query_string.append_pair("recommendationType",
                    &param_recommendation_type.to_string());
                query_string.append_pair("locationId",
                    &param_location_id.to_string());
            if let Some(param_retailer_location_ids) = param_retailer_location_ids {
                query_string.append_pair("retailerLocationIds",
                    &param_retailer_location_ids);
            }
            if let Some(param_offer_id) = param_offer_id {
                query_string.append_pair("offerId",
                    &param_offer_id.to_string());
            }
            if let Some(param_include_mission) = param_include_mission {
                query_string.append_pair("includeMission",
                    &param_include_mission.to_string());
            }
            if let Some(param_include_categories) = param_include_categories {
                query_string.append_pair("includeCategories",
                    &param_include_categories.to_string());
            }
            if let Some(param_include_filters) = param_include_filters {
                query_string.append_pair("includeFilters",
                    &param_include_filters.to_string());
            }
            if let Some(param_include_expired) = param_include_expired {
                query_string.append_pair("includeExpired",
                    &param_include_expired.to_string());
            }
            if let Some(param_include_favorite) = param_include_favorite {
                query_string.append_pair("includeFavorite",
                    &param_include_favorite.to_string());
            }
                query_string.append_pair("start",
                    &param_start.to_string());
                query_string.append_pair("limit",
                    &param_limit.to_string());
                query_string.append_pair("maxRecommendations",
                    &param_max_recommendations.to_string());
                query_string.append_pair("distanceUnit",
                    &param_distance_unit.to_string());
            if let Some(param_closest_offer_only) = param_closest_offer_only {
                query_string.append_pair("closestOfferOnly",
                    &param_closest_offer_only.to_string());
            }
            if let Some(param_search_expression) = param_search_expression {
                query_string.append_pair("searchExpression",
                    &param_search_expression);
            }
            if let Some(param_group_by) = param_group_by {
                query_string.append_pair("groupBy",
                    &param_group_by.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::OfferListResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(SearchOffersForConsumerResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn top_offer_transactions(
        &self,
        param_version: f64,
        param_start: Option<i32>,
        param_limit: Option<i32>,
        context: &C) -> Result<TopOfferTransactionsResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/offer/top",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_start) = param_start {
                query_string.append_pair("start",
                    &param_start.to_string());
            }
            if let Some(param_limit) = param_limit {
                query_string.append_pair("limit",
                    &param_limit.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::OfferListResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(TopOfferTransactionsResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn update_offer(
        &self,
        param_version: f64,
        param_offer_id: i64,
        param_include_offer_locations: bool,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_parent_offer_id: Option<i64>,
        param_retailer_location_ids: Option<String>,
        param_offer_locations: Option<String>,
        param_tags: Option<String>,
        param_title: Option<String>,
        param_sub_title: Option<String>,
        param_details: Option<String>,
        param_sub_details: Option<String>,
        param_fine_print: Option<String>,
        param_barcode_type: Option<models::CreateMediaBarcodeTypeParameter>,
        param_barcode_entry: Option<String>,
        param_external_redeem_options: Option<String>,
        param_external_url: Option<String>,
        param_external_id: Option<String>,
        param_tickets_reward_type: Option<String>,
        param_tickets_reward: Option<i64>,
        param_activated: Option<i64>,
        param_expires: Option<i64>,
        param_no_expiration: Option<bool>,
        param_available_limit: Option<i32>,
        param_available_limit_per_user: Option<i32>,
        param_added_limit: Option<i32>,
        param_view_limit: Option<i32>,
        param_max_prints: Option<i32>,
        param_ticket_price_type: Option<String>,
        param_ticket_price: Option<i64>,
        param_full_price: Option<f64>,
        param_discount_price: Option<f64>,
        param_show_remaining: Option<bool>,
        param_show_redeemed: Option<bool>,
        param_replaced: Option<bool>,
        param_featured: Option<bool>,
        param_offer_type: Option<models::CreateOfferOfferTypeParameter>,
        param_special_offer_type: Option<models::CreateMediaSpecialOfferTypeParameter>,
        param_offer_visibility: Option<models::CreateMediaOfferVisibilityParameter>,
        param_category_ids: Option<String>,
        param_filter_ids: Option<String>,
        param_active: Option<bool>,
        param_barcode_asset_id: Option<i64>,
        param_image_asset_id: Option<i64>,
        param_image_asset_id1: Option<i64>,
        param_image_asset_id2: Option<i64>,
        param_image_asset_id3: Option<i64>,
        param_image_asset_id4: Option<i64>,
        param_image_asset_id5: Option<i64>,
        param_publisher: Option<String>,
        param_redeemable_start: Option<i64>,
        param_redeemable_end: Option<i64>,
        param_brand: Option<String>,
        param_product_type: Option<models::CreateOfferProductTypeParameter>,
        param_condition_type: Option<models::CreateMediaConditionTypeParameter>,
        param_isbn: Option<String>,
        param_asin: Option<String>,
        param_catalog_numbers: Option<String>,
        param_department: Option<String>,
        param_features: Option<String>,
        param_minimum_price: Option<f64>,
        param_width: Option<f64>,
        param_height: Option<f64>,
        param_depth: Option<f64>,
        param_weight: Option<f64>,
        param_unit: Option<models::CreateOfferUnitParameter>,
        param_studio: Option<String>,
        param_parental_rating: Option<String>,
        param_publish_date: Option<i64>,
        param_availability_date: Option<i64>,
        param_size_id: Option<i64>,
        param_listing_id: Option<i64>,
        param_media_type: Option<models::CreateMediaMediaTypeParameter>,
        param_duration: Option<i32>,
        param_author: Option<String>,
        param_release_date: Option<i64>,
        param_collection_ids: Option<String>,
        param_reboot_time_hour: Option<i32>,
        param_reboot_time_minute: Option<i32>,
        param_idle_timeout_in_second: Option<i32>,
        param_serial_number: Option<String>,
        param_udid: Option<String>,
        param_device_type: Option<String>,
        param_device_power: Option<f64>,
        param_device_interference: Option<f64>,
        param_availability: Option<String>,
        param_availability_summary: Option<String>,
        context: &C) -> Result<UpdateOfferResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/retailer/offer/update",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
                query_string.append_pair("offerId",
                    &param_offer_id.to_string());
            if let Some(param_parent_offer_id) = param_parent_offer_id {
                query_string.append_pair("parentOfferId",
                    &param_parent_offer_id.to_string());
            }
                query_string.append_pair("includeOfferLocations",
                    &param_include_offer_locations.to_string());
            if let Some(param_retailer_location_ids) = param_retailer_location_ids {
                query_string.append_pair("retailerLocationIds",
                    &param_retailer_location_ids);
            }
            if let Some(param_offer_locations) = param_offer_locations {
                query_string.append_pair("offerLocations",
                    &param_offer_locations);
            }
            if let Some(param_tags) = param_tags {
                query_string.append_pair("tags",
                    &param_tags);
            }
            if let Some(param_title) = param_title {
                query_string.append_pair("title",
                    &param_title);
            }
            if let Some(param_sub_title) = param_sub_title {
                query_string.append_pair("subTitle",
                    &param_sub_title);
            }
            if let Some(param_details) = param_details {
                query_string.append_pair("details",
                    &param_details);
            }
            if let Some(param_sub_details) = param_sub_details {
                query_string.append_pair("subDetails",
                    &param_sub_details);
            }
            if let Some(param_fine_print) = param_fine_print {
                query_string.append_pair("finePrint",
                    &param_fine_print);
            }
            if let Some(param_barcode_type) = param_barcode_type {
                query_string.append_pair("barcodeType",
                    &param_barcode_type.to_string());
            }
            if let Some(param_barcode_entry) = param_barcode_entry {
                query_string.append_pair("barcodeEntry",
                    &param_barcode_entry);
            }
            if let Some(param_external_redeem_options) = param_external_redeem_options {
                query_string.append_pair("externalRedeemOptions",
                    &param_external_redeem_options);
            }
            if let Some(param_external_url) = param_external_url {
                query_string.append_pair("externalUrl",
                    &param_external_url);
            }
            if let Some(param_external_id) = param_external_id {
                query_string.append_pair("externalId",
                    &param_external_id);
            }
            if let Some(param_tickets_reward_type) = param_tickets_reward_type {
                query_string.append_pair("ticketsRewardType",
                    &param_tickets_reward_type);
            }
            if let Some(param_tickets_reward) = param_tickets_reward {
                query_string.append_pair("ticketsReward",
                    &param_tickets_reward.to_string());
            }
            if let Some(param_activated) = param_activated {
                query_string.append_pair("activated",
                    &param_activated.to_string());
            }
            if let Some(param_expires) = param_expires {
                query_string.append_pair("expires",
                    &param_expires.to_string());
            }
            if let Some(param_no_expiration) = param_no_expiration {
                query_string.append_pair("noExpiration",
                    &param_no_expiration.to_string());
            }
            if let Some(param_available_limit) = param_available_limit {
                query_string.append_pair("availableLimit",
                    &param_available_limit.to_string());
            }
            if let Some(param_available_limit_per_user) = param_available_limit_per_user {
                query_string.append_pair("availableLimitPerUser",
                    &param_available_limit_per_user.to_string());
            }
            if let Some(param_added_limit) = param_added_limit {
                query_string.append_pair("addedLimit",
                    &param_added_limit.to_string());
            }
            if let Some(param_view_limit) = param_view_limit {
                query_string.append_pair("viewLimit",
                    &param_view_limit.to_string());
            }
            if let Some(param_max_prints) = param_max_prints {
                query_string.append_pair("maxPrints",
                    &param_max_prints.to_string());
            }
            if let Some(param_ticket_price_type) = param_ticket_price_type {
                query_string.append_pair("ticketPriceType",
                    &param_ticket_price_type);
            }
            if let Some(param_ticket_price) = param_ticket_price {
                query_string.append_pair("ticketPrice",
                    &param_ticket_price.to_string());
            }
            if let Some(param_full_price) = param_full_price {
                query_string.append_pair("fullPrice",
                    &param_full_price.to_string());
            }
            if let Some(param_discount_price) = param_discount_price {
                query_string.append_pair("discountPrice",
                    &param_discount_price.to_string());
            }
            if let Some(param_show_remaining) = param_show_remaining {
                query_string.append_pair("showRemaining",
                    &param_show_remaining.to_string());
            }
            if let Some(param_show_redeemed) = param_show_redeemed {
                query_string.append_pair("showRedeemed",
                    &param_show_redeemed.to_string());
            }
            if let Some(param_replaced) = param_replaced {
                query_string.append_pair("replaced",
                    &param_replaced.to_string());
            }
            if let Some(param_featured) = param_featured {
                query_string.append_pair("featured",
                    &param_featured.to_string());
            }
            if let Some(param_offer_type) = param_offer_type {
                query_string.append_pair("offerType",
                    &param_offer_type.to_string());
            }
            if let Some(param_special_offer_type) = param_special_offer_type {
                query_string.append_pair("specialOfferType",
                    &param_special_offer_type.to_string());
            }
            if let Some(param_offer_visibility) = param_offer_visibility {
                query_string.append_pair("offerVisibility",
                    &param_offer_visibility.to_string());
            }
            if let Some(param_category_ids) = param_category_ids {
                query_string.append_pair("categoryIds",
                    &param_category_ids);
            }
            if let Some(param_filter_ids) = param_filter_ids {
                query_string.append_pair("filterIds",
                    &param_filter_ids);
            }
            if let Some(param_active) = param_active {
                query_string.append_pair("active",
                    &param_active.to_string());
            }
            if let Some(param_barcode_asset_id) = param_barcode_asset_id {
                query_string.append_pair("barcodeAssetId",
                    &param_barcode_asset_id.to_string());
            }
            if let Some(param_image_asset_id) = param_image_asset_id {
                query_string.append_pair("imageAssetId",
                    &param_image_asset_id.to_string());
            }
            if let Some(param_image_asset_id1) = param_image_asset_id1 {
                query_string.append_pair("imageAssetId1",
                    &param_image_asset_id1.to_string());
            }
            if let Some(param_image_asset_id2) = param_image_asset_id2 {
                query_string.append_pair("imageAssetId2",
                    &param_image_asset_id2.to_string());
            }
            if let Some(param_image_asset_id3) = param_image_asset_id3 {
                query_string.append_pair("imageAssetId3",
                    &param_image_asset_id3.to_string());
            }
            if let Some(param_image_asset_id4) = param_image_asset_id4 {
                query_string.append_pair("imageAssetId4",
                    &param_image_asset_id4.to_string());
            }
            if let Some(param_image_asset_id5) = param_image_asset_id5 {
                query_string.append_pair("imageAssetId5",
                    &param_image_asset_id5.to_string());
            }
            if let Some(param_publisher) = param_publisher {
                query_string.append_pair("publisher",
                    &param_publisher);
            }
            if let Some(param_redeemable_start) = param_redeemable_start {
                query_string.append_pair("redeemableStart",
                    &param_redeemable_start.to_string());
            }
            if let Some(param_redeemable_end) = param_redeemable_end {
                query_string.append_pair("redeemableEnd",
                    &param_redeemable_end.to_string());
            }
            if let Some(param_brand) = param_brand {
                query_string.append_pair("brand",
                    &param_brand);
            }
            if let Some(param_product_type) = param_product_type {
                query_string.append_pair("productType",
                    &param_product_type.to_string());
            }
            if let Some(param_condition_type) = param_condition_type {
                query_string.append_pair("conditionType",
                    &param_condition_type.to_string());
            }
            if let Some(param_isbn) = param_isbn {
                query_string.append_pair("isbn",
                    &param_isbn);
            }
            if let Some(param_asin) = param_asin {
                query_string.append_pair("asin",
                    &param_asin);
            }
            if let Some(param_catalog_numbers) = param_catalog_numbers {
                query_string.append_pair("catalogNumbers",
                    &param_catalog_numbers);
            }
            if let Some(param_department) = param_department {
                query_string.append_pair("department",
                    &param_department);
            }
            if let Some(param_features) = param_features {
                query_string.append_pair("features",
                    &param_features);
            }
            if let Some(param_minimum_price) = param_minimum_price {
                query_string.append_pair("minimumPrice",
                    &param_minimum_price.to_string());
            }
            if let Some(param_width) = param_width {
                query_string.append_pair("width",
                    &param_width.to_string());
            }
            if let Some(param_height) = param_height {
                query_string.append_pair("height",
                    &param_height.to_string());
            }
            if let Some(param_depth) = param_depth {
                query_string.append_pair("depth",
                    &param_depth.to_string());
            }
            if let Some(param_weight) = param_weight {
                query_string.append_pair("weight",
                    &param_weight.to_string());
            }
            if let Some(param_unit) = param_unit {
                query_string.append_pair("unit",
                    &param_unit.to_string());
            }
            if let Some(param_studio) = param_studio {
                query_string.append_pair("studio",
                    &param_studio);
            }
            if let Some(param_parental_rating) = param_parental_rating {
                query_string.append_pair("parentalRating",
                    &param_parental_rating);
            }
            if let Some(param_publish_date) = param_publish_date {
                query_string.append_pair("publishDate",
                    &param_publish_date.to_string());
            }
            if let Some(param_availability_date) = param_availability_date {
                query_string.append_pair("availabilityDate",
                    &param_availability_date.to_string());
            }
            if let Some(param_size_id) = param_size_id {
                query_string.append_pair("sizeId",
                    &param_size_id.to_string());
            }
            if let Some(param_listing_id) = param_listing_id {
                query_string.append_pair("listingId",
                    &param_listing_id.to_string());
            }
            if let Some(param_media_type) = param_media_type {
                query_string.append_pair("mediaType",
                    &param_media_type.to_string());
            }
            if let Some(param_duration) = param_duration {
                query_string.append_pair("duration",
                    &param_duration.to_string());
            }
            if let Some(param_author) = param_author {
                query_string.append_pair("author",
                    &param_author);
            }
            if let Some(param_release_date) = param_release_date {
                query_string.append_pair("releaseDate",
                    &param_release_date.to_string());
            }
            if let Some(param_collection_ids) = param_collection_ids {
                query_string.append_pair("collectionIds",
                    &param_collection_ids);
            }
            if let Some(param_reboot_time_hour) = param_reboot_time_hour {
                query_string.append_pair("rebootTimeHour",
                    &param_reboot_time_hour.to_string());
            }
            if let Some(param_reboot_time_minute) = param_reboot_time_minute {
                query_string.append_pair("rebootTimeMinute",
                    &param_reboot_time_minute.to_string());
            }
            if let Some(param_idle_timeout_in_second) = param_idle_timeout_in_second {
                query_string.append_pair("idleTimeoutInSecond",
                    &param_idle_timeout_in_second.to_string());
            }
            if let Some(param_serial_number) = param_serial_number {
                query_string.append_pair("serialNumber",
                    &param_serial_number);
            }
            if let Some(param_udid) = param_udid {
                query_string.append_pair("udid",
                    &param_udid);
            }
            if let Some(param_device_type) = param_device_type {
                query_string.append_pair("deviceType",
                    &param_device_type);
            }
            if let Some(param_device_power) = param_device_power {
                query_string.append_pair("devicePower",
                    &param_device_power.to_string());
            }
            if let Some(param_device_interference) = param_device_interference {
                query_string.append_pair("deviceInterference",
                    &param_device_interference.to_string());
            }
            if let Some(param_availability) = param_availability {
                query_string.append_pair("availability",
                    &param_availability);
            }
            if let Some(param_availability_summary) = param_availability_summary {
                query_string.append_pair("availabilitySummary",
                    &param_availability_summary);
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::RetailerOfferResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(UpdateOfferResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn update_offer_status(
        &self,
        param_version: f64,
        param_offer_ids: String,
        param_active: bool,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        context: &C) -> Result<UpdateOfferStatusResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/retailer/offer/status",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
                query_string.append_pair("offerIds",
                    &param_offer_ids);
                query_string.append_pair("active",
                    &param_active.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(UpdateOfferStatusResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn create_offer_transaction_status(
        &self,
        param_version: f64,
        param_name: String,
        param_code: i32,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_latitude: Option<f64>,
        param_longitude: Option<f64>,
        param_description: Option<String>,
        param_role: Option<String>,
        param_active: Option<bool>,
        param_application_ids: Option<String>,
        context: &C) -> Result<CreateOfferTransactionStatusResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/offer/status/create",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_latitude) = param_latitude {
                query_string.append_pair("latitude",
                    &param_latitude.to_string());
            }
            if let Some(param_longitude) = param_longitude {
                query_string.append_pair("longitude",
                    &param_longitude.to_string());
            }
                query_string.append_pair("name",
                    &param_name);
            if let Some(param_description) = param_description {
                query_string.append_pair("description",
                    &param_description);
            }
                query_string.append_pair("code",
                    &param_code.to_string());
            if let Some(param_role) = param_role {
                query_string.append_pair("role",
                    &param_role);
            }
            if let Some(param_active) = param_active {
                query_string.append_pair("active",
                    &param_active.to_string());
            }
            if let Some(param_application_ids) = param_application_ids {
                query_string.append_pair("applicationIds",
                    &param_application_ids);
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::OfferTransactionStatusResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(CreateOfferTransactionStatusResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn delete_offer_transaction_status(
        &self,
        param_version: f64,
        param_status_id: i64,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_latitude: Option<f64>,
        param_longitude: Option<f64>,
        context: &C) -> Result<DeleteOfferTransactionStatusResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/offer/status/delete",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_latitude) = param_latitude {
                query_string.append_pair("latitude",
                    &param_latitude.to_string());
            }
            if let Some(param_longitude) = param_longitude {
                query_string.append_pair("longitude",
                    &param_longitude.to_string());
            }
                query_string.append_pair("statusId",
                    &param_status_id.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(DeleteOfferTransactionStatusResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_offer_transaction_status(
        &self,
        param_version: f64,
        param_status_id: i64,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_latitude: Option<f64>,
        param_longitude: Option<f64>,
        context: &C) -> Result<GetOfferTransactionStatusResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/offer/status/get",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_latitude) = param_latitude {
                query_string.append_pair("latitude",
                    &param_latitude.to_string());
            }
            if let Some(param_longitude) = param_longitude {
                query_string.append_pair("longitude",
                    &param_longitude.to_string());
            }
                query_string.append_pair("statusId",
                    &param_status_id.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::OfferTransactionStatusResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetOfferTransactionStatusResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn search_offer_transaction_statuses(
        &self,
        param_version: f64,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_latitude: Option<f64>,
        param_longitude: Option<f64>,
        param_keyword: Option<String>,
        param_role: Option<String>,
        param_app_key: Option<String>,
        param_sort_field: Option<models::SearchOfferTransactionStatusesSortFieldParameter>,
        param_descending: Option<bool>,
        param_start: Option<i32>,
        param_limit: Option<i32>,
        param_include_inactive: Option<bool>,
        context: &C) -> Result<SearchOfferTransactionStatusesResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/offer/status/search",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_latitude) = param_latitude {
                query_string.append_pair("latitude",
                    &param_latitude.to_string());
            }
            if let Some(param_longitude) = param_longitude {
                query_string.append_pair("longitude",
                    &param_longitude.to_string());
            }
            if let Some(param_keyword) = param_keyword {
                query_string.append_pair("keyword",
                    &param_keyword);
            }
            if let Some(param_role) = param_role {
                query_string.append_pair("role",
                    &param_role);
            }
            if let Some(param_app_key) = param_app_key {
                query_string.append_pair("appKey",
                    &param_app_key);
            }
            if let Some(param_sort_field) = param_sort_field {
                query_string.append_pair("sortField",
                    &param_sort_field.to_string());
            }
            if let Some(param_descending) = param_descending {
                query_string.append_pair("descending",
                    &param_descending.to_string());
            }
            if let Some(param_start) = param_start {
                query_string.append_pair("start",
                    &param_start.to_string());
            }
            if let Some(param_limit) = param_limit {
                query_string.append_pair("limit",
                    &param_limit.to_string());
            }
            if let Some(param_include_inactive) = param_include_inactive {
                query_string.append_pair("includeInactive",
                    &param_include_inactive.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<Vec<models::OfferTransactionStatusResponse>>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(SearchOfferTransactionStatusesResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn update_offer_transaction_status(
        &self,
        param_version: f64,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_latitude: Option<f64>,
        param_longitude: Option<f64>,
        param_status_id: Option<i64>,
        param_name: Option<String>,
        param_description: Option<String>,
        param_code: Option<i32>,
        param_role: Option<String>,
        param_active: Option<bool>,
        param_application_ids: Option<String>,
        context: &C) -> Result<UpdateOfferTransactionStatusResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/offer/status/update",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_latitude) = param_latitude {
                query_string.append_pair("latitude",
                    &param_latitude.to_string());
            }
            if let Some(param_longitude) = param_longitude {
                query_string.append_pair("longitude",
                    &param_longitude.to_string());
            }
            if let Some(param_status_id) = param_status_id {
                query_string.append_pair("statusId",
                    &param_status_id.to_string());
            }
            if let Some(param_name) = param_name {
                query_string.append_pair("name",
                    &param_name);
            }
            if let Some(param_description) = param_description {
                query_string.append_pair("description",
                    &param_description);
            }
            if let Some(param_code) = param_code {
                query_string.append_pair("code",
                    &param_code.to_string());
            }
            if let Some(param_role) = param_role {
                query_string.append_pair("role",
                    &param_role);
            }
            if let Some(param_active) = param_active {
                query_string.append_pair("active",
                    &param_active.to_string());
            }
            if let Some(param_application_ids) = param_application_ids {
                query_string.append_pair("applicationIds",
                    &param_application_ids);
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::OfferTransactionStatusResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(UpdateOfferTransactionStatusResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn image_generation(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_post_body: String,
        param_return_raw_response: Option<bool>,
        context: &C) -> Result<ImageGenerationResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/openai/v1/images/generations",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("postBody",
                    &param_post_body);
            if let Some(param_return_raw_response) = param_return_raw_response {
                query_string.append_pair("returnRawResponse",
                    &param_return_raw_response.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::WrappedProxyItemResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(ImageGenerationResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn request_optimization(
        &self,
        param_version: f64,
        param_body: Option<models::Orders>,
        context: &C) -> Result<RequestOptimizationResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/optimize/request",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        // Consumes basic body
        // Body parameter
        if let Some(param_body) = param_body {
        let body = serde_json::to_string(&param_body).expect("impossible to fail to serialize");
        *request.body_mut() = body_from_string(body);
        }

        let header = "application/json";
        request.headers_mut().insert(CONTENT_TYPE, HeaderValue::from_static(header));

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::ImportStatuses>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(RequestOptimizationResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_optimization_result(
        &self,
        param_version: f64,
        param_batch_id: String,
        param_start: i32,
        param_limit: i32,
        context: &C) -> Result<GetOptimizationResultResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/optimize/result/{batch_id}",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
            ,batch_id=utf8_percent_encode(&param_batch_id.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("start",
                    &param_start.to_string());
                query_string.append_pair("limit",
                    &param_limit.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<std::collections::HashMap<String, models::ShipmentOrder>>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetOptimizationResultResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn add_movie(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_movie_name: String,
        param_third_party_account_id: Option<String>,
        param_tags: Option<String>,
        param_file: Option<swagger::ByteArray>,
        param_url: Option<String>,
        param_callback: Option<String>,
        context: &C) -> Result<AddMovieResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/orson/ai/addMovie",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            if let Some(param_third_party_account_id) = param_third_party_account_id {
                query_string.append_pair("thirdPartyAccountId",
                    &param_third_party_account_id);
            }
            if let Some(param_tags) = param_tags {
                query_string.append_pair("tags",
                    &param_tags);
            }
                query_string.append_pair("movieName",
                    &param_movie_name);
            if let Some(param_file) = param_file {
                query_string.append_pair("file",
                    &param_file.to_string());
            }
            if let Some(param_url) = param_url {
                query_string.append_pair("url",
                    &param_url);
            }
            if let Some(param_callback) = param_callback {
                query_string.append_pair("callback",
                    &param_callback);
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::OrsonAiAddMovieResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(AddMovieResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn ai_docs(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_doc: String,
        param_return_topics: Option<bool>,
        param_limit: Option<i32>,
        param_offset: Option<i32>,
        context: &C) -> Result<AiDocsResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/orson/ai/docs",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("doc",
                    &param_doc);
            if let Some(param_return_topics) = param_return_topics {
                query_string.append_pair("return_topics",
                    &param_return_topics.to_string());
            }
            if let Some(param_limit) = param_limit {
                query_string.append_pair("limit",
                    &param_limit.to_string());
            }
            if let Some(param_offset) = param_offset {
                query_string.append_pair("offset",
                    &param_offset.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::OrsonAiProtoResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(AiDocsResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn ai_find_images(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_text: String,
        param_parse_flag: Option<String>,
        param_fetch_flag: Option<String>,
        param_size: Option<String>,
        context: &C) -> Result<AiFindImagesResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/orson/ai/img",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("text",
                    &param_text);
            if let Some(param_parse_flag) = param_parse_flag {
                query_string.append_pair("parse_flag",
                    &param_parse_flag);
            }
            if let Some(param_fetch_flag) = param_fetch_flag {
                query_string.append_pair("fetch_flag",
                    &param_fetch_flag);
            }
            if let Some(param_size) = param_size {
                query_string.append_pair("size",
                    &param_size);
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::OrsonAiProtoResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(AiFindImagesResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn ai_tags(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_tags: String,
        param_conditional: Option<String>,
        param_limit: Option<i32>,
        param_offset: Option<i32>,
        context: &C) -> Result<AiTagsResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/orson/ai/tags",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("tags",
                    &param_tags);
            if let Some(param_conditional) = param_conditional {
                query_string.append_pair("conditional",
                    &param_conditional);
            }
            if let Some(param_limit) = param_limit {
                query_string.append_pair("limit",
                    &param_limit.to_string());
            }
            if let Some(param_offset) = param_offset {
                query_string.append_pair("offset",
                    &param_offset.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::OrsonAiProtoResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(AiTagsResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn ai_text(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_terms: String,
        param_conditional: Option<String>,
        param_limit: Option<i32>,
        param_offset: Option<i32>,
        context: &C) -> Result<AiTextResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/orson/ai/text",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("terms",
                    &param_terms);
            if let Some(param_conditional) = param_conditional {
                query_string.append_pair("conditional",
                    &param_conditional);
            }
            if let Some(param_limit) = param_limit {
                query_string.append_pair("limit",
                    &param_limit.to_string());
            }
            if let Some(param_offset) = param_offset {
                query_string.append_pair("offset",
                    &param_offset.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::OrsonAiProtoResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(AiTextResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn batch(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_third_party_account_id: Option<String>,
        param_limit: Option<i32>,
        param_operations: Option<String>,
        param_file: Option<swagger::ByteArray>,
        param_url: Option<String>,
        param_callback: Option<String>,
        context: &C) -> Result<BatchResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/orson/ai/batch",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            if let Some(param_third_party_account_id) = param_third_party_account_id {
                query_string.append_pair("thirdPartyAccountId",
                    &param_third_party_account_id);
            }
            if let Some(param_limit) = param_limit {
                query_string.append_pair("limit",
                    &param_limit.to_string());
            }
            if let Some(param_operations) = param_operations {
                query_string.append_pair("operations",
                    &param_operations);
            }
            if let Some(param_file) = param_file {
                query_string.append_pair("file",
                    &param_file.to_string());
            }
            if let Some(param_url) = param_url {
                query_string.append_pair("url",
                    &param_url);
            }
            if let Some(param_callback) = param_callback {
                query_string.append_pair("callback",
                    &param_callback);
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::OrsonAiBatchResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(BatchResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn create_instant_episode(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_data: String,
        context: &C) -> Result<CreateInstantEpisodeResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/orson/stories/episodes/instant",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("data",
                    &param_data);
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::OrsonEpisodeResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(CreateInstantEpisodeResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn create_voice_canvas(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_dimensions: String,
        param_third_party_account_id: Option<String>,
        param_text: Option<String>,
        param_file: Option<swagger::ByteArray>,
        param_url: Option<String>,
        param_parse_flag: Option<bool>,
        param_fetch_flag: Option<bool>,
        param_callback: Option<String>,
        context: &C) -> Result<CreateVoiceCanvasResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/orson/ai/voiceCanvas",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            if let Some(param_third_party_account_id) = param_third_party_account_id {
                query_string.append_pair("thirdPartyAccountId",
                    &param_third_party_account_id);
            }
                query_string.append_pair("dimensions",
                    &param_dimensions);
            if let Some(param_text) = param_text {
                query_string.append_pair("text",
                    &param_text);
            }
            if let Some(param_file) = param_file {
                query_string.append_pair("file",
                    &param_file.to_string());
            }
            if let Some(param_url) = param_url {
                query_string.append_pair("url",
                    &param_url);
            }
            if let Some(param_parse_flag) = param_parse_flag {
                query_string.append_pair("parseFlag",
                    &param_parse_flag.to_string());
            }
            if let Some(param_fetch_flag) = param_fetch_flag {
                query_string.append_pair("fetchFlag",
                    &param_fetch_flag.to_string());
            }
            if let Some(param_callback) = param_callback {
                query_string.append_pair("callback",
                    &param_callback);
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::OrsonAiVoiceCanvasResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(CreateVoiceCanvasResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn emotion(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_third_party_account_id: Option<String>,
        param_file: Option<swagger::ByteArray>,
        param_url: Option<String>,
        param_callback: Option<String>,
        context: &C) -> Result<EmotionResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/orson/ai/emotion",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            if let Some(param_third_party_account_id) = param_third_party_account_id {
                query_string.append_pair("thirdPartyAccountId",
                    &param_third_party_account_id);
            }
            if let Some(param_file) = param_file {
                query_string.append_pair("file",
                    &param_file.to_string());
            }
            if let Some(param_url) = param_url {
                query_string.append_pair("url",
                    &param_url);
            }
            if let Some(param_callback) = param_callback {
                query_string.append_pair("callback",
                    &param_callback);
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::OrsonAiEmotionsResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(EmotionResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn start_video_render(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_data: String,
        context: &C) -> Result<StartVideoRenderResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/orson/stories/renders",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("data",
                    &param_data);
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::OrsonRenderResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(StartVideoRenderResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn stt(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_third_party_account_id: Option<String>,
        param_source_language: Option<String>,
        param_target_language: Option<String>,
        param_file: Option<swagger::ByteArray>,
        param_url: Option<String>,
        param_callback: Option<String>,
        context: &C) -> Result<SttResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/orson/ai/stt",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            if let Some(param_third_party_account_id) = param_third_party_account_id {
                query_string.append_pair("thirdPartyAccountId",
                    &param_third_party_account_id);
            }
            if let Some(param_source_language) = param_source_language {
                query_string.append_pair("sourceLanguage",
                    &param_source_language);
            }
            if let Some(param_target_language) = param_target_language {
                query_string.append_pair("targetLanguage",
                    &param_target_language);
            }
            if let Some(param_file) = param_file {
                query_string.append_pair("file",
                    &param_file.to_string());
            }
            if let Some(param_url) = param_url {
                query_string.append_pair("url",
                    &param_url);
            }
            if let Some(param_callback) = param_callback {
                query_string.append_pair("callback",
                    &param_callback);
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::OrsonAiSttResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(SttResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn summarize_topics(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_third_party_account_id: Option<String>,
        param_doc: Option<String>,
        param_file: Option<swagger::ByteArray>,
        param_url: Option<String>,
        param_limit: Option<i32>,
        param_offset: Option<i32>,
        param_callback: Option<String>,
        context: &C) -> Result<SummarizeTopicsResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/orson/ai/topics",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            if let Some(param_third_party_account_id) = param_third_party_account_id {
                query_string.append_pair("thirdPartyAccountId",
                    &param_third_party_account_id);
            }
            if let Some(param_doc) = param_doc {
                query_string.append_pair("doc",
                    &param_doc);
            }
            if let Some(param_file) = param_file {
                query_string.append_pair("file",
                    &param_file.to_string());
            }
            if let Some(param_url) = param_url {
                query_string.append_pair("url",
                    &param_url);
            }
            if let Some(param_limit) = param_limit {
                query_string.append_pair("limit",
                    &param_limit.to_string());
            }
            if let Some(param_offset) = param_offset {
                query_string.append_pair("offset",
                    &param_offset.to_string());
            }
            if let Some(param_callback) = param_callback {
                query_string.append_pair("callback",
                    &param_callback);
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::OrsonAiTopicsResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(SummarizeTopicsResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn tech_tune(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_num_faces_expected: i32,
        param_third_party_account_id: Option<String>,
        param_file: Option<swagger::ByteArray>,
        param_url: Option<String>,
        param_callback: Option<String>,
        context: &C) -> Result<TechTuneResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/orson/ai/techTune",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            if let Some(param_third_party_account_id) = param_third_party_account_id {
                query_string.append_pair("thirdPartyAccountId",
                    &param_third_party_account_id);
            }
                query_string.append_pair("numFacesExpected",
                    &param_num_faces_expected.to_string());
            if let Some(param_file) = param_file {
                query_string.append_pair("file",
                    &param_file.to_string());
            }
            if let Some(param_url) = param_url {
                query_string.append_pair("url",
                    &param_url);
            }
            if let Some(param_callback) = param_callback {
                query_string.append_pair("callback",
                    &param_callback);
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::OrsonAiTechTuneResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(TechTuneResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn tts(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_text: String,
        param_third_party_account_id: Option<String>,
        param_language: Option<String>,
        param_voice: Option<String>,
        param_callback: Option<String>,
        context: &C) -> Result<TtsResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/orson/ai/tts",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            if let Some(param_third_party_account_id) = param_third_party_account_id {
                query_string.append_pair("thirdPartyAccountId",
                    &param_third_party_account_id);
            }
                query_string.append_pair("text",
                    &param_text);
            if let Some(param_language) = param_language {
                query_string.append_pair("language",
                    &param_language);
            }
            if let Some(param_voice) = param_voice {
                query_string.append_pair("voice",
                    &param_voice);
            }
            if let Some(param_callback) = param_callback {
                query_string.append_pair("callback",
                    &param_callback);
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::OrsonAiTtsResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(TtsResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_add_movie_result(
        &self,
        param_version: f64,
        param_request_id: String,
        param_account_id: i64,
        context: &C) -> Result<GetAddMovieResultResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/orson/ai/addMovie/{request_id}",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
            ,request_id=utf8_percent_encode(&param_request_id.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::OrsonAiAddMovieResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetAddMovieResultResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_batch(
        &self,
        param_version: f64,
        param_request_id: String,
        param_account_id: i64,
        context: &C) -> Result<GetBatchResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/orson/ai/batch/{request_id}",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
            ,request_id=utf8_percent_encode(&param_request_id.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::OrsonAiBatchResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetBatchResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_emotion(
        &self,
        param_version: f64,
        param_request_id: String,
        param_account_id: i64,
        context: &C) -> Result<GetEmotionResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/orson/ai/emotion/{request_id}",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
            ,request_id=utf8_percent_encode(&param_request_id.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::OrsonAiEmotionsResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetEmotionResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_episode_status(
        &self,
        param_version: f64,
        param_episode_id: i64,
        param_account_id: i64,
        context: &C) -> Result<GetEpisodeStatusResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/orson/stories/episodes/{episode_id}/status",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
            ,episode_id=utf8_percent_encode(&param_episode_id.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::OrsonEpisodeResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetEpisodeStatusResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_render_status(
        &self,
        param_version: f64,
        param_render_id: String,
        param_account_id: i64,
        context: &C) -> Result<GetRenderStatusResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/orson/stories/renders/{render_id}/status",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
            ,render_id=utf8_percent_encode(&param_render_id.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::OrsonRenderResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetRenderStatusResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_stt(
        &self,
        param_version: f64,
        param_request_id: String,
        param_account_id: i64,
        context: &C) -> Result<GetSttResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/orson/ai/stt/{request_id}",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
            ,request_id=utf8_percent_encode(&param_request_id.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::OrsonAiSttResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetSttResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_tech_tune(
        &self,
        param_version: f64,
        param_request_id: String,
        param_account_id: i64,
        context: &C) -> Result<GetTechTuneResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/orson/ai/techTune/{request_id}",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
            ,request_id=utf8_percent_encode(&param_request_id.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::OrsonAiTechTuneResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetTechTuneResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_topics(
        &self,
        param_version: f64,
        param_request_id: String,
        param_account_id: i64,
        context: &C) -> Result<GetTopicsResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/orson/ai/topics/{request_id}",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
            ,request_id=utf8_percent_encode(&param_request_id.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::OrsonAiTopicsResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetTopicsResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_tts(
        &self,
        param_version: f64,
        param_request_id: String,
        param_account_id: i64,
        context: &C) -> Result<GetTtsResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/orson/ai/tts/{request_id}",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
            ,request_id=utf8_percent_encode(&param_request_id.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::OrsonAiTtsResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetTtsResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_voice_canvas(
        &self,
        param_version: f64,
        param_request_id: String,
        param_account_id: i64,
        context: &C) -> Result<GetVoiceCanvasResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/orson/ai/voiceCanvas/{request_id}",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
            ,request_id=utf8_percent_encode(&param_request_id.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::OrsonAiVoiceCanvasResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetVoiceCanvasResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn create_pack(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_title: String,
        param_pack_order: i64,
        param_price: i32,
        param_highest: bool,
        param_allocate_tickets: bool,
        param_ticket_count: i64,
        param_description: Option<String>,
        param_search_tags: Option<String>,
        param_active: Option<bool>,
        param_game_type: Option<String>,
        param_app_key: Option<String>,
        param_pack_type: Option<models::CreatePackPackTypeParameter>,
        param_sequence_type: Option<models::CreatePackSequenceTypeParameter>,
        param_background_id: Option<i64>,
        param_image_id: Option<i64>,
        param_start_date: Option<i64>,
        param_end_date: Option<i64>,
        param_author_override: Option<String>,
        param_price_type: Option<String>,
        param_game_level_ids: Option<String>,
        param_in_game: Option<bool>,
        param_ticket_type: Option<String>,
        param_points: Option<i64>,
        context: &C) -> Result<CreatePackResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/pack/create",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("title",
                    &param_title);
            if let Some(param_description) = param_description {
                query_string.append_pair("description",
                    &param_description);
            }
            if let Some(param_search_tags) = param_search_tags {
                query_string.append_pair("searchTags",
                    &param_search_tags);
            }
            if let Some(param_active) = param_active {
                query_string.append_pair("active",
                    &param_active.to_string());
            }
            if let Some(param_game_type) = param_game_type {
                query_string.append_pair("gameType",
                    &param_game_type);
            }
            if let Some(param_app_key) = param_app_key {
                query_string.append_pair("appKey",
                    &param_app_key);
            }
            if let Some(param_pack_type) = param_pack_type {
                query_string.append_pair("packType",
                    &param_pack_type.to_string());
            }
                query_string.append_pair("packOrder",
                    &param_pack_order.to_string());
            if let Some(param_sequence_type) = param_sequence_type {
                query_string.append_pair("sequenceType",
                    &param_sequence_type.to_string());
            }
            if let Some(param_background_id) = param_background_id {
                query_string.append_pair("backgroundId",
                    &param_background_id.to_string());
            }
            if let Some(param_image_id) = param_image_id {
                query_string.append_pair("imageId",
                    &param_image_id.to_string());
            }
            if let Some(param_start_date) = param_start_date {
                query_string.append_pair("startDate",
                    &param_start_date.to_string());
            }
            if let Some(param_end_date) = param_end_date {
                query_string.append_pair("endDate",
                    &param_end_date.to_string());
            }
            if let Some(param_author_override) = param_author_override {
                query_string.append_pair("authorOverride",
                    &param_author_override);
            }
                query_string.append_pair("price",
                    &param_price.to_string());
            if let Some(param_price_type) = param_price_type {
                query_string.append_pair("priceType",
                    &param_price_type);
            }
            if let Some(param_game_level_ids) = param_game_level_ids {
                query_string.append_pair("gameLevelIds",
                    &param_game_level_ids);
            }
            if let Some(param_in_game) = param_in_game {
                query_string.append_pair("inGame",
                    &param_in_game.to_string());
            }
                query_string.append_pair("highest",
                    &param_highest.to_string());
                query_string.append_pair("allocateTickets",
                    &param_allocate_tickets.to_string());
                query_string.append_pair("ticketCount",
                    &param_ticket_count.to_string());
            if let Some(param_ticket_type) = param_ticket_type {
                query_string.append_pair("ticketType",
                    &param_ticket_type);
            }
            if let Some(param_points) = param_points {
                query_string.append_pair("points",
                    &param_points.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::PackResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(CreatePackResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn delete_pack(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_pack_id: i64,
        context: &C) -> Result<DeletePackResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/pack/delete",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("packId",
                    &param_pack_id.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(DeletePackResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_pack(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_pack_id: i64,
        param_include_game_data: bool,
        context: &C) -> Result<GetPackResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/pack/get",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("packId",
                    &param_pack_id.to_string());
                query_string.append_pair("includeGameData",
                    &param_include_game_data.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::PackResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetPackResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn search_packs(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_sort_field: models::SearchPacksSortFieldParameter,
        param_descending: bool,
        param_keyword: Option<String>,
        param_pack_type: Option<models::CreatePackPackTypeParameter>,
        param_start: Option<i32>,
        param_limit: Option<i32>,
        param_include_game_data: Option<bool>,
        param_include_inactive: Option<bool>,
        param_app_key: Option<String>,
        context: &C) -> Result<SearchPacksResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/pack/search",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            if let Some(param_keyword) = param_keyword {
                query_string.append_pair("keyword",
                    &param_keyword);
            }
            if let Some(param_pack_type) = param_pack_type {
                query_string.append_pair("packType",
                    &param_pack_type.to_string());
            }
                query_string.append_pair("sortField",
                    &param_sort_field.to_string());
                query_string.append_pair("descending",
                    &param_descending.to_string());
            if let Some(param_start) = param_start {
                query_string.append_pair("start",
                    &param_start.to_string());
            }
            if let Some(param_limit) = param_limit {
                query_string.append_pair("limit",
                    &param_limit.to_string());
            }
            if let Some(param_include_game_data) = param_include_game_data {
                query_string.append_pair("includeGameData",
                    &param_include_game_data.to_string());
            }
            if let Some(param_include_inactive) = param_include_inactive {
                query_string.append_pair("includeInactive",
                    &param_include_inactive.to_string());
            }
            if let Some(param_app_key) = param_app_key {
                query_string.append_pair("appKey",
                    &param_app_key);
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<Vec<models::PackResponse>>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(SearchPacksResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn update_pack(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_pack_id: i64,
        param_allocate_tickets: bool,
        param_ticket_count: i64,
        param_title: Option<String>,
        param_description: Option<String>,
        param_search_tags: Option<String>,
        param_active: Option<bool>,
        param_game_type: Option<String>,
        param_app_key: Option<String>,
        param_pack_type: Option<models::CreatePackPackTypeParameter>,
        param_pack_order: Option<i64>,
        param_sequence_type: Option<models::CreatePackSequenceTypeParameter>,
        param_background_id: Option<i64>,
        param_image_id: Option<i64>,
        param_start_date: Option<i64>,
        param_end_date: Option<i64>,
        param_author_override: Option<String>,
        param_price: Option<i32>,
        param_price_type: Option<String>,
        param_game_level_ids: Option<String>,
        param_in_game: Option<bool>,
        param_highest: Option<bool>,
        param_ticket_type: Option<String>,
        param_points: Option<i64>,
        context: &C) -> Result<UpdatePackResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/pack/update",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("packId",
                    &param_pack_id.to_string());
            if let Some(param_title) = param_title {
                query_string.append_pair("title",
                    &param_title);
            }
            if let Some(param_description) = param_description {
                query_string.append_pair("description",
                    &param_description);
            }
            if let Some(param_search_tags) = param_search_tags {
                query_string.append_pair("searchTags",
                    &param_search_tags);
            }
            if let Some(param_active) = param_active {
                query_string.append_pair("active",
                    &param_active.to_string());
            }
            if let Some(param_game_type) = param_game_type {
                query_string.append_pair("gameType",
                    &param_game_type);
            }
            if let Some(param_app_key) = param_app_key {
                query_string.append_pair("appKey",
                    &param_app_key);
            }
            if let Some(param_pack_type) = param_pack_type {
                query_string.append_pair("packType",
                    &param_pack_type.to_string());
            }
            if let Some(param_pack_order) = param_pack_order {
                query_string.append_pair("packOrder",
                    &param_pack_order.to_string());
            }
            if let Some(param_sequence_type) = param_sequence_type {
                query_string.append_pair("sequenceType",
                    &param_sequence_type.to_string());
            }
            if let Some(param_background_id) = param_background_id {
                query_string.append_pair("backgroundId",
                    &param_background_id.to_string());
            }
            if let Some(param_image_id) = param_image_id {
                query_string.append_pair("imageId",
                    &param_image_id.to_string());
            }
            if let Some(param_start_date) = param_start_date {
                query_string.append_pair("startDate",
                    &param_start_date.to_string());
            }
            if let Some(param_end_date) = param_end_date {
                query_string.append_pair("endDate",
                    &param_end_date.to_string());
            }
            if let Some(param_author_override) = param_author_override {
                query_string.append_pair("authorOverride",
                    &param_author_override);
            }
            if let Some(param_price) = param_price {
                query_string.append_pair("price",
                    &param_price.to_string());
            }
            if let Some(param_price_type) = param_price_type {
                query_string.append_pair("priceType",
                    &param_price_type);
            }
            if let Some(param_game_level_ids) = param_game_level_ids {
                query_string.append_pair("gameLevelIds",
                    &param_game_level_ids);
            }
            if let Some(param_in_game) = param_in_game {
                query_string.append_pair("inGame",
                    &param_in_game.to_string());
            }
            if let Some(param_highest) = param_highest {
                query_string.append_pair("highest",
                    &param_highest.to_string());
            }
                query_string.append_pair("allocateTickets",
                    &param_allocate_tickets.to_string());
                query_string.append_pair("ticketCount",
                    &param_ticket_count.to_string());
            if let Some(param_ticket_type) = param_ticket_type {
                query_string.append_pair("ticketType",
                    &param_ticket_type);
            }
            if let Some(param_points) = param_points {
                query_string.append_pair("points",
                    &param_points.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::PackResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(UpdatePackResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn process_all_participants(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_app_key: Option<String>,
        param_use_short_name_as_id: Option<bool>,
        context: &C) -> Result<ProcessAllParticipantsResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/participant/process/all",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            if let Some(param_app_key) = param_app_key {
                query_string.append_pair("appKey",
                    &param_app_key);
            }
            if let Some(param_use_short_name_as_id) = param_use_short_name_as_id {
                query_string.append_pair("useShortNameAsID",
                    &param_use_short_name_as_id.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(ProcessAllParticipantsResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn process_participants(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_league: String,
        param_app_key: Option<String>,
        param_use_short_name_as_id: Option<bool>,
        param_file: Option<swagger::ByteArray>,
        context: &C) -> Result<ProcessParticipantsResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/participant/process",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("league",
                    &param_league);
            if let Some(param_app_key) = param_app_key {
                query_string.append_pair("appKey",
                    &param_app_key);
            }
            if let Some(param_use_short_name_as_id) = param_use_short_name_as_id {
                query_string.append_pair("useShortNameAsID",
                    &param_use_short_name_as_id.to_string());
            }
            if let Some(param_file) = param_file {
                query_string.append_pair("file",
                    &param_file.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(ProcessParticipantsResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn compute_path(
        &self,
        param_version: f64,
        param_data: String,
        param_units: models::ComputePathUnitsParameter,
        param_reduce_path: bool,
        param_directions: bool,
        context: &C) -> Result<ComputePathResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/pathing/compute",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("data",
                    &param_data);
                query_string.append_pair("units",
                    &param_units.to_string());
                query_string.append_pair("reducePath",
                    &param_reduce_path.to_string());
                query_string.append_pair("directions",
                    &param_directions.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::PathingResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(ComputePathResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn create_postal_code(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_code: String,
        param_latitude: f64,
        param_longitude: f64,
        param_state_code: Option<String>,
        param_city: Option<String>,
        param_active: Option<bool>,
        context: &C) -> Result<CreatePostalCodeResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/postalCode/create",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("code",
                    &param_code);
                query_string.append_pair("latitude",
                    &param_latitude.to_string());
                query_string.append_pair("longitude",
                    &param_longitude.to_string());
            if let Some(param_state_code) = param_state_code {
                query_string.append_pair("stateCode",
                    &param_state_code);
            }
            if let Some(param_city) = param_city {
                query_string.append_pair("city",
                    &param_city);
            }
            if let Some(param_active) = param_active {
                query_string.append_pair("active",
                    &param_active.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::PostalCodeResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(CreatePostalCodeResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn delete_postal_code(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_postal_code_id: i64,
        context: &C) -> Result<DeletePostalCodeResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/postalCode/delete",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("postalCodeId",
                    &param_postal_code_id.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(DeletePostalCodeResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_postal_code(
        &self,
        param_version: f64,
        param_postal_code_id: i64,
        context: &C) -> Result<GetPostalCodeResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/postalCode/get",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("postalCodeId",
                    &param_postal_code_id.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::PostalCodeResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetPostalCodeResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_postal_codes(
        &self,
        param_version: f64,
        param_sort_field: String,
        param_descending: bool,
        param_latitude: Option<f64>,
        param_longitude: Option<f64>,
        param_keyword: Option<String>,
        param_miles: Option<f64>,
        param_start: Option<i32>,
        param_limit: Option<i32>,
        context: &C) -> Result<GetPostalCodesResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/postalCode/search",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_latitude) = param_latitude {
                query_string.append_pair("latitude",
                    &param_latitude.to_string());
            }
            if let Some(param_longitude) = param_longitude {
                query_string.append_pair("longitude",
                    &param_longitude.to_string());
            }
            if let Some(param_keyword) = param_keyword {
                query_string.append_pair("keyword",
                    &param_keyword);
            }
            if let Some(param_miles) = param_miles {
                query_string.append_pair("miles",
                    &param_miles.to_string());
            }
            if let Some(param_start) = param_start {
                query_string.append_pair("start",
                    &param_start.to_string());
            }
            if let Some(param_limit) = param_limit {
                query_string.append_pair("limit",
                    &param_limit.to_string());
            }
                query_string.append_pair("sortField",
                    &param_sort_field);
                query_string.append_pair("descending",
                    &param_descending.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<Vec<models::PostalCodeResponse>>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetPostalCodesResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn update_postal_code(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_postal_code_id: i64,
        param_code: Option<String>,
        param_latitude: Option<f64>,
        param_longitude: Option<f64>,
        param_state_code: Option<String>,
        param_city: Option<String>,
        param_active: Option<bool>,
        context: &C) -> Result<UpdatePostalCodeResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/postalCode/update",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("postalCodeId",
                    &param_postal_code_id.to_string());
            if let Some(param_code) = param_code {
                query_string.append_pair("code",
                    &param_code);
            }
            if let Some(param_latitude) = param_latitude {
                query_string.append_pair("latitude",
                    &param_latitude.to_string());
            }
            if let Some(param_longitude) = param_longitude {
                query_string.append_pair("longitude",
                    &param_longitude.to_string());
            }
            if let Some(param_state_code) = param_state_code {
                query_string.append_pair("stateCode",
                    &param_state_code);
            }
            if let Some(param_city) = param_city {
                query_string.append_pair("city",
                    &param_city);
            }
            if let Some(param_active) = param_active {
                query_string.append_pair("active",
                    &param_active.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::PostalCodeResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(UpdatePostalCodeResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn create_persona(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_title: String,
        param_preview_accounts: Option<String>,
        param_date: Option<i64>,
        param_age: Option<i32>,
        param_gender: Option<String>,
        param_game_experience_level: Option<String>,
        param_latitude: Option<f64>,
        param_longitude: Option<f64>,
        context: &C) -> Result<CreatePersonaResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/persona/create",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("title",
                    &param_title);
            if let Some(param_preview_accounts) = param_preview_accounts {
                query_string.append_pair("previewAccounts",
                    &param_preview_accounts);
            }
            if let Some(param_date) = param_date {
                query_string.append_pair("date",
                    &param_date.to_string());
            }
            if let Some(param_age) = param_age {
                query_string.append_pair("age",
                    &param_age.to_string());
            }
            if let Some(param_gender) = param_gender {
                query_string.append_pair("gender",
                    &param_gender);
            }
            if let Some(param_game_experience_level) = param_game_experience_level {
                query_string.append_pair("gameExperienceLevel",
                    &param_game_experience_level);
            }
            if let Some(param_latitude) = param_latitude {
                query_string.append_pair("latitude",
                    &param_latitude.to_string());
            }
            if let Some(param_longitude) = param_longitude {
                query_string.append_pair("longitude",
                    &param_longitude.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::PreviewPersonaResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(CreatePersonaResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn delete_persona(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_persona_id: i64,
        context: &C) -> Result<DeletePersonaResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/persona/delete",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("personaId",
                    &param_persona_id.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(DeletePersonaResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_persona_list(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_persona_id: i64,
        context: &C) -> Result<GetPersonaListResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/persona/get",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("personaId",
                    &param_persona_id.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::PreviewPersonaResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetPersonaListResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn search_persona(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_start: i32,
        param_limit: i32,
        context: &C) -> Result<SearchPersonaResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/persona/search",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("start",
                    &param_start.to_string());
                query_string.append_pair("limit",
                    &param_limit.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::PreviewPersonaResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(SearchPersonaResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn update_persona(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_persona_id: i64,
        param_title: Option<String>,
        param_preview_accounts: Option<String>,
        param_active: Option<bool>,
        param_date: Option<i64>,
        param_age: Option<i32>,
        param_gender: Option<String>,
        param_game_experience_level: Option<String>,
        param_latitude: Option<f64>,
        param_longitude: Option<f64>,
        context: &C) -> Result<UpdatePersonaResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/persona/update",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("personaId",
                    &param_persona_id.to_string());
            if let Some(param_title) = param_title {
                query_string.append_pair("title",
                    &param_title);
            }
            if let Some(param_preview_accounts) = param_preview_accounts {
                query_string.append_pair("previewAccounts",
                    &param_preview_accounts);
            }
            if let Some(param_active) = param_active {
                query_string.append_pair("active",
                    &param_active.to_string());
            }
            if let Some(param_date) = param_date {
                query_string.append_pair("date",
                    &param_date.to_string());
            }
            if let Some(param_age) = param_age {
                query_string.append_pair("age",
                    &param_age.to_string());
            }
            if let Some(param_gender) = param_gender {
                query_string.append_pair("gender",
                    &param_gender);
            }
            if let Some(param_game_experience_level) = param_game_experience_level {
                query_string.append_pair("gameExperienceLevel",
                    &param_game_experience_level);
            }
            if let Some(param_latitude) = param_latitude {
                query_string.append_pair("latitude",
                    &param_latitude.to_string());
            }
            if let Some(param_longitude) = param_longitude {
                query_string.append_pair("longitude",
                    &param_longitude.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::PreviewPersonaResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(UpdatePersonaResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn create_program(
        &self,
        param_version: f64,
        param_body: Option<models::Program>,
        context: &C) -> Result<CreateProgramResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/program",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        // Consumes basic body
        // Body parameter
        if let Some(param_body) = param_body {
        let body = serde_json::to_string(&param_body).expect("impossible to fail to serialize");
        *request.body_mut() = body_from_string(body);
        }

        let header = "application/json";
        request.headers_mut().insert(CONTENT_TYPE, HeaderValue::from_static(header));

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::Program>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(CreateProgramResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn search_programs(
        &self,
        param_version: f64,
        param_sort_field: String,
        param_descending: bool,
        param_start: i32,
        param_limit: i32,
        param_active_only: bool,
        param_keyword: Option<String>,
        context: &C) -> Result<SearchProgramsResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/program",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_keyword) = param_keyword {
                query_string.append_pair("keyword",
                    &param_keyword);
            }
                query_string.append_pair("sortField",
                    &param_sort_field);
                query_string.append_pair("descending",
                    &param_descending.to_string());
                query_string.append_pair("start",
                    &param_start.to_string());
                query_string.append_pair("limit",
                    &param_limit.to_string());
                query_string.append_pair("activeOnly",
                    &param_active_only.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<Vec<models::Program>>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(SearchProgramsResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn delete_program(
        &self,
        param_version: f64,
        param_id: i64,
        context: &C) -> Result<DeleteProgramResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/program/{id}",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
            ,id=utf8_percent_encode(&param_id.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("DELETE")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            0 => {
                Ok(
                    DeleteProgramResponse::SuccessfulOperation
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_program(
        &self,
        param_version: f64,
        param_id: i64,
        context: &C) -> Result<GetProgramResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/program/{id}",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
            ,id=utf8_percent_encode(&param_id.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::Program>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetProgramResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn post_program(
        &self,
        param_version: f64,
        param_id: i64,
        param_body: Option<models::Program>,
        context: &C) -> Result<PostProgramResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/program/{id}",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
            ,id=utf8_percent_encode(&param_id.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        // Consumes basic body
        // Body parameter
        if let Some(param_body) = param_body {
        let body = serde_json::to_string(&param_body).expect("impossible to fail to serialize");
        *request.body_mut() = body_from_string(body);
        }

        let header = "application/json";
        request.headers_mut().insert(CONTENT_TYPE, HeaderValue::from_static(header));

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::Program>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(PostProgramResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn put_program(
        &self,
        param_version: f64,
        param_id: i64,
        param_body: Option<models::Program>,
        context: &C) -> Result<PutProgramResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/program/{id}",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
            ,id=utf8_percent_encode(&param_id.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("PUT")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        // Consumes basic body
        // Body parameter
        if let Some(param_body) = param_body {
        let body = serde_json::to_string(&param_body).expect("impossible to fail to serialize");
        *request.body_mut() = body_from_string(body);
        }

        let header = "application/json";
        request.headers_mut().insert(CONTENT_TYPE, HeaderValue::from_static(header));

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::Program>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(PutProgramResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn create_purchase_item(
        &self,
        param_version: f64,
        param_app_key: String,
        param_name: String,
        param_purchase_type: models::CreatePurchaseItemPurchaseTypeParameter,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_description: Option<String>,
        param_tickets: Option<i32>,
        param_price: Option<f32>,
        param_purchase_code: Option<String>,
        param_secret_key: Option<String>,
        param_purchase_limit: Option<i32>,
        param_service_action: Option<models::CreatePurchaseItemServiceActionParameter>,
        param_cover_asset_id: Option<i64>,
        param_promo_asset_id: Option<i64>,
        param_giftable: Option<bool>,
        param_assetable: Option<bool>,
        param_allocate_tickets: Option<bool>,
        param_ticket_type: Option<String>,
        param_points: Option<i64>,
        param_offer_location_id: Option<i64>,
        context: &C) -> Result<CreatePurchaseItemResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/purchase/create",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
                query_string.append_pair("appKey",
                    &param_app_key);
                query_string.append_pair("name",
                    &param_name);
            if let Some(param_description) = param_description {
                query_string.append_pair("description",
                    &param_description);
            }
            if let Some(param_tickets) = param_tickets {
                query_string.append_pair("tickets",
                    &param_tickets.to_string());
            }
            if let Some(param_price) = param_price {
                query_string.append_pair("price",
                    &param_price.to_string());
            }
                query_string.append_pair("purchaseType",
                    &param_purchase_type.to_string());
            if let Some(param_purchase_code) = param_purchase_code {
                query_string.append_pair("purchaseCode",
                    &param_purchase_code);
            }
            if let Some(param_secret_key) = param_secret_key {
                query_string.append_pair("secretKey",
                    &param_secret_key);
            }
            if let Some(param_purchase_limit) = param_purchase_limit {
                query_string.append_pair("purchaseLimit",
                    &param_purchase_limit.to_string());
            }
            if let Some(param_service_action) = param_service_action {
                query_string.append_pair("serviceAction",
                    &param_service_action.to_string());
            }
            if let Some(param_cover_asset_id) = param_cover_asset_id {
                query_string.append_pair("coverAssetId",
                    &param_cover_asset_id.to_string());
            }
            if let Some(param_promo_asset_id) = param_promo_asset_id {
                query_string.append_pair("promoAssetId",
                    &param_promo_asset_id.to_string());
            }
            if let Some(param_giftable) = param_giftable {
                query_string.append_pair("giftable",
                    &param_giftable.to_string());
            }
            if let Some(param_assetable) = param_assetable {
                query_string.append_pair("assetable",
                    &param_assetable.to_string());
            }
            if let Some(param_allocate_tickets) = param_allocate_tickets {
                query_string.append_pair("allocateTickets",
                    &param_allocate_tickets.to_string());
            }
            if let Some(param_ticket_type) = param_ticket_type {
                query_string.append_pair("ticketType",
                    &param_ticket_type);
            }
            if let Some(param_points) = param_points {
                query_string.append_pair("points",
                    &param_points.to_string());
            }
            if let Some(param_offer_location_id) = param_offer_location_id {
                query_string.append_pair("offerLocationId",
                    &param_offer_location_id.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::PurchaseItemFullResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(CreatePurchaseItemResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn delete_purchase_item(
        &self,
        param_version: f64,
        param_purchase_item_id: i64,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        context: &C) -> Result<DeletePurchaseItemResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/purchase/delete",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
                query_string.append_pair("purchaseItemId",
                    &param_purchase_item_id.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(DeletePurchaseItemResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_purchase_item(
        &self,
        param_version: f64,
        param_purchase_item_id: i64,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        context: &C) -> Result<GetPurchaseItemResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/purchase/get",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
                query_string.append_pair("purchaseItemId",
                    &param_purchase_item_id.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::PurchaseItemFullResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetPurchaseItemResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn search_purchase_items(
        &self,
        param_version: f64,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_app_key: Option<String>,
        param_filter_by_billable: Option<bool>,
        param_purchase_type: Option<String>,
        param_service_action: Option<String>,
        param_keyword: Option<String>,
        param_sort_field: Option<models::SearchPurchaseItemsSortFieldParameter>,
        param_descending: Option<bool>,
        param_start: Option<i32>,
        param_limit: Option<i32>,
        param_active_only: Option<bool>,
        context: &C) -> Result<SearchPurchaseItemsResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/purchase/search",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_app_key) = param_app_key {
                query_string.append_pair("appKey",
                    &param_app_key);
            }
            if let Some(param_filter_by_billable) = param_filter_by_billable {
                query_string.append_pair("filterByBillable",
                    &param_filter_by_billable.to_string());
            }
            if let Some(param_purchase_type) = param_purchase_type {
                query_string.append_pair("purchaseType",
                    &param_purchase_type);
            }
            if let Some(param_service_action) = param_service_action {
                query_string.append_pair("serviceAction",
                    &param_service_action);
            }
            if let Some(param_keyword) = param_keyword {
                query_string.append_pair("keyword",
                    &param_keyword);
            }
            if let Some(param_sort_field) = param_sort_field {
                query_string.append_pair("sortField",
                    &param_sort_field.to_string());
            }
            if let Some(param_descending) = param_descending {
                query_string.append_pair("descending",
                    &param_descending.to_string());
            }
            if let Some(param_start) = param_start {
                query_string.append_pair("start",
                    &param_start.to_string());
            }
            if let Some(param_limit) = param_limit {
                query_string.append_pair("limit",
                    &param_limit.to_string());
            }
            if let Some(param_active_only) = param_active_only {
                query_string.append_pair("activeOnly",
                    &param_active_only.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<Vec<models::PurchaseItemResponse>>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(SearchPurchaseItemsResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn update_purchase_item(
        &self,
        param_version: f64,
        param_purchase_item_id: i64,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_name: Option<String>,
        param_description: Option<String>,
        param_tickets: Option<i32>,
        param_price: Option<f32>,
        param_purchase_type: Option<models::CreatePurchaseItemPurchaseTypeParameter>,
        param_purchase_code: Option<String>,
        param_secret_key: Option<String>,
        param_purchase_limit: Option<i32>,
        param_service_action: Option<models::CreatePurchaseItemServiceActionParameter>,
        param_cover_asset_id: Option<i64>,
        param_promo_asset_id: Option<i64>,
        param_giftable: Option<bool>,
        param_assetable: Option<bool>,
        param_active: Option<bool>,
        param_allocate_tickets: Option<bool>,
        param_ticket_type: Option<String>,
        param_points: Option<i64>,
        param_offer_location_id: Option<i64>,
        context: &C) -> Result<UpdatePurchaseItemResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/purchase/update",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
                query_string.append_pair("purchaseItemId",
                    &param_purchase_item_id.to_string());
            if let Some(param_name) = param_name {
                query_string.append_pair("name",
                    &param_name);
            }
            if let Some(param_description) = param_description {
                query_string.append_pair("description",
                    &param_description);
            }
            if let Some(param_tickets) = param_tickets {
                query_string.append_pair("tickets",
                    &param_tickets.to_string());
            }
            if let Some(param_price) = param_price {
                query_string.append_pair("price",
                    &param_price.to_string());
            }
            if let Some(param_purchase_type) = param_purchase_type {
                query_string.append_pair("purchaseType",
                    &param_purchase_type.to_string());
            }
            if let Some(param_purchase_code) = param_purchase_code {
                query_string.append_pair("purchaseCode",
                    &param_purchase_code);
            }
            if let Some(param_secret_key) = param_secret_key {
                query_string.append_pair("secretKey",
                    &param_secret_key);
            }
            if let Some(param_purchase_limit) = param_purchase_limit {
                query_string.append_pair("purchaseLimit",
                    &param_purchase_limit.to_string());
            }
            if let Some(param_service_action) = param_service_action {
                query_string.append_pair("serviceAction",
                    &param_service_action.to_string());
            }
            if let Some(param_cover_asset_id) = param_cover_asset_id {
                query_string.append_pair("coverAssetId",
                    &param_cover_asset_id.to_string());
            }
            if let Some(param_promo_asset_id) = param_promo_asset_id {
                query_string.append_pair("promoAssetId",
                    &param_promo_asset_id.to_string());
            }
            if let Some(param_giftable) = param_giftable {
                query_string.append_pair("giftable",
                    &param_giftable.to_string());
            }
            if let Some(param_assetable) = param_assetable {
                query_string.append_pair("assetable",
                    &param_assetable.to_string());
            }
            if let Some(param_active) = param_active {
                query_string.append_pair("active",
                    &param_active.to_string());
            }
            if let Some(param_allocate_tickets) = param_allocate_tickets {
                query_string.append_pair("allocateTickets",
                    &param_allocate_tickets.to_string());
            }
            if let Some(param_ticket_type) = param_ticket_type {
                query_string.append_pair("ticketType",
                    &param_ticket_type);
            }
            if let Some(param_points) = param_points {
                query_string.append_pair("points",
                    &param_points.to_string());
            }
            if let Some(param_offer_location_id) = param_offer_location_id {
                query_string.append_pair("offerLocationId",
                    &param_offer_location_id.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::PurchaseItemFullResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(UpdatePurchaseItemResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn create_order(
        &self,
        param_version: f64,
        param_app_key: String,
        param_cart: String,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_description: Option<String>,
        param_currency_type: Option<models::CreateOrderCurrencyTypeParameter>,
        param_payment_method_id: Option<i64>,
        param_external_order_id: Option<String>,
        param_external_payment_id: Option<String>,
        param_remote_ref_type: Option<String>,
        param_external_date: Option<i64>,
        param_promo_code: Option<String>,
        context: &C) -> Result<CreateOrderResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/order/create",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
                query_string.append_pair("appKey",
                    &param_app_key);
            if let Some(param_description) = param_description {
                query_string.append_pair("description",
                    &param_description);
            }
            if let Some(param_currency_type) = param_currency_type {
                query_string.append_pair("currencyType",
                    &param_currency_type.to_string());
            }
                query_string.append_pair("cart",
                    &param_cart);
            if let Some(param_payment_method_id) = param_payment_method_id {
                query_string.append_pair("paymentMethodId",
                    &param_payment_method_id.to_string());
            }
            if let Some(param_external_order_id) = param_external_order_id {
                query_string.append_pair("externalOrderId",
                    &param_external_order_id);
            }
            if let Some(param_external_payment_id) = param_external_payment_id {
                query_string.append_pair("externalPaymentId",
                    &param_external_payment_id);
            }
            if let Some(param_remote_ref_type) = param_remote_ref_type {
                query_string.append_pair("remoteRefType",
                    &param_remote_ref_type);
            }
            if let Some(param_external_date) = param_external_date {
                query_string.append_pair("externalDate",
                    &param_external_date.to_string());
            }
            if let Some(param_promo_code) = param_promo_code {
                query_string.append_pair("promoCode",
                    &param_promo_code);
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::OrderResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(CreateOrderResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn delete_order(
        &self,
        param_version: f64,
        param_order_id: i64,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        context: &C) -> Result<DeleteOrderResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/order/delete",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
                query_string.append_pair("orderId",
                    &param_order_id.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(DeleteOrderResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_order(
        &self,
        param_version: f64,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_order_id: Option<i64>,
        param_external_order_id: Option<String>,
        context: &C) -> Result<GetOrderResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/order/get",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_order_id) = param_order_id {
                query_string.append_pair("orderId",
                    &param_order_id.to_string());
            }
            if let Some(param_external_order_id) = param_external_order_id {
                query_string.append_pair("externalOrderId",
                    &param_external_order_id);
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::OrderResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetOrderResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn preview_order(
        &self,
        param_version: f64,
        param_app_key: String,
        param_cart: String,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_description: Option<String>,
        param_currency_type: Option<models::CreateOrderCurrencyTypeParameter>,
        param_payment_method_id: Option<i64>,
        param_external_order_id: Option<String>,
        param_external_payment_id: Option<String>,
        param_remote_ref_type: Option<String>,
        param_external_date: Option<i64>,
        param_promo_code: Option<String>,
        context: &C) -> Result<PreviewOrderResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/order/preview",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
                query_string.append_pair("appKey",
                    &param_app_key);
            if let Some(param_description) = param_description {
                query_string.append_pair("description",
                    &param_description);
            }
            if let Some(param_currency_type) = param_currency_type {
                query_string.append_pair("currencyType",
                    &param_currency_type.to_string());
            }
                query_string.append_pair("cart",
                    &param_cart);
            if let Some(param_payment_method_id) = param_payment_method_id {
                query_string.append_pair("paymentMethodId",
                    &param_payment_method_id.to_string());
            }
            if let Some(param_external_order_id) = param_external_order_id {
                query_string.append_pair("externalOrderId",
                    &param_external_order_id);
            }
            if let Some(param_external_payment_id) = param_external_payment_id {
                query_string.append_pair("externalPaymentId",
                    &param_external_payment_id);
            }
            if let Some(param_remote_ref_type) = param_remote_ref_type {
                query_string.append_pair("remoteRefType",
                    &param_remote_ref_type);
            }
            if let Some(param_external_date) = param_external_date {
                query_string.append_pair("externalDate",
                    &param_external_date.to_string());
            }
            if let Some(param_promo_code) = param_promo_code {
                query_string.append_pair("promoCode",
                    &param_promo_code);
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::OrderResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(PreviewOrderResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn search_orders(
        &self,
        param_version: f64,
        param_app_key: String,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_start: Option<i32>,
        param_limit: Option<i32>,
        param_descending: Option<bool>,
        param_active_only: Option<bool>,
        param_ignore_customer_filter: Option<bool>,
        param_order_item_types: Option<String>,
        param_order_item_ids: Option<String>,
        param_order_custom_types: Option<String>,
        param_order_custom_ids: Option<String>,
        param_sort_field: Option<String>,
        param_offer_types: Option<String>,
        param_special_offer_types: Option<String>,
        param_category_ids: Option<String>,
        param_filter_ids: Option<String>,
        param_offer_audience_ids: Option<String>,
        param_transaction_audience_ids: Option<String>,
        param_offer_ids: Option<String>,
        param_offer_location_ids: Option<String>,
        param_retailer_ids: Option<String>,
        param_retailer_location_ids: Option<String>,
        param_statuses: Option<String>,
        param_keyword: Option<String>,
        param_redeemable_start_date: Option<i64>,
        param_redeemable_end_date: Option<i64>,
        param_started_since: Option<i64>,
        param_started_before: Option<i64>,
        param_ended_since: Option<i64>,
        param_ended_before: Option<i64>,
        context: &C) -> Result<SearchOrdersResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/order/search",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
                query_string.append_pair("appKey",
                    &param_app_key);
            if let Some(param_start) = param_start {
                query_string.append_pair("start",
                    &param_start.to_string());
            }
            if let Some(param_limit) = param_limit {
                query_string.append_pair("limit",
                    &param_limit.to_string());
            }
            if let Some(param_descending) = param_descending {
                query_string.append_pair("descending",
                    &param_descending.to_string());
            }
            if let Some(param_active_only) = param_active_only {
                query_string.append_pair("activeOnly",
                    &param_active_only.to_string());
            }
            if let Some(param_ignore_customer_filter) = param_ignore_customer_filter {
                query_string.append_pair("ignoreCustomerFilter",
                    &param_ignore_customer_filter.to_string());
            }
            if let Some(param_order_item_types) = param_order_item_types {
                query_string.append_pair("orderItemTypes",
                    &param_order_item_types);
            }
            if let Some(param_order_item_ids) = param_order_item_ids {
                query_string.append_pair("orderItemIds",
                    &param_order_item_ids);
            }
            if let Some(param_order_custom_types) = param_order_custom_types {
                query_string.append_pair("orderCustomTypes",
                    &param_order_custom_types);
            }
            if let Some(param_order_custom_ids) = param_order_custom_ids {
                query_string.append_pair("orderCustomIds",
                    &param_order_custom_ids);
            }
            if let Some(param_sort_field) = param_sort_field {
                query_string.append_pair("sortField",
                    &param_sort_field);
            }
            if let Some(param_offer_types) = param_offer_types {
                query_string.append_pair("offerTypes",
                    &param_offer_types);
            }
            if let Some(param_special_offer_types) = param_special_offer_types {
                query_string.append_pair("specialOfferTypes",
                    &param_special_offer_types);
            }
            if let Some(param_category_ids) = param_category_ids {
                query_string.append_pair("categoryIds",
                    &param_category_ids);
            }
            if let Some(param_filter_ids) = param_filter_ids {
                query_string.append_pair("filterIds",
                    &param_filter_ids);
            }
            if let Some(param_offer_audience_ids) = param_offer_audience_ids {
                query_string.append_pair("offerAudienceIds",
                    &param_offer_audience_ids);
            }
            if let Some(param_transaction_audience_ids) = param_transaction_audience_ids {
                query_string.append_pair("transactionAudienceIds",
                    &param_transaction_audience_ids);
            }
            if let Some(param_offer_ids) = param_offer_ids {
                query_string.append_pair("offerIds",
                    &param_offer_ids);
            }
            if let Some(param_offer_location_ids) = param_offer_location_ids {
                query_string.append_pair("offerLocationIds",
                    &param_offer_location_ids);
            }
            if let Some(param_retailer_ids) = param_retailer_ids {
                query_string.append_pair("retailerIds",
                    &param_retailer_ids);
            }
            if let Some(param_retailer_location_ids) = param_retailer_location_ids {
                query_string.append_pair("retailerLocationIds",
                    &param_retailer_location_ids);
            }
            if let Some(param_statuses) = param_statuses {
                query_string.append_pair("statuses",
                    &param_statuses);
            }
            if let Some(param_keyword) = param_keyword {
                query_string.append_pair("keyword",
                    &param_keyword);
            }
            if let Some(param_redeemable_start_date) = param_redeemable_start_date {
                query_string.append_pair("redeemableStartDate",
                    &param_redeemable_start_date.to_string());
            }
            if let Some(param_redeemable_end_date) = param_redeemable_end_date {
                query_string.append_pair("redeemableEndDate",
                    &param_redeemable_end_date.to_string());
            }
            if let Some(param_started_since) = param_started_since {
                query_string.append_pair("startedSince",
                    &param_started_since.to_string());
            }
            if let Some(param_started_before) = param_started_before {
                query_string.append_pair("startedBefore",
                    &param_started_before.to_string());
            }
            if let Some(param_ended_since) = param_ended_since {
                query_string.append_pair("endedSince",
                    &param_ended_since.to_string());
            }
            if let Some(param_ended_before) = param_ended_before {
                query_string.append_pair("endedBefore",
                    &param_ended_before.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<Vec<models::OrderResponse>>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(SearchOrdersResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn update_order(
        &self,
        param_version: f64,
        param_order_id: i64,
        param_app_key: String,
        param_cart: String,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_payment_transaction_id: Option<i64>,
        param_description: Option<String>,
        param_currency_type: Option<models::CreateOrderCurrencyTypeParameter>,
        param_payment_method_id: Option<i64>,
        param_external_payment_id: Option<String>,
        param_external_date: Option<i64>,
        context: &C) -> Result<UpdateOrderResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/order/update",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
                query_string.append_pair("orderId",
                    &param_order_id.to_string());
            if let Some(param_payment_transaction_id) = param_payment_transaction_id {
                query_string.append_pair("paymentTransactionId",
                    &param_payment_transaction_id.to_string());
            }
                query_string.append_pair("appKey",
                    &param_app_key);
            if let Some(param_description) = param_description {
                query_string.append_pair("description",
                    &param_description);
            }
            if let Some(param_currency_type) = param_currency_type {
                query_string.append_pair("currencyType",
                    &param_currency_type.to_string());
            }
                query_string.append_pair("cart",
                    &param_cart);
            if let Some(param_payment_method_id) = param_payment_method_id {
                query_string.append_pair("paymentMethodId",
                    &param_payment_method_id.to_string());
            }
            if let Some(param_external_payment_id) = param_external_payment_id {
                query_string.append_pair("externalPaymentId",
                    &param_external_payment_id);
            }
            if let Some(param_external_date) = param_external_date {
                query_string.append_pair("externalDate",
                    &param_external_date.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::OrderResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(UpdateOrderResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn create_question(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_question: String,
        param_answers: String,
        param_active: bool,
        param_allocate_tickets: bool,
        param_ticket_count: i64,
        param_tags: Option<String>,
        param_video_url: Option<String>,
        param_asset_id: Option<i64>,
        param_ticket_type: Option<String>,
        param_points: Option<i64>,
        context: &C) -> Result<CreateQuestionResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/game/question/create",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("question",
                    &param_question);
                query_string.append_pair("answers",
                    &param_answers);
            if let Some(param_tags) = param_tags {
                query_string.append_pair("tags",
                    &param_tags);
            }
            if let Some(param_video_url) = param_video_url {
                query_string.append_pair("videoURL",
                    &param_video_url);
            }
            if let Some(param_asset_id) = param_asset_id {
                query_string.append_pair("assetId",
                    &param_asset_id.to_string());
            }
                query_string.append_pair("active",
                    &param_active.to_string());
                query_string.append_pair("allocateTickets",
                    &param_allocate_tickets.to_string());
                query_string.append_pair("ticketCount",
                    &param_ticket_count.to_string());
            if let Some(param_ticket_type) = param_ticket_type {
                query_string.append_pair("ticketType",
                    &param_ticket_type);
            }
            if let Some(param_points) = param_points {
                query_string.append_pair("points",
                    &param_points.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::QuestionResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(CreateQuestionResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn delete_question(
        &self,
        param_version: f64,
        param_question_id: i64,
        param_account_id: i64,
        context: &C) -> Result<DeleteQuestionResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/game/question/delete",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("questionId",
                    &param_question_id.to_string());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(DeleteQuestionResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_question(
        &self,
        param_version: f64,
        param_question_id: i64,
        param_account_id: i64,
        context: &C) -> Result<GetQuestionResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/game/question/get",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("questionId",
                    &param_question_id.to_string());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::QuestionResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetQuestionResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn search_questions(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_sort_field: String,
        param_descending: bool,
        param_active_only: bool,
        param_start: i32,
        param_limit: i32,
        param_keyword: Option<String>,
        context: &C) -> Result<SearchQuestionsResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/game/question/search",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            if let Some(param_keyword) = param_keyword {
                query_string.append_pair("keyword",
                    &param_keyword);
            }
                query_string.append_pair("sortField",
                    &param_sort_field);
                query_string.append_pair("descending",
                    &param_descending.to_string());
                query_string.append_pair("activeOnly",
                    &param_active_only.to_string());
                query_string.append_pair("start",
                    &param_start.to_string());
                query_string.append_pair("limit",
                    &param_limit.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<Vec<models::QuestionResponse>>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(SearchQuestionsResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn update_question(
        &self,
        param_version: f64,
        param_question_id: i64,
        param_account_id: i64,
        param_ticket_count: i64,
        param_question: Option<String>,
        param_answers: Option<String>,
        param_tags: Option<String>,
        param_video_url: Option<String>,
        param_asset_id: Option<i64>,
        param_active: Option<bool>,
        param_allocate_tickets: Option<bool>,
        param_ticket_type: Option<String>,
        param_points: Option<i64>,
        context: &C) -> Result<UpdateQuestionResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/game/question/update",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("questionId",
                    &param_question_id.to_string());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            if let Some(param_question) = param_question {
                query_string.append_pair("question",
                    &param_question);
            }
            if let Some(param_answers) = param_answers {
                query_string.append_pair("answers",
                    &param_answers);
            }
            if let Some(param_tags) = param_tags {
                query_string.append_pair("tags",
                    &param_tags);
            }
            if let Some(param_video_url) = param_video_url {
                query_string.append_pair("videoURL",
                    &param_video_url);
            }
            if let Some(param_asset_id) = param_asset_id {
                query_string.append_pair("assetId",
                    &param_asset_id.to_string());
            }
            if let Some(param_active) = param_active {
                query_string.append_pair("active",
                    &param_active.to_string());
            }
            if let Some(param_allocate_tickets) = param_allocate_tickets {
                query_string.append_pair("allocateTickets",
                    &param_allocate_tickets.to_string());
            }
                query_string.append_pair("ticketCount",
                    &param_ticket_count.to_string());
            if let Some(param_ticket_type) = param_ticket_type {
                query_string.append_pair("ticketType",
                    &param_ticket_type);
            }
            if let Some(param_points) = param_points {
                query_string.append_pair("points",
                    &param_points.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::QuestionResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(UpdateQuestionResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_historical_rankings(
        &self,
        param_version: f64,
        param_app_key: String,
        param_rank_type: String,
        param_start_date: i64,
        param_end_date: i64,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_sort_field: Option<String>,
        param_descending: Option<bool>,
        param_start: Option<i32>,
        param_limit: Option<i32>,
        context: &C) -> Result<GetHistoricalRankingsResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/ranking/historical/search",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
                query_string.append_pair("appKey",
                    &param_app_key);
                query_string.append_pair("rankType",
                    &param_rank_type);
                query_string.append_pair("startDate",
                    &param_start_date.to_string());
                query_string.append_pair("endDate",
                    &param_end_date.to_string());
            if let Some(param_sort_field) = param_sort_field {
                query_string.append_pair("sortField",
                    &param_sort_field);
            }
            if let Some(param_descending) = param_descending {
                query_string.append_pair("descending",
                    &param_descending.to_string());
            }
            if let Some(param_start) = param_start {
                query_string.append_pair("start",
                    &param_start.to_string());
            }
            if let Some(param_limit) = param_limit {
                query_string.append_pair("limit",
                    &param_limit.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::RankFullResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetHistoricalRankingsResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_rankings(
        &self,
        param_version: f64,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_game_type: Option<String>,
        param_app_key: Option<String>,
        param_q: Option<String>,
        param_keyword: Option<String>,
        param_rank_type: Option<String>,
        param_leaderboard_mode: Option<String>,
        param_within_account_ids: Option<String>,
        param_return_user_rank: Option<bool>,
        param_album_id: Option<i64>,
        param_audience_id: Option<i64>,
        param_sort_field: Option<String>,
        param_descending: Option<bool>,
        param__i: Option<i32>,
        param_start: Option<i32>,
        param__l: Option<i32>,
        param_limit: Option<i32>,
        context: &C) -> Result<GetRankingsResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/ranking/search",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_game_type) = param_game_type {
                query_string.append_pair("gameType",
                    &param_game_type);
            }
            if let Some(param_app_key) = param_app_key {
                query_string.append_pair("appKey",
                    &param_app_key);
            }
            if let Some(param_q) = param_q {
                query_string.append_pair("q",
                    &param_q);
            }
            if let Some(param_keyword) = param_keyword {
                query_string.append_pair("keyword",
                    &param_keyword);
            }
            if let Some(param_rank_type) = param_rank_type {
                query_string.append_pair("rankType",
                    &param_rank_type);
            }
            if let Some(param_leaderboard_mode) = param_leaderboard_mode {
                query_string.append_pair("leaderboardMode",
                    &param_leaderboard_mode);
            }
            if let Some(param_within_account_ids) = param_within_account_ids {
                query_string.append_pair("withinAccountIds",
                    &param_within_account_ids);
            }
            if let Some(param_return_user_rank) = param_return_user_rank {
                query_string.append_pair("returnUserRank",
                    &param_return_user_rank.to_string());
            }
            if let Some(param_album_id) = param_album_id {
                query_string.append_pair("albumId",
                    &param_album_id.to_string());
            }
            if let Some(param_audience_id) = param_audience_id {
                query_string.append_pair("audienceId",
                    &param_audience_id.to_string());
            }
            if let Some(param_sort_field) = param_sort_field {
                query_string.append_pair("sortField",
                    &param_sort_field);
            }
            if let Some(param_descending) = param_descending {
                query_string.append_pair("descending",
                    &param_descending.to_string());
            }
            if let Some(param__i) = param__i {
                query_string.append_pair("_i",
                    &param__i.to_string());
            }
            if let Some(param_start) = param_start {
                query_string.append_pair("start",
                    &param_start.to_string());
            }
            if let Some(param__l) = param__l {
                query_string.append_pair("_l",
                    &param__l.to_string());
            }
            if let Some(param_limit) = param_limit {
                query_string.append_pair("limit",
                    &param_limit.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::RankFullResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetRankingsResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_user_rank(
        &self,
        param_version: f64,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_app_key: Option<String>,
        param_rank_type: Option<String>,
        param_return_user_rank: Option<bool>,
        param_leaderboard_mode: Option<String>,
        param_sort_field: Option<String>,
        param_keyword: Option<String>,
        param_descending: Option<bool>,
        param_start: Option<i32>,
        param_limit: Option<i32>,
        context: &C) -> Result<GetUserRankResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/ranking/personal/ranks",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_app_key) = param_app_key {
                query_string.append_pair("appKey",
                    &param_app_key);
            }
            if let Some(param_rank_type) = param_rank_type {
                query_string.append_pair("rankType",
                    &param_rank_type);
            }
            if let Some(param_return_user_rank) = param_return_user_rank {
                query_string.append_pair("returnUserRank",
                    &param_return_user_rank.to_string());
            }
            if let Some(param_leaderboard_mode) = param_leaderboard_mode {
                query_string.append_pair("leaderboardMode",
                    &param_leaderboard_mode);
            }
            if let Some(param_sort_field) = param_sort_field {
                query_string.append_pair("sortField",
                    &param_sort_field);
            }
            if let Some(param_keyword) = param_keyword {
                query_string.append_pair("keyword",
                    &param_keyword);
            }
            if let Some(param_descending) = param_descending {
                query_string.append_pair("descending",
                    &param_descending.to_string());
            }
            if let Some(param_start) = param_start {
                query_string.append_pair("start",
                    &param_start.to_string());
            }
            if let Some(param_limit) = param_limit {
                query_string.append_pair("limit",
                    &param_limit.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<serde_json::Value>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetUserRankResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn override_user_rank(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_owner_account_id: i64,
        param_app_key: String,
        param_rank_type: String,
        param_total_score: Option<i64>,
        param_total_count: Option<i64>,
        param_total_time: Option<i64>,
        param_daily_score: Option<i64>,
        param_daily_count: Option<i64>,
        param_daily_time: Option<i64>,
        param_weekly_score: Option<i64>,
        param_weekly_count: Option<i64>,
        param_weekly_time: Option<i64>,
        param_monthly_score: Option<i64>,
        param_monthly_count: Option<i64>,
        param_monthly_time: Option<i64>,
        param_top_score: Option<i64>,
        param_lowest_score: Option<i64>,
        param_streak_count: Option<i64>,
        param_streak_best_count: Option<i64>,
        param_start_date: Option<i64>,
        param_end_date: Option<i64>,
        context: &C) -> Result<OverrideUserRankResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/ranking/override",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("ownerAccountId",
                    &param_owner_account_id.to_string());
                query_string.append_pair("appKey",
                    &param_app_key);
                query_string.append_pair("rankType",
                    &param_rank_type);
            if let Some(param_total_score) = param_total_score {
                query_string.append_pair("totalScore",
                    &param_total_score.to_string());
            }
            if let Some(param_total_count) = param_total_count {
                query_string.append_pair("totalCount",
                    &param_total_count.to_string());
            }
            if let Some(param_total_time) = param_total_time {
                query_string.append_pair("totalTime",
                    &param_total_time.to_string());
            }
            if let Some(param_daily_score) = param_daily_score {
                query_string.append_pair("dailyScore",
                    &param_daily_score.to_string());
            }
            if let Some(param_daily_count) = param_daily_count {
                query_string.append_pair("dailyCount",
                    &param_daily_count.to_string());
            }
            if let Some(param_daily_time) = param_daily_time {
                query_string.append_pair("dailyTime",
                    &param_daily_time.to_string());
            }
            if let Some(param_weekly_score) = param_weekly_score {
                query_string.append_pair("weeklyScore",
                    &param_weekly_score.to_string());
            }
            if let Some(param_weekly_count) = param_weekly_count {
                query_string.append_pair("weeklyCount",
                    &param_weekly_count.to_string());
            }
            if let Some(param_weekly_time) = param_weekly_time {
                query_string.append_pair("weeklyTime",
                    &param_weekly_time.to_string());
            }
            if let Some(param_monthly_score) = param_monthly_score {
                query_string.append_pair("monthlyScore",
                    &param_monthly_score.to_string());
            }
            if let Some(param_monthly_count) = param_monthly_count {
                query_string.append_pair("monthlyCount",
                    &param_monthly_count.to_string());
            }
            if let Some(param_monthly_time) = param_monthly_time {
                query_string.append_pair("monthlyTime",
                    &param_monthly_time.to_string());
            }
            if let Some(param_top_score) = param_top_score {
                query_string.append_pair("topScore",
                    &param_top_score.to_string());
            }
            if let Some(param_lowest_score) = param_lowest_score {
                query_string.append_pair("lowestScore",
                    &param_lowest_score.to_string());
            }
            if let Some(param_streak_count) = param_streak_count {
                query_string.append_pair("streakCount",
                    &param_streak_count.to_string());
            }
            if let Some(param_streak_best_count) = param_streak_best_count {
                query_string.append_pair("streakBestCount",
                    &param_streak_best_count.to_string());
            }
            if let Some(param_start_date) = param_start_date {
                query_string.append_pair("startDate",
                    &param_start_date.to_string());
            }
            if let Some(param_end_date) = param_end_date {
                query_string.append_pair("endDate",
                    &param_end_date.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(OverrideUserRankResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn update_rankings(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_app_key: String,
        param_rank_type: String,
        param_increment: Option<i64>,
        param_time_increment: Option<i64>,
        param_tag: Option<String>,
        param_start_date: Option<i64>,
        param_end_date: Option<i64>,
        param_update_global: Option<bool>,
        param_create_leaderboard: Option<bool>,
        context: &C) -> Result<UpdateRankingsResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/ranking/update",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("appKey",
                    &param_app_key);
                query_string.append_pair("rankType",
                    &param_rank_type);
            if let Some(param_increment) = param_increment {
                query_string.append_pair("increment",
                    &param_increment.to_string());
            }
            if let Some(param_time_increment) = param_time_increment {
                query_string.append_pair("timeIncrement",
                    &param_time_increment.to_string());
            }
            if let Some(param_tag) = param_tag {
                query_string.append_pair("tag",
                    &param_tag);
            }
            if let Some(param_start_date) = param_start_date {
                query_string.append_pair("startDate",
                    &param_start_date.to_string());
            }
            if let Some(param_end_date) = param_end_date {
                query_string.append_pair("endDate",
                    &param_end_date.to_string());
            }
            if let Some(param_update_global) = param_update_global {
                query_string.append_pair("updateGlobal",
                    &param_update_global.to_string());
            }
            if let Some(param_create_leaderboard) = param_create_leaderboard {
                query_string.append_pair("createLeaderboard",
                    &param_create_leaderboard.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(UpdateRankingsResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn create_rating(
        &self,
        param_version: f64,
        param_ratable_type: String,
        param_ratable_id: i64,
        param_rating_value: i32,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_category_id: Option<i64>,
        param_display: Option<String>,
        param_description: Option<String>,
        param_location_description: Option<String>,
        param_latitude: Option<f64>,
        param_longitude: Option<f64>,
        context: &C) -> Result<CreateRatingResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/rating/create",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
                query_string.append_pair("ratableType",
                    &param_ratable_type);
                query_string.append_pair("ratableId",
                    &param_ratable_id.to_string());
                query_string.append_pair("ratingValue",
                    &param_rating_value.to_string());
            if let Some(param_category_id) = param_category_id {
                query_string.append_pair("categoryId",
                    &param_category_id.to_string());
            }
            if let Some(param_display) = param_display {
                query_string.append_pair("display",
                    &param_display);
            }
            if let Some(param_description) = param_description {
                query_string.append_pair("description",
                    &param_description);
            }
            if let Some(param_location_description) = param_location_description {
                query_string.append_pair("locationDescription",
                    &param_location_description);
            }
            if let Some(param_latitude) = param_latitude {
                query_string.append_pair("latitude",
                    &param_latitude.to_string());
            }
            if let Some(param_longitude) = param_longitude {
                query_string.append_pair("longitude",
                    &param_longitude.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::RatingResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(CreateRatingResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn delete_rating(
        &self,
        param_version: f64,
        param_rating_id: i64,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        context: &C) -> Result<DeleteRatingResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/rating/delete",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
                query_string.append_pair("ratingId",
                    &param_rating_id.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(DeleteRatingResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn search_location_rating_indexes(
        &self,
        param_version: f64,
        param_category_ids: Option<String>,
        param_keyword: Option<String>,
        param_location_type: Option<String>,
        param_sort_field: Option<models::SearchRatingIndexesSortFieldParameter>,
        param_descending: Option<bool>,
        param_start: Option<i32>,
        param_limit: Option<i32>,
        param_search_range: Option<f64>,
        param_latitude: Option<f64>,
        param_longitude: Option<f64>,
        param_return_overall_rating: Option<bool>,
        param_distance_unit: Option<models::SearchOffersForConsumerDistanceUnitParameter>,
        param_return_retailer: Option<bool>,
        param_return_assets: Option<bool>,
        param_return_offers: Option<bool>,
        param_return_categories: Option<bool>,
        param_return_filters: Option<bool>,
        context: &C) -> Result<SearchLocationRatingIndexesResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/location/rating/index/search",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_category_ids) = param_category_ids {
                query_string.append_pair("categoryIds",
                    &param_category_ids);
            }
            if let Some(param_keyword) = param_keyword {
                query_string.append_pair("keyword",
                    &param_keyword);
            }
            if let Some(param_location_type) = param_location_type {
                query_string.append_pair("locationType",
                    &param_location_type);
            }
            if let Some(param_sort_field) = param_sort_field {
                query_string.append_pair("sortField",
                    &param_sort_field.to_string());
            }
            if let Some(param_descending) = param_descending {
                query_string.append_pair("descending",
                    &param_descending.to_string());
            }
            if let Some(param_start) = param_start {
                query_string.append_pair("start",
                    &param_start.to_string());
            }
            if let Some(param_limit) = param_limit {
                query_string.append_pair("limit",
                    &param_limit.to_string());
            }
            if let Some(param_search_range) = param_search_range {
                query_string.append_pair("searchRange",
                    &param_search_range.to_string());
            }
            if let Some(param_latitude) = param_latitude {
                query_string.append_pair("latitude",
                    &param_latitude.to_string());
            }
            if let Some(param_longitude) = param_longitude {
                query_string.append_pair("longitude",
                    &param_longitude.to_string());
            }
            if let Some(param_return_overall_rating) = param_return_overall_rating {
                query_string.append_pair("returnOverallRating",
                    &param_return_overall_rating.to_string());
            }
            if let Some(param_distance_unit) = param_distance_unit {
                query_string.append_pair("distanceUnit",
                    &param_distance_unit.to_string());
            }
            if let Some(param_return_retailer) = param_return_retailer {
                query_string.append_pair("returnRetailer",
                    &param_return_retailer.to_string());
            }
            if let Some(param_return_assets) = param_return_assets {
                query_string.append_pair("returnAssets",
                    &param_return_assets.to_string());
            }
            if let Some(param_return_offers) = param_return_offers {
                query_string.append_pair("returnOffers",
                    &param_return_offers.to_string());
            }
            if let Some(param_return_categories) = param_return_categories {
                query_string.append_pair("returnCategories",
                    &param_return_categories.to_string());
            }
            if let Some(param_return_filters) = param_return_filters {
                query_string.append_pair("returnFilters",
                    &param_return_filters.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<Vec<models::RatingIndexResponse>>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(SearchLocationRatingIndexesResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn search_rating_indexes(
        &self,
        param_version: f64,
        param_ratable_type: models::SearchRatingIndexesRatableTypeParameter,
        param_ratable_ids: Option<String>,
        param_category_ids: Option<String>,
        param_secondary_type: Option<String>,
        param_keyword: Option<String>,
        param_sort_field: Option<models::SearchRatingIndexesSortFieldParameter>,
        param_descending: Option<bool>,
        param_start: Option<i32>,
        param_limit: Option<i32>,
        param_latitude: Option<f64>,
        param_longitude: Option<f64>,
        param_return_ratable: Option<bool>,
        param_return_overall_rating: Option<bool>,
        context: &C) -> Result<SearchRatingIndexesResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/rating/index/search",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("ratableType",
                    &param_ratable_type.to_string());
            if let Some(param_ratable_ids) = param_ratable_ids {
                query_string.append_pair("ratableIds",
                    &param_ratable_ids);
            }
            if let Some(param_category_ids) = param_category_ids {
                query_string.append_pair("categoryIds",
                    &param_category_ids);
            }
            if let Some(param_secondary_type) = param_secondary_type {
                query_string.append_pair("secondaryType",
                    &param_secondary_type);
            }
            if let Some(param_keyword) = param_keyword {
                query_string.append_pair("keyword",
                    &param_keyword);
            }
            if let Some(param_sort_field) = param_sort_field {
                query_string.append_pair("sortField",
                    &param_sort_field.to_string());
            }
            if let Some(param_descending) = param_descending {
                query_string.append_pair("descending",
                    &param_descending.to_string());
            }
            if let Some(param_start) = param_start {
                query_string.append_pair("start",
                    &param_start.to_string());
            }
            if let Some(param_limit) = param_limit {
                query_string.append_pair("limit",
                    &param_limit.to_string());
            }
            if let Some(param_latitude) = param_latitude {
                query_string.append_pair("latitude",
                    &param_latitude.to_string());
            }
            if let Some(param_longitude) = param_longitude {
                query_string.append_pair("longitude",
                    &param_longitude.to_string());
            }
            if let Some(param_return_ratable) = param_return_ratable {
                query_string.append_pair("returnRatable",
                    &param_return_ratable.to_string());
            }
            if let Some(param_return_overall_rating) = param_return_overall_rating {
                query_string.append_pair("returnOverallRating",
                    &param_return_overall_rating.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<Vec<models::RatingIndexResponse>>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(SearchRatingIndexesResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn search_ratings(
        &self,
        param_version: f64,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_filter_account_id: Option<i64>,
        param_ratable_type: Option<String>,
        param_ratable_id: Option<i64>,
        param_category_ids: Option<String>,
        param_keyword: Option<String>,
        param_sort_field: Option<models::SearchRatingsSortFieldParameter>,
        param_descending: Option<bool>,
        param_start: Option<i32>,
        param_limit: Option<i32>,
        context: &C) -> Result<SearchRatingsResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/rating/search",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_filter_account_id) = param_filter_account_id {
                query_string.append_pair("filterAccountId",
                    &param_filter_account_id.to_string());
            }
            if let Some(param_ratable_type) = param_ratable_type {
                query_string.append_pair("ratableType",
                    &param_ratable_type);
            }
            if let Some(param_ratable_id) = param_ratable_id {
                query_string.append_pair("ratableId",
                    &param_ratable_id.to_string());
            }
            if let Some(param_category_ids) = param_category_ids {
                query_string.append_pair("categoryIds",
                    &param_category_ids);
            }
            if let Some(param_keyword) = param_keyword {
                query_string.append_pair("keyword",
                    &param_keyword);
            }
            if let Some(param_sort_field) = param_sort_field {
                query_string.append_pair("sortField",
                    &param_sort_field.to_string());
            }
            if let Some(param_descending) = param_descending {
                query_string.append_pair("descending",
                    &param_descending.to_string());
            }
            if let Some(param_start) = param_start {
                query_string.append_pair("start",
                    &param_start.to_string());
            }
            if let Some(param_limit) = param_limit {
                query_string.append_pair("limit",
                    &param_limit.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<Vec<models::RatingResponse>>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(SearchRatingsResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn update_rating(
        &self,
        param_version: f64,
        param_rating_id: i64,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_rating_value: Option<i32>,
        param_category_id: Option<i64>,
        param_display: Option<String>,
        param_description: Option<String>,
        param_location_description: Option<String>,
        param_latitude: Option<f64>,
        param_longitude: Option<f64>,
        context: &C) -> Result<UpdateRatingResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/rating/update",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
                query_string.append_pair("ratingId",
                    &param_rating_id.to_string());
            if let Some(param_rating_value) = param_rating_value {
                query_string.append_pair("ratingValue",
                    &param_rating_value.to_string());
            }
            if let Some(param_category_id) = param_category_id {
                query_string.append_pair("categoryId",
                    &param_category_id.to_string());
            }
            if let Some(param_display) = param_display {
                query_string.append_pair("display",
                    &param_display);
            }
            if let Some(param_description) = param_description {
                query_string.append_pair("description",
                    &param_description);
            }
            if let Some(param_location_description) = param_location_description {
                query_string.append_pair("locationDescription",
                    &param_location_description);
            }
            if let Some(param_latitude) = param_latitude {
                query_string.append_pair("latitude",
                    &param_latitude.to_string());
            }
            if let Some(param_longitude) = param_longitude {
                query_string.append_pair("longitude",
                    &param_longitude.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::RatingResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(UpdateRatingResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn create_region(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_region_class: String,
        param_short_name: String,
        param_full_name: Option<String>,
        param_parent_ids: Option<String>,
        param_children_ids: Option<String>,
        param_postal_code_ids: Option<String>,
        param_locations: Option<String>,
        param_retailer_location_id: Option<i64>,
        param_visibility: Option<models::AddAlbumCollectionVisibilityParameter>,
        param_category_ids: Option<String>,
        param_filter_ids: Option<String>,
        param_start: Option<i64>,
        param_end: Option<i64>,
        param_polygon: Option<String>,
        param_meta_data: Option<String>,
        param_latitude: Option<f64>,
        param_longitude: Option<f64>,
        param_version_code: Option<i32>,
        param_root: Option<bool>,
        param_active: Option<bool>,
        context: &C) -> Result<CreateRegionResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/region/create",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("regionClass",
                    &param_region_class);
                query_string.append_pair("shortName",
                    &param_short_name);
            if let Some(param_full_name) = param_full_name {
                query_string.append_pair("fullName",
                    &param_full_name);
            }
            if let Some(param_parent_ids) = param_parent_ids {
                query_string.append_pair("parentIds",
                    &param_parent_ids);
            }
            if let Some(param_children_ids) = param_children_ids {
                query_string.append_pair("childrenIds",
                    &param_children_ids);
            }
            if let Some(param_postal_code_ids) = param_postal_code_ids {
                query_string.append_pair("postalCodeIds",
                    &param_postal_code_ids);
            }
            if let Some(param_locations) = param_locations {
                query_string.append_pair("locations",
                    &param_locations);
            }
            if let Some(param_retailer_location_id) = param_retailer_location_id {
                query_string.append_pair("retailerLocationId",
                    &param_retailer_location_id.to_string());
            }
            if let Some(param_visibility) = param_visibility {
                query_string.append_pair("visibility",
                    &param_visibility.to_string());
            }
            if let Some(param_category_ids) = param_category_ids {
                query_string.append_pair("categoryIds",
                    &param_category_ids);
            }
            if let Some(param_filter_ids) = param_filter_ids {
                query_string.append_pair("filterIds",
                    &param_filter_ids);
            }
            if let Some(param_start) = param_start {
                query_string.append_pair("start",
                    &param_start.to_string());
            }
            if let Some(param_end) = param_end {
                query_string.append_pair("end",
                    &param_end.to_string());
            }
            if let Some(param_polygon) = param_polygon {
                query_string.append_pair("polygon",
                    &param_polygon);
            }
            if let Some(param_meta_data) = param_meta_data {
                query_string.append_pair("metaData",
                    &param_meta_data);
            }
            if let Some(param_latitude) = param_latitude {
                query_string.append_pair("latitude",
                    &param_latitude.to_string());
            }
            if let Some(param_longitude) = param_longitude {
                query_string.append_pair("longitude",
                    &param_longitude.to_string());
            }
            if let Some(param_version_code) = param_version_code {
                query_string.append_pair("versionCode",
                    &param_version_code.to_string());
            }
            if let Some(param_root) = param_root {
                query_string.append_pair("root",
                    &param_root.to_string());
            }
            if let Some(param_active) = param_active {
                query_string.append_pair("active",
                    &param_active.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::RegionResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(CreateRegionResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn delete_region(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_region_id: i64,
        context: &C) -> Result<DeleteRegionResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/region/delete",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("regionId",
                    &param_region_id.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::RegionResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(DeleteRegionResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_region(
        &self,
        param_version: f64,
        param_region_id: i64,
        param_account_id: Option<i64>,
        context: &C) -> Result<GetRegionResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/region/get",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
                query_string.append_pair("regionId",
                    &param_region_id.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::RegionResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetRegionResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn search_regions(
        &self,
        param_version: f64,
        param_account_id: Option<i64>,
        param_query: Option<String>,
        param_keyword: Option<String>,
        param_latitude: Option<f64>,
        param_longitude: Option<f64>,
        param_range: Option<f64>,
        param_region_class: Option<models::SearchRegionsRegionClassParameter>,
        param_visibility: Option<models::AddAlbumCollectionVisibilityParameter>,
        param_search_mode: Option<models::SearchRegionsSearchModeParameter>,
        param_sort_field: Option<models::SearchRegionsSortFieldParameter>,
        param_descending: Option<bool>,
        param_include_parent: Option<bool>,
        param_include_children: Option<bool>,
        param_include_postal_codes: Option<bool>,
        param_category_ids: Option<String>,
        param_filter_ids: Option<String>,
        param_version_code: Option<i32>,
        param_active_only: Option<bool>,
        param_show_deleted: Option<bool>,
        param_last_updated_since: Option<i64>,
        param_start: Option<i32>,
        param_limit: Option<i32>,
        context: &C) -> Result<SearchRegionsResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/region/search",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_query) = param_query {
                query_string.append_pair("query",
                    &param_query);
            }
            if let Some(param_keyword) = param_keyword {
                query_string.append_pair("keyword",
                    &param_keyword);
            }
            if let Some(param_latitude) = param_latitude {
                query_string.append_pair("latitude",
                    &param_latitude.to_string());
            }
            if let Some(param_longitude) = param_longitude {
                query_string.append_pair("longitude",
                    &param_longitude.to_string());
            }
            if let Some(param_range) = param_range {
                query_string.append_pair("range",
                    &param_range.to_string());
            }
            if let Some(param_region_class) = param_region_class {
                query_string.append_pair("regionClass",
                    &param_region_class.to_string());
            }
            if let Some(param_visibility) = param_visibility {
                query_string.append_pair("visibility",
                    &param_visibility.to_string());
            }
            if let Some(param_search_mode) = param_search_mode {
                query_string.append_pair("searchMode",
                    &param_search_mode.to_string());
            }
            if let Some(param_sort_field) = param_sort_field {
                query_string.append_pair("sortField",
                    &param_sort_field.to_string());
            }
            if let Some(param_descending) = param_descending {
                query_string.append_pair("descending",
                    &param_descending.to_string());
            }
            if let Some(param_include_parent) = param_include_parent {
                query_string.append_pair("includeParent",
                    &param_include_parent.to_string());
            }
            if let Some(param_include_children) = param_include_children {
                query_string.append_pair("includeChildren",
                    &param_include_children.to_string());
            }
            if let Some(param_include_postal_codes) = param_include_postal_codes {
                query_string.append_pair("includePostalCodes",
                    &param_include_postal_codes.to_string());
            }
            if let Some(param_category_ids) = param_category_ids {
                query_string.append_pair("categoryIds",
                    &param_category_ids);
            }
            if let Some(param_filter_ids) = param_filter_ids {
                query_string.append_pair("filterIds",
                    &param_filter_ids);
            }
            if let Some(param_version_code) = param_version_code {
                query_string.append_pair("versionCode",
                    &param_version_code.to_string());
            }
            if let Some(param_active_only) = param_active_only {
                query_string.append_pair("activeOnly",
                    &param_active_only.to_string());
            }
            if let Some(param_show_deleted) = param_show_deleted {
                query_string.append_pair("showDeleted",
                    &param_show_deleted.to_string());
            }
            if let Some(param_last_updated_since) = param_last_updated_since {
                query_string.append_pair("lastUpdatedSince",
                    &param_last_updated_since.to_string());
            }
            if let Some(param_start) = param_start {
                query_string.append_pair("start",
                    &param_start.to_string());
            }
            if let Some(param_limit) = param_limit {
                query_string.append_pair("limit",
                    &param_limit.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<Vec<models::RegionResponse>>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(SearchRegionsResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn update_region(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_region_id: i64,
        param_region_class: Option<String>,
        param_short_name: Option<String>,
        param_full_name: Option<String>,
        param_parent_ids: Option<String>,
        param_children_ids: Option<String>,
        param_postal_code_ids: Option<String>,
        param_locations: Option<String>,
        param_retailer_location_id: Option<i64>,
        param_visibility: Option<models::AddAlbumCollectionVisibilityParameter>,
        param_category_ids: Option<String>,
        param_filter_ids: Option<String>,
        param_start: Option<i64>,
        param_end: Option<i64>,
        param_polygon: Option<String>,
        param_meta_data: Option<String>,
        param_latitude: Option<f64>,
        param_longitude: Option<f64>,
        param_version_code: Option<i32>,
        param_root: Option<bool>,
        param_active: Option<bool>,
        param_clear_lists: Option<bool>,
        context: &C) -> Result<UpdateRegionResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/region/update",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("regionId",
                    &param_region_id.to_string());
            if let Some(param_region_class) = param_region_class {
                query_string.append_pair("regionClass",
                    &param_region_class);
            }
            if let Some(param_short_name) = param_short_name {
                query_string.append_pair("shortName",
                    &param_short_name);
            }
            if let Some(param_full_name) = param_full_name {
                query_string.append_pair("fullName",
                    &param_full_name);
            }
            if let Some(param_parent_ids) = param_parent_ids {
                query_string.append_pair("parentIds",
                    &param_parent_ids);
            }
            if let Some(param_children_ids) = param_children_ids {
                query_string.append_pair("childrenIds",
                    &param_children_ids);
            }
            if let Some(param_postal_code_ids) = param_postal_code_ids {
                query_string.append_pair("postalCodeIds",
                    &param_postal_code_ids);
            }
            if let Some(param_locations) = param_locations {
                query_string.append_pair("locations",
                    &param_locations);
            }
            if let Some(param_retailer_location_id) = param_retailer_location_id {
                query_string.append_pair("retailerLocationId",
                    &param_retailer_location_id.to_string());
            }
            if let Some(param_visibility) = param_visibility {
                query_string.append_pair("visibility",
                    &param_visibility.to_string());
            }
            if let Some(param_category_ids) = param_category_ids {
                query_string.append_pair("categoryIds",
                    &param_category_ids);
            }
            if let Some(param_filter_ids) = param_filter_ids {
                query_string.append_pair("filterIds",
                    &param_filter_ids);
            }
            if let Some(param_start) = param_start {
                query_string.append_pair("start",
                    &param_start.to_string());
            }
            if let Some(param_end) = param_end {
                query_string.append_pair("end",
                    &param_end.to_string());
            }
            if let Some(param_polygon) = param_polygon {
                query_string.append_pair("polygon",
                    &param_polygon);
            }
            if let Some(param_meta_data) = param_meta_data {
                query_string.append_pair("metaData",
                    &param_meta_data);
            }
            if let Some(param_latitude) = param_latitude {
                query_string.append_pair("latitude",
                    &param_latitude.to_string());
            }
            if let Some(param_longitude) = param_longitude {
                query_string.append_pair("longitude",
                    &param_longitude.to_string());
            }
            if let Some(param_version_code) = param_version_code {
                query_string.append_pair("versionCode",
                    &param_version_code.to_string());
            }
            if let Some(param_root) = param_root {
                query_string.append_pair("root",
                    &param_root.to_string());
            }
            if let Some(param_active) = param_active {
                query_string.append_pair("active",
                    &param_active.to_string());
            }
            if let Some(param_clear_lists) = param_clear_lists {
                query_string.append_pair("clearLists",
                    &param_clear_lists.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::RegionResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(UpdateRegionResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn create_batch(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_status: models::CreateBatchStatusParameter,
        param_preview_limit: i32,
        param_app_key: Option<String>,
        param_endpoint: Option<String>,
        param_parameters: Option<String>,
        param_name: Option<String>,
        param_start_date: Option<i64>,
        param_end_date: Option<i64>,
        param_description: Option<String>,
        param_page_url: Option<String>,
        context: &C) -> Result<CreateBatchResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/report/batch/create",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            if let Some(param_app_key) = param_app_key {
                query_string.append_pair("appKey",
                    &param_app_key);
            }
                query_string.append_pair("status",
                    &param_status.to_string());
            if let Some(param_endpoint) = param_endpoint {
                query_string.append_pair("endpoint",
                    &param_endpoint);
            }
            if let Some(param_parameters) = param_parameters {
                query_string.append_pair("parameters",
                    &param_parameters);
            }
            if let Some(param_name) = param_name {
                query_string.append_pair("name",
                    &param_name);
            }
            if let Some(param_start_date) = param_start_date {
                query_string.append_pair("startDate",
                    &param_start_date.to_string());
            }
            if let Some(param_end_date) = param_end_date {
                query_string.append_pair("endDate",
                    &param_end_date.to_string());
            }
            if let Some(param_description) = param_description {
                query_string.append_pair("description",
                    &param_description);
            }
                query_string.append_pair("previewLimit",
                    &param_preview_limit.to_string());
            if let Some(param_page_url) = param_page_url {
                query_string.append_pair("pageUrl",
                    &param_page_url);
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::ReportBatchResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(CreateBatchResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn create_region_leg_summary_batch<'a>(
        &self,
        param_version: f64,
        param_body: Option<&'a Vec<models::RegionLegSummary>>,
        context: &C) -> Result<CreateRegionLegSummaryBatchResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/report/region/summary/batch",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        // Consumes basic body
        // Body parameter
        if let Some(param_body) = param_body {
        let body = serde_json::to_string(&param_body).expect("impossible to fail to serialize");
        *request.body_mut() = body_from_string(body);
        }

        let header = "application/json";
        request.headers_mut().insert(CONTENT_TYPE, HeaderValue::from_static(header));

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::ReportRegionLegSummaryBatchResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(CreateRegionLegSummaryBatchResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn delete_batch(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_batch_id: i64,
        context: &C) -> Result<DeleteBatchResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/report/batch/delete",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("batchId",
                    &param_batch_id.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(DeleteBatchResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_report_batch(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_batch_id: i64,
        param_all_results: bool,
        context: &C) -> Result<GetReportBatchResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/report/batch/get",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("batchId",
                    &param_batch_id.to_string());
                query_string.append_pair("allResults",
                    &param_all_results.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::ReportBatchResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetReportBatchResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn run_report(
        &self,
        param_version: f64,
        param_desc: bool,
        param_account_id: Option<i64>,
        param_query: Option<String>,
        param_parameters: Option<String>,
        param_order: Option<String>,
        param_start: Option<i64>,
        param_limit: Option<i64>,
        param_response_format: Option<models::AggregatedFilteredUsageResponseFormatParameter>,
        context: &C) -> Result<RunReportResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/report/run",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_query) = param_query {
                query_string.append_pair("query",
                    &param_query);
            }
            if let Some(param_parameters) = param_parameters {
                query_string.append_pair("parameters",
                    &param_parameters);
            }
            if let Some(param_order) = param_order {
                query_string.append_pair("order",
                    &param_order);
            }
                query_string.append_pair("desc",
                    &param_desc.to_string());
            if let Some(param_start) = param_start {
                query_string.append_pair("start",
                    &param_start.to_string());
            }
            if let Some(param_limit) = param_limit {
                query_string.append_pair("limit",
                    &param_limit.to_string());
            }
            if let Some(param_response_format) = param_response_format {
                query_string.append_pair("responseFormat",
                    &param_response_format.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::ReportResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(RunReportResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn search_batch(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_start: i32,
        param_limit: i32,
        param_names: Option<String>,
        param_app_key: Option<String>,
        param_status: Option<models::CreateBatchStatusParameter>,
        param_global_app_search: Option<bool>,
        param_start_date: Option<i64>,
        param_end_date: Option<i64>,
        context: &C) -> Result<SearchBatchResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/report/batch/search",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            if let Some(param_names) = param_names {
                query_string.append_pair("names",
                    &param_names);
            }
            if let Some(param_app_key) = param_app_key {
                query_string.append_pair("appKey",
                    &param_app_key);
            }
            if let Some(param_status) = param_status {
                query_string.append_pair("status",
                    &param_status.to_string());
            }
            if let Some(param_global_app_search) = param_global_app_search {
                query_string.append_pair("globalAppSearch",
                    &param_global_app_search.to_string());
            }
            if let Some(param_start_date) = param_start_date {
                query_string.append_pair("startDate",
                    &param_start_date.to_string());
            }
            if let Some(param_end_date) = param_end_date {
                query_string.append_pair("endDate",
                    &param_end_date.to_string());
            }
                query_string.append_pair("start",
                    &param_start.to_string());
                query_string.append_pair("limit",
                    &param_limit.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<Vec<models::ReportBatchResponse>>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(SearchBatchResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn create_reservation(
        &self,
        param_version: f64,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_start_date: Option<i64>,
        param_end_date: Option<i64>,
        param_offer_id: Option<i64>,
        param_offer_location_id: Option<i64>,
        param_app_key: Option<String>,
        param_meta_data: Option<String>,
        context: &C) -> Result<CreateReservationResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/reservation/create",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_start_date) = param_start_date {
                query_string.append_pair("startDate",
                    &param_start_date.to_string());
            }
            if let Some(param_end_date) = param_end_date {
                query_string.append_pair("endDate",
                    &param_end_date.to_string());
            }
            if let Some(param_offer_id) = param_offer_id {
                query_string.append_pair("offerId",
                    &param_offer_id.to_string());
            }
            if let Some(param_offer_location_id) = param_offer_location_id {
                query_string.append_pair("offerLocationId",
                    &param_offer_location_id.to_string());
            }
            if let Some(param_app_key) = param_app_key {
                query_string.append_pair("appKey",
                    &param_app_key);
            }
            if let Some(param_meta_data) = param_meta_data {
                query_string.append_pair("metaData",
                    &param_meta_data);
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                Ok(
                    CreateReservationResponse::SuccessfulOperation
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn delete_reservation(
        &self,
        param_version: f64,
        param_reservation_id: i64,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        context: &C) -> Result<DeleteReservationResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/reservation/delete",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
                query_string.append_pair("reservationId",
                    &param_reservation_id.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                Ok(
                    DeleteReservationResponse::SuccessfulOperation
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn reservable_availability(
        &self,
        param_version: f64,
        param_reservable_id: i64,
        param_reservable_type: models::SearchRatingIndexesRatableTypeParameter,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_availability: Option<String>,
        param_availability_summary: Option<String>,
        context: &C) -> Result<ReservableAvailabilityResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/reservable/availability/update",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
                query_string.append_pair("reservableId",
                    &param_reservable_id.to_string());
                query_string.append_pair("reservableType",
                    &param_reservable_type.to_string());
            if let Some(param_availability) = param_availability {
                query_string.append_pair("availability",
                    &param_availability);
            }
            if let Some(param_availability_summary) = param_availability_summary {
                query_string.append_pair("availabilitySummary",
                    &param_availability_summary);
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<Vec<models::AvailabilityResponse>>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(ReservableAvailabilityResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn search_availability(
        &self,
        param_version: f64,
        param_reservable_id: i64,
        param_reservable_type: models::SearchRatingIndexesRatableTypeParameter,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_start_date: Option<i64>,
        param_end_date: Option<i64>,
        param_start: Option<i32>,
        param_limit: Option<i32>,
        context: &C) -> Result<SearchAvailabilityResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/reservable/availability/search",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
                query_string.append_pair("reservableId",
                    &param_reservable_id.to_string());
                query_string.append_pair("reservableType",
                    &param_reservable_type.to_string());
            if let Some(param_start_date) = param_start_date {
                query_string.append_pair("startDate",
                    &param_start_date.to_string());
            }
            if let Some(param_end_date) = param_end_date {
                query_string.append_pair("endDate",
                    &param_end_date.to_string());
            }
            if let Some(param_start) = param_start {
                query_string.append_pair("start",
                    &param_start.to_string());
            }
            if let Some(param_limit) = param_limit {
                query_string.append_pair("limit",
                    &param_limit.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<Vec<models::AvailabilityResponse>>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(SearchAvailabilityResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn search_reservations(
        &self,
        param_version: f64,
        param_device_id: Option<String>,
        param_app_key: Option<String>,
        param_account_id: Option<i64>,
        param_filter_account_id: Option<i64>,
        param_reservable_id: Option<i64>,
        param_reservable_type: Option<models::SearchRatingIndexesRatableTypeParameter>,
        param_keyword: Option<String>,
        param_start_date: Option<i64>,
        param_end_date: Option<i64>,
        param_start: Option<i32>,
        param_limit: Option<i32>,
        context: &C) -> Result<SearchReservationsResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/reservation/search",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_app_key) = param_app_key {
                query_string.append_pair("appKey",
                    &param_app_key);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_filter_account_id) = param_filter_account_id {
                query_string.append_pair("filterAccountId",
                    &param_filter_account_id.to_string());
            }
            if let Some(param_reservable_id) = param_reservable_id {
                query_string.append_pair("reservableId",
                    &param_reservable_id.to_string());
            }
            if let Some(param_reservable_type) = param_reservable_type {
                query_string.append_pair("reservableType",
                    &param_reservable_type.to_string());
            }
            if let Some(param_keyword) = param_keyword {
                query_string.append_pair("keyword",
                    &param_keyword);
            }
            if let Some(param_start_date) = param_start_date {
                query_string.append_pair("startDate",
                    &param_start_date.to_string());
            }
            if let Some(param_end_date) = param_end_date {
                query_string.append_pair("endDate",
                    &param_end_date.to_string());
            }
            if let Some(param_start) = param_start {
                query_string.append_pair("start",
                    &param_start.to_string());
            }
            if let Some(param_limit) = param_limit {
                query_string.append_pair("limit",
                    &param_limit.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<Vec<models::ReservationResponse>>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(SearchReservationsResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn search_schedule(
        &self,
        param_version: f64,
        param_reservable_id: i64,
        param_reservable_type: models::SearchRatingIndexesRatableTypeParameter,
        param_start_date: i64,
        param_end_date: i64,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_time_bucket_mins: Option<i32>,
        context: &C) -> Result<SearchScheduleResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/reservable/schedule/search",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
                query_string.append_pair("reservableId",
                    &param_reservable_id.to_string());
                query_string.append_pair("reservableType",
                    &param_reservable_type.to_string());
                query_string.append_pair("startDate",
                    &param_start_date.to_string());
                query_string.append_pair("endDate",
                    &param_end_date.to_string());
            if let Some(param_time_bucket_mins) = param_time_bucket_mins {
                query_string.append_pair("timeBucketMins",
                    &param_time_bucket_mins.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<Vec<models::TimeSlotResponse>>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(SearchScheduleResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn create_retailer(
        &self,
        param_version: f64,
        param_name: String,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_street_address: Option<String>,
        param_street_address2: Option<String>,
        param_city: Option<String>,
        param_state: Option<String>,
        param_postal_code: Option<String>,
        param_country: Option<String>,
        param_business_phone: Option<String>,
        param_business_phone_ext: Option<String>,
        param_website: Option<String>,
        param_email: Option<String>,
        param_facebook_url: Option<String>,
        param_twitter_url: Option<String>,
        param_logo: Option<swagger::ByteArray>,
        param_logo_asset_id: Option<i64>,
        param_picture1: Option<swagger::ByteArray>,
        param_picture1_asset_id: Option<i64>,
        param_picture2: Option<swagger::ByteArray>,
        param_picture2_asset_id: Option<i64>,
        param_category_ids: Option<String>,
        param_category_ids_to_add: Option<String>,
        param_category_ids_to_remove: Option<String>,
        param_filter_ids: Option<String>,
        param_latitude: Option<f64>,
        param_longitude: Option<f64>,
        param_meta_data: Option<String>,
        param_search_tags: Option<String>,
        param_retailer_type: Option<String>,
        param_visibility: Option<models::AddAlbumCollectionVisibilityParameter>,
        param_create_default_location: Option<bool>,
        param_response_format: Option<models::AggregatedFilteredUsageResponseFormatParameter>,
        context: &C) -> Result<CreateRetailerResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/retailer/create",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
                query_string.append_pair("name",
                    &param_name);
            if let Some(param_street_address) = param_street_address {
                query_string.append_pair("streetAddress",
                    &param_street_address);
            }
            if let Some(param_street_address2) = param_street_address2 {
                query_string.append_pair("streetAddress2",
                    &param_street_address2);
            }
            if let Some(param_city) = param_city {
                query_string.append_pair("city",
                    &param_city);
            }
            if let Some(param_state) = param_state {
                query_string.append_pair("state",
                    &param_state);
            }
            if let Some(param_postal_code) = param_postal_code {
                query_string.append_pair("postalCode",
                    &param_postal_code);
            }
            if let Some(param_country) = param_country {
                query_string.append_pair("country",
                    &param_country);
            }
            if let Some(param_business_phone) = param_business_phone {
                query_string.append_pair("businessPhone",
                    &param_business_phone);
            }
            if let Some(param_business_phone_ext) = param_business_phone_ext {
                query_string.append_pair("businessPhoneExt",
                    &param_business_phone_ext);
            }
            if let Some(param_website) = param_website {
                query_string.append_pair("website",
                    &param_website);
            }
            if let Some(param_email) = param_email {
                query_string.append_pair("email",
                    &param_email);
            }
            if let Some(param_facebook_url) = param_facebook_url {
                query_string.append_pair("facebookUrl",
                    &param_facebook_url);
            }
            if let Some(param_twitter_url) = param_twitter_url {
                query_string.append_pair("twitterUrl",
                    &param_twitter_url);
            }
            if let Some(param_logo) = param_logo {
                query_string.append_pair("logo",
                    &param_logo.to_string());
            }
            if let Some(param_logo_asset_id) = param_logo_asset_id {
                query_string.append_pair("logoAssetId",
                    &param_logo_asset_id.to_string());
            }
            if let Some(param_picture1) = param_picture1 {
                query_string.append_pair("picture1",
                    &param_picture1.to_string());
            }
            if let Some(param_picture1_asset_id) = param_picture1_asset_id {
                query_string.append_pair("picture1AssetId",
                    &param_picture1_asset_id.to_string());
            }
            if let Some(param_picture2) = param_picture2 {
                query_string.append_pair("picture2",
                    &param_picture2.to_string());
            }
            if let Some(param_picture2_asset_id) = param_picture2_asset_id {
                query_string.append_pair("picture2AssetId",
                    &param_picture2_asset_id.to_string());
            }
            if let Some(param_category_ids) = param_category_ids {
                query_string.append_pair("categoryIds",
                    &param_category_ids);
            }
            if let Some(param_category_ids_to_add) = param_category_ids_to_add {
                query_string.append_pair("categoryIdsToAdd",
                    &param_category_ids_to_add);
            }
            if let Some(param_category_ids_to_remove) = param_category_ids_to_remove {
                query_string.append_pair("categoryIdsToRemove",
                    &param_category_ids_to_remove);
            }
            if let Some(param_filter_ids) = param_filter_ids {
                query_string.append_pair("filterIds",
                    &param_filter_ids);
            }
            if let Some(param_latitude) = param_latitude {
                query_string.append_pair("latitude",
                    &param_latitude.to_string());
            }
            if let Some(param_longitude) = param_longitude {
                query_string.append_pair("longitude",
                    &param_longitude.to_string());
            }
            if let Some(param_meta_data) = param_meta_data {
                query_string.append_pair("metaData",
                    &param_meta_data);
            }
            if let Some(param_search_tags) = param_search_tags {
                query_string.append_pair("searchTags",
                    &param_search_tags);
            }
            if let Some(param_retailer_type) = param_retailer_type {
                query_string.append_pair("retailerType",
                    &param_retailer_type);
            }
            if let Some(param_visibility) = param_visibility {
                query_string.append_pair("visibility",
                    &param_visibility.to_string());
            }
            if let Some(param_create_default_location) = param_create_default_location {
                query_string.append_pair("createDefaultLocation",
                    &param_create_default_location.to_string());
            }
            if let Some(param_response_format) = param_response_format {
                query_string.append_pair("responseFormat",
                    &param_response_format.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::RetailerFullResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(CreateRetailerResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn delete_retailer(
        &self,
        param_version: f64,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_retailer_id: Option<i64>,
        context: &C) -> Result<DeleteRetailerResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/retailer/delete",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_retailer_id) = param_retailer_id {
                query_string.append_pair("retailerId",
                    &param_retailer_id.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(DeleteRetailerResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_retailer(
        &self,
        param_version: f64,
        param_retailer_id: i64,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_include_counts: Option<bool>,
        context: &C) -> Result<GetRetailerResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/retailer/get",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
                query_string.append_pair("retailerId",
                    &param_retailer_id.to_string());
            if let Some(param_include_counts) = param_include_counts {
                query_string.append_pair("includeCounts",
                    &param_include_counts.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::RetailerFullResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetRetailerResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_retailers(
        &self,
        param_version: f64,
        param_visibility: models::AddAlbumCollectionVisibilityParameter,
        param_sort_field: models::GetRetailersSortFieldParameter,
        param_descending: bool,
        param_start: i32,
        param_limit: i32,
        param_active_only: bool,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_q: Option<String>,
        param_keyword: Option<String>,
        param_category_ids: Option<String>,
        param_filter_ids: Option<String>,
        param__i: Option<i32>,
        param__l: Option<i32>,
        context: &C) -> Result<GetRetailersResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/retailer/search",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_q) = param_q {
                query_string.append_pair("q",
                    &param_q);
            }
            if let Some(param_keyword) = param_keyword {
                query_string.append_pair("keyword",
                    &param_keyword);
            }
            if let Some(param_category_ids) = param_category_ids {
                query_string.append_pair("categoryIds",
                    &param_category_ids);
            }
            if let Some(param_filter_ids) = param_filter_ids {
                query_string.append_pair("filterIds",
                    &param_filter_ids);
            }
                query_string.append_pair("visibility",
                    &param_visibility.to_string());
                query_string.append_pair("sortField",
                    &param_sort_field.to_string());
                query_string.append_pair("descending",
                    &param_descending.to_string());
            if let Some(param__i) = param__i {
                query_string.append_pair("_i",
                    &param__i.to_string());
            }
                query_string.append_pair("start",
                    &param_start.to_string());
            if let Some(param__l) = param__l {
                query_string.append_pair("_l",
                    &param__l.to_string());
            }
                query_string.append_pair("limit",
                    &param_limit.to_string());
                query_string.append_pair("activeOnly",
                    &param_active_only.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<Vec<models::RetailerResponse>>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetRetailersResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn retailer_login_check(
        &self,
        param_version: f64,
        param_username: String,
        param_password: String,
        param_device_id: Option<String>,
        param_latitude: Option<f64>,
        param_longitude: Option<f64>,
        param_app_key: Option<String>,
        context: &C) -> Result<RetailerLoginCheckResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/retailer/login",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("username",
                    &param_username);
                query_string.append_pair("password",
                    &param_password);
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_latitude) = param_latitude {
                query_string.append_pair("latitude",
                    &param_latitude.to_string());
            }
            if let Some(param_longitude) = param_longitude {
                query_string.append_pair("longitude",
                    &param_longitude.to_string());
            }
            if let Some(param_app_key) = param_app_key {
                query_string.append_pair("appKey",
                    &param_app_key);
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::AccountLoginResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(RetailerLoginCheckResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn update_retailer(
        &self,
        param_version: f64,
        param_retailer_id: i64,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_name: Option<String>,
        param_street_address: Option<String>,
        param_street_address2: Option<String>,
        param_city: Option<String>,
        param_state: Option<String>,
        param_postal_code: Option<String>,
        param_country: Option<String>,
        param_business_phone: Option<String>,
        param_business_phone_ext: Option<String>,
        param_website: Option<String>,
        param_email: Option<String>,
        param_facebook_url: Option<String>,
        param_twitter_url: Option<String>,
        param_logo: Option<swagger::ByteArray>,
        param_logo_asset_id: Option<i64>,
        param_picture1: Option<swagger::ByteArray>,
        param_picture1_asset_id: Option<i64>,
        param_picture2: Option<swagger::ByteArray>,
        param_picture2_asset_id: Option<i64>,
        param_category_ids: Option<String>,
        param_filter_ids: Option<String>,
        param_latitude: Option<f64>,
        param_longitude: Option<f64>,
        param_meta_data: Option<String>,
        param_search_tags: Option<String>,
        param_retailer_type: Option<String>,
        param_visibility: Option<models::AddAlbumCollectionVisibilityParameter>,
        param_active: Option<bool>,
        param_response_format: Option<models::AggregatedFilteredUsageResponseFormatParameter>,
        context: &C) -> Result<UpdateRetailerResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/retailer/update",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
                query_string.append_pair("retailerId",
                    &param_retailer_id.to_string());
            if let Some(param_name) = param_name {
                query_string.append_pair("name",
                    &param_name);
            }
            if let Some(param_street_address) = param_street_address {
                query_string.append_pair("streetAddress",
                    &param_street_address);
            }
            if let Some(param_street_address2) = param_street_address2 {
                query_string.append_pair("streetAddress2",
                    &param_street_address2);
            }
            if let Some(param_city) = param_city {
                query_string.append_pair("city",
                    &param_city);
            }
            if let Some(param_state) = param_state {
                query_string.append_pair("state",
                    &param_state);
            }
            if let Some(param_postal_code) = param_postal_code {
                query_string.append_pair("postalCode",
                    &param_postal_code);
            }
            if let Some(param_country) = param_country {
                query_string.append_pair("country",
                    &param_country);
            }
            if let Some(param_business_phone) = param_business_phone {
                query_string.append_pair("businessPhone",
                    &param_business_phone);
            }
            if let Some(param_business_phone_ext) = param_business_phone_ext {
                query_string.append_pair("businessPhoneExt",
                    &param_business_phone_ext);
            }
            if let Some(param_website) = param_website {
                query_string.append_pair("website",
                    &param_website);
            }
            if let Some(param_email) = param_email {
                query_string.append_pair("email",
                    &param_email);
            }
            if let Some(param_facebook_url) = param_facebook_url {
                query_string.append_pair("facebookUrl",
                    &param_facebook_url);
            }
            if let Some(param_twitter_url) = param_twitter_url {
                query_string.append_pair("twitterUrl",
                    &param_twitter_url);
            }
            if let Some(param_logo) = param_logo {
                query_string.append_pair("logo",
                    &param_logo.to_string());
            }
            if let Some(param_logo_asset_id) = param_logo_asset_id {
                query_string.append_pair("logoAssetId",
                    &param_logo_asset_id.to_string());
            }
            if let Some(param_picture1) = param_picture1 {
                query_string.append_pair("picture1",
                    &param_picture1.to_string());
            }
            if let Some(param_picture1_asset_id) = param_picture1_asset_id {
                query_string.append_pair("picture1AssetId",
                    &param_picture1_asset_id.to_string());
            }
            if let Some(param_picture2) = param_picture2 {
                query_string.append_pair("picture2",
                    &param_picture2.to_string());
            }
            if let Some(param_picture2_asset_id) = param_picture2_asset_id {
                query_string.append_pair("picture2AssetId",
                    &param_picture2_asset_id.to_string());
            }
            if let Some(param_category_ids) = param_category_ids {
                query_string.append_pair("categoryIds",
                    &param_category_ids);
            }
            if let Some(param_filter_ids) = param_filter_ids {
                query_string.append_pair("filterIds",
                    &param_filter_ids);
            }
            if let Some(param_latitude) = param_latitude {
                query_string.append_pair("latitude",
                    &param_latitude.to_string());
            }
            if let Some(param_longitude) = param_longitude {
                query_string.append_pair("longitude",
                    &param_longitude.to_string());
            }
            if let Some(param_meta_data) = param_meta_data {
                query_string.append_pair("metaData",
                    &param_meta_data);
            }
            if let Some(param_search_tags) = param_search_tags {
                query_string.append_pair("searchTags",
                    &param_search_tags);
            }
            if let Some(param_retailer_type) = param_retailer_type {
                query_string.append_pair("retailerType",
                    &param_retailer_type);
            }
            if let Some(param_visibility) = param_visibility {
                query_string.append_pair("visibility",
                    &param_visibility.to_string());
            }
            if let Some(param_active) = param_active {
                query_string.append_pair("active",
                    &param_active.to_string());
            }
            if let Some(param_response_format) = param_response_format {
                query_string.append_pair("responseFormat",
                    &param_response_format.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::RetailerFullResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(UpdateRetailerResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn create_retailer_location_consumer(
        &self,
        param_version: f64,
        param_app_key: String,
        param_name: String,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_street_address: Option<String>,
        param_street_address2: Option<String>,
        param_city: Option<String>,
        param_state: Option<String>,
        param_postal_code: Option<String>,
        param_country: Option<String>,
        param_business_phone: Option<String>,
        param_business_phone_ext: Option<String>,
        param_website: Option<String>,
        param_email: Option<String>,
        param_details_header: Option<String>,
        param_details_body: Option<String>,
        param_hours: Option<String>,
        param_tags: Option<String>,
        param_logo_asset_id: Option<i64>,
        param_picture1_asset_id: Option<i64>,
        param_picture2_asset_id: Option<i64>,
        param_category_ids: Option<String>,
        param_filter_ids: Option<String>,
        param_meta_data: Option<String>,
        param_public_location: Option<bool>,
        param_active: Option<bool>,
        param_location_type: Option<String>,
        param_latitude: Option<f64>,
        param_longitude: Option<f64>,
        context: &C) -> Result<CreateRetailerLocationConsumerResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/location/create",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
                query_string.append_pair("appKey",
                    &param_app_key);
                query_string.append_pair("name",
                    &param_name);
            if let Some(param_street_address) = param_street_address {
                query_string.append_pair("streetAddress",
                    &param_street_address);
            }
            if let Some(param_street_address2) = param_street_address2 {
                query_string.append_pair("streetAddress2",
                    &param_street_address2);
            }
            if let Some(param_city) = param_city {
                query_string.append_pair("city",
                    &param_city);
            }
            if let Some(param_state) = param_state {
                query_string.append_pair("state",
                    &param_state);
            }
            if let Some(param_postal_code) = param_postal_code {
                query_string.append_pair("postalCode",
                    &param_postal_code);
            }
            if let Some(param_country) = param_country {
                query_string.append_pair("country",
                    &param_country);
            }
            if let Some(param_business_phone) = param_business_phone {
                query_string.append_pair("businessPhone",
                    &param_business_phone);
            }
            if let Some(param_business_phone_ext) = param_business_phone_ext {
                query_string.append_pair("businessPhoneExt",
                    &param_business_phone_ext);
            }
            if let Some(param_website) = param_website {
                query_string.append_pair("website",
                    &param_website);
            }
            if let Some(param_email) = param_email {
                query_string.append_pair("email",
                    &param_email);
            }
            if let Some(param_details_header) = param_details_header {
                query_string.append_pair("detailsHeader",
                    &param_details_header);
            }
            if let Some(param_details_body) = param_details_body {
                query_string.append_pair("detailsBody",
                    &param_details_body);
            }
            if let Some(param_hours) = param_hours {
                query_string.append_pair("hours",
                    &param_hours);
            }
            if let Some(param_tags) = param_tags {
                query_string.append_pair("tags",
                    &param_tags);
            }
            if let Some(param_logo_asset_id) = param_logo_asset_id {
                query_string.append_pair("logoAssetId",
                    &param_logo_asset_id.to_string());
            }
            if let Some(param_picture1_asset_id) = param_picture1_asset_id {
                query_string.append_pair("picture1AssetId",
                    &param_picture1_asset_id.to_string());
            }
            if let Some(param_picture2_asset_id) = param_picture2_asset_id {
                query_string.append_pair("picture2AssetId",
                    &param_picture2_asset_id.to_string());
            }
            if let Some(param_category_ids) = param_category_ids {
                query_string.append_pair("categoryIds",
                    &param_category_ids);
            }
            if let Some(param_filter_ids) = param_filter_ids {
                query_string.append_pair("filterIds",
                    &param_filter_ids);
            }
            if let Some(param_meta_data) = param_meta_data {
                query_string.append_pair("metaData",
                    &param_meta_data);
            }
            if let Some(param_public_location) = param_public_location {
                query_string.append_pair("publicLocation",
                    &param_public_location.to_string());
            }
            if let Some(param_active) = param_active {
                query_string.append_pair("active",
                    &param_active.to_string());
            }
            if let Some(param_location_type) = param_location_type {
                query_string.append_pair("locationType",
                    &param_location_type);
            }
            if let Some(param_latitude) = param_latitude {
                query_string.append_pair("latitude",
                    &param_latitude.to_string());
            }
            if let Some(param_longitude) = param_longitude {
                query_string.append_pair("longitude",
                    &param_longitude.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::RetailerLocationResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(CreateRetailerLocationConsumerResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn create_retailer_locations(
        &self,
        param_version: f64,
        param_retailer_id: i64,
        param_name: String,
        param_street_address: String,
        param_city: String,
        param_state: String,
        param_postal_code: String,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_street_address2: Option<String>,
        param_country: Option<String>,
        param_business_phone: Option<String>,
        param_business_phone_ext: Option<String>,
        param_website: Option<String>,
        param_email: Option<String>,
        param_internal_id: Option<String>,
        param_details_header: Option<String>,
        param_details_body: Option<String>,
        param_hours: Option<String>,
        param_logo: Option<swagger::ByteArray>,
        param_logo_asset_id: Option<i64>,
        param_picture1: Option<swagger::ByteArray>,
        param_picture1_asset_id: Option<i64>,
        param_picture2: Option<swagger::ByteArray>,
        param_picture2_asset_id: Option<i64>,
        param_category_ids: Option<String>,
        param_filter_ids: Option<String>,
        param_latitude: Option<f64>,
        param_longitude: Option<f64>,
        param_building: Option<String>,
        param_google_place_id: Option<String>,
        param_yelp_id: Option<String>,
        param_active: Option<bool>,
        param_public_location: Option<bool>,
        param_location_type: Option<String>,
        param_audience_ids: Option<String>,
        param_audience_ids_to_add: Option<String>,
        param_audience_ids_to_remove: Option<String>,
        param_response_format: Option<models::AggregatedFilteredUsageResponseFormatParameter>,
        param_response_includes: Option<String>,
        context: &C) -> Result<CreateRetailerLocationsResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/retailer/location/create",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
                query_string.append_pair("retailerId",
                    &param_retailer_id.to_string());
                query_string.append_pair("name",
                    &param_name);
                query_string.append_pair("streetAddress",
                    &param_street_address);
            if let Some(param_street_address2) = param_street_address2 {
                query_string.append_pair("streetAddress2",
                    &param_street_address2);
            }
                query_string.append_pair("city",
                    &param_city);
                query_string.append_pair("state",
                    &param_state);
                query_string.append_pair("postalCode",
                    &param_postal_code);
            if let Some(param_country) = param_country {
                query_string.append_pair("country",
                    &param_country);
            }
            if let Some(param_business_phone) = param_business_phone {
                query_string.append_pair("businessPhone",
                    &param_business_phone);
            }
            if let Some(param_business_phone_ext) = param_business_phone_ext {
                query_string.append_pair("businessPhoneExt",
                    &param_business_phone_ext);
            }
            if let Some(param_website) = param_website {
                query_string.append_pair("website",
                    &param_website);
            }
            if let Some(param_email) = param_email {
                query_string.append_pair("email",
                    &param_email);
            }
            if let Some(param_internal_id) = param_internal_id {
                query_string.append_pair("internalId",
                    &param_internal_id);
            }
            if let Some(param_details_header) = param_details_header {
                query_string.append_pair("detailsHeader",
                    &param_details_header);
            }
            if let Some(param_details_body) = param_details_body {
                query_string.append_pair("detailsBody",
                    &param_details_body);
            }
            if let Some(param_hours) = param_hours {
                query_string.append_pair("hours",
                    &param_hours);
            }
            if let Some(param_logo) = param_logo {
                query_string.append_pair("logo",
                    &param_logo.to_string());
            }
            if let Some(param_logo_asset_id) = param_logo_asset_id {
                query_string.append_pair("logoAssetId",
                    &param_logo_asset_id.to_string());
            }
            if let Some(param_picture1) = param_picture1 {
                query_string.append_pair("picture1",
                    &param_picture1.to_string());
            }
            if let Some(param_picture1_asset_id) = param_picture1_asset_id {
                query_string.append_pair("picture1AssetId",
                    &param_picture1_asset_id.to_string());
            }
            if let Some(param_picture2) = param_picture2 {
                query_string.append_pair("picture2",
                    &param_picture2.to_string());
            }
            if let Some(param_picture2_asset_id) = param_picture2_asset_id {
                query_string.append_pair("picture2AssetId",
                    &param_picture2_asset_id.to_string());
            }
            if let Some(param_category_ids) = param_category_ids {
                query_string.append_pair("categoryIds",
                    &param_category_ids);
            }
            if let Some(param_filter_ids) = param_filter_ids {
                query_string.append_pair("filterIds",
                    &param_filter_ids);
            }
            if let Some(param_latitude) = param_latitude {
                query_string.append_pair("latitude",
                    &param_latitude.to_string());
            }
            if let Some(param_longitude) = param_longitude {
                query_string.append_pair("longitude",
                    &param_longitude.to_string());
            }
            if let Some(param_building) = param_building {
                query_string.append_pair("building",
                    &param_building);
            }
            if let Some(param_google_place_id) = param_google_place_id {
                query_string.append_pair("googlePlaceId",
                    &param_google_place_id);
            }
            if let Some(param_yelp_id) = param_yelp_id {
                query_string.append_pair("yelpId",
                    &param_yelp_id);
            }
            if let Some(param_active) = param_active {
                query_string.append_pair("active",
                    &param_active.to_string());
            }
            if let Some(param_public_location) = param_public_location {
                query_string.append_pair("publicLocation",
                    &param_public_location.to_string());
            }
            if let Some(param_location_type) = param_location_type {
                query_string.append_pair("locationType",
                    &param_location_type);
            }
            if let Some(param_audience_ids) = param_audience_ids {
                query_string.append_pair("audienceIds",
                    &param_audience_ids);
            }
            if let Some(param_audience_ids_to_add) = param_audience_ids_to_add {
                query_string.append_pair("audienceIdsToAdd",
                    &param_audience_ids_to_add);
            }
            if let Some(param_audience_ids_to_remove) = param_audience_ids_to_remove {
                query_string.append_pair("audienceIdsToRemove",
                    &param_audience_ids_to_remove);
            }
            if let Some(param_response_format) = param_response_format {
                query_string.append_pair("responseFormat",
                    &param_response_format.to_string());
            }
            if let Some(param_response_includes) = param_response_includes {
                query_string.append_pair("responseIncludes",
                    &param_response_includes);
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::RetailerLocationResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(CreateRetailerLocationsResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn delete_retailer_location(
        &self,
        param_version: f64,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_retailer_location_id: Option<i64>,
        context: &C) -> Result<DeleteRetailerLocationResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/retailer/location/delete",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_retailer_location_id) = param_retailer_location_id {
                query_string.append_pair("retailerLocationId",
                    &param_retailer_location_id.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(DeleteRetailerLocationResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_retailer_location(
        &self,
        param_version: f64,
        param_retailer_location_id: i64,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_retailer_location_token: Option<String>,
        context: &C) -> Result<GetRetailerLocationResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/retailer/location/get",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
                query_string.append_pair("retailerLocationId",
                    &param_retailer_location_id.to_string());
            if let Some(param_retailer_location_token) = param_retailer_location_token {
                query_string.append_pair("retailerLocationToken",
                    &param_retailer_location_token);
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::RetailerLocationResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetRetailerLocationResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_retailer_location_consumer(
        &self,
        param_version: f64,
        param_retailer_location_id: i64,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        context: &C) -> Result<GetRetailerLocationConsumerResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/location/get",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
                query_string.append_pair("retailerLocationId",
                    &param_retailer_location_id.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::RetailerLocationResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetRetailerLocationConsumerResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn indexed_retailer_location_distance_search(
        &self,
        param_version: f64,
        param_latitude: f64,
        param_longitude: f64,
        param_search_range: f64,
        param_start: i32,
        param_limit: i32,
        param_account_id: Option<i64>,
        param_address: Option<String>,
        param_has_offers: Option<bool>,
        param_categories: Option<String>,
        param_filters: Option<String>,
        param_audiences: Option<String>,
        param_retailer_ids: Option<String>,
        param_retailer_location_ids: Option<String>,
        param_tags: Option<String>,
        param_location_type: Option<String>,
        param_sort_field: Option<String>,
        param_descending: Option<bool>,
        param_q: Option<String>,
        param_keyword: Option<String>,
        param_keyword_operator: Option<String>,
        param_search_expression: Option<String>,
        param_distance_unit: Option<models::SearchOffersForConsumerDistanceUnitParameter>,
        param_return_favorited: Option<bool>,
        param_return_retailer: Option<bool>,
        param_return_assets: Option<bool>,
        param_return_offers: Option<bool>,
        param_return_categories: Option<bool>,
        param_return_filters: Option<bool>,
        param_return_audiences: Option<bool>,
        param_return_qr_code: Option<bool>,
        param_return_external_category_data: Option<bool>,
        param_include_favorite: Option<bool>,
        param_include_liked: Option<bool>,
        param_include_rating: Option<bool>,
        context: &C) -> Result<IndexedRetailerLocationDistanceSearchResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/retailer/location/idistancesearch",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("latitude",
                    &param_latitude.to_string());
                query_string.append_pair("longitude",
                    &param_longitude.to_string());
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_address) = param_address {
                query_string.append_pair("address",
                    &param_address);
            }
                query_string.append_pair("searchRange",
                    &param_search_range.to_string());
                query_string.append_pair("start",
                    &param_start.to_string());
                query_string.append_pair("limit",
                    &param_limit.to_string());
            if let Some(param_has_offers) = param_has_offers {
                query_string.append_pair("hasOffers",
                    &param_has_offers.to_string());
            }
            if let Some(param_categories) = param_categories {
                query_string.append_pair("categories",
                    &param_categories);
            }
            if let Some(param_filters) = param_filters {
                query_string.append_pair("filters",
                    &param_filters);
            }
            if let Some(param_audiences) = param_audiences {
                query_string.append_pair("audiences",
                    &param_audiences);
            }
            if let Some(param_retailer_ids) = param_retailer_ids {
                query_string.append_pair("retailerIds",
                    &param_retailer_ids);
            }
            if let Some(param_retailer_location_ids) = param_retailer_location_ids {
                query_string.append_pair("retailerLocationIds",
                    &param_retailer_location_ids);
            }
            if let Some(param_tags) = param_tags {
                query_string.append_pair("tags",
                    &param_tags);
            }
            if let Some(param_location_type) = param_location_type {
                query_string.append_pair("locationType",
                    &param_location_type);
            }
            if let Some(param_sort_field) = param_sort_field {
                query_string.append_pair("sortField",
                    &param_sort_field);
            }
            if let Some(param_descending) = param_descending {
                query_string.append_pair("descending",
                    &param_descending.to_string());
            }
            if let Some(param_q) = param_q {
                query_string.append_pair("q",
                    &param_q);
            }
            if let Some(param_keyword) = param_keyword {
                query_string.append_pair("keyword",
                    &param_keyword);
            }
            if let Some(param_keyword_operator) = param_keyword_operator {
                query_string.append_pair("keywordOperator",
                    &param_keyword_operator);
            }
            if let Some(param_search_expression) = param_search_expression {
                query_string.append_pair("searchExpression",
                    &param_search_expression);
            }
            if let Some(param_distance_unit) = param_distance_unit {
                query_string.append_pair("distanceUnit",
                    &param_distance_unit.to_string());
            }
            if let Some(param_return_favorited) = param_return_favorited {
                query_string.append_pair("returnFavorited",
                    &param_return_favorited.to_string());
            }
            if let Some(param_return_retailer) = param_return_retailer {
                query_string.append_pair("returnRetailer",
                    &param_return_retailer.to_string());
            }
            if let Some(param_return_assets) = param_return_assets {
                query_string.append_pair("returnAssets",
                    &param_return_assets.to_string());
            }
            if let Some(param_return_offers) = param_return_offers {
                query_string.append_pair("returnOffers",
                    &param_return_offers.to_string());
            }
            if let Some(param_return_categories) = param_return_categories {
                query_string.append_pair("returnCategories",
                    &param_return_categories.to_string());
            }
            if let Some(param_return_filters) = param_return_filters {
                query_string.append_pair("returnFilters",
                    &param_return_filters.to_string());
            }
            if let Some(param_return_audiences) = param_return_audiences {
                query_string.append_pair("returnAudiences",
                    &param_return_audiences.to_string());
            }
            if let Some(param_return_qr_code) = param_return_qr_code {
                query_string.append_pair("returnQrCode",
                    &param_return_qr_code.to_string());
            }
            if let Some(param_return_external_category_data) = param_return_external_category_data {
                query_string.append_pair("returnExternalCategoryData",
                    &param_return_external_category_data.to_string());
            }
            if let Some(param_include_favorite) = param_include_favorite {
                query_string.append_pair("includeFavorite",
                    &param_include_favorite.to_string());
            }
            if let Some(param_include_liked) = param_include_liked {
                query_string.append_pair("includeLiked",
                    &param_include_liked.to_string());
            }
            if let Some(param_include_rating) = param_include_rating {
                query_string.append_pair("includeRating",
                    &param_include_rating.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<Vec<models::RetailerLocationResponse>>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(IndexedRetailerLocationDistanceSearchResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn indexed_retailer_location_search(
        &self,
        param_version: f64,
        param_account_id: Option<i64>,
        param_start: Option<i32>,
        param_limit: Option<i32>,
        param_has_offers: Option<bool>,
        param_categories: Option<String>,
        param_filters: Option<String>,
        param_audiences: Option<String>,
        param_retailer_ids: Option<String>,
        param_retailer_location_ids: Option<String>,
        param_tags: Option<String>,
        param_location_type: Option<String>,
        param_sort_field: Option<String>,
        param_descending: Option<bool>,
        param_q: Option<String>,
        param_keyword: Option<String>,
        param_keyword_operator: Option<String>,
        param_search_expression: Option<String>,
        param_return_retailer: Option<bool>,
        param_return_assets: Option<bool>,
        param_return_offers: Option<bool>,
        param_return_categories: Option<bool>,
        param_return_filters: Option<bool>,
        param_return_audiences: Option<bool>,
        param_return_qr_code: Option<bool>,
        param_return_external_category_data: Option<bool>,
        param_include_favorite: Option<bool>,
        param_include_liked: Option<bool>,
        param_include_rating: Option<bool>,
        context: &C) -> Result<IndexedRetailerLocationSearchResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/retailer/location/isearch",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_start) = param_start {
                query_string.append_pair("start",
                    &param_start.to_string());
            }
            if let Some(param_limit) = param_limit {
                query_string.append_pair("limit",
                    &param_limit.to_string());
            }
            if let Some(param_has_offers) = param_has_offers {
                query_string.append_pair("hasOffers",
                    &param_has_offers.to_string());
            }
            if let Some(param_categories) = param_categories {
                query_string.append_pair("categories",
                    &param_categories);
            }
            if let Some(param_filters) = param_filters {
                query_string.append_pair("filters",
                    &param_filters);
            }
            if let Some(param_audiences) = param_audiences {
                query_string.append_pair("audiences",
                    &param_audiences);
            }
            if let Some(param_retailer_ids) = param_retailer_ids {
                query_string.append_pair("retailerIds",
                    &param_retailer_ids);
            }
            if let Some(param_retailer_location_ids) = param_retailer_location_ids {
                query_string.append_pair("retailerLocationIds",
                    &param_retailer_location_ids);
            }
            if let Some(param_tags) = param_tags {
                query_string.append_pair("tags",
                    &param_tags);
            }
            if let Some(param_location_type) = param_location_type {
                query_string.append_pair("locationType",
                    &param_location_type);
            }
            if let Some(param_sort_field) = param_sort_field {
                query_string.append_pair("sortField",
                    &param_sort_field);
            }
            if let Some(param_descending) = param_descending {
                query_string.append_pair("descending",
                    &param_descending.to_string());
            }
            if let Some(param_q) = param_q {
                query_string.append_pair("q",
                    &param_q);
            }
            if let Some(param_keyword) = param_keyword {
                query_string.append_pair("keyword",
                    &param_keyword);
            }
            if let Some(param_keyword_operator) = param_keyword_operator {
                query_string.append_pair("keywordOperator",
                    &param_keyword_operator);
            }
            if let Some(param_search_expression) = param_search_expression {
                query_string.append_pair("searchExpression",
                    &param_search_expression);
            }
            if let Some(param_return_retailer) = param_return_retailer {
                query_string.append_pair("returnRetailer",
                    &param_return_retailer.to_string());
            }
            if let Some(param_return_assets) = param_return_assets {
                query_string.append_pair("returnAssets",
                    &param_return_assets.to_string());
            }
            if let Some(param_return_offers) = param_return_offers {
                query_string.append_pair("returnOffers",
                    &param_return_offers.to_string());
            }
            if let Some(param_return_categories) = param_return_categories {
                query_string.append_pair("returnCategories",
                    &param_return_categories.to_string());
            }
            if let Some(param_return_filters) = param_return_filters {
                query_string.append_pair("returnFilters",
                    &param_return_filters.to_string());
            }
            if let Some(param_return_audiences) = param_return_audiences {
                query_string.append_pair("returnAudiences",
                    &param_return_audiences.to_string());
            }
            if let Some(param_return_qr_code) = param_return_qr_code {
                query_string.append_pair("returnQrCode",
                    &param_return_qr_code.to_string());
            }
            if let Some(param_return_external_category_data) = param_return_external_category_data {
                query_string.append_pair("returnExternalCategoryData",
                    &param_return_external_category_data.to_string());
            }
            if let Some(param_include_favorite) = param_include_favorite {
                query_string.append_pair("includeFavorite",
                    &param_include_favorite.to_string());
            }
            if let Some(param_include_liked) = param_include_liked {
                query_string.append_pair("includeLiked",
                    &param_include_liked.to_string());
            }
            if let Some(param_include_rating) = param_include_rating {
                query_string.append_pair("includeRating",
                    &param_include_rating.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<Vec<models::RetailerLocationResponse>>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(IndexedRetailerLocationSearchResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn search_retailer_locations(
        &self,
        param_version: f64,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_q: Option<String>,
        param_keyword: Option<String>,
        param_retailer_ids: Option<String>,
        param_retailer_location_ids: Option<String>,
        param_location_type: Option<String>,
        param_sort_field: Option<models::SearchRetailerLocationsSortFieldParameter>,
        param_descending: Option<bool>,
        param__i: Option<i32>,
        param_start: Option<i32>,
        param__l: Option<i32>,
        param_limit: Option<i32>,
        param_show_public_locations: Option<bool>,
        param_active_only: Option<bool>,
        param_return_retailer: Option<bool>,
        param_return_assets: Option<bool>,
        param_return_offers: Option<bool>,
        param_return_categories: Option<bool>,
        param_return_filters: Option<bool>,
        param_return_audiences: Option<bool>,
        param_return_qr_code: Option<bool>,
        param_include_favorite: Option<bool>,
        param_include_liked: Option<bool>,
        param_include_rating: Option<bool>,
        context: &C) -> Result<SearchRetailerLocationsResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/retailer/location/search",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_q) = param_q {
                query_string.append_pair("q",
                    &param_q);
            }
            if let Some(param_keyword) = param_keyword {
                query_string.append_pair("keyword",
                    &param_keyword);
            }
            if let Some(param_retailer_ids) = param_retailer_ids {
                query_string.append_pair("retailerIds",
                    &param_retailer_ids);
            }
            if let Some(param_retailer_location_ids) = param_retailer_location_ids {
                query_string.append_pair("retailerLocationIds",
                    &param_retailer_location_ids);
            }
            if let Some(param_location_type) = param_location_type {
                query_string.append_pair("locationType",
                    &param_location_type);
            }
            if let Some(param_sort_field) = param_sort_field {
                query_string.append_pair("sortField",
                    &param_sort_field.to_string());
            }
            if let Some(param_descending) = param_descending {
                query_string.append_pair("descending",
                    &param_descending.to_string());
            }
            if let Some(param__i) = param__i {
                query_string.append_pair("_i",
                    &param__i.to_string());
            }
            if let Some(param_start) = param_start {
                query_string.append_pair("start",
                    &param_start.to_string());
            }
            if let Some(param__l) = param__l {
                query_string.append_pair("_l",
                    &param__l.to_string());
            }
            if let Some(param_limit) = param_limit {
                query_string.append_pair("limit",
                    &param_limit.to_string());
            }
            if let Some(param_show_public_locations) = param_show_public_locations {
                query_string.append_pair("showPublicLocations",
                    &param_show_public_locations.to_string());
            }
            if let Some(param_active_only) = param_active_only {
                query_string.append_pair("activeOnly",
                    &param_active_only.to_string());
            }
            if let Some(param_return_retailer) = param_return_retailer {
                query_string.append_pair("returnRetailer",
                    &param_return_retailer.to_string());
            }
            if let Some(param_return_assets) = param_return_assets {
                query_string.append_pair("returnAssets",
                    &param_return_assets.to_string());
            }
            if let Some(param_return_offers) = param_return_offers {
                query_string.append_pair("returnOffers",
                    &param_return_offers.to_string());
            }
            if let Some(param_return_categories) = param_return_categories {
                query_string.append_pair("returnCategories",
                    &param_return_categories.to_string());
            }
            if let Some(param_return_filters) = param_return_filters {
                query_string.append_pair("returnFilters",
                    &param_return_filters.to_string());
            }
            if let Some(param_return_audiences) = param_return_audiences {
                query_string.append_pair("returnAudiences",
                    &param_return_audiences.to_string());
            }
            if let Some(param_return_qr_code) = param_return_qr_code {
                query_string.append_pair("returnQrCode",
                    &param_return_qr_code.to_string());
            }
            if let Some(param_include_favorite) = param_include_favorite {
                query_string.append_pair("includeFavorite",
                    &param_include_favorite.to_string());
            }
            if let Some(param_include_liked) = param_include_liked {
                query_string.append_pair("includeLiked",
                    &param_include_liked.to_string());
            }
            if let Some(param_include_rating) = param_include_rating {
                query_string.append_pair("includeRating",
                    &param_include_rating.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<Vec<models::RetailerLocationResponse>>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(SearchRetailerLocationsResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn update_retailer_locations(
        &self,
        param_version: f64,
        param_retailer_location_id: i64,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_name: Option<String>,
        param_street_address: Option<String>,
        param_street_address2: Option<String>,
        param_city: Option<String>,
        param_state: Option<String>,
        param_postal_code: Option<String>,
        param_country: Option<String>,
        param_business_phone: Option<String>,
        param_business_phone_ext: Option<String>,
        param_website: Option<String>,
        param_email: Option<String>,
        param_internal_id: Option<String>,
        param_details_header: Option<String>,
        param_details_body: Option<String>,
        param_hours: Option<String>,
        param_logo: Option<swagger::ByteArray>,
        param_logo_asset_id: Option<i64>,
        param_picture1: Option<swagger::ByteArray>,
        param_picture1_asset_id: Option<i64>,
        param_picture2: Option<swagger::ByteArray>,
        param_picture2_asset_id: Option<i64>,
        param_category_ids: Option<String>,
        param_filter_ids: Option<String>,
        param_latitude: Option<f64>,
        param_longitude: Option<f64>,
        param_building: Option<String>,
        param_google_place_id: Option<String>,
        param_yelp_id: Option<String>,
        param_meta_data: Option<String>,
        param_payment_provider: Option<String>,
        param_active: Option<bool>,
        param_public_location: Option<bool>,
        param_location_type: Option<String>,
        param_audience_ids: Option<String>,
        param_audience_ids_to_add: Option<String>,
        param_audience_ids_to_remove: Option<String>,
        param_response_format: Option<models::AggregatedFilteredUsageResponseFormatParameter>,
        param_tags: Option<String>,
        context: &C) -> Result<UpdateRetailerLocationsResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/retailer/location/update",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
                query_string.append_pair("retailerLocationId",
                    &param_retailer_location_id.to_string());
            if let Some(param_name) = param_name {
                query_string.append_pair("name",
                    &param_name);
            }
            if let Some(param_street_address) = param_street_address {
                query_string.append_pair("streetAddress",
                    &param_street_address);
            }
            if let Some(param_street_address2) = param_street_address2 {
                query_string.append_pair("streetAddress2",
                    &param_street_address2);
            }
            if let Some(param_city) = param_city {
                query_string.append_pair("city",
                    &param_city);
            }
            if let Some(param_state) = param_state {
                query_string.append_pair("state",
                    &param_state);
            }
            if let Some(param_postal_code) = param_postal_code {
                query_string.append_pair("postalCode",
                    &param_postal_code);
            }
            if let Some(param_country) = param_country {
                query_string.append_pair("country",
                    &param_country);
            }
            if let Some(param_business_phone) = param_business_phone {
                query_string.append_pair("businessPhone",
                    &param_business_phone);
            }
            if let Some(param_business_phone_ext) = param_business_phone_ext {
                query_string.append_pair("businessPhoneExt",
                    &param_business_phone_ext);
            }
            if let Some(param_website) = param_website {
                query_string.append_pair("website",
                    &param_website);
            }
            if let Some(param_email) = param_email {
                query_string.append_pair("email",
                    &param_email);
            }
            if let Some(param_internal_id) = param_internal_id {
                query_string.append_pair("internalId",
                    &param_internal_id);
            }
            if let Some(param_details_header) = param_details_header {
                query_string.append_pair("detailsHeader",
                    &param_details_header);
            }
            if let Some(param_details_body) = param_details_body {
                query_string.append_pair("detailsBody",
                    &param_details_body);
            }
            if let Some(param_hours) = param_hours {
                query_string.append_pair("hours",
                    &param_hours);
            }
            if let Some(param_logo) = param_logo {
                query_string.append_pair("logo",
                    &param_logo.to_string());
            }
            if let Some(param_logo_asset_id) = param_logo_asset_id {
                query_string.append_pair("logoAssetId",
                    &param_logo_asset_id.to_string());
            }
            if let Some(param_picture1) = param_picture1 {
                query_string.append_pair("picture1",
                    &param_picture1.to_string());
            }
            if let Some(param_picture1_asset_id) = param_picture1_asset_id {
                query_string.append_pair("picture1AssetId",
                    &param_picture1_asset_id.to_string());
            }
            if let Some(param_picture2) = param_picture2 {
                query_string.append_pair("picture2",
                    &param_picture2.to_string());
            }
            if let Some(param_picture2_asset_id) = param_picture2_asset_id {
                query_string.append_pair("picture2AssetId",
                    &param_picture2_asset_id.to_string());
            }
            if let Some(param_category_ids) = param_category_ids {
                query_string.append_pair("categoryIds",
                    &param_category_ids);
            }
            if let Some(param_filter_ids) = param_filter_ids {
                query_string.append_pair("filterIds",
                    &param_filter_ids);
            }
            if let Some(param_latitude) = param_latitude {
                query_string.append_pair("latitude",
                    &param_latitude.to_string());
            }
            if let Some(param_longitude) = param_longitude {
                query_string.append_pair("longitude",
                    &param_longitude.to_string());
            }
            if let Some(param_building) = param_building {
                query_string.append_pair("building",
                    &param_building);
            }
            if let Some(param_google_place_id) = param_google_place_id {
                query_string.append_pair("googlePlaceId",
                    &param_google_place_id);
            }
            if let Some(param_yelp_id) = param_yelp_id {
                query_string.append_pair("yelpId",
                    &param_yelp_id);
            }
            if let Some(param_meta_data) = param_meta_data {
                query_string.append_pair("metaData",
                    &param_meta_data);
            }
            if let Some(param_payment_provider) = param_payment_provider {
                query_string.append_pair("paymentProvider",
                    &param_payment_provider);
            }
            if let Some(param_active) = param_active {
                query_string.append_pair("active",
                    &param_active.to_string());
            }
            if let Some(param_public_location) = param_public_location {
                query_string.append_pair("publicLocation",
                    &param_public_location.to_string());
            }
            if let Some(param_location_type) = param_location_type {
                query_string.append_pair("locationType",
                    &param_location_type);
            }
            if let Some(param_audience_ids) = param_audience_ids {
                query_string.append_pair("audienceIds",
                    &param_audience_ids);
            }
            if let Some(param_audience_ids_to_add) = param_audience_ids_to_add {
                query_string.append_pair("audienceIdsToAdd",
                    &param_audience_ids_to_add);
            }
            if let Some(param_audience_ids_to_remove) = param_audience_ids_to_remove {
                query_string.append_pair("audienceIdsToRemove",
                    &param_audience_ids_to_remove);
            }
            if let Some(param_response_format) = param_response_format {
                query_string.append_pair("responseFormat",
                    &param_response_format.to_string());
            }
            if let Some(param_tags) = param_tags {
                query_string.append_pair("tags",
                    &param_tags);
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::RetailerLocationResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(UpdateRetailerLocationsResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_retaokiler(
        &self,
        param_version: f64,
        param_retailer_id: i64,
        param_active_only: bool,
        param_keyword: Option<String>,
        param_sort_field: Option<String>,
        param_start: Option<i64>,
        param_limit: Option<i64>,
        context: &C) -> Result<GetRetaokilerResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/retailer",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_keyword) = param_keyword {
                query_string.append_pair("keyword",
                    &param_keyword);
            }
            if let Some(param_sort_field) = param_sort_field {
                query_string.append_pair("sortField",
                    &param_sort_field);
            }
            if let Some(param_start) = param_start {
                query_string.append_pair("start",
                    &param_start.to_string());
            }
            if let Some(param_limit) = param_limit {
                query_string.append_pair("limit",
                    &param_limit.to_string());
            }
                query_string.append_pair("retailerId",
                    &param_retailer_id.to_string());
                query_string.append_pair("activeOnly",
                    &param_active_only.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetRetaokilerResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn create_route(
        &self,
        param_version: f64,
        param_body: Option<models::Route>,
        context: &C) -> Result<CreateRouteResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/route",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        // Consumes basic body
        // Body parameter
        if let Some(param_body) = param_body {
        let body = serde_json::to_string(&param_body).expect("impossible to fail to serialize");
        *request.body_mut() = body_from_string(body);
        }

        let header = "application/json";
        request.headers_mut().insert(CONTENT_TYPE, HeaderValue::from_static(header));

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::Route>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(CreateRouteResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn search_routes(
        &self,
        param_version: f64,
        param_sort_field: String,
        param_descending: bool,
        param_start: i32,
        param_limit: i32,
        param_active_only: bool,
        param_includes_empty: bool,
        param_root_only: bool,
        param_show_inherited_properties: bool,
        param_hub_id: Option<i64>,
        param_program_id: Option<i64>,
        param_scheduled_start: Option<i64>,
        param_scheduled_end: Option<i64>,
        param_updated_start: Option<i64>,
        param_updated_end: Option<i64>,
        param_featured: Option<bool>,
        param_seat_count: Option<i32>,
        param_approved: Option<bool>,
        param_started: Option<bool>,
        param_completed: Option<bool>,
        param_valid: Option<bool>,
        param_parent_id: Option<i64>,
        context: &C) -> Result<SearchRoutesResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/route",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_hub_id) = param_hub_id {
                query_string.append_pair("hubId",
                    &param_hub_id.to_string());
            }
            if let Some(param_program_id) = param_program_id {
                query_string.append_pair("programId",
                    &param_program_id.to_string());
            }
            if let Some(param_scheduled_start) = param_scheduled_start {
                query_string.append_pair("scheduledStart",
                    &param_scheduled_start.to_string());
            }
            if let Some(param_scheduled_end) = param_scheduled_end {
                query_string.append_pair("scheduledEnd",
                    &param_scheduled_end.to_string());
            }
            if let Some(param_updated_start) = param_updated_start {
                query_string.append_pair("updatedStart",
                    &param_updated_start.to_string());
            }
            if let Some(param_updated_end) = param_updated_end {
                query_string.append_pair("updatedEnd",
                    &param_updated_end.to_string());
            }
            if let Some(param_featured) = param_featured {
                query_string.append_pair("featured",
                    &param_featured.to_string());
            }
            if let Some(param_seat_count) = param_seat_count {
                query_string.append_pair("seatCount",
                    &param_seat_count.to_string());
            }
            if let Some(param_approved) = param_approved {
                query_string.append_pair("approved",
                    &param_approved.to_string());
            }
            if let Some(param_started) = param_started {
                query_string.append_pair("started",
                    &param_started.to_string());
            }
            if let Some(param_completed) = param_completed {
                query_string.append_pair("completed",
                    &param_completed.to_string());
            }
            if let Some(param_valid) = param_valid {
                query_string.append_pair("valid",
                    &param_valid.to_string());
            }
            if let Some(param_parent_id) = param_parent_id {
                query_string.append_pair("parentId",
                    &param_parent_id.to_string());
            }
                query_string.append_pair("sortField",
                    &param_sort_field);
                query_string.append_pair("descending",
                    &param_descending.to_string());
                query_string.append_pair("start",
                    &param_start.to_string());
                query_string.append_pair("limit",
                    &param_limit.to_string());
                query_string.append_pair("activeOnly",
                    &param_active_only.to_string());
                query_string.append_pair("includesEmpty",
                    &param_includes_empty.to_string());
                query_string.append_pair("rootOnly",
                    &param_root_only.to_string());
                query_string.append_pair("showInheritedProperties",
                    &param_show_inherited_properties.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<Vec<models::Route>>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(SearchRoutesResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn approve_route(
        &self,
        param_version: f64,
        param_route_id: i64,
        context: &C) -> Result<ApproveRouteResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/route/{route_id}/approve",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
            ,route_id=utf8_percent_encode(&param_route_id.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::Route>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(ApproveRouteResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn copy_route(
        &self,
        param_version: f64,
        param_route_id: i64,
        param_body: Option<models::Route>,
        context: &C) -> Result<CopyRouteResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/route/{route_id}/copy",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
            ,route_id=utf8_percent_encode(&param_route_id.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        // Consumes basic body
        // Body parameter
        if let Some(param_body) = param_body {
        let body = serde_json::to_string(&param_body).expect("impossible to fail to serialize");
        *request.body_mut() = body_from_string(body);
        }

        let header = "application/json";
        request.headers_mut().insert(CONTENT_TYPE, HeaderValue::from_static(header));

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::Route>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(CopyRouteResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn create_route_directions(
        &self,
        param_version: f64,
        param_route_id: i64,
        context: &C) -> Result<CreateRouteDirectionsResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/route/{route_id}/directions",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
            ,route_id=utf8_percent_encode(&param_route_id.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("PUT")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<Vec<models::Direction>>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(CreateRouteDirectionsResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn create_route_polyline(
        &self,
        param_version: f64,
        param_route_id: i64,
        context: &C) -> Result<CreateRoutePolylineResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/route/{route_id}/polyline",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
            ,route_id=utf8_percent_encode(&param_route_id.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("PUT")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::Route>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(CreateRoutePolylineResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn delete_route(
        &self,
        param_version: f64,
        param_route_id: i64,
        context: &C) -> Result<DeleteRouteResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/route/{route_id}",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
            ,route_id=utf8_percent_encode(&param_route_id.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("DELETE")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            0 => {
                Ok(
                    DeleteRouteResponse::SuccessfulOperation
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn disapprove_route(
        &self,
        param_version: f64,
        param_route_id: i64,
        context: &C) -> Result<DisapproveRouteResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/route/{route_id}/disapprove",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
            ,route_id=utf8_percent_encode(&param_route_id.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::Route>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(DisapproveRouteResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_route(
        &self,
        param_version: f64,
        param_route_id: i64,
        param_show_inherited_properties: bool,
        context: &C) -> Result<GetRouteResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/route/{route_id}",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
            ,route_id=utf8_percent_encode(&param_route_id.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("showInheritedProperties",
                    &param_show_inherited_properties.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::Route>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetRouteResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_route_directions(
        &self,
        param_version: f64,
        param_route_id: i64,
        context: &C) -> Result<GetRouteDirectionsResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/route/{route_id}/directions",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
            ,route_id=utf8_percent_encode(&param_route_id.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<Vec<models::Direction>>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetRouteDirectionsResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_route_shipments(
        &self,
        param_version: f64,
        param_route_id: i64,
        context: &C) -> Result<GetRouteShipmentsResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/route/{route_id}/shipments",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
            ,route_id=utf8_percent_encode(&param_route_id.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<Vec<models::Shipment>>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetRouteShipmentsResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_route_stops(
        &self,
        param_version: f64,
        param_route_id: i64,
        param_confirmed_only: bool,
        context: &C) -> Result<GetRouteStopsResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/route/{route_id}/stops",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
            ,route_id=utf8_percent_encode(&param_route_id.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("confirmedOnly",
                    &param_confirmed_only.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<Vec<models::Stop>>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetRouteStopsResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn optimize_route(
        &self,
        param_version: f64,
        param_route_id: i64,
        context: &C) -> Result<OptimizeRouteResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/route/{route_id}/optimize",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
            ,route_id=utf8_percent_encode(&param_route_id.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            0 => {
                Ok(
                    OptimizeRouteResponse::SuccessfulOperation
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn reorder_route_stops_patch<'a>(
        &self,
        param_version: f64,
        param_route_id: i64,
        param_body: Option<&'a Vec<models::Stop>>,
        context: &C) -> Result<ReorderRouteStopsPatchResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/route/{route_id}/stops/reorder",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
            ,route_id=utf8_percent_encode(&param_route_id.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("PATCH")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        // Consumes basic body
        // Body parameter
        if let Some(param_body) = param_body {
        let body = serde_json::to_string(&param_body).expect("impossible to fail to serialize");
        *request.body_mut() = body_from_string(body);
        }

        let header = "application/json";
        request.headers_mut().insert(CONTENT_TYPE, HeaderValue::from_static(header));

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<Vec<models::Stop>>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(ReorderRouteStopsPatchResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn reorder_route_stops_post<'a>(
        &self,
        param_version: f64,
        param_route_id: i64,
        param_body: Option<&'a Vec<models::Stop>>,
        context: &C) -> Result<ReorderRouteStopsPostResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/route/{route_id}/stops/reorder",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
            ,route_id=utf8_percent_encode(&param_route_id.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        // Consumes basic body
        // Body parameter
        if let Some(param_body) = param_body {
        let body = serde_json::to_string(&param_body).expect("impossible to fail to serialize");
        *request.body_mut() = body_from_string(body);
        }

        let header = "application/json";
        request.headers_mut().insert(CONTENT_TYPE, HeaderValue::from_static(header));

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<Vec<models::Stop>>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(ReorderRouteStopsPostResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn update_route(
        &self,
        param_version: f64,
        param_route_id: i64,
        param_body: Option<models::Route>,
        context: &C) -> Result<UpdateRouteResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/route/{route_id}",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
            ,route_id=utf8_percent_encode(&param_route_id.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("PUT")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        // Consumes basic body
        // Body parameter
        if let Some(param_body) = param_body {
        let body = serde_json::to_string(&param_body).expect("impossible to fail to serialize");
        *request.body_mut() = body_from_string(body);
        }

        let header = "application/json";
        request.headers_mut().insert(CONTENT_TYPE, HeaderValue::from_static(header));

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::Route>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(UpdateRouteResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_route_stop(
        &self,
        param_version: f64,
        param_route_id: i64,
        param_stop_id: i64,
        context: &C) -> Result<GetRouteStopResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/route/{route_id}/stop/{stop_id}",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
            ,route_id=utf8_percent_encode(&param_route_id.to_string(), ID_ENCODE_SET)
            ,stop_id=utf8_percent_encode(&param_stop_id.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::Stop>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetRouteStopResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_shipments_at_stop(
        &self,
        param_version: f64,
        param_route_id: i64,
        param_stop_id: i64,
        context: &C) -> Result<GetShipmentsAtStopResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/route/{route_id}/stop/{stop_id}/shipments",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
            ,route_id=utf8_percent_encode(&param_route_id.to_string(), ID_ENCODE_SET)
            ,stop_id=utf8_percent_encode(&param_stop_id.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<Vec<models::Shipment>>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetShipmentsAtStopResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn remove_stop(
        &self,
        param_version: f64,
        param_route_id: i64,
        param_stop_id: i64,
        context: &C) -> Result<RemoveStopResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/route/{route_id}/stop/{stop_id}",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
            ,route_id=utf8_percent_encode(&param_route_id.to_string(), ID_ENCODE_SET)
            ,stop_id=utf8_percent_encode(&param_stop_id.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("DELETE")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            0 => {
                Ok(
                    RemoveStopResponse::SuccessfulOperation
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn set_driver(
        &self,
        param_version: f64,
        param_id: i64,
        param_driver_id: i64,
        context: &C) -> Result<SetDriverResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/route/{id}/driver/{driver_id}",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
            ,id=utf8_percent_encode(&param_id.to_string(), ID_ENCODE_SET)
            ,driver_id=utf8_percent_encode(&param_driver_id.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            0 => {
                Ok(
                    SetDriverResponse::SuccessfulOperation
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn update_route_stop(
        &self,
        param_version: f64,
        param_route_id: i64,
        param_stop_id: i64,
        param_body: Option<models::Stop>,
        context: &C) -> Result<UpdateRouteStopResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/route/{route_id}/stop/{stop_id}",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
            ,route_id=utf8_percent_encode(&param_route_id.to_string(), ID_ENCODE_SET)
            ,stop_id=utf8_percent_encode(&param_stop_id.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("PUT")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        // Consumes basic body
        // Body parameter
        if let Some(param_body) = param_body {
        let body = serde_json::to_string(&param_body).expect("impossible to fail to serialize");
        *request.body_mut() = body_from_string(body);
        }

        let header = "application/json";
        request.headers_mut().insert(CONTENT_TYPE, HeaderValue::from_static(header));

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            0 => {
                Ok(
                    UpdateRouteStopResponse::SuccessfulOperation
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn create_route_settings(
        &self,
        param_version: f64,
        param_body: Option<models::RouteSettings>,
        context: &C) -> Result<CreateRouteSettingsResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/route/setting",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        // Consumes basic body
        // Body parameter
        if let Some(param_body) = param_body {
        let body = serde_json::to_string(&param_body).expect("impossible to fail to serialize");
        *request.body_mut() = body_from_string(body);
        }

        let header = "application/json";
        request.headers_mut().insert(CONTENT_TYPE, HeaderValue::from_static(header));

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::RouteSettings>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(CreateRouteSettingsResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn search_route_settings(
        &self,
        param_version: f64,
        param_sort_field: String,
        param_descending: bool,
        param_start: i32,
        param_limit: i32,
        param_active_only: bool,
        param_hub_id: Option<i64>,
        param_program_id: Option<i64>,
        param_keyword: Option<String>,
        context: &C) -> Result<SearchRouteSettingsResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/route/setting",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_hub_id) = param_hub_id {
                query_string.append_pair("hubId",
                    &param_hub_id.to_string());
            }
            if let Some(param_program_id) = param_program_id {
                query_string.append_pair("programId",
                    &param_program_id.to_string());
            }
            if let Some(param_keyword) = param_keyword {
                query_string.append_pair("keyword",
                    &param_keyword);
            }
                query_string.append_pair("sortField",
                    &param_sort_field);
                query_string.append_pair("descending",
                    &param_descending.to_string());
                query_string.append_pair("start",
                    &param_start.to_string());
                query_string.append_pair("limit",
                    &param_limit.to_string());
                query_string.append_pair("activeOnly",
                    &param_active_only.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<Vec<models::RouteSettings>>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(SearchRouteSettingsResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn delete_route_settings(
        &self,
        param_version: f64,
        param_route_settings_id: i64,
        context: &C) -> Result<DeleteRouteSettingsResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/route/setting/{route_settings_id}",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
            ,route_settings_id=utf8_percent_encode(&param_route_settings_id.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("DELETE")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<serde_json::Value>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(DeleteRouteSettingsResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_route_settings(
        &self,
        param_version: f64,
        param_route_settings_id: i64,
        context: &C) -> Result<GetRouteSettingsResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/route/setting/{route_settings_id}",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
            ,route_settings_id=utf8_percent_encode(&param_route_settings_id.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::RouteSettings>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetRouteSettingsResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn update_route_settings(
        &self,
        param_version: f64,
        param_route_settings_id: i64,
        param_body: Option<models::RouteSettings>,
        context: &C) -> Result<UpdateRouteSettingsResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/route/setting/{route_settings_id}",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
            ,route_settings_id=utf8_percent_encode(&param_route_settings_id.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("PUT")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        // Consumes basic body
        // Body parameter
        if let Some(param_body) = param_body {
        let body = serde_json::to_string(&param_body).expect("impossible to fail to serialize");
        *request.body_mut() = body_from_string(body);
        }

        let header = "application/json";
        request.headers_mut().insert(CONTENT_TYPE, HeaderValue::from_static(header));

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::RouteSettings>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(UpdateRouteSettingsResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn compute_routing(
        &self,
        param_version: f64,
        param_data: String,
        context: &C) -> Result<ComputeRoutingResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/routing/compute",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("data",
                    &param_data);
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::RoutingListResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(ComputeRoutingResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn create_scheduled_notification(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_name: String,
        param_param_type: String,
        param_message: String,
        param_content_id: Option<i64>,
        param_content_name: Option<String>,
        param_content_type: Option<String>,
        param_parent_id: Option<i64>,
        param_parent_type: Option<String>,
        param_app_key: Option<String>,
        param_grouping_id: Option<String>,
        param_connection_group_ids: Option<String>,
        param_connection_account_ids: Option<String>,
        param_audience_id: Option<i64>,
        param_audience_ids: Option<String>,
        param_album_ids: Option<String>,
        param_report_id: Option<i64>,
        param_report_params: Option<String>,
        param_endpoint_url: Option<String>,
        param_payload: Option<String>,
        param_scheduled_date: Option<i64>,
        param_start_date: Option<i64>,
        param_end_date: Option<i64>,
        param_cron_expression: Option<String>,
        param_cron_type: Option<String>,
        param_meta_data: Option<String>,
        param_conditional_input: Option<String>,
        param_template_type: Option<String>,
        param_visibility: Option<models::AddAlbumCollectionVisibilityParameter>,
        param_active: Option<bool>,
        param_send_now: Option<bool>,
        param_event_type: Option<String>,
        param_deep_link_uri: Option<String>,
        param_send_to_all: Option<bool>,
        context: &C) -> Result<CreateScheduledNotificationResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/notification/schedule/create",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("name",
                    &param_name);
                query_string.append_pair("type",
                    &param_param_type);
                query_string.append_pair("message",
                    &param_message);
            if let Some(param_content_id) = param_content_id {
                query_string.append_pair("contentId",
                    &param_content_id.to_string());
            }
            if let Some(param_content_name) = param_content_name {
                query_string.append_pair("contentName",
                    &param_content_name);
            }
            if let Some(param_content_type) = param_content_type {
                query_string.append_pair("contentType",
                    &param_content_type);
            }
            if let Some(param_parent_id) = param_parent_id {
                query_string.append_pair("parentId",
                    &param_parent_id.to_string());
            }
            if let Some(param_parent_type) = param_parent_type {
                query_string.append_pair("parentType",
                    &param_parent_type);
            }
            if let Some(param_app_key) = param_app_key {
                query_string.append_pair("appKey",
                    &param_app_key);
            }
            if let Some(param_grouping_id) = param_grouping_id {
                query_string.append_pair("groupingId",
                    &param_grouping_id);
            }
            if let Some(param_connection_group_ids) = param_connection_group_ids {
                query_string.append_pair("connectionGroupIds",
                    &param_connection_group_ids);
            }
            if let Some(param_connection_account_ids) = param_connection_account_ids {
                query_string.append_pair("connectionAccountIds",
                    &param_connection_account_ids);
            }
            if let Some(param_audience_id) = param_audience_id {
                query_string.append_pair("audienceId",
                    &param_audience_id.to_string());
            }
            if let Some(param_audience_ids) = param_audience_ids {
                query_string.append_pair("audienceIds",
                    &param_audience_ids);
            }
            if let Some(param_album_ids) = param_album_ids {
                query_string.append_pair("albumIds",
                    &param_album_ids);
            }
            if let Some(param_report_id) = param_report_id {
                query_string.append_pair("reportId",
                    &param_report_id.to_string());
            }
            if let Some(param_report_params) = param_report_params {
                query_string.append_pair("reportParams",
                    &param_report_params);
            }
            if let Some(param_endpoint_url) = param_endpoint_url {
                query_string.append_pair("endpointURL",
                    &param_endpoint_url);
            }
            if let Some(param_payload) = param_payload {
                query_string.append_pair("payload",
                    &param_payload);
            }
            if let Some(param_scheduled_date) = param_scheduled_date {
                query_string.append_pair("scheduledDate",
                    &param_scheduled_date.to_string());
            }
            if let Some(param_start_date) = param_start_date {
                query_string.append_pair("startDate",
                    &param_start_date.to_string());
            }
            if let Some(param_end_date) = param_end_date {
                query_string.append_pair("endDate",
                    &param_end_date.to_string());
            }
            if let Some(param_cron_expression) = param_cron_expression {
                query_string.append_pair("cronExpression",
                    &param_cron_expression);
            }
            if let Some(param_cron_type) = param_cron_type {
                query_string.append_pair("cronType",
                    &param_cron_type);
            }
            if let Some(param_meta_data) = param_meta_data {
                query_string.append_pair("metaData",
                    &param_meta_data);
            }
            if let Some(param_conditional_input) = param_conditional_input {
                query_string.append_pair("conditionalInput",
                    &param_conditional_input);
            }
            if let Some(param_template_type) = param_template_type {
                query_string.append_pair("templateType",
                    &param_template_type);
            }
            if let Some(param_visibility) = param_visibility {
                query_string.append_pair("visibility",
                    &param_visibility.to_string());
            }
            if let Some(param_active) = param_active {
                query_string.append_pair("active",
                    &param_active.to_string());
            }
            if let Some(param_send_now) = param_send_now {
                query_string.append_pair("sendNow",
                    &param_send_now.to_string());
            }
            if let Some(param_event_type) = param_event_type {
                query_string.append_pair("eventType",
                    &param_event_type);
            }
            if let Some(param_deep_link_uri) = param_deep_link_uri {
                query_string.append_pair("deepLinkURI",
                    &param_deep_link_uri);
            }
            if let Some(param_send_to_all) = param_send_to_all {
                query_string.append_pair("sendToAll",
                    &param_send_to_all.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::ScheduledNotificationFullResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(CreateScheduledNotificationResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn delete_scheduled_notification(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_scheduled_notification_id: i64,
        param_delete_by_grouping_id: Option<bool>,
        context: &C) -> Result<DeleteScheduledNotificationResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/notification/schedule/delete",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("scheduledNotificationId",
                    &param_scheduled_notification_id.to_string());
            if let Some(param_delete_by_grouping_id) = param_delete_by_grouping_id {
                query_string.append_pair("deleteByGroupingId",
                    &param_delete_by_grouping_id.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::ScheduledNotificationFullResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(DeleteScheduledNotificationResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_scheduled_notification(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_scheduled_notification_id: i64,
        context: &C) -> Result<GetScheduledNotificationResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/notification/schedule/get",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("scheduledNotificationId",
                    &param_scheduled_notification_id.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::ScheduledNotificationFullResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetScheduledNotificationResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn schedule_notification_listings(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_app_key: String,
        param_report_name: String,
        param_message: String,
        param_offset: i32,
        param_recipient_report_id: i64,
        param_report_params: Option<String>,
        param_param_type: Option<String>,
        context: &C) -> Result<ScheduleNotificationListingsResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/notification/schedule/generate",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("appKey",
                    &param_app_key);
                query_string.append_pair("reportName",
                    &param_report_name);
            if let Some(param_report_params) = param_report_params {
                query_string.append_pair("reportParams",
                    &param_report_params);
            }
                query_string.append_pair("message",
                    &param_message);
                query_string.append_pair("offset",
                    &param_offset.to_string());
            if let Some(param_param_type) = param_param_type {
                query_string.append_pair("type",
                    &param_param_type);
            }
                query_string.append_pair("recipientReportId",
                    &param_recipient_report_id.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(ScheduleNotificationListingsResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn search_scheduled_notifications(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_grouping_id: Option<String>,
        param_audience_id: Option<i64>,
        param_filter: Option<String>,
        param_types: Option<String>,
        param_content_ids: Option<String>,
        param_content_types: Option<String>,
        param_parent_ids: Option<String>,
        param_parent_types: Option<String>,
        param_statuses: Option<String>,
        param_template_types: Option<String>,
        param_app_key: Option<String>,
        param_keyword: Option<String>,
        param_sort_field: Option<String>,
        param_descending: Option<bool>,
        param_start: Option<i32>,
        param_limit: Option<i32>,
        param_active_only: Option<bool>,
        param_group_by_grouping_id: Option<bool>,
        param_return_audience_account_count: Option<bool>,
        context: &C) -> Result<SearchScheduledNotificationsResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/notification/schedule/search",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            if let Some(param_grouping_id) = param_grouping_id {
                query_string.append_pair("groupingId",
                    &param_grouping_id);
            }
            if let Some(param_audience_id) = param_audience_id {
                query_string.append_pair("audienceId",
                    &param_audience_id.to_string());
            }
            if let Some(param_filter) = param_filter {
                query_string.append_pair("filter",
                    &param_filter);
            }
            if let Some(param_types) = param_types {
                query_string.append_pair("types",
                    &param_types);
            }
            if let Some(param_content_ids) = param_content_ids {
                query_string.append_pair("contentIds",
                    &param_content_ids);
            }
            if let Some(param_content_types) = param_content_types {
                query_string.append_pair("contentTypes",
                    &param_content_types);
            }
            if let Some(param_parent_ids) = param_parent_ids {
                query_string.append_pair("parentIds",
                    &param_parent_ids);
            }
            if let Some(param_parent_types) = param_parent_types {
                query_string.append_pair("parentTypes",
                    &param_parent_types);
            }
            if let Some(param_statuses) = param_statuses {
                query_string.append_pair("statuses",
                    &param_statuses);
            }
            if let Some(param_template_types) = param_template_types {
                query_string.append_pair("templateTypes",
                    &param_template_types);
            }
            if let Some(param_app_key) = param_app_key {
                query_string.append_pair("appKey",
                    &param_app_key);
            }
            if let Some(param_keyword) = param_keyword {
                query_string.append_pair("keyword",
                    &param_keyword);
            }
            if let Some(param_sort_field) = param_sort_field {
                query_string.append_pair("sortField",
                    &param_sort_field);
            }
            if let Some(param_descending) = param_descending {
                query_string.append_pair("descending",
                    &param_descending.to_string());
            }
            if let Some(param_start) = param_start {
                query_string.append_pair("start",
                    &param_start.to_string());
            }
            if let Some(param_limit) = param_limit {
                query_string.append_pair("limit",
                    &param_limit.to_string());
            }
            if let Some(param_active_only) = param_active_only {
                query_string.append_pair("activeOnly",
                    &param_active_only.to_string());
            }
            if let Some(param_group_by_grouping_id) = param_group_by_grouping_id {
                query_string.append_pair("groupByGroupingId",
                    &param_group_by_grouping_id.to_string());
            }
            if let Some(param_return_audience_account_count) = param_return_audience_account_count {
                query_string.append_pair("returnAudienceAccountCount",
                    &param_return_audience_account_count.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::ScheduledNotificationFullResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(SearchScheduledNotificationsResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn update_scheduled_notification(
        &self,
        param_version: f64,
        param_scheduled_notification_id: i64,
        param_account_id: i64,
        param_name: Option<String>,
        param_param_type: Option<String>,
        param_message: Option<String>,
        param_payload: Option<String>,
        param_content_id: Option<i64>,
        param_content_name: Option<String>,
        param_content_type: Option<String>,
        param_parent_id: Option<i64>,
        param_parent_type: Option<String>,
        param_app_key: Option<String>,
        param_grouping_id: Option<String>,
        param_connection_group_ids: Option<String>,
        param_connection_account_ids: Option<String>,
        param_audience_id: Option<i64>,
        param_audience_ids: Option<String>,
        param_album_ids: Option<String>,
        param_report_id: Option<i64>,
        param_report_params: Option<String>,
        param_endpoint_url: Option<String>,
        param_scheduled_date: Option<i64>,
        param_start_date: Option<i64>,
        param_end_date: Option<i64>,
        param_cron_expression: Option<String>,
        param_cron_type: Option<String>,
        param_meta_data: Option<String>,
        param_conditional_input: Option<String>,
        param_template_type: Option<String>,
        param_visibility: Option<models::AddAlbumCollectionVisibilityParameter>,
        param_active: Option<bool>,
        param_error_message: Option<String>,
        param_status: Option<String>,
        param_update_by_grouping_id: Option<bool>,
        param_send_now: Option<bool>,
        param_event_type: Option<String>,
        param_deep_link_uri: Option<String>,
        param_send_to_all: Option<bool>,
        context: &C) -> Result<UpdateScheduledNotificationResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/notification/schedule/update",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("scheduledNotificationId",
                    &param_scheduled_notification_id.to_string());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            if let Some(param_name) = param_name {
                query_string.append_pair("name",
                    &param_name);
            }
            if let Some(param_param_type) = param_param_type {
                query_string.append_pair("type",
                    &param_param_type);
            }
            if let Some(param_message) = param_message {
                query_string.append_pair("message",
                    &param_message);
            }
            if let Some(param_payload) = param_payload {
                query_string.append_pair("payload",
                    &param_payload);
            }
            if let Some(param_content_id) = param_content_id {
                query_string.append_pair("contentId",
                    &param_content_id.to_string());
            }
            if let Some(param_content_name) = param_content_name {
                query_string.append_pair("contentName",
                    &param_content_name);
            }
            if let Some(param_content_type) = param_content_type {
                query_string.append_pair("contentType",
                    &param_content_type);
            }
            if let Some(param_parent_id) = param_parent_id {
                query_string.append_pair("parentId",
                    &param_parent_id.to_string());
            }
            if let Some(param_parent_type) = param_parent_type {
                query_string.append_pair("parentType",
                    &param_parent_type);
            }
            if let Some(param_app_key) = param_app_key {
                query_string.append_pair("appKey",
                    &param_app_key);
            }
            if let Some(param_grouping_id) = param_grouping_id {
                query_string.append_pair("groupingId",
                    &param_grouping_id);
            }
            if let Some(param_connection_group_ids) = param_connection_group_ids {
                query_string.append_pair("connectionGroupIds",
                    &param_connection_group_ids);
            }
            if let Some(param_connection_account_ids) = param_connection_account_ids {
                query_string.append_pair("connectionAccountIds",
                    &param_connection_account_ids);
            }
            if let Some(param_audience_id) = param_audience_id {
                query_string.append_pair("audienceId",
                    &param_audience_id.to_string());
            }
            if let Some(param_audience_ids) = param_audience_ids {
                query_string.append_pair("audienceIds",
                    &param_audience_ids);
            }
            if let Some(param_album_ids) = param_album_ids {
                query_string.append_pair("albumIds",
                    &param_album_ids);
            }
            if let Some(param_report_id) = param_report_id {
                query_string.append_pair("reportId",
                    &param_report_id.to_string());
            }
            if let Some(param_report_params) = param_report_params {
                query_string.append_pair("reportParams",
                    &param_report_params);
            }
            if let Some(param_endpoint_url) = param_endpoint_url {
                query_string.append_pair("endpointURL",
                    &param_endpoint_url);
            }
            if let Some(param_scheduled_date) = param_scheduled_date {
                query_string.append_pair("scheduledDate",
                    &param_scheduled_date.to_string());
            }
            if let Some(param_start_date) = param_start_date {
                query_string.append_pair("startDate",
                    &param_start_date.to_string());
            }
            if let Some(param_end_date) = param_end_date {
                query_string.append_pair("endDate",
                    &param_end_date.to_string());
            }
            if let Some(param_cron_expression) = param_cron_expression {
                query_string.append_pair("cronExpression",
                    &param_cron_expression);
            }
            if let Some(param_cron_type) = param_cron_type {
                query_string.append_pair("cronType",
                    &param_cron_type);
            }
            if let Some(param_meta_data) = param_meta_data {
                query_string.append_pair("metaData",
                    &param_meta_data);
            }
            if let Some(param_conditional_input) = param_conditional_input {
                query_string.append_pair("conditionalInput",
                    &param_conditional_input);
            }
            if let Some(param_template_type) = param_template_type {
                query_string.append_pair("templateType",
                    &param_template_type);
            }
            if let Some(param_visibility) = param_visibility {
                query_string.append_pair("visibility",
                    &param_visibility.to_string());
            }
            if let Some(param_active) = param_active {
                query_string.append_pair("active",
                    &param_active.to_string());
            }
            if let Some(param_error_message) = param_error_message {
                query_string.append_pair("errorMessage",
                    &param_error_message);
            }
            if let Some(param_status) = param_status {
                query_string.append_pair("status",
                    &param_status);
            }
            if let Some(param_update_by_grouping_id) = param_update_by_grouping_id {
                query_string.append_pair("updateByGroupingId",
                    &param_update_by_grouping_id.to_string());
            }
            if let Some(param_send_now) = param_send_now {
                query_string.append_pair("sendNow",
                    &param_send_now.to_string());
            }
            if let Some(param_event_type) = param_event_type {
                query_string.append_pair("eventType",
                    &param_event_type);
            }
            if let Some(param_deep_link_uri) = param_deep_link_uri {
                query_string.append_pair("deepLinkURI",
                    &param_deep_link_uri);
            }
            if let Some(param_send_to_all) = param_send_to_all {
                query_string.append_pair("sendToAll",
                    &param_send_to_all.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::ScheduledNotificationFullResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(UpdateScheduledNotificationResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn create_score(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_app_key: String,
        param_points: i32,
        param_mission_id: Option<i64>,
        param_game_id: Option<i64>,
        param_pack_id: Option<i64>,
        param_game_level_id: Option<i64>,
        param_game_object_id: Option<i64>,
        param_time_taken: Option<i32>,
        param_highest: Option<bool>,
        context: &C) -> Result<CreateScoreResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/score/create",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("appKey",
                    &param_app_key);
            if let Some(param_mission_id) = param_mission_id {
                query_string.append_pair("missionId",
                    &param_mission_id.to_string());
            }
            if let Some(param_game_id) = param_game_id {
                query_string.append_pair("gameId",
                    &param_game_id.to_string());
            }
            if let Some(param_pack_id) = param_pack_id {
                query_string.append_pair("packId",
                    &param_pack_id.to_string());
            }
            if let Some(param_game_level_id) = param_game_level_id {
                query_string.append_pair("gameLevelId",
                    &param_game_level_id.to_string());
            }
            if let Some(param_game_object_id) = param_game_object_id {
                query_string.append_pair("gameObjectId",
                    &param_game_object_id.to_string());
            }
                query_string.append_pair("points",
                    &param_points.to_string());
            if let Some(param_time_taken) = param_time_taken {
                query_string.append_pair("timeTaken",
                    &param_time_taken.to_string());
            }
            if let Some(param_highest) = param_highest {
                query_string.append_pair("highest",
                    &param_highest.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::ScoreResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(CreateScoreResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_score(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_app_key: String,
        param_mission_id: Option<i64>,
        param_game_id: Option<i64>,
        param_pack_id: Option<i64>,
        param_game_level_id: Option<i64>,
        param_game_object_id: Option<i64>,
        param_score_object_type: Option<String>,
        param_score_status: Option<String>,
        context: &C) -> Result<GetScoreResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/score/get",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("appKey",
                    &param_app_key);
            if let Some(param_mission_id) = param_mission_id {
                query_string.append_pair("missionId",
                    &param_mission_id.to_string());
            }
            if let Some(param_game_id) = param_game_id {
                query_string.append_pair("gameId",
                    &param_game_id.to_string());
            }
            if let Some(param_pack_id) = param_pack_id {
                query_string.append_pair("packId",
                    &param_pack_id.to_string());
            }
            if let Some(param_game_level_id) = param_game_level_id {
                query_string.append_pair("gameLevelId",
                    &param_game_level_id.to_string());
            }
            if let Some(param_game_object_id) = param_game_object_id {
                query_string.append_pair("gameObjectId",
                    &param_game_object_id.to_string());
            }
            if let Some(param_score_object_type) = param_score_object_type {
                query_string.append_pair("scoreObjectType",
                    &param_score_object_type);
            }
            if let Some(param_score_status) = param_score_status {
                query_string.append_pair("scoreStatus",
                    &param_score_status);
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::ScoreResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetScoreResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn search_scores(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_app_key: String,
        param_mission_id: Option<i64>,
        param_game_id: Option<i64>,
        param_pack_id: Option<i64>,
        param_game_level_id: Option<i64>,
        param_game_object_id: Option<i64>,
        context: &C) -> Result<SearchScoresResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/score/search",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("appKey",
                    &param_app_key);
            if let Some(param_mission_id) = param_mission_id {
                query_string.append_pair("missionId",
                    &param_mission_id.to_string());
            }
            if let Some(param_game_id) = param_game_id {
                query_string.append_pair("gameId",
                    &param_game_id.to_string());
            }
            if let Some(param_pack_id) = param_pack_id {
                query_string.append_pair("packId",
                    &param_pack_id.to_string());
            }
            if let Some(param_game_level_id) = param_game_level_id {
                query_string.append_pair("gameLevelId",
                    &param_game_level_id.to_string());
            }
            if let Some(param_game_object_id) = param_game_object_id {
                query_string.append_pair("gameObjectId",
                    &param_game_object_id.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<Vec<models::ScoreResponse>>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(SearchScoresResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn create_secure_application(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_app_key: String,
        param_key_cert: swagger::ByteArray,
        param_trust_store: swagger::ByteArray,
        param_username: String,
        param_password: String,
        param_active: Option<bool>,
        param_biometric_type: Option<models::CreateSecureApplicationBiometricTypeParameter>,
        param_biometric_position: Option<models::CreateSecureApplicationBiometricPositionParameter>,
        param_biometric_position2: Option<models::CreateSecureApplicationBiometricPositionParameter>,
        context: &C) -> Result<CreateSecureApplicationResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/secure/application/create",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("appKey",
                    &param_app_key);
            if let Some(param_active) = param_active {
                query_string.append_pair("active",
                    &param_active.to_string());
            }
                query_string.append_pair("keyCert",
                    &param_key_cert.to_string());
                query_string.append_pair("trustStore",
                    &param_trust_store.to_string());
                query_string.append_pair("username",
                    &param_username);
                query_string.append_pair("password",
                    &param_password);
            if let Some(param_biometric_type) = param_biometric_type {
                query_string.append_pair("biometricType",
                    &param_biometric_type.to_string());
            }
            if let Some(param_biometric_position) = param_biometric_position {
                query_string.append_pair("biometricPosition",
                    &param_biometric_position.to_string());
            }
            if let Some(param_biometric_position2) = param_biometric_position2 {
                query_string.append_pair("biometricPosition2",
                    &param_biometric_position2.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(CreateSecureApplicationResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn delete_secure_application(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_app_key: String,
        context: &C) -> Result<DeleteSecureApplicationResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/secure/application/delete",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("appKey",
                    &param_app_key);
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(DeleteSecureApplicationResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn login_secure(
        &self,
        param_version: f64,
        param_app_key: String,
        param_biometric_file: swagger::ByteArray,
        param_device_id: Option<String>,
        param_biometric_file2: Option<swagger::ByteArray>,
        param_age_restriction: Option<i32>,
        param_return_profile: Option<bool>,
        param_response_filters: Option<String>,
        param_latitude: Option<f64>,
        param_longitude: Option<f64>,
        context: &C) -> Result<LoginSecureResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/secure/login",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
                query_string.append_pair("appKey",
                    &param_app_key);
                query_string.append_pair("biometricFile",
                    &param_biometric_file.to_string());
            if let Some(param_biometric_file2) = param_biometric_file2 {
                query_string.append_pair("biometricFile2",
                    &param_biometric_file2.to_string());
            }
            if let Some(param_age_restriction) = param_age_restriction {
                query_string.append_pair("ageRestriction",
                    &param_age_restriction.to_string());
            }
            if let Some(param_return_profile) = param_return_profile {
                query_string.append_pair("returnProfile",
                    &param_return_profile.to_string());
            }
            if let Some(param_response_filters) = param_response_filters {
                query_string.append_pair("responseFilters",
                    &param_response_filters);
            }
            if let Some(param_latitude) = param_latitude {
                query_string.append_pair("latitude",
                    &param_latitude.to_string());
            }
            if let Some(param_longitude) = param_longitude {
                query_string.append_pair("longitude",
                    &param_longitude.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::ProfileResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(LoginSecureResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn purchase_secure(
        &self,
        param_version: f64,
        param_body: models::PaymentRequest,
        context: &C) -> Result<PurchaseSecureResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/secure/purchase",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        // Consumes basic body
        // Body parameter
        let body = serde_json::to_string(&param_body).expect("impossible to fail to serialize");
        *request.body_mut() = body_from_string(body);

        let header = "application/json";
        request.headers_mut().insert(CONTENT_TYPE, HeaderValue::from_static(header));

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::ProfileResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(PurchaseSecureResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn reset_secure(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_app_key: String,
        context: &C) -> Result<ResetSecureResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/secure/application/reset",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("appKey",
                    &param_app_key);
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(ResetSecureResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn update_secure_application(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_app_key: String,
        param_active: Option<bool>,
        param_key_cert: Option<swagger::ByteArray>,
        param_trust_store: Option<swagger::ByteArray>,
        param_username: Option<String>,
        param_password: Option<String>,
        param_biometric_type: Option<models::UpdateSecureApplicationBiometricTypeParameter>,
        param_biometric_position: Option<models::UpdateSecureApplicationBiometricPositionParameter>,
        param_biometric_position2: Option<models::UpdateSecureApplicationBiometricPositionParameter>,
        context: &C) -> Result<UpdateSecureApplicationResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/secure/application/update",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("appKey",
                    &param_app_key);
            if let Some(param_active) = param_active {
                query_string.append_pair("active",
                    &param_active.to_string());
            }
            if let Some(param_key_cert) = param_key_cert {
                query_string.append_pair("keyCert",
                    &param_key_cert.to_string());
            }
            if let Some(param_trust_store) = param_trust_store {
                query_string.append_pair("trustStore",
                    &param_trust_store.to_string());
            }
            if let Some(param_username) = param_username {
                query_string.append_pair("username",
                    &param_username);
            }
            if let Some(param_password) = param_password {
                query_string.append_pair("password",
                    &param_password);
            }
            if let Some(param_biometric_type) = param_biometric_type {
                query_string.append_pair("biometricType",
                    &param_biometric_type.to_string());
            }
            if let Some(param_biometric_position) = param_biometric_position {
                query_string.append_pair("biometricPosition",
                    &param_biometric_position.to_string());
            }
            if let Some(param_biometric_position2) = param_biometric_position2 {
                query_string.append_pair("biometricPosition2",
                    &param_biometric_position2.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(UpdateSecureApplicationResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn create_service_hub(
        &self,
        param_version: f64,
        param_body: Option<models::ServiceHub>,
        context: &C) -> Result<CreateServiceHubResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/hub",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        // Consumes basic body
        // Body parameter
        if let Some(param_body) = param_body {
        let body = serde_json::to_string(&param_body).expect("impossible to fail to serialize");
        *request.body_mut() = body_from_string(body);
        }

        let header = "application/json";
        request.headers_mut().insert(CONTENT_TYPE, HeaderValue::from_static(header));

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::ServiceHub>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(CreateServiceHubResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn search_service_hubs(
        &self,
        param_version: f64,
        param_sort_field: String,
        param_descending: bool,
        param_start: i32,
        param_limit: i32,
        param_active_only: bool,
        param_keyword: Option<String>,
        param_retailer_id: Option<i64>,
        context: &C) -> Result<SearchServiceHubsResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/hub",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_keyword) = param_keyword {
                query_string.append_pair("keyword",
                    &param_keyword);
            }
            if let Some(param_retailer_id) = param_retailer_id {
                query_string.append_pair("retailerId",
                    &param_retailer_id.to_string());
            }
                query_string.append_pair("sortField",
                    &param_sort_field);
                query_string.append_pair("descending",
                    &param_descending.to_string());
                query_string.append_pair("start",
                    &param_start.to_string());
                query_string.append_pair("limit",
                    &param_limit.to_string());
                query_string.append_pair("activeOnly",
                    &param_active_only.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<Vec<models::ServiceHub>>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(SearchServiceHubsResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn delete_service_hub(
        &self,
        param_version: f64,
        param_id: i64,
        context: &C) -> Result<DeleteServiceHubResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/hub/{id}",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
            ,id=utf8_percent_encode(&param_id.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("DELETE")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            0 => {
                Ok(
                    DeleteServiceHubResponse::SuccessfulOperation
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_service_hub(
        &self,
        param_version: f64,
        param_id: i64,
        context: &C) -> Result<GetServiceHubResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/hub/{id}",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
            ,id=utf8_percent_encode(&param_id.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<serde_json::Value>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetServiceHubResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn post_service_hub(
        &self,
        param_version: f64,
        param_id: i64,
        param_body: Option<models::ServiceHub>,
        context: &C) -> Result<PostServiceHubResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/hub/{id}",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
            ,id=utf8_percent_encode(&param_id.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        // Consumes basic body
        // Body parameter
        if let Some(param_body) = param_body {
        let body = serde_json::to_string(&param_body).expect("impossible to fail to serialize");
        *request.body_mut() = body_from_string(body);
        }

        let header = "application/json";
        request.headers_mut().insert(CONTENT_TYPE, HeaderValue::from_static(header));

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::ServiceHub>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(PostServiceHubResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn put_service_hub(
        &self,
        param_version: f64,
        param_id: i64,
        param_body: Option<models::ServiceHub>,
        context: &C) -> Result<PutServiceHubResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/hub/{id}",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
            ,id=utf8_percent_encode(&param_id.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("PUT")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        // Consumes basic body
        // Body parameter
        if let Some(param_body) = param_body {
        let body = serde_json::to_string(&param_body).expect("impossible to fail to serialize");
        *request.body_mut() = body_from_string(body);
        }

        let header = "application/json";
        request.headers_mut().insert(CONTENT_TYPE, HeaderValue::from_static(header));

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::ServiceHub>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(PutServiceHubResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn create_shipment(
        &self,
        param_version: f64,
        param_body: Option<models::Shipment>,
        context: &C) -> Result<CreateShipmentResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/shipment",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        // Consumes basic body
        // Body parameter
        if let Some(param_body) = param_body {
        let body = serde_json::to_string(&param_body).expect("impossible to fail to serialize");
        *request.body_mut() = body_from_string(body);
        }

        let header = "application/json";
        request.headers_mut().insert(CONTENT_TYPE, HeaderValue::from_static(header));

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::Shipment>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(CreateShipmentResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn search_shipments(
        &self,
        param_version: f64,
        param_sort_field: String,
        param_descending: bool,
        param_start: i32,
        param_limit: i32,
        param_active_only: bool,
        param_owner_id: Option<i64>,
        param_rider_id: Option<i64>,
        param_route_id: Option<i64>,
        context: &C) -> Result<SearchShipmentsResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/shipment",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_owner_id) = param_owner_id {
                query_string.append_pair("ownerId",
                    &param_owner_id.to_string());
            }
            if let Some(param_rider_id) = param_rider_id {
                query_string.append_pair("riderId",
                    &param_rider_id.to_string());
            }
            if let Some(param_route_id) = param_route_id {
                query_string.append_pair("routeId",
                    &param_route_id.to_string());
            }
                query_string.append_pair("sortField",
                    &param_sort_field);
                query_string.append_pair("descending",
                    &param_descending.to_string());
                query_string.append_pair("start",
                    &param_start.to_string());
                query_string.append_pair("limit",
                    &param_limit.to_string());
                query_string.append_pair("activeOnly",
                    &param_active_only.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<Vec<models::Shipment>>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(SearchShipmentsResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn cancel_shipment(
        &self,
        param_version: f64,
        param_id: i64,
        context: &C) -> Result<CancelShipmentResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/shipment/{id}/cancel",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
            ,id=utf8_percent_encode(&param_id.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            0 => {
                Ok(
                    CancelShipmentResponse::SuccessfulOperation
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn delete_shipment(
        &self,
        param_version: f64,
        param_id: i64,
        context: &C) -> Result<DeleteShipmentResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/shipment/{id}",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
            ,id=utf8_percent_encode(&param_id.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("DELETE")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            0 => {
                Ok(
                    DeleteShipmentResponse::SuccessfulOperation
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_shipment(
        &self,
        param_version: f64,
        param_id: i64,
        context: &C) -> Result<GetShipmentResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/shipment/{id}",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
            ,id=utf8_percent_encode(&param_id.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::Shipment>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetShipmentResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn update_shipment(
        &self,
        param_version: f64,
        param_id: i64,
        param_body: Option<models::Shipment>,
        context: &C) -> Result<UpdateShipmentResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/shipment/{id}",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
            ,id=utf8_percent_encode(&param_id.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("PUT")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        // Consumes basic body
        // Body parameter
        if let Some(param_body) = param_body {
        let body = serde_json::to_string(&param_body).expect("impossible to fail to serialize");
        *request.body_mut() = body_from_string(body);
        }

        let header = "application/json";
        request.headers_mut().insert(CONTENT_TYPE, HeaderValue::from_static(header));

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::Shipment>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(UpdateShipmentResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn update_shipment_status(
        &self,
        param_version: f64,
        param_id: i64,
        param_body: Option<std::collections::HashMap<String, bool>>,
        context: &C) -> Result<UpdateShipmentStatusResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/shipment/{id}/status",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
            ,id=utf8_percent_encode(&param_id.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        // Consumes basic body
        // Body parameter
        if let Some(param_body) = param_body {
        let body = serde_json::to_string(&param_body).expect("impossible to fail to serialize");
        *request.body_mut() = body_from_string(body);
        }

        let header = "application/json";
        request.headers_mut().insert(CONTENT_TYPE, HeaderValue::from_static(header));

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            0 => {
                Ok(
                    UpdateShipmentStatusResponse::SuccessfulOperation
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn create_shipment_batch(
        &self,
        param_version: f64,
        param_body: Option<models::ShipmentBatch>,
        context: &C) -> Result<CreateShipmentBatchResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/shipment/batch",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        // Consumes basic body
        // Body parameter
        if let Some(param_body) = param_body {
        let body = serde_json::to_string(&param_body).expect("impossible to fail to serialize");
        *request.body_mut() = body_from_string(body);
        }

        let header = "application/json";
        request.headers_mut().insert(CONTENT_TYPE, HeaderValue::from_static(header));

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::ShipmentBatch>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(CreateShipmentBatchResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn search_shipment_batch(
        &self,
        param_version: f64,
        param_hub_id: i64,
        param_sort_field: String,
        param_descending: bool,
        param_start: i32,
        param_limit: i32,
        context: &C) -> Result<SearchShipmentBatchResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/shipment/batch",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("hubId",
                    &param_hub_id.to_string());
                query_string.append_pair("sortField",
                    &param_sort_field);
                query_string.append_pair("descending",
                    &param_descending.to_string());
                query_string.append_pair("start",
                    &param_start.to_string());
                query_string.append_pair("limit",
                    &param_limit.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<Vec<models::ShipmentBatch>>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(SearchShipmentBatchResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn delete_shipment_batch(
        &self,
        param_version: f64,
        param_batch_id: i64,
        context: &C) -> Result<DeleteShipmentBatchResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/shipment/batch/{batch_id}",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
            ,batch_id=utf8_percent_encode(&param_batch_id.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("DELETE")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            0 => {
                Ok(
                    DeleteShipmentBatchResponse::SuccessfulOperation
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_shipment_batch(
        &self,
        param_version: f64,
        param_batch_id: i64,
        context: &C) -> Result<GetShipmentBatchResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/shipment/batch/{batch_id}",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
            ,batch_id=utf8_percent_encode(&param_batch_id.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::ShipmentBatch>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetShipmentBatchResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_shipment_batch_status(
        &self,
        param_version: f64,
        param_batch_id: i64,
        param_account_id: i64,
        param_sort_field: String,
        param_descending: bool,
        param_start: i32,
        param_limit: i32,
        param_valid: Option<bool>,
        param_started: Option<bool>,
        param_completed: Option<bool>,
        param_has_shipment: Option<bool>,
        param_has_route: Option<bool>,
        param_keyword: Option<String>,
        context: &C) -> Result<GetShipmentBatchStatusResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/shipment/batch/{batch_id}/status",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
            ,batch_id=utf8_percent_encode(&param_batch_id.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            if let Some(param_valid) = param_valid {
                query_string.append_pair("valid",
                    &param_valid.to_string());
            }
            if let Some(param_started) = param_started {
                query_string.append_pair("started",
                    &param_started.to_string());
            }
            if let Some(param_completed) = param_completed {
                query_string.append_pair("completed",
                    &param_completed.to_string());
            }
            if let Some(param_has_shipment) = param_has_shipment {
                query_string.append_pair("hasShipment",
                    &param_has_shipment.to_string());
            }
            if let Some(param_has_route) = param_has_route {
                query_string.append_pair("hasRoute",
                    &param_has_route.to_string());
            }
            if let Some(param_keyword) = param_keyword {
                query_string.append_pair("keyword",
                    &param_keyword);
            }
                query_string.append_pair("sortField",
                    &param_sort_field);
                query_string.append_pair("descending",
                    &param_descending.to_string());
                query_string.append_pair("start",
                    &param_start.to_string());
                query_string.append_pair("limit",
                    &param_limit.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<Vec<models::ShipmentImportStatus>>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetShipmentBatchStatusResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn simulation(
        &self,
        param_version: f64,
        param_data: String,
        param_real_time: bool,
        context: &C) -> Result<SimulationResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/simulation/routing",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("data",
                    &param_data);
                query_string.append_pair("realTime",
                    &param_real_time.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(SimulationResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_stop(
        &self,
        param_version: f64,
        param_id: i64,
        context: &C) -> Result<GetStopResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/stop/{id}",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
            ,id=utf8_percent_encode(&param_id.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::Stop>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetStopResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn update_stop(
        &self,
        param_version: f64,
        param_id: i64,
        param_body: Option<models::Stop>,
        context: &C) -> Result<UpdateStopResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/stop/{id}",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
            ,id=utf8_percent_encode(&param_id.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("PUT")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        // Consumes basic body
        // Body parameter
        if let Some(param_body) = param_body {
        let body = serde_json::to_string(&param_body).expect("impossible to fail to serialize");
        *request.body_mut() = body_from_string(body);
        }

        let header = "application/json";
        request.headers_mut().insert(CONTENT_TYPE, HeaderValue::from_static(header));

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::Stop>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(UpdateStopResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn create_stripe_checkout_session(
        &self,
        param_version: f64,
        param_app_key: String,
        param_stripe_parameters: String,
        context: &C) -> Result<CreateStripeCheckoutSessionResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/stripe/checkout/session/create",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("appKey",
                    &param_app_key);
                query_string.append_pair("stripeParameters",
                    &param_stripe_parameters);
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(CreateStripeCheckoutSessionResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn create_subscription(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_plan_id: Option<i64>,
        param_promo_code: Option<String>,
        context: &C) -> Result<CreateSubscriptionResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/subscription/create",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            if let Some(param_plan_id) = param_plan_id {
                query_string.append_pair("planId",
                    &param_plan_id.to_string());
            }
            if let Some(param_promo_code) = param_promo_code {
                query_string.append_pair("promoCode",
                    &param_promo_code);
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SubscriptionResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(CreateSubscriptionResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn delete_subscription(
        &self,
        param_version: f64,
        param_account_id: i64,
        context: &C) -> Result<DeleteSubscriptionResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/subscription/delete",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(DeleteSubscriptionResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_subscription(
        &self,
        param_version: f64,
        param_account_id: i64,
        context: &C) -> Result<GetSubscriptionResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/subscription/get",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SubscriptionResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetSubscriptionResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_subscription_plan(
        &self,
        param_version: f64,
        param_plan_id: i64,
        context: &C) -> Result<GetSubscriptionPlanResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/subscription/plan/get",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("planId",
                    &param_plan_id.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SubscriptionPlanResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetSubscriptionPlanResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_subscription_plans(
        &self,
        param_version: f64,
        param_visible: Option<bool>,
        param_role: Option<String>,
        context: &C) -> Result<GetSubscriptionPlansResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/subscription/plan/list",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_visible) = param_visible {
                query_string.append_pair("visible",
                    &param_visible.to_string());
            }
            if let Some(param_role) = param_role {
                query_string.append_pair("role",
                    &param_role);
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<Vec<models::SubscriptionPlanResponse>>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetSubscriptionPlansResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_subscription_usage(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_application_id: Option<i64>,
        param_start: Option<i64>,
        param_end: Option<i64>,
        context: &C) -> Result<GetSubscriptionUsageResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/subscription/usage/get",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            if let Some(param_application_id) = param_application_id {
                query_string.append_pair("applicationId",
                    &param_application_id.to_string());
            }
            if let Some(param_start) = param_start {
                query_string.append_pair("start",
                    &param_start.to_string());
            }
            if let Some(param_end) = param_end {
                query_string.append_pair("end",
                    &param_end.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::ApplicationUsageResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetSubscriptionUsageResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn update_subscription(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_plan_id: Option<i64>,
        param_promo_code: Option<String>,
        param_active: Option<bool>,
        context: &C) -> Result<UpdateSubscriptionResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/subscription/update",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            if let Some(param_plan_id) = param_plan_id {
                query_string.append_pair("planId",
                    &param_plan_id.to_string());
            }
            if let Some(param_promo_code) = param_promo_code {
                query_string.append_pair("promoCode",
                    &param_promo_code);
            }
            if let Some(param_active) = param_active {
                query_string.append_pair("active",
                    &param_active.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SubscriptionResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(UpdateSubscriptionResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn create_task(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_name: String,
        param_app_key: Option<String>,
        param_grouping_id: Option<String>,
        param_endpoint_url: Option<String>,
        param_payload: Option<String>,
        param_scheduled_date: Option<i64>,
        param_start_date: Option<i64>,
        param_end_date: Option<i64>,
        param_cron_expression: Option<String>,
        param_visibility: Option<models::AddAlbumCollectionVisibilityParameter>,
        param_active: Option<bool>,
        context: &C) -> Result<CreateTaskResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/task/create",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("name",
                    &param_name);
            if let Some(param_app_key) = param_app_key {
                query_string.append_pair("appKey",
                    &param_app_key);
            }
            if let Some(param_grouping_id) = param_grouping_id {
                query_string.append_pair("groupingId",
                    &param_grouping_id);
            }
            if let Some(param_endpoint_url) = param_endpoint_url {
                query_string.append_pair("endpointURL",
                    &param_endpoint_url);
            }
            if let Some(param_payload) = param_payload {
                query_string.append_pair("payload",
                    &param_payload);
            }
            if let Some(param_scheduled_date) = param_scheduled_date {
                query_string.append_pair("scheduledDate",
                    &param_scheduled_date.to_string());
            }
            if let Some(param_start_date) = param_start_date {
                query_string.append_pair("startDate",
                    &param_start_date.to_string());
            }
            if let Some(param_end_date) = param_end_date {
                query_string.append_pair("endDate",
                    &param_end_date.to_string());
            }
            if let Some(param_cron_expression) = param_cron_expression {
                query_string.append_pair("cronExpression",
                    &param_cron_expression);
            }
            if let Some(param_visibility) = param_visibility {
                query_string.append_pair("visibility",
                    &param_visibility.to_string());
            }
            if let Some(param_active) = param_active {
                query_string.append_pair("active",
                    &param_active.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::TaskResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(CreateTaskResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn delete_task(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_task_id: i64,
        context: &C) -> Result<DeleteTaskResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/task/delete",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("taskId",
                    &param_task_id.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(DeleteTaskResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_task(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_task_id: i64,
        context: &C) -> Result<GetTaskResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/task/get",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("taskId",
                    &param_task_id.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::TaskResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetTaskResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn search_tasks(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_grouping_id: Option<String>,
        param_filter: Option<String>,
        param_statuses: Option<String>,
        param_template_types: Option<String>,
        param_app_key: Option<String>,
        param_keyword: Option<String>,
        param_sort_field: Option<String>,
        param_descending: Option<bool>,
        param_start: Option<i32>,
        param_limit: Option<i32>,
        param_active_only: Option<bool>,
        context: &C) -> Result<SearchTasksResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/task/search",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            if let Some(param_grouping_id) = param_grouping_id {
                query_string.append_pair("groupingId",
                    &param_grouping_id);
            }
            if let Some(param_filter) = param_filter {
                query_string.append_pair("filter",
                    &param_filter);
            }
            if let Some(param_statuses) = param_statuses {
                query_string.append_pair("statuses",
                    &param_statuses);
            }
            if let Some(param_template_types) = param_template_types {
                query_string.append_pair("templateTypes",
                    &param_template_types);
            }
            if let Some(param_app_key) = param_app_key {
                query_string.append_pair("appKey",
                    &param_app_key);
            }
            if let Some(param_keyword) = param_keyword {
                query_string.append_pair("keyword",
                    &param_keyword);
            }
            if let Some(param_sort_field) = param_sort_field {
                query_string.append_pair("sortField",
                    &param_sort_field);
            }
            if let Some(param_descending) = param_descending {
                query_string.append_pair("descending",
                    &param_descending.to_string());
            }
            if let Some(param_start) = param_start {
                query_string.append_pair("start",
                    &param_start.to_string());
            }
            if let Some(param_limit) = param_limit {
                query_string.append_pair("limit",
                    &param_limit.to_string());
            }
            if let Some(param_active_only) = param_active_only {
                query_string.append_pair("activeOnly",
                    &param_active_only.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<Vec<models::TaskResponse>>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(SearchTasksResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn update_task(
        &self,
        param_version: f64,
        param_task_id: i64,
        param_account_id: i64,
        param_name: Option<String>,
        param_app_key: Option<String>,
        param_grouping_id: Option<String>,
        param_endpoint_url: Option<String>,
        param_payload: Option<String>,
        param_scheduled_date: Option<i64>,
        param_start_date: Option<i64>,
        param_end_date: Option<i64>,
        param_cron_expression: Option<String>,
        param_visibility: Option<models::AddAlbumCollectionVisibilityParameter>,
        param_active: Option<bool>,
        context: &C) -> Result<UpdateTaskResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/task/update",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("taskId",
                    &param_task_id.to_string());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            if let Some(param_name) = param_name {
                query_string.append_pair("name",
                    &param_name);
            }
            if let Some(param_app_key) = param_app_key {
                query_string.append_pair("appKey",
                    &param_app_key);
            }
            if let Some(param_grouping_id) = param_grouping_id {
                query_string.append_pair("groupingId",
                    &param_grouping_id);
            }
            if let Some(param_endpoint_url) = param_endpoint_url {
                query_string.append_pair("endpointURL",
                    &param_endpoint_url);
            }
            if let Some(param_payload) = param_payload {
                query_string.append_pair("payload",
                    &param_payload);
            }
            if let Some(param_scheduled_date) = param_scheduled_date {
                query_string.append_pair("scheduledDate",
                    &param_scheduled_date.to_string());
            }
            if let Some(param_start_date) = param_start_date {
                query_string.append_pair("startDate",
                    &param_start_date.to_string());
            }
            if let Some(param_end_date) = param_end_date {
                query_string.append_pair("endDate",
                    &param_end_date.to_string());
            }
            if let Some(param_cron_expression) = param_cron_expression {
                query_string.append_pair("cronExpression",
                    &param_cron_expression);
            }
            if let Some(param_visibility) = param_visibility {
                query_string.append_pair("visibility",
                    &param_visibility.to_string());
            }
            if let Some(param_active) = param_active {
                query_string.append_pair("active",
                    &param_active.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::TaskResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(UpdateTaskResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn create_territory(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_name: String,
        param_active: Option<bool>,
        context: &C) -> Result<CreateTerritoryResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/territory/create",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("name",
                    &param_name);
            if let Some(param_active) = param_active {
                query_string.append_pair("active",
                    &param_active.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::TerritoryResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(CreateTerritoryResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn delete_territory(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_territory_id: i64,
        context: &C) -> Result<DeleteTerritoryResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/territory/delete",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("territoryId",
                    &param_territory_id.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(DeleteTerritoryResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_territory(
        &self,
        param_version: f64,
        param_territory_id: i64,
        context: &C) -> Result<GetTerritoryResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/territory/get",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("territoryId",
                    &param_territory_id.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::TerritoryResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetTerritoryResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn search_territories(
        &self,
        param_version: f64,
        param_sort_field: models::SearchTerritoriesSortFieldParameter,
        param_descending: bool,
        param_keyword: Option<String>,
        param_start: Option<i32>,
        param_limit: Option<i32>,
        context: &C) -> Result<SearchTerritoriesResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/territory/search",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_keyword) = param_keyword {
                query_string.append_pair("keyword",
                    &param_keyword);
            }
            if let Some(param_start) = param_start {
                query_string.append_pair("start",
                    &param_start.to_string());
            }
            if let Some(param_limit) = param_limit {
                query_string.append_pair("limit",
                    &param_limit.to_string());
            }
                query_string.append_pair("sortField",
                    &param_sort_field.to_string());
                query_string.append_pair("descending",
                    &param_descending.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<Vec<models::TerritoryResponse>>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(SearchTerritoriesResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn update_territory(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_territory_id: i64,
        param_name: Option<String>,
        param_active: Option<bool>,
        context: &C) -> Result<UpdateTerritoryResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/territory/update",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("territoryId",
                    &param_territory_id.to_string());
            if let Some(param_name) = param_name {
                query_string.append_pair("name",
                    &param_name);
            }
            if let Some(param_active) = param_active {
                query_string.append_pair("active",
                    &param_active.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::TerritoryResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(UpdateTerritoryResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn add_or_update_theme_descriptor(
        &self,
        param_version: f64,
        param_public_read: bool,
        param_public_write: bool,
        param_public_delete: bool,
        param_public_add: bool,
        param_visibility: models::AddAlbumCollectionVisibilityParameter,
        param_include_friend_group: bool,
        param_complete_with_default_values: bool,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_game_type: Option<String>,
        param_theme_descriptor_id: Option<i64>,
        param_title: Option<String>,
        param_description: Option<String>,
        param_connection_ids_to_add: Option<String>,
        param_connection_group_ids_to_add: Option<String>,
        param_app_version: Option<String>,
        param_color_value_json: Option<String>,
        param_string_replacer_json: Option<String>,
        param_custom_json_objects: Option<String>,
        param_icon_image: Option<swagger::ByteArray>,
        param_scene_atlas_image: Option<swagger::ByteArray>,
        param_bg_image: Option<swagger::ByteArray>,
        param_bg_sound: Option<swagger::ByteArray>,
        param_music_selection: Option<String>,
        param_location_description: Option<String>,
        param_latitude: Option<f64>,
        param_longitude: Option<f64>,
        context: &C) -> Result<AddOrUpdateThemeDescriptorResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/consumer/theme",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_game_type) = param_game_type {
                query_string.append_pair("gameType",
                    &param_game_type);
            }
            if let Some(param_theme_descriptor_id) = param_theme_descriptor_id {
                query_string.append_pair("themeDescriptorId",
                    &param_theme_descriptor_id.to_string());
            }
            if let Some(param_title) = param_title {
                query_string.append_pair("title",
                    &param_title);
            }
            if let Some(param_description) = param_description {
                query_string.append_pair("description",
                    &param_description);
            }
                query_string.append_pair("publicRead",
                    &param_public_read.to_string());
                query_string.append_pair("publicWrite",
                    &param_public_write.to_string());
                query_string.append_pair("publicDelete",
                    &param_public_delete.to_string());
                query_string.append_pair("publicAdd",
                    &param_public_add.to_string());
                query_string.append_pair("visibility",
                    &param_visibility.to_string());
            if let Some(param_connection_ids_to_add) = param_connection_ids_to_add {
                query_string.append_pair("connectionIdsToAdd",
                    &param_connection_ids_to_add);
            }
            if let Some(param_connection_group_ids_to_add) = param_connection_group_ids_to_add {
                query_string.append_pair("connectionGroupIdsToAdd",
                    &param_connection_group_ids_to_add);
            }
                query_string.append_pair("includeFriendGroup",
                    &param_include_friend_group.to_string());
            if let Some(param_app_version) = param_app_version {
                query_string.append_pair("appVersion",
                    &param_app_version);
            }
            if let Some(param_color_value_json) = param_color_value_json {
                query_string.append_pair("colorValueJson",
                    &param_color_value_json);
            }
            if let Some(param_string_replacer_json) = param_string_replacer_json {
                query_string.append_pair("stringReplacerJson",
                    &param_string_replacer_json);
            }
            if let Some(param_custom_json_objects) = param_custom_json_objects {
                query_string.append_pair("customJsonObjects",
                    &param_custom_json_objects);
            }
            if let Some(param_icon_image) = param_icon_image {
                query_string.append_pair("iconImage",
                    &param_icon_image.to_string());
            }
            if let Some(param_scene_atlas_image) = param_scene_atlas_image {
                query_string.append_pair("sceneAtlasImage",
                    &param_scene_atlas_image.to_string());
            }
            if let Some(param_bg_image) = param_bg_image {
                query_string.append_pair("bgImage",
                    &param_bg_image.to_string());
            }
            if let Some(param_bg_sound) = param_bg_sound {
                query_string.append_pair("bgSound",
                    &param_bg_sound.to_string());
            }
            if let Some(param_music_selection) = param_music_selection {
                query_string.append_pair("musicSelection",
                    &param_music_selection);
            }
                query_string.append_pair("completeWithDefaultValues",
                    &param_complete_with_default_values.to_string());
            if let Some(param_location_description) = param_location_description {
                query_string.append_pair("locationDescription",
                    &param_location_description);
            }
            if let Some(param_latitude) = param_latitude {
                query_string.append_pair("latitude",
                    &param_latitude.to_string());
            }
            if let Some(param_longitude) = param_longitude {
                query_string.append_pair("longitude",
                    &param_longitude.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::ThemeDescriptorResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(AddOrUpdateThemeDescriptorResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_theme_descriptor(
        &self,
        param_version: f64,
        param_theme_descriptor_id: i64,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_game_type: Option<String>,
        param_latitude: Option<f64>,
        param_longitude: Option<f64>,
        context: &C) -> Result<GetThemeDescriptorResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/consumer/theme/get",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_game_type) = param_game_type {
                query_string.append_pair("gameType",
                    &param_game_type);
            }
                query_string.append_pair("themeDescriptorId",
                    &param_theme_descriptor_id.to_string());
            if let Some(param_latitude) = param_latitude {
                query_string.append_pair("latitude",
                    &param_latitude.to_string());
            }
            if let Some(param_longitude) = param_longitude {
                query_string.append_pair("longitude",
                    &param_longitude.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::PurchaseItemListResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetThemeDescriptorResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_theme_descriptors(
        &self,
        param_version: f64,
        param_filter: String,
        param_sort_field: String,
        param_descending: bool,
        param_start: i32,
        param_limit: i32,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_game_type: Option<String>,
        param_contest_type: Option<String>,
        param_owner_id: Option<i64>,
        param_q: Option<String>,
        param_keyword: Option<String>,
        param__i: Option<i32>,
        param__l: Option<i32>,
        param_date_created: Option<i64>,
        param_app_version: Option<String>,
        param_latitude: Option<f64>,
        param_longitude: Option<f64>,
        context: &C) -> Result<GetThemeDescriptorsResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/consumer/theme/search",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_game_type) = param_game_type {
                query_string.append_pair("gameType",
                    &param_game_type);
            }
            if let Some(param_contest_type) = param_contest_type {
                query_string.append_pair("contestType",
                    &param_contest_type);
            }
            if let Some(param_owner_id) = param_owner_id {
                query_string.append_pair("ownerId",
                    &param_owner_id.to_string());
            }
            if let Some(param_q) = param_q {
                query_string.append_pair("q",
                    &param_q);
            }
            if let Some(param_keyword) = param_keyword {
                query_string.append_pair("keyword",
                    &param_keyword);
            }
                query_string.append_pair("filter",
                    &param_filter);
                query_string.append_pair("sortField",
                    &param_sort_field);
                query_string.append_pair("descending",
                    &param_descending.to_string());
            if let Some(param__i) = param__i {
                query_string.append_pair("_i",
                    &param__i.to_string());
            }
                query_string.append_pair("start",
                    &param_start.to_string());
            if let Some(param__l) = param__l {
                query_string.append_pair("_l",
                    &param__l.to_string());
            }
                query_string.append_pair("limit",
                    &param_limit.to_string());
            if let Some(param_date_created) = param_date_created {
                query_string.append_pair("dateCreated",
                    &param_date_created.to_string());
            }
            if let Some(param_app_version) = param_app_version {
                query_string.append_pair("appVersion",
                    &param_app_version);
            }
            if let Some(param_latitude) = param_latitude {
                query_string.append_pair("latitude",
                    &param_latitude.to_string());
            }
            if let Some(param_longitude) = param_longitude {
                query_string.append_pair("longitude",
                    &param_longitude.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::PurchaseItemListResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetThemeDescriptorsResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn remove_theme_descriptor(
        &self,
        param_version: f64,
        param_theme_descriptor_id: i64,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_game_type: Option<String>,
        param_latitude: Option<f64>,
        param_longitude: Option<f64>,
        context: &C) -> Result<RemoveThemeDescriptorResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/consumer/theme/remove",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_game_type) = param_game_type {
                query_string.append_pair("gameType",
                    &param_game_type);
            }
                query_string.append_pair("themeDescriptorId",
                    &param_theme_descriptor_id.to_string());
            if let Some(param_latitude) = param_latitude {
                query_string.append_pair("latitude",
                    &param_latitude.to_string());
            }
            if let Some(param_longitude) = param_longitude {
                query_string.append_pair("longitude",
                    &param_longitude.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(RemoveThemeDescriptorResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn create_credential(
        &self,
        param_version: f64,
        param_third_party_id: String,
        param_third_party_token: String,
        param_network_uid: String,
        param_app_key: String,
        param_account_id: Option<i64>,
        param_device_id: Option<String>,
        param_session_id: Option<String>,
        param_third_party_name: Option<String>,
        param_email_address: Option<String>,
        param_signin_only_mode: Option<bool>,
        param_response_filters: Option<String>,
        param_latitude: Option<f64>,
        param_longitude: Option<f64>,
        param_meta_data: Option<String>,
        param_third_party_refresh_token: Option<String>,
        param_audience_ids_to_add: Option<String>,
        param_audience_ids_to_remove: Option<String>,
        context: &C) -> Result<CreateCredentialResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/thirdparty/credential/create",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_session_id) = param_session_id {
                query_string.append_pair("sessionId",
                    &param_session_id);
            }
                query_string.append_pair("thirdPartyId",
                    &param_third_party_id);
            if let Some(param_third_party_name) = param_third_party_name {
                query_string.append_pair("thirdPartyName",
                    &param_third_party_name);
            }
                query_string.append_pair("thirdPartyToken",
                    &param_third_party_token);
                query_string.append_pair("networkUID",
                    &param_network_uid);
                query_string.append_pair("appKey",
                    &param_app_key);
            if let Some(param_email_address) = param_email_address {
                query_string.append_pair("emailAddress",
                    &param_email_address);
            }
            if let Some(param_signin_only_mode) = param_signin_only_mode {
                query_string.append_pair("signinOnlyMode",
                    &param_signin_only_mode.to_string());
            }
            if let Some(param_response_filters) = param_response_filters {
                query_string.append_pair("responseFilters",
                    &param_response_filters);
            }
            if let Some(param_latitude) = param_latitude {
                query_string.append_pair("latitude",
                    &param_latitude.to_string());
            }
            if let Some(param_longitude) = param_longitude {
                query_string.append_pair("longitude",
                    &param_longitude.to_string());
            }
            if let Some(param_meta_data) = param_meta_data {
                query_string.append_pair("metaData",
                    &param_meta_data);
            }
            if let Some(param_third_party_refresh_token) = param_third_party_refresh_token {
                query_string.append_pair("thirdPartyRefreshToken",
                    &param_third_party_refresh_token);
            }
            if let Some(param_audience_ids_to_add) = param_audience_ids_to_add {
                query_string.append_pair("audienceIdsToAdd",
                    &param_audience_ids_to_add);
            }
            if let Some(param_audience_ids_to_remove) = param_audience_ids_to_remove {
                query_string.append_pair("audienceIdsToRemove",
                    &param_audience_ids_to_remove);
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::ProfileResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(CreateCredentialResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn create_network(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_name: String,
        param_enable_introspection: bool,
        param_description: Option<String>,
        param_introspection_method: Option<String>,
        param_introspection_url: Option<String>,
        param_introspection_params: Option<String>,
        param_required_root_field: Option<String>,
        param_enable_mfa: Option<bool>,
        param_size_mfa: Option<i32>,
        param_shelf_life_mfa: Option<i32>,
        param_oauth_token_url: Option<String>,
        param_oauth_private_key: Option<swagger::ByteArray>,
        param_oauth_public_key: Option<swagger::ByteArray>,
        param_oauth_client_id: Option<String>,
        param_oauth_secret_key: Option<String>,
        param_body: Option<String>,
        context: &C) -> Result<CreateNetworkResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/thirdparty/network/create",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("name",
                    &param_name);
            if let Some(param_description) = param_description {
                query_string.append_pair("description",
                    &param_description);
            }
                query_string.append_pair("enableIntrospection",
                    &param_enable_introspection.to_string());
            if let Some(param_introspection_method) = param_introspection_method {
                query_string.append_pair("introspectionMethod",
                    &param_introspection_method);
            }
            if let Some(param_introspection_url) = param_introspection_url {
                query_string.append_pair("introspectionURL",
                    &param_introspection_url);
            }
            if let Some(param_introspection_params) = param_introspection_params {
                query_string.append_pair("introspectionParams",
                    &param_introspection_params);
            }
            if let Some(param_required_root_field) = param_required_root_field {
                query_string.append_pair("requiredRootField",
                    &param_required_root_field);
            }
            if let Some(param_enable_mfa) = param_enable_mfa {
                query_string.append_pair("enableMFA",
                    &param_enable_mfa.to_string());
            }
            if let Some(param_size_mfa) = param_size_mfa {
                query_string.append_pair("sizeMFA",
                    &param_size_mfa.to_string());
            }
            if let Some(param_shelf_life_mfa) = param_shelf_life_mfa {
                query_string.append_pair("shelfLifeMFA",
                    &param_shelf_life_mfa.to_string());
            }
            if let Some(param_oauth_token_url) = param_oauth_token_url {
                query_string.append_pair("oauthTokenURL",
                    &param_oauth_token_url);
            }
            if let Some(param_oauth_private_key) = param_oauth_private_key {
                query_string.append_pair("oauthPrivateKey",
                    &param_oauth_private_key.to_string());
            }
            if let Some(param_oauth_public_key) = param_oauth_public_key {
                query_string.append_pair("oauthPublicKey",
                    &param_oauth_public_key.to_string());
            }
            if let Some(param_oauth_client_id) = param_oauth_client_id {
                query_string.append_pair("oauthClientId",
                    &param_oauth_client_id);
            }
            if let Some(param_oauth_secret_key) = param_oauth_secret_key {
                query_string.append_pair("oauthSecretKey",
                    &param_oauth_secret_key);
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        // Consumes basic body
        // Body parameter
        if let Some(param_body) = param_body {
        let body = serde_json::to_string(&param_body).expect("impossible to fail to serialize");
        *request.body_mut() = body_from_string(body);
        }

        let header = "application/json";
        request.headers_mut().insert(CONTENT_TYPE, HeaderValue::from_static(header));

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::ThirdPartyNetworkResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(CreateNetworkResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn delete_credential(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_network_uid: String,
        param_third_party_id: String,
        param_app_key: String,
        context: &C) -> Result<DeleteCredentialResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/thirdparty/credential/delete",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("networkUID",
                    &param_network_uid);
                query_string.append_pair("thirdPartyId",
                    &param_third_party_id);
                query_string.append_pair("appKey",
                    &param_app_key);
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(DeleteCredentialResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn delete_network(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_network_uid: String,
        context: &C) -> Result<DeleteNetworkResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/thirdparty/network/delete",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("networkUID",
                    &param_network_uid);
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(DeleteNetworkResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_credential(
        &self,
        param_version: f64,
        param_network_uid: String,
        param_app_key: String,
        param_account_id: Option<i64>,
        param_device_id: Option<String>,
        param_session_id: Option<String>,
        param_third_party_credential_id: Option<i64>,
        param_third_party_token: Option<String>,
        param_third_party_secret: Option<String>,
        param_create_new_account: Option<bool>,
        param_response_filters: Option<String>,
        param_latitude: Option<f64>,
        param_longitude: Option<f64>,
        param_audience_ids_to_add: Option<String>,
        param_audience_ids_to_remove: Option<String>,
        param_referral_account_id: Option<i64>,
        context: &C) -> Result<GetCredentialResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/thirdparty/credential/get",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_session_id) = param_session_id {
                query_string.append_pair("sessionId",
                    &param_session_id);
            }
            if let Some(param_third_party_credential_id) = param_third_party_credential_id {
                query_string.append_pair("thirdPartyCredentialId",
                    &param_third_party_credential_id.to_string());
            }
            if let Some(param_third_party_token) = param_third_party_token {
                query_string.append_pair("thirdPartyToken",
                    &param_third_party_token);
            }
            if let Some(param_third_party_secret) = param_third_party_secret {
                query_string.append_pair("thirdPartySecret",
                    &param_third_party_secret);
            }
            if let Some(param_create_new_account) = param_create_new_account {
                query_string.append_pair("createNewAccount",
                    &param_create_new_account.to_string());
            }
                query_string.append_pair("networkUID",
                    &param_network_uid);
                query_string.append_pair("appKey",
                    &param_app_key);
            if let Some(param_response_filters) = param_response_filters {
                query_string.append_pair("responseFilters",
                    &param_response_filters);
            }
            if let Some(param_latitude) = param_latitude {
                query_string.append_pair("latitude",
                    &param_latitude.to_string());
            }
            if let Some(param_longitude) = param_longitude {
                query_string.append_pair("longitude",
                    &param_longitude.to_string());
            }
            if let Some(param_audience_ids_to_add) = param_audience_ids_to_add {
                query_string.append_pair("audienceIdsToAdd",
                    &param_audience_ids_to_add);
            }
            if let Some(param_audience_ids_to_remove) = param_audience_ids_to_remove {
                query_string.append_pair("audienceIdsToRemove",
                    &param_audience_ids_to_remove);
            }
            if let Some(param_referral_account_id) = param_referral_account_id {
                query_string.append_pair("referralAccountId",
                    &param_referral_account_id.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::ProfileResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetCredentialResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_network(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_network_uid: String,
        context: &C) -> Result<GetNetworkResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/thirdparty/network/get",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("networkUID",
                    &param_network_uid);
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::ThirdPartyNetworkResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetNetworkResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn search_credentials(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_keyword: Option<String>,
        param_network_uid: Option<String>,
        param_descending: Option<bool>,
        param_start: Option<i32>,
        param_limit: Option<i32>,
        context: &C) -> Result<SearchCredentialsResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/thirdparty/credential/search",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            if let Some(param_keyword) = param_keyword {
                query_string.append_pair("keyword",
                    &param_keyword);
            }
            if let Some(param_network_uid) = param_network_uid {
                query_string.append_pair("networkUID",
                    &param_network_uid);
            }
            if let Some(param_descending) = param_descending {
                query_string.append_pair("descending",
                    &param_descending.to_string());
            }
            if let Some(param_start) = param_start {
                query_string.append_pair("start",
                    &param_start.to_string());
            }
            if let Some(param_limit) = param_limit {
                query_string.append_pair("limit",
                    &param_limit.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<Vec<models::ThirdPartyCredentialResponse>>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(SearchCredentialsResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn search_networks(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_sort_field: models::SearchNetworksSortFieldParameter,
        param_descending: bool,
        param_start: i32,
        param_limit: i32,
        param_active_only: bool,
        param_keyword: Option<String>,
        param_filter_billable: Option<bool>,
        context: &C) -> Result<SearchNetworksResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/thirdparty/network/search",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            if let Some(param_keyword) = param_keyword {
                query_string.append_pair("keyword",
                    &param_keyword);
            }
                query_string.append_pair("sortField",
                    &param_sort_field.to_string());
                query_string.append_pair("descending",
                    &param_descending.to_string());
                query_string.append_pair("start",
                    &param_start.to_string());
                query_string.append_pair("limit",
                    &param_limit.to_string());
                query_string.append_pair("activeOnly",
                    &param_active_only.to_string());
            if let Some(param_filter_billable) = param_filter_billable {
                query_string.append_pair("filterBillable",
                    &param_filter_billable.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<Vec<models::ThirdPartyNetworkShortResponse>>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(SearchNetworksResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn send_mfa_challenge(
        &self,
        param_version: f64,
        param_network_uid: String,
        param_app_key: String,
        param_third_party_token: Option<String>,
        param_third_party_credential_id: Option<i64>,
        param_device_id: Option<String>,
        context: &C) -> Result<SendMfaChallengeResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/thirdparty/credential/mfa/send",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_third_party_token) = param_third_party_token {
                query_string.append_pair("thirdPartyToken",
                    &param_third_party_token);
            }
            if let Some(param_third_party_credential_id) = param_third_party_credential_id {
                query_string.append_pair("thirdPartyCredentialId",
                    &param_third_party_credential_id.to_string());
            }
                query_string.append_pair("networkUID",
                    &param_network_uid);
                query_string.append_pair("appKey",
                    &param_app_key);
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(SendMfaChallengeResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn update_credential(
        &self,
        param_version: f64,
        param_network_uid: String,
        param_third_party_id: String,
        param_app_key: String,
        param_device_id: Option<String>,
        param_third_party_name: Option<String>,
        param_third_party_token: Option<String>,
        param_response_filters: Option<String>,
        param_meta_data: Option<String>,
        param_third_party_refresh_token: Option<String>,
        context: &C) -> Result<UpdateCredentialResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/thirdparty/credential/update",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
                query_string.append_pair("networkUID",
                    &param_network_uid);
                query_string.append_pair("thirdPartyId",
                    &param_third_party_id);
            if let Some(param_third_party_name) = param_third_party_name {
                query_string.append_pair("thirdPartyName",
                    &param_third_party_name);
            }
            if let Some(param_third_party_token) = param_third_party_token {
                query_string.append_pair("thirdPartyToken",
                    &param_third_party_token);
            }
                query_string.append_pair("appKey",
                    &param_app_key);
            if let Some(param_response_filters) = param_response_filters {
                query_string.append_pair("responseFilters",
                    &param_response_filters);
            }
            if let Some(param_meta_data) = param_meta_data {
                query_string.append_pair("metaData",
                    &param_meta_data);
            }
            if let Some(param_third_party_refresh_token) = param_third_party_refresh_token {
                query_string.append_pair("thirdPartyRefreshToken",
                    &param_third_party_refresh_token);
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::ProfileResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(UpdateCredentialResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn update_network(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_network_uid: String,
        param_name: Option<String>,
        param_description: Option<String>,
        param_enable_introspection: Option<bool>,
        param_introspection_method: Option<String>,
        param_introspection_url: Option<String>,
        param_introspection_params: Option<String>,
        param_required_root_field: Option<String>,
        param_enable_mfa: Option<bool>,
        param_size_mfa: Option<i32>,
        param_shelf_life_mfa: Option<i32>,
        param_oauth_token_url: Option<String>,
        param_oauth_private_key: Option<swagger::ByteArray>,
        param_oauth_public_key: Option<swagger::ByteArray>,
        param_oauth_client_id: Option<String>,
        param_oauth_secret_key: Option<String>,
        param_body: Option<String>,
        context: &C) -> Result<UpdateNetworkResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/thirdparty/network/update",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("networkUID",
                    &param_network_uid);
            if let Some(param_name) = param_name {
                query_string.append_pair("name",
                    &param_name);
            }
            if let Some(param_description) = param_description {
                query_string.append_pair("description",
                    &param_description);
            }
            if let Some(param_enable_introspection) = param_enable_introspection {
                query_string.append_pair("enableIntrospection",
                    &param_enable_introspection.to_string());
            }
            if let Some(param_introspection_method) = param_introspection_method {
                query_string.append_pair("introspectionMethod",
                    &param_introspection_method);
            }
            if let Some(param_introspection_url) = param_introspection_url {
                query_string.append_pair("introspectionURL",
                    &param_introspection_url);
            }
            if let Some(param_introspection_params) = param_introspection_params {
                query_string.append_pair("introspectionParams",
                    &param_introspection_params);
            }
            if let Some(param_required_root_field) = param_required_root_field {
                query_string.append_pair("requiredRootField",
                    &param_required_root_field);
            }
            if let Some(param_enable_mfa) = param_enable_mfa {
                query_string.append_pair("enableMFA",
                    &param_enable_mfa.to_string());
            }
            if let Some(param_size_mfa) = param_size_mfa {
                query_string.append_pair("sizeMFA",
                    &param_size_mfa.to_string());
            }
            if let Some(param_shelf_life_mfa) = param_shelf_life_mfa {
                query_string.append_pair("shelfLifeMFA",
                    &param_shelf_life_mfa.to_string());
            }
            if let Some(param_oauth_token_url) = param_oauth_token_url {
                query_string.append_pair("oauthTokenURL",
                    &param_oauth_token_url);
            }
            if let Some(param_oauth_private_key) = param_oauth_private_key {
                query_string.append_pair("oauthPrivateKey",
                    &param_oauth_private_key.to_string());
            }
            if let Some(param_oauth_public_key) = param_oauth_public_key {
                query_string.append_pair("oauthPublicKey",
                    &param_oauth_public_key.to_string());
            }
            if let Some(param_oauth_client_id) = param_oauth_client_id {
                query_string.append_pair("oauthClientId",
                    &param_oauth_client_id);
            }
            if let Some(param_oauth_secret_key) = param_oauth_secret_key {
                query_string.append_pair("oauthSecretKey",
                    &param_oauth_secret_key);
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        // Consumes basic body
        // Body parameter
        if let Some(param_body) = param_body {
        let body = serde_json::to_string(&param_body).expect("impossible to fail to serialize");
        *request.body_mut() = body_from_string(body);
        }

        let header = "application/json";
        request.headers_mut().insert(CONTENT_TYPE, HeaderValue::from_static(header));

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::ThirdPartyNetworkResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(UpdateNetworkResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_ticket_count(
        &self,
        param_version: f64,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_game_type: Option<String>,
        param_app_key: Option<String>,
        param_ticket_type: Option<String>,
        context: &C) -> Result<GetTicketCountResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/ticket/count",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_game_type) = param_game_type {
                query_string.append_pair("gameType",
                    &param_game_type);
            }
            if let Some(param_app_key) = param_app_key {
                query_string.append_pair("appKey",
                    &param_app_key);
            }
            if let Some(param_ticket_type) = param_ticket_type {
                query_string.append_pair("ticketType",
                    &param_ticket_type);
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::CountResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetTicketCountResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_ticket_list(
        &self,
        param_version: f64,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_ticket_object_type: Option<String>,
        param_action_type: Option<String>,
        param_ticket_ids: Option<String>,
        param_object_ids: Option<String>,
        param_receipt_tokens: Option<String>,
        param_game_type: Option<String>,
        param_app_key: Option<String>,
        context: &C) -> Result<GetTicketListResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/ticket/getList",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_ticket_object_type) = param_ticket_object_type {
                query_string.append_pair("ticketObjectType",
                    &param_ticket_object_type);
            }
            if let Some(param_action_type) = param_action_type {
                query_string.append_pair("actionType",
                    &param_action_type);
            }
            if let Some(param_ticket_ids) = param_ticket_ids {
                query_string.append_pair("ticketIds",
                    &param_ticket_ids);
            }
            if let Some(param_object_ids) = param_object_ids {
                query_string.append_pair("objectIds",
                    &param_object_ids);
            }
            if let Some(param_receipt_tokens) = param_receipt_tokens {
                query_string.append_pair("receiptTokens",
                    &param_receipt_tokens);
            }
            if let Some(param_game_type) = param_game_type {
                query_string.append_pair("gameType",
                    &param_game_type);
            }
            if let Some(param_app_key) = param_app_key {
                query_string.append_pair("appKey",
                    &param_app_key);
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::TicketListResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetTicketListResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn gift_purchase(
        &self,
        param_version: f64,
        param_receiver_account_id: i64,
        param_ticket_id: i64,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_asset_id: Option<i64>,
        param_custom_message: Option<String>,
        param_game_type: Option<String>,
        param_app_key: Option<String>,
        context: &C) -> Result<GiftPurchaseResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/purchase/gift",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
                query_string.append_pair("receiverAccountId",
                    &param_receiver_account_id.to_string());
                query_string.append_pair("ticketId",
                    &param_ticket_id.to_string());
            if let Some(param_asset_id) = param_asset_id {
                query_string.append_pair("assetId",
                    &param_asset_id.to_string());
            }
            if let Some(param_custom_message) = param_custom_message {
                query_string.append_pair("customMessage",
                    &param_custom_message);
            }
            if let Some(param_game_type) = param_game_type {
                query_string.append_pair("gameType",
                    &param_game_type);
            }
            if let Some(param_app_key) = param_app_key {
                query_string.append_pair("appKey",
                    &param_app_key);
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GiftPurchaseResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn save_ticket(
        &self,
        param_version: f64,
        param_action_type: String,
        param_ticket_object_type: String,
        param_return_nulls: Option<bool>,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_game_type: Option<String>,
        param_app_key: Option<String>,
        param_object_id: Option<i64>,
        param_purchase_code: Option<String>,
        param_receipt_token: Option<String>,
        param_receipt_data: Option<String>,
        param_count: Option<i64>,
        param_ticket_type: Option<String>,
        param_purchase_provider: Option<String>,
        param_purchase_type: Option<String>,
        param_return_profile_response: Option<bool>,
        param_include_profile_response: Option<bool>,
        param_app_version: Option<String>,
        context: &C) -> Result<SaveTicketResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/ticket/save",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_return_nulls) = param_return_nulls {
                query_string.append_pair("returnNulls",
                    &param_return_nulls.to_string());
            }
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_game_type) = param_game_type {
                query_string.append_pair("gameType",
                    &param_game_type);
            }
            if let Some(param_app_key) = param_app_key {
                query_string.append_pair("appKey",
                    &param_app_key);
            }
                query_string.append_pair("actionType",
                    &param_action_type);
                query_string.append_pair("ticketObjectType",
                    &param_ticket_object_type);
            if let Some(param_object_id) = param_object_id {
                query_string.append_pair("objectId",
                    &param_object_id.to_string());
            }
            if let Some(param_purchase_code) = param_purchase_code {
                query_string.append_pair("purchaseCode",
                    &param_purchase_code);
            }
            if let Some(param_receipt_token) = param_receipt_token {
                query_string.append_pair("receiptToken",
                    &param_receipt_token);
            }
            if let Some(param_receipt_data) = param_receipt_data {
                query_string.append_pair("receiptData",
                    &param_receipt_data);
            }
            if let Some(param_count) = param_count {
                query_string.append_pair("count",
                    &param_count.to_string());
            }
            if let Some(param_ticket_type) = param_ticket_type {
                query_string.append_pair("ticketType",
                    &param_ticket_type);
            }
            if let Some(param_purchase_provider) = param_purchase_provider {
                query_string.append_pair("purchaseProvider",
                    &param_purchase_provider);
            }
            if let Some(param_purchase_type) = param_purchase_type {
                query_string.append_pair("purchaseType",
                    &param_purchase_type);
            }
            if let Some(param_return_profile_response) = param_return_profile_response {
                query_string.append_pair("returnProfileResponse",
                    &param_return_profile_response.to_string());
            }
            if let Some(param_include_profile_response) = param_include_profile_response {
                query_string.append_pair("includeProfileResponse",
                    &param_include_profile_response.to_string());
            }
            if let Some(param_app_version) = param_app_version {
                query_string.append_pair("appVersion",
                    &param_app_version);
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::ProfileResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(SaveTicketResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn save_ticket_via_file_upload(
        &self,
        param_version: f64,
        param_action_type: String,
        param_ticket_object_type: String,
        param_receipt_data: swagger::ByteArray,
        param_return_nulls: Option<bool>,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_game_type: Option<String>,
        param_app_key: Option<String>,
        param_object_id: Option<i64>,
        param_purchase_code: Option<String>,
        param_receipt_token: Option<String>,
        param_count: Option<i64>,
        param_ticket_type: Option<String>,
        param_purchase_provider: Option<String>,
        param_purchase_type: Option<String>,
        param_return_profile_response: Option<bool>,
        param_include_profile_response: Option<bool>,
        param_app_version: Option<String>,
        context: &C) -> Result<SaveTicketViaFileUploadResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/ticket/save/fileUpload",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_return_nulls) = param_return_nulls {
                query_string.append_pair("returnNulls",
                    &param_return_nulls.to_string());
            }
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_game_type) = param_game_type {
                query_string.append_pair("gameType",
                    &param_game_type);
            }
            if let Some(param_app_key) = param_app_key {
                query_string.append_pair("appKey",
                    &param_app_key);
            }
                query_string.append_pair("actionType",
                    &param_action_type);
                query_string.append_pair("ticketObjectType",
                    &param_ticket_object_type);
            if let Some(param_object_id) = param_object_id {
                query_string.append_pair("objectId",
                    &param_object_id.to_string());
            }
            if let Some(param_purchase_code) = param_purchase_code {
                query_string.append_pair("purchaseCode",
                    &param_purchase_code);
            }
            if let Some(param_receipt_token) = param_receipt_token {
                query_string.append_pair("receiptToken",
                    &param_receipt_token);
            }
                query_string.append_pair("receiptData",
                    &param_receipt_data.to_string());
            if let Some(param_count) = param_count {
                query_string.append_pair("count",
                    &param_count.to_string());
            }
            if let Some(param_ticket_type) = param_ticket_type {
                query_string.append_pair("ticketType",
                    &param_ticket_type);
            }
            if let Some(param_purchase_provider) = param_purchase_provider {
                query_string.append_pair("purchaseProvider",
                    &param_purchase_provider);
            }
            if let Some(param_purchase_type) = param_purchase_type {
                query_string.append_pair("purchaseType",
                    &param_purchase_type);
            }
            if let Some(param_return_profile_response) = param_return_profile_response {
                query_string.append_pair("returnProfileResponse",
                    &param_return_profile_response.to_string());
            }
            if let Some(param_include_profile_response) = param_include_profile_response {
                query_string.append_pair("includeProfileResponse",
                    &param_include_profile_response.to_string());
            }
            if let Some(param_app_version) = param_app_version {
                query_string.append_pair("appVersion",
                    &param_app_version);
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::ProfileResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(SaveTicketViaFileUploadResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn ticket_offers(
        &self,
        param_version: f64,
        context: &C) -> Result<TicketOffersResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/ticket/ticketoffers",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::TicketOfferResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(TicketOffersResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn create_tournament(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_app_key: String,
        param_title: String,
        param_cost_to_play: i32,
        param_start_date: i64,
        param_sub_type: Option<String>,
        param_image_asset_id: Option<i64>,
        param_seconds_between_levels: Option<i32>,
        param_seconds_for_tie_breaker: Option<i32>,
        param_seconds_between_packs: Option<i32>,
        param_maximum_level_length: Option<i32>,
        param_cost_to_play_type: Option<String>,
        param_minimum_to_play: Option<i32>,
        param_starting_limit: Option<i32>,
        param_available_limit: Option<i32>,
        param_description: Option<String>,
        param_meta_data: Option<String>,
        param_audience_ids: Option<String>,
        param_active: Option<bool>,
        param_enable_buy_back: Option<bool>,
        param_offer_ids: Option<String>,
        param_offer_asset_id: Option<i64>,
        param_fixed_reward: Option<bool>,
        param_split_reward: Option<models::CreateTournamentSplitRewardParameter>,
        param_allocate_tickets: Option<bool>,
        param_tournament_data: Option<String>,
        param_mission_type: Option<models::CreateTournamentMissionTypeParameter>,
        param_visibility: Option<models::CreateTournamentVisibilityParameter>,
        param_preliminary_groups: Option<i32>,
        param_preliminary_group_advancements: Option<String>,
        param_enable_multiple_entries: Option<bool>,
        param_enable_multiple_votes: Option<bool>,
        param_featured: Option<bool>,
        param_winner_tag: Option<String>,
        param_tie_tag: Option<String>,
        context: &C) -> Result<CreateTournamentResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/tournament/create",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("appKey",
                    &param_app_key);
                query_string.append_pair("title",
                    &param_title);
            if let Some(param_sub_type) = param_sub_type {
                query_string.append_pair("subType",
                    &param_sub_type);
            }
            if let Some(param_image_asset_id) = param_image_asset_id {
                query_string.append_pair("imageAssetId",
                    &param_image_asset_id.to_string());
            }
            if let Some(param_seconds_between_levels) = param_seconds_between_levels {
                query_string.append_pair("secondsBetweenLevels",
                    &param_seconds_between_levels.to_string());
            }
            if let Some(param_seconds_for_tie_breaker) = param_seconds_for_tie_breaker {
                query_string.append_pair("secondsForTieBreaker",
                    &param_seconds_for_tie_breaker.to_string());
            }
            if let Some(param_seconds_between_packs) = param_seconds_between_packs {
                query_string.append_pair("secondsBetweenPacks",
                    &param_seconds_between_packs.to_string());
            }
            if let Some(param_maximum_level_length) = param_maximum_level_length {
                query_string.append_pair("maximumLevelLength",
                    &param_maximum_level_length.to_string());
            }
                query_string.append_pair("costToPlay",
                    &param_cost_to_play.to_string());
            if let Some(param_cost_to_play_type) = param_cost_to_play_type {
                query_string.append_pair("costToPlayType",
                    &param_cost_to_play_type);
            }
            if let Some(param_minimum_to_play) = param_minimum_to_play {
                query_string.append_pair("minimumToPlay",
                    &param_minimum_to_play.to_string());
            }
            if let Some(param_starting_limit) = param_starting_limit {
                query_string.append_pair("startingLimit",
                    &param_starting_limit.to_string());
            }
            if let Some(param_available_limit) = param_available_limit {
                query_string.append_pair("availableLimit",
                    &param_available_limit.to_string());
            }
            if let Some(param_description) = param_description {
                query_string.append_pair("description",
                    &param_description);
            }
            if let Some(param_meta_data) = param_meta_data {
                query_string.append_pair("metaData",
                    &param_meta_data);
            }
                query_string.append_pair("startDate",
                    &param_start_date.to_string());
            if let Some(param_audience_ids) = param_audience_ids {
                query_string.append_pair("audienceIds",
                    &param_audience_ids);
            }
            if let Some(param_active) = param_active {
                query_string.append_pair("active",
                    &param_active.to_string());
            }
            if let Some(param_enable_buy_back) = param_enable_buy_back {
                query_string.append_pair("enableBuyBack",
                    &param_enable_buy_back.to_string());
            }
            if let Some(param_offer_ids) = param_offer_ids {
                query_string.append_pair("offerIds",
                    &param_offer_ids);
            }
            if let Some(param_offer_asset_id) = param_offer_asset_id {
                query_string.append_pair("offerAssetId",
                    &param_offer_asset_id.to_string());
            }
            if let Some(param_fixed_reward) = param_fixed_reward {
                query_string.append_pair("fixedReward",
                    &param_fixed_reward.to_string());
            }
            if let Some(param_split_reward) = param_split_reward {
                query_string.append_pair("splitReward",
                    &param_split_reward.to_string());
            }
            if let Some(param_allocate_tickets) = param_allocate_tickets {
                query_string.append_pair("allocateTickets",
                    &param_allocate_tickets.to_string());
            }
            if let Some(param_tournament_data) = param_tournament_data {
                query_string.append_pair("tournamentData",
                    &param_tournament_data);
            }
            if let Some(param_mission_type) = param_mission_type {
                query_string.append_pair("missionType",
                    &param_mission_type.to_string());
            }
            if let Some(param_visibility) = param_visibility {
                query_string.append_pair("visibility",
                    &param_visibility.to_string());
            }
            if let Some(param_preliminary_groups) = param_preliminary_groups {
                query_string.append_pair("preliminaryGroups",
                    &param_preliminary_groups.to_string());
            }
            if let Some(param_preliminary_group_advancements) = param_preliminary_group_advancements {
                query_string.append_pair("preliminaryGroupAdvancements",
                    &param_preliminary_group_advancements);
            }
            if let Some(param_enable_multiple_entries) = param_enable_multiple_entries {
                query_string.append_pair("enableMultipleEntries",
                    &param_enable_multiple_entries.to_string());
            }
            if let Some(param_enable_multiple_votes) = param_enable_multiple_votes {
                query_string.append_pair("enableMultipleVotes",
                    &param_enable_multiple_votes.to_string());
            }
            if let Some(param_featured) = param_featured {
                query_string.append_pair("featured",
                    &param_featured.to_string());
            }
            if let Some(param_winner_tag) = param_winner_tag {
                query_string.append_pair("winnerTag",
                    &param_winner_tag);
            }
            if let Some(param_tie_tag) = param_tie_tag {
                query_string.append_pair("tieTag",
                    &param_tie_tag);
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::TournamentResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(CreateTournamentResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn delete_tournament(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_mission_id: i64,
        context: &C) -> Result<DeleteTournamentResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/tournament/delete",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("missionId",
                    &param_mission_id.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(DeleteTournamentResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_tournament(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_mission_id: Option<i64>,
        param_join_code: Option<String>,
        param_include_scores: Option<models::GetTournamentIncludeScoresParameter>,
        param_object_preview_size: Option<i32>,
        context: &C) -> Result<GetTournamentResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/tournament/get",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            if let Some(param_mission_id) = param_mission_id {
                query_string.append_pair("missionId",
                    &param_mission_id.to_string());
            }
            if let Some(param_join_code) = param_join_code {
                query_string.append_pair("joinCode",
                    &param_join_code);
            }
            if let Some(param_include_scores) = param_include_scores {
                query_string.append_pair("includeScores",
                    &param_include_scores.to_string());
            }
            if let Some(param_object_preview_size) = param_object_preview_size {
                query_string.append_pair("objectPreviewSize",
                    &param_object_preview_size.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::TournamentResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetTournamentResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn search_objects(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_game_level_id: i64,
        param_sort_field: Option<models::SearchObjectsSortFieldParameter>,
        param_descending: Option<bool>,
        param_start: Option<i32>,
        param_limit: Option<i32>,
        context: &C) -> Result<SearchObjectsResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/tournament/object/search",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("gameLevelId",
                    &param_game_level_id.to_string());
            if let Some(param_sort_field) = param_sort_field {
                query_string.append_pair("sortField",
                    &param_sort_field.to_string());
            }
            if let Some(param_descending) = param_descending {
                query_string.append_pair("descending",
                    &param_descending.to_string());
            }
            if let Some(param_start) = param_start {
                query_string.append_pair("start",
                    &param_start.to_string());
            }
            if let Some(param_limit) = param_limit {
                query_string.append_pair("limit",
                    &param_limit.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(SearchObjectsResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn search_rounds(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_app_key: String,
        param_status: Option<String>,
        param_mission_type: Option<models::SearchRoundsMissionTypeParameter>,
        param_current_only: Option<bool>,
        param_visibilities: Option<String>,
        param_start: Option<i32>,
        param_limit: Option<i32>,
        context: &C) -> Result<SearchRoundsResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/tournament/round/search",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("appKey",
                    &param_app_key);
            if let Some(param_status) = param_status {
                query_string.append_pair("status",
                    &param_status);
            }
            if let Some(param_mission_type) = param_mission_type {
                query_string.append_pair("missionType",
                    &param_mission_type.to_string());
            }
            if let Some(param_current_only) = param_current_only {
                query_string.append_pair("currentOnly",
                    &param_current_only.to_string());
            }
            if let Some(param_visibilities) = param_visibilities {
                query_string.append_pair("visibilities",
                    &param_visibilities);
            }
            if let Some(param_start) = param_start {
                query_string.append_pair("start",
                    &param_start.to_string());
            }
            if let Some(param_limit) = param_limit {
                query_string.append_pair("limit",
                    &param_limit.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(SearchRoundsResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn search_tournaments(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_app_key: String,
        param_keyword: Option<String>,
        param_sub_type: Option<String>,
        param_include_inactive: Option<bool>,
        param_mission_types: Option<String>,
        param_filter: Option<models::SearchTournamentsFilterParameter>,
        param_sort_field: Option<models::SearchTournamentsSortFieldParameter>,
        param_descending: Option<bool>,
        param_visibility: Option<String>,
        param_start: Option<i32>,
        param_limit: Option<i32>,
        context: &C) -> Result<SearchTournamentsResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/tournament/search",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("appKey",
                    &param_app_key);
            if let Some(param_keyword) = param_keyword {
                query_string.append_pair("keyword",
                    &param_keyword);
            }
            if let Some(param_sub_type) = param_sub_type {
                query_string.append_pair("subType",
                    &param_sub_type);
            }
            if let Some(param_include_inactive) = param_include_inactive {
                query_string.append_pair("includeInactive",
                    &param_include_inactive.to_string());
            }
            if let Some(param_mission_types) = param_mission_types {
                query_string.append_pair("missionTypes",
                    &param_mission_types);
            }
            if let Some(param_filter) = param_filter {
                query_string.append_pair("filter",
                    &param_filter.to_string());
            }
            if let Some(param_sort_field) = param_sort_field {
                query_string.append_pair("sortField",
                    &param_sort_field.to_string());
            }
            if let Some(param_descending) = param_descending {
                query_string.append_pair("descending",
                    &param_descending.to_string());
            }
            if let Some(param_visibility) = param_visibility {
                query_string.append_pair("visibility",
                    &param_visibility);
            }
            if let Some(param_start) = param_start {
                query_string.append_pair("start",
                    &param_start.to_string());
            }
            if let Some(param_limit) = param_limit {
                query_string.append_pair("limit",
                    &param_limit.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::MissionShortResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(SearchTournamentsResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn submit_tournament_score(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_app_key: String,
        param_mission_id: i64,
        param_game_id: i64,
        param_pack_id: i64,
        param_scores: String,
        param_game_level_id: Option<i64>,
        context: &C) -> Result<SubmitTournamentScoreResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/tournament/score",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("appKey",
                    &param_app_key);
                query_string.append_pair("missionId",
                    &param_mission_id.to_string());
                query_string.append_pair("gameId",
                    &param_game_id.to_string());
                query_string.append_pair("packId",
                    &param_pack_id.to_string());
            if let Some(param_game_level_id) = param_game_level_id {
                query_string.append_pair("gameLevelId",
                    &param_game_level_id.to_string());
            }
                query_string.append_pair("scores",
                    &param_scores);
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(SubmitTournamentScoreResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn submit_tournament_vote(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_app_key: String,
        param_mission_id: i64,
        param_game_object_id: i64,
        param_device_id: Option<String>,
        param_check_if_device_already_voted: Option<bool>,
        context: &C) -> Result<SubmitTournamentVoteResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/tournament/vote",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("appKey",
                    &param_app_key);
                query_string.append_pair("missionId",
                    &param_mission_id.to_string());
                query_string.append_pair("gameObjectId",
                    &param_game_object_id.to_string());
            if let Some(param_check_if_device_already_voted) = param_check_if_device_already_voted {
                query_string.append_pair("checkIfDeviceAlreadyVoted",
                    &param_check_if_device_already_voted.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(SubmitTournamentVoteResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn substitute_tournament_player(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_mission_id: i64,
        param_pack_id: i64,
        param_game_level_id: i64,
        context: &C) -> Result<SubstituteTournamentPlayerResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/tournament/substitute",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("missionId",
                    &param_mission_id.to_string());
                query_string.append_pair("packId",
                    &param_pack_id.to_string());
                query_string.append_pair("gameLevelId",
                    &param_game_level_id.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(SubstituteTournamentPlayerResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn update_tournament(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_mission_id: i64,
        param_title: Option<String>,
        param_sub_type: Option<String>,
        param_image_asset_id: Option<i64>,
        param_seconds_between_levels: Option<i32>,
        param_seconds_for_tie_breaker: Option<i32>,
        param_seconds_between_packs: Option<i32>,
        param_maximum_level_length: Option<i32>,
        param_cost_to_play: Option<i32>,
        param_cost_to_play_type: Option<String>,
        param_minimum_to_play: Option<i32>,
        param_starting_limit: Option<i32>,
        param_available_limit: Option<i32>,
        param_description: Option<String>,
        param_meta_data: Option<String>,
        param_start_date: Option<i64>,
        param_audience_ids: Option<String>,
        param_active: Option<bool>,
        param_enable_buy_back: Option<bool>,
        param_offer_ids: Option<String>,
        param_offer_asset_id: Option<i64>,
        param_fixed_reward: Option<bool>,
        param_split_reward: Option<models::UpdateTournamentSplitRewardParameter>,
        param_allocate_tickets: Option<bool>,
        param_tournament_data: Option<String>,
        param_visibility: Option<models::CreateMediaOfferVisibilityParameter>,
        param_preliminary_groups: Option<i32>,
        param_preliminary_group_advancements: Option<String>,
        param_enable_multiple_entries: Option<bool>,
        param_enable_multiple_votes: Option<bool>,
        param_featured: Option<bool>,
        param_winner_tag: Option<String>,
        param_tie_tag: Option<String>,
        context: &C) -> Result<UpdateTournamentResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/tournament/update",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("missionId",
                    &param_mission_id.to_string());
            if let Some(param_title) = param_title {
                query_string.append_pair("title",
                    &param_title);
            }
            if let Some(param_sub_type) = param_sub_type {
                query_string.append_pair("subType",
                    &param_sub_type);
            }
            if let Some(param_image_asset_id) = param_image_asset_id {
                query_string.append_pair("imageAssetId",
                    &param_image_asset_id.to_string());
            }
            if let Some(param_seconds_between_levels) = param_seconds_between_levels {
                query_string.append_pair("secondsBetweenLevels",
                    &param_seconds_between_levels.to_string());
            }
            if let Some(param_seconds_for_tie_breaker) = param_seconds_for_tie_breaker {
                query_string.append_pair("secondsForTieBreaker",
                    &param_seconds_for_tie_breaker.to_string());
            }
            if let Some(param_seconds_between_packs) = param_seconds_between_packs {
                query_string.append_pair("secondsBetweenPacks",
                    &param_seconds_between_packs.to_string());
            }
            if let Some(param_maximum_level_length) = param_maximum_level_length {
                query_string.append_pair("maximumLevelLength",
                    &param_maximum_level_length.to_string());
            }
            if let Some(param_cost_to_play) = param_cost_to_play {
                query_string.append_pair("costToPlay",
                    &param_cost_to_play.to_string());
            }
            if let Some(param_cost_to_play_type) = param_cost_to_play_type {
                query_string.append_pair("costToPlayType",
                    &param_cost_to_play_type);
            }
            if let Some(param_minimum_to_play) = param_minimum_to_play {
                query_string.append_pair("minimumToPlay",
                    &param_minimum_to_play.to_string());
            }
            if let Some(param_starting_limit) = param_starting_limit {
                query_string.append_pair("startingLimit",
                    &param_starting_limit.to_string());
            }
            if let Some(param_available_limit) = param_available_limit {
                query_string.append_pair("availableLimit",
                    &param_available_limit.to_string());
            }
            if let Some(param_description) = param_description {
                query_string.append_pair("description",
                    &param_description);
            }
            if let Some(param_meta_data) = param_meta_data {
                query_string.append_pair("metaData",
                    &param_meta_data);
            }
            if let Some(param_start_date) = param_start_date {
                query_string.append_pair("startDate",
                    &param_start_date.to_string());
            }
            if let Some(param_audience_ids) = param_audience_ids {
                query_string.append_pair("audienceIds",
                    &param_audience_ids);
            }
            if let Some(param_active) = param_active {
                query_string.append_pair("active",
                    &param_active.to_string());
            }
            if let Some(param_enable_buy_back) = param_enable_buy_back {
                query_string.append_pair("enableBuyBack",
                    &param_enable_buy_back.to_string());
            }
            if let Some(param_offer_ids) = param_offer_ids {
                query_string.append_pair("offerIds",
                    &param_offer_ids);
            }
            if let Some(param_offer_asset_id) = param_offer_asset_id {
                query_string.append_pair("offerAssetId",
                    &param_offer_asset_id.to_string());
            }
            if let Some(param_fixed_reward) = param_fixed_reward {
                query_string.append_pair("fixedReward",
                    &param_fixed_reward.to_string());
            }
            if let Some(param_split_reward) = param_split_reward {
                query_string.append_pair("splitReward",
                    &param_split_reward.to_string());
            }
            if let Some(param_allocate_tickets) = param_allocate_tickets {
                query_string.append_pair("allocateTickets",
                    &param_allocate_tickets.to_string());
            }
            if let Some(param_tournament_data) = param_tournament_data {
                query_string.append_pair("tournamentData",
                    &param_tournament_data);
            }
            if let Some(param_visibility) = param_visibility {
                query_string.append_pair("visibility",
                    &param_visibility.to_string());
            }
            if let Some(param_preliminary_groups) = param_preliminary_groups {
                query_string.append_pair("preliminaryGroups",
                    &param_preliminary_groups.to_string());
            }
            if let Some(param_preliminary_group_advancements) = param_preliminary_group_advancements {
                query_string.append_pair("preliminaryGroupAdvancements",
                    &param_preliminary_group_advancements);
            }
            if let Some(param_enable_multiple_entries) = param_enable_multiple_entries {
                query_string.append_pair("enableMultipleEntries",
                    &param_enable_multiple_entries.to_string());
            }
            if let Some(param_enable_multiple_votes) = param_enable_multiple_votes {
                query_string.append_pair("enableMultipleVotes",
                    &param_enable_multiple_votes.to_string());
            }
            if let Some(param_featured) = param_featured {
                query_string.append_pair("featured",
                    &param_featured.to_string());
            }
            if let Some(param_winner_tag) = param_winner_tag {
                query_string.append_pair("winnerTag",
                    &param_winner_tag);
            }
            if let Some(param_tie_tag) = param_tie_tag {
                query_string.append_pair("tieTag",
                    &param_tie_tag);
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::TournamentResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(UpdateTournamentResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn batch_save_tracking(
        &self,
        param_version: f64,
        param_data: String,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_generate_accounts: Option<bool>,
        param_update_account_locations: Option<bool>,
        param_default_tag: Option<String>,
        param_slave_uid: Option<String>,
        context: &C) -> Result<BatchSaveTrackingResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/tracking/batch/create",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
                query_string.append_pair("data",
                    &param_data);
            if let Some(param_generate_accounts) = param_generate_accounts {
                query_string.append_pair("generateAccounts",
                    &param_generate_accounts.to_string());
            }
            if let Some(param_update_account_locations) = param_update_account_locations {
                query_string.append_pair("updateAccountLocations",
                    &param_update_account_locations.to_string());
            }
            if let Some(param_default_tag) = param_default_tag {
                query_string.append_pair("defaultTag",
                    &param_default_tag);
            }
            if let Some(param_slave_uid) = param_slave_uid {
                query_string.append_pair("slaveUID",
                    &param_slave_uid);
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<Vec<models::Leg>>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(BatchSaveTrackingResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_predicted_locations(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_latitude: Option<f64>,
        param_longitude: Option<f64>,
        param_date_check: Option<i64>,
        param_hour_check: Option<String>,
        param_threshold: Option<i64>,
        param_distance_unit: Option<models::GetOfferListCountsDistanceUnitParameter>,
        param_search_range: Option<f64>,
        param_sort_order: Option<models::GetPredictedLocationsSortOrderParameter>,
        context: &C) -> Result<GetPredictedLocationsResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/tracking/predicted/get",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            if let Some(param_latitude) = param_latitude {
                query_string.append_pair("latitude",
                    &param_latitude.to_string());
            }
            if let Some(param_longitude) = param_longitude {
                query_string.append_pair("longitude",
                    &param_longitude.to_string());
            }
            if let Some(param_date_check) = param_date_check {
                query_string.append_pair("dateCheck",
                    &param_date_check.to_string());
            }
            if let Some(param_hour_check) = param_hour_check {
                query_string.append_pair("hourCheck",
                    &param_hour_check);
            }
            if let Some(param_threshold) = param_threshold {
                query_string.append_pair("threshold",
                    &param_threshold.to_string());
            }
            if let Some(param_distance_unit) = param_distance_unit {
                query_string.append_pair("distanceUnit",
                    &param_distance_unit.to_string());
            }
            if let Some(param_search_range) = param_search_range {
                query_string.append_pair("searchRange",
                    &param_search_range.to_string());
            }
            if let Some(param_sort_order) = param_sort_order {
                query_string.append_pair("sortOrder",
                    &param_sort_order.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::PredictedLocationResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetPredictedLocationsResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_predicted_path(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_start_step_id: i64,
        param_end_step_id: i64,
        context: &C) -> Result<GetPredictedPathResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/tracking/path/get",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("startStepId",
                    &param_start_step_id.to_string());
                query_string.append_pair("endStepId",
                    &param_end_step_id.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<Vec<models::StepResponse>>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetPredictedPathResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_preferred_locations(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_latitude: Option<f64>,
        param_longitude: Option<f64>,
        param_date_check: Option<i64>,
        param_hour_check: Option<String>,
        param_sort_field: Option<String>,
        param_descending: Option<bool>,
        param_start: Option<i32>,
        param_limit: Option<i32>,
        param_search_range: Option<f64>,
        param_distance_unit: Option<models::GetOfferListCountsDistanceUnitParameter>,
        context: &C) -> Result<GetPreferredLocationsResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/tracking/preferred/search",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            if let Some(param_latitude) = param_latitude {
                query_string.append_pair("latitude",
                    &param_latitude.to_string());
            }
            if let Some(param_longitude) = param_longitude {
                query_string.append_pair("longitude",
                    &param_longitude.to_string());
            }
            if let Some(param_date_check) = param_date_check {
                query_string.append_pair("dateCheck",
                    &param_date_check.to_string());
            }
            if let Some(param_hour_check) = param_hour_check {
                query_string.append_pair("hourCheck",
                    &param_hour_check);
            }
            if let Some(param_sort_field) = param_sort_field {
                query_string.append_pair("sortField",
                    &param_sort_field);
            }
            if let Some(param_descending) = param_descending {
                query_string.append_pair("descending",
                    &param_descending.to_string());
            }
            if let Some(param_start) = param_start {
                query_string.append_pair("start",
                    &param_start.to_string());
            }
            if let Some(param_limit) = param_limit {
                query_string.append_pair("limit",
                    &param_limit.to_string());
            }
            if let Some(param_search_range) = param_search_range {
                query_string.append_pair("searchRange",
                    &param_search_range.to_string());
            }
            if let Some(param_distance_unit) = param_distance_unit {
                query_string.append_pair("distanceUnit",
                    &param_distance_unit.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<Vec<models::PreferredLocationResponse>>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetPreferredLocationsResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_tracking_legs(
        &self,
        param_version: f64,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_owner_id: Option<i64>,
        param_tracking_device_id: Option<String>,
        param_start_date: Option<i64>,
        param_end_date: Option<i64>,
        param_tags: Option<String>,
        param_get_last_point: Option<bool>,
        context: &C) -> Result<GetTrackingLegsResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/tracking/search",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_owner_id) = param_owner_id {
                query_string.append_pair("ownerId",
                    &param_owner_id.to_string());
            }
            if let Some(param_tracking_device_id) = param_tracking_device_id {
                query_string.append_pair("trackingDeviceId",
                    &param_tracking_device_id);
            }
            if let Some(param_start_date) = param_start_date {
                query_string.append_pair("startDate",
                    &param_start_date.to_string());
            }
            if let Some(param_end_date) = param_end_date {
                query_string.append_pair("endDate",
                    &param_end_date.to_string());
            }
            if let Some(param_tags) = param_tags {
                query_string.append_pair("tags",
                    &param_tags);
            }
            if let Some(param_get_last_point) = param_get_last_point {
                query_string.append_pair("getLastPoint",
                    &param_get_last_point.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<Vec<models::LegResponse>>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetTrackingLegsResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn save_tracking_leg(
        &self,
        param_version: f64,
        param_start_lat: f64,
        param_start_lng: f64,
        param_start_date: i64,
        param_end_lat: f64,
        param_end_lng: f64,
        param_end_date: i64,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_distance: Option<f64>,
        param_duration: Option<i64>,
        param_steps: Option<String>,
        param_tags: Option<String>,
        context: &C) -> Result<SaveTrackingLegResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/tracking/leg/create",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_distance) = param_distance {
                query_string.append_pair("distance",
                    &param_distance.to_string());
            }
            if let Some(param_duration) = param_duration {
                query_string.append_pair("duration",
                    &param_duration.to_string());
            }
                query_string.append_pair("startLat",
                    &param_start_lat.to_string());
                query_string.append_pair("startLng",
                    &param_start_lng.to_string());
                query_string.append_pair("startDate",
                    &param_start_date.to_string());
                query_string.append_pair("endLat",
                    &param_end_lat.to_string());
                query_string.append_pair("endLng",
                    &param_end_lng.to_string());
                query_string.append_pair("endDate",
                    &param_end_date.to_string());
            if let Some(param_steps) = param_steps {
                query_string.append_pair("steps",
                    &param_steps);
            }
            if let Some(param_tags) = param_tags {
                query_string.append_pair("tags",
                    &param_tags);
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(SaveTrackingLegResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn save_tracking_step(
        &self,
        param_version: f64,
        param_leg_id: i64,
        param_start_lat: f64,
        param_start_lng: f64,
        param_start_date: i64,
        param_end_lat: f64,
        param_end_lng: f64,
        param_end_date: i64,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_distance: Option<f64>,
        param_duration: Option<i64>,
        context: &C) -> Result<SaveTrackingStepResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/tracking/step/create",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
                query_string.append_pair("legId",
                    &param_leg_id.to_string());
            if let Some(param_distance) = param_distance {
                query_string.append_pair("distance",
                    &param_distance.to_string());
            }
            if let Some(param_duration) = param_duration {
                query_string.append_pair("duration",
                    &param_duration.to_string());
            }
                query_string.append_pair("startLat",
                    &param_start_lat.to_string());
                query_string.append_pair("startLng",
                    &param_start_lng.to_string());
                query_string.append_pair("startDate",
                    &param_start_date.to_string());
                query_string.append_pair("endLat",
                    &param_end_lat.to_string());
                query_string.append_pair("endLng",
                    &param_end_lng.to_string());
                query_string.append_pair("endDate",
                    &param_end_date.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(SaveTrackingStepResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn search_accounts_with_tracking_legs(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_keyword: Option<String>,
        param_start_date: Option<i64>,
        param_end_date: Option<i64>,
        param_tags: Option<String>,
        param_audience_ids: Option<String>,
        param_latitude: Option<f64>,
        param_longitude: Option<f64>,
        param_range: Option<f64>,
        param_sort_field: Option<String>,
        param_descending: Option<bool>,
        param_start: Option<i32>,
        param_limit: Option<i32>,
        param_active_only: Option<bool>,
        context: &C) -> Result<SearchAccountsWithTrackingLegsResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/tracking/list",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            if let Some(param_keyword) = param_keyword {
                query_string.append_pair("keyword",
                    &param_keyword);
            }
            if let Some(param_start_date) = param_start_date {
                query_string.append_pair("startDate",
                    &param_start_date.to_string());
            }
            if let Some(param_end_date) = param_end_date {
                query_string.append_pair("endDate",
                    &param_end_date.to_string());
            }
            if let Some(param_tags) = param_tags {
                query_string.append_pair("tags",
                    &param_tags);
            }
            if let Some(param_audience_ids) = param_audience_ids {
                query_string.append_pair("audienceIds",
                    &param_audience_ids);
            }
            if let Some(param_latitude) = param_latitude {
                query_string.append_pair("latitude",
                    &param_latitude.to_string());
            }
            if let Some(param_longitude) = param_longitude {
                query_string.append_pair("longitude",
                    &param_longitude.to_string());
            }
            if let Some(param_range) = param_range {
                query_string.append_pair("range",
                    &param_range.to_string());
            }
            if let Some(param_sort_field) = param_sort_field {
                query_string.append_pair("sortField",
                    &param_sort_field);
            }
            if let Some(param_descending) = param_descending {
                query_string.append_pair("descending",
                    &param_descending.to_string());
            }
            if let Some(param_start) = param_start {
                query_string.append_pair("start",
                    &param_start.to_string());
            }
            if let Some(param_limit) = param_limit {
                query_string.append_pair("limit",
                    &param_limit.to_string());
            }
            if let Some(param_active_only) = param_active_only {
                query_string.append_pair("activeOnly",
                    &param_active_only.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<Vec<models::AccountMiniResponse>>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(SearchAccountsWithTrackingLegsResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn search_tracking_legs(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_app_key: String,
        param_tracking_device_id: Option<String>,
        param_start_date: Option<i64>,
        param_end_date: Option<i64>,
        param_tags: Option<String>,
        param_start: Option<i32>,
        param_limit: Option<i32>,
        context: &C) -> Result<SearchTrackingLegsResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/tracking/searchByBillable",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("appKey",
                    &param_app_key);
            if let Some(param_tracking_device_id) = param_tracking_device_id {
                query_string.append_pair("trackingDeviceId",
                    &param_tracking_device_id);
            }
            if let Some(param_start_date) = param_start_date {
                query_string.append_pair("startDate",
                    &param_start_date.to_string());
            }
            if let Some(param_end_date) = param_end_date {
                query_string.append_pair("endDate",
                    &param_end_date.to_string());
            }
            if let Some(param_tags) = param_tags {
                query_string.append_pair("tags",
                    &param_tags);
            }
            if let Some(param_start) = param_start {
                query_string.append_pair("start",
                    &param_start.to_string());
            }
            if let Some(param_limit) = param_limit {
                query_string.append_pair("limit",
                    &param_limit.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<Vec<models::LegResponse>>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(SearchTrackingLegsResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn create_trigger(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_name: String,
        param_app_key: Option<String>,
        param_grouping_id: Option<String>,
        param_endpoint_url: Option<String>,
        param_payload: Option<String>,
        param_scheduled_date: Option<i64>,
        param_start_date: Option<i64>,
        param_end_date: Option<i64>,
        param_cron_expression: Option<String>,
        param_conditional_input: Option<String>,
        param_visibility: Option<models::AddAlbumCollectionVisibilityParameter>,
        param_active: Option<bool>,
        context: &C) -> Result<CreateTriggerResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/trigger/create",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("name",
                    &param_name);
            if let Some(param_app_key) = param_app_key {
                query_string.append_pair("appKey",
                    &param_app_key);
            }
            if let Some(param_grouping_id) = param_grouping_id {
                query_string.append_pair("groupingId",
                    &param_grouping_id);
            }
            if let Some(param_endpoint_url) = param_endpoint_url {
                query_string.append_pair("endpointURL",
                    &param_endpoint_url);
            }
            if let Some(param_payload) = param_payload {
                query_string.append_pair("payload",
                    &param_payload);
            }
            if let Some(param_scheduled_date) = param_scheduled_date {
                query_string.append_pair("scheduledDate",
                    &param_scheduled_date.to_string());
            }
            if let Some(param_start_date) = param_start_date {
                query_string.append_pair("startDate",
                    &param_start_date.to_string());
            }
            if let Some(param_end_date) = param_end_date {
                query_string.append_pair("endDate",
                    &param_end_date.to_string());
            }
            if let Some(param_cron_expression) = param_cron_expression {
                query_string.append_pair("cronExpression",
                    &param_cron_expression);
            }
            if let Some(param_conditional_input) = param_conditional_input {
                query_string.append_pair("conditionalInput",
                    &param_conditional_input);
            }
            if let Some(param_visibility) = param_visibility {
                query_string.append_pair("visibility",
                    &param_visibility.to_string());
            }
            if let Some(param_active) = param_active {
                query_string.append_pair("active",
                    &param_active.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::TriggerResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(CreateTriggerResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn delete_trigger(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_trigger_id: i64,
        context: &C) -> Result<DeleteTriggerResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/trigger/delete",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("triggerId",
                    &param_trigger_id.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(DeleteTriggerResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_trigger(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_trigger_id: i64,
        context: &C) -> Result<GetTriggerResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/trigger/get",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("triggerId",
                    &param_trigger_id.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::TriggerResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetTriggerResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn search_triggers(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_grouping_id: Option<String>,
        param_filter: Option<String>,
        param_statuses: Option<String>,
        param_template_types: Option<String>,
        param_app_key: Option<String>,
        param_keyword: Option<String>,
        param_sort_field: Option<String>,
        param_descending: Option<bool>,
        param_start: Option<i32>,
        param_limit: Option<i32>,
        param_active_only: Option<bool>,
        context: &C) -> Result<SearchTriggersResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/trigger/search",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            if let Some(param_grouping_id) = param_grouping_id {
                query_string.append_pair("groupingId",
                    &param_grouping_id);
            }
            if let Some(param_filter) = param_filter {
                query_string.append_pair("filter",
                    &param_filter);
            }
            if let Some(param_statuses) = param_statuses {
                query_string.append_pair("statuses",
                    &param_statuses);
            }
            if let Some(param_template_types) = param_template_types {
                query_string.append_pair("templateTypes",
                    &param_template_types);
            }
            if let Some(param_app_key) = param_app_key {
                query_string.append_pair("appKey",
                    &param_app_key);
            }
            if let Some(param_keyword) = param_keyword {
                query_string.append_pair("keyword",
                    &param_keyword);
            }
            if let Some(param_sort_field) = param_sort_field {
                query_string.append_pair("sortField",
                    &param_sort_field);
            }
            if let Some(param_descending) = param_descending {
                query_string.append_pair("descending",
                    &param_descending.to_string());
            }
            if let Some(param_start) = param_start {
                query_string.append_pair("start",
                    &param_start.to_string());
            }
            if let Some(param_limit) = param_limit {
                query_string.append_pair("limit",
                    &param_limit.to_string());
            }
            if let Some(param_active_only) = param_active_only {
                query_string.append_pair("activeOnly",
                    &param_active_only.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<Vec<models::TriggerResponse>>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(SearchTriggersResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn update_trigger(
        &self,
        param_version: f64,
        param_trigger_id: i64,
        param_account_id: i64,
        param_name: Option<String>,
        param_app_key: Option<String>,
        param_grouping_id: Option<String>,
        param_endpoint_url: Option<String>,
        param_payload: Option<String>,
        param_scheduled_date: Option<i64>,
        param_start_date: Option<i64>,
        param_end_date: Option<i64>,
        param_cron_expression: Option<String>,
        param_conditional_input: Option<String>,
        param_visibility: Option<models::AddAlbumCollectionVisibilityParameter>,
        param_active: Option<bool>,
        context: &C) -> Result<UpdateTriggerResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/trigger/update",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("triggerId",
                    &param_trigger_id.to_string());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            if let Some(param_name) = param_name {
                query_string.append_pair("name",
                    &param_name);
            }
            if let Some(param_app_key) = param_app_key {
                query_string.append_pair("appKey",
                    &param_app_key);
            }
            if let Some(param_grouping_id) = param_grouping_id {
                query_string.append_pair("groupingId",
                    &param_grouping_id);
            }
            if let Some(param_endpoint_url) = param_endpoint_url {
                query_string.append_pair("endpointURL",
                    &param_endpoint_url);
            }
            if let Some(param_payload) = param_payload {
                query_string.append_pair("payload",
                    &param_payload);
            }
            if let Some(param_scheduled_date) = param_scheduled_date {
                query_string.append_pair("scheduledDate",
                    &param_scheduled_date.to_string());
            }
            if let Some(param_start_date) = param_start_date {
                query_string.append_pair("startDate",
                    &param_start_date.to_string());
            }
            if let Some(param_end_date) = param_end_date {
                query_string.append_pair("endDate",
                    &param_end_date.to_string());
            }
            if let Some(param_cron_expression) = param_cron_expression {
                query_string.append_pair("cronExpression",
                    &param_cron_expression);
            }
            if let Some(param_conditional_input) = param_conditional_input {
                query_string.append_pair("conditionalInput",
                    &param_conditional_input);
            }
            if let Some(param_visibility) = param_visibility {
                query_string.append_pair("visibility",
                    &param_visibility.to_string());
            }
            if let Some(param_active) = param_active {
                query_string.append_pair("active",
                    &param_active.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::TriggerResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(UpdateTriggerResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn create_trip(
        &self,
        param_version: f64,
        param_body: Option<models::Trip>,
        context: &C) -> Result<CreateTripResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/trip",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        // Consumes basic body
        // Body parameter
        if let Some(param_body) = param_body {
        let body = serde_json::to_string(&param_body).expect("impossible to fail to serialize");
        *request.body_mut() = body_from_string(body);
        }

        let header = "application/json";
        request.headers_mut().insert(CONTENT_TYPE, HeaderValue::from_static(header));

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::Trip>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(CreateTripResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn process_trip_matches(
        &self,
        param_version: f64,
        param_start_date: Option<i64>,
        param_end_date: Option<i64>,
        param_trip_id: Option<i64>,
        context: &C) -> Result<ProcessTripMatchesResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/trip/match/process",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_start_date) = param_start_date {
                query_string.append_pair("startDate",
                    &param_start_date.to_string());
            }
            if let Some(param_end_date) = param_end_date {
                query_string.append_pair("endDate",
                    &param_end_date.to_string());
            }
            if let Some(param_trip_id) = param_trip_id {
                query_string.append_pair("tripId",
                    &param_trip_id.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<Vec<models::Trip>>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(ProcessTripMatchesResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn search(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_sort_field: String,
        param_descending: bool,
        param_start: i32,
        param_limit: i32,
        param_active_only: bool,
        param_start_date: Option<i64>,
        param_end_date: Option<i64>,
        param_has_notifications: Option<bool>,
        context: &C) -> Result<SearchResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/trip",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            if let Some(param_start_date) = param_start_date {
                query_string.append_pair("startDate",
                    &param_start_date.to_string());
            }
            if let Some(param_end_date) = param_end_date {
                query_string.append_pair("endDate",
                    &param_end_date.to_string());
            }
            if let Some(param_has_notifications) = param_has_notifications {
                query_string.append_pair("hasNotifications",
                    &param_has_notifications.to_string());
            }
                query_string.append_pair("sortField",
                    &param_sort_field);
                query_string.append_pair("descending",
                    &param_descending.to_string());
                query_string.append_pair("start",
                    &param_start.to_string());
                query_string.append_pair("limit",
                    &param_limit.to_string());
                query_string.append_pair("activeOnly",
                    &param_active_only.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<Vec<models::Trip>>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(SearchResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn search_trips(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_sort_field: String,
        param_descending: bool,
        param_start: i32,
        param_limit: i32,
        param_active_only: bool,
        param_start_date: Option<i64>,
        param_end_date: Option<i64>,
        param_matched_has_route: Option<bool>,
        param_matched_has_driver: Option<bool>,
        context: &C) -> Result<SearchTripsResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/trip/match",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            if let Some(param_start_date) = param_start_date {
                query_string.append_pair("startDate",
                    &param_start_date.to_string());
            }
            if let Some(param_end_date) = param_end_date {
                query_string.append_pair("endDate",
                    &param_end_date.to_string());
            }
            if let Some(param_matched_has_route) = param_matched_has_route {
                query_string.append_pair("matchedHasRoute",
                    &param_matched_has_route.to_string());
            }
            if let Some(param_matched_has_driver) = param_matched_has_driver {
                query_string.append_pair("matchedHasDriver",
                    &param_matched_has_driver.to_string());
            }
                query_string.append_pair("sortField",
                    &param_sort_field);
                query_string.append_pair("descending",
                    &param_descending.to_string());
                query_string.append_pair("start",
                    &param_start.to_string());
                query_string.append_pair("limit",
                    &param_limit.to_string());
                query_string.append_pair("activeOnly",
                    &param_active_only.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<Vec<models::Trip>>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(SearchTripsResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn update_trip_notifications(
        &self,
        param_version: f64,
        param_id: i64,
        param_notifications: Option<String>,
        context: &C) -> Result<UpdateTripNotificationsResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/trip/notifications",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("id",
                    &param_id.to_string());
            if let Some(param_notifications) = param_notifications {
                query_string.append_pair("notifications",
                    &param_notifications);
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::Trip>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(UpdateTripNotificationsResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn delete(
        &self,
        param_version: f64,
        param_id: i64,
        context: &C) -> Result<DeleteResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/trip/{id}",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
            ,id=utf8_percent_encode(&param_id.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("DELETE")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            0 => {
                Ok(
                    DeleteResponse::SuccessfulOperation
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn drive_trip(
        &self,
        param_version: f64,
        param_id: i64,
        param_recurrence: bool,
        context: &C) -> Result<DriveTripResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/trip/{id}/drive",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
            ,id=utf8_percent_encode(&param_id.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("recurrence",
                    &param_recurrence.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::Trip>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(DriveTripResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn flexible_trip(
        &self,
        param_version: f64,
        param_id: i64,
        param_recurrence: bool,
        context: &C) -> Result<FlexibleTripResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/trip/{id}/flexible",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
            ,id=utf8_percent_encode(&param_id.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("recurrence",
                    &param_recurrence.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::Trip>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(FlexibleTripResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_trip(
        &self,
        param_version: f64,
        param_id: i64,
        context: &C) -> Result<GetTripResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/trip/{id}",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
            ,id=utf8_percent_encode(&param_id.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::Trip>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetTripResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_trip_matches(
        &self,
        param_version: f64,
        param_id: i64,
        param_sort_field: String,
        param_descending: bool,
        param_start: i32,
        param_limit: i32,
        param_active_only: bool,
        param_matched_has_route: Option<bool>,
        param_matched_has_driver: Option<bool>,
        context: &C) -> Result<GetTripMatchesResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/trip/{id}/match",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
            ,id=utf8_percent_encode(&param_id.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_matched_has_route) = param_matched_has_route {
                query_string.append_pair("matchedHasRoute",
                    &param_matched_has_route.to_string());
            }
            if let Some(param_matched_has_driver) = param_matched_has_driver {
                query_string.append_pair("matchedHasDriver",
                    &param_matched_has_driver.to_string());
            }
                query_string.append_pair("sortField",
                    &param_sort_field);
                query_string.append_pair("descending",
                    &param_descending.to_string());
                query_string.append_pair("start",
                    &param_start.to_string());
                query_string.append_pair("limit",
                    &param_limit.to_string());
                query_string.append_pair("activeOnly",
                    &param_active_only.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<Vec<models::Trip>>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetTripMatchesResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn ride(
        &self,
        param_version: f64,
        param_id: i64,
        param_recurrence: bool,
        context: &C) -> Result<RideResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/trip/{id}/ride",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
            ,id=utf8_percent_encode(&param_id.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("recurrence",
                    &param_recurrence.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::Trip>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(RideResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn update_locations(
        &self,
        param_version: f64,
        param_id: i64,
        param_body: Option<models::Trip>,
        context: &C) -> Result<UpdateLocationsResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/trip/{id}/locations",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
            ,id=utf8_percent_encode(&param_id.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        // Consumes basic body
        // Body parameter
        if let Some(param_body) = param_body {
        let body = serde_json::to_string(&param_body).expect("impossible to fail to serialize");
        *request.body_mut() = body_from_string(body);
        }

        let header = "application/json";
        request.headers_mut().insert(CONTENT_TYPE, HeaderValue::from_static(header));

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::Trip>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(UpdateLocationsResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn update_recurrence_locations(
        &self,
        param_version: f64,
        param_id: i64,
        param_body: Option<models::Trip>,
        context: &C) -> Result<UpdateRecurrenceLocationsResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/trip/{id}/locations/recurrence",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
            ,id=utf8_percent_encode(&param_id.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        // Consumes basic body
        // Body parameter
        if let Some(param_body) = param_body {
        let body = serde_json::to_string(&param_body).expect("impossible to fail to serialize");
        *request.body_mut() = body_from_string(body);
        }

        let header = "application/json";
        request.headers_mut().insert(CONTENT_TYPE, HeaderValue::from_static(header));

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<Vec<models::Trip>>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(UpdateRecurrenceLocationsResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn update_recurrence_shipments(
        &self,
        param_version: f64,
        param_id: i64,
        param_body: Option<models::Trip>,
        context: &C) -> Result<UpdateRecurrenceShipmentsResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/trip/{id}/shipments/recurrence",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
            ,id=utf8_percent_encode(&param_id.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        // Consumes basic body
        // Body parameter
        if let Some(param_body) = param_body {
        let body = serde_json::to_string(&param_body).expect("impossible to fail to serialize");
        *request.body_mut() = body_from_string(body);
        }

        let header = "application/json";
        request.headers_mut().insert(CONTENT_TYPE, HeaderValue::from_static(header));

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<Vec<models::Trip>>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(UpdateRecurrenceShipmentsResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn update_shipments(
        &self,
        param_version: f64,
        param_id: i64,
        param_body: Option<models::Trip>,
        context: &C) -> Result<UpdateShipmentsResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/trip/{id}/shipments",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
            ,id=utf8_percent_encode(&param_id.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        // Consumes basic body
        // Body parameter
        if let Some(param_body) = param_body {
        let body = serde_json::to_string(&param_body).expect("impossible to fail to serialize");
        *request.body_mut() = body_from_string(body);
        }

        let header = "application/json";
        request.headers_mut().insert(CONTENT_TYPE, HeaderValue::from_static(header));

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::Trip>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(UpdateShipmentsResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn update_trip(
        &self,
        param_version: f64,
        param_id: i64,
        param_body: Option<models::Trip>,
        context: &C) -> Result<UpdateTripResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/trip/{id}",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
            ,id=utf8_percent_encode(&param_id.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("PUT")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        // Consumes basic body
        // Body parameter
        if let Some(param_body) = param_body {
        let body = serde_json::to_string(&param_body).expect("impossible to fail to serialize");
        *request.body_mut() = body_from_string(body);
        }

        let header = "application/json";
        request.headers_mut().insert(CONTENT_TYPE, HeaderValue::from_static(header));

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::Trip>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(UpdateTripResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn sms_buy_offer(
        &self,
        param_version: f64,
        param_app_key: String,
        param_body: String,
        param_from: String,
        param_currency_type: String,
        context: &C) -> Result<SmsBuyOfferResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/sms/buyoffer/{app_key}",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
            ,app_key=utf8_percent_encode(&param_app_key.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("Body",
                    &param_body);
                query_string.append_pair("From",
                    &param_from);
                query_string.append_pair("currencyType",
                    &param_currency_type);
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                // ToDo: this will move to swagger-rs and become a standard From conversion trait
                // once https://github.com/RReverser/serde-xml-rs/pull/45 is accepted upstream
                let body = serde_xml_rs::from_str::<models::TwiMlResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(SmsBuyOfferResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn authorize_twitter(
        &self,
        param_version: f64,
        param_app_key: String,
        context: &C) -> Result<AuthorizeTwitterResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/twitter/authorize",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("appKey",
                    &param_app_key);
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(AuthorizeTwitterResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn login_twitter(
        &self,
        param_version: f64,
        param_access_token: String,
        param_access_token_secret: String,
        param_app_key: String,
        param_response_filters: String,
        param_device_id: Option<String>,
        param_latitude: Option<f64>,
        param_longitude: Option<f64>,
        context: &C) -> Result<LoginTwitterResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/twitter/login",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
                query_string.append_pair("accessToken",
                    &param_access_token);
                query_string.append_pair("accessTokenSecret",
                    &param_access_token_secret);
                query_string.append_pair("appKey",
                    &param_app_key);
                query_string.append_pair("responseFilters",
                    &param_response_filters);
            if let Some(param_latitude) = param_latitude {
                query_string.append_pair("latitude",
                    &param_latitude.to_string());
            }
            if let Some(param_longitude) = param_longitude {
                query_string.append_pair("longitude",
                    &param_longitude.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::ProfileResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(LoginTwitterResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn add_users_to_permissionable(
        &self,
        param_version: f64,
        param_permissionable_type: models::AddUsersToPermissionablePermissionableTypeParameter,
        param_permissionable_id: i64,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_read: Option<bool>,
        param_write: Option<bool>,
        param_delete: Option<bool>,
        param_add: Option<bool>,
        param_connection_ids: Option<String>,
        param_connection_account_ids: Option<String>,
        param_connection_group_ids: Option<String>,
        param_pending: Option<bool>,
        param_admin: Option<bool>,
        param_include_friend_group: Option<bool>,
        param_latitude: Option<f64>,
        param_longitude: Option<f64>,
        param_audience_ids: Option<String>,
        context: &C) -> Result<AddUsersToPermissionableResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/consumer/permissions/add",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
                query_string.append_pair("permissionableType",
                    &param_permissionable_type.to_string());
                query_string.append_pair("permissionableId",
                    &param_permissionable_id.to_string());
            if let Some(param_read) = param_read {
                query_string.append_pair("read",
                    &param_read.to_string());
            }
            if let Some(param_write) = param_write {
                query_string.append_pair("write",
                    &param_write.to_string());
            }
            if let Some(param_delete) = param_delete {
                query_string.append_pair("delete",
                    &param_delete.to_string());
            }
            if let Some(param_add) = param_add {
                query_string.append_pair("add",
                    &param_add.to_string());
            }
            if let Some(param_connection_ids) = param_connection_ids {
                query_string.append_pair("connectionIds",
                    &param_connection_ids);
            }
            if let Some(param_connection_account_ids) = param_connection_account_ids {
                query_string.append_pair("connectionAccountIds",
                    &param_connection_account_ids);
            }
            if let Some(param_connection_group_ids) = param_connection_group_ids {
                query_string.append_pair("connectionGroupIds",
                    &param_connection_group_ids);
            }
            if let Some(param_pending) = param_pending {
                query_string.append_pair("pending",
                    &param_pending.to_string());
            }
            if let Some(param_admin) = param_admin {
                query_string.append_pair("admin",
                    &param_admin.to_string());
            }
            if let Some(param_include_friend_group) = param_include_friend_group {
                query_string.append_pair("includeFriendGroup",
                    &param_include_friend_group.to_string());
            }
            if let Some(param_latitude) = param_latitude {
                query_string.append_pair("latitude",
                    &param_latitude.to_string());
            }
            if let Some(param_longitude) = param_longitude {
                query_string.append_pair("longitude",
                    &param_longitude.to_string());
            }
            if let Some(param_audience_ids) = param_audience_ids {
                query_string.append_pair("audienceIds",
                    &param_audience_ids);
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(AddUsersToPermissionableResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn approve_permissionable(
        &self,
        param_version: f64,
        param_permissionable_type: models::AddUsersToPermissionablePermissionableTypeParameter,
        param_permissionable_id: i64,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_approval_status: Option<models::ApprovePermissionableApprovalStatusParameter>,
        context: &C) -> Result<ApprovePermissionableResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/permissionable/approve",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
                query_string.append_pair("permissionableType",
                    &param_permissionable_type.to_string());
                query_string.append_pair("permissionableId",
                    &param_permissionable_id.to_string());
            if let Some(param_approval_status) = param_approval_status {
                query_string.append_pair("approvalStatus",
                    &param_approval_status.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(ApprovePermissionableResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn leave_from_permissionable(
        &self,
        param_version: f64,
        param_permissionable_type: String,
        param_permissionable_id: i64,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_latitude: Option<f64>,
        param_longitude: Option<f64>,
        context: &C) -> Result<LeaveFromPermissionableResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/consumer/permissions/leave",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
                query_string.append_pair("permissionableType",
                    &param_permissionable_type);
                query_string.append_pair("permissionableId",
                    &param_permissionable_id.to_string());
            if let Some(param_latitude) = param_latitude {
                query_string.append_pair("latitude",
                    &param_latitude.to_string());
            }
            if let Some(param_longitude) = param_longitude {
                query_string.append_pair("longitude",
                    &param_longitude.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(LeaveFromPermissionableResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn remove_users_from_permissionable(
        &self,
        param_version: f64,
        param_permissionable_type: models::AddUsersToPermissionablePermissionableTypeParameter,
        param_permissionable_id: i64,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_connection_ids: Option<String>,
        param_connection_account_ids: Option<String>,
        param_connection_group_ids: Option<String>,
        param_remove_friend_group: Option<bool>,
        param_latitude: Option<f64>,
        param_longitude: Option<f64>,
        param_audience_ids: Option<String>,
        context: &C) -> Result<RemoveUsersFromPermissionableResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/consumer/permissions/remove",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
                query_string.append_pair("permissionableType",
                    &param_permissionable_type.to_string());
                query_string.append_pair("permissionableId",
                    &param_permissionable_id.to_string());
            if let Some(param_connection_ids) = param_connection_ids {
                query_string.append_pair("connectionIds",
                    &param_connection_ids);
            }
            if let Some(param_connection_account_ids) = param_connection_account_ids {
                query_string.append_pair("connectionAccountIds",
                    &param_connection_account_ids);
            }
            if let Some(param_connection_group_ids) = param_connection_group_ids {
                query_string.append_pair("connectionGroupIds",
                    &param_connection_group_ids);
            }
            if let Some(param_remove_friend_group) = param_remove_friend_group {
                query_string.append_pair("removeFriendGroup",
                    &param_remove_friend_group.to_string());
            }
            if let Some(param_latitude) = param_latitude {
                query_string.append_pair("latitude",
                    &param_latitude.to_string());
            }
            if let Some(param_longitude) = param_longitude {
                query_string.append_pair("longitude",
                    &param_longitude.to_string());
            }
            if let Some(param_audience_ids) = param_audience_ids {
                query_string.append_pair("audienceIds",
                    &param_audience_ids);
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(RemoveUsersFromPermissionableResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn search_permissionables(
        &self,
        param_version: f64,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_connection_account_id: Option<i64>,
        param_connection_account_ids: Option<String>,
        param_permissionable_type: Option<models::AddUsersToPermissionablePermissionableTypeParameter>,
        param_permissionable_id: Option<i64>,
        param_keyword: Option<String>,
        param_sort_field: Option<String>,
        param_descending: Option<bool>,
        param_pending: Option<bool>,
        param_admin: Option<bool>,
        param_start: Option<i32>,
        param_limit: Option<i32>,
        context: &C) -> Result<SearchPermissionablesResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/permissions/search",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_connection_account_id) = param_connection_account_id {
                query_string.append_pair("connectionAccountId",
                    &param_connection_account_id.to_string());
            }
            if let Some(param_connection_account_ids) = param_connection_account_ids {
                query_string.append_pair("connectionAccountIds",
                    &param_connection_account_ids);
            }
            if let Some(param_permissionable_type) = param_permissionable_type {
                query_string.append_pair("permissionableType",
                    &param_permissionable_type.to_string());
            }
            if let Some(param_permissionable_id) = param_permissionable_id {
                query_string.append_pair("permissionableId",
                    &param_permissionable_id.to_string());
            }
            if let Some(param_keyword) = param_keyword {
                query_string.append_pair("keyword",
                    &param_keyword);
            }
            if let Some(param_sort_field) = param_sort_field {
                query_string.append_pair("sortField",
                    &param_sort_field);
            }
            if let Some(param_descending) = param_descending {
                query_string.append_pair("descending",
                    &param_descending.to_string());
            }
            if let Some(param_pending) = param_pending {
                query_string.append_pair("pending",
                    &param_pending.to_string());
            }
            if let Some(param_admin) = param_admin {
                query_string.append_pair("admin",
                    &param_admin.to_string());
            }
            if let Some(param_start) = param_start {
                query_string.append_pair("start",
                    &param_start.to_string());
            }
            if let Some(param_limit) = param_limit {
                query_string.append_pair("limit",
                    &param_limit.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<Vec<models::UserPermissionsResponse>>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(SearchPermissionablesResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn search_permissionables_following_distance(
        &self,
        param_version: f64,
        param_latitude: f64,
        param_longitude: f64,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_connection_account_id: Option<i64>,
        param_connection_account_ids: Option<String>,
        param_permissionable_type: Option<models::AddUsersToPermissionablePermissionableTypeParameter>,
        param_permissionable_id: Option<i64>,
        param_search_range: Option<f64>,
        param_keyword: Option<String>,
        param_pending: Option<bool>,
        param_admin: Option<bool>,
        param_start: Option<i32>,
        param_limit: Option<i32>,
        context: &C) -> Result<SearchPermissionablesFollowingDistanceResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/permissions/distancesearch",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_connection_account_id) = param_connection_account_id {
                query_string.append_pair("connectionAccountId",
                    &param_connection_account_id.to_string());
            }
            if let Some(param_connection_account_ids) = param_connection_account_ids {
                query_string.append_pair("connectionAccountIds",
                    &param_connection_account_ids);
            }
            if let Some(param_permissionable_type) = param_permissionable_type {
                query_string.append_pair("permissionableType",
                    &param_permissionable_type.to_string());
            }
            if let Some(param_permissionable_id) = param_permissionable_id {
                query_string.append_pair("permissionableId",
                    &param_permissionable_id.to_string());
            }
                query_string.append_pair("latitude",
                    &param_latitude.to_string());
                query_string.append_pair("longitude",
                    &param_longitude.to_string());
            if let Some(param_search_range) = param_search_range {
                query_string.append_pair("searchRange",
                    &param_search_range.to_string());
            }
            if let Some(param_keyword) = param_keyword {
                query_string.append_pair("keyword",
                    &param_keyword);
            }
            if let Some(param_pending) = param_pending {
                query_string.append_pair("pending",
                    &param_pending.to_string());
            }
            if let Some(param_admin) = param_admin {
                query_string.append_pair("admin",
                    &param_admin.to_string());
            }
            if let Some(param_start) = param_start {
                query_string.append_pair("start",
                    &param_start.to_string());
            }
            if let Some(param_limit) = param_limit {
                query_string.append_pair("limit",
                    &param_limit.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<Vec<models::UserPermissionsResponse>>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(SearchPermissionablesFollowingDistanceResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn create_following(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_vatom_parameters: String,
        param_return_raw_response: Option<bool>,
        context: &C) -> Result<CreateFollowingResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/vatom/me/rels/following/create",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("vatomParameters",
                    &param_vatom_parameters);
            if let Some(param_return_raw_response) = param_return_raw_response {
                query_string.append_pair("returnRawResponse",
                    &param_return_raw_response.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                Ok(
                    CreateFollowingResponse::SuccessfulOperation
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn create_space(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_app_key: String,
        param_vatom_parameters: String,
        param_return_raw_response: Option<bool>,
        context: &C) -> Result<CreateSpaceResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/vatom/b/spaces/create",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("appKey",
                    &param_app_key);
                query_string.append_pair("vatomParameters",
                    &param_vatom_parameters);
            if let Some(param_return_raw_response) = param_return_raw_response {
                query_string.append_pair("returnRawResponse",
                    &param_return_raw_response.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                Ok(
                    CreateSpaceResponse::SuccessfulOperation
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn create_vatom_event(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_app_key: String,
        param_vatom_parameters: String,
        param_return_raw_response: Option<bool>,
        context: &C) -> Result<CreateVatomEventResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/vatom/b/events/create",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("appKey",
                    &param_app_key);
                query_string.append_pair("vatomParameters",
                    &param_vatom_parameters);
            if let Some(param_return_raw_response) = param_return_raw_response {
                query_string.append_pair("returnRawResponse",
                    &param_return_raw_response.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                Ok(
                    CreateVatomEventResponse::SuccessfulOperation
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn delete_following(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_vatom_rels_key: String,
        param_return_raw_response: Option<bool>,
        context: &C) -> Result<DeleteFollowingResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/vatom/me/rels/following/delete",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("vatomRelsKey",
                    &param_vatom_rels_key);
            if let Some(param_return_raw_response) = param_return_raw_response {
                query_string.append_pair("returnRawResponse",
                    &param_return_raw_response.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                Ok(
                    DeleteFollowingResponse::SuccessfulOperation
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn delete_points_balance(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_app_key: String,
        param_vatom_campaign_id: String,
        param_return_raw_response: Option<bool>,
        context: &C) -> Result<DeletePointsBalanceResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/vatom/b/campaign/points/delete",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("appKey",
                    &param_app_key);
                query_string.append_pair("vatomCampaignId",
                    &param_vatom_campaign_id);
            if let Some(param_return_raw_response) = param_return_raw_response {
                query_string.append_pair("returnRawResponse",
                    &param_return_raw_response.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                Ok(
                    DeletePointsBalanceResponse::SuccessfulOperation
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn delete_space(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_app_key: String,
        param_vatom_space_id: String,
        param_return_raw_response: Option<bool>,
        context: &C) -> Result<DeleteSpaceResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/vatom/b/spaces/delete",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("appKey",
                    &param_app_key);
                query_string.append_pair("vatomSpaceId",
                    &param_vatom_space_id);
            if let Some(param_return_raw_response) = param_return_raw_response {
                query_string.append_pair("returnRawResponse",
                    &param_return_raw_response.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                Ok(
                    DeleteSpaceResponse::SuccessfulOperation
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn delete_vatom_event(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_app_key: String,
        param_vatom_event_id: String,
        param_return_raw_response: Option<bool>,
        context: &C) -> Result<DeleteVatomEventResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/vatom/b/events/delete",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("appKey",
                    &param_app_key);
                query_string.append_pair("vatomEventId",
                    &param_vatom_event_id);
            if let Some(param_return_raw_response) = param_return_raw_response {
                query_string.append_pair("returnRawResponse",
                    &param_return_raw_response.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                Ok(
                    DeleteVatomEventResponse::SuccessfulOperation
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn delete_vatom_nft(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_vatom_id: String,
        param_return_raw_response: Option<bool>,
        context: &C) -> Result<DeleteVatomNftResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/vatom/vatoms/delete",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("vatomId",
                    &param_vatom_id);
            if let Some(param_return_raw_response) = param_return_raw_response {
                query_string.append_pair("returnRawResponse",
                    &param_return_raw_response.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                Ok(
                    DeleteVatomNftResponse::SuccessfulOperation
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn execute_action_on_nft(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_vatom_id: String,
        param_vatom_parameters: String,
        param_return_raw_response: Option<bool>,
        context: &C) -> Result<ExecuteActionOnNftResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/vatom/vatoms/execute-action",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("vatomId",
                    &param_vatom_id);
                query_string.append_pair("vatomParameters",
                    &param_vatom_parameters);
            if let Some(param_return_raw_response) = param_return_raw_response {
                query_string.append_pair("returnRawResponse",
                    &param_return_raw_response.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                Ok(
                    ExecuteActionOnNftResponse::SuccessfulOperation
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn geomap_search(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_vatom_parameters: String,
        param_return_raw_response: Option<bool>,
        context: &C) -> Result<GeomapSearchResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/vatom/vatoms/geo-map/search",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("vatomParameters",
                    &param_vatom_parameters);
            if let Some(param_return_raw_response) = param_return_raw_response {
                query_string.append_pair("returnRawResponse",
                    &param_return_raw_response.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                Ok(
                    GeomapSearchResponse::SuccessfulOperation
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_business_behaviors(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_app_key: String,
        param_return_raw_response: Option<bool>,
        context: &C) -> Result<GetBusinessBehaviorsResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/vatom/b/behaviors",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("appKey",
                    &param_app_key);
            if let Some(param_return_raw_response) = param_return_raw_response {
                query_string.append_pair("returnRawResponse",
                    &param_return_raw_response.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                Ok(
                    GetBusinessBehaviorsResponse::SuccessfulOperation
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_business_coins_balance(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_app_key: String,
        param_return_raw_response: Option<bool>,
        context: &C) -> Result<GetBusinessCoinsBalanceResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/vatom/b/coins/get",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("appKey",
                    &param_app_key);
            if let Some(param_return_raw_response) = param_return_raw_response {
                query_string.append_pair("returnRawResponse",
                    &param_return_raw_response.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                Ok(
                    GetBusinessCoinsBalanceResponse::SuccessfulOperation
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_business_ids(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_return_raw_response: Option<bool>,
        context: &C) -> Result<GetBusinessIdsResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/vatom/me/businesses",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            if let Some(param_return_raw_response) = param_return_raw_response {
                query_string.append_pair("returnRawResponse",
                    &param_return_raw_response.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                Ok(
                    GetBusinessIdsResponse::SuccessfulOperation
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_business_info(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_app_key: String,
        param_vatom_parameters: Option<String>,
        param_return_raw_response: Option<bool>,
        context: &C) -> Result<GetBusinessInfoResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/vatom/b/get",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("appKey",
                    &param_app_key);
            if let Some(param_vatom_parameters) = param_vatom_parameters {
                query_string.append_pair("vatomParameters",
                    &param_vatom_parameters);
            }
            if let Some(param_return_raw_response) = param_return_raw_response {
                query_string.append_pair("returnRawResponse",
                    &param_return_raw_response.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                Ok(
                    GetBusinessInfoResponse::SuccessfulOperation
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_business_users(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_app_key: String,
        param_return_raw_response: Option<bool>,
        context: &C) -> Result<GetBusinessUsersResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/vatom/b/users",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("appKey",
                    &param_app_key);
            if let Some(param_return_raw_response) = param_return_raw_response {
                query_string.append_pair("returnRawResponse",
                    &param_return_raw_response.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                Ok(
                    GetBusinessUsersResponse::SuccessfulOperation
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_campaign_group_entities(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_app_key: String,
        param_vatom_campaign_id: String,
        param_return_raw_response: Option<bool>,
        context: &C) -> Result<GetCampaignGroupEntitiesResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/vatom/b/campaign-groups/entities",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("appKey",
                    &param_app_key);
                query_string.append_pair("vatomCampaignId",
                    &param_vatom_campaign_id);
            if let Some(param_return_raw_response) = param_return_raw_response {
                query_string.append_pair("returnRawResponse",
                    &param_return_raw_response.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                Ok(
                    GetCampaignGroupEntitiesResponse::SuccessfulOperation
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_campaign_group_rules(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_app_key: String,
        param_vatom_campaign_id: String,
        param_return_raw_response: Option<bool>,
        context: &C) -> Result<GetCampaignGroupRulesResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/vatom/b/campaign-groups/rules",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("appKey",
                    &param_app_key);
                query_string.append_pair("vatomCampaignId",
                    &param_vatom_campaign_id);
            if let Some(param_return_raw_response) = param_return_raw_response {
                query_string.append_pair("returnRawResponse",
                    &param_return_raw_response.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                Ok(
                    GetCampaignGroupRulesResponse::SuccessfulOperation
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_campaign_group_stats(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_app_key: String,
        param_vatom_campaign_id: String,
        param_return_raw_response: Option<bool>,
        context: &C) -> Result<GetCampaignGroupStatsResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/vatom/b/campaign-groups/stats",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("appKey",
                    &param_app_key);
                query_string.append_pair("vatomCampaignId",
                    &param_vatom_campaign_id);
            if let Some(param_return_raw_response) = param_return_raw_response {
                query_string.append_pair("returnRawResponse",
                    &param_return_raw_response.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                Ok(
                    GetCampaignGroupStatsResponse::SuccessfulOperation
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_campaign_info(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_app_key: String,
        param_vatom_campaign_id: String,
        param_return_raw_response: Option<bool>,
        context: &C) -> Result<GetCampaignInfoResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/vatom/b/campaign-groups/get",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("appKey",
                    &param_app_key);
                query_string.append_pair("vatomCampaignId",
                    &param_vatom_campaign_id);
            if let Some(param_return_raw_response) = param_return_raw_response {
                query_string.append_pair("returnRawResponse",
                    &param_return_raw_response.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                Ok(
                    GetCampaignInfoResponse::SuccessfulOperation
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_event_guest_list(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_app_key: String,
        param_vatom_event_id: String,
        param_return_raw_response: Option<bool>,
        context: &C) -> Result<GetEventGuestListResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/vatom/b/events/guests/get",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("appKey",
                    &param_app_key);
                query_string.append_pair("vatomEventId",
                    &param_vatom_event_id);
            if let Some(param_return_raw_response) = param_return_raw_response {
                query_string.append_pair("returnRawResponse",
                    &param_return_raw_response.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                Ok(
                    GetEventGuestListResponse::SuccessfulOperation
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_inventory(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_vatom_parameters: String,
        param_return_raw_response: Option<bool>,
        context: &C) -> Result<GetInventoryResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/vatom/me/inventory",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("vatomParameters",
                    &param_vatom_parameters);
            if let Some(param_return_raw_response) = param_return_raw_response {
                query_string.append_pair("returnRawResponse",
                    &param_return_raw_response.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                Ok(
                    GetInventoryResponse::SuccessfulOperation
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_my_following(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_return_raw_response: Option<bool>,
        context: &C) -> Result<GetMyFollowingResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/vatom/me/rels/following",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            if let Some(param_return_raw_response) = param_return_raw_response {
                query_string.append_pair("returnRawResponse",
                    &param_return_raw_response.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                Ok(
                    GetMyFollowingResponse::SuccessfulOperation
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_points_balance(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_vatom_user_id: String,
        param_vatom_campaign_id: String,
        param_return_raw_response: Option<bool>,
        context: &C) -> Result<GetPointsBalanceResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/vatom/u/campaign/points/get",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("vatomUserId",
                    &param_vatom_user_id);
                query_string.append_pair("vatomCampaignId",
                    &param_vatom_campaign_id);
            if let Some(param_return_raw_response) = param_return_raw_response {
                query_string.append_pair("returnRawResponse",
                    &param_return_raw_response.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                Ok(
                    GetPointsBalanceResponse::SuccessfulOperation
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_points_balance_as_business(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_app_key: String,
        param_vatom_user_id: String,
        param_vatom_campaign_id: String,
        param_return_raw_response: Option<bool>,
        context: &C) -> Result<GetPointsBalanceAsBusinessResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/vatom/b/campaign/u/points/get",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("appKey",
                    &param_app_key);
                query_string.append_pair("vatomUserId",
                    &param_vatom_user_id);
                query_string.append_pair("vatomCampaignId",
                    &param_vatom_campaign_id);
            if let Some(param_return_raw_response) = param_return_raw_response {
                query_string.append_pair("returnRawResponse",
                    &param_return_raw_response.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                Ok(
                    GetPointsBalanceAsBusinessResponse::SuccessfulOperation
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_space(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_app_key: String,
        param_vatom_space_id: String,
        param_return_raw_response: Option<bool>,
        context: &C) -> Result<GetSpaceResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/vatom/b/spaces/get",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("appKey",
                    &param_app_key);
                query_string.append_pair("vatomSpaceId",
                    &param_vatom_space_id);
            if let Some(param_return_raw_response) = param_return_raw_response {
                query_string.append_pair("returnRawResponse",
                    &param_return_raw_response.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                Ok(
                    GetSpaceResponse::SuccessfulOperation
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_user_coins_as_business(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_vatom_user_id: String,
        param_app_key: String,
        param_return_raw_response: Option<bool>,
        context: &C) -> Result<GetUserCoinsAsBusinessResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/vatom/b/users/coins/get",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("vatomUserId",
                    &param_vatom_user_id);
                query_string.append_pair("appKey",
                    &param_app_key);
            if let Some(param_return_raw_response) = param_return_raw_response {
                query_string.append_pair("returnRawResponse",
                    &param_return_raw_response.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                Ok(
                    GetUserCoinsAsBusinessResponse::SuccessfulOperation
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_user_coins_balance(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_vatom_user_id: String,
        param_vatom_parameters: Option<String>,
        param_return_raw_response: Option<bool>,
        context: &C) -> Result<GetUserCoinsBalanceResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/vatom/u/coins/get",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("vatomUserId",
                    &param_vatom_user_id);
            if let Some(param_vatom_parameters) = param_vatom_parameters {
                query_string.append_pair("vatomParameters",
                    &param_vatom_parameters);
            }
            if let Some(param_return_raw_response) = param_return_raw_response {
                query_string.append_pair("returnRawResponse",
                    &param_return_raw_response.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                Ok(
                    GetUserCoinsBalanceResponse::SuccessfulOperation
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_user_followers(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_vatom_user_id: String,
        param_return_raw_response: Option<bool>,
        context: &C) -> Result<GetUserFollowersResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/vatom/users/rels/followers",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("vatomUserId",
                    &param_vatom_user_id);
            if let Some(param_return_raw_response) = param_return_raw_response {
                query_string.append_pair("returnRawResponse",
                    &param_return_raw_response.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                Ok(
                    GetUserFollowersResponse::SuccessfulOperation
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_user_following(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_vatom_user_id: String,
        param_return_raw_response: Option<bool>,
        context: &C) -> Result<GetUserFollowingResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/vatom/users/rels/following",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("vatomUserId",
                    &param_vatom_user_id);
            if let Some(param_return_raw_response) = param_return_raw_response {
                query_string.append_pair("returnRawResponse",
                    &param_return_raw_response.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                Ok(
                    GetUserFollowingResponse::SuccessfulOperation
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_user_info(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_vatom_user_id: String,
        param_return_raw_response: Option<bool>,
        context: &C) -> Result<GetUserInfoResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/vatom/user/get",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("vatomUserId",
                    &param_vatom_user_id);
            if let Some(param_return_raw_response) = param_return_raw_response {
                query_string.append_pair("returnRawResponse",
                    &param_return_raw_response.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                Ok(
                    GetUserInfoResponse::SuccessfulOperation
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_user_profile(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_return_raw_response: Option<bool>,
        context: &C) -> Result<GetUserProfileResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/vatom/me/get",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            if let Some(param_return_raw_response) = param_return_raw_response {
                query_string.append_pair("returnRawResponse",
                    &param_return_raw_response.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                Ok(
                    GetUserProfileResponse::SuccessfulOperation
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_vatom_event(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_app_key: String,
        param_vatom_event_id: String,
        param_return_raw_response: Option<bool>,
        context: &C) -> Result<GetVatomEventResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/vatom/b/events/get",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("appKey",
                    &param_app_key);
                query_string.append_pair("vatomEventId",
                    &param_vatom_event_id);
            if let Some(param_return_raw_response) = param_return_raw_response {
                query_string.append_pair("returnRawResponse",
                    &param_return_raw_response.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                Ok(
                    GetVatomEventResponse::SuccessfulOperation
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_vatom_nft(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_vatom_id: String,
        param_return_raw_response: Option<bool>,
        context: &C) -> Result<GetVatomNftResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/vatom/vatoms/get",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("vatomId",
                    &param_vatom_id);
            if let Some(param_return_raw_response) = param_return_raw_response {
                query_string.append_pair("returnRawResponse",
                    &param_return_raw_response.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                Ok(
                    GetVatomNftResponse::SuccessfulOperation
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn list_communities(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_app_key: String,
        param_vatom_parameters: Option<String>,
        param_return_raw_response: Option<bool>,
        context: &C) -> Result<ListCommunitiesResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/vatom/b/communities/search",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("appKey",
                    &param_app_key);
            if let Some(param_vatom_parameters) = param_vatom_parameters {
                query_string.append_pair("vatomParameters",
                    &param_vatom_parameters);
            }
            if let Some(param_return_raw_response) = param_return_raw_response {
                query_string.append_pair("returnRawResponse",
                    &param_return_raw_response.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                Ok(
                    ListCommunitiesResponse::SuccessfulOperation
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn list_events(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_app_key: String,
        param_vatom_parameters: Option<String>,
        param_return_raw_response: Option<bool>,
        context: &C) -> Result<ListEventsResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/vatom/b/events/search",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("appKey",
                    &param_app_key);
            if let Some(param_vatom_parameters) = param_vatom_parameters {
                query_string.append_pair("vatomParameters",
                    &param_vatom_parameters);
            }
            if let Some(param_return_raw_response) = param_return_raw_response {
                query_string.append_pair("returnRawResponse",
                    &param_return_raw_response.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                Ok(
                    ListEventsResponse::SuccessfulOperation
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn list_spaces(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_app_key: String,
        param_vatom_parameters: Option<String>,
        param_return_raw_response: Option<bool>,
        context: &C) -> Result<ListSpacesResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/vatom/b/spaces/search",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("appKey",
                    &param_app_key);
            if let Some(param_vatom_parameters) = param_vatom_parameters {
                query_string.append_pair("vatomParameters",
                    &param_vatom_parameters);
            }
            if let Some(param_return_raw_response) = param_return_raw_response {
                query_string.append_pair("returnRawResponse",
                    &param_return_raw_response.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                Ok(
                    ListSpacesResponse::SuccessfulOperation
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn list_user_coin_transactions(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_vatom_user_id: String,
        param_vatom_parameters: Option<String>,
        param_return_raw_response: Option<bool>,
        context: &C) -> Result<ListUserCoinTransactionsResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/vatom/u/coins/txns/search",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("vatomUserId",
                    &param_vatom_user_id);
            if let Some(param_vatom_parameters) = param_vatom_parameters {
                query_string.append_pair("vatomParameters",
                    &param_vatom_parameters);
            }
            if let Some(param_return_raw_response) = param_return_raw_response {
                query_string.append_pair("returnRawResponse",
                    &param_return_raw_response.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                Ok(
                    ListUserCoinTransactionsResponse::SuccessfulOperation
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn list_user_coin_transactions_as_business(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_vatom_user_id: String,
        param_app_key: String,
        param_vatom_parameters: Option<String>,
        param_return_raw_response: Option<bool>,
        context: &C) -> Result<ListUserCoinTransactionsAsBusinessResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/vatom/b/users/coins/txns/search",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("vatomUserId",
                    &param_vatom_user_id);
                query_string.append_pair("appKey",
                    &param_app_key);
            if let Some(param_vatom_parameters) = param_vatom_parameters {
                query_string.append_pair("vatomParameters",
                    &param_vatom_parameters);
            }
            if let Some(param_return_raw_response) = param_return_raw_response {
                query_string.append_pair("returnRawResponse",
                    &param_return_raw_response.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                Ok(
                    ListUserCoinTransactionsAsBusinessResponse::SuccessfulOperation
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn perform_action_on_nft(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_vatom_id: String,
        param_vatom_action: String,
        param_vatom_parameters: String,
        param_return_raw_response: Option<bool>,
        context: &C) -> Result<PerformActionOnNftResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/vatom/me/vatoms/actions",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("vatomId",
                    &param_vatom_id);
                query_string.append_pair("vatomAction",
                    &param_vatom_action);
                query_string.append_pair("vatomParameters",
                    &param_vatom_parameters);
            if let Some(param_return_raw_response) = param_return_raw_response {
                query_string.append_pair("returnRawResponse",
                    &param_return_raw_response.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                Ok(
                    PerformActionOnNftResponse::SuccessfulOperation
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn redeem_nft(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_app_key: String,
        param_vatom_parameters: String,
        param_return_raw_response: Option<bool>,
        context: &C) -> Result<RedeemNftResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/vatom/b/redemptions",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("appKey",
                    &param_app_key);
                query_string.append_pair("vatomParameters",
                    &param_vatom_parameters);
            if let Some(param_return_raw_response) = param_return_raw_response {
                query_string.append_pair("returnRawResponse",
                    &param_return_raw_response.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                Ok(
                    RedeemNftResponse::SuccessfulOperation
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn redeem_user_coins_as_business(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_vatom_user_id: String,
        param_app_key: String,
        param_vatom_parameters: String,
        param_return_raw_response: Option<bool>,
        context: &C) -> Result<RedeemUserCoinsAsBusinessResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/vatom/b/users/coins/redeem",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("vatomUserId",
                    &param_vatom_user_id);
                query_string.append_pair("appKey",
                    &param_app_key);
                query_string.append_pair("vatomParameters",
                    &param_vatom_parameters);
            if let Some(param_return_raw_response) = param_return_raw_response {
                query_string.append_pair("returnRawResponse",
                    &param_return_raw_response.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                Ok(
                    RedeemUserCoinsAsBusinessResponse::SuccessfulOperation
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn search_businesses(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_vatom_parameters: Option<String>,
        param_return_raw_response: Option<bool>,
        context: &C) -> Result<SearchBusinessesResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/vatom/b/search",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            if let Some(param_vatom_parameters) = param_vatom_parameters {
                query_string.append_pair("vatomParameters",
                    &param_vatom_parameters);
            }
            if let Some(param_return_raw_response) = param_return_raw_response {
                query_string.append_pair("returnRawResponse",
                    &param_return_raw_response.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                Ok(
                    SearchBusinessesResponse::SuccessfulOperation
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn search_campaign_groups(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_app_key: String,
        param_return_raw_response: Option<bool>,
        context: &C) -> Result<SearchCampaignGroupsResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/vatom/b/campaign-groups/search",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("appKey",
                    &param_app_key);
            if let Some(param_return_raw_response) = param_return_raw_response {
                query_string.append_pair("returnRawResponse",
                    &param_return_raw_response.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                Ok(
                    SearchCampaignGroupsResponse::SuccessfulOperation
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn search_identities(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_return_raw_response: Option<bool>,
        context: &C) -> Result<SearchIdentitiesResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/vatom/me/identities/search",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            if let Some(param_return_raw_response) = param_return_raw_response {
                query_string.append_pair("returnRawResponse",
                    &param_return_raw_response.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                Ok(
                    SearchIdentitiesResponse::SuccessfulOperation
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn search_inventory(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_vatom_parameters: Option<String>,
        param_return_raw_response: Option<bool>,
        context: &C) -> Result<SearchInventoryResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/vatom/user-inventory/search",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            if let Some(param_vatom_parameters) = param_vatom_parameters {
                query_string.append_pair("vatomParameters",
                    &param_vatom_parameters);
            }
            if let Some(param_return_raw_response) = param_return_raw_response {
                query_string.append_pair("returnRawResponse",
                    &param_return_raw_response.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                Ok(
                    SearchInventoryResponse::SuccessfulOperation
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn send_nft(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_app_key: String,
        param_vatom_campaign_id: String,
        param_vatom_parameters: String,
        param_return_raw_response: Option<bool>,
        context: &C) -> Result<SendNftResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/vatom/b/campaigns/send",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("appKey",
                    &param_app_key);
                query_string.append_pair("vatomCampaignId",
                    &param_vatom_campaign_id);
                query_string.append_pair("vatomParameters",
                    &param_vatom_parameters);
            if let Some(param_return_raw_response) = param_return_raw_response {
                query_string.append_pair("returnRawResponse",
                    &param_return_raw_response.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                Ok(
                    SendNftResponse::SuccessfulOperation
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn set_points_balance_as_business(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_app_key: String,
        param_vatom_user_id: String,
        param_vatom_campaign_id: String,
        param_vatom_parameters: String,
        param_return_raw_response: Option<bool>,
        context: &C) -> Result<SetPointsBalanceAsBusinessResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/vatom/b/campaign/u/points/update",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("appKey",
                    &param_app_key);
                query_string.append_pair("vatomUserId",
                    &param_vatom_user_id);
                query_string.append_pair("vatomCampaignId",
                    &param_vatom_campaign_id);
                query_string.append_pair("vatomParameters",
                    &param_vatom_parameters);
            if let Some(param_return_raw_response) = param_return_raw_response {
                query_string.append_pair("returnRawResponse",
                    &param_return_raw_response.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                Ok(
                    SetPointsBalanceAsBusinessResponse::SuccessfulOperation
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn transfer_user_coins(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_vatom_user_id: String,
        param_vatom_parameters: String,
        param_return_raw_response: Option<bool>,
        context: &C) -> Result<TransferUserCoinsResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/vatom/u/coins/transfer",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("vatomUserId",
                    &param_vatom_user_id);
                query_string.append_pair("vatomParameters",
                    &param_vatom_parameters);
            if let Some(param_return_raw_response) = param_return_raw_response {
                query_string.append_pair("returnRawResponse",
                    &param_return_raw_response.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                Ok(
                    TransferUserCoinsResponse::SuccessfulOperation
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn update_business_coins(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_app_key: String,
        param_vatom_parameters: String,
        param_return_raw_response: Option<bool>,
        context: &C) -> Result<UpdateBusinessCoinsResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/vatom/b/coins/update",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("appKey",
                    &param_app_key);
                query_string.append_pair("vatomParameters",
                    &param_vatom_parameters);
            if let Some(param_return_raw_response) = param_return_raw_response {
                query_string.append_pair("returnRawResponse",
                    &param_return_raw_response.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                Ok(
                    UpdateBusinessCoinsResponse::SuccessfulOperation
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn update_event_guest_list(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_app_key: String,
        param_vatom_event_id: String,
        param_vatom_parameters: String,
        param_return_raw_response: Option<bool>,
        context: &C) -> Result<UpdateEventGuestListResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/vatom/b/events/guests/update",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("appKey",
                    &param_app_key);
                query_string.append_pair("vatomEventId",
                    &param_vatom_event_id);
                query_string.append_pair("vatomParameters",
                    &param_vatom_parameters);
            if let Some(param_return_raw_response) = param_return_raw_response {
                query_string.append_pair("returnRawResponse",
                    &param_return_raw_response.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                Ok(
                    UpdateEventGuestListResponse::SuccessfulOperation
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn update_space(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_app_key: String,
        param_vatom_space_id: String,
        param_vatom_parameters: String,
        param_return_raw_response: Option<bool>,
        context: &C) -> Result<UpdateSpaceResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/vatom/b/spaces/update",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("appKey",
                    &param_app_key);
                query_string.append_pair("vatomSpaceId",
                    &param_vatom_space_id);
                query_string.append_pair("vatomParameters",
                    &param_vatom_parameters);
            if let Some(param_return_raw_response) = param_return_raw_response {
                query_string.append_pair("returnRawResponse",
                    &param_return_raw_response.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                Ok(
                    UpdateSpaceResponse::SuccessfulOperation
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn update_user_coins_as_business(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_vatom_user_id: String,
        param_app_key: String,
        param_vatom_parameters: String,
        param_return_raw_response: Option<bool>,
        context: &C) -> Result<UpdateUserCoinsAsBusinessResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/vatom/b/users/coins/update",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("vatomUserId",
                    &param_vatom_user_id);
                query_string.append_pair("appKey",
                    &param_app_key);
                query_string.append_pair("vatomParameters",
                    &param_vatom_parameters);
            if let Some(param_return_raw_response) = param_return_raw_response {
                query_string.append_pair("returnRawResponse",
                    &param_return_raw_response.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                Ok(
                    UpdateUserCoinsAsBusinessResponse::SuccessfulOperation
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn update_user_profile(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_vatom_parameters: String,
        param_return_raw_response: Option<bool>,
        context: &C) -> Result<UpdateUserProfileResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/vatom/me/update",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("vatomParameters",
                    &param_vatom_parameters);
            if let Some(param_return_raw_response) = param_return_raw_response {
                query_string.append_pair("returnRawResponse",
                    &param_return_raw_response.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                Ok(
                    UpdateUserProfileResponse::SuccessfulOperation
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn update_vatom_event(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_app_key: String,
        param_vatom_event_id: String,
        param_vatom_parameters: String,
        param_return_raw_response: Option<bool>,
        context: &C) -> Result<UpdateVatomEventResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/vatom/b/events/update",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("appKey",
                    &param_app_key);
                query_string.append_pair("vatomEventId",
                    &param_vatom_event_id);
                query_string.append_pair("vatomParameters",
                    &param_vatom_parameters);
            if let Some(param_return_raw_response) = param_return_raw_response {
                query_string.append_pair("returnRawResponse",
                    &param_return_raw_response.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                Ok(
                    UpdateVatomEventResponse::SuccessfulOperation
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn create_vehicle(
        &self,
        param_version: f64,
        param_vehicle: String,
        param_body: Option<models::Vehicle>,
        context: &C) -> Result<CreateVehicleResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/vehicle",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("vehicle",
                    &param_vehicle);
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        // Consumes basic body
        // Body parameter
        if let Some(param_body) = param_body {
        let body = serde_json::to_string(&param_body).expect("impossible to fail to serialize");
        *request.body_mut() = body_from_string(body);
        }

        let header = "application/json";
        request.headers_mut().insert(CONTENT_TYPE, HeaderValue::from_static(header));

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::Vehicle>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(CreateVehicleResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn search_vehicle(
        &self,
        param_version: f64,
        param_hub_id: i64,
        param_sort_field: String,
        param_descending: bool,
        param_start: i32,
        param_limit: i32,
        param_active_only: bool,
        param_keyword: Option<String>,
        context: &C) -> Result<SearchVehicleResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/vehicle",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("hubId",
                    &param_hub_id.to_string());
            if let Some(param_keyword) = param_keyword {
                query_string.append_pair("keyword",
                    &param_keyword);
            }
                query_string.append_pair("sortField",
                    &param_sort_field);
                query_string.append_pair("descending",
                    &param_descending.to_string());
                query_string.append_pair("start",
                    &param_start.to_string());
                query_string.append_pair("limit",
                    &param_limit.to_string());
                query_string.append_pair("activeOnly",
                    &param_active_only.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<Vec<models::Vehicle>>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(SearchVehicleResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn delete_vehicle(
        &self,
        param_version: f64,
        param_id: i64,
        context: &C) -> Result<DeleteVehicleResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/vehicle/{id}",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
            ,id=utf8_percent_encode(&param_id.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("DELETE")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            0 => {
                Ok(
                    DeleteVehicleResponse::SuccessfulOperation
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_vehicle(
        &self,
        param_version: f64,
        param_id: i64,
        context: &C) -> Result<GetVehicleResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/vehicle/{id}",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
            ,id=utf8_percent_encode(&param_id.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::Vehicle>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetVehicleResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn update_vehicle(
        &self,
        param_version: f64,
        param_id: i64,
        param_vehicle: String,
        param_body: Option<models::Vehicle>,
        context: &C) -> Result<UpdateVehicleResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/vehicle/{id}",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
            ,id=utf8_percent_encode(&param_id.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("vehicle",
                    &param_vehicle);
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("PUT")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        // Consumes basic body
        // Body parameter
        if let Some(param_body) = param_body {
        let body = serde_json::to_string(&param_body).expect("impossible to fail to serialize");
        *request.body_mut() = body_from_string(body);
        }

        let header = "application/json";
        request.headers_mut().insert(CONTENT_TYPE, HeaderValue::from_static(header));

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::Vehicle>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(UpdateVehicleResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn create_vehicle_type(
        &self,
        param_version: f64,
        param_vehicle_type: String,
        param_body: Option<models::VehicleType>,
        context: &C) -> Result<CreateVehicleTypeResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/vehicle/type",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("vehicleType",
                    &param_vehicle_type);
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        // Consumes basic body
        // Body parameter
        if let Some(param_body) = param_body {
        let body = serde_json::to_string(&param_body).expect("impossible to fail to serialize");
        *request.body_mut() = body_from_string(body);
        }

        let header = "application/json";
        request.headers_mut().insert(CONTENT_TYPE, HeaderValue::from_static(header));

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::VehicleType>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(CreateVehicleTypeResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn search_vehicle_types(
        &self,
        param_version: f64,
        param_sort_field: String,
        param_descending: bool,
        param_start: i32,
        param_limit: i32,
        param_active_only: bool,
        param_retailer_id: Option<i64>,
        param_hub_id: Option<i64>,
        context: &C) -> Result<SearchVehicleTypesResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/vehicle/type",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_retailer_id) = param_retailer_id {
                query_string.append_pair("retailerId",
                    &param_retailer_id.to_string());
            }
            if let Some(param_hub_id) = param_hub_id {
                query_string.append_pair("hubId",
                    &param_hub_id.to_string());
            }
                query_string.append_pair("sortField",
                    &param_sort_field);
                query_string.append_pair("descending",
                    &param_descending.to_string());
                query_string.append_pair("start",
                    &param_start.to_string());
                query_string.append_pair("limit",
                    &param_limit.to_string());
                query_string.append_pair("activeOnly",
                    &param_active_only.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<Vec<models::VehicleType>>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(SearchVehicleTypesResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn delete_vehicle_type(
        &self,
        param_version: f64,
        param_vehicle_type_id: i64,
        context: &C) -> Result<DeleteVehicleTypeResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/vehicle/type/{vehicle_type_id}",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
            ,vehicle_type_id=utf8_percent_encode(&param_vehicle_type_id.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("DELETE")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            0 => {
                Ok(
                    DeleteVehicleTypeResponse::SuccessfulOperation
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_vehicle_type(
        &self,
        param_version: f64,
        param_vehicle_type_id: i64,
        context: &C) -> Result<GetVehicleTypeResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/vehicle/type/{vehicle_type_id}",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
            ,vehicle_type_id=utf8_percent_encode(&param_vehicle_type_id.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::VehicleType>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetVehicleTypeResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn update_vehicle_type(
        &self,
        param_version: f64,
        param_vehicle_type_id: i64,
        param_vehicle_type: String,
        param_body: Option<models::VehicleType>,
        context: &C) -> Result<UpdateVehicleTypeResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/vehicle/type/{vehicle_type_id}",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
            ,vehicle_type_id=utf8_percent_encode(&param_vehicle_type_id.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("vehicleType",
                    &param_vehicle_type);
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("PUT")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        // Consumes basic body
        // Body parameter
        if let Some(param_body) = param_body {
        let body = serde_json::to_string(&param_body).expect("impossible to fail to serialize");
        *request.body_mut() = body_from_string(body);
        }

        let header = "application/json";
        request.headers_mut().insert(CONTENT_TYPE, HeaderValue::from_static(header));

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::VehicleType>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(UpdateVehicleTypeResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn create_offer_transaction(
        &self,
        param_version: f64,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_offer_id: Option<i64>,
        param_offer_location_id: Option<i64>,
        param_offer_cart: Option<String>,
        param_promo_code: Option<String>,
        param_currency_type: Option<String>,
        param_use_points: Option<bool>,
        param_meta_data: Option<String>,
        param_app_key: Option<String>,
        param_status: Option<i32>,
        context: &C) -> Result<CreateOfferTransactionResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/wallet/create",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_offer_id) = param_offer_id {
                query_string.append_pair("offerId",
                    &param_offer_id.to_string());
            }
            if let Some(param_offer_location_id) = param_offer_location_id {
                query_string.append_pair("offerLocationId",
                    &param_offer_location_id.to_string());
            }
            if let Some(param_offer_cart) = param_offer_cart {
                query_string.append_pair("offerCart",
                    &param_offer_cart);
            }
            if let Some(param_promo_code) = param_promo_code {
                query_string.append_pair("promoCode",
                    &param_promo_code);
            }
            if let Some(param_currency_type) = param_currency_type {
                query_string.append_pair("currencyType",
                    &param_currency_type);
            }
            if let Some(param_use_points) = param_use_points {
                query_string.append_pair("usePoints",
                    &param_use_points.to_string());
            }
            if let Some(param_meta_data) = param_meta_data {
                query_string.append_pair("metaData",
                    &param_meta_data);
            }
            if let Some(param_app_key) = param_app_key {
                query_string.append_pair("appKey",
                    &param_app_key);
            }
            if let Some(param_status) = param_status {
                query_string.append_pair("status",
                    &param_status.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<Vec<models::OfferTransactionResponse>>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(CreateOfferTransactionResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn delete_offer_transaction(
        &self,
        param_version: f64,
        param_transaction_id: i64,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        context: &C) -> Result<DeleteOfferTransactionResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/wallet/delete",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
                query_string.append_pair("transactionId",
                    &param_transaction_id.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(DeleteOfferTransactionResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_offer_transaction(
        &self,
        param_version: f64,
        param_transaction_id: i64,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_include_mission: Option<bool>,
        param_latitude: Option<f64>,
        param_longitude: Option<f64>,
        param_return_full_response: Option<bool>,
        context: &C) -> Result<GetOfferTransactionResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/wallet/get",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
                query_string.append_pair("transactionId",
                    &param_transaction_id.to_string());
            if let Some(param_include_mission) = param_include_mission {
                query_string.append_pair("includeMission",
                    &param_include_mission.to_string());
            }
            if let Some(param_latitude) = param_latitude {
                query_string.append_pair("latitude",
                    &param_latitude.to_string());
            }
            if let Some(param_longitude) = param_longitude {
                query_string.append_pair("longitude",
                    &param_longitude.to_string());
            }
            if let Some(param_return_full_response) = param_return_full_response {
                query_string.append_pair("returnFullResponse",
                    &param_return_full_response.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::OfferTransactionResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetOfferTransactionResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn preview_offer_transaction(
        &self,
        param_version: f64,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_offer_id: Option<i64>,
        param_offer_location_id: Option<i64>,
        param_offer_cart: Option<String>,
        param_promo_code: Option<String>,
        param_currency_type: Option<String>,
        param_use_points: Option<bool>,
        param_meta_data: Option<String>,
        param_app_key: Option<String>,
        context: &C) -> Result<PreviewOfferTransactionResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/wallet/preview",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_offer_id) = param_offer_id {
                query_string.append_pair("offerId",
                    &param_offer_id.to_string());
            }
            if let Some(param_offer_location_id) = param_offer_location_id {
                query_string.append_pair("offerLocationId",
                    &param_offer_location_id.to_string());
            }
            if let Some(param_offer_cart) = param_offer_cart {
                query_string.append_pair("offerCart",
                    &param_offer_cart);
            }
            if let Some(param_promo_code) = param_promo_code {
                query_string.append_pair("promoCode",
                    &param_promo_code);
            }
            if let Some(param_currency_type) = param_currency_type {
                query_string.append_pair("currencyType",
                    &param_currency_type);
            }
            if let Some(param_use_points) = param_use_points {
                query_string.append_pair("usePoints",
                    &param_use_points.to_string());
            }
            if let Some(param_meta_data) = param_meta_data {
                query_string.append_pair("metaData",
                    &param_meta_data);
            }
            if let Some(param_app_key) = param_app_key {
                query_string.append_pair("appKey",
                    &param_app_key);
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<Vec<models::OfferTransactionResponse>>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(PreviewOfferTransactionResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn search_offer_transactions(
        &self,
        param_version: f64,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_keyword: Option<String>,
        param_retailer_id: Option<i64>,
        param_retailer_ids: Option<String>,
        param_retailer_location_id: Option<i64>,
        param_retailer_location_ids: Option<String>,
        param_exclude_retailer_location_ids: Option<String>,
        param_offer_id: Option<i64>,
        param_offer_ids: Option<String>,
        param_offer_location_id: Option<i64>,
        param_offer_location_ids: Option<String>,
        param_offer_type: Option<models::CreateOfferOfferTypeParameter>,
        param_offer_types: Option<String>,
        param_special_offer_type: Option<String>,
        param_special_offer_types: Option<String>,
        param_category_ids: Option<String>,
        param_filter_ids: Option<String>,
        param_offer_audience_ids: Option<String>,
        param_sort_field: Option<models::SearchOfferTransactionsSortFieldParameter>,
        param_descending: Option<bool>,
        param_start: Option<i32>,
        param_limit: Option<i32>,
        param_latitude: Option<f64>,
        param_longitude: Option<f64>,
        param_redeemable_start_date: Option<i64>,
        param_redeemable_end_date: Option<i64>,
        param_filter_by_parent_offer: Option<bool>,
        param_started_since: Option<i64>,
        param_started_before: Option<i64>,
        param_ended_since: Option<i64>,
        param_ended_before: Option<i64>,
        param_redeemed: Option<bool>,
        param_statuses: Option<String>,
        param_reservations_only: Option<bool>,
        param_active_only: Option<bool>,
        param_return_full_response: Option<bool>,
        param_recurring_started_since: Option<i64>,
        param_recurring_started_before: Option<i64>,
        param_recurring_expiration_since: Option<i64>,
        param_recurring_expiration_before: Option<i64>,
        context: &C) -> Result<SearchOfferTransactionsResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/wallet/search",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
            if let Some(param_keyword) = param_keyword {
                query_string.append_pair("keyword",
                    &param_keyword);
            }
            if let Some(param_retailer_id) = param_retailer_id {
                query_string.append_pair("retailerId",
                    &param_retailer_id.to_string());
            }
            if let Some(param_retailer_ids) = param_retailer_ids {
                query_string.append_pair("retailerIds",
                    &param_retailer_ids);
            }
            if let Some(param_retailer_location_id) = param_retailer_location_id {
                query_string.append_pair("retailerLocationId",
                    &param_retailer_location_id.to_string());
            }
            if let Some(param_retailer_location_ids) = param_retailer_location_ids {
                query_string.append_pair("retailerLocationIds",
                    &param_retailer_location_ids);
            }
            if let Some(param_exclude_retailer_location_ids) = param_exclude_retailer_location_ids {
                query_string.append_pair("excludeRetailerLocationIds",
                    &param_exclude_retailer_location_ids);
            }
            if let Some(param_offer_id) = param_offer_id {
                query_string.append_pair("offerId",
                    &param_offer_id.to_string());
            }
            if let Some(param_offer_ids) = param_offer_ids {
                query_string.append_pair("offerIds",
                    &param_offer_ids);
            }
            if let Some(param_offer_location_id) = param_offer_location_id {
                query_string.append_pair("offerLocationId",
                    &param_offer_location_id.to_string());
            }
            if let Some(param_offer_location_ids) = param_offer_location_ids {
                query_string.append_pair("offerLocationIds",
                    &param_offer_location_ids);
            }
            if let Some(param_offer_type) = param_offer_type {
                query_string.append_pair("offerType",
                    &param_offer_type.to_string());
            }
            if let Some(param_offer_types) = param_offer_types {
                query_string.append_pair("offerTypes",
                    &param_offer_types);
            }
            if let Some(param_special_offer_type) = param_special_offer_type {
                query_string.append_pair("specialOfferType",
                    &param_special_offer_type);
            }
            if let Some(param_special_offer_types) = param_special_offer_types {
                query_string.append_pair("specialOfferTypes",
                    &param_special_offer_types);
            }
            if let Some(param_category_ids) = param_category_ids {
                query_string.append_pair("categoryIds",
                    &param_category_ids);
            }
            if let Some(param_filter_ids) = param_filter_ids {
                query_string.append_pair("filterIds",
                    &param_filter_ids);
            }
            if let Some(param_offer_audience_ids) = param_offer_audience_ids {
                query_string.append_pair("offerAudienceIds",
                    &param_offer_audience_ids);
            }
            if let Some(param_sort_field) = param_sort_field {
                query_string.append_pair("sortField",
                    &param_sort_field.to_string());
            }
            if let Some(param_descending) = param_descending {
                query_string.append_pair("descending",
                    &param_descending.to_string());
            }
            if let Some(param_start) = param_start {
                query_string.append_pair("start",
                    &param_start.to_string());
            }
            if let Some(param_limit) = param_limit {
                query_string.append_pair("limit",
                    &param_limit.to_string());
            }
            if let Some(param_latitude) = param_latitude {
                query_string.append_pair("latitude",
                    &param_latitude.to_string());
            }
            if let Some(param_longitude) = param_longitude {
                query_string.append_pair("longitude",
                    &param_longitude.to_string());
            }
            if let Some(param_redeemable_start_date) = param_redeemable_start_date {
                query_string.append_pair("redeemableStartDate",
                    &param_redeemable_start_date.to_string());
            }
            if let Some(param_redeemable_end_date) = param_redeemable_end_date {
                query_string.append_pair("redeemableEndDate",
                    &param_redeemable_end_date.to_string());
            }
            if let Some(param_filter_by_parent_offer) = param_filter_by_parent_offer {
                query_string.append_pair("filterByParentOffer",
                    &param_filter_by_parent_offer.to_string());
            }
            if let Some(param_started_since) = param_started_since {
                query_string.append_pair("startedSince",
                    &param_started_since.to_string());
            }
            if let Some(param_started_before) = param_started_before {
                query_string.append_pair("startedBefore",
                    &param_started_before.to_string());
            }
            if let Some(param_ended_since) = param_ended_since {
                query_string.append_pair("endedSince",
                    &param_ended_since.to_string());
            }
            if let Some(param_ended_before) = param_ended_before {
                query_string.append_pair("endedBefore",
                    &param_ended_before.to_string());
            }
            if let Some(param_redeemed) = param_redeemed {
                query_string.append_pair("redeemed",
                    &param_redeemed.to_string());
            }
            if let Some(param_statuses) = param_statuses {
                query_string.append_pair("statuses",
                    &param_statuses);
            }
            if let Some(param_reservations_only) = param_reservations_only {
                query_string.append_pair("reservationsOnly",
                    &param_reservations_only.to_string());
            }
            if let Some(param_active_only) = param_active_only {
                query_string.append_pair("activeOnly",
                    &param_active_only.to_string());
            }
            if let Some(param_return_full_response) = param_return_full_response {
                query_string.append_pair("returnFullResponse",
                    &param_return_full_response.to_string());
            }
            if let Some(param_recurring_started_since) = param_recurring_started_since {
                query_string.append_pair("recurringStartedSince",
                    &param_recurring_started_since.to_string());
            }
            if let Some(param_recurring_started_before) = param_recurring_started_before {
                query_string.append_pair("recurringStartedBefore",
                    &param_recurring_started_before.to_string());
            }
            if let Some(param_recurring_expiration_since) = param_recurring_expiration_since {
                query_string.append_pair("recurringExpirationSince",
                    &param_recurring_expiration_since.to_string());
            }
            if let Some(param_recurring_expiration_before) = param_recurring_expiration_before {
                query_string.append_pair("recurringExpirationBefore",
                    &param_recurring_expiration_before.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<Vec<models::OfferTransactionResponse>>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(SearchOfferTransactionsResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn update_offer_transaction(
        &self,
        param_version: f64,
        param_transaction_id: i64,
        param_status: i32,
        param_device_id: Option<String>,
        param_account_id: Option<i64>,
        param_offer_location_id: Option<i64>,
        param_currency_type: Option<String>,
        param_use_points: Option<bool>,
        param_app_key: Option<String>,
        param_latitude: Option<f64>,
        param_longitude: Option<f64>,
        param_meta_data: Option<String>,
        param_return_full_response: Option<bool>,
        param_exception_membership_offer_ids: Option<String>,
        context: &C) -> Result<UpdateOfferTransactionResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/wallet/update",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_device_id) = param_device_id {
                query_string.append_pair("deviceId",
                    &param_device_id);
            }
            if let Some(param_account_id) = param_account_id {
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            }
                query_string.append_pair("transactionId",
                    &param_transaction_id.to_string());
            if let Some(param_offer_location_id) = param_offer_location_id {
                query_string.append_pair("offerLocationId",
                    &param_offer_location_id.to_string());
            }
            if let Some(param_currency_type) = param_currency_type {
                query_string.append_pair("currencyType",
                    &param_currency_type);
            }
            if let Some(param_use_points) = param_use_points {
                query_string.append_pair("usePoints",
                    &param_use_points.to_string());
            }
            if let Some(param_app_key) = param_app_key {
                query_string.append_pair("appKey",
                    &param_app_key);
            }
                query_string.append_pair("status",
                    &param_status.to_string());
            if let Some(param_latitude) = param_latitude {
                query_string.append_pair("latitude",
                    &param_latitude.to_string());
            }
            if let Some(param_longitude) = param_longitude {
                query_string.append_pair("longitude",
                    &param_longitude.to_string());
            }
            if let Some(param_meta_data) = param_meta_data {
                query_string.append_pair("metaData",
                    &param_meta_data);
            }
            if let Some(param_return_full_response) = param_return_full_response {
                query_string.append_pair("returnFullResponse",
                    &param_return_full_response.to_string());
            }
            if let Some(param_exception_membership_offer_ids) = param_exception_membership_offer_ids {
                query_string.append_pair("exceptionMembershipOfferIds",
                    &param_exception_membership_offer_ids);
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::OfferTransactionResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(UpdateOfferTransactionResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn search_weather(
        &self,
        param_version: f64,
        param_region_id: Option<i64>,
        param_latitude: Option<f64>,
        param_longitude: Option<f64>,
        param_timezone_offset: Option<i64>,
        context: &C) -> Result<SearchWeatherResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/weather/search",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
            if let Some(param_region_id) = param_region_id {
                query_string.append_pair("regionId",
                    &param_region_id.to_string());
            }
            if let Some(param_latitude) = param_latitude {
                query_string.append_pair("latitude",
                    &param_latitude.to_string());
            }
            if let Some(param_longitude) = param_longitude {
                query_string.append_pair("longitude",
                    &param_longitude.to_string());
            }
            if let Some(param_timezone_offset) = param_timezone_offset {
                query_string.append_pair("timezoneOffset",
                    &param_timezone_offset.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::WeatherResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(SearchWeatherResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn create_word(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_word: String,
        param_definition: String,
        param_active: bool,
        param_allocate_tickets: bool,
        param_ticket_count: i64,
        param_asset_id: Option<i64>,
        param_ticket_type: Option<String>,
        param_points: Option<i64>,
        context: &C) -> Result<CreateWordResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/game/word/create",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("word",
                    &param_word);
                query_string.append_pair("definition",
                    &param_definition);
            if let Some(param_asset_id) = param_asset_id {
                query_string.append_pair("assetId",
                    &param_asset_id.to_string());
            }
                query_string.append_pair("active",
                    &param_active.to_string());
                query_string.append_pair("allocateTickets",
                    &param_allocate_tickets.to_string());
                query_string.append_pair("ticketCount",
                    &param_ticket_count.to_string());
            if let Some(param_ticket_type) = param_ticket_type {
                query_string.append_pair("ticketType",
                    &param_ticket_type);
            }
            if let Some(param_points) = param_points {
                query_string.append_pair("points",
                    &param_points.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::WordzWordResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(CreateWordResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn delete_word(
        &self,
        param_version: f64,
        param_word_id: i64,
        param_account_id: i64,
        context: &C) -> Result<DeleteWordResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/game/word/delete",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("wordId",
                    &param_word_id.to_string());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("DELETE")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(DeleteWordResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_word(
        &self,
        param_version: f64,
        param_word_id: i64,
        param_account_id: i64,
        context: &C) -> Result<GetWordResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/game/word/get",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("wordId",
                    &param_word_id.to_string());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::WordzWordResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetWordResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn get_words(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_sort_field: String,
        param_descending: bool,
        param_active_only: bool,
        param_start: i32,
        param_limit: i32,
        param_keyword: Option<String>,
        context: &C) -> Result<GetWordsResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/game/word/search",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            if let Some(param_keyword) = param_keyword {
                query_string.append_pair("keyword",
                    &param_keyword);
            }
                query_string.append_pair("sortField",
                    &param_sort_field);
                query_string.append_pair("descending",
                    &param_descending.to_string());
                query_string.append_pair("activeOnly",
                    &param_active_only.to_string());
                query_string.append_pair("start",
                    &param_start.to_string());
                query_string.append_pair("limit",
                    &param_limit.to_string());
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("GET")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<Vec<models::WordzWordResponse>>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(GetWordsResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn update_word(
        &self,
        param_version: f64,
        param_word_id: i64,
        param_account_id: i64,
        param_ticket_count: i64,
        param_word_text: Option<String>,
        param_definition: Option<String>,
        param_asset_id: Option<i64>,
        param_active: Option<bool>,
        param_allocate_tickets: Option<bool>,
        param_ticket_type: Option<String>,
        param_points: Option<i64>,
        context: &C) -> Result<UpdateWordResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/game/word/update",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("wordId",
                    &param_word_id.to_string());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
            if let Some(param_word_text) = param_word_text {
                query_string.append_pair("wordText",
                    &param_word_text);
            }
            if let Some(param_definition) = param_definition {
                query_string.append_pair("definition",
                    &param_definition);
            }
            if let Some(param_asset_id) = param_asset_id {
                query_string.append_pair("assetId",
                    &param_asset_id.to_string());
            }
            if let Some(param_active) = param_active {
                query_string.append_pair("active",
                    &param_active.to_string());
            }
            if let Some(param_allocate_tickets) = param_allocate_tickets {
                query_string.append_pair("allocateTickets",
                    &param_allocate_tickets.to_string());
            }
                query_string.append_pair("ticketCount",
                    &param_ticket_count.to_string());
            if let Some(param_ticket_type) = param_ticket_type {
                query_string.append_pair("ticketType",
                    &param_ticket_type);
            }
            if let Some(param_points) = param_points {
                query_string.append_pair("points",
                    &param_points.to_string());
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::WordzWordResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(UpdateWordResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

    #[allow(clippy::vec_init_then_push)]
    async fn run_workflow(
        &self,
        param_version: f64,
        param_account_id: i64,
        param_workflow_id: i64,
        param_sku_id: Option<i64>,
        param_version_code: Option<i32>,
        param_parameters: Option<String>,
        context: &C) -> Result<RunWorkflowResponse, ApiError>
    {
        let mut client_service = self.client_service.clone();
        #[allow(clippy::uninlined_format_args)]
        let mut uri = format!(
            "{}/api/{version}/workflow/run",
            self.base_path
            ,version=utf8_percent_encode(&param_version.to_string(), ID_ENCODE_SET)
        );

        // Query parameters
        let query_string = {
            let mut query_string = form_urlencoded::Serializer::new("".to_owned());
                query_string.append_pair("accountId",
                    &param_account_id.to_string());
                query_string.append_pair("workflowId",
                    &param_workflow_id.to_string());
            if let Some(param_sku_id) = param_sku_id {
                query_string.append_pair("skuId",
                    &param_sku_id.to_string());
            }
            if let Some(param_version_code) = param_version_code {
                query_string.append_pair("versionCode",
                    &param_version_code.to_string());
            }
            if let Some(param_parameters) = param_parameters {
                query_string.append_pair("parameters",
                    &param_parameters);
            }
            query_string.finish()
        };
        if !query_string.is_empty() {
            uri += "?";
            uri += &query_string;
        }

        let uri = match Uri::from_str(&uri) {
            Ok(uri) => uri,
            Err(err) => return Err(ApiError(format!("Unable to build URI: {err}"))),
        };

        let mut request = match Request::builder()
            .method("POST")
            .uri(uri)
            .body(BoxBody::new(http_body_util::Empty::new())) {
                Ok(req) => req,
                Err(e) => return Err(ApiError(format!("Unable to create request: {e}")))
        };

        let header = HeaderValue::from_str(Has::<XSpanIdString>::get(context).0.as_str());
        request.headers_mut().insert(HeaderName::from_static("x-span-id"), match header {
            Ok(h) => h,
            Err(e) => return Err(ApiError(format!("Unable to create X-Span ID header value: {e}")))
        });

        let response = client_service.call((request, context.clone()))
            .map_err(|e| ApiError(format!("No response received: {e}"))).await?;

        match response.status().as_u16() {
            200 => {
                let body = response.into_body();
                let body = http_body_util::BodyExt::collect(body)
                        .await
                        .map(|f| f.to_bytes().to_vec())
                        .map_err(|e| ApiError(format!("Failed to read response: {}", e.into())))?;

                let body = str::from_utf8(&body)
                    .map_err(|e| ApiError(format!("Response was not valid UTF8: {e}")))?;
                let body = serde_json::from_str::<models::SirqulResponse>(body)
                    .map_err(|e| ApiError(format!("Response body did not match the schema: {e}")))?;


                Ok(RunWorkflowResponse::SuccessfulOperation
                    (body)
                )
            }
            code => {
                let headers = response.headers().clone();
                let body = http_body_util::BodyExt::collect(response.into_body())
                        .await
                        .map(|f| f.to_bytes().to_vec());
                Err(ApiError(format!("Unexpected response code {code}:\n{headers:?}\n\n{}",
                    match body {
                        Ok(body) => match String::from_utf8(body) {
                            Ok(body) => body,
                            Err(e) => format!("<Body was not UTF8: {e:?}>"),
                        },
                        Err(e) => format!("<Failed to read body: {}>", Into::<crate::ServiceError>::into(e)),
                    }
                )))
            }
        }
    }

}
