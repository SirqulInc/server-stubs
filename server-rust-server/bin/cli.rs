//! CLI tool driving the API client
use anyhow::{anyhow, Context, Result};
use clap::Parser;
use dialoguer::Confirm;
use log::{debug, info};
// models may be unused if all inputs are primitive types
#[allow(unused_imports)]
use openapi_client::{
    models, ApiNoContext, Client, ContextWrapperExt,
    ConsumerCreateResponse,
    ConsumerUpdateResponse,
    QueueCreateResponse,
    QueueDeleteResponse,
    QueueGetResponse,
    QueuePublishResponse,
    QueueSearchResponse,
    QueueUpdateResponse,
    AccountLocationSearchResponse,
    BlockAccountResponse,
    CreateAccountResponse,
    EditAccountResponse,
    EditUsernameResponse,
    GetAccountResponse,
    GetProfileAssetsResponse,
    GetReferralListResponse,
    GetSettingsResponse,
    LoginDelegateResponse,
    LoginGeneralResponse,
    LoginUsernameResponse,
    LogoutResponse,
    MergeAccountResponse,
    PasswordChangeResponse,
    PasswordResetResponse,
    RequestPasswordResetResponse,
    RequestValidateAccountResponse,
    SearchAccountsResponse,
    SecureLoginResponse,
    SecureSignupResponse,
    SetMatchTokenResponse,
    UpdateActveStatusResponse,
    UpdateLocationResponse,
    UpdateSettingsResponse,
    ValidateAccountSignupResponse,
    ValidatePasswordResetResponse,
    ApiVersionAchievementTierSearchPostResponse,
    CreateAchievementResponse,
    CreateAchievementTierResponse,
    DeleteAchievementResponse,
    DeleteAchievementTierResponse,
    GetAchievementResponse,
    GetAchievementTierResponse,
    GetUserAchievementsResponse,
    ListAchievementTagsResponse,
    ListAchievementsResponse,
    SearchAchievementsResponse,
    UpdateAchievementResponse,
    UpdateAchievementTierResponse,
    UpdateUserAchievementResponse,
    CreateEntityReferenceResponse,
    AddAlbumCollectionResponse,
    AddAlbumUsersResponse,
    ApproveAlbumResponse,
    GetAlbumCollectionResponse,
    LeaveAlbumResponse,
    RemoveAlbumResponse,
    RemoveAlbumUsersResponse,
    SearchAlbumsResponse,
    UpdateAlbumCollectionResponse,
    ActivitiesResponse,
    AggregatedFilteredUsageResponse,
    FilteredUsageResponse,
    UsageResponse,
    UsageBatchResponse,
    GetAppDataResponse,
    PostAppDataResponse,
    RegenAppDataResponse,
    CreateApplicationResponse,
    CreateApplicationPlacementResponse,
    DeleteApplicationResponse,
    DeleteApplicationPlacementResponse,
    GetApplicationResponse,
    GetApplicationPlacementResponse,
    GetApplicationVersionsResponse,
    GetUniqueUsersByAppResponse,
    ListApplicationsResponse,
    SearchApplicationPlacementResponse,
    SearchApplicationSettingsResponse,
    SearchApplicationsResponse,
    UpdateApplicationResponse,
    UpdateApplicationActiveResponse,
    UpdateApplicationPlacementResponse,
    UploadApplicationCertificateResponse,
    CreateApplicationConfigResponse,
    DeleteApplicationConfigResponse,
    GetApplicationConfigResponse,
    GetApplicationConfigByConfigVersionResponse,
    SearchApplicationConfigResponse,
    UpdateApplicationConfigResponse,
    AssetMorphResponse,
    CreateAssetResponse,
    DeleteAssetResponse,
    GetAssetResponse,
    RemoveAssetResponse,
    SearchAssetsResponse,
    UpdateAssetResponse,
    AssetDownloadResponse,
    AssigmentAssigneeAccountSearchResponse,
    AssignmentCreateResponse,
    AssignmentDeleteResponse,
    AssignmentGetResponse,
    AssignmentSearchResponse,
    AssignmentStatusCreateResponse,
    AssignmentStatusDeleteResponse,
    AssignmentStatusGetResponse,
    AssignmentStatusSearchResponse,
    AssignmentStatusUpdateResponse,
    AssignmentUpdateResponse,
    CreateAudienceResponse,
    DeleteAudienceResponse,
    GetAgeGroupsResponse,
    GetAudienceResponse,
    GetAudienceListResponse,
    GetDevicesResponse,
    GetExperiencesResponse,
    GetGroupedAudiencesResponse,
    ListByAccountResponse,
    ListByAudienceResponse,
    ListLastestByAccountResponse,
    SendByAccountResponse,
    UpdateAudienceResponse,
    CreateBidResponse,
    DeleteBidResponse,
    GetBidResponse,
    UpdateBidResponse,
    CreateBillableEntityResponse,
    DeleteBillableEntityResponse,
    GetBillableEntityResponse,
    UpdateBillableEntityResponse,
    AddPaymentMethodResponse,
    CreatePaymentMethodResponse,
    CreateSmartContractResponse,
    GetCryptoBalanceResponse,
    GetPaymentMethodResponse,
    SearchPaymentMethodResponse,
    GetStatusCsvResponse,
    ListStatusCsvResponse,
    StatusCsvResponse,
    UploadCsvResponse,
    CreateCargoTypeResponse,
    SearchCargoTypesResponse,
    DeleteCargoTypeResponse,
    GetCargoTypeResponse,
    UpdateCargoTypeResponse,
    SearchCarriersResponse,
    CategoryDistanceSearchResponse,
    CreateCategoryResponse,
    DeleteCategoryResponse,
    DuplicateCategoryResponse,
    GetCategoryResponse,
    SearchCategoriesResponse,
    UpdateCategoryResponse,
    AddConnectionToGroupResponse,
    AddConnectionsToGroupResponse,
    AddSubGroupsResponse,
    CreateOrUpdateConnectionResponse,
    CreateOrUpdateGroupResponse,
    FollowAcceptResponse,
    FollowRejectResponse,
    FollowRemoveResponse,
    FollowRequestResponse,
    FriendAcceptResponse,
    FriendRejectResponse,
    FriendRemoveResponse,
    FriendRequestResponse,
    GetConnectionSentFriendRequestsResponse,
    GetConnectionsResponse,
    GetGroupDetailsResponse,
    GroupSearchResponse,
    RemoveConnectionFromGroupResponse,
    RemoveConnectionsFromGroupResponse,
    RemoveGroupResponse,
    RemoveSubGroupsResponse,
    SearchConnectionsResponse,
    AddOrUpdateAlbumContestResponse,
    ApproveAlbumContestResponse,
    DeleteContestResponse,
    GetAlbumContestResponse,
    GetAlbumContestsResponse,
    VoteOnAlbumContestResponse,
    AddPreviewResponse,
    AdsFindResponse,
    CreateCreativeResponse,
    DeleteCreativeResponse,
    GetCreativeResponse,
    GetCreativesByApplicationResponse,
    RemovePreviewResponse,
    UpdateCreativeResponse,
    CreateResponse,
    GetDependentsResponse,
    RemoveDependentResponse,
    CheckDisbursementsResponse,
    CreateDisbursementResponse,
    GetDisbursementResponse,
    SearchDisbursementsResponse,
    UpdateDisbursementResponse,
    AssignEmployeeResponse,
    AssignToLocationEmployeeResponse,
    CreateEmployeeResponse,
    DeleteEmployeeResponse,
    GetEmployeeResponse,
    SearchEmployeesResponse,
    UnassignEmployeeResponse,
    UpdateEmployeeResponse,
    AttendEventResponse,
    CreateEventResponse,
    DeleteEventResponse,
    GetEventResponse,
    SearchEventTransactionsResponse,
    SearchEventsResponse,
    UpdateEventResponse,
    GetTokenResponse,
    GraphInterfaceResponse,
    AddFavoriteResponse,
    DeleteFavoriteResponse,
    GetFavoriteResponse,
    SearchFavoritesResponse,
    WhoHasFavoritedResponse,
    CreateFilterResponse,
    DeleteFilterResponse,
    GetFilterResponse,
    SearchFiltersResponse,
    UpdateFilterResponse,
    CreateFlagResponse,
    DeleteFlagResponse,
    GetFlagResponse,
    GetFlagThresholdResponse,
    UpdateFlagThresholdResponse,
    CreateGameResponse,
    DeleteGameResponse,
    GetGameResponse,
    SearchGamesResponse,
    UpdateGameResponse,
    CreateGameLevelResponse,
    DeleteGameLevelResponse,
    GetGameLevelResponse,
    GetGameLevelsByApplicationResponse,
    GetGameLevelsByBillableEntityResponse,
    GetQuestionsInLevelResponse,
    GetWordsInLevelResponse,
    UpdateGameLevelResponse,
    UpdateQuestionsInLevelResponse,
    UpdateWordsInLevelResponse,
    AcceptInviteResponse,
    AlbumContestInviteResponse,
    AlbumInviteResponse,
    EventInviteResponse,
    GameInviteResponse,
    GetInviteResponse,
    MissionInviteResponse,
    OfferInviteResponse,
    OfferLocationInviteResponse,
    RetailerLocationInviteResponse,
    CreateLeaderboardResponse,
    DeleteLeaderboardResponse,
    GetLeaderboardResponse,
    SearchLeaderboardsResponse,
    UpdateLeaderboardResponse,
    RegisterLikeResponse,
    RemoveLikeResponse,
    SearchLikesResponse,
    CreateListingResponse,
    DeleteListingResponse,
    GetListingResponse,
    SearchListingResponse,
    SummaryListingResponse,
    UpdateListingResponse,
    CacheTrilaterationDataResponse,
    CacheTrilaterationDataGzipResponse,
    GetLocationByIpResponse,
    GetLocationByTrilaterationResponse,
    GetLocationsResponse,
    CreateLocationV2Response,
    UpdateLocationV2Response,
    CreateMediaResponse,
    DeleteMediaResponse,
    GetMediaResponse,
    SearchMediaResponse,
    UpdateMediaResponse,
    CreateMissionResponse,
    DeleteMissionResponse,
    FindMissionsResponse,
    GetMissionResponse,
    ImportMissionResponse,
    SearchMissionFormatsResponse,
    SearchMissionsResponse,
    SearchMissionsByBillableEntityResponse,
    UpdateMissionResponse,
    CreateMissionInviteResponse,
    DeleteMissionInviteResponse,
    GetMissionInviteResponse,
    SearchMissionInvitesResponse,
    UpdateMissionInviteResponse,
    BatchOperationResponse,
    CreateNoteResponse,
    DeleteNoteResponse,
    GetNoteResponse,
    SearchNotesResponse,
    UpdateNoteResponse,
    CreateNotificationTemplateResponse,
    CreateOrUpdateBlockedNotificationsResponse,
    DeleteNotificationTemplateResponse,
    GetNotificationTemplateResponse,
    GetNotificationsResponse,
    RegisterNotificationTokenResponse,
    SearchBlockedNotificationsResponse,
    SearchNotificationTemplateResponse,
    SearchRecipientsResponse,
    SearchRecipientsCountResponse,
    SendBatchNotificationsResponse,
    SendCustomNotificationsResponse,
    UpdateNotificationTemplateResponse,
    AddFieldResponse,
    CreateObjectResponse,
    DeleteFieldResponse,
    DeleteObjectResponse,
    GetObjectResponse,
    SearchObjectResponse,
    CreateDataResponse,
    SearchDataResponse,
    DeleteDataResponse,
    GetDataResponse,
    UpdateDataResponse,
    BatchUpdateOfferLocationsResponse,
    CreateOfferResponse,
    DeleteOfferResponse,
    DeleteOfferLocationResponse,
    GetOfferResponse,
    GetOfferDetailsResponse,
    GetOfferListCountsResponse,
    GetOfferLocationResponse,
    GetOfferLocationsForRetailersResponse,
    GetOffersForRetailersResponse,
    RedeemOfferTransactionResponse,
    SearchOfferTransactionsForRetailersResponse,
    SearchOffersForConsumerResponse,
    TopOfferTransactionsResponse,
    UpdateOfferResponse,
    UpdateOfferStatusResponse,
    CreateOfferTransactionStatusResponse,
    DeleteOfferTransactionStatusResponse,
    GetOfferTransactionStatusResponse,
    SearchOfferTransactionStatusesResponse,
    UpdateOfferTransactionStatusResponse,
    ImageGenerationResponse,
    RequestOptimizationResponse,
    GetOptimizationResultResponse,
    AddMovieResponse,
    AiDocsResponse,
    AiFindImagesResponse,
    AiTagsResponse,
    AiTextResponse,
    BatchResponse,
    CreateInstantEpisodeResponse,
    CreateVoiceCanvasResponse,
    EmotionResponse,
    StartVideoRenderResponse,
    SttResponse,
    SummarizeTopicsResponse,
    TechTuneResponse,
    TtsResponse,
    GetAddMovieResultResponse,
    GetBatchResponse,
    GetEmotionResponse,
    GetEpisodeStatusResponse,
    GetRenderStatusResponse,
    GetSttResponse,
    GetTechTuneResponse,
    GetTopicsResponse,
    GetTtsResponse,
    GetVoiceCanvasResponse,
    CreatePackResponse,
    DeletePackResponse,
    GetPackResponse,
    SearchPacksResponse,
    UpdatePackResponse,
    ProcessAllParticipantsResponse,
    ProcessParticipantsResponse,
    ComputePathResponse,
    CreatePostalCodeResponse,
    DeletePostalCodeResponse,
    GetPostalCodeResponse,
    GetPostalCodesResponse,
    UpdatePostalCodeResponse,
    CreatePersonaResponse,
    DeletePersonaResponse,
    GetPersonaListResponse,
    SearchPersonaResponse,
    UpdatePersonaResponse,
    CreateProgramResponse,
    SearchProgramsResponse,
    DeleteProgramResponse,
    GetProgramResponse,
    PostProgramResponse,
    PutProgramResponse,
    CreatePurchaseItemResponse,
    DeletePurchaseItemResponse,
    GetPurchaseItemResponse,
    SearchPurchaseItemsResponse,
    UpdatePurchaseItemResponse,
    CreateOrderResponse,
    DeleteOrderResponse,
    GetOrderResponse,
    PreviewOrderResponse,
    SearchOrdersResponse,
    UpdateOrderResponse,
    CreateQuestionResponse,
    DeleteQuestionResponse,
    GetQuestionResponse,
    SearchQuestionsResponse,
    UpdateQuestionResponse,
    GetHistoricalRankingsResponse,
    GetRankingsResponse,
    GetUserRankResponse,
    OverrideUserRankResponse,
    UpdateRankingsResponse,
    CreateRatingResponse,
    DeleteRatingResponse,
    SearchLocationRatingIndexesResponse,
    SearchRatingIndexesResponse,
    SearchRatingsResponse,
    UpdateRatingResponse,
    CreateRegionResponse,
    DeleteRegionResponse,
    GetRegionResponse,
    SearchRegionsResponse,
    UpdateRegionResponse,
    CreateBatchResponse,
    CreateRegionLegSummaryBatchResponse,
    DeleteBatchResponse,
    GetReportBatchResponse,
    RunReportResponse,
    SearchBatchResponse,
    CreateReservationResponse,
    DeleteReservationResponse,
    ReservableAvailabilityResponse,
    SearchAvailabilityResponse,
    SearchReservationsResponse,
    SearchScheduleResponse,
    CreateRetailerResponse,
    DeleteRetailerResponse,
    GetRetailerResponse,
    GetRetailersResponse,
    RetailerLoginCheckResponse,
    UpdateRetailerResponse,
    CreateRetailerLocationConsumerResponse,
    CreateRetailerLocationsResponse,
    DeleteRetailerLocationResponse,
    GetRetailerLocationResponse,
    GetRetailerLocationConsumerResponse,
    IndexedRetailerLocationDistanceSearchResponse,
    IndexedRetailerLocationSearchResponse,
    SearchRetailerLocationsResponse,
    UpdateRetailerLocationsResponse,
    GetRetaokilerResponse,
    CreateRouteResponse,
    SearchRoutesResponse,
    ApproveRouteResponse,
    CopyRouteResponse,
    CreateRouteDirectionsResponse,
    CreateRoutePolylineResponse,
    DeleteRouteResponse,
    DisapproveRouteResponse,
    GetRouteResponse,
    GetRouteDirectionsResponse,
    GetRouteShipmentsResponse,
    GetRouteStopsResponse,
    OptimizeRouteResponse,
    ReorderRouteStopsPatchResponse,
    ReorderRouteStopsPostResponse,
    UpdateRouteResponse,
    GetRouteStopResponse,
    GetShipmentsAtStopResponse,
    RemoveStopResponse,
    SetDriverResponse,
    UpdateRouteStopResponse,
    CreateRouteSettingsResponse,
    SearchRouteSettingsResponse,
    DeleteRouteSettingsResponse,
    GetRouteSettingsResponse,
    UpdateRouteSettingsResponse,
    ComputeRoutingResponse,
    CreateScheduledNotificationResponse,
    DeleteScheduledNotificationResponse,
    GetScheduledNotificationResponse,
    ScheduleNotificationListingsResponse,
    SearchScheduledNotificationsResponse,
    UpdateScheduledNotificationResponse,
    CreateScoreResponse,
    GetScoreResponse,
    SearchScoresResponse,
    CreateSecureApplicationResponse,
    DeleteSecureApplicationResponse,
    LoginSecureResponse,
    PurchaseSecureResponse,
    ResetSecureResponse,
    UpdateSecureApplicationResponse,
    CreateServiceHubResponse,
    SearchServiceHubsResponse,
    DeleteServiceHubResponse,
    GetServiceHubResponse,
    PostServiceHubResponse,
    PutServiceHubResponse,
    CreateShipmentResponse,
    SearchShipmentsResponse,
    CancelShipmentResponse,
    DeleteShipmentResponse,
    GetShipmentResponse,
    UpdateShipmentResponse,
    UpdateShipmentStatusResponse,
    CreateShipmentBatchResponse,
    SearchShipmentBatchResponse,
    DeleteShipmentBatchResponse,
    GetShipmentBatchResponse,
    GetShipmentBatchStatusResponse,
    SimulationResponse,
    GetStopResponse,
    UpdateStopResponse,
    CreateStripeCheckoutSessionResponse,
    CreateSubscriptionResponse,
    DeleteSubscriptionResponse,
    GetSubscriptionResponse,
    GetSubscriptionPlanResponse,
    GetSubscriptionPlansResponse,
    GetSubscriptionUsageResponse,
    UpdateSubscriptionResponse,
    CreateTaskResponse,
    DeleteTaskResponse,
    GetTaskResponse,
    SearchTasksResponse,
    UpdateTaskResponse,
    CreateTerritoryResponse,
    DeleteTerritoryResponse,
    GetTerritoryResponse,
    SearchTerritoriesResponse,
    UpdateTerritoryResponse,
    AddOrUpdateThemeDescriptorResponse,
    GetThemeDescriptorResponse,
    GetThemeDescriptorsResponse,
    RemoveThemeDescriptorResponse,
    CreateCredentialResponse,
    CreateNetworkResponse,
    DeleteCredentialResponse,
    DeleteNetworkResponse,
    GetCredentialResponse,
    GetNetworkResponse,
    SearchCredentialsResponse,
    SearchNetworksResponse,
    SendMfaChallengeResponse,
    UpdateCredentialResponse,
    UpdateNetworkResponse,
    GetTicketCountResponse,
    GetTicketListResponse,
    GiftPurchaseResponse,
    SaveTicketResponse,
    SaveTicketViaFileUploadResponse,
    TicketOffersResponse,
    CreateTournamentResponse,
    DeleteTournamentResponse,
    GetTournamentResponse,
    SearchObjectsResponse,
    SearchRoundsResponse,
    SearchTournamentsResponse,
    SubmitTournamentScoreResponse,
    SubmitTournamentVoteResponse,
    SubstituteTournamentPlayerResponse,
    UpdateTournamentResponse,
    BatchSaveTrackingResponse,
    GetPredictedLocationsResponse,
    GetPredictedPathResponse,
    GetPreferredLocationsResponse,
    GetTrackingLegsResponse,
    SaveTrackingLegResponse,
    SaveTrackingStepResponse,
    SearchAccountsWithTrackingLegsResponse,
    SearchTrackingLegsResponse,
    CreateTriggerResponse,
    DeleteTriggerResponse,
    GetTriggerResponse,
    SearchTriggersResponse,
    UpdateTriggerResponse,
    CreateTripResponse,
    ProcessTripMatchesResponse,
    SearchResponse,
    SearchTripsResponse,
    UpdateTripNotificationsResponse,
    DeleteResponse,
    DriveTripResponse,
    FlexibleTripResponse,
    GetTripResponse,
    GetTripMatchesResponse,
    RideResponse,
    UpdateLocationsResponse,
    UpdateRecurrenceLocationsResponse,
    UpdateRecurrenceShipmentsResponse,
    UpdateShipmentsResponse,
    UpdateTripResponse,
    SmsBuyOfferResponse,
    AuthorizeTwitterResponse,
    LoginTwitterResponse,
    AddUsersToPermissionableResponse,
    ApprovePermissionableResponse,
    LeaveFromPermissionableResponse,
    RemoveUsersFromPermissionableResponse,
    SearchPermissionablesResponse,
    SearchPermissionablesFollowingDistanceResponse,
    CreateFollowingResponse,
    CreateSpaceResponse,
    CreateVatomEventResponse,
    DeleteFollowingResponse,
    DeletePointsBalanceResponse,
    DeleteSpaceResponse,
    DeleteVatomEventResponse,
    DeleteVatomNftResponse,
    ExecuteActionOnNftResponse,
    GeomapSearchResponse,
    GetBusinessBehaviorsResponse,
    GetBusinessCoinsBalanceResponse,
    GetBusinessIdsResponse,
    GetBusinessInfoResponse,
    GetBusinessUsersResponse,
    GetCampaignGroupEntitiesResponse,
    GetCampaignGroupRulesResponse,
    GetCampaignGroupStatsResponse,
    GetCampaignInfoResponse,
    GetEventGuestListResponse,
    GetInventoryResponse,
    GetMyFollowingResponse,
    GetPointsBalanceResponse,
    GetPointsBalanceAsBusinessResponse,
    GetSpaceResponse,
    GetUserCoinsAsBusinessResponse,
    GetUserCoinsBalanceResponse,
    GetUserFollowersResponse,
    GetUserFollowingResponse,
    GetUserInfoResponse,
    GetUserProfileResponse,
    GetVatomEventResponse,
    GetVatomNftResponse,
    ListCommunitiesResponse,
    ListEventsResponse,
    ListSpacesResponse,
    ListUserCoinTransactionsResponse,
    ListUserCoinTransactionsAsBusinessResponse,
    PerformActionOnNftResponse,
    RedeemNftResponse,
    RedeemUserCoinsAsBusinessResponse,
    SearchBusinessesResponse,
    SearchCampaignGroupsResponse,
    SearchIdentitiesResponse,
    SearchInventoryResponse,
    SendNftResponse,
    SetPointsBalanceAsBusinessResponse,
    TransferUserCoinsResponse,
    UpdateBusinessCoinsResponse,
    UpdateEventGuestListResponse,
    UpdateSpaceResponse,
    UpdateUserCoinsAsBusinessResponse,
    UpdateUserProfileResponse,
    UpdateVatomEventResponse,
    CreateVehicleResponse,
    SearchVehicleResponse,
    DeleteVehicleResponse,
    GetVehicleResponse,
    UpdateVehicleResponse,
    CreateVehicleTypeResponse,
    SearchVehicleTypesResponse,
    DeleteVehicleTypeResponse,
    GetVehicleTypeResponse,
    UpdateVehicleTypeResponse,
    CreateOfferTransactionResponse,
    DeleteOfferTransactionResponse,
    GetOfferTransactionResponse,
    PreviewOfferTransactionResponse,
    SearchOfferTransactionsResponse,
    UpdateOfferTransactionResponse,
    SearchWeatherResponse,
    CreateWordResponse,
    DeleteWordResponse,
    GetWordResponse,
    GetWordsResponse,
    UpdateWordResponse,
    RunWorkflowResponse,
};
use simple_logger::SimpleLogger;
use swagger::{AuthData, ContextBuilder, EmptyContext, Push, XSpanIdString};

type ClientContext = swagger::make_context_ty!(
    ContextBuilder,
    EmptyContext,
    Option<AuthData>,
    XSpanIdString
);

#[derive(Parser, Debug)]
#[clap(
    name = "Sirqul IoT Platform",
    version = "3.16",
    about = "CLI access to Sirqul IoT Platform"
)]
struct Cli {
    #[clap(subcommand)]
    operation: Operation,

    /// Address or hostname of the server hosting this API, including optional port
    #[clap(short = 'a', long, default_value = "http://localhost")]
    server_address: String,

    /// Path to the client private key if using client-side TLS authentication
    #[cfg(all(feature = "client-tls", not(any(target_os = "macos", target_os = "windows", target_os = "ios"))))]
    #[clap(long, requires_all(&["client_certificate", "server_certificate"]))]
    client_key: Option<String>,

    /// Path to the client's public certificate associated with the private key
    #[cfg(all(feature = "client-tls", not(any(target_os = "macos", target_os = "windows", target_os = "ios"))))]
    #[clap(long, requires_all(&["client_key", "server_certificate"]))]
    client_certificate: Option<String>,

    /// Path to CA certificate used to authenticate the server
    #[cfg(all(feature = "client-tls", not(any(target_os = "macos", target_os = "windows", target_os = "ios"))))]
    #[clap(long)]
    server_certificate: Option<String>,

    /// If set, write output to file instead of stdout
    #[clap(short, long)]
    output_file: Option<String>,

    #[command(flatten)]
    verbosity: clap_verbosity_flag::Verbosity,

    /// Don't ask for any confirmation prompts
    #[allow(dead_code)]
    #[clap(short, long)]
    force: bool,
}

#[derive(Parser, Debug)]
enum Operation {
    /// Create Consumer
    ConsumerCreate {
        version: f64,
        /// The application key to use when creating an analytic or service request. The account needs to have permissions to the applicaton or it will be denied.
        app_key: String,
        /// The name of the queue to connect to
        name: String,
        /// The hostname of the server the queue is hosted on
        hostname: String,
        /// The username to access the server the queue is hosted on
        username: String,
        /// The password to access the queue to connect to
        password: String,
        /// The data mapping information in the format of AMQPRequest
        data_mapping: String,
        /// The client deviceID
        device_id: Option<String>,
        /// The logged in user ID
        account_id: Option<i64>,
        /// The port of the server the queue is hosted on
        port: Option<i32>,
        /// The virtual host defined on the server the queue is associated on
        virtual_host: Option<String>,
        /// The exchanger of the queue to connect to
        exchanger: Option<String>,
        /// The exchanger type of the queue to connect to
        exchanger_type: Option<String>,
        /// The number of workers to generate 
        workers: Option<i32>,
        /// Use SSL
        #[clap(short, long)]
        use_ssl: Option<bool>,
    },
    /// Update Consumer
    ConsumerUpdate {
        version: f64,
        /// The application key to use when creating an analytic or service request. The account needs to have permissions to the applicaton or it will be denied.
        app_key: String,
        /// The queue to update
        queue_id: i64,
        /// The data mapping information in the format of AMQPRequest
        data_mapping: String,
        /// The client deviceID
        device_id: Option<String>,
        /// The logged in user ID
        account_id: Option<i64>,
        /// Use SSL
        #[clap(short, long)]
        use_ssl: Option<bool>,
    },
    /// Create Queue
    QueueCreate {
        version: f64,
        /// The application key unique to each application.
        app_key: String,
        /// The name of the queue to create
        name: String,
        /// The client deviceID
        device_id: Option<String>,
        /// The logged in user ID
        account_id: Option<i64>,
        /// The number of workers to generate 
        workers: Option<i32>,
        /// If provided the analytic processing will publsih to this queue instead of the default one for the provided list of tags
        analytic_tags: Option<String>,
        /// The hostname of the server the queue is hosted on
        hostname: Option<String>,
        /// The port of the server the queue is hosted on
        port: Option<i32>,
        /// The username to access the server that the queue is on
        username: Option<String>,
        /// The password to access the queue to connect to
        password: Option<String>,
        /// The virtual host defined on the server to queue
        virtual_host: Option<String>,
        /// Use SSL
        #[clap(short, long)]
        use_ssl: Option<bool>,
    },
    /// Delete Queue
    QueueDelete {
        version: f64,
        /// The id of the queue to find
        queue_id: i64,
        /// The client device ID
        device_id: Option<String>,
        /// The logged in user ID
        account_id: Option<i64>,
    },
    /// Get Queue
    QueueGet {
        version: f64,
        /// The client device ID
        device_id: Option<String>,
        /// The logged in user ID
        account_id: Option<i64>,
        /// The id of the queue to find
        queue_id: Option<i64>,
        /// The application key the queue was assigned to
        app_key: Option<String>,
        /// The name of the queue to find
        name: Option<String>,
        /// The hostname of the queue to find
        hostname: Option<String>,
        /// The virtual host of the queue to find
        virtual_host: Option<String>,
    },
    /// Publish Queue
    QueuePublish {
        version: f64,
        /// The payload to send to the queue
        message: String,
        /// The id of the queue to publish to
        queue_id: Option<i64>,
        /// The application key the queue was assigned to
        app_key: Option<String>,
        /// The name of the queue to publish to or the analytic tag to handle if the analytic param is true
        name: Option<String>,
        /// The hostname of the server the queue is hosted on
        hostname: Option<String>,
        /// The virtual host defined on the server to queue
        virtual_host: Option<String>,
    },
    /// Search Queue
    QueueSearch {
        version: f64,
        /// The id of the queue to find
        queue_id: Option<i64>,
        /// The client device ID
        device_id: Option<String>,
        /// The logged in user ID
        account_id: Option<i64>,
        /// The name of the queue to find
        name: Option<String>,
        /// Start of the index
        start: Option<i32>,
        /// Limit of the index
        limit: Option<i32>,
    },
    /// Update Queue
    QueueUpdate {
        version: f64,
        /// The id of the queue to update
        queue_id: i64,
        /// The client deviceID
        device_id: Option<String>,
        /// The logged in user ID
        account_id: Option<i64>,
        /// The application key unique to each application.
        app_key: Option<String>,
        /// The number of workers to generate
        workers: Option<i32>,
        /// If provided the analytic processing will publsih to this queue instead of the default one for the provided list of tags
        analytic_tags: Option<String>,
        /// The hostname of the server the queue is hosted on
        hostname: Option<String>,
        /// The port of the server the queue is hosted on
        port: Option<i32>,
        /// The username to access the server that the queue is on
        username: Option<String>,
        /// The password to access the queue to connect to
        password: Option<String>,
        /// The virtual host defined on the server to queue
        virtual_host: Option<String>,
        /// the SSL to use
        #[clap(short, long)]
        use_ssl: Option<bool>,
    },
    /// Search Accounts by Location
    AccountLocationSearch {
        version: f64,
        /// The device id (deviceId or accountId required)
        device_id: Option<String>,
        /// The account id of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// Deprecated - legacy query parameter
        q: Option<String>,
        /// An optional keyword to search on, will be ignore if empty (NOT implemented yet)
        keyword: Option<String>,
        /// The postal code to search on, either postalCode or the user's exact location is required
        postal_code: Option<String>,
        /// The latitude of the user, either postalCode or the user's exact location is required
        latitude: Option<f64>,
        /// The longitude of the user, either postalCode or the user's exact location is required
        longitude: Option<f64>,
        /// The application key
        app_key: Option<String>,
        /// The range to search on
        range: Option<f64>,
        /// Searches for user's that has updated their location since this date
        location_last_updated: Option<i64>,
        /// The preferred gender
        gender: Option<String>,
        /// The preferred min age
        min_age: Option<i32>,
        /// The preferred max age
        max_age: Option<i32>,
        /// The preferred companionship index
        companionship_index: Option<i32>,
        /// this is the start index of a query
        _i: Option<i32>,
        /// Start of the pagination
        start: Option<i32>,
        /// this is the limit index of a query
        _l: Option<i32>,
        /// Limit of the pagination
        limit: Option<i32>,
        /// Search mode to use for index searches (e.g. CLOUDINDEX, OPENSEARCH)
        search_mode: Option<String>,
        /// Sorting field for results (default: DISTANCE)
        sort_field: Option<String>,
        /// Whether to sort descending (default: false)
        #[clap(short, long)]
        descending: Option<bool>,
        /// Roles to filter on
        roles: Option<String>,
        /// Tags to filter on
        tags: Option<String>,
        /// The experience to filter on
        experience: Option<String>,
        /// The category ids to filter on (comma separated)
        category_ids: Option<String>,
        /// The audience ids to filter on (comma separated)
        audience_ids: Option<String>,
        /// Operator used to combine audience filters (default: AND)
        audience_operator: Option<String>,
        /// Whether to use the given lat & long to update the user's current location
        #[clap(long)]
        update_current_location: Option<bool>,
        /// Whether to use the given parameters to update the user's preferred settings
        #[clap(long)]
        update_preferred_settings: Option<bool>,
        /// Determines whether to always display user exact locations
        #[clap(long)]
        show_exact_locations: Option<bool>,
        /// Return connection of the accounts in the result to the passed in account if there exists any
        #[clap(long)]
        show_connection_to_searcher: Option<bool>,
        /// Return any results that have a minimum of the specified flag count (even ones that have met the flag threshold)
        flag_count_minimum: Option<i64>,
        /// Returns only verified users
        #[clap(short, long)]
        verified_user_only: Option<bool>,
        /// Returns only content admin users
        #[clap(short, long)]
        content_admin_only: Option<bool>,
    },
    /// Block Account
    BlockAccount {
        version: f64,
        /// The id of the account to be blocked/unblocked
        account_id_being_blocked: i64,
        /// The device id (deviceId or accountId required)
        device_id: Option<String>,
        /// The account id of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// Determines whether the account is blocked or unblocked
        #[clap(short, long)]
        block_flag_value: Option<bool>,
        /// Determines whether the account is removed from all other groups if blocked
        #[clap(short, long)]
        remove_from_groups_if_blocked: Option<bool>,
        /// The current latitude of the user
        latitude: Option<f64>,
        /// The current longitude of the user
        longitude: Option<f64>,
    },
    /// Create Account
    CreateAccount {
        version: f64,
        /// The access token to authenticate with (ex: username)
        username: String,
        /// The secret to authenticate with (ex: password)
        password: String,
        /// The full name of the user. If this parameter is NOT empty, the following parameters will be ignored: prefixName, firstName, middleName, lastName, and suffixName
        name: Option<String>,
        /// If the parameter 'name' is empty or not present, this field will be used to set the prefix of the user's name
        prefix_name: Option<String>,
        /// If the parameter 'name' is empty or not present, this field will be used to set the user's first name
        first_name: Option<String>,
        /// If the parameter 'name' is empty or not present, this field will be used to set the user's middle name
        middle_name: Option<String>,
        /// If the parameter 'name' is empty or not present, this field will be used to set the user's last name
        last_name: Option<String>,
        /// If the parameter 'name' is empty or not present, this field will be used to set the suffix of the user's name
        suffix_name: Option<String>,
        /// This field will be used to set the user's job title
        title: Option<String>,
        /// The unique id of the device making the request
        device_id: Option<String>,
        /// The type of device id (this is defined by the client), ie. MAC_ADDRESS, APPLE_UDID, etc
        device_id_type: Option<String>,
        /// The user's contact email address (NOT the username)
        email_address: Option<String>,
        /// The asset id to set the user's profile image
        asset_id: Option<i64>,
        /// The street address of the user's contact location
        street_address: Option<String>,
        /// The zipcode of the user's contact location
        zipcode: Option<String>,
        /// The gender of the user (AudienceGender)
        gender: Option<String>,
        /// The birthday date of the user in UTC milliseconds
        birthday: Option<i64>,
        /// The home phone number
        home_phone: Option<String>,
        /// The cellular phone number
        cell_phone: Option<String>,
        /// The cellular service provider
        cell_phone_carrier: Option<String>,
        /// The business phone number
        business_phone: Option<String>,
        /// The account role (default: MEMBER)
        role: Option<String>,
        /// Comma separated list of development platforms
        platforms: Option<String>,
        /// Search tags
        tags: Option<String>,
        /// About us information
        about_us: Option<String>,
        /// Game experience of the user
        game_experience: Option<String>,
        /// A list of category ids that represent interests and associations
        category_ids: Option<String>,
        /// The user's hometown
        hometown: Option<String>,
        /// The user's height
        height: Option<String>,
        /// The user's height in a numerical value that can be used for ordering/searching
        height_index: Option<i32>,
        /// The user's ethnicity
        ethnicity: Option<String>,
        /// The user's body type
        body_type: Option<String>,
        /// The user's marital status
        marital_status: Option<String>,
        /// The user's children status
        children: Option<String>,
        /// The user's religion
        religion: Option<String>,
        /// The user's education
        education: Option<String>,
        /// The user's education in a numerical value that can be used for ordering/searching
        education_index: Option<i32>,
        /// The user's smoke status
        smoke: Option<String>,
        /// The user's drink status
        drink: Option<String>,
        /// The user's companionship status
        companionship: Option<String>,
        /// The user's companionship index
        companionship_index: Option<i32>,
        /// The preferred minimum age in the account location search
        preferred_min_age: Option<i32>,
        /// The preferred maximum age in the account location search
        preferred_max_age: Option<i32>,
        /// The preferred minimum height in the account location search
        preferred_min_height: Option<i32>,
        /// The preferred maximum height in the account location search
        preferred_max_height: Option<i32>,
        /// The preferred gender in the account location search
        preferred_gender: Option<String>,
        /// The preferred education in the account location search
        preferred_education: Option<String>,
        /// The preferred education in a numerical value that can be used for ordering/searching
        preferred_education_index: Option<i32>,
        /// The preferred body type in the account location search
        preferred_body_type: Option<String>,
        /// The preferred ethnicity in the account location search
        preferred_ethnicity: Option<String>,
        /// The preferred location in the account location search
        preferred_location: Option<String>,
        /// The preferred location range in the account location search
        preferred_location_range: Option<f64>,
        /// The current latitude of the user
        latitude: Option<f64>,
        /// The current longitude of the user
        longitude: Option<f64>,
        /// Accepted Terms
        #[clap(long)]
        accepted_terms: Option<bool>,
        /// The inviteToken that the referrer used for this account to sign up
        invite_token: Option<String>,
        /// The accountId of the referrer (used if there is no inviteToken)
        referral_account_id: Option<i64>,
        /// Whether to send validation email
        #[clap(short, long)]
        send_validation: Option<bool>,
        /// Deprecated: use appKey
        game_type: Option<String>,
        /// The application key
        app_key: Option<String>,
        /// The application version
        app_version: Option<String>,
        /// Returns an AccountLoginResponse if \"AccountLoginResponse\" is passed in
        response_type: Option<String>,
        /// Comma separated list of audience ids to assign to the user
        audience_ids_to_add: Option<String>,
        /// Application blob data
        app_blob: Option<String>,
        /// Enable push for the app
        #[clap(long)]
        app_enable_push: Option<bool>,
        /// Enable SMS for the app
        #[clap(long)]
        app_enable_sms: Option<bool>,
        /// Enable email for the app
        #[clap(long)]
        app_enable_email: Option<bool>,
        /// Location visibility setting
        location_visibility: Option<String>,
        /// Home latitude
        home_latitude: Option<f64>,
        /// Home longitude
        home_longitude: Option<f64>,
        /// The nickname used in the application for this account
        app_nickname: Option<String>,
        /// Personal audience id to associate with this account
        personal_audience_id: Option<i64>,
    },
    /// Update Account
    EditAccount {
        version: f64,
        /// The device id (deviceId or accountId required)
        device_id: Option<String>,
        /// The account id of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// The account id used to edit another person's account
        connection_account_id: Option<i64>,
        /// The account role to change to
        role: Option<String>,
        /// The asset id to set the user's profile image
        asset_id: Option<i64>,
        /// The full name of the user. If this parameter is NOT empty, the  following parameters will be ignored: prefixName, firstName, middleName,  lastName, and suffixName 
        name: Option<String>,
        /// If the parameter 'name' is empty or not present, this field will be used to set the prefix of the user's name
        prefix_name: Option<String>,
        /// If the parameter 'name' is empty or not present, this field will be used to set the user's first name
        first_name: Option<String>,
        /// If the parameter 'name' is empty or not present, this field will be used to set the user's middle name
        middle_name: Option<String>,
        /// If the parameter 'name' is empty or not present, this field will be used to set the user's last name
        last_name: Option<String>,
        /// If the parameter 'name' is empty or not present, this field will be used to set the suffix of the user's name
        suffix_name: Option<String>,
        /// This field will be used to set the user's job title
        title: Option<String>,
        /// The gender of the user AudienceGender
        gender: Option<String>,
        /// This is deperecated, use the birthday parameter
        age: Option<i32>,
        /// The birthday date of the user in UTC milliseconds
        birthday: Option<i64>,
        /// The home phone number
        home_phone: Option<String>,
        /// The cellular phone number
        cell_phone: Option<String>,
        /// The cellular service provider
        cell_phone_carrier: Option<String>,
        /// The business phone number
        business_phone: Option<String>,
        /// The user's contact email address (NOT the username)
        email_address: Option<String>,
        /// The street address of the user's contact location
        street_address: Option<String>,
        /// Additional address information (such as a suite number, floor number, building name, or PO Box)
        street_address2: Option<String>,
        /// The city of the user's contact location
        city: Option<String>,
        /// The state of the user's contact location
        state: Option<String>,
        /// The zipcode of the user's contact location
        zipcode: Option<String>,
        /// The country of the user's contact location
        country: Option<String>,
        /// Allow anyone to view the user's personal profile
        #[clap(long)]
        make_profile_info_public: Option<bool>,
        /// Allow anyone to view the user's game/app info
        #[clap(long)]
        make_game_info_public: Option<bool>,
        /// Allow anyone to view the user's friends list
        #[clap(long)]
        make_friends_info_public: Option<bool>,
        /// The user's hometown
        hometown: Option<String>,
        /// The user's height
        height: Option<String>,
        /// The user's height in a numerical value that can be used for ordering/searching
        height_index: Option<i32>,
        /// The user's ethnicity
        ethnicity: Option<String>,
        /// The user's body type
        body_type: Option<String>,
        /// The user's marital status
        marital_status: Option<String>,
        /// The user's children status
        children: Option<String>,
        /// The user's religion
        religion: Option<String>,
        /// The user's education
        education: Option<String>,
        /// The user's education in a numerical value that can be used for ordering/searching
        education_index: Option<i32>,
        /// The user's smoke status
        smoke: Option<String>,
        /// The user's drink status
        drink: Option<String>,
        /// The user's companionship status
        companionship: Option<String>,
        /// The user's companionship index
        companionship_index: Option<i32>,
        /// The preferred minimum age in the account location search
        preferred_min_age: Option<i32>,
        /// The preferred maximum age in the account location search
        preferred_max_age: Option<i32>,
        /// The preferred minimum height in the account location search
        preferred_min_height: Option<i32>,
        /// The preferred maximum height in the account location search
        preferred_max_height: Option<i32>,
        /// The preferred gender in the account location search
        preferred_gender: Option<String>,
        /// The preferred education in the account location search
        preferred_education: Option<String>,
        /// The preferred education in a numerical value that can be used for ordering/searching
        preferred_education_index: Option<i32>,
        /// The preferred body type in the account location search
        preferred_body_type: Option<String>,
        /// The preferred ethnicity in the account location search
        preferred_ethnicity: Option<String>,
        /// The preferred education in the account location search
        preferred_location: Option<String>,
        /// The preferred location range in the account location search
        preferred_location_range: Option<f64>,
        /// Platforms
        platforms: Option<String>,
        /// Tags
        tags: Option<String>,
        /// About Us
        about_us: Option<String>,
        /// Match Token
        match_token: Option<String>,
        /// Game Experience
        game_experience: Option<String>,
        /// Deprecated use categoryIds
        categories: Option<String>,
        /// A list of category ids that represent interests and associations
        category_ids: Option<String>,
        /// A comma separated list of ProfileFilters for filtering the returned response data
        response_filters: Option<String>,
        /// The user's preference if they want to be shown by zipcode on a map
        #[clap(long)]
        show_as_zipcode: Option<bool>,
        /// The user's preference if they want to be shown by their exact location on a map
        #[clap(long)]
        show_exact_location: Option<bool>,
        /// The user's preference if they want to see others exact location on a map
        #[clap(long)]
        show_others_exact_location: Option<bool>,
        /// Accepted Terms
        #[clap(long)]
        accepted_terms: Option<bool>,
        /// Location Visibility
        location_visibility: Option<String>,
        /// App Blob
        app_blob: Option<String>,
        /// App Enable Push
        #[clap(long)]
        app_enable_push: Option<bool>,
        /// App Enable SMS
        #[clap(long)]
        app_enable_sms: Option<bool>,
        /// App Enable Email
        #[clap(long)]
        app_enable_email: Option<bool>,
        /// Game Type
        game_type: Option<String>,
        /// The application key
        app_key: Option<String>,
        /// The current latitude of the user
        latitude: Option<f64>,
        /// The current longitude of the user
        longitude: Option<f64>,
        /// Return Profile
        #[clap(short, long)]
        return_profile: Option<bool>,
        /// Audience Ids to add
        audience_ids_to_add: Option<String>,
        /// Audience Ids to remove
        audience_ids_to_remove: Option<String>,
        /// The account id of the referrer
        referral_account_id: Option<i64>,
        /// App nickname
        app_nickname: Option<String>,
        /// Personal Audience
        personal_audience_id: Option<i64>,
        /// The user's username to update with if they currently have a guest username
        non_guest_username: Option<String>,
    },
    /// Update Username and Email
    EditUsername {
        version: f64,
        /// The device id
        device_id: Option<String>,
        /// The account id of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// the user's contact email address (NOT the username) which is also used for email validation
        email_address: Option<String>,
        /// the user's username to update with if they currently have a guest username
        username: Option<String>,
    },
    /// Get Account
    GetAccount {
        version: f64,
        /// Return Nulls
        #[clap(short, long)]
        return_nulls: Option<bool>,
        /// The device id (deviceId or accountId required)
        device_id: Option<String>,
        /// The account id of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// Connection Account Email
        connection_account_email: Option<String>,
        /// The account id used to view another person's account
        connection_account_id: Option<i64>,
        /// A comma separated list of ProfileFilters for filtering the returned response data
        response_filters: Option<String>,
        /// Game Type
        game_type: Option<String>,
        /// The application key
        app_key: Option<String>,
        /// Purchase Type
        purchase_type: Option<String>,
        /// Determines whether to track if a person has viewed someone's profile
        #[clap(short, long)]
        update_viewed_date: Option<bool>,
        /// Latitude used to update the user's current location
        latitude: Option<f64>,
        /// Longitude used to update the user's current location
        longitude: Option<f64>,
    },
    /// Get Profile Assets
    GetProfileAssets {
        version: f64,
        /// Determines whether to return null fields in the response
        #[clap(short, long)]
        return_nulls: Option<bool>,
        /// The device id (deviceId or accountId required)
        device_id: Option<String>,
        /// The account id of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// The account id of the person the user wants to view
        owner_id: Option<i64>,
        /// Comma separated list of MediaType
        media_types: Option<String>,
        /// Comma separated list of mime types
        mime_types: Option<String>,
        /// Determines what the returning list will be sorted by (see AssetApiMap)
        sort_field: Option<String>,
        /// Determines whether to return the resulting list in descending or ascending order
        #[clap(short, long)]
        descending: Option<bool>,
        /// Latitude used to update the user's current location
        latitude: Option<f64>,
        /// Longitude used to update the user's current location
        longitude: Option<f64>,
        /// _i
        _i: Option<i32>,
        /// Start of the pagination
        start: Option<i32>,
        /// _l
        _l: Option<i32>,
        /// Limit of the pagination
        limit: Option<i32>,
    },
    /// Search Accounts
    GetReferralList {
        version: f64,
        /// The account id of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// The application key
        app_key: Option<String>,
        /// one of these option - GET_CHILDREN will get all accounts that had signed up using the current account invite link - GET_ANCESTOR will get all accounts that referred the current account and it's parents, recursively - GET_ALL will get all of the above
        retrieve_type: Option<String>,
        /// level limit for children and ancestors of current account, starts from current account
        level_limit: Option<f64>,
        /// level limit for ancestors, will override levelLimit if this is set
        ancestor_level_limit: Option<f64>,
        /// level limit for children, will override levelLimit if this is set
        children_level_limit: Option<f64>,
        /// pagination start for children list
        ancestor_list_start: Option<f64>,
        /// pagination limit for children list
        ancestor_list_limit: Option<f64>,
        /// pagination start for children list
        children_list_start: Option<f64>,
        /// pagination limit for children list
        children_list_limit: Option<f64>,
        /// if true, on each item in ancestor and children list, return the childrenTotalNumber and ancestorTotalNumber for that item
        #[clap(short, long)]
        children_children: Option<bool>,
    },
    /// Get Account Settings
    GetSettings {
        version: f64,
        /// The device id (deviceId or accountId required)
        device_id: Option<String>,
        /// The account id of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// The current latitude of the user
        latitude: Option<f64>,
        /// The current longitude of the user
        longitude: Option<f64>,
    },
    /// Login as Account
    LoginDelegate {
        version: f64,
        access_token: String,
        app_key: String,
        device_id: Option<String>,
        access_token_secret: Option<String>,
        delegated_account_id: Option<i64>,
        delegated_username: Option<String>,
        /// The access provider to authenticate against (default: USERNAME). Supported values: FACEBOOK, TWITTER, USERNAME, PHONE
        network_uid: Option<String>,
        /// Checks user's birthday to see if they meet an age requirement. If the user is under age, an error message is returned.
        age_restriction: Option<i32>,
        /// This determines how much of the profile should be returned, see ProfileFilters
        response_filters: Option<String>,
        latitude: Option<f64>,
        longitude: Option<f64>,
    },
    /// Login Account
    LoginGeneral {
        version: f64,
        /// The access token to authenticate with (ex: username or fb token)
        access_token: String,
        /// The access provider to authenticate against. This can be custom  networks created using the ThirdPartyApi as well. Supported values by default  include: FACEBOOK, TWITTER, USERNAME, PHONE 
        network_uid: String,
        /// The application key
        app_key: String,
        /// The unique id of the device making the request
        device_id: Option<String>,
        /// The type of device id (this is defined by the client), ie. MAC_ADDRESS, APPLE_UDID, etc
        device_id_type: Option<String>,
        /// The secret to authenticate with (ex: password)
        access_token_secret: Option<String>,
        /// Checks user's birthday to see if they meet an age requirement. If the user is under age, an error message is returned.
        age_restriction: Option<i32>,
        /// This determines how much of the profile should be returned, see ProfileFilters
        response_filters: Option<String>,
        /// Used to update the user's current location
        latitude: Option<f64>,
        /// Used to update the user's current location
        longitude: Option<f64>,
        /// Option to check for email if username doesn't match, also support multiple accounts
        #[clap(short, long)]
        email_match: Option<bool>,
        /// Chosen account Id sent from the app - pass in the 2nd request to choose an account from multiple accounts matching the email - use one of the account id from the previous request
        chosen_account_id: Option<i64>,
        /// Third-party credential Id, pass in the 2nd request to choose an account from multiple accounts matching the email - use the id from the previous call ThirdPartyCredential object
        third_party_credential_id: Option<i64>,
    },
    /// Login Account (Username)
    LoginUsername {
        version: f64,
        /// the user's email address they used to sign-up
        username: String,
        /// the password
        password: String,
        /// the device id
        device_id: Option<String>,
        /// the current latitude of the user
        latitude: Option<f64>,
        /// the current longitude of the user
        longitude: Option<f64>,
        /// the app
        app: Option<String>,
        /// This parameter is deprecated. This is deprecated, use appKey.
        game_type: Option<String>,
        /// the application key
        app_key: Option<String>,
        /// the profile to return
        #[clap(short, long)]
        return_profile: Option<bool>,
        /// a comma separated list of ProfileFilters for filtering the returned response data
        response_filters: Option<String>,
    },
    /// Logout Account
    Logout {
        version: f64,
        /// The device id (deviceId or accountId required)
        device_id: Option<String>,
        /// Device Id Type
        device_id_type: Option<String>,
        /// The account id of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// The current latitude of the user
        latitude: Option<f64>,
        /// The current longitude of the user
        longitude: Option<f64>,
    },
    /// Merge Account
    MergeAccount {
        version: f64,
        /// The id of the account to being merged
        merge_account_id: i64,
        /// The application key
        app_key: String,
        /// The device id (deviceId or accountId required)
        device_id: Option<String>,
        /// The account id of the user (deviceId or accountId required)
        account_id: Option<i64>,
    },
    /// Update Password
    PasswordChange {
        version: f64,
        /// The account to update
        account_id: i64,
        /// The current password, used to validate access
        old_password: String,
        /// The new password to set, cannot be empty
        new_password: String,
        /// The new password to confirm, must match newPassword
        confirm_password: String,
    },
    /// Reset Password
    PasswordReset {
        version: f64,
        /// The token associated with the account to update, good for 24 hours
        token: String,
        /// The new password to set, cannot be empty
        password: String,
        /// The new password to confirm, must match newPassword
        confirm: String,
    },
    /// Request Password Reset
    RequestPasswordReset {
        version: f64,
        /// The email/username of the account
        email: String,
        /// this is the sender email
        from: Option<String>,
        /// this is the domain (like dev.sirqul.com) used to generate the password reset link
        domain: Option<String>,
        /// this is the the subUrl (like resetpassword) used to generate a password reset link
        sub_url: Option<String>,
        /// this is used to generate a password reset link
        referer: Option<String>,
    },
    /// Send Validation Request
    RequestValidateAccount {
        version: f64,
        /// The account id of the user
        account_id: i64,
    },
    /// Search Accounts
    SearchAccounts {
        version: f64,
        /// The id of the account requesting
        account_id: i64,
        /// The application key
        app_key: String,
        /// The keyword for for querying the account
        keyword: Option<String>,
        /// the latitude
        latitude: Option<f64>,
        /// the longitude
        longitude: Option<f64>,
        /// the radius
        radius: Option<f64>,
        /// the user's gender
        #[clap(value_parser = parse_json::<models::SearchAccountsGenderParameter>)]
        gender: Option<models::SearchAccountsGenderParameter>,
        /// the user's Game Experience
        #[clap(value_parser = parse_json::<models::SearchAccountsGameExperienceParameter>)]
        game_experience: Option<models::SearchAccountsGameExperienceParameter>,
        /// the user's age
        age: Option<i32>,
        /// the user's Category Ids
        category_ids: Option<String>,
        /// Return Nulls
        #[clap(short, long)]
        return_nulls: Option<bool>,
        /// A comma separated list of ProfileFilters for filtering the returned response data
        response_filters: Option<String>,
        /// A comma separated list of PurchaseType
        purchase_type: Option<String>,
        /// The field to sort by
        sort_field: Option<String>,
        /// The order to return the results. Default is false, which will return the results in ascending order.
        #[clap(short, long)]
        descending: Option<bool>,
        /// The index into the record set to start with.
        start: Option<i32>,
        /// The total number of record to return.
        limit: Option<i32>,
        /// Determines whether to return only active results. Default is false.
        #[clap(long)]
        active_only: Option<bool>,
    },
    /// Login Account (Encrypted Username)
    SecureLogin {
        version: f64,
        /// The user's encrypted email address they used to sign-up
        username: String,
        /// The encrypted password
        password: String,
        /// The application key
        game_type: String,
        /// The device id
        device_id: Option<String>,
        /// Charset Name
        charset_name: Option<String>,
        /// The current latitude of the user
        latitude: Option<f64>,
        /// The current longitude of the user
        longitude: Option<f64>,
        /// Return Profile
        #[clap(short, long)]
        return_profile: Option<bool>,
        /// A comma separated list of ProfileFilters for filtering the returned response data
        response_filters: Option<String>,
    },
    /// Create Account (Encrypted Username)
    SecureSignup {
        version: f64,
        /// The device id
        device_id: String,
        /// The encrypted email of the user, this is what will be used when they login
        username: String,
        /// The encrypted password of the user
        password: String,
        /// The full name of the user. If this parameter is not empty, the  following parameters will be ignored: prefixName, firstName, middleName,  lastName, and suffixName 
        name: Option<String>,
        /// the inviteToken that the referrer use for this account to sign up
        invite_token: Option<String>,
        /// If the parameter 'name' is empty or not present, this field will be used to set the prefix of the user's name
        prefix_name: Option<String>,
        /// If the parameter 'name' is empty or not present, this field will be used to set the user's first name
        first_name: Option<String>,
        /// If the parameter 'name' is empty or not present, this field will be used to set the user's middle name
        middle_name: Option<String>,
        /// If the parameter 'name' is empty or not present, this field will be used to set the user's last name
        last_name: Option<String>,
        /// If the parameter 'name' is empty or not present, this field will be used to set the suffix of the user's name
        suffix_name: Option<String>,
        /// Title
        title: Option<String>,
        /// Device Id Type
        device_id_type: Option<String>,
        /// The user's contact email address (NOT the username) which is also used for email validation
        email_address: Option<String>,
        /// The asset id to set the user's profile image
        asset_id: Option<i64>,
        /// the user's address
        address: Option<String>,
        /// The street zipcode of the user's contact location
        zipcode: Option<String>,
        /// The gender of the user AudienceGender
        gender: Option<String>,
        /// The birthday date of the user in milliseconds
        birthday: Option<i64>,
        /// the user's home phone number
        home_phone: Option<String>,
        /// the user's cell phone number
        cell_phone: Option<String>,
        /// the user's Cell Phone Carrier
        cell_phone_carrier: Option<String>,
        /// the user's Business Phone Number
        business_phone: Option<String>,
        /// The type of account being created {RETAILER, MEMBER, DEVELOPER, GUEST
        role: Option<String>,
        /// Comma separated list of development platforms: MAC, WINDOWS, IOS, ANDROID, WINDOWSPHONE, KINDLE, UNITY3D, COCOS2D, HTML5, FACEBOOK
        platforms: Option<String>,
        /// Search tags
        tags: Option<String>,
        /// About Us information
        about_us: Option<String>,
        /// Game experience level of the user {ANY, NEW, BEGINNER, INTERMEDIATE, EXPERT
        game_experience: Option<String>,
        /// A list of category ids that represent interests and associations
        category_ids: Option<String>,
        /// The user's hometown
        hometown: Option<String>,
        /// The user's height
        height: Option<String>,
        /// The user's height in a numerical value that can be used for ordering/searching
        height_index: Option<i32>,
        /// The user's ethnicity
        ethnicity: Option<String>,
        /// The user's body type
        body_type: Option<String>,
        /// The user's maritial status
        marital_status: Option<String>,
        /// The user's children status
        children: Option<String>,
        /// The user's religion
        religion: Option<String>,
        /// The user's education
        education: Option<String>,
        /// The user's education in a numerical value that can be used for ordering/searching
        education_index: Option<i32>,
        /// The user's smoke status
        smoke: Option<String>,
        /// The user's drink status
        drink: Option<String>,
        /// The user's companionship status
        companionship: Option<String>,
        /// The user's companionship index
        companionship_index: Option<i32>,
        /// The preferred minimum age in the account location search
        preferred_min_age: Option<i32>,
        /// The preferred maximum age in the account location search
        preferred_max_age: Option<i32>,
        /// The preferred minimum height in the account location search
        preferred_min_height: Option<i32>,
        /// The preferred maximum height in the account location search
        preferred_max_height: Option<i32>,
        /// The preferred gender in the account location search
        preferred_gender: Option<String>,
        /// The preferred education in the account location search
        preferred_education: Option<String>,
        /// The preferred education in a numerical value that can be used for ordering/searching
        preferred_education_index: Option<i32>,
        /// The preferred body type in the account location search
        preferred_body_type: Option<String>,
        /// The preferred ethnicity in the account location search
        preferred_ethnicity: Option<String>,
        /// The preferred education in the account location search
        preferred_location: Option<String>,
        /// The preferred location range in the account location search
        preferred_location_range: Option<f64>,
        /// The current latitude of the user
        latitude: Option<f64>,
        /// The current longitude of the user
        longitude: Option<f64>,
        /// Accepted Terms
        #[clap(long)]
        accepted_terms: Option<bool>,
        /// Charset Name
        charset_name: Option<String>,
        /// Game Type
        game_type: Option<String>,
        /// The application key
        app_key: Option<String>,
        /// App Version
        app_version: Option<String>,
        /// Response Type
        response_type: Option<String>,
    },
    /// Save Match Token
    SetMatchToken {
        version: f64,
        /// The device id (deviceId or accountId required)
        device_id: Option<String>,
        /// The account id of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// A string of numbers
        match_token: Option<String>,
        /// Game Type (deprecated)
        game_type: Option<String>,
        /// The application key
        app_key: Option<String>,
        /// The current latitude of the user
        latitude: Option<f64>,
        /// The current longitude of the user
        longitude: Option<f64>,
    },
    /// Update Account Active Status
    UpdateActveStatus {
        version: f64,
        /// the account id of the user (deviceId or accountId required)
        account_id: i64,
        /// The account id of the user you want to modify (if this is not set, then the accountId parameter will be used instead)
        connection_account_id: i64,
        /// true will activate the user and false will deactivate
        #[clap(long)]
        active: bool,
        /// the device id (deviceId or accountId required)
        device_id: Option<String>,
        /// the application key that the user belongs to
        app_key: Option<String>,
    },
    /// Update Location
    UpdateLocation {
        version: f64,
        /// The device id (deviceId or accountId required)
        device_id: Option<String>,
        /// The account id of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// The current latitude of the user
        latitude: Option<f64>,
        /// The current longitude of the user
        longitude: Option<f64>,
        /// The time of the update
        client_time: Option<i64>,
    },
    /// Update Account Settings
    UpdateSettings {
        version: f64,
        /// The device id (deviceId or accountId required)
        device_id: Option<String>,
        /// The account id of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// The notifications to be blocked
        blocked_notifications: Option<String>,
        /// How suggestions are to be sent (APNS, MOBILE_NOTIFICATION, SMS)
        suggestion_method: Option<String>,
        /// How many suggestions to receive per time frame
        suggestion_count: Option<i32>,
        /// The time frame in seconds, 3600 would be a 1 hour time frame
        suggestion_time_frame: Option<i32>,
        /// Show Others Exact Location
        #[clap(long)]
        show_others_exact_location: Option<bool>,
        /// Show As Zipcode
        #[clap(long)]
        show_as_zipcode: Option<bool>,
        /// Show Exact Location
        #[clap(long)]
        show_exact_location: Option<bool>,
        /// Show favorites
        favorite_visibility: Option<String>,
        /// The current latitude of the user
        latitude: Option<f64>,
        /// The current longitude of the user
        longitude: Option<f64>,
    },
    /// Save Validation Status
    ValidateAccountSignup {
        version: f64,
        /// The token associated with the account to update, good for 24 hours
        token: String,
    },
    /// Validate Password Reset Token
    ValidatePasswordReset {
        version: f64,
        /// The token associated with the account to update, good for 24 hours
        token: String,
    },
    /// Searches an Achievement Tier
    ApiVersionAchievementTierSearchPost {
        version: f64,
        /// a unique id given by the device (deviceId or accountId required)
        device_id: Option<String>,
        /// the account id of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// the application key
        app_key: Option<String>,
        /// the keyword used to filter resutls with (this returns results that have the keyword in the title or the description of the achievement tier)
        keyword: Option<String>,
        /// filter results by achievementType (these are exact case sensitive matches)
        achievement_type: Option<i64>,
        /// filter results by the rankType (these are the exact case sensitive matches)
        rank_type: Option<String>,
        /// the field to sort by. See {@link AchievementApiMap}
        sort_field: Option<String>,
        /// determines whether the sort list is in descending or ascending order (of the achievement)
        #[clap(long)]
        descending: Option<bool>,
        /// determines whether the results are in descending or ascending order by the tier goal count (after the initial sort on the achievement)
        #[clap(long)]
        descending_goal: Option<bool>,
        /// The start of the index for pagination
        start: Option<i64>,
        /// the limit for pagination (has a hard limit of 1000)
        limit: Option<i64>,
    },
    /// Create Achievement
    CreateAchievement {
        version: f64,
        /// the application key the achievement is for
        app_key: String,
        /// the title of the achievement (255 character limit)
        title: String,
        /// a unique id given by the device (deviceId or accountId required)
        device_id: Option<String>,
        /// the account id of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// the analytics tag that will trigger when a user's achievement count gets updated
        analytics_tag: Option<String>,
        /// the description of the achievement
        description: Option<String>,
        /// the rank type for updating leader boards
        rank_type: Option<String>,
        /// determines how much the rank count is incremented
        rank_increment: Option<i32>,
        /// restrict scores to be above or equal to this minimum value
        min_increment: Option<i32>,
        /// restrict scores to be below or equal to this maximum value
        max_increment: Option<i32>,
        /// determines whether the customId on analytics are used to validate a user's achievement progress.
        #[clap(short, long)]
        validate: Option<bool>,
        /// achievement is active or inactive
        #[clap(long)]
        active: Option<bool>,
        /// if provided will define what triggers to run after a tier is completed
        trigger_definition: Option<String>,
    },
    /// Create Achievement Tier
    CreateAchievementTier {
        version: f64,
        /// the achievement id for adding a new tier
        achievement_id: i64,
        /// score all instances
        #[clap(short, long)]
        score_all_instances: bool,
        /// a unique id given by the device (deviceId or accountId required)
        device_id: Option<String>,
        /// the account id of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// achievement tier icon image file
        #[clap(value_parser = parse_json::<swagger::ByteArray>)]
        icon: Option<swagger::ByteArray>,
        /// the icon assetId, if icon is provided, icon will overrule
        icon_asset_id: Option<i64>,
        /// the title of the achievement tier
        title: Option<String>,
        /// the description of the achievement tier
        description: Option<String>,
        /// the count requirement for completing the achievement tier
        goal_count: Option<i64>,
        /// The ID of the mission to associate with the achievement
        mission_id: Option<i64>,
        /// The ID of the game to associate with the achievement
        game_id: Option<i64>,
        /// The ID of the pack to associate with the achievement
        pack_id: Option<i64>,
        /// The ID of the game level to associate with the achievement
        game_level_id: Option<i64>,
        /// The ID of the game object to associate with the achievement
        game_object_id: Option<i32>,
    },
    /// Delete Achievement
    DeleteAchievement {
        version: f64,
        /// The ID of the achievement
        achievement_id: i64,
        /// the account id of the user (deviceId or accountId required)
        account_id: Option<i64>,
    },
    /// Delete Achievement Tier
    DeleteAchievementTier {
        version: f64,
        /// the achievement id for deletion
        achievement_tier_id: i64,
        /// the account id of the user (deviceId or accountId required).
        account_id: Option<i64>,
    },
    /// Get Achievement
    GetAchievement {
        version: f64,
        /// The ID of the achievement
        achievement_id: i64,
        /// a unique id given by the device (deviceId or accountId required)
        device_id: Option<String>,
        /// the account id of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// achievementType
        achievement_type: Option<String>,
    },
    /// Gets an achievement tier
    GetAchievementTier {
        version: f64,
        /// the account id of the user (deviceId or accountId required)
        account_id: i64,
        /// the achievement tier id that is being retrieved
        achievement_tier_id: i64,
    },
    /// Get Achievement Progress
    GetUserAchievements {
        version: f64,
        /// determines whether to return null fields in the response
        #[clap(short, long)]
        return_nulls: bool,
        /// the application key for filtering results by application
        app_key: String,
        /// determines whether to return achievements that the user has not discovered yet
        #[clap(short, long)]
        include_undiscovered: bool,
        /// a unique id given by the device (deviceId or accountId required)
        device_id: Option<String>,
        /// the account id of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// the email of the account to view achievements
        connection_account_email: Option<String>,
        /// the id of the account to view achievements
        connection_account_id: Option<i64>,
        /// filter results by achievement rankType
        rank_type: Option<String>,
        /// filter results by achievement type
        achievement_type: Option<String>,
        /// the current latitude of the user
        latitude: Option<f64>,
        /// the current longitude of the user
        longitude: Option<f64>,
    },
    /// List Achievement Tags
    ListAchievementTags {
        version: f64,
        /// filter results by application key
        app_key: Option<String>,
    },
    /// List Achievements
    ListAchievements {
        version: f64,
        /// the field to sort by. See AchievementApiMap
        #[clap(value_parser = parse_json::<models::ListAchievementsSortFieldParameter>)]
        sort_field: models::ListAchievementsSortFieldParameter,
        /// determines whether the sorted list is in descending or ascending order
        #[clap(short, long)]
        descending: bool,
        /// the start index for pagination
        start: i32,
        /// the limit for pagination (has a hard limit of 1000)
        limit: i32,
        /// Filter results to only return active achievements
        #[clap(long)]
        active_only: bool,
        /// a unique id given by the device (deviceId or accountId required)
        device_id: Option<String>,
        /// the account id of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// the application key
        app_key: Option<String>,
        /// the keyword used to filter results with (this returns results that have the keyword in the title or description of the achievement)
        keyword: Option<String>,
        /// filter results by the achievementType (these are exact case sensitive matches)
        achievement_type: Option<String>,
        /// filter results by the rankType (these are exact case sensitive matches)
        rank_type: Option<String>,
    },
    /// Search Achievements
    SearchAchievements {
        version: f64,
        /// the application key
        app_key: String,
        /// the field to sort by. See AchievementApiMap
        #[clap(value_parser = parse_json::<models::SearchAchievementsSortFieldParameter>)]
        sort_field: models::SearchAchievementsSortFieldParameter,
        /// determines whether the sorted list is in descending or ascending order
        #[clap(short, long)]
        descending: bool,
        /// return tiers, only applicable for version >3.18
        #[clap(long)]
        include_tiers: bool,
        /// return inactive tiers, only applicable when includeTiers is true, only applicable for version >3.18
        #[clap(long)]
        include_inactive_tiers: bool,
        /// the start index for pagination
        start: i32,
        /// the limit for pagination (has a hard limit of 1000)
        limit: i32,
        /// a unique id given by the device (deviceId or accountId required)
        device_id: Option<String>,
        /// the account id of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// the keyword used to filter results with (this returns results that have the keyword in the title or description of the achievement)
        keyword: Option<String>,
        /// filter results by the achievementType (these are exact case sensitive matches)
        achievement_type: Option<String>,
        /// filter results by the rankType (these are exact case sensitive matches)
        rank_type: Option<String>,
    },
    /// Update Achievement
    UpdateAchievement {
        version: f64,
        /// a unique id given by the device (deviceId or accountId required)
        device_id: Option<String>,
        /// the account id of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// the achievement ID for updating an existing achievement
        achievement_id: Option<i64>,
        /// the analytics tag that will trigger when a user's achievement count gets updated
        analytics_tag: Option<String>,
        /// the title of the achievement (255 character limit)
        title: Option<String>,
        /// the description of the achievement
        description: Option<String>,
        /// the rank type for updating leader boards
        rank_type: Option<String>,
        /// determines how much the rank count is incremented
        rank_increment: Option<i32>,
        /// restrict scores to be above or equal to this minimum value
        min_increment: Option<i32>,
        /// enable to ignore usage of minIncrement
        #[clap(long)]
        null_min_increment: Option<bool>,
        /// restrict scores to be below or equal to this maximum value
        max_increment: Option<i32>,
        /// enable to ignore usage of maxIncrement
        #[clap(long)]
        null_max_increment: Option<bool>,
        /// determines whether the customId on analytics are used to validate a user's achievement progress.
        #[clap(short, long)]
        validate: Option<bool>,
        /// if it's active or inactive
        #[clap(long)]
        active: Option<bool>,
        /// if provided will define what triggers to run after a tier is completed
        trigger_definition: Option<String>,
    },
    /// Update Achievement Tier
    UpdateAchievementTier {
        version: f64,
        /// the achievement tier id for updating
        achievement_tier_id: i64,
        /// a unique id given by the device (deviceId or accountId required)
        device_id: Option<String>,
        /// the account id of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// achievement tier icon image file
        #[clap(value_parser = parse_json::<swagger::ByteArray>)]
        icon: Option<swagger::ByteArray>,
        /// the icon assetId, if icon is provided, icon will overrule
        icon_asset_id: Option<i64>,
        /// the title of the achievement tier
        title: Option<String>,
        /// the description of the achievement tier
        description: Option<String>,
        /// the count requirement for completing the achievement tier
        goal_count: Option<i64>,
        /// The ID of the mission to associate with the achievement
        mission_id: Option<i64>,
        /// The ID of the game to associate with the achievement
        game_id: Option<i64>,
        /// The ID of the pack to associate with the achievement
        pack_id: Option<i64>,
        /// The ID of the game level to associate with the achievement
        game_level_id: Option<i64>,
        /// The ID of the game object to associate with the achievement
        game_object_id: Option<i64>,
        /// score all instances
        #[clap(short, long)]
        score_all_instances: Option<bool>,
    },
    /// Update Achievement Progress
    UpdateUserAchievement {
        version: f64,
        /// the account id of the user
        account_id: i64,
        /// the achievement id (achievementId or tag required)
        achievement_id: Option<i64>,
        /// the analytic tag to identify an achievement (achievementId or tag required)
        tag: Option<String>,
        /// a custom identifier used for validation
        custom_id: Option<i64>,
        /// the amount to increment an achievement progress by (if no increment is sent in, the server defaults to using the achievement's rankIncrement value)
        increment: Option<i64>,
        /// a custom start date that the client can set (not yet used in server logic)
        start_date: Option<i64>,
        /// a custom end date that the client can set (not yet used in server logic)
        end_date: Option<i64>,
        /// determines whether to return the achievement progress response
        #[clap(short, long)]
        return_progress: Option<bool>,
    },
    /// Create an entity reference.
    CreateEntityReference {
        version: f64,
        /// The entity reference object
        #[clap(value_parser = parse_json::<models::EntityReference>)]
        body: models::EntityReference,
    },
    /// Create Album
    AddAlbumCollection {
        version: f64,
        /// the title of the album
        title: String,
        /// determines whether the cover image of the album can be empty, else will use the user's profile picture as the cover image
        #[clap(short, long)]
        cover_asset_nullable: bool,
        /// determines whether the cover image should be added to the album asset list
        #[clap(long)]
        include_cover_in_asset_list: bool,
        /// determines whether the album's participants has read permissions
        #[clap(long)]
        public_read: bool,
        /// determines whether the album's participants has write permissions
        #[clap(long)]
        public_write: bool,
        /// determines whether the album's participants has delete permissions
        #[clap(long)]
        public_delete: bool,
        /// determines whether the album's participants has add permissions
        #[clap(long)]
        public_add: bool,
        /// determines whether the album is posted anonymously
        #[clap(long)]
        anonymous: bool,
        /// a unique ID given by the device (deviceId or accountId required)
        device_id: Option<String>,
        /// the account ID of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// Comma separated list of asset IDs to add to the album's asset list (use \"assetId\" for setting the cover of the album)
        assets_to_add: Option<String>,
        /// a MultipartFile containing the cover image of the album (this will only be used if \"assetId\" is empty)
        #[clap(value_parser = parse_json::<swagger::ByteArray>)]
        media: Option<swagger::ByteArray>,
        /// this can be used if the \"media\" is a link (this will only be used if \"assetId\" and media are empty)
        media_url: Option<String>,
        /// The asset ID to set the album cover image
        asset_id: Option<i64>,
        /// a MultipartFile containing an asset that the \"media\" file references. Example to upload a video: the \"media\" file should contain a screen capture of the video, and the \"attachedMedia\" should be the actual video.
        #[clap(value_parser = parse_json::<swagger::ByteArray>)]
        attached_media: Option<swagger::ByteArray>,
        /// this can be used if the \"attachedMedia\" is a link (i.e. a Youtube video, etc)
        attached_media_url: Option<String>,
        /// the start date
        start_date: Option<i64>,
        /// the end date
        end_date: Option<i64>,
        /// the tags
        tags: Option<String>,
        /// the description of the album
        description: Option<String>,
        /// a custom field used for aggregation and searching
        album_type: Option<String>,
        /// a custom indexed number used for aggregation and searching
        album_type_id: Option<i64>,
        /// a custom string field used for aggregation and searching
        sub_type: Option<String>,
        /// latitude used to update the album's location
        latitude: Option<f64>,
        /// longitude used to update the album's location
        longitude: Option<f64>,
        /// the location description
        location_description: Option<String>,
        /// the determines the album's participants (PUBLIC - includes everyone in the system as a potential participant, PRIVATE - only considers people who have been invited as participants)
        #[clap(value_parser = parse_json::<models::AddAlbumCollectionVisibilityParameter>)]
        visibility: Option<models::AddAlbumCollectionVisibilityParameter>,
        /// @deprecated, use the appKey
        game_type: Option<String>,
        /// the application key
        app_key: Option<String>,
        /// the cell phone number
        cell_phone: Option<String>,
        /// The street address of the location
        street_address: Option<String>,
        /// Additional address information (such as a suite number, floor number, building name, or PO Box)
        street_address2: Option<String>,
        /// The city of the location
        city: Option<String>,
        /// The state of of the location
        state: Option<String>,
        /// The postal code of the location
        postal_code: Option<String>,
        /// The full address of the location which should include the street address, city, state, and postal code
        full_address: Option<String>,
        /// External custom client defined data
        meta_data: Option<String>,
        /// comma separated category ids string associated with the Album
        category_ids: Option<String>,
        /// comma separated filter ids string associated with the Album
        category_filter_ids: Option<String>,
        /// comma separated audience ids string associated with the album
        audience_ids: Option<String>,
        /// determines whether to include all app users as members (only admins of the app can do this)
        #[clap(long)]
        include_all_app_users_as_members: Option<bool>,
        /// determines whether to include all users of the audiences as members (only admins of the app can do this)
        #[clap(long)]
        include_audiences_as_members: Option<bool>,
        /// determines whether to use ands or ors when using the audience list to add users
        audience_operator: Option<String>,
        /// The approval status to set {PENDING, REJECTED, APPROVED, FEATURED}
        #[clap(value_parser = parse_json::<models::ApproveAlbumApprovalStatusParameter>)]
        approval_status: Option<models::ApproveAlbumApprovalStatusParameter>,
        /// sets a linked object so that it can be returned as part of the album response
        linked_object_type: Option<String>,
        /// sets a linked object id so that it can be returned as part of the album response
        linked_object_id: Option<i64>,
    },
    /// Add Album Users
    AddAlbumUsers {
        version: f64,
        /// the album ID
        album_id: i64,
        /// determines whether to include all friends as participants
        #[clap(short, long)]
        include_friend_group: bool,
        /// a unique ID given by the device (deviceId or accountId required)
        device_id: Option<String>,
        /// the account ID of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// determines whether the users being added have read permissions
        #[clap(short, long)]
        read: Option<bool>,
        /// determines whether the users being added have write permissions
        #[clap(short, long)]
        write: Option<bool>,
        /// determines whether the users being added have delete permissions
        #[clap(short, long)]
        delete: Option<bool>,
        /// determines whether the users being added have add permissions
        #[clap(long)]
        add: Option<bool>,
        /// comma separated list of connection IDs
        connections: Option<String>,
        /// comma separated list of connection group IDs
        connection_groups: Option<String>,
    },
    /// Approve Album
    ApproveAlbum {
        version: f64,
        /// The ID of the album
        album_id: i64,
        /// A unique ID given by the device (deviceId or accountId required)
        device_id: Option<String>,
        /// The account ID of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// The approval status to set {PENDING, REJECTED, APPROVED, FEATURED}
        #[clap(value_parser = parse_json::<models::ApproveAlbumApprovalStatusParameter>)]
        approval_status: Option<models::ApproveAlbumApprovalStatusParameter>,
        /// Sets whether the album should be marked as \"verified\"
        #[clap(short, long)]
        verified: Option<bool>,
    },
    ///  Get Album
    GetAlbumCollection {
        version: f64,
        /// This parameter is deprecated.
        #[clap(short, long)]
        return_nulls: bool,
        /// the album to look up
        album_id: i64,
        /// a unique ID given by the device (deviceId or accountId required)
        device_id: Option<String>,
        /// the account ID of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// returns the last X likes. To search on and paginate the remaining likes - please use the \"/like/search\" endpoint.
        like_preview_size: Option<i32>,
        /// returns the first X assets. To search on and paginate the remaining assets - please use the \"/assets/search\" endpoint.
        asset_preview_size: Option<i32>,
        /// returns the last X notes. To search on and paginate the remaining notes - please use the \"/note/search\" endpoint.
        note_preview_size: Option<i32>,
        /// returns the first X users/connections. To search on and paginate the remaining connections - please use the \"/permissions/search\" endpoint.
        connection_preview_size: Option<i32>,
        /// returns the first X audiences. To search on and paginate the remaining audiences - please use the \"/audience/search\" endpoint.
        audience_preview_size: Option<i32>,
    },
    /// Leave Album
    LeaveAlbum {
        version: f64,
        /// the album ID
        album_id: i64,
        /// a unique ID given by the device (deviceId or accountId required)
        device_id: Option<String>,
        /// the account ID of the user (deviceId or accountId required)
        account_id: Option<i64>,
    },
    /// Delete Album
    RemoveAlbum {
        version: f64,
        /// the album ID to delete
        album_id: i64,
        /// a unique ID given by the device (deviceId or accountId required)
        device_id: Option<String>,
        /// the account ID of the user (deviceId or accountId required)
        account_id: Option<i64>,
    },
    /// Remove Album Users
    RemoveAlbumUsers {
        version: f64,
        /// the album ID
        album_id: i64,
        /// remove friend group
        #[clap(short, long)]
        remove_friend_group: bool,
        /// a unique ID given by the device (deviceId or accountId required)
        device_id: Option<String>,
        /// the account ID of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// comma separated list of connection IDs
        connections: Option<String>,
        /// comma separated list of connection group IDs
        connection_groups: Option<String>,
    },
    /// Search Albums
    SearchAlbums {
        version: f64,
        /// a comma separated list of filters: * MINE - Return albums that the user has created. * SHARED - Return albums that have been shared to the user via addAlbumUsers, or addUsersToPermissionable . * FOLLOWER - Return albums that have been created by the user's followers (the content needs to have been APPROVED or FEATURED). * FOLLOWING - Return albums that have been created by people who the user is following (the content needs to have been APPROVED or FEATURED). * PUBLIC - Return all PUBLIC albums that have been APPROVED or FEATURED. * ALL_PUBLIC - Return all PUBLIC albums regardless of whether they are approved or not (ignores the approval status). * LIKED - Return all albums that the user has liked. * FEATURED - Return all albums that have been featured. * PENDING - Return all pending albums. 
        filter: String,
        /// id of custom albumType
        album_type_id: i64,
        /// filter albums with this album sub type
        sub_type: String,
        /// determines whether to return inactive albums
        #[clap(long)]
        include_inactive: bool,
        /// the field to sort by. See AlbumApiMap
        sort_field: String,
        /// determines whether the sorted list is in descending or ascending order
        #[clap(short, long)]
        descending: bool,
        /// the start index for pagination
        start: i32,
        /// the limit for pagination (There is a hard limit of 100)
        limit: i32,
        /// the maximum range the album can be from the center (used when sortField=ALBUM_DISTANCE)
        range: f64,
        /// returns whether or not the current logged in user has liked the album
        #[clap(long)]
        include_liked: bool,
        /// returns whether or not the current logged in user has favorited the album
        #[clap(long)]
        include_favorited: bool,
        /// returns permission details on whether they have read/write/delete permissions etc (client app probably doesn't need this)
        #[clap(long)]
        include_permissions: bool,
        /// returns the last X likes
        like_preview_size: i32,
        /// returns the first X assets
        asset_preview_size: i32,
        /// returns the last X notes
        note_preview_size: i32,
        /// returns the first X users/connections
        connection_preview_size: i32,
        /// returns the first X audiences. To search on and paginate the remaining audiences, please use the \"/audience/search\" endpoint.
        audience_preview_size: i32,
        /// a unique ID given by the device (deviceId or accountId required)
        device_id: Option<String>,
        /// the account ID of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// the account ID of the user that the results will be based on. This is used to return albums that this account has liked/favorited.
        connection_account_id: Option<i64>,
        /// search on albums that have been created by this account (that the user has permissions to)
        owner_id: Option<i64>,
        /// search on album within a comma separated list of album IDs (this does not work with sortField=ALBUM_DISTANCE, or when stackSearch=true)
        album_ids: Option<String>,
        /// Only for CLOUDINDEX mode, exclude albums with ids matching this list
        exclude_album_ids: Option<String>,
        /// search on albums that are in a particular media offering
        media_id: Option<i64>,
        /// keyword search string
        keyword: Option<String>,
        /// filter albums with this album type
        album_type: Option<String>,
        /// When using multiple album types this sets a per-album-type limit (used with cloud index mode)
        limit_per_album_type: Option<i32>,
        /// return items that have been created before this date (time-stamp in milliseconds)
        date_created: Option<i64>,
        /// return items that have been updated since this date (time-stamp in milliseconds)
        updated_since: Option<i64>,
        /// return items that have been updated before this date (time-stamp in milliseconds)
        updated_before: Option<i64>,
        /// return items that have been created since this date (time-stamp in milliseconds)
        created_since: Option<i64>,
        /// return items that have been created before this date (time-stamp in milliseconds)
        created_before: Option<i64>,
        /// return items that have been started since this date (time-stamp in milliseconds)
        started_since: Option<i64>,
        /// return items that have been started before this date (time-stamp in milliseconds)
        started_before: Option<i64>,
        /// return items that have been ended since this date (time-stamp in milliseconds)
        ended_since: Option<i64>,
        /// return items that have been ended before this date (time-stamp in milliseconds)
        ended_before: Option<i64>,
        /// the latitude of where the search is centered on (used when sortField=ALBUM_DISTANCE)
        latitude: Option<f64>,
        /// the longitude of where the search is centered on (used when sortField=ALBUM_DISTANCE)
        longitude: Option<f64>,
        /// the application key to filter results by application. This is required for consumer searches. Leaving this empty will return albums for the applications that the logged in user owns or has access to.
        app_key: Option<String>,
        /// return results with categories matching this list
        category_ids: Option<String>,
        /// return results with filters matching this list
        category_filter_ids: Option<String>,
        /// return results with audiences matching this list
        audience_ids: Option<String>,
        /// exclude audiences with ids matching this list
        exclude_audience_ids: Option<String>,
        /// returns the user's completable object for the album if it exists
        #[clap(long)]
        include_completable: Option<bool>,
        /// returns the user's rating for the album if it exists
        #[clap(long)]
        include_rating: Option<bool>,
        /// The search index mode to use (RDS, LUCENE, or CLOUDINDEX). If not provided will use server default.
        search_mode: Option<String>,
        /// groups similar albums together that have the same albumTypeId, within a time window defined in stackWindowSize
        #[clap(long)]
        stack_search: Option<bool>,
        /// size of each window for each stack
        stack_window_size: Option<i32>,
        /// The minimum number of stacks returned in a response. For example,  first call, minStackPerPage = 20, the API will return at least 20 results
        min_stack_per_page: Option<i32>,
        /// this is used to tell the system where it left off on the previous previous page, since we can't use start/limit for stackSearch
        stack_pagination_identifier: Option<String>,
        /// set this to true when making the call to view the albums in the stack
        #[clap(long)]
        stack_details: Option<bool>,
        /// Return any results that have a minimum of the specified flag count (even ones that have met the flag threshold)
        flag_count_minimum: Option<i64>,
        /// return items that have flagCount >= flagThreshold (controls removal of flagged content)
        #[clap(short, long)]
        remove_flagged_content: Option<bool>,
        /// setting to true will return only verified albums only, setting to false will return non-verified albums only (leave empty to return both)
        #[clap(short, long)]
        verified_filter: Option<bool>,
        /// filter results by the linkedObjectType
        linked_object_type: Option<String>,
        /// filter results by the linkedObjectId
        linked_object_id: Option<i64>,
        /// determines whether to use the order assigned via the /album/order/_* api (which is tied to an audience)
        order_audience_id: Option<i64>,
        /// if true, ignore the application's default app filter when searching
        #[clap(long)]
        ignore_default_app_filter: Option<bool>,
        /// Advanced search expression to be used by the server
        search_expression: Option<String>,
        /// If true and results are empty, attempt to generate albums via templates
        #[clap(short, long)]
        generate_albums: Option<bool>,
    },
    /// Update Album
    UpdateAlbumCollection {
        version: f64,
        /// the ID of the album to update
        album_id: i64,
        /// a unique ID given by the device (deviceId or accountId required)
        device_id: Option<String>,
        /// the account ID of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// Comma separated list of asset IDs to add to the album's asset list (use \"assetId\" for setting the cover of the album)
        assets_to_add: Option<String>,
        /// Comma separated list of asset IDs to remove from the album's asset list
        assets_to_remove: Option<String>,
        /// the cover asset ID
        asset_id: Option<i64>,
        /// a MultipartFile containing the cover image of the album (this will only be used if \"assetId\" is empty)
        #[clap(value_parser = parse_json::<swagger::ByteArray>)]
        media: Option<swagger::ByteArray>,
        /// this can be used if the \"media\" is a link (this will only be used if \"assetId\" and media are empty)
        media_url: Option<String>,
        /// determines whether the album is active or inactive
        #[clap(long)]
        active: Option<bool>,
        /// the title of the album
        title: Option<String>,
        /// the start date
        start_date: Option<i64>,
        /// the end date
        end_date: Option<i64>,
        /// the tags
        tags: Option<String>,
        /// the description of the album
        description: Option<String>,
        /// a custom field used for aggregation and searching
        album_type: Option<String>,
        /// a custom indexed number used for aggregation and searching
        album_type_id: Option<i64>,
        /// a custom string field used for aggregation and searching
        sub_type: Option<String>,
        /// determines whether the album's participants have read permissions
        #[clap(long)]
        public_read: Option<bool>,
        /// determines whether the album's participants have write permissions
        #[clap(long)]
        public_write: Option<bool>,
        /// determines whether the album's participants have delete permissions
        #[clap(long)]
        public_delete: Option<bool>,
        /// determines whether the album's participants have add permissions
        #[clap(long)]
        public_add: Option<bool>,
        /// latitude used to update the album's location
        latitude: Option<f64>,
        /// longitude used to update the album's location
        longitude: Option<f64>,
        /// the location description
        location_description: Option<String>,
        /// the determines the album's participants (PUBLIC - includes everyone in the system as a potential participant, PRIVATE - only considers people who have been invited as participants)
        #[clap(value_parser = parse_json::<models::AddAlbumCollectionVisibilityParameter>)]
        visibility: Option<models::AddAlbumCollectionVisibilityParameter>,
        /// the cell phone number
        cell_phone: Option<String>,
        /// The street address of the location
        street_address: Option<String>,
        /// Additional address information (such as a suite number, floor number, building name, or PO Box)
        street_address2: Option<String>,
        /// The city of the location
        city: Option<String>,
        /// The state of of the location
        state: Option<String>,
        /// The postal code of the location
        postal_code: Option<String>,
        /// The full address of the location which should include the street address, city, state, and postal code
        full_address: Option<String>,
        /// determines whether the album is posted anonymously
        #[clap(long)]
        anonymous: Option<bool>,
        /// External custom client defined data
        meta_data: Option<String>,
        /// comma separated category ids string associated with the Album
        category_ids: Option<String>,
        /// comma separated filter ids string associated with the Album
        category_filter_ids: Option<String>,
        /// comma separated audience ids string associated with the album
        audience_ids: Option<String>,
        /// comma separated audience ids to add to the album
        audience_ids_to_add: Option<String>,
        /// comma separated audience ids to remove from the album (overrides audienceIds and audienceIdsToAdd)
        audience_ids_to_remove: Option<String>,
        /// determines whether to include all app users as members (only admins of the app can do this)
        #[clap(long)]
        include_all_app_users_as_members: Option<bool>,
        /// determines whether to include all users of the audiences as members (only admins of the app can do this)
        #[clap(long)]
        include_audiences_as_members: Option<bool>,
        /// determines whether to use ands or ors when using the audience list to add users
        audience_operator: Option<String>,
        /// sets a linked object so that it can be returned as part of the album response
        linked_object_type: Option<String>,
        /// sets a linked object id so that it can be returned as part of the album response
        linked_object_id: Option<i64>,
        /// determines whether the album should be indexed immediately
        #[clap(long)]
        index_now: Option<bool>,
    },
    /// Get User Activity
    Activities {
        version: f64,
        /// The start of the pagination
        start: i32,
        /// The limit of the pagination
        limit: i32,
        /// the account id of the user
        account_id: i64,
    },
    /// Get Aggregated Filtered Usage
    AggregatedFilteredUsage {
        version: f64,
        /// The unique id of the device making the request (deviceId or accountId required)
        device_id: Option<String>,
        /// The account id of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// This parameter is deprecated.
        application_id: Option<i64>,
        /// The application key used to filter results by application
        app_key: Option<String>,
        /// Used to search for results after or equal to this date (UNIX time-stamp in milliseconds)
        start_date: Option<i64>,
        /// Used to search for results before or equal to this date (UNIX time-stamp in milliseconds)
        end_date: Option<i64>,
        /// The device type to filter results by (performs a LIKE search)
        device_type: Option<String>,
        /// The device to filter results by (performs a LIKE search)
        device: Option<String>,
        /// The device OS to filter results by (performs a LIKE search)
        device_os: Option<String>,
        /// The gender to filter results by {MALE, FEMALE}
        gender: Option<String>,
        /// Comma separated list of age groups to filter by {AGE_0_13, AGE_14_17, AGE_18_22, AGE_23_30, AGE_31_54, AGE_55_PLUS}
        age_group: Option<String>,
        /// The country to filter results by (performs a wild-card search)
        country: Option<String>,
        /// The state to filter results by (performs a wild-card search)
        state: Option<String>,
        /// The city to filter results by (performs a wild-card search)
        city: Option<String>,
        /// The zip to filter results by (performs a wild-card search)
        zip: Option<String>,
        /// The model to filter results by (performs a wild-card search)
        model: Option<String>,
        /// The tag to filter results by (performs a wild-card search)
        tag: Option<String>,
        /// The account id to filter results for a particular user
        user_account_id: Option<i64>,
        /// The user display to filter results by (performs a wild-card search)
        user_account_display: Option<String>,
        /// The username to filter results by (performs a wild-card search)
        user_account_username: Option<String>,
        /// Determines how to group results. For example, passing in 'CREATED' will return results by date. Passing in 'ACCOUNT' will return results by user {TAG, CUSTOM_ID, TOKEN, MODEL, DEVICE_TYPE, DEVICE, DEVICE_OS, IP_ADDRESS, STATE, CITY, ZIP, COUNTRY, ACCOUNT, APPLICATION_ID, APPLICATION_NAME_BY_ID}
        #[clap(value_parser = parse_json::<models::AggregatedFilteredUsageGroupByRootParameter>)]
        group_by_root: Option<models::AggregatedFilteredUsageGroupByRootParameter>,
        /// Determines how to group the nested data. {TAG, CUSTOM_ID, TOKEN, MODEL, DEVICE_TYPE, DEVICE, DEVICE_OS, IP_ADDRESS, STATE, CITY, ZIP, COUNTRY, ACCOUNT, APPLICATION_ID, APPLICATION_NAME_BY_ID}
        #[clap(value_parser = parse_json::<models::AggregatedFilteredUsageGroupByRootParameter>)]
        group_by: Option<models::AggregatedFilteredUsageGroupByRootParameter>,
        /// Performs a unique query on the specified column. For example, passing in 'ACCOUNT' will return the number of unique users. {TAG, CUSTOM_ID, TOKEN, MODEL, DEVICE_TYPE, DEVICE, DEVICE_OS, IP_ADDRESS, STATE, CITY, ZIP, COUNTRY, ACCOUNT, APPLICATION_ID, NEW_ACCOUNT}
        #[clap(value_parser = parse_json::<models::AggregatedFilteredUsageGroupByRootParameter>)]
        distinct_count: Option<models::AggregatedFilteredUsageGroupByRootParameter>,
        /// Determines whether the results will be sorted by day or by number of hits {CREATED, TAG_COUNT}
        #[clap(value_parser = parse_json::<models::AggregatedFilteredUsageGroupByRootParameter>)]
        sort_field: Option<models::AggregatedFilteredUsageGroupByRootParameter>,
        /// Determines whether to return results in descending order
        #[clap(short, long)]
        descending: Option<bool>,
        /// Determines whether to return data that has empty or unknown values
        #[clap(short, long)]
        hide_unknown: Option<bool>,
        /// Determines whether to return a JOSN or XML representation of the graph results
        #[clap(value_parser = parse_json::<models::AggregatedFilteredUsageResponseFormatParameter>)]
        response_format: Option<models::AggregatedFilteredUsageResponseFormatParameter>,
        /// This parameter is deprecated.
        _l: Option<i32>,
        /// Used to limit results to get a cleaner graph. The results that gets filtered out will be combined
        limit: Option<i32>,
        /// the current latitude of the user
        latitude: Option<f64>,
        /// the current longitude of the user
        longitude: Option<f64>,
    },
    /// Get Filtered Usage
    FilteredUsage {
        version: f64,
        /// The unique id of the device making the request (deviceId or accountId required)
        device_id: Option<String>,
        /// The account id of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// This parameter is deprecated.
        application_id: Option<i64>,
        /// The application key used to filter results by application
        app_key: Option<String>,
        /// Used to search for results after or equal to this date (UNIX time-stamp in milliseconds)
        start_date: Option<i64>,
        /// Used to search for results before or equal to this date (UNIX time-stamp in milliseconds)
        end_date: Option<i64>,
        /// The device type to filter results by (performs a LIKE search)
        device_type: Option<String>,
        /// The device to filter results by (performs a LIKE search)
        device: Option<String>,
        /// The device OS to filter results by (performs a LIKE search)
        device_os: Option<String>,
        /// The gender to filter results by {MALE, FEMALE}
        gender: Option<String>,
        /// Comma separated list of age groups to filter by {AGE_0_13, AGE_14_17, AGE_18_22, AGE_23_30, AGE_31_54, AGE_55_PLUS}
        age_group: Option<String>,
        /// The country to filter results by (performs a wild-card search)
        country: Option<String>,
        /// The state to filter results by (performs a wild-card search)
        state: Option<String>,
        /// The city to filter results by (performs a wild-card search)
        city: Option<String>,
        /// The zip to filter results by (performs a wild-card search)
        zip: Option<String>,
        /// The model to filter results by (performs a wild-card search)
        model: Option<String>,
        /// The tag to filter results by (performs a wild-card search)
        tag: Option<String>,
        /// The account id to filter results for a particular user
        user_account_id: Option<i64>,
        /// The user display to filter results by (performs a wild-card search)
        user_account_display: Option<String>,
        /// The username to filter results by (performs a wild-card search)
        user_account_username: Option<String>,
        /// The ID for the custom table column
        custom_id: Option<i64>,
        /// The type defined for the custom table column
        custom_type: Option<String>,
        /// The value for the custom table column
        custom_value: Option<f64>,
        /// The value for another custom table column
        custom_value2: Option<f64>,
        /// The value that supports Longs for custom table column
        custom_long: Option<i64>,
        /// The value that supports Longs for custom table column
        custom_long2: Option<i64>,
        /// The message for the custom table column
        custom_message: Option<String>,
        /// The message for the custom table column
        custom_message2: Option<String>,
        /// Determines how to group results. For example, passing in 'CREATED' will return results by date. Passing in 'ACCOUNT' will return results by user {TAG, CUSTOM_ID, TOKEN, MODEL, DEVICE_TYPE, DEVICE, DEVICE_OS, DEVICE_ID, IP_ADDRESS, STATE, CITY, ZIP, COUNTRY, ACCOUNT, APPLICATION_ID}
        #[clap(value_parser = parse_json::<models::AggregatedFilteredUsageGroupByRootParameter>)]
        group_by: Option<models::AggregatedFilteredUsageGroupByRootParameter>,
        /// Performs a unique query on the specified column. For example, passing in 'ACCOUNT' will return the number of unique users. {TAG, CUSTOM_ID, TOKEN, MODEL, DEVICE_TYPE, DEVICE, DEVICE_OS, DEVICE_ID, IP_ADDRESS, STATE, CITY, ZIP, COUNTRY, ACCOUNT, APPLICATION_ID}
        #[clap(value_parser = parse_json::<models::AggregatedFilteredUsageGroupByRootParameter>)]
        distinct_count: Option<models::AggregatedFilteredUsageGroupByRootParameter>,
        /// sum of the column values
        #[clap(value_parser = parse_json::<models::AggregatedFilteredUsageGroupByRootParameter>)]
        sum_column: Option<models::AggregatedFilteredUsageGroupByRootParameter>,
        /// Determines whether the results will be sorted by day or by number of hits {CREATED, TAG_COUNT}
        #[clap(value_parser = parse_json::<models::AggregatedFilteredUsageGroupByRootParameter>)]
        sort_field: Option<models::AggregatedFilteredUsageGroupByRootParameter>,
        /// Determines whether to return results in descending order
        #[clap(short, long)]
        descending: Option<bool>,
        /// Determines whether to return data that has empty or unknown values
        #[clap(short, long)]
        hide_unknown: Option<bool>,
        /// Determines whether to return a JOSN or XML representation of the graph results
        #[clap(value_parser = parse_json::<models::AggregatedFilteredUsageResponseFormatParameter>)]
        response_format: Option<models::AggregatedFilteredUsageResponseFormatParameter>,
        /// This parameter is deprecated.
        _l: Option<i32>,
        /// Used to limit results to get a cleaner graph. The results that gets filtered out will be combined
        limit: Option<i32>,
        /// the current latitude of the user
        latitude: Option<f64>,
        /// the current longitude of the user
        longitude: Option<f64>,
    },
    /// Create Usage Record
    Usage {
        version: f64,
        /// The tag to apply: the name of the action or thing being logged.
        tag: String,
        /// The client deviceID
        device_id: Option<String>,
        /// The logged in user ID
        account_id: Option<i64>,
        /// This parameter is deprecated. This is deprecated, use appKey.
        application_id: Option<i64>,
        /// The application key unique to each application.
        app_key: Option<String>,
        /// The current build version of the application
        app_version: Option<String>,
        /// The name of the device being used (iPhone5,1 , HTC Nexus One, x86_64, etc.)
        device: Option<String>,
        /// The type of device (Handheld or Desktop)
        device_type: Option<String>,
        /// The operating system that the device is using (iPhone OS 5.0, Android OS 2.3.6, Windows 7 Service Pack 1, etc)
        device_os: Option<String>,
        /// The model of the device (iPhone5,1 , Nexus One, etc.)
        model: Option<String>,
        /// The current position of the user
        latitude: Option<f64>,
        /// The current position of the user
        longitude: Option<f64>,
        /// A customId used to associate the usage record with some other record in the system
        custom_id: Option<i64>,
        /// The type of record the customId is recorded for
        custom_type: Option<String>,
        /// This parameter is deprecated. This is deprecated, use \"customValue\". Determines how many achievement points and/or ranking points the user gets if this analytic is associated with an achievement
        achievement_increment: Option<i64>,
        /// The current city of the user
        city: Option<String>,
        /// The current state of the user
        state: Option<String>,
        /// The current country of the user
        country: Option<String>,
        /// The current zip of the user
        zip: Option<String>,
        /// The general description of the user's location
        location_description: Option<String>,
        /// Timestamp sent from device
        client_time: Option<i64>,
        /// This parameter is deprecated.
        error_message: Option<String>,
        /// the ip address of the client device
        ip: Option<String>,
        /// this is a description of the client (might contain the device's OS, browser version etc - its a common term)
        user_agent: Option<String>,
        /// This is deprecated.
        #[clap(short, long)]
        background_event: Option<bool>,
        /// a custom message for the usage record
        custom_message: Option<String>,
        /// a custom message for the usage record
        custom_message2: Option<String>,
        /// a custom value for the usage record
        custom_value: Option<f64>,
        /// a custom value for the usage record
        custom_value2: Option<f64>,
        /// a custom long value for the usage record
        custom_long: Option<i64>,
        /// a custom long value for the usage record
        custom_long2: Option<i64>,
    },
    /// Create Multiple Usage Records
    UsageBatch {
        version: f64,
        /// The application key unique to each application.
        app_key: String,
        /// The name of the device being used (iPhone5,1 , HTC Nexus One, x86_64, etc.)
        device: String,
        /// The analytic data AnalyticListResponse
        data: String,
        /// The unique id of the device making the request
        device_id: Option<String>,
        /// The account ID of the logged in user making the request
        account_id: Option<i64>,
        /// The current build version of the application
        app_version: Option<String>,
        /// The type of device (Handheld or Desktop)
        device_type: Option<String>,
        /// The operating system that the device is using (iPhone OS 5.0, Android OS 2.3.6, Windows 7 Service Pack 1, etc.)
        device_os: Option<String>,
        /// The model of the device (iPhone5,1 , Nexus One, etc.)
        model: Option<String>,
        /// Will create a leaderboard if one does not exist for the \"tag\" yet
        #[clap(short, long)]
        update_ranking: Option<bool>,
        /// Returns a summary response of the achievements that have been completed due to the analytics
        #[clap(short, long)]
        return_summary_response: Option<bool>,
    },
    /// Get App Data
    GetAppData {
        version: f64,
        /// start the search results at a record.
        start: i32,
        /// limit the search results to some number.
        limit: i32,
        /// the device id (deviceId or accountId required).
        device_id: Option<String>,
        /// the account id of the user (deviceId or accountId required).
        account_id: Option<i64>,
        /// the game to retrieve the data for, use your application key.
        game_type: Option<String>,
        /// if true then include the game data blob, otherwise don't include.
        #[clap(long)]
        include_game_data: Option<bool>,
        /// This parameter is deprecated.
        q: Option<String>,
        /// query string used to filter the search results when looking for community and saved levels.
        keyword: Option<String>,
        /// how to sort the results when looking for community and saved levels. possible values are: LEVEL_NAME, LEVEL_CREATED, LEVEL_UPDATED, LEVEL_LIKES, LEVEL_DISLIKES, LEVEL_NOTES, LEVEL_PLAYS.
        sort_field: Option<String>,
        /// order the search results descending or ascending when looking for community and saved levels.
        #[clap(short, long)]
        descending: Option<bool>,
        /// This parameter is deprecated.
        _i: Option<i32>,
        /// This parameter is deprecated.
        _l: Option<i32>,
        /// if true then include the game object count, otherwise don't include.
        #[clap(short, long)]
        game_object_count: Option<bool>,
        /// restrict the search to items with certain permissions, possible values are: MINE, FRIENDS, PUBLIC, ALL_PUBLIC, ALL, LIKED
        filter: Option<String>,
        /// restrict the search to items created less then date
        date_created: Option<i64>,
        /// get levels owned by a particular account
        owner_id: Option<i64>,
        /// get missions by specified id, comman seperated list of long ids
        mission_ids: Option<String>,
        /// get games by specified id, comman seperated list of long ids
        game_ids: Option<String>,
        /// get packs by specified id, comman seperated list of long ids
        pack_ids: Option<String>,
        /// get game levels by specified id, comman seperated list of long ids
        game_level_ids: Option<String>,
        /// the application version, used to versin the game level data
        app_version: Option<String>,
        /// default is false and will not include any packs that have levels above the specified appVersion. If true then will return all levels regardless of version.
        #[clap(long)]
        include_higher_version_packs: Option<bool>,
        /// default is false and will not include any levels above the specified appVersion. If true then will return all levels regardless of version.
        #[clap(long)]
        include_higher_version_levels: Option<bool>,
        /// use response groups to include large parts of the structure. possible values are: * MISSION_DEFAULT (default) - include the default mission (built-in packs), excludes all other mission groups * MISSION_DEFAULT_LEVELS_SAVED - include saved levels, excludes all other mission groups * MISSION_DEFAULT_LEVELS_COMMUNITY - include community levels, excludes all other mission groups * MISSION_INVITED (default) - include challenges sent to user * PROFILE (default) - include entire profile * PROFILE_DATA - only include profile date (exclude friends) * PROFILE_FRIENDS - include friends list 
        response_groups: Option<String>,
        /// the will return the correct in app purchases for the device, possible values are: * SIRQUL (default) - purchasing from the sirqul store using tickets * IOS - purchasing from the itunes store for iPhone, iPod, iPod Touch * GOOGLE - purchasing from the google android store * AMAZON - purchasing from the amazon android store * MAC - purchasing from the itunes store for OSX * FREE - the item is free to purchase 
        purchase_type: Option<String>,
    },
    /// Create App Data
    PostAppData {
        version: f64,
        /// the game to retrieve the data for, use your application key.
        game_type: String,
        /// start the search results at a record.
        start: i32,
        /// limit the search results to some number.
        limit: i32,
        /// The analytic data AnalyticListResponse
        data: String,
        /// the device id (deviceId or accountId required).
        device_id: Option<String>,
        /// the account id of the user (deviceId or accountId required).
        account_id: Option<i64>,
        /// if true then include the game data blob, otherwise don't include.
        #[clap(long)]
        include_game_data: Option<bool>,
        /// This parameter is deprecated.
        q: Option<String>,
        /// query string used to filter the search results when looking for community and saved levels.
        keyword: Option<String>,
        /// how to sort the results when looking for community and saved levels. possible values are: LEVEL_NAME, LEVEL_CREATED, LEVEL_UPDATED, LEVEL_LIKES, LEVEL_DISLIKES, LEVEL_NOTES, LEVEL_PLAYS.
        sort_field: Option<String>,
        /// order the search results descending or ascending when looking for community and saved levels.
        #[clap(short, long)]
        descending: Option<bool>,
        /// This parameter is deprecated.
        _i: Option<i32>,
        /// This parameter is deprecated.
        _l: Option<i32>,
        /// if true then include the game object count, otherwise don't include.
        #[clap(short, long)]
        game_object_count: Option<bool>,
        /// restrict the search to items with certain permissions, possible values are: MINE, FRIENDS, PUBLIC, ALL_PUBLIC, ALL, LIKED
        filter: Option<String>,
        /// restrict the search to items created less then date
        date_created: Option<i64>,
        /// get levels owned by a particular account
        owner_id: Option<i64>,
        /// get missions by specified id, comman seperated list of long ids
        mission_ids: Option<String>,
        /// get games by specified id, comman seperated list of long ids
        game_ids: Option<String>,
        /// get packs by specified id, comman seperated list of long ids
        pack_ids: Option<String>,
        /// get game levels by specified id, comman seperated list of long ids
        game_level_ids: Option<String>,
        /// the application version, used to versin the game level data
        app_version: Option<String>,
        /// default is false and will not include any packs that have levels above the specified appVersion. If true then will return all levels regardless of version.
        #[clap(long)]
        include_higher_version_packs: Option<bool>,
        /// default is false and will not include any levels above the specified appVersion. If true then will return all levels regardless of version.
        #[clap(long)]
        include_higher_version_levels: Option<bool>,
        /// use response groups to include large parts of the structure. possible values are: * MISSION_DEFAULT (default) - include the default mission (built-in packs), excludes all other mission groups * MISSION_DEFAULT_LEVELS_SAVED - include saved levels, excludes all other mission groups * MISSION_DEFAULT_LEVELS_COMMUNITY - include community levels, excludes all other mission groups * MISSION_INVITED (default) - include challenges sent to user * PROFILE (default) - include entire profile * PROFILE_DATA - only include profile date (exclude friends) * PROFILE_FRIENDS - include friends list 
        response_groups: Option<String>,
        /// the will return the correct in app purchases for the device, possible values are: * SIRQUL (default) - purchasing from the sirqul store using tickets * IOS - purchasing from the itunes store for iPhone, iPod, iPod Touch * GOOGLE - purchasing from the google android store * AMAZON - purchasing from the amazon android store * MAC - purchasing from the itunes store for OSX * FREE - the item is free to purchase 
        purchase_type: Option<String>,
    },
    /// Regenerate App Data
    RegenAppData {
        version: f64,
        /// the account id of the user
        account_id: Option<i64>,
        /// process a specific application, if null process all apps with caches
        app_key: Option<String>,
        /// create a specific version, if null use current version. Be careful if processing all
        build_version: Option<String>,
        /// create a specific version, if null use current version. Be careful if processing all
        api_version: Option<String>,
    },
    /// Create Application
    CreateApplication {
        version: f64,
        /// The name of the application
        app_name: String,
        /// The unique id of the device making the request (deviceId or accountId required)
        device_id: Option<String>,
        /// The account id of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// The description of the application
        about: Option<String>,
        /// The application bundle identifier (format - com.company.appName)
        bundle_id: Option<String>,
        /// The application icon asset id
        app_icon_asset_id: Option<i64>,
        /// The application logo asset id
        app_logo_asset_id: Option<i64>,
        /// The Facebook application id
        facebook_app_id: Option<String>,
        /// The Facebook application secret
        facebook_app_secret: Option<String>,
        /// This is the either the 'server key' or 'browser key' generated from google to enable Google Cloud Messaging
        google_api_key: Option<String>,
        /// Determines whether to update the EULA date
        #[clap(long)]
        update_eula_date: Option<bool>,
        /// The EULA version
        eula_version: Option<String>,
        /// The landing page URL
        landing_page_url: Option<String>,
        /// Determines whether to show the application in the activity feed
        #[clap(short, long)]
        show_in_activities: Option<bool>,
        /// The description of the application in the activity feed
        activity_description: Option<String>,
        /// The text to display on the invite page
        invite_welcome_text: Option<String>,
        /// The url to the application invite page
        invite_page_url: Option<String>,
        /// The protocal the app uses to load the app via a browser
        url_scheme: Option<String>,
        /// A json object with a list of supported platforms.  ```json {   \"platforms\": [     {       \"deviceId\": 1,       \"minimum\": 230,       \"maximum\": 421,       \"downloadUrl\": \"http://app.store.com/download\",       \"description\": \"description and version info\"     }   ] } ``` 
        platforms: Option<String>,
        /// Json formatted downloadUrls.  ```json {   \"ios\": \"the-url-to-app-store\",    \"android\": \"the-url-to-google-play\" } ```  
        download_urls: Option<String>,
        /// List of categories to apply
        category_ids: Option<String>,
        /// The type of scoring this application will use {GAME_LEVEL, GAME_OBJECT
        #[clap(value_parser = parse_json::<models::CreateApplicationScoringTypeParameter>)]
        scoring_type: Option<models::CreateApplicationScoringTypeParameter>,
        /// The cost of hints
        hint_cost: Option<i32>,
        /// The maximum score that will be possible
        max_score: Option<i32>,
        /// The point-to-ticket conversion ratio
        tickets_per_point: Option<f32>,
        /// Determines whether the application uses services to save custom game objects
        #[clap(short, long)]
        has_game_data: Option<bool>,
        /// Public Notifications
        #[clap(long)]
        public_notifications: Option<bool>,
        /// Use Matching Algorithm
        #[clap(long)]
        use_matching_algorithm: Option<bool>,
        /// Determines whether earned tickets are applied across all applications
        #[clap(short, long)]
        global_tickets: Option<bool>,
        /// The current build version of the application
        build_version: Option<f32>,
        /// The current API version the application uses
        api_version: Option<f32>,
        /// The name of the placement
        placement_name: Option<String>,
        /// The description of the placement
        placement_description: Option<String>,
        /// The ad placement size {BANNER, LEADERBOARD, SKYSCRAPER, INTERSTITIAL, CUSTOM (this is required if a placements is to be created)
        #[clap(value_parser = parse_json::<models::CreateApplicationPlacementSizeParameter>)]
        placement_size: Option<models::CreateApplicationPlacementSizeParameter>,
        /// The height of a custom ad size
        placement_height: Option<i32>,
        /// The width of a custom ad size
        placement_width: Option<i32>,
        /// The refresh interval in seconds
        placement_refresh_interval: Option<i32>,
        /// Generate a custom object store to use
        #[clap(short, long)]
        create_object_store: Option<bool>,
        /// Determine whether or not public content requires admin approval before it becomes public
        #[clap(long)]
        public_content_approval: Option<bool>,
        /// Determines whether the application uses production or sandbox services
        #[clap(long)]
        production_mode: Option<bool>,
        /// Minimum Session Length
        minimum_session_length: Option<i32>,
        /// Session Gap Length
        session_gap_length: Option<i32>,
        /// Local Ads Enabled
        #[clap(short, long)]
        local_ads_enabled: Option<bool>,
        /// Sqoot Api Key
        sqoot_api_key: Option<String>,
        /// Determines how to process trilateration data. Possible values include: DEFAULT, FINGERPRINT
        #[clap(value_parser = parse_json::<models::CreateApplicationTrilatProcessingTypeParameter>)]
        trilat_processing_type: Option<models::CreateApplicationTrilatProcessingTypeParameter>,
        /// Determines what the maximum sample size during trilateration
        max_sample_size: Option<i32>,
        /// Determines what the minimum acceptable RSSI value
        min_rssi: Option<f64>,
        /// List modules allowed to be served by the server, possible values include: COMMON, MEDIA, OFFER, GAME, SOCIAL, CONSUMER_WEBSITE, ALL
        modules: Option<String>,
        /// How many servers the license will support
        authorized_count: Option<i32>,
        /// The list of ip addresses of servers the license will support, leave null for any server
        authorized_servers: Option<String>,
        /// Sets the default timezone for the app (used for leaderboards and other time specific content)
        default_timezone: Option<String>,
        /// SMTP Pass
        smtp_pass: Option<String>,
        /// The application meta data. Defined by the client
        meta_data: Option<String>,
        /// The ad placement meta data. Defined by the client
        placement_meta_data: Option<String>,
        /// Create floor tables for Ips
        #[clap(long)]
        ips_floor: Option<bool>,
        /// Enables setting the APNS badge value in the payload
        #[clap(long)]
        enable_apns_badge: Option<bool>,
        /// Enables using the application in session reports
        #[clap(long)]
        include_in_report: Option<bool>,
        /// Sets the default filter to use (if none is passed in) for certain search APIs including Album Search.
        default_app_filter_id: Option<i64>,
        /// Enables whether the default welcome email will be sent for new app users
        #[clap(long)]
        enable_welcome_email: Option<bool>,
        /// The Apple Application ID
        apple_app_id: Option<String>,
        /// The Apple Team ID
        apple_team_id: Option<String>,
        /// The Apple Auth Key ID
        apple_auth_key_id: Option<String>,
        /// The Apple Auth Signin Key (p8) File
        #[clap(value_parser = parse_json::<swagger::ByteArray>)]
        apple_auth_key: Option<swagger::ByteArray>,
        /// The Apple Issuer ID
        apple_issuer_id: Option<String>,
        /// The Apple App Store Key ID
        app_store_key_id: Option<String>,
        /// The Apple App Store Key (p8) File
        #[clap(value_parser = parse_json::<swagger::ByteArray>)]
        app_store_key: Option<swagger::ByteArray>,
        /// This is the private key file for your Google service account.
        #[clap(value_parser = parse_json::<swagger::ByteArray>)]
        google_private_key_file: Option<swagger::ByteArray>,
        /// Authorize Net Api Key
        authorize_net_api_key: Option<String>,
        /// Authorize Net Transaction Key
        authorize_net_transaction_key: Option<String>,
        /// Email Sender
        email_sender: Option<String>,
        /// SMTP User
        smtp_user: Option<String>,
        /// SMTP Host
        smtp_host: Option<String>,
        /// Vatom Business Id
        vatom_business_id: Option<String>,
        /// Vatom REST Client Id
        vatom_rest_client_id: Option<String>,
        /// Vatom Secret Key
        vatom_rest_secret_key: Option<String>,
        /// Twilio Account SID
        twilio_account_sid: Option<String>,
        /// Twilio Auth Token
        twilio_auth_token: Option<String>,
        /// Twilio Sender Phone Number
        twilio_sender_phone_number: Option<String>,
        /// OpenAI Secret API Key
        open_ai_secret_key: Option<String>,
    },
    /// Create Ad Placement
    CreateApplicationPlacement {
        version: f64,
        /// The appKey of the application the ad placement is for
        app_key: String,
        /// The ad placement size {BANNER, LEADERBOARD, SKYSCRAPER, INTERSTITIAL, CUSTOM
        #[clap(value_parser = parse_json::<models::CreateApplicationPlacementSizeParameter>)]
        size: models::CreateApplicationPlacementSizeParameter,
        /// The unique id of the device making the request (deviceId or accountId required)
        device_id: Option<String>,
        /// The account id of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// The name of the placement
        name: Option<String>,
        /// The description of the placement
        description: Option<String>,
        /// The height of a custom ad size
        height: Option<i32>,
        /// The width of a custom ad size
        width: Option<i32>,
        /// The refresh interval in seconds
        refresh_interval: Option<i32>,
        /// Default Image Id
        default_image_id: Option<i64>,
        /// Active
        #[clap(long)]
        active: Option<bool>,
    },
    /// Delete Application
    DeleteApplication {
        version: f64,
        /// The account used to perform the delete, must have rights to edit the application.
        account_id: Option<i64>,
        /// The key of the application to be deleted
        app_key: Option<String>,
    },
    /// Delete Ad Placement
    DeleteApplicationPlacement {
        version: f64,
        /// The id of the placement to delete, the user must have rights to the application the ad placement is for
        placement_id: i64,
        /// The unique id of the device making the request (deviceId or accountId required)
        device_id: Option<String>,
        /// The account id of the user (deviceId or accountId required)
        account_id: Option<i64>,
    },
    /// Get Application
    GetApplication {
        version: f64,
        /// The key of the application
        app_key: Option<String>,
        /// Application Id
        application_id: Option<i64>,
    },
    /// Get Ad Placement
    GetApplicationPlacement {
        version: f64,
        /// The id of the placement
        placement_id: i64,
        /// The unique id of the device making the request (deviceId or accountId required)
        device_id: Option<String>,
        /// The account id of the user (deviceId or accountId required)
        account_id: Option<i64>,
    },
    /// Get API versions
    GetApplicationVersions {
        version: f64,
    },
    /// Search Application Users
    GetUniqueUsersByApp {
        version: f64,
        /// The application key
        app_key: String,
        /// Q
        q: Option<String>,
        /// The keyword used to search
        keyword: Option<String>,
        /// Return accounts that have been active after this date (UNIX time-stamp in milliseconds)
        since: Option<i64>,
        /// the start of the index
        _i: Option<i32>,
        /// The start of the pagination
        start: Option<i32>,
        /// the limit of the index
        _l: Option<i32>,
        /// The limit of the pagination
        limit: Option<i32>,
    },
    /// List Applications
    ListApplications {
        version: f64,
        /// The account id of the application owner/manager
        account_id: Option<i64>,
        /// Q
        q: Option<String>,
        /// The keyword used to search for title, about, and description fields
        keyword: Option<String>,
        /// Deprecated, use deviceIds and deviceVersions
        platforms: Option<String>,
        /// The list of targeted device ids, comma separated; possible values are retreived via /api/{version/audience/devices com.sirqul.geoapps.common.service.AudienceApi#getDevices getDevices (pass in deviceId values)
        device_ids: Option<String>,
        /// The list of targeted device version ranges that are aligned  with the provided devices list (see devices param for possible values),  comma separated; examples are: 2.3-X, 0-5.1.4, 4.3.1-6.1.4 where X  is no maximum and 0 is no minimum. 
        device_versions: Option<String>,
        /// The list of category ids to filter the list by
        category_ids: Option<String>,
        /// The column to sort the search on, possible values include: UPDATED (default), CREATED, TITLE
        #[clap(value_parser = parse_json::<models::ListApplicationsSortFieldParameter>)]
        sort_field: Option<models::ListApplicationsSortFieldParameter>,
        /// Filter results on whether the application supports ads or not. Ignore this parameter to return all results.
        #[clap(long)]
        has_ads: Option<bool>,
        /// Filter results on whether the application is available for public trigger notifications
        #[clap(short, long)]
        public_notifications: Option<bool>,
        /// Determines whether to only return applications that the user has access to
        #[clap(long)]
        filter_billable: Option<bool>,
        /// Determines whether to only return applications that the user is a content admin of
        #[clap(long)]
        filter_content_admin: Option<bool>,
        /// The order to return the search results
        #[clap(short, long)]
        descending: Option<bool>,
        /// the start of the index
        _i: Option<i32>,
        /// The start of the pagination
        start: Option<i32>,
        /// The limit of the index
        _l: Option<i32>,
        /// The limit of the pagination
        limit: Option<i32>,
        /// The list of application ids, comma separated. If provided will ignore all other params.
        application_ids: Option<String>,
        /// Only include applications with a object store (default is false)
        #[clap(long)]
        has_object_store: Option<bool>,
        /// Return only active results
        #[clap(long)]
        active_only: Option<bool>,
    },
    /// Search for Ad Placements
    SearchApplicationPlacement {
        version: f64,
        /// The key of the application
        app_key: String,
        /// The unique id of the device making the request (deviceId or accountId required)
        device_id: Option<String>,
        /// The account id of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// The start of the pagination
        start: Option<i32>,
        /// The limit of the pagination
        limit: Option<i32>,
    },
    /// Search for Application Settings
    SearchApplicationSettings {
        version: f64,
        /// The device id (deviceId or accountId required)
        device_id: Option<String>,
        /// The account id of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// The account id used to view another person's account
        connection_account_id: Option<i64>,
        /// The string to search applications on
        keyword: Option<String>,
        /// The column to sort the search on. Possible values include: CREATED, UPDATED, APPLICATION_TITLE
        sort_field: Option<String>,
        /// The order to return the search results
        #[clap(short, long)]
        descending: Option<bool>,
        /// The start index for pagination
        start: Option<i32>,
        /// The limit per result set for pagination
        limit: Option<i32>,
    },
    /// Search Applications
    SearchApplications {
        version: f64,
        /// The unique id of the device making the request (deviceId or accountId required)
        device_id: Option<String>,
        /// The account id of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// The location of the device
        latitude: Option<f64>,
        /// The location of the device
        longitude: Option<f64>,
        /// Q
        q: Option<String>,
        /// The keyword used to search
        keyword: Option<String>,
        /// The columns to applied the keyword search to
        q_search_fields: Option<String>,
        /// The column to sort the search on
        #[clap(value_parser = parse_json::<models::SearchApplicationsSortFieldParameter>)]
        sort_field: Option<models::SearchApplicationsSortFieldParameter>,
        /// The order to return the search results
        #[clap(short, long)]
        descending: Option<bool>,
        /// the start of the index
        _i: Option<i32>,
        /// The start of the pagination
        start: Option<i32>,
        /// the limit of the index
        _l: Option<i32>,
        /// The limit of the pagination
        limit: Option<i32>,
        /// Filter results on whether the application supports ads or not. Ignore this parameter to return all results.
        #[clap(short, long)]
        has_ads: Option<bool>,
        /// Filter results on whether the application is available for public trigger notifications
        #[clap(short, long)]
        public_notifications: Option<bool>,
        /// Return only active results
        #[clap(long)]
        active_only: Option<bool>,
    },
    /// Update Application
    UpdateApplication {
        version: f64,
        /// The application key for updating an existing application
        app_key: String,
        /// The name of the application
        app_name: String,
        /// The unique id of the device making the request (deviceId or accountId required)
        device_id: Option<String>,
        /// The account id of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// The description of the application
        about: Option<String>,
        /// The application bundle identifier (format - com.company.appName)
        bundle_id: Option<String>,
        /// The application icon asset id
        app_icon_asset_id: Option<i64>,
        /// The application logo asset id
        app_logo_asset_id: Option<i64>,
        /// The Facebook application id
        facebook_app_id: Option<String>,
        /// The Facebook application secret
        facebook_app_secret: Option<String>,
        /// This is the either the 'server key' or 'browser key' generated from google to enable Google Cloud Messaging
        google_api_key: Option<String>,
        /// Determines whether to update the EULA date
        #[clap(long)]
        update_eula_date: Option<bool>,
        /// The EULA version
        eula_version: Option<String>,
        /// The landing page URL
        landing_page_url: Option<String>,
        /// Determines whether to show the application in the activity feed
        #[clap(short, long)]
        show_in_activities: Option<bool>,
        /// The description of the application in the activity feed
        activity_description: Option<String>,
        /// The text to display on the invite page
        invite_welcome_text: Option<String>,
        /// The url to the application invite page
        invite_page_url: Option<String>,
        /// The protocal the app uses to load the app via a browser
        url_scheme: Option<String>,
        /// A json object with a list of supported platforms.  ```json {   \"platforms\": [     {       \"deviceId\": 1,       \"minimum\": 230,       \"maximum\": 421,       \"downloadUrl\": \"http://app.store.com/download\",       \"description\": \"description and version info\"     }   ] } ``` 
        platforms: Option<String>,
        /// Json formatted downloadUrls.  ```json {   \"ios\": \"the-url-to-app-store\",    \"android\": \"the-url-to-google-play\" } ```  
        download_urls: Option<String>,
        /// List of categories to apply
        category_ids: Option<String>,
        /// The type of scoring this application will use {GAME_LEVEL, GAME_OBJECT
        #[clap(value_parser = parse_json::<models::CreateApplicationScoringTypeParameter>)]
        scoring_type: Option<models::CreateApplicationScoringTypeParameter>,
        /// The cost of hints
        hint_cost: Option<i32>,
        /// The maximum score that will be possible
        max_score: Option<i32>,
        /// The point-to-ticket conversion ratio
        tickets_per_point: Option<f32>,
        /// Determines whether the application uses services to save custom game objects
        #[clap(short, long)]
        has_game_data: Option<bool>,
        /// Public Notifications
        #[clap(long)]
        public_notifications: Option<bool>,
        /// Use Matching Algorithm
        #[clap(long)]
        use_matching_algorithm: Option<bool>,
        /// Determines whether earned tickets are applied across all applications
        #[clap(short, long)]
        global_tickets: Option<bool>,
        /// The current build version of the application
        build_version: Option<f32>,
        /// The current API version the application uses
        api_version: Option<f32>,
        /// The name of the placement
        placement_name: Option<String>,
        /// The description of the placement
        placement_description: Option<String>,
        /// The ad placement size {BANNER, LEADERBOARD, SKYSCRAPER, INTERSTITIAL, CUSTOM (this is required if a placements is to be created)
        #[clap(value_parser = parse_json::<models::CreateApplicationPlacementSizeParameter>)]
        placement_size: Option<models::CreateApplicationPlacementSizeParameter>,
        /// The height of a custom ad size
        placement_height: Option<i32>,
        /// The width of a custom ad size
        placement_width: Option<i32>,
        /// The refresh interval in seconds
        placement_refresh_interval: Option<i32>,
        /// Generate a custom object store to use
        #[clap(short, long)]
        create_object_store: Option<bool>,
        /// Determine whether or not public content requires admin approval before it becomes public
        #[clap(long)]
        public_content_approval: Option<bool>,
        /// Determines whether the application uses production or sandbox services
        #[clap(long)]
        production_mode: Option<bool>,
        /// Minimum Session Length
        minimum_session_length: Option<i32>,
        /// Session Gap Length
        session_gap_length: Option<i32>,
        /// Local Ads Enabled
        #[clap(short, long)]
        local_ads_enabled: Option<bool>,
        /// Sqoot Api Key
        sqoot_api_key: Option<String>,
        /// Determines how to process trilateration data. Possible values include: DEFAULT, FINGERPRINT
        #[clap(value_parser = parse_json::<models::CreateApplicationTrilatProcessingTypeParameter>)]
        trilat_processing_type: Option<models::CreateApplicationTrilatProcessingTypeParameter>,
        /// Determines what the maximum sample size during trilateration
        max_sample_size: Option<i32>,
        /// Determines what the minimum acceptable RSSI value
        min_rssi: Option<f64>,
        /// List modules allowed to be served by the server, possible values include: COMMON, MEDIA, OFFER, GAME, SOCIAL, CONSUMER_WEBSITE, ALL
        modules: Option<String>,
        /// How many servers the license will support
        authorized_count: Option<i32>,
        /// The list of ip addresses of servers the license will support, leave null for any server
        authorized_servers: Option<String>,
        /// Sets the default timezone for the app (used for leaderboards and other time specific content)
        default_timezone: Option<String>,
        /// SMTP Pass
        smtp_pass: Option<String>,
        /// The application meta data. Defined by the client
        meta_data: Option<String>,
        /// The ad placement meta data. Defined by the client
        placement_meta_data: Option<String>,
        /// Create floor tables for Ips
        #[clap(long)]
        ips_floor: Option<bool>,
        /// Enables setting the APNS badge value in the payload
        #[clap(long)]
        enable_apns_badge: Option<bool>,
        /// Enables using the application in session reports
        #[clap(long)]
        include_in_report: Option<bool>,
        /// Sets the default filter to use (if none is passed in) for certain search APIs including Album Search.
        default_app_filter_id: Option<i64>,
        /// Enables whether the default welcome email will be sent for new app users
        #[clap(long)]
        enable_welcome_email: Option<bool>,
        /// The Apple Application ID
        apple_app_id: Option<String>,
        /// The Apple Team ID
        apple_team_id: Option<String>,
        /// The Apple Auth Key ID
        apple_auth_key_id: Option<String>,
        /// The Apple Auth Signin Key (p8) File
        #[clap(value_parser = parse_json::<swagger::ByteArray>)]
        apple_auth_key: Option<swagger::ByteArray>,
        /// The Apple Issuer ID
        apple_issuer_id: Option<String>,
        /// The Apple App Store Key ID
        app_store_key_id: Option<String>,
        /// The Apple App Store Key (p8) File
        #[clap(value_parser = parse_json::<swagger::ByteArray>)]
        app_store_key: Option<swagger::ByteArray>,
        /// This is the private key file for your Google service account.
        #[clap(value_parser = parse_json::<swagger::ByteArray>)]
        google_private_key_file: Option<swagger::ByteArray>,
        /// Authorize Net Api Key
        authorize_net_api_key: Option<String>,
        /// Authorize Net Transaction Key
        authorize_net_transaction_key: Option<String>,
        /// Email Sender
        email_sender: Option<String>,
        /// SMTP User
        smtp_user: Option<String>,
        /// SMTP Host
        smtp_host: Option<String>,
        /// Vatom Business Id
        vatom_business_id: Option<String>,
        /// Vatom REST Client Id
        vatom_rest_client_id: Option<String>,
        /// Vatom Secret Key
        vatom_rest_secret_key: Option<String>,
        /// Twilio Account SID
        twilio_account_sid: Option<String>,
        /// Twilio Auth Token
        twilio_auth_token: Option<String>,
        /// Twilio Sender Phone Number
        twilio_sender_phone_number: Option<String>,
        /// OpenAI Secret API Key
        open_ai_secret_key: Option<String>,
    },
    /// Change Appliation Status
    UpdateApplicationActive {
        version: f64,
        /// The account used to perform the delete, must have rights to edit the application.
        account_id: i64,
        /// The key of the application to be deleted
        app_key: String,
        /// If true then set to active, false otherwise
        #[clap(long)]
        active: bool,
    },
    /// Update Ad Placement
    UpdateApplicationPlacement {
        version: f64,
        /// The id of the placement to update, the user must have rights to the application the ad placement is for
        placement_id: i64,
        /// The unique id of the device making the request (deviceId or accountId required)
        device_id: Option<String>,
        /// The account id of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// The name of the placement
        name: Option<String>,
        /// The description of the placement
        description: Option<String>,
        /// The ad placement size {BANNER, LEADERBOARD, SKYSCRAPER, INTERSTITIAL, CUSTOM
        #[clap(value_parser = parse_json::<models::CreateApplicationPlacementSizeParameter>)]
        size: Option<models::CreateApplicationPlacementSizeParameter>,
        /// The height of a custom ad size
        height: Option<i32>,
        /// The width of a custom ad size
        width: Option<i32>,
        /// The refresh interval in seconds
        refresh_interval: Option<i32>,
        /// Default Image Id
        default_image_id: Option<i64>,
        /// Active
        #[clap(long)]
        active: Option<bool>,
    },
    /// Create Application Certificate
    UploadApplicationCertificate {
        version: f64,
        /// The key of the application
        app_key: String,
        /// Device Id
        device_id: Option<String>,
        /// The account used to perform the delete, must have rights to edit the application.
        account_id: Option<i64>,
        /// Certificate
        #[clap(value_parser = parse_json::<swagger::ByteArray>)]
        certificate: Option<swagger::ByteArray>,
    },
    /// Create AppConfig
    CreateApplicationConfig {
        version: f64,
        /// The account ID of the user
        account_id: i64,
        /// The application key that the newly created applicationConfig will be associated to
        app_key: String,
        /// The application configuration, has to be unique within the application
        config_version: String,
        /// The json assetId that stores the configuration detail.
        asset_id: i64,
        /// The retailer id for retailer specific configurations
        retailer_id: Option<i64>,
        /// The retailer location id for retailer location specific configurations
        retailer_location_id: Option<i64>,
        /// The device udid for device specific configurations
        udid: Option<String>,
    },
    /// Delete AppConfig
    DeleteApplicationConfig {
        version: f64,
        /// The account ID of the user
        account_id: i64,
        /// The config ID of the application configuration to delete
        config_id: i64,
    },
    /// Get AppConfig
    GetApplicationConfig {
        version: f64,
        /// The account ID of the user
        account_id: i64,
        /// The config ID of the application configuration
        config_id: i64,
    },
    /// Get AppConfig by Version
    GetApplicationConfigByConfigVersion {
        version: f64,
        /// The application key
        app_key: String,
        /// The version of the application configuration
        config_version: String,
        /// Only returns the config that matches the given retailer
        retailer_id: Option<i64>,
        /// Only returns the config that matches the given retailer location
        retailer_location_id: Option<i64>,
        /// Only returns only returns the config that matches the given device udid
        udid: Option<String>,
        /// Determines whether to return older config versions if the exact version is not found. If this happens, will try to return the latest version.
        #[clap(long)]
        allow_older_versions: Option<bool>,
    },
    /// Search AppConfigs
    SearchApplicationConfig {
        version: f64,
        /// The account ID of the user
        account_id: i64,
        /// The application key to filter results by application Leaving this empty will return all application configurations for all applications (executive user only)
        app_key: Option<String>,
        /// Only returns the configs that matches the given retailer
        retailer_id: Option<i64>,
        /// Only returns the configs that matches the given retailer location
        retailer_location_id: Option<i64>,
        /// Only returns only returns the configs that matches the given device udid
        udid: Option<String>,
        /// Config Version
        config_version: Option<String>,
        /// Orders the results by: CREATED, UPDATED, ACTIVE, APPLICATION_ID,  APPLICATION_KEY, APPLICATION_NAME, RETAILER_NAME, RETAILER_ID, RETAILER_LOCATION_NAME,  RETAILER_LOCATION_ID, OFFER_TITLE, OFFER_ID, OFFER_LOCATION_ID, CONFIG_VERSION_MINOR,  CONFIG_VERSION_MAJOR, CONFIG_VERSION_INDEX 
        sort_field: Option<String>,
        /// Determines whether the results are in descending or ascending order
        #[clap(short, long)]
        descending: Option<bool>,
        /// The start index for pagination
        start: Option<i32>,
        /// The limit for pagination (There is a hard limit of 100)
        limit: Option<i32>,
    },
    /// Update AppConfig
    UpdateApplicationConfig {
        version: f64,
        /// The account ID of the user
        account_id: i64,
        /// The config ID of the application configuration to update
        config_id: i64,
        /// The application key that the updated applicationConfig will be associated to
        app_key: Option<String>,
        /// The application configuration, has to be unique within the application
        config_version: Option<String>,
        /// The json assetId that stores the configuration detail.
        asset_id: Option<i64>,
        /// The retailer id for retailer specific configurations
        retailer_id: Option<i64>,
        /// The retailer location id for retailer location specific configurations
        retailer_location_id: Option<i64>,
        /// The device udid for device specific configurations
        udid: Option<String>,
    },
    /// Convert Offer to Creative
    AssetMorph {
        version: f64,
        /// offer id used for inserting offer text/flavor
        offer_id: i64,
        /// the ad size used for selecting a format for the creative image
        #[clap(value_parser = parse_json::<models::CreateApplicationPlacementSizeParameter>)]
        ad_size: models::CreateApplicationPlacementSizeParameter,
        /// used for inserting the newly created image into
        creative_id: Option<i64>,
        /// total width of the creative image
        width: Option<i32>,
        /// total height of the creative image
        height: Option<i32>,
        /// the size of the background
        background_size: Option<String>,
        /// the template to use
        template: Option<String>,
    },
    /// Create Asset
    CreateAsset {
        version: f64,
        /// to return nulls
        #[clap(short, long)]
        return_nulls: Option<bool>,
        /// a unique ID given by the device (deviceId or accountId required)
        device_id: Option<String>,
        /// the account ID of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// the album the asset will be added to (optional)
        album_id: Option<i64>,
        /// Deprecated: use collections via the collection endpoints.
        collection_id: Option<i64>,
        /// Whether to add to a default album
        add_to_default_album: Option<String>,
        /// Whether to add to the media library
        #[clap(long)]
        add_to_media_library: Option<bool>,
        /// the version code
        version_code: Option<i32>,
        /// the version name
        version_name: Option<String>,
        /// External custom client defined data
        meta_data: Option<String>,
        /// the caption (optional)
        caption: Option<String>,
        /// the asset type
        asset_type: Option<String>,
        /// approval status for the asset
        approval_status: Option<String>,
        /// account id assigned to the asset
        assigned_account_id: Option<i64>,
        /// a MultipartFile containing the mimetype, etc
        #[clap(value_parser = parse_json::<swagger::ByteArray>)]
        media: Option<swagger::ByteArray>,
        /// this can be used if the \"media\" is a link (optional)
        media_url: Option<String>,
        /// the media content as a string (optional)
        media_string: Option<String>,
        /// file name for mediaString (optional)
        media_string_file_name: Option<String>,
        /// content type for mediaString (optional)
        media_string_content_type: Option<String>,
        /// the media height (optional)
        media_height: Option<i32>,
        /// the media width (optional)
        media_width: Option<i32>,
        /// a MultipartFile containing an asset that the \"media\" file references (optional). Example: to upload a video the \"media\" file should contain a screen capture and the \"attachedMedia\" should be the actual video.
        #[clap(value_parser = parse_json::<swagger::ByteArray>)]
        attached_media: Option<swagger::ByteArray>,
        /// this can be used if the \"attachedMedia\" is a link (i.e. a Youtube video, etc) (optional)
        attached_media_url: Option<String>,
        /// attached media content as a string (optional)
        attached_media_string: Option<String>,
        /// file name for attachedMediaString (optional)
        attached_media_string_file_name: Option<String>,
        /// content type for attachedMediaString (optional)
        attached_media_string_content_type: Option<String>,
        /// the attached media height (optional)
        attached_media_height: Option<i32>,
        /// the attached media width (optional)
        attached_media_width: Option<i32>,
        /// the location description (optional)
        location_description: Option<String>,
        /// Deprecated: app parameter
        app: Option<String>,
        /// the application key
        app_key: Option<String>,
        /// the search tags
        search_tags: Option<String>,
        /// the latitude (optional)
        latitude: Option<f64>,
        /// the longitude (optional)
        longitude: Option<f64>,
    },
    /// Delete Asset
    DeleteAsset {
        version: f64,
        /// the id of the asset to delete
        asset_id: String,
        /// the device id (deviceId or accountId required)
        device_id: Option<String>,
        /// the account id of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// latitude used to update the user's current location
        latitude: Option<f64>,
        /// longitude used to update the user's current location
        longitude: Option<f64>,
    },
    /// Get Asset
    GetAsset {
        version: f64,
        /// the asset ID
        asset_id: i64,
        /// a unique ID given by the device (deviceId or accountId required)
        device_id: Option<String>,
        /// the account ID of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// determines whether the notes on the asset are in descending order
        #[clap(short, long)]
        note_descending: Option<bool>,
    },
    /// Remove Asset from Collection
    RemoveAsset {
        version: f64,
        /// the id of the asset to remove
        asset_id: String,
        /// the device id (deviceId or accountId required)
        device_id: Option<String>,
        /// the account id of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// the album id to remove the asset from
        album_id: Option<i64>,
        /// the collection id to remove the asset from
        collection_id: Option<i64>,
        /// remove from the user's profile album
        #[clap(short, long)]
        remove_from_default_albums: Option<bool>,
        /// latitude used to update the user's current location
        latitude: Option<f64>,
        /// longitude used to update the user's current location
        longitude: Option<f64>,
    },
    /// Search Assets
    SearchAssets {
        version: f64,
        /// a unique ID given by the device (deviceId or accountId required)
        device_id: Option<String>,
        /// the account ID of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// comma separated list of album ids to search on
        album_ids: Option<String>,
        /// comma separated list of asset ids to search on
        asset_ids: Option<String>,
        /// the application key to filter results by application.
        app_key: Option<String>,
        /// filter results by media type. Possible values include: APPLICATION, IMAGE, AUDIO, VIDEO, MULTIPART, TEXT
        media_type: Option<String>,
        /// filter results by mime type
        mime_type: Option<String>,
        /// keyword search string
        keyword: Option<String>,
        /// filter results by version code
        version_code: Option<i32>,
        /// filter results by version name
        version_name: Option<String>,
        /// return items that have been updated since this date (time-stamp in milliseconds)
        updated_since: Option<i64>,
        /// return items that have been updated before this date (time-stamp in milliseconds)
        updated_before: Option<i64>,
        /// the field to sort by. See AssetApiMap
        sort_field: Option<String>,
        /// determines whether the sorted list is in descending or ascending order
        #[clap(short, long)]
        descending: Option<bool>,
        /// determines whether to search on the media library album
        #[clap(short, long)]
        search_media_library: Option<bool>,
        /// filter results by billable entity
        #[clap(long)]
        filter_by_billable: Option<bool>,
        /// if only searching for active assets
        #[clap(long)]
        active_only: Option<bool>,
        /// determines whether to include the application response as part of the asset response
        #[clap(short, long)]
        return_app: Option<bool>,
        /// the start index for pagination
        start: Option<i32>,
        /// the limit for pagination (there is a hard limit of 200)
        limit: Option<i32>,
        /// search mode for index (SearchIndexMode)
        search_mode: Option<String>,
        /// filter by asset type
        asset_type: Option<String>,
        /// filter by approval status
        approval_status: Option<String>,
        /// filter results by an assigned account id
        assigned_account_id: Option<i64>,
    },
    /// Update Asset
    UpdateAsset {
        version: f64,
        /// the ID of the asset to update
        asset_id: i64,
        /// a unique ID given by the device (deviceId or accountId required)
        device_id: Option<String>,
        /// the account ID of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// the ID of the album to check user permissions
        album_id: Option<i64>,
        /// the ID of the attached asset
        attached_asset_id: Option<i64>,
        /// the version code
        version_code: Option<i32>,
        /// the version name
        version_name: Option<String>,
        /// External custom client defined data
        meta_data: Option<String>,
        /// the caption
        caption: Option<String>,
        /// the asset type
        asset_type: Option<String>,
        /// approval status for the asset
        approval_status: Option<String>,
        /// account id assigned to the asset
        assigned_account_id: Option<i64>,
        /// a MultipartFile containing the mimetype, etc
        #[clap(value_parser = parse_json::<swagger::ByteArray>)]
        media: Option<swagger::ByteArray>,
        /// this can be used if the \"media\" is a link (optional)
        media_url: Option<String>,
        /// the media content as a string (optional)
        media_string: Option<String>,
        /// file name for mediaString (optional)
        media_string_file_name: Option<String>,
        /// content type for mediaString (optional)
        media_string_content_type: Option<String>,
        /// the media height (optional)
        media_height: Option<i32>,
        /// the media width (optional)
        media_width: Option<i32>,
        /// a MultipartFile containing an asset that the \"media\" file references (optional). Example: to upload a video the \"media\" file should contain a screen capture and the \"attachedMedia\" should be the actual video.
        #[clap(value_parser = parse_json::<swagger::ByteArray>)]
        attached_media: Option<swagger::ByteArray>,
        /// this can be used if the \"attachedMedia\" is a link (i.e. a Youtube video, etc) (optional)
        attached_media_url: Option<String>,
        /// attached media content as a string (optional)
        attached_media_string: Option<String>,
        /// file name for attachedMediaString (optional)
        attached_media_string_file_name: Option<String>,
        /// content type for attachedMediaString (optional)
        attached_media_string_content_type: Option<String>,
        /// the attached media height (optional)
        attached_media_height: Option<i32>,
        /// the attached media width (optional)
        attached_media_width: Option<i32>,
        /// the location description
        location_description: Option<String>,
        /// search tags
        search_tags: Option<String>,
        /// the application key
        app_key: Option<String>,
        /// latitude used to update the asset's location
        latitude: Option<f64>,
        /// longitude used to update the asset's location
        longitude: Option<f64>,
    },
    /// Download Asset
    AssetDownload {
        version: f64,
        /// the filename in the following formats: {assetId}-{suffix}.{extension} | {assetId}.{extension} | {assetId}
        filename: String,
    },
    /// Search Assignment Assignees
    AssigmentAssigneeAccountSearch {
        version: f64,
        /// The account id sending the request
        account_id: i64,
        /// The keyword to filter the returned results
        keyword: Option<String>,
    },
    /// Create Assignment
    AssignmentCreate {
        version: f64,
        /// the user account id
        account_id: i64,
        /// the name for the assignment
        name: String,
        /// the account id to assign to
        assignee_account_id: i64,
        /// the desciprtion for the assignment
        description: Option<String>,
        /// the retailer location id
        retailer_location_id: Option<i64>,
        /// the tags
        tags: Option<String>,
        /// determines whether the assignment is active or inactive
        #[clap(long)]
        active: Option<bool>,
    },
    /// Delete Assignment
    AssignmentDelete {
        version: f64,
        /// the user account id
        account_id: i64,
        /// the assignment id
        assignment_id: i64,
    },
    /// Get Assignment
    AssignmentGet {
        version: f64,
        /// the user account id
        account_id: i64,
        /// the assignment id
        assignment_id: i64,
    },
    /// Search Assignments
    AssignmentSearch {
        version: f64,
        /// the account sending the request
        account_id: i64,
        /// sort by table field
        #[clap(value_parser = parse_json::<models::AssignmentSearchSortFieldParameter>)]
        sort_field: models::AssignmentSearchSortFieldParameter,
        /// return results in descending order or not
        #[clap(short, long)]
        descending: bool,
        /// return active results only or not
        #[clap(long)]
        active_only: bool,
        /// The record to begin the return set on
        start: i32,
        /// The number of records to return
        limit: i32,
        /// the creator of the assignment
        creator_account_id: Option<i64>,
        /// filter results by assignee accounts. If not provided, all assignments that are assigned to accounts that are managed by the requested account will be returned.
        assignee_account_ids: Option<String>,
        /// filter results by retailer locations
        retailer_location_ids: Option<String>,
        /// filter results by assignment status
        #[clap(value_parser = parse_json::<models::AssignmentSearchCurrentStatusTypeParameter>)]
        current_status_type: Option<models::AssignmentSearchCurrentStatusTypeParameter>,
        /// filter results by keyword search that matches the assignee, creator, or retailer location name
        keyword: Option<String>,
    },
    /// Create Assignment Status
    AssignmentStatusCreate {
        version: f64,
        /// the user account id
        account_id: i64,
        /// the assignment id
        assignment_id: i64,
        /// the scheduled notification id for reminders
        scheduled_notification_id: Option<i64>,
        /// the type of to do. Possible values include: SITE_VISIT, PHONE, RECONTACT, RENEWAL, CREDIT
        #[clap(value_parser = parse_json::<models::AssignmentStatusCreateToDoParameter>)]
        to_do: Option<models::AssignmentStatusCreateToDoParameter>,
        /// the connection type. Possible values include: INITIAL, FOLLOW_UP, DECLINED
        #[clap(value_parser = parse_json::<models::AssignmentStatusCreateConnectionParameter>)]
        connection: Option<models::AssignmentStatusCreateConnectionParameter>,
        /// the communication method type. Possible values include: PHONE, SITE_VISIT, EMAIL
        #[clap(value_parser = parse_json::<models::AssignmentStatusCreateMethodParameter>)]
        method: Option<models::AssignmentStatusCreateMethodParameter>,
        /// the status type. Possible values include: ARCHIVED, SUBSCRIBED, UNSUBSCRIBED, CONTACTED, DECLINED, NOT_CONTACTED
        #[clap(value_parser = parse_json::<models::AssignmentStatusCreateStatusParameter>)]
        status: Option<models::AssignmentStatusCreateStatusParameter>,
        /// the closure type. Possible values include: PHONE, SITE_VISIT, PHONE_SITE, WEB
        #[clap(value_parser = parse_json::<models::AssignmentStatusCreateClosureParameter>)]
        closure: Option<models::AssignmentStatusCreateClosureParameter>,
        /// the message from the assignee
        message: Option<String>,
        /// the date to follow up by
        follow_up: Option<i64>,
        /// determines whether the assignment status is active or inactive
        #[clap(long)]
        active: Option<bool>,
    },
    /// Deletes Assignment Status
    AssignmentStatusDelete {
        version: f64,
        /// the user account id
        account_id: i64,
        /// the assignment status id
        assignment_status_id: i64,
    },
    /// Get Assignment Status
    AssignmentStatusGet {
        version: f64,
        /// the user account id
        account_id: i64,
        /// the assignment status id
        assignment_status_id: i64,
    },
    /// Search Assignment Statuses
    AssignmentStatusSearch {
        version: f64,
        /// the user account id
        account_id: i64,
        /// the field to sort by. Possible values include: ID, CREATED, UPDATED, DELETED, SEARCH_TAGS, ACTIVE, CURRENT_STATUS, TODO, CONNECTION, METHOD, STATUS, CLOSURE, MESSAGE, FOLLOW_UP
        #[clap(value_parser = parse_json::<models::AssignmentStatusSearchSortFieldParameter>)]
        sort_field: models::AssignmentStatusSearchSortFieldParameter,
        /// determines whether the sorted list is in descending or ascending order
        #[clap(short, long)]
        descending: bool,
        /// determines whether to only return active results
        #[clap(long)]
        active_only: bool,
        /// the start index for pagination
        start: i32,
        /// the limit for pagination
        limit: i32,
        /// the assignment id
        assignment_id: Option<i64>,
        /// filter results by the account who created the status
        creator_account_id: Option<i64>,
        /// filter results by the assignee account
        assignee_account_id: Option<i64>,
        /// filter results by by retailer location
        retailer_location_id: Option<i64>,
        /// filter results by the status type
        #[clap(value_parser = parse_json::<models::AssignmentStatusCreateStatusParameter>)]
        status_type: Option<models::AssignmentStatusCreateStatusParameter>,
        /// filter results by keyword search
        keyword: Option<String>,
    },
    /// Update Assignment Status
    AssignmentStatusUpdate {
        version: f64,
        /// the user account id
        account_id: i64,
        /// the assignment status id
        assignment_status_id: i64,
        /// the scheduled notification id for reminders
        scheduled_notification_id: Option<i64>,
        /// the type of to do. Possible values include: SITE_VISIT, PHONE, RECONTACT, RENEWAL, CREDIT
        #[clap(value_parser = parse_json::<models::AssignmentStatusCreateToDoParameter>)]
        to_do: Option<models::AssignmentStatusCreateToDoParameter>,
        /// the connection type. Possible values include: INITIAL, FOLLOW_UP, DECLINED
        #[clap(value_parser = parse_json::<models::AssignmentStatusCreateConnectionParameter>)]
        connection: Option<models::AssignmentStatusCreateConnectionParameter>,
        /// the communication method type. Possible values include: PHONE, SITE_VISIT, EMAIL
        #[clap(value_parser = parse_json::<models::AssignmentStatusCreateMethodParameter>)]
        method: Option<models::AssignmentStatusCreateMethodParameter>,
        /// the status type. Possible values include: ARCHIVED, SUBSCRIBED, UNSUBSCRIBED, CONTACTED, DECLINED, NOT_CONTACTED
        #[clap(value_parser = parse_json::<models::AssignmentStatusCreateStatusParameter>)]
        status: Option<models::AssignmentStatusCreateStatusParameter>,
        /// the closure type. Possible values include: PHONE, SITE_VISIT, PHONE_SITE, WEB
        #[clap(value_parser = parse_json::<models::AssignmentStatusCreateClosureParameter>)]
        closure: Option<models::AssignmentStatusCreateClosureParameter>,
        /// the message from the assignee
        message: Option<String>,
        /// the date to follow up by
        follow_up: Option<i64>,
        /// determines whether the assignment status is active or inactive
        #[clap(long)]
        active: Option<bool>,
    },
    /// Update Assignment
    AssignmentUpdate {
        version: f64,
        /// the user account id
        account_id: i64,
        /// the assignment id
        assignment_id: i64,
        /// the name of the assignment
        name: Option<String>,
        /// the description of the assignment
        description: Option<String>,
        /// the account id to assign to
        assignee_account_id: Option<i64>,
        /// the retailer location id
        retailer_location_id: Option<i64>,
        /// the tags
        tags: Option<String>,
        /// determines whether the assignment is active or inactive
        #[clap(long)]
        active: Option<bool>,
    },
    /// Create Audience
    CreateAudience {
        version: f64,
        /// The logged in user.
        account_id: i64,
        /// The name of the audience
        name: String,
        /// The description of the audience
        description: Option<String>,
        /// The search tags
        search_tags: Option<String>,
        /// The gender; possible values are: MALE, FEMALE, ANY
        gender: Option<String>,
        /// The list of age groups, comma separated; possible values are AGE_0_13, AGE_14_17, AGE_18_22, AGE_23_30, AGE_31_54, AGE_55_PLUS, AGE_ANY (to reset to none)
        age_groups: Option<String>,
        /// The list of category ids, comma separated; possible values are retrieved via /api/{version}/category/search (pass in id values)
        category_ids: Option<String>,
        /// The list of application ids, comma separated; possible values are retrieved via /api/{version}/application/list (pass in id values)
        application_ids: Option<String>,
        /// The experience level of the player; possible values are: ANY, NEW, BEGINNER, INTERMEDIATE, EXPERT
        game_experience_level: Option<String>,
        /// (Deprecated) Use deviceIds. The list of targeted device names, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in name values)
        devices: Option<String>,
        /// The list of targeted device ids, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in id values)
        device_ids: Option<String>,
        /// The list of targeted device version ranges that are aligned with the provided devices list, comma separated (examples: 2.3-X, 0-5.1.4, 4.3.1-6.1.4)
        device_versions: Option<String>,
        /// The list of locations to build the center around; comma separated list of latitude/longitude pairs (example: lat1,long1,lat2,long2)
        locations: Option<String>,
        /// The list of radius of influence for the audience, in miles; comma separated list. Either provide 1 to be applied to all location pairs or a matching list to each lat/long pair.
        radius: Option<String>,
        /// Seconds from the start time of an event
        start_time_offset: Option<i32>,
        /// Seconds from the end time of an event
        end_time_offset: Option<i32>,
        /// If true, then notify matching users when they are inside the radius
        #[clap(short, long)]
        send_suggestion: Option<bool>,
        /// The description of the associated object
        associate_description: Option<String>,
        /// The type of the object to center the audience geofence
        associate_type: Option<String>,
        /// The ID of the object to center the audience geofence
        associate_id: Option<i64>,
        /// Optional grouping id for the audience
        grouping_id: Option<String>,
        /// External custom client defined data
        meta_data: Option<String>,
        /// Visibility of the audience
        visibility: Option<String>,
        /// Type of audience
        audience_type: Option<String>,
        /// Use order for cohort
        #[clap(long)]
        use_order: Option<bool>,
        /// Cohort data for \"cohort\" audience type
        cohort_regions_data: Option<String>,
        /// Filter results by application key
        app_key: Option<String>,
        /// Trilateration types
        trilateration_types: Option<String>,
        /// If true, makes sure the audience name is unique
        #[clap(long)]
        unique_name: Option<bool>,
    },
    /// Delete Audience
    DeleteAudience {
        version: f64,
        /// The logged in user.
        account_id: i64,
        /// The id of the audience to delete.
        audience_id: i64,
    },
    /// Get Age Groups
    GetAgeGroups {
        version: f64,
    },
    /// Get Audience
    GetAudience {
        version: f64,
        /// The logged in user.
        account_id: i64,
        /// The id of the audience to return.
        audience_id: i64,
        /// The application key (optional). If provided, results may be scoped to this application.
        app_key: Option<String>,
        /// (boolean) set to true to include the accountCount associated with current audience of the current app
        #[clap(long)]
        return_account_count: Option<bool>,
        /// (boolean) set to true to include the albumCount associated with current audience of the current app
        #[clap(long)]
        return_album_count: Option<bool>,
        /// (String) comma separated list, return an array with each item is the count of each album type. If not provided, \"all_types\" count is returned.
        album_types_for_count: Option<String>,
    },
    /// Search Audiences
    GetAudienceList {
        version: f64,
        /// The logged in user.
        account_id: Option<i64>,
        /// Comma separated list of album IDs to filter results with
        album_ids: Option<String>,
        /// The keyword used to search
        keyword: Option<String>,
        /// Comma separated list of fields that the keywords will match against. Possible values include: SEARCH_TAGS, NAME, DESCRIPTION, OWNER_DISPLAY
        keyword_fields: Option<String>,
        /// The field to sort by, possible values include: {ID, CREATED, UPDATED, DELETED, SEARCH_TAGS, ACTIVE, NAME, DESCRIPTION, OWNER_ID, OWNER_DISPLAY, GENDER}
        #[clap(value_parser = parse_json::<models::GetAudienceListSortFieldParameter>)]
        sort_field: Option<models::GetAudienceListSortFieldParameter>,
        /// The order to return the results. Default is false, which will return the results in ascending order.
        #[clap(short, long)]
        descending: Option<bool>,
        /// The index into the record set to start with.
        start: Option<i32>,
        /// The total number of record to return (there is a hard limit of 100).
        limit: Option<i32>,
        /// Filter results based on whether or not the audience is set to send suggestions
        #[clap(short, long)]
        send_suggestion: Option<bool>,
        /// Determines whether to return only active results. Default is false.
        #[clap(long)]
        active_only: Option<bool>,
        /// Groups results by the audience groupingId (this does not work in conjunction with the following parameters: albumIds, audienceType, appKey, returnGlobal)
        #[clap(short, long)]
        group_by_grouping_id: Option<bool>,
        /// Filter results by application key
        app_key: Option<String>,
        /// If filtering by appKey, determines whether or not audiences that do not have an application set will also be returned as well
        #[clap(long)]
        return_global: Option<bool>,
        /// If true, match keyword exactly
        #[clap(short, long)]
        exact_keyword: Option<bool>,
        /// (Deprecated) Filter results by audience type
        audience_type: Option<String>,
        /// comma separated string with the different audience types you want to filter for
        audience_types: Option<String>,
        /// (boolean) set to true to include the accountCount associated with current audience of the current app
        #[clap(long)]
        return_account_count: Option<bool>,
        /// (boolean) set to true to include the albumCount associated with current audience of the current app
        #[clap(long)]
        return_album_count: Option<bool>,
        /// (String) comma separated list, return an array with each item is the count of each album type. If not provided, \"all_types\" count is returned.
        album_types_for_count: Option<String>,
    },
    /// Get Devices
    GetDevices {
        version: f64,
        /// If true return inactive record as well. default is false.
        #[clap(short, long)]
        include_inactive: bool,
    },
    /// Get Experiences
    GetExperiences {
        version: f64,
    },
    /// Get GroupedAudiences
    GetGroupedAudiences {
        version: f64,
        /// The logged in user.
        account_id: i64,
        /// The audience grouping id to return.
        audience_grouping_id: String,
    },
    /// List Suggestions by Audience
    ListByAccount {
        version: f64,
        /// The account to match offers for.
        account_id: i64,
        /// the limit of the index
        limit: i32,
        /// the type of suggestion
        suggestion_type: String,
    },
    /// List Offers by Audience
    ListByAudience {
        version: f64,
        /// this is the limit of the index
        limit: i32,
        /// this is the gender to list offers by
        gender: Option<String>,
        /// this is the age to list offers by
        age: Option<i32>,
        /// this is the category IDs to list offers by
        category_ids: Option<String>,
        /// this is the latitude to list offers by
        latitude: Option<f64>,
        /// this is the longitude to list offers by
        longitude: Option<f64>,
    },
    /// List Sent Suggestions 
    ListLastestByAccount {
        version: f64,
        /// The account to match offers for.
        account_id: i64,
        /// The timeframe in seconds of the latest suggestions
        timeframe: i32,
        /// The type of trigger suggestions to return
        suggestion_type: String,
    },
    /// Send Suggestions
    SendByAccount {
        version: f64,
        /// The account to match offers for.
        account_id: i64,
        /// the latitude
        latitude: f64,
        /// the longitude
        longitude: f64,
    },
    /// Update Audience
    UpdateAudience {
        version: f64,
        /// The logged in user.
        account_id: i64,
        /// The id of the audience to update.
        audience_id: i64,
        /// The name of the audience
        name: Option<String>,
        /// The description of the audience
        description: Option<String>,
        /// The search tags
        search_tags: Option<String>,
        /// The gender; possible values are: MALE, FEMALE, ANY
        gender: Option<String>,
        /// The list of age groups, comma separated; possible values are AGE_0_13, AGE_14_17, AGE_18_22, AGE_23_30, AGE_31_54, AGE_55_PLUS, AGE_ANY (to reset to none)
        age_groups: Option<String>,
        /// The list of category ids, comma separated; possible values are retrieved via /api/{version}/category/search (pass in id values)
        category_ids: Option<String>,
        /// The list of application ids, comma separated; possible values are retrieved via /api/{version}/application/list (pass in id values)
        application_ids: Option<String>,
        /// The experience level of the player; possible values are: ANY, NEW, BEGINNER, INTERMEDIATE, EXPERT
        game_experience_level: Option<String>,
        /// (Deprecated) Use deviceIds. The list of targeted device names, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in name values)
        devices: Option<String>,
        /// The list of targeted device ids, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in id values)
        device_ids: Option<String>,
        /// The list of targeted device version ranges that are aligned with the provided devices list, comma separated (examples: 2.3-X, 0-5.1.4, 4.3.1-6.1.4)
        device_versions: Option<String>,
        /// The list of locations to build the center around; comma separated list of latitude/longitude pairs (example: lat1,long1,lat2,long2)
        locations: Option<String>,
        /// The list of radius of influence for the audience, in miles; comma separated list. Either provide 1 to be applied to all location pairs or a matching list to each lat/long pair.
        radius: Option<String>,
        /// if audience is active
        #[clap(long)]
        active: Option<bool>,
        /// If true, then notify matching users when they are inside the radius
        #[clap(short, long)]
        send_suggestion: Option<bool>,
        /// Seconds from the start time of an event
        start_time_offset: Option<i32>,
        /// Seconds from the end time of an event
        end_time_offset: Option<i32>,
        /// the associate description
        associate_description: Option<String>,
        /// The type of the object to center the audience geofence
        associate_type: Option<String>,
        /// The ID of the object to center the audience geofence
        associate_id: Option<i64>,
        /// Optional grouping id for the audience
        grouping_id: Option<String>,
        /// External custom client defined data
        meta_data: Option<String>,
        /// Visibility of the audience
        visibility: Option<String>,
        /// Type of audience
        audience_type: Option<String>,
        /// Use order for cohort
        #[clap(long)]
        use_order: Option<bool>,
        /// Cohort data for \"cohort\" audience type
        cohort_regions_data: Option<String>,
        /// Filter results by application key
        app_key: Option<String>,
        /// Trilateration types
        trilateration_types: Option<String>,
        /// If true, makes sure the audience name is unique
        #[clap(long)]
        unique_name: Option<bool>,
    },
    /// Create Bid
    CreateBid {
        version: f64,
        /// A biddable object type. Possible values include: CREATIVE (ads).
        biddable_type: String,
        /// The id of the biddable object
        biddable_id: i64,
        /// The bid amount for views. For ads, this is the amount that will be taken for each impression.
        amount_per_view: f64,
        /// The bid amount for actions. For ads, this is the amount that will be taken for each click.
        amount_per_action: f64,
        /// The allocated budget amount that will be used
        budget_amount: f64,
        /// The schedule for when the allocated budget amount is reset
        budget_schedule: String,
        /// The device id (deviceId or accountId required)
        device_id: Option<String>,
        /// The account id of the user (deviceId or accountId required)
        account_id: Option<i64>,
    },
    /// Delete Bid
    DeleteBid {
        version: f64,
        /// The bid id
        bid_id: i64,
        /// The device id (deviceId or accountId required)
        device_id: Option<String>,
        /// The account id of the user (deviceId or accountId required)
        account_id: Option<i64>,
    },
    /// Get Bid
    GetBid {
        version: f64,
        /// The bid id
        bid_id: i64,
        /// The device id (deviceId or accountId required)
        device_id: Option<String>,
        /// The account id of the user (deviceId or accountId required)
        account_id: Option<i64>,
    },
    /// Update Bid
    UpdateBid {
        version: f64,
        /// The bid id
        bid_id: i64,
        /// The device id (deviceId or accountId required)
        device_id: Option<String>,
        /// The account id of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// The bid amount for views. For ads, this is the amount that will be taken for each impression.
        amount_per_view: Option<f64>,
        /// The bid amount for actions. For ads, this is the amount that will be taken for each click.
        amount_per_action: Option<f64>,
        /// The allocated budget amount that will be used
        budget_amount: Option<f64>,
        /// The schedule for when the allocated budget amount is reset
        budget_schedule: Option<String>,
    },
    /// Create Billable
    CreateBillableEntity {
        version: f64,
        /// The unique device identifier that made the request (either deviceId or accountId must be used)
        device_id: Option<String>,
        /// The unique accountId that made the request (either deviceId or accountId must be used)
        account_id: Option<i64>,
        /// The name of the entity responsible for billing 
        name: Option<String>,
        /// The street address of the billable entity
        street_address: Option<String>,
        /// Additional address information (such as a suite number, floor number, building name, or PO Box) 
        street_address2: Option<String>,
        /// The city of the billable entity
        city: Option<String>,
        /// The state of the billable entity
        state: Option<String>,
        /// The postal code of the billable entity
        postal_code: Option<String>,
        /// The business phone of the billable entity
        business_phone: Option<String>,
        /// The business phone extension
        business_phone_ext: Option<String>,
        /// Authorize Net Api Key
        authorize_net_api_key: Option<String>,
        /// Authorize Net Transaction Key
        authorize_net_transaction_key: Option<String>,
    },
    /// Delete Billable
    DeleteBillableEntity {
        version: f64,
        /// The device id (deviceId or accountId required)
        device_id: Option<String>,
        /// The account used to perform the delete, must have rights to edit the billable entity.
        account_id: Option<i64>,
    },
    /// Get Billable
    GetBillableEntity {
        version: f64,
        /// The unique device identifier that made the request (either deviceId or accountId must be used)
        device_id: Option<String>,
        /// The unique accountId that made the request (either deviceId or accountId must be used)
        account_id: Option<i64>,
        /// Determines whether to include the retailer dash board counts into the response
        #[clap(long)]
        include_counts: Option<bool>,
        /// Whether to enable payments or not
        #[clap(long)]
        include_payments: Option<bool>,
    },
    /// Update Billable
    UpdateBillableEntity {
        version: f64,
        /// The unique device identifier that made the request (either deviceId or accountId must be used)
        device_id: Option<String>,
        /// The unique accountId that made the request (either deviceId or accountId must be used). The account must have rights to edit the billable entity.
        account_id: Option<i64>,
        /// The name of the entity responsible for billing 
        name: Option<String>,
        /// The street address of the billable entity
        street_address: Option<String>,
        /// Additional address information (such as a suite number, floor number, building name, or PO Box) 
        street_address2: Option<String>,
        /// The city of the billable entity
        city: Option<String>,
        /// The state of the billable entity
        state: Option<String>,
        /// The postal code of the billable entity
        postal_code: Option<String>,
        /// The business phone of the billable entity
        business_phone: Option<String>,
        /// The business phone extension of the billable entity
        business_phone_ext: Option<String>,
        /// Authorize Net Api Key of the billable entity
        authorize_net_api_key: Option<String>,
        /// Authorize Net Transaction Key of the billable entity
        authorize_net_transaction_key: Option<String>,
    },
    /// Update Payment Method
    AddPaymentMethod {
        version: f64,
        /// The account used to perform the the request
        account_id: i64,
        /// Payment Method Id
        payment_method_id: Option<i64>,
        /// the name of the account
        account_name: Option<String>,
        /// First Name that the account is filed as
        first_name: Option<String>,
        /// Last Name that the account is filed as
        last_name: Option<String>,
        /// Address that the account is filed as
        address: Option<String>,
        /// City that the account is filed as
        city: Option<String>,
        /// State that the account is filed as
        state: Option<String>,
        /// Postal Code that the account is filed as
        postal_code: Option<String>,
        /// Country that the account is filed as
        country: Option<String>,
        /// Phone that the account is filed as
        phone: Option<String>,
        /// The full credit card number to store on file
        credit_card_number: Option<String>,
        /// The credit card expiration date YYYY-MM
        expiration_date: Option<String>,
        /// The 3 digit confirmation code
        ccv: Option<String>,
        /// The bank account number
        account_number: Option<String>,
        /// The bank name
        bank_name: Option<String>,
        /// Routing Number
        routing_number: Option<String>,
        /// Default Payment Method
        #[clap(short, long)]
        default_payment_method: Option<bool>,
        /// Payment Method Nickname
        payment_method_nickname: Option<String>,
        /// Tax Id
        tax_id: Option<String>,
        /// Provider customer profile Id
        provider_customer_profile_id: Option<String>,
        /// Provider customer payment profile Id
        provider_payment_profile_id: Option<String>,
        /// Meta Data
        meta_data: Option<String>,
    },
    /// Create Payment Method
    CreatePaymentMethod {
        version: f64,
        /// The account used to perform the the request
        account_id: i64,
        /// Account Name of the credit card user
        account_name: Option<String>,
        /// The first name on the credit card
        first_name: Option<String>,
        /// The last name on the credit card
        last_name: Option<String>,
        /// The billing address of the credit card
        address: Option<String>,
        /// The billing city of the credit card
        city: Option<String>,
        /// The billing state of the credit card
        state: Option<String>,
        /// The billing zip code of the credit card
        postal_code: Option<String>,
        /// Country of the credit card
        country: Option<String>,
        /// The billing phone of the credit card
        phone: Option<String>,
        /// The full credit card number to store on file
        credit_card_number: Option<String>,
        /// The credit card expiration date YYYY-MM
        expiration_date: Option<String>,
        /// The 3 digit confirmation code
        ccv: Option<String>,
        /// The bank account number
        account_number: Option<String>,
        /// The bank name
        bank_name: Option<String>,
        /// The bank routing number
        routing_number: Option<String>,
        /// The nickname to give the payment method
        payment_method_nickname: Option<String>,
        /// Tax Id
        tax_id: Option<String>,
        /// Whether this should be the default payment method
        #[clap(short, long)]
        default_payment_method: Option<bool>,
        /// An authorization token for providers that provide this (like Amazon Payments)
        auth_token: Option<String>,
        /// The payment provider (see PaymentMethodProvider)
        provider: Option<String>,
        /// Provider customer profile Id
        provider_customer_profile_id: Option<String>,
        /// Provider customer payment profile Id
        provider_payment_profile_id: Option<String>,
        /// Meta Data
        meta_data: Option<String>,
        /// Application Key
        app_key: Option<String>,
    },
    /// Create Smart Contract
    CreateSmartContract {
        version: f64,
        /// The account used to perform the the request
        account_id: i64,
        /// The token name
        token_name: String,
        /// The token symbol
        token_symbol: String,
        /// The payment method to return details on. If this is not set, then the user's default payment method will be returned.
        payment_method_id: Option<i64>,
    },
    /// Get Crypto Balances
    GetCryptoBalance {
        version: f64,
        /// The account used to perform the the request
        account_id: i64,
        /// The account to retreive balances for
        owner_account_id: Option<i64>,
        /// The payment method to return details on. If this is not set, then the user's default payment method will be returned.
        payment_method_id: Option<i64>,
    },
    /// Get Payment Method
    GetPaymentMethod {
        version: f64,
        /// The account used to perform the the request
        account_id: i64,
        /// The payment method to return details on. If this is not set, then the user's default payment method will be returned.
        payment_method_id: Option<i64>,
        /// Determines whether to get the user's current balance for the requested payment method option (not all payment method options support this)
        #[clap(short, long)]
        get_current_balance: Option<bool>,
    },
    /// Search Payment Methods
    SearchPaymentMethod {
        version: f64,
        /// Account Id to search on
        account_id: i64,
        /// Provider to search on
        provider: Option<String>,
        /// the type to search on
        param_type: Option<String>,
        /// the keyword to search on
        keyword: Option<String>,
        /// the sort field to use for the search
        sort_field: Option<String>,
        /// if the results should be in descending order
        #[clap(short, long)]
        descending: Option<bool>,
        /// the start of the search
        start: Option<i32>,
        /// the limit of the search
        limit: Option<i32>,
    },
    /// Detail Status
    GetStatusCsv {
        version: f64,
        /// the id of the logged in user
        account_id: i64,
        /// the id of the batch
        batch_id: i64,
        /// The group of categories to return: SUMMARY, DETAILS, ERRORS, OR ALL
        #[clap(value_parser = parse_json::<models::GetStatusCsvResponseGroupParameter>)]
        response_group: models::GetStatusCsvResponseGroupParameter,
        /// the start of the pagination
        start: i64,
        /// the limit of the pagination
        limit: i64,
    },
    /// Search Status
    ListStatusCsv {
        version: f64,
        /// the id of the account
        account_id: i64,
        /// the start of the pagination
        start: i32,
        /// the limit of the pagination
        limit: i32,
    },
    /// Batch Status
    StatusCsv {
        version: f64,
        /// the id of the account
        account_id: i64,
        /// the id of the batch to get its status
        batch_id: i64,
    },
    /// Upload CSV
    UploadCsv {
        version: f64,
        /// the id of the account
        account_id: i64,
        /// the upload type: OFFERS, RETAILERS, RETAILERLOCATIONS, CATEGORIES, OR FILTERS
        #[clap(value_parser = parse_json::<models::UploadCsvUploadTypeParameter>)]
        upload_type: models::UploadCsvUploadTypeParameter,
        /// the import file to reference
        #[clap(value_parser = parse_json::<swagger::ByteArray>)]
        import_file: swagger::ByteArray,
        /// the format of the file
        #[clap(value_parser = parse_json::<models::UploadCsvFileFormatParameter>)]
        file_format: models::UploadCsvFileFormatParameter,
        /// the application key
        app_key: Option<String>,
    },
    /// Create Cargo Type
    CreateCargoType {
        version: f64,
        #[clap(value_parser = parse_json::<models::CargoType>)]
        body: Option<models::CargoType>,
    },
    /// Search Cargo Type
    SearchCargoTypes {
        version: f64,
        /// the sort field to use for the cargo type
        sort_field: String,
        /// if the cargo type should be should be in descending order
        #[clap(short, long)]
        descending: bool,
        /// the start of the search
        start: i32,
        /// the limit of the search
        limit: i32,
        /// if search should be on active only
        #[clap(long)]
        active_only: bool,
        /// the id of the retailer location
        retailer_id: Option<i64>,
        /// the ID of the hub
        hub_id: Option<i64>,
    },
    /// Delete Cargo Type
    DeleteCargoType {
        version: f64,
        /// the ID of the cargo type
        cargo_type_id: i64,
    },
    /// Get Cargo Type
    GetCargoType {
        version: f64,
        /// the cargo type ID
        cargo_type_id: i64,
    },
    /// Update Cargo Type
    UpdateCargoType {
        version: f64,
        /// the ID of the cargo type
        cargo_type_id: i64,
        #[clap(value_parser = parse_json::<models::CargoType>)]
        body: Option<models::CargoType>,
    },
    /// Search Carriers
    SearchCarriers {
        version: f64,
        /// The keyword to search on
        keyword: Option<String>,
        /// Determines whether the sorted list is in descending or ascending order
        #[clap(short, long)]
        descending: Option<bool>,
        /// The start index for pagination
        start: Option<i32>,
        /// The limit for pagination
        limit: Option<i32>,
        /// Determines whether to return inactive results
        #[clap(long)]
        active_only: Option<bool>,
    },
    /// Search Categories by Distance
    CategoryDistanceSearch {
        version: f64,
        /// The account id of the user
        account_id: Option<i64>,
        /// The keyword string to search on
        keyword: Option<String>,
        /// the appKey of the application to retrieve categories for, if not specified then search on the global application.
        app_key: Option<String>,
        /// Restrict the search by specific categories
        category_ids: Option<String>,
        /// Restrict the search by specific parent categories so that only its sub children are searched.
        parent_category_ids: Option<String>,
        /// Restrict the search to only those categories with no parent category assigned.
        #[clap(long)]
        root_only: Option<bool>,
        /// The column to sort the search on. Possible values include: ID, CREATED, UPDATED, ACTIVE, NAME, DISPLAY
        #[clap(value_parser = parse_json::<models::SearchCategoriesSortFieldParameter>)]
        sort_field: Option<models::SearchCategoriesSortFieldParameter>,
        /// The group of categories to return: ALL, GLOBAL or MINE. ALL returns both global and application specific matches, GLOBAL only returns global matches, and MINE only returns the application specific matches. If not provided search on the application provided.
        #[clap(value_parser = parse_json::<models::SearchCategoriesResponseGroupParameter>)]
        response_group: Option<models::SearchCategoriesResponseGroupParameter>,
        /// The order to return the search results
        #[clap(short, long)]
        descending: Option<bool>,
        /// The record to begin the return set on
        start: Option<i32>,
        /// The number of records to return
        limit: Option<i32>,
        /// Determines whether to return only active categories
        #[clap(long)]
        active_only: Option<bool>,
        /// Determines whether to return extra info about the category's \"Participant\" reference
        #[clap(long)]
        return_external: Option<bool>,
        /// If true search categories using the exact keyword, if false then do a partial match (like) search.
        #[clap(short, long)]
        exact_match: Option<bool>,
        /// Filters results by the Category's type
        param_type: Option<String>,
        /// Filters results by externalType
        external_type: Option<String>,
        /// Filters results to only return Categories that have been referenced by a minimum number of Offers
        min_offer_count: Option<i32>,
        /// the latitude of where the search is centered on
        latitude: Option<f64>,
        /// the longitude of where the search is centered on
        longitude: Option<f64>,
        /// the maximum range the category can be from the center
        range: Option<f64>,
    },
    /// Create Category
    CreateCategory {
        version: f64,
        /// The account id of the user (must have permissions to the target application)
        account_id: i64,
        /// The name of the category
        name: String,
        /// The appKey of the application to assign the category to, if not provided then the category will be applied to the global application (if the account has permissions)
        app_key: Option<String>,
        /// The ID of the parent category, if not provided then the parent category will be null
        parent_category_id: Option<i64>,
        /// The description of the category
        description: Option<String>,
        /// The type of the category
        param_type: Option<String>,
        /// The ID of the image asset previously uploaded using the media service
        asset_id: Option<i64>,
        /// A string identifier used by client applications to store external information
        external_id: Option<String>,
        /// A string type used by client applications to store external information
        external_type: Option<String>,
        /// external category slug
        external_category_slug: Option<String>,
        /// sqoot slug
        sqoot_slug: Option<String>,
        /// Sets whether the category is active or inactive (hidden from consumers)
        #[clap(long)]
        active: Option<bool>,
        /// external custom client defined data
        meta_data: Option<String>,
        /// user defined strings for searching
        search_tags: Option<String>,
    },
    /// Delete Category
    DeleteCategory {
        version: f64,
        /// the ID of the account
        account_id: i64,
        /// the ID of the category
        category_id: i64,
    },
    /// Duplicate Category
    DuplicateCategory {
        version: f64,
        /// The account id of the user (must have permissions to the target application)
        account_id: i64,
        /// The category ID to duplicate (includes all children)
        category_id: i64,
        /// The application to assign the new category to, may be different then the application the source category is assigned to
        app_key: Option<String>,
        /// The parent category ID to add the target category to.
        parent_category_id: Option<i64>,
    },
    /// Get Category
    GetCategory {
        version: f64,
        /// the ID of the category
        category_id: i64,
        /// Determines whether to return extra info about the category's \"Participant\" reference
        #[clap(short, long)]
        return_external: Option<bool>,
    },
    /// Search Categories
    SearchCategories {
        version: f64,
        /// The account id of the user
        account_id: Option<i64>,
        /// The string to search on
        keyword: Option<String>,
        /// the appKey of the application to retrieve categories for, if not specified then search on the global application.
        app_key: Option<String>,
        /// @Deprecated, use parentCategoryIds instead
        category_id: Option<String>,
        /// Restrict the search by specific categories
        category_ids: Option<String>,
        /// Restrict the search by specific parent categories so that only its sub children are searched.
        parent_category_ids: Option<String>,
        /// Restrict the search to only those categories with no parent category assigned.
        #[clap(long)]
        root_only: Option<bool>,
        /// The column to sort the search on. Possible values include: ID, CREATED, UPDATED, ACTIVE, NAME, DISPLAY
        #[clap(value_parser = parse_json::<models::SearchCategoriesSortFieldParameter>)]
        sort_field: Option<models::SearchCategoriesSortFieldParameter>,
        /// The group of categories to return: ALL, GLOBAL or MINE. ALL returns both global and application specific matches, GLOBAL only returns global matches, and MINE only returns the application specific matches. If not provided search on the application provided.
        #[clap(value_parser = parse_json::<models::SearchCategoriesResponseGroupParameter>)]
        response_group: Option<models::SearchCategoriesResponseGroupParameter>,
        /// The order to return the search results
        #[clap(short, long)]
        descending: Option<bool>,
        /// The record to begin the return set on
        start: Option<i32>,
        /// The number of records to return
        limit: Option<i32>,
        /// Determines whether to return only active categories
        #[clap(long)]
        active_only: Option<bool>,
        /// Determines whether to return extra info about the category's \"Participant\" reference
        #[clap(long)]
        return_external: Option<bool>,
        /// If true search categories using the exact keyword, if false then do a partial match (like) search. Default is false.
        #[clap(long)]
        exact_match: Option<bool>,
        /// Filters results by the Category's type
        param_type: Option<String>,
        /// Filters results by externalType
        external_type: Option<String>,
        /// Determines whether the \"externalType\" param is excluded from the search results
        #[clap(long)]
        exclude_external_type: Option<bool>,
        /// Filters results to only return Categories that have been referenced by a minimum number of Offers
        min_offer_count: Option<i32>,
        /// When searching by a specific parent category (to return sub children), this determines the number of child layers to search in. The minimum is 1, the maximum is 4.
        search_depth: Option<i32>,
        /// The search index mode to use (e.g. OPENSEARCH or RDS)
        search_mode: Option<String>,
    },
    /// Update Category
    UpdateCategory {
        version: f64,
        /// The account id of the user
        account_id: i64,
        /// The ID of the category to edit
        category_id: i64,
        /// The ID of the parent category, if not provided then the parent category will be null
        parent_category_id: Option<i64>,
        /// The name of the category
        name: Option<String>,
        /// The description of the category
        description: Option<String>,
        /// The type of the category
        param_type: Option<String>,
        /// The ID of the image asset previously uploaded using the media service
        asset_id: Option<i64>,
        /// A string identifier used by client applications to store external information
        external_id: Option<String>,
        /// A string type used by client applications to store external information
        external_type: Option<String>,
        /// external category slug
        external_category_slug: Option<String>,
        /// sqoot slug
        sqoot_slug: Option<String>,
        /// Sets whether the category is active or inactive (hidden from consumers)
        #[clap(long)]
        active: Option<bool>,
        /// external custom client defined data
        meta_data: Option<String>,
        /// user defined strings for searching
        search_tags: Option<String>,
    },
    /// Add Connection
    AddConnectionToGroup {
        version: f64,
        /// whether to return nulls or not
        #[clap(short, long)]
        return_nulls: bool,
        /// the group id
        group_id: i64,
        /// the device id (deviceId or accountId required)
        device_id: Option<String>,
        /// the account id of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// the connection id
        connection_id: Option<i64>,
        /// the connection account id
        connection_account_id: Option<i64>,
        /// the pending id
        pending_id: Option<i64>,
        /// the current latitude of the user
        latitude: Option<f64>,
        /// the current longitude of the user
        longitude: Option<f64>,
    },
    /// Add Connections
    AddConnectionsToGroup {
        version: f64,
        /// the connection group ID
        connection_group_id: i64,
        /// the device id (deviceId or accountId required)
        device_id: Option<String>,
        /// the account id of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// comma separated list of connection ids
        connection_ids: Option<String>,
        /// comma separated list of connection account ids
        connection_account_ids: Option<String>,
        /// the current latitude of the user
        latitude: Option<f64>,
        /// the current longitude of the user
        longitude: Option<f64>,
    },
    /// Add Connection Groups
    AddSubGroups {
        version: f64,
        /// whether to return nulls or not
        #[clap(short, long)]
        return_nulls: bool,
        /// the parent group id
        group_id: i64,
        /// comma separated list of group IDs to add to the parent group
        sub_group_ids: String,
        /// the device id (deviceId or accountId required)
        device_id: Option<String>,
        /// the account id of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// the current latitude of the user
        latitude: Option<f64>,
        /// the current longitude of the user
        longitude: Option<f64>,
    },
    /// Create or Update Connection
    CreateOrUpdateConnection {
        version: f64,
        /// the device id (deviceId or accountId required)
        device_id: Option<String>,
        /// the account id of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// the connection id for editing
        connection_id: Option<i64>,
        /// the connection account id (i.e. the account id of another user)
        connection_account_id: Option<i64>,
        /// the pending id (usually for people who do not have a Sirqul account but are already friends via other third party apps)
        pending_id: Option<i64>,
        /// optional group id if the user wants to add this person into a group
        group_id: Option<i64>,
        /// This parameter is deprecated.
        game_type: Option<String>,
        /// the application key
        app_key: Option<String>,
        /// determines whether the user is trusting this account
        #[clap(long)]
        is_trusted: Option<bool>,
        /// determines whether the user has set to ignore the user's friend request
        #[clap(long)]
        ignore_friend_request: Option<bool>,
        /// determines whether the user is a contact of this account
        #[clap(long)]
        is_contact: Option<bool>,
        /// determines whether the user is blocking this account
        #[clap(long)]
        is_blocked: Option<bool>,
        /// determines whether the user is following this account
        #[clap(long)]
        is_following: Option<bool>,
        /// whether to return the connection response or not
        #[clap(short, long)]
        connection_response: Option<bool>,
    },
    /// Create or Update Connection Group
    CreateOrUpdateGroup {
        version: f64,
        /// whether to return nulls or not
        #[clap(short, long)]
        return_nulls: bool,
        /// the device id (deviceId or accountId required)
        device_id: Option<String>,
        /// the account id of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// the name of the group
        name: Option<String>,
        /// the group id to update a group (don't pass anything in if you want to create a new group)
        group_id: Option<i64>,
        /// the asset to attach to the group
        asset_id: Option<i64>,
        /// comma separated list of connection IDs
        connections: Option<String>,
        /// the description of the group
        description: Option<String>,
        /// determines whether the connections in the group can see the user's profile info
        #[clap(long)]
        can_view_profile_info: Option<bool>,
        /// determines whether the connections in the group can see the user's game info
        #[clap(long)]
        can_view_game_info: Option<bool>,
        /// determines whether the connections in the group can see the user's friends/connections
        #[clap(long)]
        can_view_friend_info: Option<bool>,
        /// Sets whether the connection group is active or inactive
        #[clap(long)]
        active: Option<bool>,
        /// the latitude of the group
        latitude: Option<f64>,
        /// the longitude of the group
        longitude: Option<f64>,
    },
    /// Accept Follow Request
    FollowAccept {
        version: f64,
        /// the account id of the user
        account_id: i64,
        /// the account ID of the user who initiated the follow
        connection_account_id: i64,
        /// the application key for sending notifications
        app_key: String,
    },
    /// Reject Follow Request
    FollowReject {
        version: f64,
        /// the account id of the user
        account_id: i64,
        /// the account ID of the user who initiated the follow
        connection_account_id: i64,
        /// the application key for sending notifications
        app_key: String,
    },
    /// Remove Follower / Unfollow
    FollowRemove {
        version: f64,
        /// the account id of the user
        account_id: i64,
        /// the account ID of the user who you want to unfollow
        connection_account_id: i64,
        /// the application key for sending notifications
        app_key: String,
    },
    /// Send Follow Request
    FollowRequest {
        version: f64,
        /// the account id of the user
        account_id: i64,
        /// the account ID of the user who you want to follow
        connection_account_id: i64,
        /// the application key for sending notifications
        app_key: String,
        /// determines if the other user needs to confirm the follow request
        #[clap(long)]
        approval_needed: Option<bool>,
    },
    /// Accept Friend
    FriendAccept {
        version: f64,
        /// the friend's account id
        friend_account_id: i64,
        /// determines whether to send a notification to the afflicting party
        #[clap(short, long)]
        notify_friend: bool,
        /// the device id (deviceId or accountId required)
        device_id: Option<String>,
        /// the account id of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// This parameter is deprecated.
        game_type: Option<String>,
        /// the application key
        app_key: Option<String>,
        /// optional message to send in a notification
        notification_message: Option<String>,
    },
    /// Decline Friend
    FriendReject {
        version: f64,
        /// the friend's account id
        friend_account_id: i64,
        /// the device id (deviceId or accountId required)
        device_id: Option<String>,
        /// the account id of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// This parameter is deprecated.
        game_type: Option<String>,
        /// the application key
        app_key: Option<String>,
        /// determines whether to send a notification to the afflicting party
        #[clap(short, long)]
        notify_friend: Option<bool>,
        /// optional message to send in a notification
        notification_message: Option<String>,
    },
    /// Delete Friend
    FriendRemove {
        version: f64,
        /// the account ID of the friend to remove
        friend_account_id: i64,
        /// the device id (deviceId or accountId required)
        device_id: Option<String>,
        /// the account id of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// optionally notifies the connection that they have been removed as a friend
        #[clap(short, long)]
        notify_friend: Option<bool>,
        /// optionally removes the connection from the user's groups
        #[clap(short, long)]
        remove_from_groups: Option<bool>,
    },
    /// Request Friend
    FriendRequest {
        version: f64,
        /// the friend's account id
        friend_account_id: i64,
        /// the device id (deviceId or accountId required)
        device_id: Option<String>,
        /// the account id of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// This parameter is deprecated.
        game_type: Option<String>,
        /// the application key
        app_key: Option<String>,
        /// optional message to send in a notification
        notification_message: Option<String>,
    },
    /// Get Sent Friend Requests
    GetConnectionSentFriendRequests {
        version: f64,
        /// the ID of the device
        device_id: Option<String>,
        /// the id of the account
        account_id: Option<i64>,
    },
    /// Search Connections
    GetConnections {
        version: f64,
        /// whether to return nulls or not
        #[clap(short, long)]
        return_nulls: bool,
        /// a comma separated list of ConnectionApiMap. (NOTE on FOLLOWER vs FOLLOWING: FOLLOWER will get me a list of followers, FOLLOWING will get me a list of people I am following)
        filter: String,
        /// sorts the response list by ConnectionApiMap
        sort_field: String,
        /// sorts the response list by descending order if true
        #[clap(short, long)]
        descending: bool,
        /// start index of the pagination
        start: i32,
        /// limit of the pagination
        limit: i32,
        /// the device id (deviceId or accountId required)
        device_id: Option<String>,
        /// the account id (deviceId or accountId required)
        account_id: Option<i64>,
        /// optional parameter to search on other account's connections
        connection_account_id: Option<i64>,
        /// This parameter is deprecated.
        q: Option<String>,
        /// an optional keyword to search on, this parameter is ignored if empty
        keyword: Option<String>,
        /// This parameter is deprecated.
        _i: Option<i32>,
        /// This parameter is deprecated.
        _l: Option<i32>,
        /// the current latitude of the user
        latitude: Option<f64>,
        /// the current longitude of the user
        longitude: Option<f64>,
    },
    /// Get Connection Group
    GetGroupDetails {
        version: f64,
        /// whether to combine connections or not
        #[clap(short, long)]
        combine_connections: bool,
        /// the device id (deviceId or accountId required)
        device_id: Option<String>,
        /// the account id of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// the group id
        group_id: Option<i64>,
        /// the current latitude of the user
        latitude: Option<f64>,
        /// the current longitude of the user
        longitude: Option<f64>,
    },
    /// Search Connection Groups
    GroupSearch {
        version: f64,
        /// the field to sort by
        #[clap(value_parser = parse_json::<models::GroupSearchSortFieldParameter>)]
        sort_field: models::GroupSearchSortFieldParameter,
        /// whether to return results in descending or ascending order
        #[clap(short, long)]
        descending: bool,
        /// to search on active only or not
        #[clap(long)]
        active_only: bool,
        /// The start of the pagination
        start: i32,
        /// the limit of the pagination
        limit: i32,
        /// the device id (deviceId or accountId required)
        device_id: Option<String>,
        /// the account id of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// the current latitude of the user
        latitude: Option<f64>,
        /// the current longitude of the user
        longitude: Option<f64>,
        /// keyword search string
        keyword: Option<String>,
    },
    /// Delete Connection
    RemoveConnectionFromGroup {
        version: f64,
        /// whether to return nulls or not
        #[clap(short, long)]
        return_nulls: bool,
        /// the group id
        group_id: i64,
        /// the device id (deviceId or accountId required)
        device_id: Option<String>,
        /// the account id of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// the connection id
        connection_id: Option<i64>,
        /// the connection account id
        connection_account_id: Option<i64>,
        /// the pending id
        pending_id: Option<i64>,
        /// the current latitude of the user
        latitude: Option<f64>,
        /// the current longitude of the user
        longitude: Option<f64>,
    },
    /// Remove Connections
    RemoveConnectionsFromGroup {
        version: f64,
        /// connection group id
        connection_group_id: i64,
        /// the device id (deviceId or accountId required)
        device_id: Option<String>,
        /// the account id of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// comma separated list of connection ids
        connection_ids: Option<String>,
        /// comma separated list of connection account ids
        connection_account_ids: Option<String>,
        /// the current latitude of the user
        latitude: Option<f64>,
        /// the current longitude of the user
        longitude: Option<f64>,
    },
    /// Delete Connection Group
    RemoveGroup {
        version: f64,
        /// whether to return nulls or not
        #[clap(short, long)]
        return_nulls: bool,
        /// the group id
        group_id: i64,
        /// the device id (deviceId or accountId required)
        device_id: Option<String>,
        /// the account id of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// the current latitude of the user
        latitude: Option<f64>,
        /// the current longitude of the user
        longitude: Option<f64>,
    },
    /// Remove Connection Groups
    RemoveSubGroups {
        version: f64,
        /// whether to return nulls or not
        #[clap(short, long)]
        return_nulls: bool,
        /// the parent group id
        group_id: i64,
        /// comma separated list of group IDs to remove from the parent group
        sub_group_ids: String,
        /// the device id (deviceId or accountId required)
        device_id: Option<String>,
        /// the account id of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// the current latitude of the user
        latitude: Option<f64>,
        /// the current longitude of the user
        longitude: Option<f64>,
    },
    /// Search Possible Connections
    SearchConnections {
        version: f64,
        /// return all json attributes if true. defualt is true.
        #[clap(short, long)]
        return_nulls: bool,
        /// start index of the pagination
        start: i32,
        /// limit of the pagination
        limit: i32,
        /// the device id (deviceId or accountId required)
        device_id: Option<String>,
        /// the account id (deviceId or accountId required)
        account_id: Option<i64>,
        /// This parameter is deprecated.
        q: Option<String>,
        /// keyword to search on, optional and this parameter is ignored if empt
        keyword: Option<String>,
        /// the current latitude of the user
        latitude: Option<f64>,
        /// the current longitude of the user
        longitude: Option<f64>,
        /// This parameter is deprecated.
        game_type: Option<String>,
        /// the public application key, if provided only looks for users of that application
        app_key: Option<String>,
        /// This parameter is deprecated.
        _i: Option<i32>,
        /// This parameter is deprecated.
        _l: Option<i32>,
        /// the field to sort on
        sort_field: Option<String>,
        /// whether the search has location or not
        #[clap(short, long)]
        has_location: Option<bool>,
    },
    /// Create or Update Contest
    AddOrUpdateAlbumContest {
        version: f64,
        /// determines whether the contest's participants has read permissions
        #[clap(long)]
        public_read: bool,
        /// determines whether the contest's participants has write permissions
        #[clap(long)]
        public_write: bool,
        /// determines whether the contest's participants has delete permissions
        #[clap(long)]
        public_delete: bool,
        /// determines whether the contest's participants has add permissions
        #[clap(long)]
        public_add: bool,
        /// the determines the album's participants (PUBLIC - includes everyone in the system as a potential participant, PRIVATE - only considers people who have been invited as participants)
        #[clap(value_parser = parse_json::<models::AddAlbumCollectionVisibilityParameter>)]
        visibility: models::AddAlbumCollectionVisibilityParameter,
        /// determines whether to include all friends as participants
        #[clap(short, long)]
        include_friend_group: bool,
        /// a unique ID given by the device (deviceId or accountId required)
        device_id: Option<String>,
        /// the account ID of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// This parameter is deprecated. the application key
        game_type: Option<String>,
        /// the application key
        app_key: Option<String>,
        /// a custom field used for aggregation and searching
        contest_type: Option<String>,
        /// the album contest ID for updating (don't pass in if creating)
        album_contest_id: Option<i64>,
        /// the title of the contest
        title: Option<String>,
        /// the description of the contest
        description: Option<String>,
        /// the album ID for the first album
        album_id1: Option<i64>,
        /// removes album1 from the contest
        #[clap(long)]
        remove_album1: Option<bool>,
        /// the album ID for the second album
        album_id2: Option<i64>,
        /// removes album2 from the contest
        #[clap(long)]
        remove_album2: Option<bool>,
        /// the start date of the contest (time-stamp in milliseconds)
        start_date: Option<i64>,
        /// the end date of the contest (time-stamp in milliseconds)
        end_date: Option<i64>,
        /// the location description of the contest taking place
        location_description: Option<String>,
        /// comma separated list of connection IDs
        connection_ids_to_add: Option<String>,
        /// comma separated list of connection group IDs
        connection_group_ids_to_add: Option<String>,
        /// latitude used to update the user's current location
        latitude: Option<f64>,
        /// longitude used to update the user's current location
        longitude: Option<f64>,
    },
    /// Approve Contest
    ApproveAlbumContest {
        version: f64,
        /// The ID of the album contest
        album_contest_id: i64,
        /// The approval status to set {PENDING, REJECTED, APPROVED, FEATURED}
        #[clap(value_parser = parse_json::<models::ApproveAlbumApprovalStatusParameter>)]
        approval_status: models::ApproveAlbumApprovalStatusParameter,
        /// A unique ID given by the device (deviceId or accountId required)
        device_id: Option<String>,
        /// The account ID of the user (deviceId or accountId required)
        account_id: Option<i64>,
    },
    /// Delete Contest
    DeleteContest {
        version: f64,
        /// the album contest ID
        album_contest_id: i64,
        /// a unique ID given by the device (deviceId or accountId required)
        device_id: Option<String>,
        /// the account ID of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// latitude used to update the user's current location
        latitude: Option<f64>,
        /// longitude used to update the user's current location
        longitude: Option<f64>,
    },
    /// Get Contest
    GetAlbumContest {
        version: f64,
        /// the album contest ID
        album_contest_id: i64,
        /// a unique ID given by the device (deviceId or accountId required)
        device_id: Option<String>,
        /// the account ID of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// latitude used to update the user's current location
        latitude: Option<f64>,
        /// longitude used to update the user's current location
        longitude: Option<f64>,
    },
    /// Search Contests
    GetAlbumContests {
        version: f64,
        /// a comma separated list of Ownership
        filter: String,
        /// the field to sort by. See AlbumContestApiMap
        sort_field: String,
        /// determines whether the sorted list is in descending or ascending order
        #[clap(short, long)]
        descending: bool,
        /// the start index for pagination
        start: i32,
        /// the limit for pagination (there is a hard limit of 30)
        limit: i32,
        /// a unique ID given by the device (deviceId or accountId required)
        device_id: Option<String>,
        /// the account ID of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// This parameter is deprecated.
        game_type: Option<String>,
        /// the application key
        app_key: Option<String>,
        /// the application type
        app_type: Option<String>,
        /// filter contests with this contest type
        contest_type: Option<String>,
        /// search on contests that have been created by this account (that the user has permissions to)
        owner_id: Option<i64>,
        /// This parameter is deprecated.
        q: Option<String>,
        /// keyword search string
        keyword: Option<String>,
        /// This parameter is deprecated.
        _i: Option<i32>,
        /// This parameter is deprecated.
        _l: Option<i32>,
        /// filter on items that have been created before this date
        date_created: Option<i64>,
        /// latitude used to update the user's current location
        latitude: Option<f64>,
        /// longitude used to update the user's current location
        longitude: Option<f64>,
    },
    /// Vote on Contest
    VoteOnAlbumContest {
        version: f64,
        /// the album contest ID
        album_contest_id: i64,
        /// the ID of the album to vote on
        album_id: i64,
        /// a unique ID given by the device (deviceId or accountId required)
        device_id: Option<String>,
        /// the account ID of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// a custom field used for aggregation and searching
        contest_type: Option<String>,
        /// latitude used to update the user's current location
        latitude: Option<f64>,
        /// longitude used to update the user's current location
        longitude: Option<f64>,
    },
    /// Add Preview
    AddPreview {
        version: f64,
        /// the id of the account
        account_id: i64,
        /// The id of the creative that want to enable preview. The type of the creative should be CONFIG, otherwise no action will be applied.
        creative_id: i64,
    },
    /// Find Missions
    AdsFind {
        version: f64,
        /// The application key, if provided return missions specific for the app. Will always return mission levels that are app agnostic.
        app_key: String,
        /// return a random set of results, default is true. If false returns in nature order.
        #[clap(short, long)]
        randomize: bool,
        /// return only ads targets to the specific app, no global ads.
        #[clap(short, long)]
        targeted_ads_only: bool,
        /// The type of ads to get, possible values are: BANNER, LEADERBOARD, SKYSCRAPER, FULL, VIDEO, ZIP, CONFIG. Use this instead of suffix.
        param_type: Option<String>,
        /// The logged in user.
        account_id: Option<i64>,
        /// The version of the application, will not return levels newer than the appVersion.
        app_version: Option<String>,
        /// The current location of the requesting device
        latitude: Option<f64>,
        /// The current location of the requesting device
        longitude: Option<f64>,
        /// Should use deviceId if possible. The name of the requesting device; possible values are: Android, iPhone, iPad, iPod, etc. use /audience/devices for list.
        device: Option<String>,
        /// The device ID of the requesting device, use /audience/devices for list
        device_identifier: Option<i64>,
        /// The requesting device version; examples are: 2.3, 5.1.4, 6.1.4. Supports X, X.X, or X.X.X formated string.
        device_version: Option<String>,
        /// The index into the record set to start with.
        start: Option<i32>,
        /// The total number of record to return.
        limit: Option<i32>,
        /// If true then return the audience data in the response. Default is false.
        #[clap(short, long)]
        include_audiences: Option<bool>,
        /// If true/false only return missions whose game levels allocate (or don't allocate) tickets. Do not provide a value to return both.
        #[clap(long)]
        allocates_tickets: Option<bool>,
        /// return only ads from the specified campaigns.
        mission_ids: Option<String>,
    },
    /// Create Creative
    CreateCreative {
        version: f64,
        /// The logged in user.
        account_id: i64,
        /// The name of the level.
        name: String,
        /// If true set the game level as active. Default is false.
        #[clap(long)]
        active: bool,
        /// determines whether the response will wait until the asset gets created
        #[clap(short, long)]
        wait_for_asset: bool,
        /// The description of the level.
        description: Option<String>,
        /// The asset Id of the level image.
        asset_image_id: Option<i64>,
        /// This parameter is deprecated. deprecated use data field
        action: Option<String>,
        /// The creative data, json based format depending on type. If not using action then data is required.
        data: Option<String>,
        /// This parameter is deprecated. deprecated use type field
        suffix: Option<String>,
        /// The type of creative. If not using suffix then type is required.
        param_type: Option<String>,
        /// Set the amount of money available to spend, once 0 deactivate level. Set to a negative value for unlimited.
        balance: Option<f64>,
        /// if creative related so some other content provided the id
        reference_id: Option<i64>,
        /// The version of the application, will not return creatives newer than the appVersion. Only used when requesting application configuration creatives.
        app_version: Option<String>,
        /// Assign the creative to a campaign for timing and audience matching.
        mission_id: Option<i64>,
        /// the id of the offer
        offer_id: Option<i64>,
    },
    /// Delete Creative
    DeleteCreative {
        version: f64,
        /// the id of the logged in user
        account_id: i64,
        /// the id of the creative to delete
        creative_id: i64,
    },
    /// Get Creative
    GetCreative {
        version: f64,
        /// the id of the logged in user
        account_id: i64,
        /// the ID of the creative to get
        creative_id: i64,
    },
    /// Search Creatives
    GetCreativesByApplication {
        version: f64,
        /// The logged in user.
        account_id: i64,
        /// the application key
        app_key: String,
        /// Start the result set at some index.
        start: i32,
        /// Limit the result to some number.
        limit: i32,
        /// Creatives contained in the provided mission.
        mission_id: Option<i64>,
        /// Match the keyword to the owner name or level name.
        keyword: Option<String>,
    },
    /// Remove Preview
    RemovePreview {
        version: f64,
        /// the ID of the logged in user
        account_id: i64,
        /// the ID of the creative to remove preview
        creative_id: i64,
    },
    /// Update Creative
    UpdateCreative {
        version: f64,
        /// The logged in user.
        account_id: i64,
        /// the creative Id to upate.
        creative_id: i64,
        /// The name of the level.
        name: Option<String>,
        /// The description of the level.
        description: Option<String>,
        /// The asset Id of the level image.
        asset_image_id: Option<i64>,
        /// This parameter is deprecated. deprecated use data field
        action: Option<String>,
        /// The creative data, json based format depending on type
        data: Option<String>,
        /// This parameter is deprecated. deprecated use type field
        suffix: Option<String>,
        /// The type of creative.
        param_type: Option<String>,
        /// Set the amount of money available to spend, once 0 deactivate level. Set to a negative value for unlimited.
        balance: Option<f64>,
        /// If true set the game level as active. Default is false.
        #[clap(long)]
        active: Option<bool>,
        /// if creative related so some other content provided the id
        reference_id: Option<i64>,
        /// The version of the application, will not return creatives newer than the appVersion. Only used when requesting application configuration creatives.
        app_version: Option<String>,
        /// Assign the creative to a campaign for timing and audience matching.
        mission_id: Option<i64>,
    },
    /// Create Dependent
    Create {
        version: f64,
        /// the id of the parent account to create a dependent for
        account_id: i64,
        #[clap(value_parser = parse_json::<models::Account>)]
        body: Option<models::Account>,
    },
    /// Get dependent list of an account
    GetDependents {
        version: f64,
        /// the id of the parent account to get a list of dependents
        account_id: i64,
    },
    /// Delete Dependent
    RemoveDependent {
        version: f64,
        /// the id of the parent account tied to the dependent
        account_id: i64,
        /// the id of the dependent to delete
        dependent_id: i64,
    },
    /// Check Disbursements
    CheckDisbursements {
        version: f64,
        /// the ID of the disbursement being checked on
        disbursement_id: i64,
    },
    /// Create Disbursement
    CreateDisbursement {
        version: f64,
        /// the ID of the logging in user (must be an EXECUTIVE account)
        account_id: i64,
        /// the ID of the account receiving the disbursement
        receiver_account_id: i64,
        /// the ID of the original sender account
        original_sender_account_id: i64,
        /// the dollar amount of the disbursement
        amount: f64,
        /// the provider (e.g. Authorize.net, Bill.com, etc.)
        #[clap(value_parser = parse_json::<models::CreateDisbursementProviderParameter>)]
        provider: models::CreateDisbursementProviderParameter,
        /// the date that the disbursement is scheduled to go out to the payment provider
        scheduled_date: Option<i64>,
        /// a title given for the disbursement
        title: Option<String>,
        /// a comment that could be made for a disbursement
        comment: Option<String>,
        /// external ID, which can be used as a way to reference the disbursement
        external_id: Option<String>,
        /// This is for specifying parameters to make an http callback request for validating that the disbursement is valid
        introspection_params: Option<String>,
    },
    /// Get Disbursement
    GetDisbursement {
        version: f64,
        /// The logged in user.
        account_id: i64,
        /// the id of the disbursement
        disbursement_id: i64,
    },
    /// Search Disbursements
    SearchDisbursements {
        version: f64,
        /// the id of the logged in user
        account_id: i64,
        /// filter results by the id of the account receiving the disbursement
        receiver_account_id: Option<i64>,
        /// comma separated list of status values to search for, possilbe values include: NEW, APPROVED, VALIDATING, ERROR, AUTHORIZED, CAPTURED, SETTLED
        statuses: Option<String>,
        /// comma separated list of payment providers to search for, possbile values include: AUTHORIZE_NET, AMAZON_FPS, BILL_COM
        providers: Option<String>,
        /// the date for searching disbursements before it has been processed
        before_date: Option<i64>,
        /// the date for searching disbursements before it has been processed
        after_date: Option<i64>,
        /// the start index for pagination
        start: Option<i32>,
        /// the limit per result set for pagination
        limit: Option<i32>,
        /// search on disbursements that are active only
        #[clap(long)]
        active_only: Option<bool>,
        /// search results by this external ID (that can be used to reference the disbursement)
        external_id: Option<String>,
    },
    /// Update Disbursement
    UpdateDisbursement {
        version: f64,
        /// the id of the logged in user
        account_id: i64,
        /// the id of the disbursement being updated
        disbursement_id: i64,
        /// the disbursement dollar amount being updated
        amount: Option<f64>,
        /// the payments and/or billing provider (e.g. Authorize.net, Bill.com, etc.)
        #[clap(value_parser = parse_json::<models::CreateDisbursementProviderParameter>)]
        provider: Option<models::CreateDisbursementProviderParameter>,
        /// the date that the disbursement is scheduled to go out to the payment provider
        scheduled_date: Option<i64>,
        /// the title given to the disbursement
        title: Option<String>,
        /// a comment that can be made on a disbursement
        comment: Option<String>,
        /// an external ID that can be used to reference the disbursement
        external_id: Option<String>,
        /// determines whether to try sending the disbursement again in the case of a previous failure
        #[clap(short, long)]
        retry: Option<bool>,
        /// for specifying parameters to make an http callback request for validating that the disbursement is valid
        introspection_params: Option<String>,
    },
    /// Assign Employee
    AssignEmployee {
        version: f64,
        /// The account id of the logged in user
        account_id: i64,
        /// The account id of the manager to assign under
        manager_account_id: i64,
        /// The account id of the user to be assigned as employee
        employee_account_id: i64,
        /// The role to assign to the employee (e.g. RETAILER or RETAILER_LIMITED)
        role: Option<String>,
    },
    /// Assign Employee to Location
    AssignToLocationEmployee {
        version: f64,
        /// The account id of the logged in user
        account_id: i64,
        /// The retailer location to apply the change to
        retailer_location_id: i64,
        /// The account id of the user to apply the change to
        employee_account_id: Option<i64>,
        /// If true (default) assign to the location, otherwise remove from the retailer
        #[clap(long)]
        assign: Option<bool>,
    },
    /// Create Employee
    CreateEmployee {
        version: f64,
        /// The account id of the logged in user
        account_id: i64,
        /// The account id of the manager to assign under
        manager_account_id: i64,
        /// The username/email for the new user. This must be unique across the entire the system.
        username: String,
        /// The password for the new user
        password: String,
        /// a name field
        name: Option<String>,
        /// The name prefix; Mr, Mrs, etc
        prefix_name: Option<String>,
        /// The first name
        first_name: Option<String>,
        /// The middle name
        middle_name: Option<String>,
        /// The last name
        last_name: Option<String>,
        /// The name suffix; Jr, Sr, III, etc
        suffix_name: Option<String>,
        /// The title of the user
        title: Option<String>,
        /// Additional about/biography text
        about_us: Option<String>,
        /// the asset id to set the user's profile image
        asset_id: Option<i64>,
        /// The gender
        #[clap(value_parser = parse_json::<models::SearchAccountsGenderParameter>)]
        gender: Option<models::SearchAccountsGenderParameter>,
        /// The home phone number
        home_phone: Option<String>,
        /// The cellular phone number
        cell_phone: Option<String>,
        /// The cellular service provider. This is required for sending SMS. Leave this empty if the provider is not on the list of supported carriers.
        cell_phone_carrier: Option<String>,
        /// The business phone number
        business_phone: Option<String>,
        /// The user's contact email address (NOT the username)
        email_address: Option<String>,
        /// The street address of the user's contact location
        street_address: Option<String>,
        /// Additional address information (such as a suite number, floor number, building name, or PO Box)
        street_address2: Option<String>,
        /// The city of the user's contact location
        city: Option<String>,
        /// The state of the user's contact location
        state: Option<String>,
        /// The zipcode of the user's contact location
        zipcode: Option<String>,
        /// The country of the user's contact location
        country: Option<String>,
        /// The role; RETAILER or RETAILER_LIMITED, defaulted to RETAILER_LIMITED
        role: Option<String>,
        /// the retailer location IDs the employee is associated with
        retailer_location_ids: Option<String>,
        /// Determines whether to return the application settings for the employee for a particular application
        settings_app_key: Option<String>,
        /// external custom client defined data (per Application)
        app_blob: Option<String>,
        /// The device id to assign to the user (used for IPS beacon tracking)
        assigned_device_id: Option<String>,
    },
    /// Delete Employee
    DeleteEmployee {
        version: f64,
        /// the id of the logged in user
        account_id: i64,
        /// the id of the employee to delete
        employee_account_id: i64,
    },
    /// Get Employee
    GetEmployee {
        version: f64,
        /// the id of logged in user
        account_id: i64,
        /// the id of the employee account to get
        employee_account_id: i64,
        /// Determines whether to return the application settings for the employee for a particular application
        settings_app_key: Option<String>,
    },
    /// Search Employees
    SearchEmployees {
        version: f64,
        /// The account id of the logged in user
        account_id: i64,
        /// The role to limit the search to: RETAILER or RETAILER_LIMITED. Leave empty to search on both roles.
        role: Option<String>,
        /// Filters employees by retailer
        retailer_id: Option<i64>,
        /// Filter employees by retailer locations
        retailer_location_id: Option<i64>,
        /// Deprecated parameter
        q: Option<String>,
        /// an optional keyword to search on; ignored if empty
        keyword: Option<String>,
        /// The field to sort by. Possible values include: DISPLAY, CREATED, UPDATED, ACTIVE, DELETED, LAST_LOGGED_IN, CONTACT_EMAIL, RETAILER_LOCATION_NAME, RETAILER_NAME
        #[clap(value_parser = parse_json::<models::SearchEmployeesSortFieldParameter>)]
        sort_field: Option<models::SearchEmployeesSortFieldParameter>,
        /// Determines whether the sorted list is in descending or ascending order
        #[clap(short, long)]
        descending: Option<bool>,
        /// Deprecated parameter
        _i: Option<i32>,
        /// Start the result set at some index
        start: Option<i32>,
        /// Deprecated parameter
        _l: Option<i32>,
        /// Limit the result to some number
        limit: Option<i32>,
        /// Filter results to only return active employees
        #[clap(long)]
        active_only: Option<bool>,
        /// Filter results to only employees that you manage
        #[clap(short, long)]
        managed_only: Option<bool>,
        /// Determines whether to return the application settings for the employee for a particular application
        settings_app_key: Option<String>,
        /// Comma separated list of category ids to filter results
        category_ids: Option<String>,
        /// Legacy/reporting query parameter used for formatting employee responses
        query: Option<String>,
    },
    /// Unassign Employee
    UnassignEmployee {
        version: f64,
        /// The account id of the logged in user
        account_id: i64,
        /// The account id of the user to be unassigned
        employee_account_id: i64,
    },
    /// Update Employee
    UpdateEmployee {
        version: f64,
        /// The account id of the logged in user
        account_id: i64,
        /// the id of the employee account
        employee_account_id: i64,
        /// The account id of the manager to assign under
        manager_account_id: Option<i64>,
        /// a name field
        name: Option<String>,
        /// The name prefix; Mr, Mrs, etc
        prefix_name: Option<String>,
        /// The first name
        first_name: Option<String>,
        /// The middle name
        middle_name: Option<String>,
        /// The last name
        last_name: Option<String>,
        /// The name suffix; Jr, Sr, III, etc
        suffix_name: Option<String>,
        /// The title of the user
        title: Option<String>,
        /// the asset id to set the user's profile image
        asset_id: Option<i64>,
        /// The gender {MALE, FEMALE, ANY}
        #[clap(value_parser = parse_json::<models::SearchAccountsGenderParameter>)]
        gender: Option<models::SearchAccountsGenderParameter>,
        /// The home phone number
        home_phone: Option<String>,
        /// The cellular phone number
        cell_phone: Option<String>,
        /// The cellular service provider. This is required for sending SMS. Leave this empty if the provider is not on the list of supported carriers. Supported Carriers: {ATT, QWEST, T_MOBILE, VERIZON, SPRINT, VIRIGIN_MOBILE, NEXTEL, ALLTEL, METRO_PCS, POWERTEL, BOOST_MOBILE, SUNCOM, TRACFONE, US_CELLULAR}
        cell_phone_carrier: Option<String>,
        /// The business phone number
        business_phone: Option<String>,
        /// The user's contact email address (NOT the username)
        email_address: Option<String>,
        /// The street address of the user's contact location
        street_address: Option<String>,
        /// Additional address information (such as a suite number, floor number, building name, or PO Box)
        street_address2: Option<String>,
        /// The city of the user's contact location
        city: Option<String>,
        /// The state of the user's contact location
        state: Option<String>,
        /// The zipcode of the user's contact location
        zipcode: Option<String>,
        /// The country of the user's contact location
        country: Option<String>,
        /// The role; RETAILER or RETAILER_LIMITED, defaulted to RETAILER_LIMITED
        role: Option<String>,
        /// Sets whether the employee is active or inactive
        #[clap(long)]
        active: Option<bool>,
        /// Sets the password for the employee
        password: Option<String>,
        /// Sets which retailer locations the employee is assigned to
        retailer_location_ids: Option<String>,
        /// Determines whether to return the application settings for the employee for a particular application
        settings_app_key: Option<String>,
        /// external custom client defined data (per Application)
        app_blob: Option<String>,
        /// The device id to assign to the user (used for IPS beacon tracking)
        assigned_device_id: Option<String>,
    },
    /// Attend Event
    AttendEvent {
        version: f64,
        /// The device id (deviceId or accountId required)
        device_id: Option<String>,
        /// The account id (deviceId or accountId required)
        account_id: Option<i64>,
        /// The application of where to send notifications about the attend action
        app_key: Option<String>,
        /// The scheduled broadcast or marketing experience id
        listing_id: Option<i64>,
        /// The retailer location where the event is being held
        retailer_location_id: Option<i64>,
        /// The actual event being held
        offer_location_id: Option<i64>,
        /// The wallet item to update the status of, if provided then ignore the listingId, retailerLocationId, and the offerLocationId
        transaction_id: Option<i64>,
        /// Sets whether the user is: undecided (0), attending (1), attending and checked in (2), or not attending (3)
        status: Option<i32>,
        /// The location of the status update
        latitude: Option<f64>,
        /// The location of the status update
        longitude: Option<f64>,
    },
    /// Create Event
    CreateEvent {
        version: f64,
        /// The logged in user.
        account_id: i64,
        /// The event title
        title: String,
        /// The retailer location to have the event at
        retailer_location_ids: Option<String>,
        /// The event sub title
        sub_title: Option<String>,
        /// The event details
        details: Option<String>,
        /// The categories the associate the event with
        category_ids: Option<String>,
        /// The filters the associate the event with
        filter_ids: Option<String>,
        /// Is this event active
        #[clap(long)]
        active: Option<bool>,
        /// The image to show for the event
        image_asset_id: Option<i64>,
        /// The event start date/time
        redeemable_start: Option<i64>,
        /// The event end date/time
        redeemable_end: Option<i64>,
        /// external custom client defined data
        meta_data: Option<String>,
    },
    /// Delete Event
    DeleteEvent {
        version: f64,
        /// the id of the logged in user
        account_id: i64,
        /// the id of the event to update
        event_id: i64,
    },
    /// Get Event
    GetEvent {
        version: f64,
        /// the id of the logged in user
        account_id: i64,
        /// The id of the event to return
        event_id: i64,
    },
    /// Search Event Attendance
    SearchEventTransactions {
        version: f64,
        /// The device id (deviceId or accountId required)
        device_id: Option<String>,
        /// The account id of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// The application key
        app_key: Option<String>,
        /// The keyword to search for
        keyword: Option<String>,
        /// Filter results for this retailer
        retailer_id: Option<i64>,
        /// Filter results for this retailer location
        retailer_location_id: Option<i64>,
        /// Exclude results from this retailer location
        exclude_retailer_location_id: Option<i64>,
        /// Filter results for this event listing
        listing_id: Option<i64>,
        /// Filter results for this offer
        offer_id: Option<i64>,
        /// Filter results for this offer location
        offer_location_id: Option<i64>,
        /// Filter results by accounts
        customer_account_ids: Option<String>,
        /// Comma separated list of category ids to determine whether the attendee is affiliated with the category
        affiliated_category_ids: Option<String>,
        /// Filter on attendance starting on or after this date (milliseconds since epoch)
        start_date: Option<i64>,
        /// Filter on attendance starting on or before this date (milliseconds since epoch)
        end_date: Option<i64>,
        /// Comma separated list of transaction statuses to filter on
        statuses: Option<String>,
        /// Determines what to sort the results by {CREATED, UPDATED, SEARCH_TAGS, ACTIVE, ACTIVATED, EXPIRES, TITLE, SUBTITLE, OFFER_TYPE, SPECIAL_OFFER_TYPE, OFFER_VISIBILITY, CUSTOMER_ID, CUSTOMER_DISPLAY, RETAILER_ID, RETAILER_NAME, RETAILER_LOCATION_ID, RETAILER_LOCATION_NAME, BILLABLE_ENTITY_ID, BILLABLE_ENTITY_NAME, RESPONSIBLE_DISPLAY}
        #[clap(value_parser = parse_json::<models::SearchEventTransactionsSortFieldParameter>)]
        sort_field: Option<models::SearchEventTransactionsSortFieldParameter>,
        /// Determines whether the results are in descending order
        #[clap(short, long)]
        descending: Option<bool>,
        /// The start index for pagination
        start: Option<i32>,
        /// The limit for pagination
        limit: Option<i32>,
    },
    /// Search Events
    SearchEvents {
        version: f64,
        /// The logged in user.
        account_id: i64,
        /// The keyword used to search
        keyword: Option<String>,
        /// Return only active results
        #[clap(long)]
        active_only: Option<bool>,
        /// the IDs of the categories that this event is associated with
        category_ids: Option<String>,
        /// the IDs of the filters that this event is associated with
        filter_ids: Option<String>,
        /// Offer audience ids to filter on
        offer_audience_ids: Option<String>,
        /// Transaction audience ids to filter on
        transaction_audience_ids: Option<String>,
        /// The column to sort the search on. Possible values include: ID, CREATED, UPDATED, ACTIVE, ACTIVATED, EXPIRES, TITLE, SUBTITLE, DETAILS, OFFER_TYPE, SPECIAL_OFFER_TYPE, OFFER_VISIBILITY, ESTIMATED_VALUE, VOUCHER_PRICE, RETAILER_ID, RETAILER_NAME, RETAILER_LOCATION_ID, RETAILER_LOCATION_NAME, BILLABLE_ENTITY_ID, BILLABLE_ENTITY_NAME, RESPONSIBLE_DISPLAY
        #[clap(value_parser = parse_json::<models::SearchEventsSortFieldParameter>)]
        sort_field: Option<models::SearchEventsSortFieldParameter>,
        /// The order to return the search results
        #[clap(short, long)]
        descending: Option<bool>,
        /// Filter the events to return only those that start on or after the date
        start_date: Option<i64>,
        /// Filter the events to return only those that start on or before the date
        end_date: Option<i64>,
        /// The record to begin the return set on
        start: Option<i32>,
        /// The number of records to return
        limit: Option<i32>,
    },
    /// Update Event
    UpdateEvent {
        version: f64,
        /// The logged in user.
        account_id: i64,
        /// The id of the event to update
        event_id: i64,
        /// The retailer location to have the event at
        retailer_location_ids: Option<String>,
        /// The event title
        title: Option<String>,
        /// The event sub title
        sub_title: Option<String>,
        /// The event details
        details: Option<String>,
        /// The categories the associate the event with
        category_ids: Option<String>,
        /// The filters the associate the event with
        filter_ids: Option<String>,
        /// Is this event active
        #[clap(long)]
        active: Option<bool>,
        /// The image to show for the event
        image_asset_id: Option<i64>,
        /// The event start date/time
        redeemable_start: Option<i64>,
        /// The event end date/time
        redeemable_end: Option<i64>,
    },
    /// Get Facebook Token
    GetToken {
        version: f64,
        /// a unique id given by the device (deviceId or accountId required)
        device_id: Option<String>,
        /// the account id of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// used to update the user's current location
        latitude: Option<f64>,
        /// used to update the user's current location
        longitude: Option<f64>,
    },
    /// Post to Facebook
    GraphInterface {
        version: f64,
        /// the type of Sirqul event {DOWNLOADED_APP, CHALLENGE, LEVEL_COMPLETED, LEVEL_CREATED}
        event: String,
        /// a unique id given by the device (deviceId or accountId required)
        device_id: Option<String>,
        /// the account id of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// for posting about information related to an object. Possible types: {ALBUM, ALBUM_CONTEST, GAME_LEVEL, THEME_DESCRIPTOR}
        permissionable_type: Option<String>,
        /// the object id
        permissionable_id: Option<i64>,
        /// used to include an asset on a Facebook post
        asset_id: Option<i64>,
        /// This parameter is deprecated.
        game_type: Option<String>,
        /// the application key
        app_key: Option<String>,
        /// used to update the user's current location
        latitude: Option<f64>,
        /// used to update the user's current location
        longitude: Option<f64>,
    },
    /// Create Favorite
    AddFavorite {
        version: f64,
        /// The ID of the object to favorite {offerId, offerLocationId, retailerLocationId, categoryId}
        favoritable_id: i64,
        /// The type of the object to favorite {OFFER, OFFER_LOCATION, RETAILER_LOCATION, CATEGORY, ALBUM}
        favoritable_type: String,
        /// The unique ID given by the device (deviceId or accountId required)
        device_id: Option<String>,
        /// The account ID of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// The current latitude of the user
        latitude: Option<f64>,
        /// The current longitude of the user
        longitude: Option<f64>,
    },
    /// Delete Favorite
    DeleteFavorite {
        version: f64,
        /// The unique ID given by the device (deviceId or accountId required)
        device_id: Option<String>,
        /// The account ID of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// The ID of the favorite reference record (only optional if favoritableId & favoritableType is pass in instead)
        favorite_id: Option<i64>,
        /// The ID of the object to un-favorite {offerId, offerLocationId, retailerLocationId, categoryId} (this is required if favoriteId is NOT passed in)
        favoritable_id: Option<i64>,
        /// The type of the object to un-favorite {OFFER, OFFER_LOCATION, RETAILER_LOCATION, CATEGORY} (this is required if favoriteId is NOT passed in)
        favoritable_type: Option<String>,
    },
    /// Get Favorite
    GetFavorite {
        version: f64,
        /// The ID of the favorite reference record
        favorite_id: i64,
        /// The unique ID given by the device (deviceId or accountId required)
        device_id: Option<String>,
        /// The account ID of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// The current latitude of the user
        latitude: Option<f64>,
        /// The current longitude of the user
        longitude: Option<f64>,
    },
    /// Search Favorites
    SearchFavorites {
        version: f64,
        /// The type of the object to favorite {OFFER, OFFER_LOCATION, RETAILER_LOCATION, CATEGORY}
        favoritable_type: String,
        /// Determines what to sort the results by {CREATED, UPDATED, DISPLAY}
        #[clap(value_parser = parse_json::<models::SearchFavoritesSortFieldParameter>)]
        sort_field: models::SearchFavoritesSortFieldParameter,
        /// Determines whether the results are in descending order
        #[clap(short, long)]
        descending: bool,
        /// The start index for pagination
        start: i32,
        /// The limit for pagination (there is a hard limit of 1000)
        limit: i32,
        /// Determines whether to only return active favorites
        #[clap(long)]
        active_only: bool,
        /// Determines whether to return a detailed version of the response list
        #[clap(short, long)]
        return_full_response: bool,
        /// The unique ID given by the device (deviceId or accountId required)
        device_id: Option<String>,
        /// The account ID of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// The ID of an account the user would like to view favorites for
        connection_account_id: Option<i64>,
        /// 
        secondary_type: Option<String>,
        /// The keyword to search for
        keyword: Option<String>,
        /// The current latitude of the user
        latitude: Option<f64>,
        /// The current longitude of the user
        longitude: Option<f64>,
    },
    /// Who has Favorited
    WhoHasFavorited {
        version: f64,
        /// The ID of the favoritableType to search on
        favoritable_id: i64,
        /// The type of the object to favorite {OFFER, OFFER_LOCATION, RETAILER_LOCATION, CATEGORY}
        favoritable_type: String,
        /// The start index for pagination
        start: i32,
        /// The limit for pagination
        limit: i32,
        /// The unique ID given by the device (deviceId or accountId required)
        device_id: Option<String>,
        /// The account ID of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// The current latitude of the user
        latitude: Option<f64>,
        /// The current longitude of the user
        longitude: Option<f64>,
        /// The keyword to limit that account list
        keyword: Option<String>,
    },
    /// Create Filter
    CreateFilter {
        version: f64,
        /// The account id of the user (must have permissions to the target application)
        account_id: i64,
        /// The name of the filter
        name: String,
        /// The appKey of the application to assign the filter to, if not provided then the filter will be applied to the global application (if the account has permissions)
        app_key: Option<String>,
        /// The ID of the parent filter, if not provided then the parent filter will be null
        parent_filter_id: Option<i64>,
        /// The description of the filter
        description: Option<String>,
        /// A string identifier used by client applications to store external information
        external_id: Option<String>,
        /// A string type used by client applications to store external information
        external_type: Option<String>,
        /// Sets whether the filter is active or inactive (hidden from consumers)
        #[clap(long)]
        active: Option<bool>,
        /// external custom client defined data
        meta_data: Option<String>,
    },
    /// Delete Filter
    DeleteFilter {
        version: f64,
        /// The account id of the user (must have permissions to the filter's assigned application)
        account_id: i64,
        /// The ID of the filter to delete
        filter_id: i64,
    },
    /// Get Filter
    GetFilter {
        version: f64,
        /// the id of the filter to get
        filter_id: i64,
    },
    /// Search Filters
    SearchFilters {
        version: f64,
        /// The account id of the user
        account_id: Option<i64>,
        /// The string to search on
        keyword: Option<String>,
        /// the appKey of the application to retrieve filters for
        app_key: Option<String>,
        /// The group of filters to return: ALL, GLOBAL or MINE. ALL returns both global and application specific matches, GLOBAL only returns global matches, and MINE only returns the application specific matches. If not provided search on the application provided.
        #[clap(value_parser = parse_json::<models::SearchCategoriesResponseGroupParameter>)]
        response_group: Option<models::SearchCategoriesResponseGroupParameter>,
        /// Restrict the search to only those filters with no parent filter assigned.
        #[clap(short, long)]
        root_only: Option<bool>,
        /// The column to sort the search on. Possible values include: ID, CREATED, UPDATED, ACTIVE, NAME, DISPLAY
        #[clap(value_parser = parse_json::<models::SearchCategoriesSortFieldParameter>)]
        sort_field: Option<models::SearchCategoriesSortFieldParameter>,
        /// The order to return the search results
        #[clap(short, long)]
        descending: Option<bool>,
        /// The record to begin the return set on
        start: Option<i32>,
        /// The number of records to return
        limit: Option<i32>,
        /// Determines whether to return only active categories
        #[clap(long)]
        active_only: Option<bool>,
    },
    /// Update Filter
    UpdateFilter {
        version: f64,
        /// The account id of the user
        account_id: i64,
        /// The ID of the filter to edit
        filter_id: i64,
        /// The ID of the parent filter, if not provided then the parent filter will be null
        parent_filter_id: Option<i64>,
        /// The name of the filter
        name: Option<String>,
        /// The description of the filter
        description: Option<String>,
        /// A string identifier used by client applications to store external information
        external_id: Option<String>,
        /// A string type used by client applications to store external information
        external_type: Option<String>,
        /// Sets whether the filter is active or inactive (hidden from consumers)
        #[clap(long)]
        active: Option<bool>,
        /// external custom client defined data
        meta_data: Option<String>,
    },
    /// Create Flag
    CreateFlag {
        version: f64,
        /// The flagable object type {ACCOUNT, ALBUM, ALBUM_CONTEST, ASSET, GAME_LEVEL, THEME_DESCRIPTOR, NOTE, OFFER}
        flagable_type: String,
        /// The flagable object id
        flagable_id: i64,
        /// The unique device identifier that made the request (either deviceId or accountId must be used)
        device_id: Option<String>,
        /// The unique accountId that made the request (either deviceId or accountId must be used)
        account_id: Option<i64>,
        /// An optional description of why is it being flagged
        flag_description: Option<String>,
        /// The current location of the user
        latitude: Option<f64>,
        /// The current location of the user
        longitude: Option<f64>,
    },
    /// Delete Flag
    DeleteFlag {
        version: f64,
        /// The unique device identifier that made the request (either deviceId or accountId must be used)
        device_id: Option<String>,
        /// The unique accountId that made the request (either deviceId or accountId must be used)
        account_id: Option<i64>,
        /// This parameter is deprecated.
        item_being_flagged_type: Option<String>,
        /// This parameter is deprecated.
        item_being_flagged_id: Option<i64>,
        /// The flagable object type {ACCOUNT, ALBUM, ALBUM_CONTEST, ASSET, GAME_LEVEL, THEME_DESCRIPTOR, OFFER, NOTE}
        flagable_type: Option<String>,
        /// The flagable object id
        flagable_id: Option<i64>,
    },
    /// Get Flag
    GetFlag {
        version: f64,
        /// The flagable object type {ACCOUNT, ALBUM, ALBUM_CONTEST, ASSET, GAME_LEVEL, THEME_DESCRIPTOR, NOTE, OFFER}
        flagable_type: String,
        /// The flagable object id
        flagable_id: i64,
        /// The unique device identifier that made the request (either deviceId or accountId must be used)
        device_id: Option<String>,
        /// The unique accountId that made the request (either deviceId or accountId must be used)
        account_id: Option<i64>,
        /// The current location of the user
        latitude: Option<f64>,
        /// The current location of the user
        longitude: Option<f64>,
    },
    /// Get Flag Threshold
    GetFlagThreshold {
        version: f64,
        /// The flagable object type {ACCOUNT, ALBUM, ALBUM_CONTEST, ASSET, GAME_LEVEL, THEME_DESCRIPTOR, OFFER, NOTE}
        item_being_flagged_type: String,
        /// The application key
        app_key: String,
    },
    /// Update Flag Threshold
    UpdateFlagThreshold {
        version: f64,
        /// The flagable object type {ACCOUNT, ALBUM, ALBUM_CONTEST, ASSET, GAME_LEVEL, THEME_DESCRIPTOR, OFFER, NOTE}
        item_being_flagged_type: String,
        /// The threshold value
        threshold: i64,
        /// The application key
        app_key: String,
        /// The unique device identifier that made the request (either deviceId or accountId must be used)
        device_id: Option<String>,
        /// The unique accountId that made the request (either deviceId or accountId must be used)
        account_id: Option<i64>,
    },
    /// Create a Game
    CreateGame {
        version: f64,
        /// The logged in user.
        account_id: Option<i64>,
        /// The game application key to save the level for.
        app_key: Option<String>,
        /// Title of the game.
        title: Option<String>,
        /// Description of the game.
        description: Option<String>,
        /// metaData of the Game.
        meta_data: Option<String>,
        /// comma separated String of pack Ids that will associate with the game.
        pack_ids: Option<String>,
        /// Show more details in response.
        #[clap(short, long)]
        include_game_data: Option<bool>,
    },
    /// Delete a Game
    DeleteGame {
        version: f64,
        /// The logged in user.
        account_id: i64,
        /// the updating game's id.
        game_id: i64,
    },
    /// Get a Game by id
    GetGame {
        version: f64,
        /// The logged in user.
        account_id: i64,
        /// the updating game's id.
        game_id: i64,
        /// If true include the game level data, otherwise don't. default is false.
        #[clap(short, long)]
        include_game_data: Option<bool>,
    },
    /// Search a Game
    SearchGames {
        version: f64,
        /// The logged in user.
        account_id: i64,
        /// the application key
        app_key: String,
        /// Start the result set at some index.
        start: i32,
        /// Limit the result to some number.
        limit: i32,
        /// Match the keyword to the owner name or level name.
        keyword: Option<String>,
        /// The maximum version of the level to return.
        app_version: Option<String>,
        /// more details in response
        #[clap(long)]
        include_game_data: Option<bool>,
        /// more details in response
        #[clap(long)]
        include_inactive: Option<bool>,
    },
    /// Update a Game
    UpdateGame {
        version: f64,
        /// The logged in user.
        account_id: Option<i64>,
        /// the updating game's id
        game_id: Option<i64>,
        /// The game application key to save the level for.
        app_key: Option<String>,
        /// Title of the Game.
        title: Option<String>,
        /// Description of the Game.
        description: Option<String>,
        /// metaData of the Game.
        meta_data: Option<String>,
        /// comma separated String of pack Ids that will associate with the game.
        pack_ids: Option<String>,
        /// show more details in response.
        #[clap(short, long)]
        include_game_data: Option<bool>,
    },
    /// Create Game Level
    CreateGameLevel {
        version: f64,
        /// The logged in user.
        account_id: i64,
        /// The name of the level.
        name: String,
        /// The game level data: xml, json, or other text based format.
        game_data: String,
        /// The game level data format type.
        game_data_suffix: String,
        /// The game application key to save the level for.
        app_key: Option<String>,
        /// The description of the level.
        description: Option<String>,
        /// The difficulty, possible values are: VERY_EASY, EASY, MEDIUM, HARD, VERY_HARD.
        difficulty: Option<String>,
        /// The version number of the application required to correctly load/play the level.
        app_version: Option<String>,
        /// The asset Id of the level image.
        asset_image_id: Option<i64>,
        /// The asset Id of the level icon.
        asset_icon_id: Option<i64>,
        /// Is the level visible to others, possible values are: PUBLIC, PRIVATE.
        visibility: Option<String>,
        /// Make the level be readable by all friends.
        #[clap(long)]
        friend_group: Option<bool>,
        /// Make the level be readable by connections in this list.
        connection_ids: Option<String>,
        /// Make the level be readable by connection groups in this list.
        connection_group_ids: Option<String>,
        /// Set the amount of money available to spend, once 0 deactivate level. Set to a negative value for unlimited.
        balance: Option<f64>,
        /// If true set the game level as active. Default is false.
        #[clap(long)]
        active: Option<bool>,
        /// If true then scoring will give tickets. Default is false.
        #[clap(long)]
        allocate_tickets: Option<bool>,
        /// The number of tickets to reward
        ticket_count: Option<i64>,
        /// The type of ticket to reward, null means default type
        ticket_type: Option<String>,
        /// The number of points to award for completing a level
        points: Option<i64>,
        /// Title of the tutorial.
        tutorial_title: Option<String>,
        /// Message of the tutotrial.
        tutorial_message: Option<String>,
        /// Alignment of the tutorial image. Default to NONE. Possible values are: NONE, IMAGE_ABOVE, IMAGE_BELOW, IMAGE_LEFT, IMAGE_RIGHT, IMAGE_ONLY, TEXT_ONLY
        tutorial_alignment: Option<String>,
        /// Asset id of the tutorial image.
        tutorial_image_asset_id: Option<i64>,
        /// id of the offer
        offer_id: Option<i64>,
        /// external custom client defined data
        meta_data: Option<String>,
    },
    /// Delete Game Level
    DeleteGameLevel {
        version: f64,
        /// The logged in user.
        account_id: i64,
        /// The id of the level to return.
        level_id: i64,
    },
    /// Get Game Level
    GetGameLevel {
        version: f64,
        /// The logged in user.
        account_id: i64,
        /// The id of the level to return.
        level_id: i64,
        /// If true include the game level data, otherwise don't. default is false.
        #[clap(short, long)]
        include_game_data: Option<bool>,
    },
    /// Search Game Levels
    GetGameLevelsByApplication {
        version: f64,
        /// The logged in user.
        account_id: i64,
        /// the application key
        app_key: String,
        /// Match the keyword to the owner name or level name.
        keyword: Option<String>,
        /// what field to sort on
        sort_field: Option<String>,
        /// whether to return levels in ascending or descending order
        #[clap(short, long)]
        descending: Option<bool>,
        /// Start the result set at some index.
        start: Option<i32>,
        /// Limit the result to some number.
        limit: Option<i32>,
        /// The maximum version of the level to return.
        app_version: Option<String>,
        /// If true include the game level data, otherwise don't. default is false.
        #[clap(short, long)]
        include_game_data: Option<bool>,
        /// 
        filters: Option<String>,
    },
    /// Search Game Level by Billable Entity
    GetGameLevelsByBillableEntity {
        version: f64,
        /// The account id of the user
        account_id: i64,
        /// the application key
        app_key: Option<String>,
        /// The keyword used to search
        keyword: Option<String>,
        /// The column to sort the search on
        #[clap(value_parser = parse_json::<models::GetGameLevelsByBillableEntitySortFieldParameter>)]
        sort_field: Option<models::GetGameLevelsByBillableEntitySortFieldParameter>,
        /// The order to return the search results
        #[clap(short, long)]
        descending: Option<bool>,
        /// Return only active results
        #[clap(long)]
        active_only: Option<bool>,
        /// The record to begin the return set on
        start: Option<i64>,
        /// The number of records to return
        limit: Option<i64>,
    },
    /// Get Level Questions
    GetQuestionsInLevel {
        version: f64,
        /// the id of the level to get questions from
        level_id: i64,
        /// the id of the logged in user
        account_id: i64,
    },
    /// Get Level Words
    GetWordsInLevel {
        version: f64,
        /// the id of the level to get words for
        level_id: i64,
        /// the id of the logged in user
        account_id: i64,
    },
    /// Update Game Level
    UpdateGameLevel {
        version: f64,
        /// The logged in user.
        account_id: i64,
        /// If update then include the level Id.
        level_id: i64,
        /// The game application key to save the level for.
        app_key: Option<String>,
        /// The name of the level.
        name: Option<String>,
        /// The description of the level.
        description: Option<String>,
        /// The difficulty, possible values are: VERY_EASY, EASY, MEDIUM, HARD, VERY_HARD.
        difficulty: Option<String>,
        /// The version number of the applicatuion required to correctly load/play the level.
        app_version: Option<String>,
        /// The asset Id of the level image.
        asset_image_id: Option<i64>,
        /// The asset Id of the level icon.
        asset_icon_id: Option<i64>,
        /// The game level data: xml, json, or other texted based format.
        game_data: Option<String>,
        /// The game level data format type.
        game_data_suffix: Option<String>,
        /// Is the level visible to others, possible values are: PUBLIC, PRIVATE.
        visibility: Option<String>,
        /// Make the level be readable by all friends.
        #[clap(long)]
        friend_group: Option<bool>,
        /// Make the level be readable by connections in this list.
        connection_ids: Option<String>,
        /// Make the level be readable by connection groups in this list.
        connection_group_ids: Option<String>,
        /// Set the amount of money available to spend, once 0 deactivate level. Set to a negative value for unlimited.
        balance: Option<f64>,
        /// If true set the game level as active.
        #[clap(long)]
        active: Option<bool>,
        /// If true then scoring will give tickets.
        #[clap(long)]
        allocate_tickets: Option<bool>,
        /// The number of tickets to reward
        ticket_count: Option<i64>,
        /// The type of ticket to reward, null means default type
        ticket_type: Option<String>,
        /// The number of points to award for completing a level
        points: Option<i64>,
        /// Title of the tutorial.
        tutorial_title: Option<String>,
        /// Message of the tutorial.
        tutorial_message: Option<String>,
        /// Alignment of the tutorial image, possible values are: NONE, IMAGE_ABOVE, IMAGE_BELOW, IMAGE_LEFT, IMAGE_RIGHT, IMAGE_ONLY, TEXT_ONLY
        tutorial_alignment: Option<String>,
        /// Asset id of the tutorial image.
        tutorial_image_asset_id: Option<i64>,
        /// 
        offer_id: Option<i64>,
        /// external custom client defined data
        meta_data: Option<String>,
    },
    /// Update Level Questions
    UpdateQuestionsInLevel {
        version: f64,
        /// the id of the level to update questions on
        level_id: i64,
        /// the id of the logged in user
        account_id: i64,
        /// the IDs of the questions to update
        question_ids: String,
    },
    /// Update Level Words
    UpdateWordsInLevel {
        version: f64,
        /// the id of the level to update words for
        level_id: i64,
        /// the id of the logged in user
        account_id: i64,
        /// the ids of the words to update for the level
        word_ids: String,
    },
    /// Accept Invite
    AcceptInvite {
        version: f64,
        /// the invite token
        token: String,
        /// the accountId of the user who is accepting the invite
        account_id: i64,
        /// the album id associated with this invite (if applicable)
        album_id: Option<i64>,
        /// the mission id associated with this invite (if applicable)
        mission_id: Option<i64>,
        /// the album contest id associated with this invite (if applicable)
        album_contest_id: Option<i64>,
        /// the offer id associated with this invite (if applicable)
        offer_id: Option<i64>,
        /// the offer location id associated with this invite (if applicable)
        offer_location_id: Option<i64>,
        /// the retailer location id associated with this invite (if applicable)
        retailer_location_id: Option<i64>,
        /// the application key
        app_key: Option<String>,
        /// whether to auto-friend the invite sender and receiver
        #[clap(long)]
        auto_friend: Option<bool>,
        /// whether to mark the event as attending automatically after invite is accepted
        #[clap(long)]
        auto_attend_event: Option<bool>,
        /// whether to mark the offer as favorited automatically after invite is accepted
        #[clap(long)]
        auto_favorite_offer: Option<bool>,
        /// whether to mark the offer location as favorited automatically after invite is accepted
        #[clap(long)]
        auto_favorite_offer_location: Option<bool>,
        /// whether to mark the retailer location as favorited automatically after invite is accepted
        #[clap(long)]
        auto_favorite_retailer_location: Option<bool>,
    },
    /// Invite to Contest
    AlbumContestInvite {
        version: f64,
        /// a unique ID given by the device (deviceId or accountId required)
        device_id: Option<String>,
        /// the account ID of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// This parameter is deprecated.
        app_id: Option<i64>,
        /// the application key
        app_key: Option<String>,
        /// the album contest to share
        album_contest_id: Option<i64>,
        /// the current latitude of the user
        latitude: Option<f64>,
        /// the current longitude of the user
        longitude: Option<f64>,
    },
    /// Invite to Collection
    AlbumInvite {
        version: f64,
        /// a unique ID given by the device (deviceId or accountId required)
        device_id: Option<String>,
        /// the account ID of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// This parameter is deprecated.
        app_id: Option<i64>,
        /// the application key
        app_key: Option<String>,
        /// the album to share
        album_id: Option<i64>,
        /// the current latitude of the user
        latitude: Option<f64>,
        /// the current longitude of the user
        longitude: Option<f64>,
    },
    /// Invite to Event
    EventInvite {
        version: f64,
        /// the account ID of the user making the share
        account_id: i64,
        /// the application key
        app_key: String,
        /// The ID of the event listing
        listing_id: i64,
        /// the account ID of a Sirqul user they would like to share an event with
        receiver_account_ids: Option<String>,
        /// The retailer location id of where the event will take place
        retailer_location_id: Option<i64>,
    },
    /// Invite to Game Level
    GameInvite {
        version: f64,
        /// a unique ID given by the device (deviceId or accountId required)
        device_id: Option<String>,
        /// the account ID of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// This parameter is deprecated.
        app_id: Option<i64>,
        /// the application key
        app_key: Option<String>,
        /// the game level that the user owns and is giving access to
        game_level_id: Option<i64>,
        /// the current latitude of the user
        latitude: Option<f64>,
        /// the current longitude of the user
        longitude: Option<f64>,
    },
    /// Get Invite
    GetInvite {
        version: f64,
        /// Account ID of the user if they are logged in
        account_id: Option<i64>,
        /// the invite token
        token: Option<String>,
        /// album id to match the invite against (if applicable)
        album_id: Option<i64>,
        /// mission id to match the invite against (if applicable)
        mission_id: Option<i64>,
        /// album contest id to match the invite against (if applicable)
        album_contest_id: Option<i64>,
        /// offer id to match the invite against (if applicable)
        offer_id: Option<i64>,
        /// offer location id to match the invite against (if applicable)
        offer_location_id: Option<i64>,
        /// retailer location id to match the invite against (if applicable)
        retailer_location_id: Option<i64>,
        /// the application key
        app_key: Option<String>,
    },
    /// Invite to Mission
    MissionInvite {
        version: f64,
        /// a unique ID given by the device (deviceId or accountId required)
        device_id: Option<String>,
        /// the account ID of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// This parameter is deprecated.
        app_id: Option<i64>,
        /// the application key
        app_key: Option<String>,
        /// the mission to share
        mission_id: Option<i64>,
        /// the current latitude of the user
        latitude: Option<f64>,
        /// the current longitude of the user
        longitude: Option<f64>,
    },
    /// Invite to Offer
    OfferInvite {
        version: f64,
        /// the account ID of the user making the share
        account_id: i64,
        /// the application key
        app_key: String,
        /// the ID of the offer used to invite to favorite
        offer_id: i64,
    },
    /// Invite to Offer Location
    OfferLocationInvite {
        version: f64,
        /// the account ID of the user making the share
        account_id: i64,
        /// the application key
        app_key: String,
        /// the id of the offer location to share
        offer_location_id: i64,
    },
    /// Invite to Retailer Location
    RetailerLocationInvite {
        version: f64,
        /// the account ID of the user making the share
        account_id: i64,
        /// the application key
        app_key: String,
        /// The retailer location id of where the event will take place
        retailer_location_id: i64,
        /// Optional album id to link with the invite
        album_id: Option<i64>,
    },
    /// Create a leaderboard based on the rankingType, rankMode(leaderboardMode), sortField and limitation
    CreateLeaderboard {
        version: f64,
        /// The account id of the user creating the leaderboard.
        account_id: Option<i64>,
        /// The application key
        app_key: Option<String>,
        /// a unique label for identifying the ranking. This can be any alphanumeric string with a maximum length of 64 characters. There are also default rank types to use which include: POINTS, DOWNLOADS, INVITATIONS, CREATIONS, VOTES, REDEEMED, ACTIONS
        rank_type: Option<String>,
        /// the type of search to perform. Possible values include: GLOBAL - searches scores globally (all users in the system are included in the ranking); LOCAL - filters results by select users and on users that have logged into the same device; SEARCH - does a GLOBAL search by keyword; CUSTOM - does a LOCAL search by keyword
        leaderboard_mode: Option<String>,
        /// a MultipartFile containing the icon image of the leaderboard (this will only be used if \"iconAssetId\" is empty)
        #[clap(value_parser = parse_json::<swagger::ByteArray>)]
        icon_media: Option<swagger::ByteArray>,
        /// The asset ID to set the leaderboard icon
        icon_asset_id: Option<i64>,
        /// a MultipartFile containing the icon banner of the leaderboard (this will only be used if \"bannerAssetId\" is empty)
        #[clap(value_parser = parse_json::<swagger::ByteArray>)]
        banner_media: Option<swagger::ByteArray>,
        /// The asset ID to set the leaderboard banner
        banner_asset_id: Option<i64>,
        /// limit number of rankings for each leaderboard
        limitation: Option<i32>,
        /// determines how to order and rank the results. Possible values include: TOTAL, WEEKLY, DAILY, TOP, LOWEST
        sort_field: Option<String>,
        /// leaderboard's title
        title: Option<String>,
        /// leaderboard's description
        description: Option<String>,
        /// custom meta data for the leaderboard
        meta_data: Option<String>,
    },
    /// Delete the Leader Board
    DeleteLeaderboard {
        version: f64,
        /// The leaderboard id to delete.
        leaderboard_id: i64,
        /// The account id of the user making the request.
        account_id: Option<i64>,
    },
    /// Read a leaderboard by id and retrieve the matching ranking list
    GetLeaderboard {
        version: f64,
        /// The leaderboard id.
        leaderboard_id: i64,
        /// A valid account.
        account_id: Option<i64>,
        /// set to true if need to return the leaderboard's full ranking list
        #[clap(short, long)]
        include_full_ranking_list: Option<bool>,
    },
    /// Search leaderboard and retrieve the matching ranking list
    SearchLeaderboards {
        version: f64,
        /// The account id of the user requesting the search.
        account_id: Option<i64>,
        /// The application key.
        app_key: Option<String>,
        /// only include global leaderboards (this overrides the appKey filter)
        #[clap(short, long)]
        global_only: Option<bool>,
        /// keyword to search by title
        keyword: Option<String>,
        /// comma separated list of leaderboard ids to filter results with
        leaderboard_ids: Option<String>,
        /// comma separated list of rankType to filter results with
        rank_types: Option<String>,
        /// sortField of the result, from LeaderboardApiMap (TITLE, DESCRIPTION, CREATED, UPDATED, RANK_TYPE, RANK_MODE)
        sort_field: Option<String>,
        /// Determines whether the sorted list is in descending or ascending order
        #[clap(short, long)]
        descending: Option<bool>,
        /// include inactive in the result
        #[clap(long)]
        include_inactive: Option<bool>,
        /// determines whether to include the application response for each leaderboard
        #[clap(long)]
        include_app_response: Option<bool>,
        /// Start the result set at some index.
        start: Option<i32>,
        /// Limit the result to some number.
        limit: Option<i32>,
    },
    /// Update a leaderboard based on the rankingType, rankMode(leaderboardMode), sortField and limitation
    UpdateLeaderboard {
        version: f64,
        /// The leaderboard id to update.
        leaderboard_id: i64,
        /// The account id of the user updating the leaderboard.
        account_id: Option<i64>,
        /// The application key
        app_key: Option<String>,
        /// a unique label for identifying the ranking. This can be any alphanumeric string with a maximum length of 64 characters.
        rank_type: Option<String>,
        /// the type of search to perform. Possible values include: GLOBAL, LOCAL, SEARCH, CUSTOM
        leaderboard_mode: Option<String>,
        /// determines how to order and rank the results. Possible values include: TOTAL, WEEKLY, DAILY, TOP, LOWEST
        sort_field: Option<String>,
        /// a MultipartFile containing the icon image of the leaderboard (this will only be used if \"iconAssetId\" is empty)
        #[clap(value_parser = parse_json::<swagger::ByteArray>)]
        icon_media: Option<swagger::ByteArray>,
        /// The asset ID to set the leaderboard icon
        icon_asset_id: Option<i64>,
        /// a MultipartFile containing the icon banner of the leaderboard (this will only be used if \"bannerAssetId\" is empty)
        #[clap(value_parser = parse_json::<swagger::ByteArray>)]
        banner_media: Option<swagger::ByteArray>,
        /// The asset ID to set the leaderboard banner
        banner_asset_id: Option<i64>,
        /// limit number of rankings for each leaderboard
        limitation: Option<i32>,
        /// Whether the leaderboard is active
        #[clap(long)]
        active: Option<bool>,
        /// leaderboard's title
        title: Option<String>,
        /// leaderboard's description
        description: Option<String>,
        /// custom meta data for the leaderboard
        meta_data: Option<String>,
    },
    /// Create Like
    RegisterLike {
        version: f64,
        /// The type of likable object {ALBUM, ALBUM_CONTEST, ASSET, GAME_LEVEL, NOTE, THEME_DESCRIPTOR}
        likable_type: String,
        /// The id of the likable object
        likable_id: i64,
        /// The unique device identifier that made the request (either deviceId or accountId must be used)
        device_id: Option<String>,
        /// The unique accountId that made the request (either deviceId or accountId must be used)
        account_id: Option<i64>,
        /// This is used for sending out group notifications. For example, when someone likes an asset which is also a part of an album, everyone in the album will receive a notification. This is achieved by passing in the permissionable type (in this case \"album\"), and the permissionable id (the album id). Possible types: {ALBUM, ALBUM_CONTEST, GAME_LEVEL, THEME_DESCRIPTOR}
        permissionable_type: Option<String>,
        /// The id of the permissionable object (for sending group notifications)
        permissionable_id: Option<i64>,
        /// determines whether the user likes or dislikes the object
        #[clap(short, long)]
        like: Option<bool>,
        /// This parameter is deprecated. This is deprecated, use \"appKey\" instead.
        app: Option<String>,
        /// This parameter is deprecated. This is deprecated, use \"appKey\" instead.
        game_type: Option<String>,
        /// the application key
        app_key: Option<String>,
        /// The current location of the user
        latitude: Option<f64>,
        /// The current location of the user
        longitude: Option<f64>,
    },
    /// Delete Like
    RemoveLike {
        version: f64,
        /// The type of the likable object {ALBUM, ALBUM_CONTEST, ASSET, GAME_LEVEL, NOTE, THEME_DESCRIPTOR}
        likable_type: String,
        /// The id of the likable object
        likable_id: i64,
        /// The unique device identifier that made the request (either deviceId or accountId must be used)
        device_id: Option<String>,
        /// The unique accountId that made the request (either deviceId or accountId must be used)
        account_id: Option<i64>,
        /// The current location of the user
        latitude: Option<f64>,
        /// The current location of the user
        longitude: Option<f64>,
    },
    /// Search Likes
    SearchLikes {
        version: f64,
        /// The type of the likable object {ALBUM, ALBUM_CONTEST, ASSET, GAME_LEVEL, NOTE, THEME_DESCRIPTOR}
        likable_type: String,
        /// The id of the likable object
        likable_id: i64,
        /// The unique device identifier that made the request (either deviceId or accountId must be used)
        device_id: Option<String>,
        /// The unique accountId that made the request (either deviceId or accountId must be used)
        account_id: Option<i64>,
        /// Comma separated list of account IDs for filtering on users
        connection_account_ids: Option<String>,
        /// The field to sort by. Possible values include: ID
        sort_field: Option<String>,
        /// Determines whether the sorted list is in descending or ascending order
        #[clap(short, long)]
        descending: Option<bool>,
        /// return items that have been updated since this date (time-stamp in milliseconds)
        updated_since: Option<i64>,
        /// return items that have been updated before this date (time-stamp in milliseconds)
        updated_before: Option<i64>,
        /// the start index for pagination
        start: Option<i32>,
        /// the limit for pagination
        limit: Option<i32>,
    },
    /// Create Listing
    CreateListing {
        version: f64,
        /// the user's account ID
        account_id: i64,
        /// the name of the listing
        name: String,
        /// comma separated list of filter IDs
        filter_ids: Option<String>,
        /// the description of the listing
        description: Option<String>,
        /// the start date of the listing
        start: Option<i64>,
        /// the end date of the listing
        end: Option<i64>,
        /// the name of the location the listing will be held at
        location_name: Option<String>,
        /// the description of the location the listing will be held at
        location_description: Option<String>,
        /// determines whether the listing is public or private
        #[clap(short, long)]
        is_private: Option<bool>,
        /// external identifier used by a third party
        external_id: Option<String>,
        /// secondary external identifier used by a third party
        external_id2: Option<String>,
        /// external group identifier used by a third party
        external_group_id: Option<String>,
        /// Sets the active flag
        #[clap(long)]
        active: Option<bool>,
        /// external custom client defined data
        meta_data: Option<String>,
    },
    /// Delete Listing
    DeleteListing {
        version: f64,
        /// the id of the logged in user
        account_id: i64,
        /// the id of the listing to delete
        listing_id: i64,
    },
    /// Get Listing
    GetListing {
        version: f64,
        /// the id of the listing to get
        listing_id: i64,
    },
    /// Search Listings
    SearchListing {
        version: f64,
        /// the account id of the user
        account_id: Option<i64>,
        /// search the event name and description for this keyword
        keyword: Option<String>,
        /// the record to begin the return set on
        start: Option<i32>,
        /// the number of records to return
        limit: Option<i32>,
        /// whether to search on active listings only
        #[clap(long)]
        active_only: Option<bool>,
        /// the current latitude of the user
        latitude: Option<f64>,
        /// the current longitude of the user
        longitude: Option<f64>,
        /// the start date to search from
        start_date: Option<i64>,
        /// the end date to search to
        end_date: Option<i64>,
        /// only return items of these categories
        category_ids: Option<String>,
        /// 
        filter_ids: Option<String>,
        /// determines whether to use configured listing order ids
        #[clap(short, long)]
        use_listing_order_ids: Option<bool>,
        /// external identifier used by a third party
        external_id: Option<String>,
        /// secondary external identifier used by a third party
        external_id2: Option<String>,
        /// external group identifier used by a third party
        external_group_id: Option<String>,
    },
    /// Summary Listing
    SummaryListing {
        version: f64,
        /// the account id of the user
        account_id: Option<i64>,
        /// the start date to search from
        start_date: Option<i64>,
        /// the list of categories to search on
        category_ids: Option<String>,
        /// how far out to search, in days
        days_to_include: Option<i32>,
        /// determines whether to use configured listing order ids
        #[clap(short, long)]
        use_listing_order_ids: Option<bool>,
    },
    /// Update Listing
    UpdateListing {
        version: f64,
        /// the user's account ID
        account_id: i64,
        /// the listing to update
        listing_id: i64,
        /// comma separated list of filter IDs
        filter_ids: Option<String>,
        /// the name of the listing
        name: Option<String>,
        /// the description of the listing
        description: Option<String>,
        /// the start date of the listing
        start: Option<i64>,
        /// the end date of the listing
        end: Option<i64>,
        /// the name of the location the listing will be held at
        location_name: Option<String>,
        /// the description of the location the listing will be held at
        location_description: Option<String>,
        /// determines whether the listing is public or private
        #[clap(short, long)]
        is_private: Option<bool>,
        /// external identifier used by a third party
        external_id: Option<String>,
        /// secondary external identifier used by a third party
        external_id2: Option<String>,
        /// external group identifier used by a third party
        external_group_id: Option<String>,
        /// Sets the active flag
        #[clap(long)]
        active: Option<bool>,
        /// external custom client defined data
        meta_data: Option<String>,
    },
    /// Create Trilateration Data with File
    CacheTrilaterationData {
        version: f64,
        /// The unique identifier of the source device
        udid: String,
        /// The current timestamp of the source device
        source_time: Option<i64>,
        /// the minimum number of Edysen devices that must be used to be able to trilaterate a device
        minimum_sample_size: Option<i32>,
        /// The json formated sample data:  ```json {    \"count\": 2,   \"timespan\": 10,    \"samples\": [     {       \"deviceId\": \"device1\",       \"randomizedId\": true,        \"deviceSignature\": \"probe:xyz...\",        \"alternativeId\":\"adc123\",        \"rssi\": [-63, -75]     },      {       \"deviceId\": \"device2\",       \"randomizedId\": true,        \"deviceSignature\": \"probe:xyz...\",        \"alternativeId\": \"adc123\",        \"rssi\": [-83, -79]     }   ] } ``` 
        data: Option<String>,
        /// Binary file containing data (multipart upload)
        #[clap(value_parser = parse_json::<swagger::ByteArray>)]
        data_file: Option<swagger::ByteArray>,
    },
    /// Create Trilateration Data with Rest
    CacheTrilaterationDataGzip {
        version: f64,
        #[clap(value_parser = parse_json::<models::TrilatCacheRequest>)]
        body: Option<models::TrilatCacheRequest>,
    },
    /// Get Location by IP
    GetLocationByIp {
        version: f64,
        /// the ip address of the client device
        ip: Option<String>,
    },
    /// Get Location by Trilateration
    GetLocationByTrilateration {
        version: f64,
        /// The account making the request, if provided the last know location will be updated
        account_id: Option<i64>,
        /// The known GPS latitude to compare to the calculated version
        latitude: Option<f64>,
        /// The known GPS longitude to compare to the calculated version
        longitude: Option<f64>,
        /// The json formated sample data:  ```json {    \"count\": 2,   \"timespan\": 10,    \"samples\": [     {       \"deviceId\": \"device1\",       \"rssi\": [-63, -75]     },      {       \"deviceId\": \"device2\",       \"rssi\": [-83, -79]     }   ] } ``` 
        data: Option<String>,
        /// Optional response filters (not used currently)
        response_filters: Option<String>,
    },
    /// Search Regions or Postal Codes
    GetLocations {
        version: f64,
        /// the device id
        device_id: Option<String>,
        /// the account id
        account_id: Option<i64>,
        /// This parameter is deprecated.
        currentlatitude: Option<f64>,
        /// This parameter is deprecated.
        currentlongitude: Option<f64>,
        /// the current latitude of the user
        current_latitude: Option<f64>,
        /// the current longitude of the user
        current_longitude: Option<f64>,
        /// the query results by keyword or address
        query: Option<String>,
        /// This parameter is deprecated.
        zipcode: Option<String>,
        /// the zip code to filter results
        zip_code: Option<String>,
        /// This parameter is deprecated.
        selected_maplatitude: Option<f64>,
        /// This parameter is deprecated.
        selected_maplongitude: Option<f64>,
        /// the latitude of where the search should originate from
        selected_map_latitude: Option<f64>,
        /// the longitude of where the search should originate from
        selected_map_longitude: Option<f64>,
        /// the search range of the search in miles
        search_range: Option<f64>,
        /// determines whether to allow searches via address
        #[clap(short, long)]
        use_geocode: Option<bool>,
        /// This parameter is deprecated.
        _i: Option<i32>,
        /// the start index for pagination
        start: Option<i32>,
        /// This parameter is deprecated.
        _l: Option<i32>,
        /// the limit for pagination
        limit: Option<i32>,
    },
    /// Create new location
    CreateLocationV2 {
        version: f64,
        #[clap(value_parser = parse_json::<models::Location>)]
        body: Option<models::Location>,
    },
    /// Update an existing location
    UpdateLocationV2 {
        version: f64,
        /// the id of the location to update
        id: i64,
        #[clap(value_parser = parse_json::<models::Location>)]
        body: Option<models::Location>,
    },
    /// Create Media
    CreateMedia {
        version: f64,
        /// The account id of the logged in user
        account_id: i64,
        /// The title (255 char limit)
        title: String,
        /// The bar code type {NONE, UPC, CODE_128, QR, CUSTOM_MEDIA}
        #[clap(value_parser = parse_json::<models::CreateMediaBarcodeTypeParameter>)]
        barcode_type: models::CreateMediaBarcodeTypeParameter,
        /// Overrides the expiration date so that the offer does not expire
        #[clap(short, long)]
        no_expiration: bool,
        /// The limit of how many times the offer can be used by consumers
        available_limit: i32,
        /// The limit of how many times a user can used the same offer
        available_limit_per_user: i32,
        /// The limit of how many times the offer can be added to consumer wallets
        added_limit: i32,
        /// The limit of how many times the offer can be viewed
        view_limit: i32,
        /// The maximum number of times the offer can be printed
        max_prints: i32,
        /// The cost of the offer in tickets
        ticket_price: i64,
        /// The retail/full price cost of the offer in real currency
        full_price: f64,
        /// The cost of the offer at a discounted price (what the consumer pays)
        discount_price: f64,
        /// The special offer type {ALL, REGULAR_OFFER, ACT_NOW, GET_THERE_NOW}
        #[clap(value_parser = parse_json::<models::CreateMediaSpecialOfferTypeParameter>)]
        special_offer_type: models::CreateMediaSpecialOfferTypeParameter,
        /// The offer visibility {PUBLIC, REWARDABLE, TRIGGERABLE}
        #[clap(value_parser = parse_json::<models::CreateMediaOfferVisibilityParameter>)]
        offer_visibility: models::CreateMediaOfferVisibilityParameter,
        /// Sets the active flag
        #[clap(long)]
        active: bool,
        /// Comma separated list of retailer location ids. This will assign the offer to these retailer locations.
        retailer_location_ids: Option<String>,
        /// The sub title (255 char limit)
        sub_title: Option<String>,
        /// The details of the media
        details: Option<String>,
        /// A string for custom details (255 char limit)
        sub_details: Option<String>,
        /// The fine print of the media
        fine_print: Option<String>,
        /// The bar code entry string
        barcode_entry: Option<String>,
        /// An external identifier. What the identifier will be used for and how it is formatted is up to the frontend developer
        external_redeem_options: Option<String>,
        /// The clickUrl of the offer
        external_url: Option<String>,
        /// The type of ticket to reward, null means default type
        tickets_reward_type: Option<String>,
        /// Determines how many tickets are awarded
        tickets_reward: Option<i64>,
        /// The date of when the offer will be visible to consumers
        activated: Option<i64>,
        /// The date of when the offer expires
        expires: Option<i64>,
        /// the type of ticket needed to buy offer
        ticket_price_type: Option<String>,
        /// show how many of the media is remaining (if there is a limit)
        #[clap(long)]
        show_remaining: Option<bool>,
        /// show how many of the media has been redeemed
        #[clap(long)]
        show_redeemed: Option<bool>,
        /// if the media has been replaced
        #[clap(short, long)]
        replaced: Option<bool>,
        /// if the media should be featured or not
        #[clap(long)]
        featured: Option<bool>,
        /// Comma separated list of category ids
        category_ids: Option<String>,
        /// Comma separated list of filter ids
        filter_ids: Option<String>,
        /// The id of the barcode asset
        barcode_asset_id: Option<i64>,
        /// The id of the an offer asset
        image_asset_id: Option<i64>,
        /// The id of the an offer asset
        image_asset_id1: Option<i64>,
        /// The id of the an offer asset
        image_asset_id2: Option<i64>,
        /// The id of the an offer asset
        image_asset_id3: Option<i64>,
        /// The id of the an offer asset
        image_asset_id4: Option<i64>,
        /// The id of the an offer asset
        image_asset_id5: Option<i64>,
        /// The maker of the item.
        publisher: Option<String>,
        /// The redeemable start date/time of the offer.
        redeemable_start: Option<i64>,
        /// The redeemable start date/time of the offer.
        redeemable_end: Option<i64>,
        /// The condition type of the media
        #[clap(value_parser = parse_json::<models::CreateMediaConditionTypeParameter>)]
        condition_type: Option<models::CreateMediaConditionTypeParameter>,
        /// The ISBN id
        isbn: Option<String>,
        /// The ASIN id
        asin: Option<String>,
        /// The list of catelog numbers, comma seperated
        catalog_numbers: Option<String>,
        /// The parental control rating
        parental_rating: Option<String>,
        /// The date the media is available to use
        availability_date: Option<i64>,
        /// the media type
        #[clap(value_parser = parse_json::<models::CreateMediaMediaTypeParameter>)]
        media_type: Option<models::CreateMediaMediaTypeParameter>,
        /// The total playing time of the media item
        duration: Option<i32>,
        /// The created/author of the media item
        author: Option<String>,
        /// The date/time of when the media item was originally released
        release_date: Option<i64>,
        /// the IDs of the collections this media should be assigned to
        collection_ids: Option<String>,
        /// ability to assign if this media should active or not
        availability: Option<String>,
        /// ability to assign when the media expires
        availability_summary: Option<String>,
    },
    /// Delete Media
    DeleteMedia {
        version: f64,
        /// the id of the logged in user
        account_id: i64,
        /// the ID of the media to delete
        media_id: i64,
    },
    /// Media Get
    GetMedia {
        version: f64,
        /// the id of the logged in user
        account_id: i64,
        /// the id of the media to get
        media_id: i64,
    },
    /// Search Media
    SearchMedia {
        version: f64,
        /// The logged in user.
        account_id: i64,
        /// Return only active results
        #[clap(long)]
        active_only: bool,
        /// The column to sort the search on. Possible values include: ID, CREATED, UPDATED, ACTIVE, ACTIVATED, EXPIRES, TITLE, SUBTITLE, DETAILS, OFFER_TYPE, SPECIAL_OFFER_TYPE, OFFER_VISIBILITY, ESTIMATED_VALUE, VOUCHER_PRICE, RETAILER_ID, RETAILER_NAME, RETAILER_LOCATION_ID, RETAILER_LOCATION_NAME, BILLABLE_ENTITY_ID, BILLABLE_ENTITY_NAME, RESPONSIBLE_DISPLAY, AVAILABILITY_DATE, RELEASE_DATE
        #[clap(value_parser = parse_json::<models::SearchEventsSortFieldParameter>)]
        sort_field: models::SearchEventsSortFieldParameter,
        /// The order to return the search results
        #[clap(short, long)]
        descending: bool,
        /// The keyword used to search
        keyword: Option<String>,
        /// 
        category_ids: Option<String>,
        /// 
        filter_ids: Option<String>,
        /// The record to begin the return set on
        start: Option<i32>,
        /// The number of records to return
        limit: Option<i32>,
    },
    /// Update Media
    UpdateMedia {
        version: f64,
        /// The account used to perform the update, must have rights to edit the offer (deviceId or accountId required)
        account_id: i64,
        /// 
        media_id: i64,
        /// Comma separated list of retailer location ids. This will assign the offer to these retailer locations.
        retailer_location_ids: Option<String>,
        /// A list of json data that has offer location specific values.
        offer_locations: Option<String>,
        /// The title (255 char limit)
        title: Option<String>,
        /// The sub title (255 char limit)
        sub_title: Option<String>,
        /// The details
        details: Option<String>,
        /// A string for custom details (255 char limit)
        sub_details: Option<String>,
        /// The fine print
        fine_print: Option<String>,
        /// The bar code type {NONE, UPC, CODE_128, QR, CUSTOM_MEDIA}
        #[clap(value_parser = parse_json::<models::CreateMediaBarcodeTypeParameter>)]
        barcode_type: Option<models::CreateMediaBarcodeTypeParameter>,
        /// The bar code entry string
        barcode_entry: Option<String>,
        /// An external identifier. What the identifier will be used for and how it is formatted is up to the frontend developer.
        external_redeem_options: Option<String>,
        /// The clickUrl of the offer
        external_url: Option<String>,
        /// The type of ticket to reward, null means default type
        tickets_reward_type: Option<String>,
        /// Determines how many tickets are awarded
        tickets_reward: Option<i64>,
        /// The date of when the offer will be visible to consumers
        activated: Option<i64>,
        /// The date of when the offer expires
        expires: Option<i64>,
        /// Overrides the expiration date so that the offer does not expire
        #[clap(short, long)]
        no_expiration: Option<bool>,
        /// The limit of how many times the offer can be used by consumers
        available_limit: Option<i32>,
        /// The limit of how many times a user can used the same offer
        available_limit_per_user: Option<i32>,
        /// The limit of how many times the offer can be added to consumer wallets
        added_limit: Option<i32>,
        /// 
        view_limit: Option<i32>,
        /// The maximum number of times the offer can be printed
        max_prints: Option<i32>,
        /// the type of ticket needed to buy the offer
        ticket_price_type: Option<String>,
        /// The cost of the offer in tickets
        ticket_price: Option<i64>,
        /// The retail/full price cost of the offer in real currency
        full_price: Option<f64>,
        /// The cost of the offer at a discounted price (what the consumer pays)
        discount_price: Option<f64>,
        /// The show remaining
        #[clap(long)]
        show_remaining: Option<bool>,
        /// The show redeemed
        #[clap(long)]
        show_redeemed: Option<bool>,
        /// The replaced
        #[clap(short, long)]
        replaced: Option<bool>,
        /// The featured
        #[clap(long)]
        featured: Option<bool>,
        /// The special offer type {ALL, REGULAR_OFFER, ACT_NOW, GET_THERE_NOW}
        #[clap(value_parser = parse_json::<models::CreateMediaSpecialOfferTypeParameter>)]
        special_offer_type: Option<models::CreateMediaSpecialOfferTypeParameter>,
        /// The offer visibility {PUBLIC, REWARDABLE, TRIGGERABLE}
        #[clap(value_parser = parse_json::<models::CreateMediaOfferVisibilityParameter>)]
        offer_visibility: Option<models::CreateMediaOfferVisibilityParameter>,
        /// Comma separated list of category ids
        category_ids: Option<String>,
        /// Comma separated list of filter ids
        filter_ids: Option<String>,
        /// Sets the active flag
        #[clap(long)]
        active: Option<bool>,
        /// The id of the barcode asset
        barcode_asset_id: Option<i64>,
        /// The id of the an offer asset
        image_asset_id: Option<i64>,
        /// The id of the an offer asset
        image_asset_id1: Option<i64>,
        /// The id of the an offer asset
        image_asset_id2: Option<i64>,
        /// The id of the an offer asset
        image_asset_id3: Option<i64>,
        /// The id of the an offer asset
        image_asset_id4: Option<i64>,
        /// The id of the an offer asset
        image_asset_id5: Option<i64>,
        /// The maker of the item.
        publisher: Option<String>,
        /// The redeemable start date/time of the offer.
        redeemable_start: Option<i64>,
        /// The redeemable start date/time of the offer.
        redeemable_end: Option<i64>,
        /// The condition. OfferType PRODUCT only.
        #[clap(value_parser = parse_json::<models::CreateMediaConditionTypeParameter>)]
        condition_type: Option<models::CreateMediaConditionTypeParameter>,
        /// The ISBN id. OfferType PRODUCT only.
        isbn: Option<String>,
        /// The ASIN id. OfferType PRODUCT only.
        asin: Option<String>,
        /// The list of catelog numbers, comma seperated. OfferType PRODUCT only.
        catalog_numbers: Option<String>,
        /// The date available. OfferType PRODUCT only.
        availability_date: Option<i64>,
        /// The parental control rating. OfferType PRODUCT only.
        parental_rating: Option<String>,
        /// 
        #[clap(value_parser = parse_json::<models::CreateMediaMediaTypeParameter>)]
        media_type: Option<models::CreateMediaMediaTypeParameter>,
        /// The total playing time of the media item. OfferType MEDIA only.
        duration: Option<i32>,
        /// The created/author of the media item. OfferType MEDIA only.
        author: Option<String>,
        /// The date/time of when the media item was originally released. OfferType MEDIA only.
        release_date: Option<i64>,
        /// 
        collection_ids: Option<String>,
        /// 
        availability: Option<String>,
        /// 
        availability_summary: Option<String>,
    },
    /// Create Mission
    CreateMission {
        version: f64,
        /// The logged in user.
        account_id: i64,
        /// The title of the mission
        title: String,
        /// The description of the mission
        description: Option<String>,
        /// Custom string client apps can use for searching/filtering missions
        sub_type: Option<String>,
        /// The date/time to start the mission, send 0 to unset
        start_date: Option<i64>,
        /// The date/time to end the mission, send 0 to unset
        end_date: Option<i64>,
        /// Activate/deactivate the mission
        #[clap(long)]
        active: Option<bool>,
        /// the game level ids to include in the mission, comma separated
        game_level_ids: Option<String>,
        /// creatives to associate with the mission
        creative_ids: Option<String>,
        /// audiences to associate with the mission
        audience_ids: Option<String>,
        /// This parameter is deprecated.
        mission_task: Option<String>,
        /// The string identifier for a mission format (this is not the missionFormatId)
        format_type: Option<String>,
        /// The offerId to give as a reward
        offer_id: Option<i64>,
        /// Set the amount of money available to spend, once 0 deactivate mission. Set to a negative value for unlimited.
        balance: Option<f64>,
        /// Flag to mark the mission as eligible for advanced reporting
        #[clap(long)]
        advanced_reporting: Option<bool>,
        /// Flag to indicate owner should receive tickets for completed missions
        #[clap(long)]
        allocate_tickets: Option<bool>,
        /// The number of tickets to reward
        ticket_count: Option<i64>,
        /// The type of ticket to reward, null means default type
        ticket_type: Option<String>,
        /// The number of points to award for completing a mission
        points: Option<i64>,
        /// external custom client defined data
        meta_data: Option<String>,
        /// Comma separated list of application ids
        application_ids: Option<String>,
        /// Deprecated parameter for device names
        devices: Option<String>,
        /// Comma separated list of device ids
        device_ids: Option<String>,
        /// Comma separated list of device version ranges
        device_versions: Option<String>,
        /// List of lat/long pairs for mission locations
        locations: Option<String>,
        /// Comma separated list of radii for locations
        radius: Option<String>,
    },
    /// Delete Mission
    DeleteMission {
        version: f64,
        /// the id of the logged in user
        account_id: i64,
        /// the id of the mission to delete
        mission_id: i64,
    },
    /// Find Missions
    FindMissions {
        version: f64,
        /// The application key, if provided return missions specific for the app. Will always return mission levels that are app agnostic.
        app_key: String,
        /// The type of mission to get, possible values are: click_banner, click_leaderboard, click_skyscraper, click_full, click_video, or click_zip
        suffix: Option<String>,
        /// The type of ads to get, possible values are: BANNER, LEADERBOARD, SKYSCRAPER, FULL, VIDEO, ZIP, CONFIG. Use this instead of suffix.
        param_type: Option<String>,
        /// The logged in user.
        account_id: Option<i64>,
        /// The version of the application, will not return levels newer than the appVersion.
        app_version: Option<String>,
        /// The current location of the requesting device
        latitude: Option<f64>,
        /// The current location of the requesting device
        longitude: Option<f64>,
        /// Should use deviceId if possible. The name of the requesting device; possible values are: Android, iPhone, iPad, iPod, etc. use /audience/devices for list.
        device: Option<String>,
        /// The device ID of the requesting device, use /audience/devices for list
        device_identifier: Option<i64>,
        /// The requesting device version; examples are: 2.3, 5.1.4, 6.1.4. Supports X, X.X, or X.X.X formated string.
        device_version: Option<String>,
        /// The index into the record set to start with.
        start: Option<i32>,
        /// The total number of record to return.
        limit: Option<i32>,
        /// Include the game level data with the mission.
        #[clap(long)]
        include_game_data: Option<bool>,
        /// If true then return the audience data in the response. Default is false.
        #[clap(long)]
        include_audiences: Option<bool>,
        /// If true/false only return missions whose game levels allocate (or don't allocate) tickets. Do not provide a value to return both.
        #[clap(long)]
        allocates_tickets: Option<bool>,
        /// return a random set of results, default is true. If false returns in natural order.
        #[clap(short, long)]
        randomize: Option<bool>,
        /// return only ads targeted to the specific app, no global ads.
        #[clap(short, long)]
        targeted_ads_only: Option<bool>,
        /// return only ads from the specified campaigns.
        mission_ids: Option<String>,
        /// will return the items that have at least 1 or all of their audiences exist in the logged in users audiences, depending if the value is OR or AND
        audience_operator: Option<String>,
    },
    /// Get Mission
    GetMission {
        version: f64,
        /// The logged in user.
        account_id: i64,
        /// The id of the mission to return.
        mission_id: i64,
        /// Return creatives associated with the mission when true
        #[clap(short, long)]
        return_creative: Option<bool>,
    },
    /// Import Mission
    ImportMission {
        version: f64,
        /// The logged in user.
        account_id: i64,
        /// The current location of the requesting device
        latitude: f64,
        /// The current location of the requesting device
        longitude: f64,
        /// the application key
        app_key: String,
        /// the keyword of the mission
        keyword: Option<String>,
        /// The starting index in the result set to return. Default is 0.
        start: Option<i32>,
        /// The total number of records to return. Default is 20.
        limit: Option<i32>,
        /// the size of the ad
        #[clap(value_parser = parse_json::<models::CreateApplicationPlacementSizeParameter>)]
        ad_size: Option<models::CreateApplicationPlacementSizeParameter>,
    },
    /// Search Mission Formats
    SearchMissionFormats {
        version: f64,
        /// The starting index in the result set to return. Default is 0.
        start: i32,
        /// The total number of records to return. Default is 20.
        limit: i32,
        /// Determines whether to return only active results. Default is false.
        #[clap(long)]
        active_only: bool,
    },
    /// Search Missions
    SearchMissions {
        version: f64,
        /// The logged in user.
        account_id: i64,
        /// Filter by keyword
        keyword: Option<String>,
        /// Custom string client apps can use for searching/filtering missions
        sub_type: Option<String>,
        /// The index into the record set to start with. Default is 0.
        start: Option<i32>,
        /// The total number of record to return. Default is 20, maximum is 100.
        limit: Option<i32>,
        /// If true then return the game level data in the response. Default is false.
        #[clap(long)]
        include_game_data: Option<bool>,
        /// If true then return the audience data in the response. Default is false.
        #[clap(long)]
        include_audiences: Option<bool>,
        /// If true then include inactive missions. Default is false.
        #[clap(long)]
        include_inactive: Option<bool>,
        /// A list of game types to include; click_leaderboard, click_banner, click_skyscraper, click_full, click_video, click_zip, create, vote, question, invite, share, json, xml
        suffix: Option<String>,
        /// The field to sort the search on (for example TITLE)
        sort_field: Option<String>,
        /// Whether to sort in descending order (default true)
        #[clap(short, long)]
        descending: Option<bool>,
    },
    /// Search Missions by Billable Entity
    SearchMissionsByBillableEntity {
        version: f64,
        /// The logged in user.
        account_id: i64,
        /// Filter by keyword
        keyword: Option<String>,
        /// The index into the record set to start with. Default is 0.
        start: Option<i32>,
        /// The total number of record to return. Default id 20.
        limit: Option<i32>,
        /// If true then return the game level data in the response. Default is false.
        #[clap(long)]
        include_game_data: Option<bool>,
        /// If true then return the audience data in the response. Default is false.
        #[clap(long)]
        include_audiences: Option<bool>,
        /// If true then include inactive missions. Default is false.
        #[clap(long)]
        include_inactive: Option<bool>,
        /// A list of game types to include; click_leaderboard, click_banner, click_skyscraper, click_full, click_video, click_zip, create, vote, question, invite, share, json, xml
        suffix: Option<String>,
        /// The field to sort the search on (for example TITLE)
        sort_field: Option<String>,
        /// Whether to sort in descending order (default true)
        #[clap(short, long)]
        descending: Option<bool>,
    },
    /// Update Mission
    UpdateMission {
        version: f64,
        /// The logged in user.
        account_id: i64,
        /// The id of the mission to update.
        mission_id: i64,
        /// The title of the mission
        title: Option<String>,
        /// The description of the mission
        description: Option<String>,
        /// Custom string client apps can use for searching/filtering missions
        sub_type: Option<String>,
        /// external custom client defined data
        meta_data: Option<String>,
        /// The date/time to start the mission, send 0 to unset
        start_date: Option<i64>,
        /// The date/time to end the mission, send 0 to unset
        end_date: Option<i64>,
        /// Activate/deactivate the mission
        #[clap(long)]
        active: Option<bool>,
        /// the game level ids to include in the mission, comma separated
        game_level_ids: Option<String>,
        /// 
        creative_ids: Option<String>,
        /// 
        audience_ids: Option<String>,
        /// The offerId to give as a reward
        offer_id: Option<i64>,
        /// Replace the amount of money available to spend, once 0 deactivate mission. Set to a negative value for unlimited.
        balance: Option<f64>,
        /// Flag to mark the mission as eligible for advanced reporting
        #[clap(long)]
        advanced_reporting: Option<bool>,
        /// Flag to indicate owner should receive tickets for completed missions
        #[clap(long)]
        allocate_tickets: Option<bool>,
        /// The number of tickets to reward
        ticket_count: Option<i64>,
        /// The type of ticket to reward, null means default type
        ticket_type: Option<String>,
        /// The number of points to award for completing a mission
        points: Option<i64>,
        /// Comma separated list of application ids
        application_ids: Option<String>,
        /// Deprecated parameter for device names
        devices: Option<String>,
        /// Comma separated list of device ids
        device_ids: Option<String>,
        /// Comma separated list of device version ranges
        device_versions: Option<String>,
        /// List of lat/long pairs for mission locations
        locations: Option<String>,
        /// Comma separated list of radii for locations
        radius: Option<String>,
    },
    /// Create Mission Invite
    CreateMissionInvite {
        version: f64,
        /// the device id (deviceId or accountId required).
        device_id: Option<String>,
        /// the account id of the user (deviceId or accountId required).
        account_id: Option<i64>,
        /// The mission to find the invite for.
        mission_id: Option<i64>,
        /// code to be entered for user to join the mission
        join_code: Option<String>,
        /// Include the game level data with the mission.
        #[clap(short, long)]
        include_game_data: Option<bool>,
    },
    /// Delete Mission Invite
    DeleteMissionInvite {
        version: f64,
        /// the device id (deviceId or accountId required).
        device_id: Option<String>,
        /// the account id of the user (deviceId or accountId required).
        account_id: Option<i64>,
        /// The mission to find the invite for (missionId or missionInviteId requried).
        mission_id: Option<i64>,
        /// The mission invite id. This checks on the user's billable for permission (missionId or missionInviteId requried).
        mission_invite_id: Option<i64>,
        /// Include the game level data with the mission.
        #[clap(short, long)]
        include_game_data: Option<bool>,
    },
    /// Get Mission Invite
    GetMissionInvite {
        version: f64,
        /// the device id (deviceId or accountId required).
        device_id: Option<String>,
        /// the account id of the user (deviceId or accountId required).
        account_id: Option<i64>,
        /// The mission to find the invite for (missionId or missionInviteId requried).
        mission_id: Option<i64>,
        /// The mission invite id. This checks on the user's billable for permission (missionId or missionInviteId requried).
        mission_invite_id: Option<i64>,
        /// Include the game level data with the mission.
        #[clap(short, long)]
        include_game_data: Option<bool>,
        /// include the scores with the mission
        include_scores: Option<String>,
    },
    /// Search Mission Invites
    SearchMissionInvites {
        version: f64,
        /// the device id (deviceId or accountId required).
        device_id: Option<String>,
        /// the account id of the user (deviceId or accountId required).
        account_id: Option<i64>,
        /// the app to retrieve the data for, use your application key.
        app_key: Option<String>,
        /// the application version, used to version the game level data
        app_version: Option<String>,
        /// the mission id to filter on
        mission_id: Option<i64>,
        /// The invite status to filter for, comma separated list {AVAILABLE, PENDING, UPDATED, ACCEPTED, ACTIVE, QUIT, COMPLETED, PENDING_REVIEW, REJECTED}
        status: Option<String>,
        /// Only return invites that have been updated since this date/time (long)
        last_updated: Option<i64>,
        /// The index into the record set to start with.
        start: Option<i32>,
        /// The total number of record to return.
        limit: Option<i32>,
        /// the keyword to search on
        keyword: Option<String>,
        /// 
        mission_types: Option<String>,
        /// filter results by the account's billable
        #[clap(long)]
        filter_by_billable: Option<bool>,
        /// Include the game level data with the mission.
        #[clap(short, long)]
        include_game_data: Option<bool>,
    },
    /// Update Mission Invite
    UpdateMissionInvite {
        version: f64,
        /// the device id (deviceId or accountId required).
        device_id: Option<String>,
        /// the account id of the user (deviceId or accountId required).
        account_id: Option<i64>,
        /// the application key
        app_key: Option<String>,
        /// The mission to find the invite for (missionId or missionInviteId requried).
        mission_id: Option<i64>,
        /// The mission invite id. This checks on the user's billable for permission (missionId or missionInviteId requried).
        mission_invite_id: Option<i64>,
        /// the pack id to find the invite for
        pack_id: Option<i64>,
        /// the game level id to find the invite for
        game_level_id: Option<i64>,
        /// The invite status to filter for, comma separated list {AVAILABLE, PENDING, UPDATED, ACCEPTED, ACTIVE, QUIT, COMPLETED, PENDING_REVIEW, REJECTED}
        status: Option<String>,
        /// This is the content type for missions that require user submission. Note that user submitted content must require a status of PENDING_REVIEW to be accpeted. {ACCOUNT, GAMELEVEL, COLLECTION, ALBUM_CONTEST, THEME_DESCRIPTOR, ALBUM}
        permissionable_type: Option<String>,
        /// The id of the content being submitted.
        permissionable_id: Option<i64>,
        /// Include the game level data with the mission.
        #[clap(short, long)]
        include_game_data: Option<bool>,
    },
    /// Batch Note Operation
    BatchOperation {
        version: f64,
        /// The id of the notable object the batch operation will affect
        notable_id: i64,
        /// The notable object type (for example ALBUM, ASSET, OFFER, etc.)
        notable_type: String,
        /// The device id (deviceId or accountId required)
        device_id: Option<String>,
        /// The account id of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// The batch operation to perform (e.g., DELETE_ALL_NOTES_IN_NOTABLE). Optional.
        batch_operation: Option<String>,
    },
    /// Create Note
    CreateNote {
        version: f64,
        /// The message the user wishes to leave a comment on
        comment: String,
        /// The unique device identifier that made the request (either deviceId or accountId must be used)
        device_id: Option<String>,
        /// The unique accountId that made the request (either deviceId or accountId must be used)
        account_id: Option<i64>,
        /// The notable object type {ALBUM, ALBUM_CONTEST, ASSET, GAME_LEVEL, OFFER, OFFER_LOCATION, RETAILER, RETAILER_LOCATION, THEME_DESCRIPTOR}
        notable_type: Option<String>,
        /// The id of the notable object
        notable_id: Option<i64>,
        /// The custom string defined by the client (used for differentiating various note types)
        note_type: Option<String>,
        /// A comma separated list of asset IDs to add with the note
        asset_ids: Option<String>,
        /// search tags
        tags: Option<String>,
        /// This is used for sending out group notifications. For example, when someone adds a note to an asset which is also a part of an album, everyone in the album will receive a notification. This is achieved by passing in the permissionable type (in this case \"album\"), and the permissionable id (the album id). Possible types: {ALBUM, ALBUM_CONTEST, GAME_LEVEL, THEME_DESCRIPTOR}
        permissionable_type: Option<String>,
        /// The id of the permissionable object (for sending group notifications)
        permissionable_id: Option<i64>,
        /// The application key used to identify the application
        app_key: Option<String>,
        /// The description of the location
        location_description: Option<String>,
        /// The current location of the user
        latitude: Option<f64>,
        /// The current location of the user
        longitude: Option<f64>,
        /// External custom client defined data
        meta_data: Option<String>,
        /// Comma separated list of additional account IDs that will receive the note notifications
        receiver_account_ids: Option<String>,
        /// whether to return the full response or not
        #[clap(short, long)]
        return_full_response: Option<bool>,
        /// Check true if need to initialize an asset and assign to current note
        #[clap(short, long)]
        initialize_asset: Option<bool>,
        /// Return null fields for asset response when creating an asset
        #[clap(long)]
        asset_return_nulls: Option<bool>,
        /// the album the asset will be added to (optional)
        asset_album_id: Option<i64>,
        /// the collection ID that the asset is associated with
        asset_collection_id: Option<i64>,
        /// the default album to add the asset to
        asset_add_to_default_album: Option<String>,
        /// the media library to add the asset to
        #[clap(long)]
        asset_add_to_media_library: Option<bool>,
        /// the version code of the asset
        asset_version_code: Option<i32>,
        /// the version name of the asset
        asset_version_name: Option<String>,
        /// the meta data of the asset
        asset_meta_data: Option<String>,
        /// the caption of the asset
        asset_caption: Option<String>,
        /// the media of the asset
        #[clap(value_parser = parse_json::<swagger::ByteArray>)]
        asset_media: Option<swagger::ByteArray>,
        /// the media URL of the asset
        asset_media_url: Option<String>,
        /// the media string of the asset
        asset_media_string: Option<String>,
        /// the media string file name of the asset
        asset_media_string_file_name: Option<String>,
        /// the media string content type of the asset
        asset_media_string_content_type: Option<String>,
        /// the attached media of the asset
        #[clap(value_parser = parse_json::<swagger::ByteArray>)]
        asset_attached_media: Option<swagger::ByteArray>,
        /// the attached media URL of the asset
        asset_attached_media_url: Option<String>,
        /// the attached media string of the asset
        asset_attached_media_string: Option<String>,
        /// the attached media string file name of the asset
        asset_attached_media_string_file_name: Option<String>,
        /// the attached media string content type of the asset
        asset_attached_media_string_content_type: Option<String>,
        /// the location description for the asset
        asset_location_description: Option<String>,
        /// the application for the asset
        asset_app: Option<String>,
        /// the search tags used for the asset
        asset_search_tags: Option<String>,
        /// the latitude of the asset
        asset_latitude: Option<f64>,
        /// the longitude of the asset
        asset_longitude: Option<f64>,
    },
    /// Delete Note
    DeleteNote {
        version: f64,
        /// The ID of the note to delete
        note_id: i64,
        /// The unique device identifier that made the request (either deviceId or accountId must be used)
        device_id: Option<String>,
        /// The unique accountId that made the request (either deviceId or accountId must be used)
        account_id: Option<i64>,
        /// The current location of the user
        latitude: Option<f64>,
        /// The current location of the user
        longitude: Option<f64>,
        /// The application key used to identify the application
        app_key: Option<String>,
    },
    /// Get Note
    GetNote {
        version: f64,
        /// the id of the note to get
        note_id: i64,
        /// The unique device identifier that made the request (either deviceId or accountId must be used)
        device_id: Option<String>,
        /// The unique accountId that made the request (either deviceId or accountId must be used)
        account_id: Option<i64>,
        /// Determines whether to return the NoteFullResponse for the item
        #[clap(short, long)]
        return_full_response: Option<bool>,
    },
    /// Search Notes
    SearchNotes {
        version: f64,
        /// The device id (deviceId or accountId required)
        device_id: Option<String>,
        /// The account id of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// The notable object type {ALBUM, ALBUM_CONTEST, ASSET, GAME_LEVEL, OFFER, OFFER_LOCATION, RETAILER, RETAILER_LOCATION, THEME_DESCRIPTOR}
        notable_type: Option<String>,
        /// The id of the notable object
        notable_id: Option<i64>,
        /// Comma separated list of noteType strings to filter results with
        note_types: Option<String>,
        /// The application key used to identify the application
        app_key: Option<String>,
        /// The keyword used to search
        keyword: Option<String>,
        /// return items that has flagCount >= flagCountMinimum if this is set, return all items, even ones with flagCount >= flagThreshold
        flag_count_minimum: Option<i64>,
        /// return items that has flagCount >= flagThreshold, which are hidden by default
        #[clap(long)]
        flags_exceed_threshold: Option<bool>,
        /// include inactive in the result
        #[clap(short, long)]
        include_inactive: Option<bool>,
        /// The column to sort the search on
        #[clap(value_parser = parse_json::<models::SearchNotesSortFieldParameter>)]
        sort_field: Option<models::SearchNotesSortFieldParameter>,
        /// The order to return the search results
        #[clap(short, long)]
        descending: Option<bool>,
        /// Determines whether to return the NoteFullResponse for each search item
        #[clap(short, long)]
        return_full_response: Option<bool>,
        /// return items that have been updated since this date (time-stamp in milliseconds)
        updated_since: Option<i64>,
        /// return items that have been updated before this date (time-stamp in milliseconds)
        updated_before: Option<i64>,
        /// The record to begin the return set on
        start: Option<i32>,
        /// The number of records to return
        limit: Option<i32>,
    },
    /// Update Note
    UpdateNote {
        version: f64,
        /// The id of the note, used when editing a comment
        note_id: i64,
        /// The unique device identifier that made the request (either deviceId or accountId must be used)
        device_id: Option<String>,
        /// The unique accountId that made the request (either deviceId or accountId must be used)
        account_id: Option<i64>,
        /// The message the user wishes to leave a comment on
        comment: Option<String>,
        /// The custom string defined by the client (used for differentiating on various note types)
        note_type: Option<String>,
        /// A comma separated list of asset IDs to add with the note
        asset_ids: Option<String>,
        /// search tags
        tags: Option<String>,
        /// This is used for sending out group notifications. For example, when someone adds a note to an asset which is also a part of an album, everyone in the album will receive a notification. This is achieved by passing in the permissionable type (in this case \"album\"), and the permissionable id (the album id). Possible types: {ALBUM, ALBUM_CONTEST, GAME_LEVEL, THEME_DESCRIPTOR}
        permissionable_type: Option<String>,
        /// The id of the permissionable object (for sending group notifications)
        permissionable_id: Option<i64>,
        /// The application key used to identify the application
        app_key: Option<String>,
        /// The description of the location
        location_description: Option<String>,
        /// The current location of the user
        latitude: Option<f64>,
        /// The current location of the user
        longitude: Option<f64>,
        /// meta data to update with the note
        meta_data: Option<String>,
        /// whether to return the full response or not
        #[clap(short, long)]
        return_full_response: Option<bool>,
        /// Sets the active flag for the note
        #[clap(long)]
        active: Option<bool>,
        /// main flag for updating asset in note, must set to true if you want to update the note's asset
        #[clap(short, long)]
        update_asset: Option<bool>,
        /// Return null fields for asset response when updating an asset
        #[clap(long)]
        asset_return_nulls: Option<bool>,
        /// the album the asset will be added to (optional)
        asset_album_id: Option<i64>,
        /// the collection ID that the asset is associated with
        asset_collection_id: Option<i64>,
        /// the default album to add the asset to
        asset_add_to_default_album: Option<String>,
        /// the media library to add the asset to
        #[clap(long)]
        asset_add_to_media_library: Option<bool>,
        /// the version code of the asset
        asset_version_code: Option<i32>,
        /// the version name of the asset
        asset_version_name: Option<String>,
        /// the meta data of the asset
        asset_meta_data: Option<String>,
        /// the caption of the asset
        asset_caption: Option<String>,
        /// the media of the asset
        #[clap(value_parser = parse_json::<swagger::ByteArray>)]
        asset_media: Option<swagger::ByteArray>,
        /// the media URL of the asset
        asset_media_url: Option<String>,
        /// the media string of the asset
        asset_media_string: Option<String>,
        /// the media string file name of the asset
        asset_media_string_file_name: Option<String>,
        /// the media string content type of the asset
        asset_media_string_content_type: Option<String>,
        /// the attached media of the asset
        #[clap(value_parser = parse_json::<swagger::ByteArray>)]
        asset_attached_media: Option<swagger::ByteArray>,
        /// the attached media URL of the asset
        asset_attached_media_url: Option<String>,
        /// the attached media string of the asset
        asset_attached_media_string: Option<String>,
        /// the attached media string file name of the asset
        asset_attached_media_string_file_name: Option<String>,
        /// the attached media string content type of the asset
        asset_attached_media_string_content_type: Option<String>,
        /// the location description for the asset
        asset_location_description: Option<String>,
        /// the application for the asset
        asset_app: Option<String>,
        /// the search tags used for the asset
        asset_search_tags: Option<String>,
        /// the latitude of the asset
        asset_latitude: Option<f64>,
        /// the longitude of the asset
        asset_longitude: Option<f64>,
    },
    /// Create Notification Template
    CreateNotificationTemplate {
        version: f64,
        /// The account ID of the user.
        account_id: i64,
        /// Filter results by notification type: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION.
        conduit: String,
        /// title of the notification template
        title: String,
        /// body of the notification template
        body: String,
        /// Filter results by application.
        app_key: Option<String>,
        /// Filter results by event.
        event: Option<String>,
        /// tags associated with the note template
        tags: Option<String>,
    },
    /// Create or update blocked notification settings
    CreateOrUpdateBlockedNotifications {
        version: f64,
        /// The application key
        app_key: String,
        /// batch data payload (application specific)
        data: String,
        /// the account id of the user
        account_id: Option<i64>,
    },
    /// Delete Notification Template
    DeleteNotificationTemplate {
        version: f64,
        /// the account id of the user
        account_id: i64,
        /// the id of the notification template to delete
        notification_template_id: i64,
    },
    /// Get Notification Template
    GetNotificationTemplate {
        version: f64,
        /// the id of the account
        account_id: i64,
        /// the id of the notification template to get
        notification_template_id: i64,
    },
    /// Get Notifications
    GetNotifications {
        version: f64,
        /// the unique id of the device making the request (deviceId or accountId required)
        device_id: Option<String>,
        /// the account id of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// the account id used to view another person's notifications
        connection_account_id: Option<i64>,
        /// the application key to filter messages by application
        app_key: Option<String>,
        /// comma separated list of EVENTS. Filters search results to only include these events. Don't include this parameter or pass in an empty string to return all event types.
        event_type: Option<String>,
        /// comma separated list of content ids to search notifications on
        content_ids: Option<String>,
        /// comma separated list of content types to search notifications on
        content_types: Option<String>,
        /// comma separated list of parent ids to search notifications on
        parent_ids: Option<String>,
        /// comma separated list of parent types to search notifications on
        parent_types: Option<String>,
        /// Action category used to filter notifications
        action_category: Option<String>,
        /// comma separated list of conduits to search notifications on
        conduits: Option<String>,
        /// search notifications via keyword
        keyword: Option<String>,
        /// if set to true, will return notifications that have been marked as read
        #[clap(long)]
        return_read_messages: Option<bool>,
        /// if set to true, the returned notifications will be marked as \\\"read\\\" after the response has been sent
        #[clap(short, long)]
        mark_as_read: Option<bool>,
        /// filter notifications from this date
        from_date: Option<i64>,
        /// latitude used to update the user's current location
        latitude: Option<f64>,
        /// longitude used to update the user's current location
        longitude: Option<f64>,
        /// whether to include notifications sent by the requester in the response
        #[clap(long)]
        return_sent: Option<bool>,
        /// whether to ignore flagged notifications
        #[clap(short, long)]
        ignore_flagged: Option<bool>,
        /// start of the pagination
        start: Option<i32>,
        /// limit of the pagination
        limit: Option<i32>,
    },
    /// Register Notification Token
    RegisterNotificationToken {
        version: f64,
        /// A token that is generated by the device to sign requests for the notification service providers
        token: String,
        /// The type of push notification. Possible values include: APNS, GCM
        #[clap(value_parser = parse_json::<models::RegisterNotificationTokenPushTypeParameter>)]
        push_type: models::RegisterNotificationTokenPushTypeParameter,
        /// The unique id of the device making the request (deviceId or accountId required)
        device_id: Option<String>,
        /// The account id of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// Determines if the token is a DEVELOPMENT or PRODUCTION token
        environment: Option<String>,
        /// The application key
        app_key: Option<String>,
        /// This parameter is deprecated (use appKey instead)
        game_type: Option<String>,
        /// Sets whether the token is active or not (non-active tokens are not used)
        #[clap(long)]
        active: Option<bool>,
        /// Latitude used to update the user's current location
        latitude: Option<f64>,
        /// Longitude used to update the user's current location
        longitude: Option<f64>,
    },
    /// Search on the user's blocked notification settings
    SearchBlockedNotifications {
        version: f64,
        /// The application key
        app_key: String,
        /// the account id of the user
        account_id: Option<i64>,
        /// search tags to filter results
        search_tags: Option<String>,
        /// events to filter by (comma separated)
        events: Option<String>,
        /// conduits to filter by (comma separated)
        conduits: Option<String>,
        /// custom types to filter by (comma separated)
        custom_types: Option<String>,
        /// content types to filter by (comma separated)
        content_types: Option<String>,
        /// content ids to filter by (comma separated)
        content_ids: Option<String>,
        /// sort field for results
        sort_field: Option<String>,
        /// whether to sort descending
        #[clap(short, long)]
        descending: Option<bool>,
        /// start of the pagination
        start: Option<i32>,
        /// limit of the pagination
        limit: Option<i32>,
    },
    /// Search Notification Templates
    SearchNotificationTemplate {
        version: f64,
        /// The account ID of the user.
        account_id: i64,
        /// Specifies how results are ordered.ID - order results by the notificationTemplateId CREATED - order results by the created date UPDATED - order results by the updated date TITLE - order results by title EVENT - order results by event CONDUIT - order results by conduit APP_NAME - order results by the application name ('global' templates will not have an application and will be returned last if 'descending' is set to false.
        sort_field: String,
        /// Specified whether the results are returned in descending or ascending order.
        #[clap(short, long)]
        descending: bool,
        /// The start of the pagination.
        start: i32,
        /// The limit of the pagination.
        limit: i32,
        /// Filter results by application.
        app_key: Option<String>,
        /// Filter results by event.
        event: Option<String>,
        /// Filter results by notification type: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION.
        conduit: Option<String>,
        /// Returns only templates that have been reserved for system use on all applications (only for admin accounts).
        #[clap(short, long)]
        global_only: Option<bool>,
        /// Returns only templates that use reserved events.
        #[clap(short, long)]
        reserved_only: Option<bool>,
        /// Filter results by keyword on the title, tags.
        keyword: Option<String>,
    },
    /// Search for Recipients
    SearchRecipients {
        version: f64,
        /// The field to sort by. Possible values include: {ACCOUNT_DISPLAY, CREATED, UPDATED, ACTIVE, DELETED, LAST_LOGGED_IN, CONTACT_EMAIL, RETAILER_LOCATION_NAME, RETAILER_NAME, APPLICATION_NAME}
        #[clap(value_parser = parse_json::<models::SearchRecipientsSortFieldParameter>)]
        sort_field: models::SearchRecipientsSortFieldParameter,
        /// the unique id of the device making the request (deviceId or accountId required)
        device_id: Option<String>,
        /// the account id of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// filters results by application. If this is empty, will return all recipients for all applications that the user has access to.
        app_key: Option<String>,
        /// the type of notification to send: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION.
        conduit: Option<String>,
        /// search by keyword on user's display name and email
        keyword: Option<String>,
        /// This parameter is deprecated. filter results by audience
        audience_id: Option<i64>,
        /// filter results by audiences (comma separated list of audience ids)
        audience_ids: Option<String>,
        /// filter results by connection groups (comma separated list of connection group ids)
        connection_group_ids: Option<String>,
        /// filter results by accounts (comma separated list of account ids)
        recipient_account_ids: Option<String>,
        /// Determines whether the sorted list is in descending or ascending order
        #[clap(short, long)]
        descending: Option<bool>,
        /// start of the pagination
        start: Option<i32>,
        /// limit of the pagination (hard limit of 1000)
        limit: Option<i32>,
    },
    /// Search for Recipients (Counts/Grouped)
    SearchRecipientsCount {
        version: f64,
        /// the unique id of the device making the request (deviceId or accountId required)
        device_id: Option<String>,
        /// the account id of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// filters results by application. If this is empty, will return all recipients for all applications that the user has access to.
        app_key: Option<String>,
        /// the type of notification to send: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION.
        conduit: Option<String>,
        /// search by keyword on user's display name and email
        keyword: Option<String>,
        /// This parameter is deprecated. filter results by audience
        audience_id: Option<i64>,
        /// filter results by audiences (comma separated list of audience ids)
        audience_ids: Option<String>,
        /// filter results by connection groups (comma separated list of connection group ids)
        connection_group_ids: Option<String>,
        /// The field to sort by (see API docs for allowed values).
        sort_field: Option<String>,
        /// Determines whether the sorted list is in descending or ascending order
        #[clap(short, long)]
        descending: Option<bool>,
        /// start of the pagination
        start: Option<i32>,
        /// limit of the pagination
        limit: Option<i32>,
    },
    /// Send Batch Notifications
    SendBatchNotifications {
        version: f64,
        /// The account id of the application owner/manager
        account_id: i64,
        /// The application key for updating an existing application
        app_key: String,
        /// Message string that will be displayed in on the notification
        custom_message: String,
        /// The type of notification to send: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION.
        conduit: Option<String>,
        /// Default notification pay-load field (usage is dependent on the app and the type of event)
        content_id: Option<i64>,
        /// Default notification pay-load field (usage is dependent on the app and the type of event)
        content_name: Option<String>,
        /// Default notification pay-load field (usage is dependent on the app and the type of event)
        content_type: Option<String>,
        /// Default notification pay-load field (usage is dependent on the app and the type of event)
        parent_id: Option<i64>,
        /// Default notification pay-load field (usage is dependent on the app and the type of event)
        parent_type: Option<String>,
    },
    /// Send Custom Notifications
    SendCustomNotifications {
        version: f64,
        /// the unique id of the device making the request (deviceId or accountId required)
        device_id: Option<String>,
        /// the account id of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// comma separated list of account IDs that will receive the notification
        receiver_account_ids: Option<String>,
        /// determines whether to send to all of the user's friends, this flag must be true or receiverAccountIds must not be empty
        #[clap(short, long)]
        include_friend_group: Option<bool>,
        /// the application key
        app_key: Option<String>,
        /// This parameter is deprecated.
        game_type: Option<String>,
        /// the type of notification to send: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION.
        conduit: Option<String>,
        /// default notification pay-load field (usage is dependent on the app and the type of event)
        content_id: Option<i64>,
        /// default notification pay-load field (usage is dependent on the app and the type of event)
        content_name: Option<String>,
        /// default notification pay-load field (usage is dependent on the app and the type of event)
        content_type: Option<String>,
        /// default notification pay-load field (usage is dependent on the app and the type of event)
        parent_id: Option<i64>,
        /// default notification pay-load field (usage is dependent on the app and the type of event)
        parent_type: Option<String>,
        /// 
        action_category: Option<String>,
        /// the subject line of an email #@param customPayload custom json definition of notification pay-load (usage is dependent on the app and the type of event)
        subject: Option<String>,
        /// message string that will be displayed in on the notification
        custom_message: Option<String>,
        /// only sends APNS to people who are friends of the user (still saves the notification message for feed polling)
        #[clap(long)]
        friend_only_apns: Option<bool>,
        /// latitude used to update the user's current location
        latitude: Option<f64>,
        /// longitude used to update the user's current location
        longitude: Option<f64>,
    },
    /// Update Notification Template
    UpdateNotificationTemplate {
        version: f64,
        /// The account ID of the user.
        account_id: i64,
        /// The notification template ID to update.
        notification_template_id: i64,
        /// The title of the message (this would become the subject title for emails). There is a 191 character limit.
        title: Option<String>,
        /// The body of the message.
        body: Option<String>,
        /// The search tags on the template used during search queries.
        tags: Option<String>,
    },
    /// Create Field
    AddField {
        version: f64,
        /// The account id of the logged in user
        account_id: i64,
        /// The application key for updating an existing application
        app_key: String,
        /// The name of the object to add the field to
        object_name: String,
        /// field name The name of the field to add.
        field_name: String,
        /// field type The field type to create, supported types are: STRING, DATE, NUMBER, BOOLEAN, IDENTITY
        field_type: String,
    },
    /// Create Object
    CreateObject {
        version: f64,
        /// The account id of the logged in user
        account_id: i64,
        /// The application key for updating an existing application
        app_key: String,
        /// The name of the object to create
        object_name: String,
    },
    /// Delete Field
    DeleteField {
        version: f64,
        /// The account id of the logged in user
        account_id: i64,
        /// The application key for updating an existing application
        app_key: String,
        /// The name of the object to remove the field from
        object_name: String,
        /// field name The name of the field to remove.
        field_name: String,
    },
    /// Delete Object
    DeleteObject {
        version: f64,
        /// the id of the logged in user
        account_id: i64,
        /// the application key
        app_key: String,
        /// the name of the object to delete
        object_name: String,
    },
    /// Get Object
    GetObject {
        version: f64,
        /// The account id of the logged in user
        account_id: i64,
        /// The application key for updating an existing application
        app_key: String,
        /// The name of the object to get the definition for
        object_name: String,
    },
    /// Search Objects
    SearchObject {
        version: f64,
        /// The account id of the logged in user
        account_id: i64,
        /// The application key for updating an existing application
        app_key: String,
        /// The start of the pagination
        start: i64,
        /// The limit of the pagination
        limit: i64,
        /// The name of the object(s) to search for, can be a partial match
        keyword: Option<String>,
    },
    /// Create Data
    CreateData {
        version: f64,
        /// the name of the object to create data for
        object_name: String,
        /// the account id
        account_id: Option<i64>,
        body: Option<String>,
    },
    /// Search Data
    SearchData {
        version: f64,
        /// The name of the object to search upon
        object_name: String,
        /// If true just return the record count of the search. False (default) will return the actual records
        #[clap(short, long)]
        count: bool,
        /// The start of the pagination
        start: i64,
        /// The limit of the pagination
        limit: i64,
        /// The account id of the logged in user
        account_id: Option<i64>,
        /// The search criteria
        criteria: Option<String>,
        /// The order of results; comma seperated list of field names. Illegal field names will be ignored. Direction by defualt is ascending. Prepend a minus to the field name to make that field descending.
        order: Option<String>,
        /// 
        include: Option<String>,
    },
    /// Delete Data
    DeleteData {
        version: f64,
        /// The name of the object to search upon
        object_name: String,
        /// objectId The id of the record to return
        object_id: String,
        /// The account id of the logged in user
        account_id: Option<i64>,
    },
    /// Get Data
    GetData {
        version: f64,
        /// The name of the object to search upon
        object_name: String,
        /// objectId The id of the record to return
        object_id: String,
        /// The account id of the logged in user
        account_id: Option<i64>,
        /// 
        include: Option<String>,
    },
    /// Update Data
    UpdateData {
        version: f64,
        /// The name of the object to search upon
        object_name: String,
        /// objectId The id of the record to return
        object_id: String,
        /// The account id of the logged in user
        account_id: Option<i64>,
        body: Option<String>,
    },
    /// Update Offer Locations
    BatchUpdateOfferLocations {
        version: f64,
        /// JSON string in the following format: ```json [{   \"offerLocationId\": 1705,   \"latitude\": 54.0,   \"longitude\": -122.0,   \"altitude\": 1.0,   \"locationDetail\": \"floor 1\",   \"locationDescription\": \"behind the Coke sign\" }, {   \"offerLocationId\": 1704,   \"latitude\": 54.1,   \"longitude\": -122.1 }] ``` 
        data: String,
        /// The device id (deviceId or accountId required)
        device_id: Option<String>,
        /// The account id of the user (deviceId or accountId required)
        account_id: Option<i64>,
    },
    /// Create Offer
    CreateOffer {
        version: f64,
        /// If true return all the offer locations associated with the offer
        #[clap(short, long)]
        include_offer_locations: bool,
        /// The title (255 char limit)
        title: String,
        /// The bar code type {NONE, UPC, CODE_128, QR, CUSTOM_MEDIA}
        #[clap(value_parser = parse_json::<models::CreateMediaBarcodeTypeParameter>)]
        barcode_type: models::CreateMediaBarcodeTypeParameter,
        /// Overrides the expiration date so that the offer does not expire
        #[clap(short, long)]
        no_expiration: bool,
        /// The limit of how many times the offer can be used by consumers
        available_limit: i32,
        /// The limit of how many times a user can used the same offer
        available_limit_per_user: i32,
        /// The limit of how many times the offer can be added to consumer wallets
        added_limit: i32,
        /// The limit of how many times the offer can be viewed
        view_limit: i32,
        /// The maximum number of times the offer can be printed
        max_prints: i32,
        /// The cost of the offer in tickets
        ticket_price: i64,
        /// The retail/full price cost of the offer in real currency
        full_price: f64,
        /// The cost of the offer at a discounted price (what the consumer pays)
        discount_price: f64,
        /// The offer type {VOUCHER, COUPON, PRODUCT, EVENT, MEDIA, DEVICE}
        #[clap(value_parser = parse_json::<models::CreateOfferOfferTypeParameter>)]
        offer_type: models::CreateOfferOfferTypeParameter,
        /// The special offer type {ALL, REGULAR_OFFER, ACT_NOW, GET_THERE_NOW}
        #[clap(value_parser = parse_json::<models::CreateMediaSpecialOfferTypeParameter>)]
        special_offer_type: models::CreateMediaSpecialOfferTypeParameter,
        /// The offer visibility {PUBLIC, REWARDABLE, TRIGGERABLE}
        #[clap(value_parser = parse_json::<models::CreateMediaOfferVisibilityParameter>)]
        offer_visibility: models::CreateMediaOfferVisibilityParameter,
        /// Sets the active flag
        #[clap(long)]
        active: bool,
        /// The device id (deviceId or accountId required)
        device_id: Option<String>,
        /// The account id (deviceId or accountId required)
        account_id: Option<i64>,
        /// Custom string field for doing full-text searches
        tags: Option<String>,
        /// the parent offer id
        parent_offer_id: Option<i64>,
        /// Comma separated list of retailer location ids. This will assign the offer to these retailer locations.
        retailer_location_ids: Option<String>,
        /// A list of json data that has offer location specific values.
        offer_locations: Option<String>,
        /// The sub title (255 char limit)
        sub_title: Option<String>,
        /// The details
        details: Option<String>,
        /// A string for custom details (255 char limit)
        sub_details: Option<String>,
        /// The fine print
        fine_print: Option<String>,
        /// The bar code entry string
        barcode_entry: Option<String>,
        /// An external identifier. What the identifier will be used for and how it is formatted is up to the frontend developer
        external_redeem_options: Option<String>,
        /// The clickUrl of the offer
        external_url: Option<String>,
        /// an external identifier. What the identifier will be used for and how it is formatted is up to the frontend developer
        external_id: Option<String>,
        /// The type of ticket to reward, null means default type
        tickets_reward_type: Option<String>,
        /// Determines how many tickets are awarded
        tickets_reward: Option<i64>,
        /// The date of when the offer will be visible to consumers
        activated: Option<i64>,
        /// The date of when the offer expires
        expires: Option<i64>,
        /// the type of ticket needed to buy offer
        ticket_price_type: Option<String>,
        /// show remaining offers available
        #[clap(long)]
        show_remaining: Option<bool>,
        /// show how many offers have been redeemed
        #[clap(long)]
        show_redeemed: Option<bool>,
        /// 
        #[clap(short, long)]
        replaced: Option<bool>,
        /// flag if offer is featured or not
        #[clap(long)]
        featured: Option<bool>,
        /// Comma separated list of category ids
        category_ids: Option<String>,
        /// Comma separated list of filter ids
        filter_ids: Option<String>,
        /// The id of the barcode asset
        barcode_asset_id: Option<i64>,
        /// The id of the an offer asset
        image_asset_id: Option<i64>,
        /// The id of the an offer asset
        image_asset_id1: Option<i64>,
        /// The id of the an offer asset
        image_asset_id2: Option<i64>,
        /// The id of the an offer asset
        image_asset_id3: Option<i64>,
        /// The id of the an offer asset
        image_asset_id4: Option<i64>,
        /// The id of the an offer asset
        image_asset_id5: Option<i64>,
        /// The maker of the item.
        publisher: Option<String>,
        /// The redeemable start date/time of the offer.
        redeemable_start: Option<i64>,
        /// The redeemable start date/time of the offer.
        redeemable_end: Option<i64>,
        /// The brand. OfferType PRODUCT only.
        brand: Option<String>,
        /// The product type. OfferType PRODUCT only.
        #[clap(value_parser = parse_json::<models::CreateOfferProductTypeParameter>)]
        product_type: Option<models::CreateOfferProductTypeParameter>,
        /// The condition. OfferType PRODUCT only.
        #[clap(value_parser = parse_json::<models::CreateMediaConditionTypeParameter>)]
        condition_type: Option<models::CreateMediaConditionTypeParameter>,
        /// The ISBN id. OfferType PRODUCT only.
        isbn: Option<String>,
        /// The ASIN id. OfferType PRODUCT only.
        asin: Option<String>,
        /// The list of catelog numbers, comma seperated. OfferType PRODUCT only.
        catalog_numbers: Option<String>,
        /// The department name. The OfferType PRODUCT only.
        department: Option<String>,
        /// The list of features, comma seperated. OfferType PRODUCT only.
        features: Option<String>,
        /// The MAP price. OfferType PRODUCT only.
        minimum_price: Option<f64>,
        /// The width of the item. OfferType PRODUCT only.
        width: Option<f64>,
        /// The height of the item. OfferType PRODUCT only.
        height: Option<f64>,
        /// The depth of the item. OfferType PRODUCT only.
        depth: Option<f64>,
        /// The weight of the item. OfferType PRODUCT only.
        weight: Option<f64>,
        /// The unit of measurement. OfferType PRODUCT only.
        #[clap(value_parser = parse_json::<models::CreateOfferUnitParameter>)]
        unit: Option<models::CreateOfferUnitParameter>,
        /// The studio name. OfferType PRODUCT only.
        studio: Option<String>,
        /// The parental control rating. OfferType PRODUCT only.
        parental_rating: Option<String>,
        /// The date published. OfferType PRODUCT only.
        publish_date: Option<i64>,
        /// The date available. OfferType PRODUCT only.
        availability_date: Option<i64>,
        /// 
        size_id: Option<i64>,
        /// The ID of the event listing
        listing_id: Option<i64>,
        /// the media type of the offer
        #[clap(value_parser = parse_json::<models::CreateMediaMediaTypeParameter>)]
        media_type: Option<models::CreateMediaMediaTypeParameter>,
        /// The total playing time of the media item. OfferType MEDIA only.
        duration: Option<i32>,
        /// The created/author of the media item. OfferType MEDIA only.
        author: Option<String>,
        /// The date/time of when the media item was originally released. OfferType MEDIA only.
        release_date: Option<i64>,
        /// 
        collection_ids: Option<String>,
        /// The reboot hour time ranging from 0 to 23
        reboot_time_hour: Option<i32>,
        /// The reboot minute time ranging from 0 to 59
        reboot_time_minute: Option<i32>,
        /// If the device is idle for idleTimeoutInSecond then the device should timeout
        idle_timeout_in_second: Option<i32>,
        /// The serial number on the device
        serial_number: Option<String>,
        /// The unique device id for the device
        udid: Option<String>,
        /// The type of the device, for example: \"Kiosk\", \"Beacon\".
        device_type: Option<String>,
        /// Edysen device power level setting
        device_power: Option<f64>,
        /// Edysen device inteference setting
        device_interference: Option<f64>,
        /// 
        availability: Option<String>,
        /// 
        availability_summary: Option<String>,
    },
    /// Delete Offer
    DeleteOffer {
        version: f64,
        /// The ID of the offer to be deleted
        offer_id: i64,
        /// The device id (deviceId or accountId required)
        device_id: Option<String>,
        /// The account used to perform the delete, must have rights to edit the offer.
        account_id: Option<i64>,
    },
    /// Delete Offer Location
    DeleteOfferLocation {
        version: f64,
        /// The ID of the offer location to be deleted
        offer_location_id: i64,
        /// The device id (deviceId or accountId required)
        device_id: Option<String>,
        /// The account used to perform the delete, must have rights to edit the offer location.
        account_id: Option<i64>,
    },
    /// Get Offer
    GetOffer {
        version: f64,
        /// The id of the offer
        offer_id: i64,
        /// 
        #[clap(short, long)]
        include_offer_locations: bool,
        /// The device id (deviceId or accountId required)
        device_id: Option<String>,
        /// The account id (deviceId or accountId required)
        account_id: Option<i64>,
    },
    /// Get Offer
    GetOfferDetails {
        version: f64,
        /// The device id for returning account information (i.e. favorites)
        device_id: Option<String>,
        /// The account id for returning account information (i.e. favorites)
        account_id: Option<i64>,
        /// The offer id (either offeLocationId or offerId must be provided)
        offer_id: Option<i64>,
        /// The offer location id (either offeLocationId or offerId must be provided)
        offer_location_id: Option<i64>,
        /// The distance of the offer from the user's current location (this is returned when the offer is searched)
        distance: Option<f64>,
        /// The latitude to calculate distance from the offer
        latitude: Option<f64>,
        /// The longitude to calculate distance from the offer
        longitude: Option<f64>,
        /// Determines whether to return offer locations for the offer
        #[clap(long)]
        include_offer_locations: Option<bool>,
        /// Determines whether to return the retailer location info for each offer location response (includeOfferLocations must also be true for this to work)
        #[clap(long)]
        include_retailer_locations: Option<bool>,
        /// Determines whether to include child offers in the response
        #[clap(long)]
        include_child_offers: Option<bool>,
    },
    /// Get Offers (Counts)
    GetOfferListCounts {
        version: f64,
        /// The latitude of where the search will center at
        latitude: f64,
        /// The longitude of where the search will center at
        longitude: f64,
        /// The range of the search
        search_range: Option<f64>,
        /// The units to use for distance calculations (e.g. MILES, KILOMETERS)
        #[clap(value_parser = parse_json::<models::GetOfferListCountsDistanceUnitParameter>)]
        distance_unit: Option<models::GetOfferListCountsDistanceUnitParameter>,
    },
    /// Get Offer Location
    GetOfferLocation {
        version: f64,
        /// the id of the offer location to get
        offer_location_id: Option<i64>,
        /// the UDID of the device
        udid: Option<String>,
    },
    /// Search Offer Locations
    GetOfferLocationsForRetailers {
        version: f64,
        /// The column to sort the results on. Default is \"TITLE\", which will sort the results by the offer title. Possible input values: {CREATED, UPDATED, ACTIVE, ACTIVATED, EXPIRES, TITLE, SUBTITLE, DETAILS, OFFER_TYPE, RETAILER_ID,RETAILER_LOCATION_ID, BILLABLE_ENTITY_NAME, RESPONSIBLE_DISPLAY}
        #[clap(value_parser = parse_json::<models::SearchOffersForConsumerGroupByParameter>)]
        sort_field: models::SearchOffersForConsumerGroupByParameter,
        /// The order to return the results. Default is false, which will return the results in ascending order.
        #[clap(short, long)]
        descending: bool,
        /// The index into the record set to start with. Default is 0.
        start: i32,
        /// The total number of records to return. Default is 20.
        limit: i32,
        /// Determines whether to return only active results. Default is false.
        #[clap(long)]
        active_only: bool,
        /// 
        #[clap(short, long)]
        include_retailer_location: bool,
        /// The device id (deviceId or accountId required)
        device_id: Option<String>,
        /// The account id of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// The keyword used to search
        keyword: Option<String>,
        /// Filter results for a specific retailer
        retailer_id: Option<i64>,
        /// Filter results for a specific retailer location
        retailer_location_id: Option<i64>,
        /// Filter results to only return COUPON, VOUCHER, PRODUCT, MEDIA, or EVENT offers
        #[clap(value_parser = parse_json::<models::CreateOfferOfferTypeParameter>)]
        offer_type: Option<models::CreateOfferOfferTypeParameter>,
        /// Filter results to only return REGULAR_OFFER, ACT_NOW, GET_THERE_NOW offer specials
        #[clap(value_parser = parse_json::<models::CreateMediaSpecialOfferTypeParameter>)]
        special_offer_type: Option<models::CreateMediaSpecialOfferTypeParameter>,
        /// 
        barcode_type: Option<String>,
        /// 
        barcode_entry: Option<String>,
        /// 
        isbn: Option<String>,
        /// 
        asin: Option<String>,
        /// Edysen device status, running, warning, or down
        #[clap(value_parser = parse_json::<models::GetOfferLocationsForRetailersDeviceStatusParameter>)]
        device_status: Option<models::GetOfferLocationsForRetailersDeviceStatusParameter>,
        /// 
        #[clap(short, long)]
        needs_notification_sent: Option<bool>,
        /// 
        last_notification_sent: Option<i64>,
    },
    /// Search Offers
    GetOffersForRetailers {
        version: f64,
        /// 
        #[clap(value_parser = parse_json::<models::CreateMediaOfferVisibilityParameter>)]
        offer_visibility: models::CreateMediaOfferVisibilityParameter,
        /// The column to sort the search on. Possible values include: ID, CREATED, UPDATED, ACTIVE, ACTIVATED, EXPIRES, TITLE, SUBTITLE, DETAILS, OFFER_TYPE, SPECIAL_OFFER_TYPE, OFFER_VISIBILITY, ESTIMATED_VALUE, VOUCHER_PRICE, RETAILER_ID, RETAILER_NAME, RETAILER_LOCATION_ID, RETAILER_LOCATION_NAME, BILLABLE_ENTITY_ID, BILLABLE_ENTITY_NAME, RESPONSIBLE_DISPLAY
        #[clap(value_parser = parse_json::<models::SearchEventsSortFieldParameter>)]
        sort_field: models::SearchEventsSortFieldParameter,
        /// The order to return the search results
        #[clap(short, long)]
        descending: bool,
        /// The record to begin the return set on
        start: i32,
        /// The number of records to return
        limit: i32,
        /// Return only results that are currently being promoted (is activated and not expired)
        #[clap(long)]
        available_only: bool,
        /// Return only active results
        #[clap(long)]
        active_only: bool,
        /// 
        #[clap(long)]
        include_categories: bool,
        /// 
        #[clap(long)]
        include_filters: bool,
        /// 
        #[clap(long)]
        include_offer_locations: bool,
        /// The device id (deviceId or accountId required)
        device_id: Option<String>,
        /// The account id of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// 
        category_ids: Option<String>,
        /// 
        filter_ids: Option<String>,
        /// This parameter is deprecated.
        q: Option<String>,
        /// The keyword used to search
        keyword: Option<String>,
        /// the id of the retailer
        retailer_id: Option<i64>,
        /// the id of the retailer location
        retailer_location_id: Option<i64>,
        /// This parameter is deprecated.
        #[clap(value_parser = parse_json::<models::CreateOfferOfferTypeParameter>)]
        coupon_type: Option<models::CreateOfferOfferTypeParameter>,
        /// This parameter is deprecated. Use offer types. Filter results to only return COUPON, VOUCHER, PRODUCT, MEDIA, or EVENT offers
        #[clap(value_parser = parse_json::<models::CreateOfferOfferTypeParameter>)]
        offer_type: Option<models::CreateOfferOfferTypeParameter>,
        /// Comma separated list of offer types {COUPON, VOUCHER, PRODUCT, MEDIA, EVENT, DEVICE}
        offer_types: Option<String>,
        /// Filter results to only return REGULAR_OFFER, ACT_NOW, GET_THERE_NOW offer specials
        #[clap(value_parser = parse_json::<models::CreateMediaSpecialOfferTypeParameter>)]
        special_offer_type: Option<models::CreateMediaSpecialOfferTypeParameter>,
        /// This parameter is deprecated.
        _i: Option<i32>,
        /// This parameter is deprecated.
        _l: Option<i32>,
        /// 
        barcode_type: Option<String>,
        /// 
        barcode_entry: Option<String>,
        /// 
        isbn: Option<String>,
        /// 
        asin: Option<String>,
        /// Edysen device status
        #[clap(value_parser = parse_json::<models::GetOfferLocationsForRetailersDeviceStatusParameter>)]
        device_status: Option<models::GetOfferLocationsForRetailersDeviceStatusParameter>,
        /// 
        #[clap(short, long)]
        needs_notification_sent: Option<bool>,
        /// 
        last_notification_sent: Option<i64>,
    },
    /// Update Offer Transaction
    RedeemOfferTransaction {
        version: f64,
        /// the OfferTransaction ID of the transaction being redeemed
        offer_transaction_id: i64,
        /// the status to set the offer transaction to - 1 sets it to redeemable and 2 sets it to redeemed
        status: i32,
        /// the device id (deviceId or accountId required)
        device_id: Option<String>,
        /// the account id of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// the OfferLocation ID where the offer is being redeemed
        offer_location_id: Option<i64>,
    },
    /// Search Offer Transactions
    SearchOfferTransactionsForRetailers {
        version: f64,
        /// Determines what to sort the results by {CREATED, UPDATED, SEARCH_TAGS, ACTIVE, ACTIVATED, EXPIRES, TITLE, SUBTITLE, OFFER_TYPE, SPECIAL_OFFER_TYPE, OFFER_VISIBILITY, CUSTOMER_ID, CUSTOMER_DISPLAY, RETAILER_ID, RETAILER_NAME, RETAILER_LOCATION_ID, RETAILER_LOCATION_NAME, BILLABLE_ENTITY_ID, BILLABLE_ENTITY_NAME, RESPONSIBLE_DISPLAY}
        #[clap(value_parser = parse_json::<models::SearchEventTransactionsSortFieldParameter>)]
        sort_field: models::SearchEventTransactionsSortFieldParameter,
        /// Determines whether the results are in descending order
        #[clap(short, long)]
        descending: bool,
        /// The start index for pagination
        start: i32,
        /// The limit for pagination
        limit: i32,
        /// Determines whether to only return active offer transactions
        #[clap(long)]
        active_only: bool,
        /// The device id (deviceId or accountId required)
        device_id: Option<String>,
        /// The account id of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// This parameter is deprecated.
        q: Option<String>,
        /// The keyword to search for
        keyword: Option<String>,
        /// Filter results for this retailer
        retailer_id: Option<i64>,
        /// Filter results for this retailer location
        retailer_location_id: Option<i64>,
        /// Filter results for this offer
        offer_id: Option<i64>,
        /// Filter results for this offer location
        offer_location_id: Option<i64>,
        /// if true return redeemed transactions (status 2), if false return active transactions (status 0 or 1)
        #[clap(long)]
        redeemed: Option<bool>,
        /// returns only reservation transactions if true
        #[clap(long)]
        reservations_only: Option<bool>,
        /// This parameter is deprecated.
        #[clap(value_parser = parse_json::<models::CreateOfferOfferTypeParameter>)]
        coupon_type: Option<models::CreateOfferOfferTypeParameter>,
        /// Filter results to only return COUPON, VOUCHER, PRODUCT, MEDIA, or EVENT offers
        #[clap(value_parser = parse_json::<models::CreateOfferOfferTypeParameter>)]
        offer_type: Option<models::CreateOfferOfferTypeParameter>,
        /// Filter results to only return REGULAR_OFFER, ACT_NOW, GET_THERE_NOW offer specials
        #[clap(value_parser = parse_json::<models::CreateMediaSpecialOfferTypeParameter>)]
        special_offer_type: Option<models::CreateMediaSpecialOfferTypeParameter>,
        /// Filter results by accounts
        customer_account_ids: Option<String>,
        /// 
        category_ids: Option<String>,
        /// 
        redeemable_start_date: Option<i64>,
        /// 
        redeemable_end_date: Option<i64>,
        /// This parameter is deprecated.
        _i: Option<i32>,
        /// This parameter is deprecated.
        _l: Option<i32>,
    },
    /// Search Offers
    SearchOffersForConsumer {
        version: f64,
        /// The latitude of where the search will center at
        latitude: f64,
        /// The longitude of where the search will center at
        longitude: f64,
        /// The method to use to gather recommendations: WALLET base relevance on items in users wallets CLICKS base relevance on items users have clicked on BLENDED blend using all methods available
        #[clap(value_parser = parse_json::<models::SearchOffersForConsumerRecommendationTypeParameter>)]
        recommendation_type: models::SearchOffersForConsumerRecommendationTypeParameter,
        /// This parameter is deprecated. The location id
        location_id: i64,
        /// The start index for pagination
        start: i32,
        /// The limit for pagination
        limit: i32,
        /// 
        max_recommendations: i32,
        /// 
        #[clap(value_parser = parse_json::<models::SearchOffersForConsumerDistanceUnitParameter>)]
        distance_unit: models::SearchOffersForConsumerDistanceUnitParameter,
        /// The application key used to identify the application
        app_key: Option<String>,
        /// The device id for returning account information (i.e. offer transactions made by the user)
        device_id: Option<String>,
        /// The account id for returning account information (i.e. offer transactions made by the user)
        account_id: Option<i64>,
        /// The range of the search
        search_range: Option<f64>,
        /// Does a full-text search on tags
        tags: Option<String>,
        /// supported postal codes
        supported_postal_codes: Option<String>,
        /// The keyword to filter results by
        keyword: Option<String>,
        /// Comma separate list of category ids
        categories: Option<String>,
        /// Comma separated list of filter ids
        filters: Option<String>,
        /// Comma separated list of offer types {COUPON, VOUCHER, PRODUCT, MEDIA, EVENT, DEVICE}
        offer_types: Option<String>,
        /// The special offer type {ALL, RESERVABLE, REGULAR_OFFER, ACT_NOW, GET_THERE_NOW}
        param_type: Option<String>,
        /// The field to sort the result set on:DISTANCE Sort the offers nearest to farthest BUSINESS_NAME Sort the offers alphabetically by location name SHUFFLE Sort the nearest offers randomly USERPREFS accountId must accompany this parameter. Gives the first X recommendations where X equals the parameter maxRecommendations
        sort_field: Option<String>,
        /// Return recommendations based on these offers IDs
        recommend_offer_ids: Option<String>,
        /// Only return offer locations for the specific retailer locations.
        retailer_location_ids: Option<String>,
        /// Only return offer locations for the specific offer.
        offer_id: Option<i64>,
        /// If true include the mission response as part of the offer. Default is false.
        #[clap(long)]
        include_mission: Option<bool>,
        /// If true include the category list response as part of the offer. Default is false.
        #[clap(long)]
        include_categories: Option<bool>,
        /// If true include the filter list response as part of the offer. Default is false.
        #[clap(long)]
        include_filters: Option<bool>,
        /// If true then ignore the expired dates. Default is false.
        #[clap(long)]
        include_expired: Option<bool>,
        /// If true then ignore the favorite. Default is false.
        #[clap(long)]
        include_favorite: Option<bool>,
        /// This parameter is deprecated. see groupBy. If true then it only returns the offer location for an offer closest to the given lat/lon
        #[clap(short, long)]
        closest_offer_only: Option<bool>,
        /// 
        search_expression: Option<String>,
        /// groups the results by a certain field. For example, if you want to return the closest offer location of an offer, then pass in groupBy=OFFER_ID and sortField=DISTANCE (to sort by distance).
        #[clap(value_parser = parse_json::<models::SearchOffersForConsumerGroupByParameter>)]
        group_by: Option<models::SearchOffersForConsumerGroupByParameter>,
    },
    /// Get Offers (Top)
    TopOfferTransactions {
        version: f64,
        /// The index into the record set to start with. Default is 0.
        start: Option<i32>,
        /// The total number of record to return. Default id 20.
        limit: Option<i32>,
    },
    /// Update Offer
    UpdateOffer {
        version: f64,
        /// The offer to update
        offer_id: i64,
        /// If true return all the offer locations associated with the offer
        #[clap(short, long)]
        include_offer_locations: bool,
        /// The device id (deviceId or accountId required)
        device_id: Option<String>,
        /// The account used to perform the update, must have rights to edit the offer (deviceId or accountId required)
        account_id: Option<i64>,
        /// 
        parent_offer_id: Option<i64>,
        /// Comma separated list of retailer location ids. This will assign the offer to these retailer locations.
        retailer_location_ids: Option<String>,
        /// A list of json data that has offer location specific values.
        offer_locations: Option<String>,
        /// Custom string field for doing full-text searches
        tags: Option<String>,
        /// The title (255 char limit)
        title: Option<String>,
        /// The sub title (255 char limit)
        sub_title: Option<String>,
        /// The details
        details: Option<String>,
        /// A string for custom details (255 char limit)
        sub_details: Option<String>,
        /// The fine print
        fine_print: Option<String>,
        /// The bar code type {NONE, UPC, CODE_128, QR, CUSTOM_MEDIA}
        #[clap(value_parser = parse_json::<models::CreateMediaBarcodeTypeParameter>)]
        barcode_type: Option<models::CreateMediaBarcodeTypeParameter>,
        /// The bar code entry string
        barcode_entry: Option<String>,
        /// An external identifier. What the identifier will be used for and how it is formatted is up to the frontend developer.
        external_redeem_options: Option<String>,
        /// The clickUrl of the offer
        external_url: Option<String>,
        /// 
        external_id: Option<String>,
        /// The type of ticket to reward, null means default type
        tickets_reward_type: Option<String>,
        /// Determines how many tickets are awarded
        tickets_reward: Option<i64>,
        /// The date of when the offer will be visible to consumers
        activated: Option<i64>,
        /// The date of when the offer expires
        expires: Option<i64>,
        /// Overrides the expiration date so that the offer does not expire
        #[clap(short, long)]
        no_expiration: Option<bool>,
        /// The limit of how many times the offer can be used by consumers
        available_limit: Option<i32>,
        /// The limit of how many times a user can used the same offer
        available_limit_per_user: Option<i32>,
        /// The limit of how many times the offer can be added to consumer wallets
        added_limit: Option<i32>,
        /// 
        view_limit: Option<i32>,
        /// The maximum number of times the offer can be printed
        max_prints: Option<i32>,
        /// the type of ticket needed to buy the offer
        ticket_price_type: Option<String>,
        /// The cost of the offer in tickets
        ticket_price: Option<i64>,
        /// The retail/full price cost of the offer in real currency
        full_price: Option<f64>,
        /// The cost of the offer at a discounted price (what the consumer pays)
        discount_price: Option<f64>,
        /// show remaining offers available
        #[clap(long)]
        show_remaining: Option<bool>,
        /// show how many offers have been redeemed
        #[clap(long)]
        show_redeemed: Option<bool>,
        /// 
        #[clap(short, long)]
        replaced: Option<bool>,
        /// whether the offer is featured or not
        #[clap(long)]
        featured: Option<bool>,
        /// The offer type {VOUCHER, COUPON, PRODUCT, MEDIA, EVENT}
        #[clap(value_parser = parse_json::<models::CreateOfferOfferTypeParameter>)]
        offer_type: Option<models::CreateOfferOfferTypeParameter>,
        /// The special offer type {ALL, REGULAR_OFFER, ACT_NOW, GET_THERE_NOW}
        #[clap(value_parser = parse_json::<models::CreateMediaSpecialOfferTypeParameter>)]
        special_offer_type: Option<models::CreateMediaSpecialOfferTypeParameter>,
        /// The offer visibility {PUBLIC, REWARDABLE, TRIGGERABLE}
        #[clap(value_parser = parse_json::<models::CreateMediaOfferVisibilityParameter>)]
        offer_visibility: Option<models::CreateMediaOfferVisibilityParameter>,
        /// Comma separated list of category ids
        category_ids: Option<String>,
        /// Comma separated list of filter ids
        filter_ids: Option<String>,
        /// Sets the active flag
        #[clap(long)]
        active: Option<bool>,
        /// The id of the barcode asset
        barcode_asset_id: Option<i64>,
        /// The id of the an offer asset
        image_asset_id: Option<i64>,
        /// The id of the an offer asset
        image_asset_id1: Option<i64>,
        /// The id of the an offer asset
        image_asset_id2: Option<i64>,
        /// The id of the an offer asset
        image_asset_id3: Option<i64>,
        /// The id of the an offer asset
        image_asset_id4: Option<i64>,
        /// The id of the an offer asset
        image_asset_id5: Option<i64>,
        /// The maker of the item.
        publisher: Option<String>,
        /// The redeemable start date/time of the offer.
        redeemable_start: Option<i64>,
        /// The redeemable start date/time of the offer.
        redeemable_end: Option<i64>,
        /// The brand. OfferType PRODUCT only.
        brand: Option<String>,
        /// The product type. OfferType PRODUCT only.
        #[clap(value_parser = parse_json::<models::CreateOfferProductTypeParameter>)]
        product_type: Option<models::CreateOfferProductTypeParameter>,
        /// The condition. OfferType PRODUCT only.
        #[clap(value_parser = parse_json::<models::CreateMediaConditionTypeParameter>)]
        condition_type: Option<models::CreateMediaConditionTypeParameter>,
        /// The ISBN id. OfferType PRODUCT only.
        isbn: Option<String>,
        /// The ASIN id. OfferType PRODUCT only.
        asin: Option<String>,
        /// The list of catelog numbers, comma seperated. OfferType PRODUCT only.
        catalog_numbers: Option<String>,
        /// The department name. The OfferType PRODUCT only.
        department: Option<String>,
        /// The list of features, comma seperated. OfferType PRODUCT only.
        features: Option<String>,
        /// The MAP price. OfferType PRODUCT only.
        minimum_price: Option<f64>,
        /// The width of the item. OfferType PRODUCT only.
        width: Option<f64>,
        /// The height of the item. OfferType PRODUCT only.
        height: Option<f64>,
        /// The depth of the item. OfferType PRODUCT only.
        depth: Option<f64>,
        /// The weight of the item. OfferType PRODUCT only.
        weight: Option<f64>,
        /// The unit of measurement. OfferType PRODUCT only.
        #[clap(value_parser = parse_json::<models::CreateOfferUnitParameter>)]
        unit: Option<models::CreateOfferUnitParameter>,
        /// The studio name. OfferType PRODUCT only.
        studio: Option<String>,
        /// The parental control rating. OfferType PRODUCT only.
        parental_rating: Option<String>,
        /// The date published. OfferType PRODUCT only.
        publish_date: Option<i64>,
        /// The date available. OfferType PRODUCT only.
        availability_date: Option<i64>,
        /// The size Id. OfferType PRODUCT only.
        size_id: Option<i64>,
        /// The ID of the event listing
        listing_id: Option<i64>,
        /// 
        #[clap(value_parser = parse_json::<models::CreateMediaMediaTypeParameter>)]
        media_type: Option<models::CreateMediaMediaTypeParameter>,
        /// The total playing time of the media item. OfferType MEDIA only.
        duration: Option<i32>,
        /// The created/author of the media item. OfferType MEDIA only.
        author: Option<String>,
        /// The date/time of when the media item was originally released. OfferType MEDIA only.
        release_date: Option<i64>,
        /// 
        collection_ids: Option<String>,
        /// The reboot hour time ranging from 0 to 23
        reboot_time_hour: Option<i32>,
        /// The reboot minute time ranging from 0 to 59
        reboot_time_minute: Option<i32>,
        /// If the device is idle for idleTimeoutInSecond then the device should timeout
        idle_timeout_in_second: Option<i32>,
        /// The serial number on the device
        serial_number: Option<String>,
        /// The unique device id for the device
        udid: Option<String>,
        /// The type of the device, for example: \"Kiosk\", \"Beacon\".
        device_type: Option<String>,
        /// RSSI reading at 1 meter from device (-10 to -140)
        device_power: Option<f64>,
        /// 
        device_interference: Option<f64>,
        /// 
        availability: Option<String>,
        /// 
        availability_summary: Option<String>,
    },
    /// Activate Offer
    UpdateOfferStatus {
        version: f64,
        /// Comma separated list of offer ids
        offer_ids: String,
        /// Determines whether to make the offer active as well
        #[clap(long)]
        active: bool,
        /// The device id (deviceId or accountId required)
        device_id: Option<String>,
        /// The account used to perform the activation, must have rights to edit the offer.
        account_id: Option<i64>,
    },
    /// Create Offer Status
    CreateOfferTransactionStatus {
        version: f64,
        /// The name of the status
        name: String,
        /// The status code, must be unique 
        code: i32,
        /// The device id (deviceId or accountId required)
        device_id: Option<String>,
        /// The account id of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// Used to update the user's current location
        latitude: Option<f64>,
        /// Used to update the user's current location
        longitude: Option<f64>,
        /// The description of the status
        description: Option<String>,
        /// The actor that uses the status
        role: Option<String>,
        /// The active status
        #[clap(long)]
        active: Option<bool>,
        /// The applications to associate the status with, if null then for all.
        application_ids: Option<String>,
    },
    /// Delete Offer Status
    DeleteOfferTransactionStatus {
        version: f64,
        /// The id of the record to delete
        status_id: i64,
        /// The device id (deviceId or accountId required)
        device_id: Option<String>,
        /// The account id of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// Used to update the user's current location
        latitude: Option<f64>,
        /// Used to update the user's current location
        longitude: Option<f64>,
    },
    /// Get Offer Status
    GetOfferTransactionStatus {
        version: f64,
        /// The id of the record to get 
        status_id: i64,
        /// The device id (deviceId or accountId required)
        device_id: Option<String>,
        /// The account id of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// Used to update the user's current location
        latitude: Option<f64>,
        /// Used to update the user's current location
        longitude: Option<f64>,
    },
    /// Search Offer Status
    SearchOfferTransactionStatuses {
        version: f64,
        /// The device id (deviceId or accountId required)
        device_id: Option<String>,
        /// The account id of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// Used to update the user's current location
        latitude: Option<f64>,
        /// Used to update the user's current location
        longitude: Option<f64>,
        /// Search the name and description fields
        keyword: Option<String>,
        /// The actors role, possible values are: CUSTOMER, RETAILER, or ANY
        role: Option<String>,
        /// The application making the request
        app_key: Option<String>,
        /// The field to sort on, possible values are: ID, CREATED, UPDATED, DELETED, SEARCH_TAGS, ACTIVE, NAME, DESCRIPTION, CODE, ROLE
        #[clap(value_parser = parse_json::<models::SearchOfferTransactionStatusesSortFieldParameter>)]
        sort_field: Option<models::SearchOfferTransactionStatusesSortFieldParameter>,
        /// Determines whether the results are in descending order
        #[clap(short, long)]
        descending: Option<bool>,
        /// The start index for pagination
        start: Option<i32>,
        /// The limit for pagination
        limit: Option<i32>,
        /// If true include inactive items
        #[clap(short, long)]
        include_inactive: Option<bool>,
    },
    /// Update Offer Status
    UpdateOfferTransactionStatus {
        version: f64,
        /// The device id (deviceId or accountId required)
        device_id: Option<String>,
        /// The account id of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// Used to update the user's current location
        latitude: Option<f64>,
        /// Used to update the user's current location
        longitude: Option<f64>,
        /// The id of the record to update 
        status_id: Option<i64>,
        /// The name of th status
        name: Option<String>,
        /// The description of the status
        description: Option<String>,
        /// The status code, must be unique 
        code: Option<i32>,
        /// The actor that uses the status
        role: Option<String>,
        /// The active status
        #[clap(long)]
        active: Option<bool>,
        /// The applications to associate the status with, if null then for all.
        application_ids: Option<String>,
    },
    /// Generate images with OpenAI
    ImageGeneration {
        version: f64,
        /// Sirqul Account Id
        account_id: i64,
        /// Post Body Parameters
        post_body: String,
        /// Return raw response
        #[clap(short, long)]
        return_raw_response: Option<bool>,
    },
    /// Request Optimization
    RequestOptimization {
        version: f64,
        #[clap(value_parser = parse_json::<models::Orders>)]
        body: Option<models::Orders>,
    },
    /// Get Optimization Result
    GetOptimizationResult {
        version: f64,
        /// The batchID for getting the import status of.
        batch_id: String,
        /// The start index for pagination
        start: i32,
        /// The limit for pagination
        limit: i32,
    },
    /// Add Movie
    AddMovie {
        version: f64,
        /// Sirqul Account Id
        account_id: i64,
        /// Movie Name
        movie_name: String,
        /// A third-party account id that is meaningful to your systems
        third_party_account_id: Option<String>,
        /// A user defined list (comma-delimited) of tags associated with the movie
        tags: Option<String>,
        /// An uploaded recording to analyze (Currently limited to 10MB)
        #[clap(value_parser = parse_json::<swagger::ByteArray>)]
        file: Option<swagger::ByteArray>,
        /// A recording file to download and analyze (Size limit: 1GB)
        url: Option<String>,
        /// When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open
        callback: Option<String>,
    },
    /// Search Docs
    AiDocs {
        version: f64,
        /// Sirqul Account Id
        account_id: i64,
        /// Doc
        doc: String,
        /// Return Topics
        #[clap(short, long)]
        return_topics: Option<bool>,
        /// Limit
        limit: Option<i32>,
        /// Offset
        offset: Option<i32>,
    },
    /// Find images
    AiFindImages {
        version: f64,
        /// Sirqul Account Id
        account_id: i64,
        /// Text
        text: String,
        /// Parse Flag
        parse_flag: Option<String>,
        /// Fetch Flag
        fetch_flag: Option<String>,
        /// Size
        size: Option<String>,
    },
    /// Search Tags
    AiTags {
        version: f64,
        /// Sirqul Account Id
        account_id: i64,
        /// Tags
        tags: String,
        /// Conditional
        conditional: Option<String>,
        /// Limit
        limit: Option<i32>,
        /// Offset
        offset: Option<i32>,
    },
    /// Search Text
    AiText {
        version: f64,
        /// Sirqul Account Id
        account_id: i64,
        /// Terms
        terms: String,
        /// Conditional
        conditional: Option<String>,
        /// Limit
        limit: Option<i32>,
        /// Offset
        offset: Option<i32>,
    },
    /// Batch Analysis
    Batch {
        version: f64,
        /// Sirqul Account Id
        account_id: i64,
        /// A third-party account id that is meaningful to your systems
        third_party_account_id: Option<String>,
        /// The number of topics to return
        limit: Option<i32>,
        /// The comma-delimited list of A/V batch analysis operations to run on this file. Possible values: Transcript,Topics,Emotions
        operations: Option<String>,
        /// An uploaded recording to analyze (Currently limited to 10MB)
        #[clap(value_parser = parse_json::<swagger::ByteArray>)]
        file: Option<swagger::ByteArray>,
        /// A recording file to download and analyze (Size limit: 1GB)
        url: Option<String>,
        /// When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open
        callback: Option<String>,
    },
    /// Creates an instant episode
    CreateInstantEpisode {
        version: f64,
        /// Sirqul Account Id
        account_id: i64,
        /// Request Data String
        data: String,
    },
    /// Create VoiceCanvas images
    CreateVoiceCanvas {
        version: f64,
        /// Sirqul Account Id
        account_id: i64,
        /// Enum: \"256x256\" \"512x512\" \"1024x1024\"
        dimensions: String,
        /// A third-party account id that is meaningful to your systems
        third_party_account_id: Option<String>,
        /// Provide a transcript or previously extracted topics for image generation
        text: Option<String>,
        /// An uploaded recording to analyze (Currently limited to 10MB)
        #[clap(value_parser = parse_json::<swagger::ByteArray>)]
        file: Option<swagger::ByteArray>,
        /// A recording file to download and analyze (Size limit: 1GB)
        url: Option<String>,
        /// When false, uses the raw value from text instead of identifying topics to fetch/generate from
        #[clap(short, long)]
        parse_flag: Option<bool>,
        /// When true, fetches images instead of generating them
        #[clap(long)]
        fetch_flag: Option<bool>,
        /// When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open
        callback: Option<String>,
    },
    /// Detect emotions
    Emotion {
        version: f64,
        /// Sirqul Account Id
        account_id: i64,
        /// A third-party account id that is meaningful to your systems
        third_party_account_id: Option<String>,
        /// An uploaded recording to analyze (Currently limited to 10MB)
        #[clap(value_parser = parse_json::<swagger::ByteArray>)]
        file: Option<swagger::ByteArray>,
        /// A recording file to download and analyze (Size limit: 1GB)
        url: Option<String>,
        /// When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open
        callback: Option<String>,
    },
    /// Starts a StoryStitch video render
    StartVideoRender {
        version: f64,
        /// Sirqul Account Id
        account_id: i64,
        /// Request Data String
        data: String,
    },
    /// Speach to Text
    Stt {
        version: f64,
        /// Sirqul Account Id
        account_id: i64,
        /// A third-party account id that is meaningful to your systems
        third_party_account_id: Option<String>,
        /// Source Language
        source_language: Option<String>,
        /// Target Language
        target_language: Option<String>,
        /// An uploaded recording to analyze (Currently limited to 10MB)
        #[clap(value_parser = parse_json::<swagger::ByteArray>)]
        file: Option<swagger::ByteArray>,
        /// A recording file to download and analyze (Size limit: 1GB)
        url: Option<String>,
        /// When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open
        callback: Option<String>,
    },
    /// Summarize Topics
    SummarizeTopics {
        version: f64,
        /// Sirqul Account Id
        account_id: i64,
        /// A third-party account id that is meaningful to your systems
        third_party_account_id: Option<String>,
        /// The text to get topics for.
        doc: Option<String>,
        /// An uploaded recording to analyze (Currently limited to 10MB)
        #[clap(value_parser = parse_json::<swagger::ByteArray>)]
        file: Option<swagger::ByteArray>,
        /// A recording file to download and analyze (Size limit: 1GB)
        url: Option<String>,
        /// The number of results to return
        limit: Option<i32>,
        /// The starting offset into the total result set to start from
        offset: Option<i32>,
        /// When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open
        callback: Option<String>,
    },
    /// Detect Technical Issues
    TechTune {
        version: f64,
        /// Sirqul Account Id
        account_id: i64,
        /// Number of expected faces
        num_faces_expected: i32,
        /// A third-party account id that is meaningful to your systems
        third_party_account_id: Option<String>,
        /// An uploaded recording to analyze (Currently limited to 10MB)
        #[clap(value_parser = parse_json::<swagger::ByteArray>)]
        file: Option<swagger::ByteArray>,
        /// A recording file to download and analyze (Size limit: 1GB)
        url: Option<String>,
        /// When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open
        callback: Option<String>,
    },
    /// Text to Speach
    Tts {
        version: f64,
        /// Sirqul Account Id
        account_id: i64,
        /// Text
        text: String,
        /// A third-party account id that is meaningful to your systems
        third_party_account_id: Option<String>,
        /// The language to use for the speaker and incoming text
        language: Option<String>,
        /// A language-specific voice to use, or picks the language default if not provided
        voice: Option<String>,
        /// When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open
        callback: Option<String>,
    },
    /// Get Add Movie Result
    GetAddMovieResult {
        version: f64,
        /// Orson Request Id
        request_id: String,
        /// Sirqul Account Id
        account_id: i64,
    },
    /// Get Batch Analysis Results
    GetBatch {
        version: f64,
        /// Orson Request Id
        request_id: String,
        /// Sirqul Account Id
        account_id: i64,
    },
    /// Get Emotion Results
    GetEmotion {
        version: f64,
        /// Orson Request Id
        request_id: String,
        /// Sirqul Account Id
        account_id: i64,
    },
    /// Check episode status
    GetEpisodeStatus {
        version: f64,
        /// Episode ID
        episode_id: i64,
        /// Sirqul Account Id
        account_id: i64,
    },
    /// Check episode status
    GetRenderStatus {
        version: f64,
        /// Render ID
        render_id: String,
        /// Sirqul Account Id
        account_id: i64,
    },
    /// Get Speach to Text Result
    GetStt {
        version: f64,
        /// Orson Request Id
        request_id: String,
        /// Sirqul Account Id
        account_id: i64,
    },
    /// Get TechTune Results
    GetTechTune {
        version: f64,
        /// Orson Request Id
        request_id: String,
        /// Sirqul Account Id
        account_id: i64,
    },
    /// Get Topics
    GetTopics {
        version: f64,
        /// Orson Request Id
        request_id: String,
        /// Sirqul Account Id
        account_id: i64,
    },
    /// Get Text to Speach Result
    GetTts {
        version: f64,
        /// Orson Request Id
        request_id: String,
        /// Sirqul Account Id
        account_id: i64,
    },
    /// Get VoiceCanvas images
    GetVoiceCanvas {
        version: f64,
        /// Orson Request Id
        request_id: String,
        /// Sirqul Account Id
        account_id: i64,
    },
    /// Create Pack
    CreatePack {
        version: f64,
        /// The logged in user.
        account_id: i64,
        /// The title of the pack
        title: String,
        /// The order of the pack
        pack_order: i64,
        /// The price in tickets to purchase this pack
        price: i32,
        /// The scoring is highest is best
        #[clap(short, long)]
        highest: bool,
        /// Flag to indicate owner should receive tickets for completed packs
        #[clap(long)]
        allocate_tickets: bool,
        /// The number of tickets to reward
        ticket_count: i64,
        /// The description of the pack
        description: Option<String>,
        /// The tags for searching the pack, comma separated
        search_tags: Option<String>,
        /// Activate/deactivate the pack
        #[clap(long)]
        active: Option<bool>,
        /// This parameter is deprecated.
        game_type: Option<String>,
        /// The application key used to identify the application
        app_key: Option<String>,
        /// The type of the pack
        #[clap(value_parser = parse_json::<models::CreatePackPackTypeParameter>)]
        pack_type: Option<models::CreatePackPackTypeParameter>,
        /// The type of game sequence of the pack
        #[clap(value_parser = parse_json::<models::CreatePackSequenceTypeParameter>)]
        sequence_type: Option<models::CreatePackSequenceTypeParameter>,
        /// The background asset id of the pack
        background_id: Option<i64>,
        /// The image asset id of the pack
        image_id: Option<i64>,
        /// The date/time to start the pack, send 0 to unset
        start_date: Option<i64>,
        /// The date/time to end the pack, send 0 to unset
        end_date: Option<i64>,
        /// 
        author_override: Option<String>,
        /// the type of ticket required to purchase this pack
        price_type: Option<String>,
        /// the game level ids to include in the pack, comma separated
        game_level_ids: Option<String>,
        /// 
        #[clap(short, long)]
        in_game: Option<bool>,
        /// The type of ticket to reward, null means default type
        ticket_type: Option<String>,
        /// The number of points to award for completing a pack
        points: Option<i64>,
    },
    /// Delete Pack
    DeletePack {
        version: f64,
        /// the id of the logged in user
        account_id: i64,
        /// the id of the pack to delete
        pack_id: i64,
    },
    /// Get Pack
    GetPack {
        version: f64,
        /// The logged in user.
        account_id: i64,
        /// The id of the pack to return.
        pack_id: i64,
        /// If true include the game level data, otherwise don't. default is false.
        #[clap(short, long)]
        include_game_data: bool,
    },
    /// Search Packs
    SearchPacks {
        version: f64,
        /// The logged in user.
        account_id: i64,
        /// The field to sort by. Possible values include: TITLE, DESCRIPTION, CREATED, UPDATED
        #[clap(value_parser = parse_json::<models::SearchPacksSortFieldParameter>)]
        sort_field: models::SearchPacksSortFieldParameter,
        /// Determines whether the sorted list is in descending or ascending order
        #[clap(short, long)]
        descending: bool,
        /// Keyword search on the pack name
        keyword: Option<String>,
        /// Filters results on pack type
        #[clap(value_parser = parse_json::<models::CreatePackPackTypeParameter>)]
        pack_type: Option<models::CreatePackPackTypeParameter>,
        /// Start the result set at some index.
        start: Option<i32>,
        /// Limit the result to some number.
        limit: Option<i32>,
        /// Determines whether to include game data in the results
        #[clap(long)]
        include_game_data: Option<bool>,
        /// Determines whether to include inactive results
        #[clap(long)]
        include_inactive: Option<bool>,
        /// The application to filter results on
        app_key: Option<String>,
    },
    /// Update Pack
    UpdatePack {
        version: f64,
        /// The logged in user.
        account_id: i64,
        /// The id of the pack to update.
        pack_id: i64,
        /// Flag to indicate owner should receive tickets for completed packs
        #[clap(long)]
        allocate_tickets: bool,
        /// The number of tickets to reward
        ticket_count: i64,
        /// The title of the pack
        title: Option<String>,
        /// The description of the pack
        description: Option<String>,
        /// The tags for searching the pack, comma separated
        search_tags: Option<String>,
        /// Activate/deactivate the pack
        #[clap(long)]
        active: Option<bool>,
        /// This parameter is deprecated.
        game_type: Option<String>,
        /// The application key used to identify the application
        app_key: Option<String>,
        /// The type of the pack
        #[clap(value_parser = parse_json::<models::CreatePackPackTypeParameter>)]
        pack_type: Option<models::CreatePackPackTypeParameter>,
        /// The order of the pack
        pack_order: Option<i64>,
        /// The type of game sequence of the pack
        #[clap(value_parser = parse_json::<models::CreatePackSequenceTypeParameter>)]
        sequence_type: Option<models::CreatePackSequenceTypeParameter>,
        /// The background asset id of the pack
        background_id: Option<i64>,
        /// The image asset id of the pack
        image_id: Option<i64>,
        /// The date/time to start the pack, send 0 to unset
        start_date: Option<i64>,
        /// The date/time to end the pack, send 0 to unset
        end_date: Option<i64>,
        /// 
        author_override: Option<String>,
        /// The price in tickets to purchase this pack
        price: Option<i32>,
        /// the type of ticket required to purchase this pack
        price_type: Option<String>,
        /// the game level ids to include in the pack, comma separated
        game_level_ids: Option<String>,
        /// 
        #[clap(short, long)]
        in_game: Option<bool>,
        /// The scoring is highest is best
        #[clap(short, long)]
        highest: Option<bool>,
        /// The type of ticket to reward, null means default type
        ticket_type: Option<String>,
        /// The number of points to award for completing a pack
        points: Option<i64>,
    },
    /// Process All Participant Feeds
    ProcessAllParticipants {
        version: f64,
        /// The account id of the user
        account_id: i64,
        /// The application key used to identify the application
        app_key: Option<String>,
        /// Whether to use short name as the participant ID
        #[clap(short, long)]
        use_short_name_as_id: Option<bool>,
    },
    /// Process Participants Feed
    ProcessParticipants {
        version: f64,
        /// The account id of the user
        account_id: i64,
        /// The league identifier to process
        league: String,
        /// The application key used to identify the application
        app_key: Option<String>,
        /// Whether to use short name as the participant ID
        #[clap(short, long)]
        use_short_name_as_id: Option<bool>,
        /// Multipart file containing participant feed contents
        #[clap(value_parser = parse_json::<swagger::ByteArray>)]
        file: Option<swagger::ByteArray>,
    },
    /// Calculate Path
    ComputePath {
        version: f64,
        /// the data to with start, end point and exclusion points
        data: String,
        /// the system of measurement for directions: {METRIC, IMPERIAL}
        #[clap(value_parser = parse_json::<models::ComputePathUnitsParameter>)]
        units: models::ComputePathUnitsParameter,
        /// determines whether to reduce the path to go in diagonal lines
        #[clap(short, long)]
        reduce_path: bool,
        /// determines whether to return text directions
        #[clap(short, long)]
        directions: bool,
    },
    /// Create Postal Code
    CreatePostalCode {
        version: f64,
        /// the id of the logged in user
        account_id: i64,
        /// the postal code
        code: String,
        /// the latitude of the postal code
        latitude: f64,
        /// the longitude of the postal code
        longitude: f64,
        /// the state code (e.g WA, WV, WI) that the postal code is located
        state_code: Option<String>,
        /// the city that the postal code is located
        city: Option<String>,
        /// whether the postal code created should be active or inactive
        #[clap(long)]
        active: Option<bool>,
    },
    /// Delete Postal Code
    DeletePostalCode {
        version: f64,
        /// the id of the logged in user
        account_id: i64,
        /// the id of the postal code to delete
        postal_code_id: i64,
    },
    /// Get Postal Code
    GetPostalCode {
        version: f64,
        /// the id of the postal code to get
        postal_code_id: i64,
    },
    /// Search Postal Codes
    GetPostalCodes {
        version: f64,
        /// the field to sort the results on
        sort_field: String,
        /// whether to order results in ascending or descending order
        #[clap(short, long)]
        descending: bool,
        /// the latitude of the postal code to search on
        latitude: Option<f64>,
        /// the longitude of the postal code to search on
        longitude: Option<f64>,
        /// the keyword of the postal code to search on
        keyword: Option<String>,
        /// how far (in miles) to search on for the postal code
        miles: Option<f64>,
        /// the start of the index and/or pagination
        start: Option<i32>,
        /// the limit of the index and/or pagination
        limit: Option<i32>,
    },
    /// Update Postal Code
    UpdatePostalCode {
        version: f64,
        /// the id of the logged in user
        account_id: i64,
        /// the id of the postal code to update
        postal_code_id: i64,
        /// the postal code to update
        code: Option<String>,
        /// the latitude of the postal code
        latitude: Option<f64>,
        /// the longitude of the postal code
        longitude: Option<f64>,
        /// the state code (e.g. WA, WI, WY) where the postal code is located
        state_code: Option<String>,
        /// the city where the postal code is located
        city: Option<String>,
        /// whether the postal code is active or inactive
        #[clap(long)]
        active: Option<bool>,
    },
    /// Create Persona
    CreatePersona {
        version: f64,
        /// the account ID of the user
        account_id: i64,
        /// the title of the persona
        title: String,
        /// the accounts that are able to preview from this persona
        preview_accounts: Option<String>,
        /// the sepcified date that this persona is viewing the app
        date: Option<i64>,
        /// the specified age of this persona
        age: Option<i32>,
        /// the specified gender of this persona
        gender: Option<String>,
        /// the specified experience level of the persona
        game_experience_level: Option<String>,
        /// the specified latitude of the persona
        latitude: Option<f64>,
        /// the specified longitude of the persona
        longitude: Option<f64>,
    },
    /// Delete Persona
    DeletePersona {
        version: f64,
        /// the account id of the user
        account_id: i64,
        /// the id of the persona to delete
        persona_id: i64,
    },
    /// Get Persona
    GetPersonaList {
        version: f64,
        /// the account ID of the user
        account_id: i64,
        /// the persona ID of the persona
        persona_id: i64,
    },
    /// Search Personas
    SearchPersona {
        version: f64,
        /// the account ID of the user
        account_id: i64,
        /// the start index for pagination
        start: i32,
        /// the limit for pagination (There is a hard limit of 100)
        limit: i32,
    },
    /// Update Persona
    UpdatePersona {
        version: f64,
        /// the account ID of the user
        account_id: i64,
        /// the persona ID of the persona to update
        persona_id: i64,
        /// the title of the persona
        title: Option<String>,
        /// the accounts that are able to preview from this persona
        preview_accounts: Option<String>,
        /// the status of the persona, there can only be one active persona per account
        #[clap(long)]
        active: Option<bool>,
        /// the sepcified date that this persona is viewing the app
        date: Option<i64>,
        /// the specified age of this persona
        age: Option<i32>,
        /// the specified gender of this persona
        gender: Option<String>,
        /// the specified experience level of the persona
        game_experience_level: Option<String>,
        /// the specified latitude of the persona
        latitude: Option<f64>,
        /// the specified longitude of the persona
        longitude: Option<f64>,
    },
    /// Create Program
    CreateProgram {
        version: f64,
        #[clap(value_parser = parse_json::<models::Program>)]
        body: Option<models::Program>,
    },
    /// Search Programs
    SearchPrograms {
        version: f64,
        /// The field to sort by
        sort_field: String,
        /// Determines whether the sorted list is in descending or ascending order
        #[clap(short, long)]
        descending: bool,
        /// The start index for pagination
        start: i32,
        /// The limit for pagination
        limit: i32,
        /// Return only active results
        #[clap(long)]
        active_only: bool,
        /// The keyword to filter results by
        keyword: Option<String>,
    },
    /// Delete Program
    DeleteProgram {
        version: f64,
        /// the id of the program
        id: i64,
    },
    /// Get Program
    GetProgram {
        version: f64,
        /// the id of the program
        id: i64,
    },
    /// Update Program
    PostProgram {
        version: f64,
        /// the id of the program
        id: i64,
        #[clap(value_parser = parse_json::<models::Program>)]
        body: Option<models::Program>,
    },
    /// Update Program
    PutProgram {
        version: f64,
        /// the id of the program
        id: i64,
        #[clap(value_parser = parse_json::<models::Program>)]
        body: Option<models::Program>,
    },
    /// Create Purchase
    CreatePurchaseItem {
        version: f64,
        /// The application key that the purchase can be used in
        app_key: String,
        /// The name of the purchase item
        name: String,
        /// The purchase provider <ul> <li>SIRQUL - the Sirqul store to make purchases using tickets</li> <li>IOS - the iTunes store for iPhone, iPod, iPod Touch</li> <li>GOOGLE - the Google Play store</li> <li>AMAZON - the Amazon Android store</li> <li>MAC - the iTunes store for OSX</li> <li>WP8 - the Windows Phone 8 store</li> <li>FREE - used for purchase items that are free (can be used for development/testing purposes)</li> </ul>
        #[clap(value_parser = parse_json::<models::CreatePurchaseItemPurchaseTypeParameter>)]
        purchase_type: models::CreatePurchaseItemPurchaseTypeParameter,
        /// The device id (deviceId or accountId required)
        device_id: Option<String>,
        /// The account id of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// The description of the purchase item
        description: Option<String>,
        /// How much the purchase item is worth in tickets
        tickets: Option<i32>,
        /// How much the purchase item will cost in real money
        price: Option<f32>,
        /// The unique identifier used by purchase providers to identify in-app-purchases
        purchase_code: Option<String>,
        /// A secret key from purchase providers that would be used for validation
        secret_key: Option<String>,
        /// How many times a user acquire the same purchase item
        purchase_limit: Option<i32>,
        /// Determines whether the purchase item will enable certain features <ul> <li>DAY_PREMIUM - subscribes a user for a day of membership</li> <li>WEEK_PREMIUM - subscribes a user for a week of membership</li> <li>MONTH_PREMIUM - subscribes a user for a month of membership</li> <li>ADD_TICKET - allows a user to add more tickets to their account</li> <li>ADD_GIFT - allows a user to send/recieve the purchase item as a gift</li> </ul>
        #[clap(value_parser = parse_json::<models::CreatePurchaseItemServiceActionParameter>)]
        service_action: Option<models::CreatePurchaseItemServiceActionParameter>,
        /// The cover image of the purchase item
        cover_asset_id: Option<i64>,
        /// An application specific asset that can be used to store/provide additional data
        promo_asset_id: Option<i64>,
        /// Determines whether the purchase item can be gifted to other users
        #[clap(short, long)]
        giftable: Option<bool>,
        /// Determines whether users can attach their own media/asset to the purchase item
        #[clap(long)]
        assetable: Option<bool>,
        /// Flag to indicate owner should receive tickets for completed missions
        #[clap(long)]
        allocate_tickets: Option<bool>,
        /// The type of ticket to reward, null means default type
        ticket_type: Option<String>,
        /// The number of points to award for completing a mission
        points: Option<i64>,
        /// The offer location that will get added to the user's wallet after purchase.
        offer_location_id: Option<i64>,
    },
    /// Delete Purchase
    DeletePurchaseItem {
        version: f64,
        /// The purchase item id
        purchase_item_id: i64,
        /// The device id (deviceId or accountId required)
        device_id: Option<String>,
        /// The account id of the user (deviceId or accountId required)
        account_id: Option<i64>,
    },
    /// Get Purchase
    GetPurchaseItem {
        version: f64,
        /// The purchase item id
        purchase_item_id: i64,
        /// The device id (deviceId or accountId required)
        device_id: Option<String>,
        /// The account id of the user (deviceId or accountId required)
        account_id: Option<i64>,
    },
    /// Search Purchases
    SearchPurchaseItems {
        version: f64,
        /// The device id (deviceId or accountId required)
        device_id: Option<String>,
        /// The account id of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// The application key to filter results by application
        app_key: Option<String>,
        /// Determines whether to filter results by the user's billable entity
        #[clap(long)]
        filter_by_billable: Option<bool>,
        /// A comma separated list of purchase providers to filter by. Possible values include: <ul> <li>SIRQUL - purchases from the Sirqul store using tickets</li> <li>IOS - purchases from the iTunes store for iPhone, iPod, iPod Touch</li> <li>GOOGLE - purchases from the Google Play store</li> <li>AMAZON - purchases from the Amazon Android store</li> <li>MAC - purchases from the iTunes store for OSX</li> <li>WP8 - purchases from the Windows Phone 8 store</li> <li>FREE - purchases that are free (can be used for development/testing purposes)</li> </ul>
        purchase_type: Option<String>,
        /// A comma separated list of service actions to filter results by. Possible values include: <ul> <li>DAY_PREMIUM - purchases that subscribes a user for a day of membership</li> <li>WEEK_PREMIUM - purchases that subscribes a user for a week of membership</li> <li>MONTH_PREMIUM - purchases that subscribes a user for a month of membership</li> <li>ADD_TICKET - purchases that allow users to add more tickets</li> <li>ADD_GIFT - purchases that allow users to recieve gifts</li> </ul>
        service_action: Option<String>,
        /// The keyword used to search
        keyword: Option<String>,
        /// The column to sort the search on. Possible values include: ID, CREATED, UPDATED, ACTIVE, ACTIVATED, EXPIRES, TITLE, SUBTITLE, DETAILS, OFFER_TYPE, SPECIAL_OFFER_TYPE, OFFER_VISIBILITY, ESTIMATED_VALUE, VOUCHER_PRICE, RETAILER_ID, RETAILER_NAME, RETAILER_LOCATION_ID, RETAILER_LOCATION_NAME, BILLABLE_ENTITY_ID, BILLABLE_ENTITY_NAME, RESPONSIBLE_DISPLAY
        #[clap(value_parser = parse_json::<models::SearchPurchaseItemsSortFieldParameter>)]
        sort_field: Option<models::SearchPurchaseItemsSortFieldParameter>,
        /// The order to return the search results
        #[clap(short, long)]
        descending: Option<bool>,
        /// The record to begin the return set on
        start: Option<i32>,
        /// The number of records to return
        limit: Option<i32>,
        /// Return only active results
        #[clap(long)]
        active_only: Option<bool>,
    },
    /// Update Purchase
    UpdatePurchaseItem {
        version: f64,
        /// The purchase item id
        purchase_item_id: i64,
        /// The device id (deviceId or accountId required)
        device_id: Option<String>,
        /// The account id of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// The name of the purchase item
        name: Option<String>,
        /// The description of the purchase item
        description: Option<String>,
        /// How much the purchase item is worth in tickets
        tickets: Option<i32>,
        /// How much the purchase item will cost in real money
        price: Option<f32>,
        /// The purchase provider <ul> <li>SIRQUL - the Sirqul store to make purchases using tickets</li> <li>IOS - the iTunes store for iPhone, iPod, iPod Touch</li> <li>GOOGLE - the Google Play store</li> <li>AMAZON - the Amazon Android store</li> <li>MAC - the iTunes store for OSX</li> <li>WP8 - the Windows Phone 8 store</li> <li>FREE - used for purchase items that are free (can be used for development/testing purposes)</li> </ul>
        #[clap(value_parser = parse_json::<models::CreatePurchaseItemPurchaseTypeParameter>)]
        purchase_type: Option<models::CreatePurchaseItemPurchaseTypeParameter>,
        /// The unique identifier used by purchase providers to identify in-app-purchases
        purchase_code: Option<String>,
        /// A secret key from purchase providers that would be used for validation
        secret_key: Option<String>,
        /// How many times a user acquire the same purchase item
        purchase_limit: Option<i32>,
        /// Determines whether the purchase item will enable certain features <ul> <li>DAY_PREMIUM - subscribes a user for a day of membership</li> <li>WEEK_PREMIUM - subscribes a user for a week of membership</li> <li>MONTH_PREMIUM - subscribes a user for a month of membership</li> <li>ADD_TICKET - allows a user to add more tickets to their account</li> <li>ADD_GIFT - allows a user to send/recieve the purchase item as a gift</li> </ul>
        #[clap(value_parser = parse_json::<models::CreatePurchaseItemServiceActionParameter>)]
        service_action: Option<models::CreatePurchaseItemServiceActionParameter>,
        /// The cover image of the purchase item
        cover_asset_id: Option<i64>,
        /// An application specific asset that can be used to store/provide additional data
        promo_asset_id: Option<i64>,
        /// Determines whether the purchase item can be gifted to other users
        #[clap(short, long)]
        giftable: Option<bool>,
        /// Determines whether users can attach their own media/asset to the purchase item
        #[clap(long)]
        assetable: Option<bool>,
        /// Sets whether the purchase item is active or inactive (hidden from consumers)
        #[clap(long)]
        active: Option<bool>,
        /// Flag to indicate owner should receive tickets for completed missions
        #[clap(long)]
        allocate_tickets: Option<bool>,
        /// The type of ticket to reward, null means default type
        ticket_type: Option<String>,
        /// The number of points to award for completing a mission
        points: Option<i64>,
        /// The offer location that will get added to the user's wallet after purchase.
        offer_location_id: Option<i64>,
    },
    /// Create Order
    CreateOrder {
        version: f64,
        /// The application requesting the purchase
        app_key: String,
        /// ```json [   { \"orderItemType\": \"OFFER\", \"orderItemId\": 234, \"orderCustomType\": \"OfferLocation\", \"orderCustomId\": 123, \"retailerLocationId\": 1234, \"quantity\": 2 },   { \"orderItemType\": \"OFFER\", \"orderItemId\": 235, \"quantity\": 2 },   { \"orderItemType\": \"CUSTOM\", \"amount\": 10.50, \"orderCustomType\": \"ServiceFee\" },   { \"orderItemType\": \"CUSTOM\", \"amount\": 25.10, \"quantity\": 2, \"orderCustomType\": \"Hat\", \"orderCustomId\": 123 } ] ``` 
        cart: String,
        /// The device id (deviceId or accountId required)
        device_id: Option<String>,
        /// The account id of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// A description of the purchase
        description: Option<String>,
        /// Determines the method of purchasing offer.  * VOID: used for when there is no payment involved (ie. for updating the status of a purchase order)  * CASH: use card on file  * POINTS: use account balance  * TICKETS: use tickets  * REFUND: not allowed for a create, requires a paymentTransactionId.  * CREDIT: add to the account balance  * RELOAD: charge a credit card then add to the account balance  
        #[clap(value_parser = parse_json::<models::CreateOrderCurrencyTypeParameter>)]
        currency_type: Option<models::CreateOrderCurrencyTypeParameter>,
        /// Use a specific payment method (CASH), if not provided use default
        payment_method_id: Option<i64>,
        /// Store identifier from external system
        external_order_id: Option<String>,
        /// Store identifier from external system
        external_payment_id: Option<String>,
        /// Remote Reference type
        remote_ref_type: Option<String>,
        /// External Date
        external_date: Option<i64>,
        /// The Promo Code
        promo_code: Option<String>,
    },
    /// Delete Order
    DeleteOrder {
        version: f64,
        /// Order Id
        order_id: i64,
        /// The device id (deviceId or accountId required)
        device_id: Option<String>,
        /// The account id of the user (deviceId or accountId required)
        account_id: Option<i64>,
    },
    /// Get Order
    GetOrder {
        version: f64,
        /// The device id (deviceId or accountId required)
        device_id: Option<String>,
        /// The account id of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// The order id to get details of, either orderId or externalOrderId must be provided
        order_id: Option<i64>,
        /// The external order id to get details of, either orderId or externalOrderId must be provided
        external_order_id: Option<String>,
    },
    /// Preview Order
    PreviewOrder {
        version: f64,
        /// The application requesting the purchase
        app_key: String,
        /// A JSON list of items to purchase
        cart: String,
        /// The device id (deviceId or accountId required)
        device_id: Option<String>,
        /// The account id of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// A description of the purchase
        description: Option<String>,
        /// Determines the method of purchasing offer. ```json {   \"VOID\": \"used for when there is no payment involved (ie. for updating the status of a purchase order)\",   \"CASH\": \"use card on file\",   \"POINTS\": \"use account balance\",   \"TICKETS\": \"use tickets\",   \"REFUND\": \"not allowed for a create, requires a paymentTransactionId\",   \"CREDIT\": \"add to the account balance\",   \"RELOAD\": \"charge a credit card then add to the account balance\" } ``` 
        #[clap(value_parser = parse_json::<models::CreateOrderCurrencyTypeParameter>)]
        currency_type: Option<models::CreateOrderCurrencyTypeParameter>,
        /// Use a specific payment method (CASH), if not provided use default
        payment_method_id: Option<i64>,
        /// Store identifier from external system
        external_order_id: Option<String>,
        /// Store identifier from external system
        external_payment_id: Option<String>,
        /// Remote Reference type
        remote_ref_type: Option<String>,
        /// External Date
        external_date: Option<i64>,
        /// The Promo Code
        promo_code: Option<String>,
    },
    /// Search Orders
    SearchOrders {
        version: f64,
        /// The application requesting the purchase
        app_key: String,
        /// The device id (deviceId or accountId required)
        device_id: Option<String>,
        /// The account id of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// The start index for pagination
        start: Option<i32>,
        /// The limit for pagination
        limit: Option<i32>,
        /// Determines whether to return the resulting list in descending or ascending order
        #[clap(short, long)]
        descending: Option<bool>,
        /// Only return active orders
        #[clap(long)]
        active_only: Option<bool>,
        /// Determines whether to ignore the customer filter (requires an Admin/Exec account)
        #[clap(short, long)]
        ignore_customer_filter: Option<bool>,
        /// Filter results by orderItemTypes
        order_item_types: Option<String>,
        /// Filter results by orderItemIds
        order_item_ids: Option<String>,
        /// Filter results by orderCustomTypes
        order_custom_types: Option<String>,
        /// Filter results by orderCustomIds
        order_custom_ids: Option<String>,
        /// Determines what to sort the results by
        sort_field: Option<String>,
        /// Filter results by offer type
        offer_types: Option<String>,
        /// Filter results by special offer type
        special_offer_types: Option<String>,
        /// Filter results by category Ids
        category_ids: Option<String>,
        /// Filter results by filter Ids
        filter_ids: Option<String>,
        /// Filter results by offer audience Ids
        offer_audience_ids: Option<String>,
        /// Filter results by transaction audience Ids
        transaction_audience_ids: Option<String>,
        /// Filter results by offer Ids
        offer_ids: Option<String>,
        /// Filter results by offer location Ids
        offer_location_ids: Option<String>,
        /// Filter results by retailer Ids
        retailer_ids: Option<String>,
        /// Filter results by retailer location Ids
        retailer_location_ids: Option<String>,
        /// Filter results by offer transaction status (0: non-redeemable, 1: redeemable, 2: redeemed, 3: user deleted, 4: unclaimed/rewarded, 5: membership active, 6: membership cancelled)
        statuses: Option<String>,
        /// The keyword to search for
        keyword: Option<String>,
        /// Filter results by the offer redeemable date
        redeemable_start_date: Option<i64>,
        /// Filter results by the offer redeemable date
        redeemable_end_date: Option<i64>,
        /// Filter results by the offer start date
        started_since: Option<i64>,
        /// Filter results by the offer start date
        started_before: Option<i64>,
        /// Filter results by the offer end date
        ended_since: Option<i64>,
        /// Filter results by the offer end date
        ended_before: Option<i64>,
    },
    /// Update Order
    UpdateOrder {
        version: f64,
        /// The order to add the purchase to, leave null for new order.
        order_id: i64,
        /// The application requesting the purchase
        app_key: String,
        /// ```json [   { \"orderItemType\": \"OFFER\", \"orderItemId\": 234, \"orderCustomType\": \"OfferLocation\", \"orderCustomId\": 123, \"retailerLocationId\": 1234, \"quantity\": 2 },   { \"orderItemType\": \"OFFER\", \"orderItemId\": 235, \"quantity\": 2 },   { \"orderItemType\": \"CUSTOM\", \"amount\": 10.50, \"orderCustomType\": \"ServiceFee\" },   { \"orderItemType\": \"CUSTOM\", \"amount\": 25.10, \"quantity\": 2, \"orderCustomType\": \"Hat\", \"orderCustomId\": 123 } ] ``` 
        cart: String,
        /// The device id (deviceId or accountId required)
        device_id: Option<String>,
        /// The account id of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// The payment transaction to apply the refund to
        payment_transaction_id: Option<i64>,
        /// A description of the purchase
        description: Option<String>,
        /// Determines the method of purchasing offer.  * VOID: used for when there is no payment involved (ie. for updating the status of a purchase order)  * CASH: use card on file  * POINTS: use account balance  * TICKETS: use tickets  * REFUND: not allowed for a create, requires a paymentTransactionId.  * CREDIT: add to the account balance  * RELOAD: charge a credit card then add to the account balance  
        #[clap(value_parser = parse_json::<models::CreateOrderCurrencyTypeParameter>)]
        currency_type: Option<models::CreateOrderCurrencyTypeParameter>,
        /// Use a specific payment method (CASH), if not provided use default
        payment_method_id: Option<i64>,
        /// Store identifier from external system
        external_payment_id: Option<String>,
        /// External Date
        external_date: Option<i64>,
    },
    /// Create Question
    CreateQuestion {
        version: f64,
        /// the id of the logged in user
        account_id: i64,
        /// the text of the question
        question: String,
        /// ```json [   {     \"text\": \"1942\",     \"image\": 123,     \"videoURL\": \"http://www.here.com\",     \"correct\": true   },   {     \"text\": \"1943\",     \"image\": 124,     \"videoURL\": \"http://www.there.com\",     \"correct\": false   } ] ``` 
        answers: String,
        /// If true set the question to active. Default to false.
        #[clap(long)]
        active: bool,
        /// If true then scoring will give tickets. Default to false.
        #[clap(long)]
        allocate_tickets: bool,
        /// The number of tickets to reward
        ticket_count: i64,
        /// The tags of the question for search.
        tags: Option<String>,
        /// The video link for the question.
        video_url: Option<String>,
        /// The asset id of the question.
        asset_id: Option<i64>,
        /// The type of ticket to reward, null means default type
        ticket_type: Option<String>,
        /// The number of points to award for completing a mission
        points: Option<i64>,
    },
    /// Delete Question
    DeleteQuestion {
        version: f64,
        /// the id of the question to delete
        question_id: i64,
        /// the id of the account that can execute this request
        account_id: i64,
    },
    /// Get Question
    GetQuestion {
        version: f64,
        /// the id of the question to get
        question_id: i64,
        /// the id of the account that can make this request
        account_id: i64,
    },
    /// Search Questions
    SearchQuestions {
        version: f64,
        /// The logged in user.
        account_id: i64,
        /// The column to sort the search on
        sort_field: String,
        /// The order to return the search results
        #[clap(short, long)]
        descending: bool,
        /// Return only active results if set to true.
        #[clap(long)]
        active_only: bool,
        /// The record to begin the return set on.
        start: i32,
        /// The number of records to return.
        limit: i32,
        /// The keyword for searching questions with matching tags or question text.
        keyword: Option<String>,
    },
    /// Update Question
    UpdateQuestion {
        version: f64,
        /// The id of the question to update.
        question_id: i64,
        /// The logged in user.
        account_id: i64,
        /// The number of tickets to reward
        ticket_count: i64,
        /// The text of the question.
        question: Option<String>,
        /// The json representations of answers for the question.
        answers: Option<String>,
        /// The tags of the question for search.
        tags: Option<String>,
        /// The video link for the question.
        video_url: Option<String>,
        /// The asset id of the question.
        asset_id: Option<i64>,
        /// If true set the question to active.
        #[clap(long)]
        active: Option<bool>,
        /// If true then scoring will give tickets.
        #[clap(long)]
        allocate_tickets: Option<bool>,
        /// The type of ticket to reward, null means default type
        ticket_type: Option<String>,
        /// The number of points to award for completing a mission
        points: Option<i64>,
    },
    /// Search Historical Rankings
    GetHistoricalRankings {
        version: f64,
        /// the application key for filtering results by application
        app_key: String,
        /// the rank type to return
        rank_type: String,
        /// timestamp in milliseconds to filter results with
        start_date: i64,
        /// timestamp in milliseconds to filter results with
        end_date: i64,
        /// a unique id given by the device (deviceId or accountId required)
        device_id: Option<String>,
        /// the account id of the user
        account_id: Option<i64>,
        /// determines how to order and rank the results. Possible values include: TOTAL, MONTHLY, WEEKLY, DAILY, TOP, LOWEST
        sort_field: Option<String>,
        /// determines whether to return results in ascending or descending order
        #[clap(short, long)]
        descending: Option<bool>,
        /// the start index for pagination
        start: Option<i32>,
        /// the limit for pagination
        limit: Option<i32>,
    },
    /// Search Rankings
    GetRankings {
        version: f64,
        /// a unique id given by the device (deviceId or accountId required)
        device_id: Option<String>,
        /// the account id of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// This parameter is deprecated.
        game_type: Option<String>,
        /// the application key for filtering results by application (required for non-EXECUTIVE users)
        app_key: Option<String>,
        /// This parameter is deprecated.
        q: Option<String>,
        /// keyword to search for
        keyword: Option<String>,
        /// a comma separated list of rank types to return. Possible default rank types: POINTS, DOWNLOADS, INVITATIONS
        rank_type: Option<String>,
        /// the type of search to perform. Possible values include: GLOBAL - searches scores globally (all users in the system are included in the ranking) LOCAL - filters results by select users and on users that have logged into the same device CUSTOM - allows for custom filtering using the params: withinAccountIds, albumId, audienceId
        leaderboard_mode: Option<String>,
        /// comma separated list of account ids. If performing a LOCAL or CUSTOM search, the query will include these accounts.
        within_account_ids: Option<String>,
        /// determines whether to return the user's current rank in the response. This can be turned off for sequential paginated requests.
        #[clap(short, long)]
        return_user_rank: Option<bool>,
        /// album id to use when performing CUSTOM filters
        album_id: Option<i64>,
        /// audience id to use when performing CUSTOM filters
        audience_id: Option<i64>,
        /// determines how to order and rank the results. Possible values include: TOTAL - order results by total score MONTHLY - order results by monthly score WEEKLY - order results by weekly score DAILY - order results by daily score TOP - order results by top score LOWEST - order results by lowest score
        sort_field: Option<String>,
        /// determines whether to return results in ascending or descending order
        #[clap(short, long)]
        descending: Option<bool>,
        /// This parameter is deprecated.
        _i: Option<i32>,
        /// the start index for pagination
        start: Option<i32>,
        /// This parameter is deprecated.
        _l: Option<i32>,
        /// the limit for pagination
        limit: Option<i32>,
    },
    /// Get Personal Rankings
    GetUserRank {
        version: f64,
        /// a unique id given by the device (deviceId or accountId required)
        device_id: Option<String>,
        /// the account id of the user
        account_id: Option<i64>,
        /// the application key for filtering results by application (required)
        app_key: Option<String>,
        /// pass in all rankTypes and children rankTypes
        rank_type: Option<String>,
        /// determines whether to return the user's current rank in the response, for each rankType
        #[clap(short, long)]
        return_user_rank: Option<bool>,
        /// the type of search to perform. Possible values include: GLOBAL, LOCAL, SEARCH, CUSTOM
        leaderboard_mode: Option<String>,
        /// determines how to order and rank the results. Possible values include: TOTAL, MONTHLY, WEEKLY, DAILY, TOP, LOWEST
        sort_field: Option<String>,
        /// keyword to search for (on rankType)
        keyword: Option<String>,
        /// determines whether to return results in descending order
        #[clap(short, long)]
        descending: Option<bool>,
        /// the start index for pagination
        start: Option<i32>,
        /// the limit for pagination
        limit: Option<i32>,
    },
    /// Override User Rank
    OverrideUserRank {
        version: f64,
        /// the logged in user's account id (must have permissions to manage data for the application)
        account_id: i64,
        /// the end user's account id to override
        owner_account_id: i64,
        /// the application key the leaderboard is for
        app_key: String,
        /// the rankType of the leaderboard
        rank_type: String,
        /// the total score to update
        total_score: Option<i64>,
        /// the total count to update
        total_count: Option<i64>,
        /// the total time to update
        total_time: Option<i64>,
        /// the daily score to update
        daily_score: Option<i64>,
        /// the daily count to update
        daily_count: Option<i64>,
        /// the daily time to update
        daily_time: Option<i64>,
        /// the weekly score to update
        weekly_score: Option<i64>,
        /// the weekly count to update
        weekly_count: Option<i64>,
        /// the weekly time to update
        weekly_time: Option<i64>,
        /// the monthly score to update
        monthly_score: Option<i64>,
        /// the monthly count to update
        monthly_count: Option<i64>,
        /// the monthly time to update
        monthly_time: Option<i64>,
        /// the top score to update
        top_score: Option<i64>,
        /// the lowest score to update
        lowest_score: Option<i64>,
        /// the streak count to update
        streak_count: Option<i64>,
        /// the best streak count to update
        streak_best_count: Option<i64>,
        /// the start date to update
        start_date: Option<i64>,
        /// the end date to update
        end_date: Option<i64>,
    },
    /// Update Ranking
    UpdateRankings {
        version: f64,
        /// the account id of the user
        account_id: i64,
        /// the application key for filtering results by application
        app_key: String,
        /// a unique label for identifying the ranking. This can be any alphanumeric string (no spaces or special characters) with a maximum length of 64 characters. There are also default rank types to use which include: POINTS, DOWNLOADS, INVITATIONS, CREATIONS, VOTES, REDEEMED, ACTIONS
        rank_type: String,
        /// the value to increment
        increment: Option<i64>,
        /// the time value to increment
        time_increment: Option<i64>,
        /// the analytic tag for this achievement (used to validate scores)
        tag: Option<String>,
        /// custom date you can save along with the score for the user
        start_date: Option<i64>,
        /// custom date you can save along with the score for the user
        end_date: Option<i64>,
        /// update the global rankings if true, default is false
        #[clap(short, long)]
        update_global: Option<bool>,
        /// create the leaderboard if it does not exist (default false)
        #[clap(short, long)]
        create_leaderboard: Option<bool>,
    },
    /// Create Rating
    CreateRating {
        version: f64,
        /// The ratable object type {RETAILER_LOCATION}
        ratable_type: String,
        /// The id of the ratable object
        ratable_id: i64,
        /// The integer value of 0-100
        rating_value: i32,
        /// The unique device identifier that made the request (either deviceId or accountId must be used)
        device_id: Option<String>,
        /// The unique accountId that made the request (either deviceId or accountId must be used)
        account_id: Option<i64>,
        /// 
        category_id: Option<i64>,
        /// A subject title for the user rating (limited to 255 characters)
        display: Option<String>,
        /// The description of the rating
        description: Option<String>,
        /// The description of the location
        location_description: Option<String>,
        /// The current location of the user
        latitude: Option<f64>,
        /// The current location of the user
        longitude: Option<f64>,
    },
    /// Delete Rating
    DeleteRating {
        version: f64,
        /// The ID of the rating to delete
        rating_id: i64,
        /// The unique device identifier that made the request (either deviceId or accountId must be used)
        device_id: Option<String>,
        /// The unique accountId that made the request (either deviceId or accountId must be used)
        account_id: Option<i64>,
    },
    /// Search Location Rating Indexes
    SearchLocationRatingIndexes {
        version: f64,
        /// Comma separated list of category ids to filter the results by
        category_ids: Option<String>,
        /// The keyword used to search
        keyword: Option<String>,
        /// The type of location to filter the results by
        location_type: Option<String>,
        /// The column to sort the search on {ID, CREATED, UPDATED, ACTIVE, RATABLE_TYPE, RATABLE_ID, RATABLE_DISPLAY, CATEGORY_ID, CATEGORY_NAME, CATEGORY_SHORT_NAME, CATEGORY_DISPLAY, COUNT, SUMMATION, AVERAGE, VALUE}
        #[clap(value_parser = parse_json::<models::SearchRatingIndexesSortFieldParameter>)]
        sort_field: Option<models::SearchRatingIndexesSortFieldParameter>,
        /// The order to return the search results
        #[clap(short, long)]
        descending: Option<bool>,
        /// The record to begin the return set on
        start: Option<i32>,
        /// The number of records to return
        limit: Option<i32>,
        /// The search radius in kilometers to filter results
        search_range: Option<f64>,
        /// The current location of the user
        latitude: Option<f64>,
        /// The current location of the user
        longitude: Option<f64>,
        /// Determines whether to return the overall rating record instead
        #[clap(long)]
        return_overall_rating: Option<bool>,
        /// 
        #[clap(value_parser = parse_json::<models::SearchOffersForConsumerDistanceUnitParameter>)]
        distance_unit: Option<models::SearchOffersForConsumerDistanceUnitParameter>,
        /// whether to return the retailer or not
        #[clap(long)]
        return_retailer: Option<bool>,
        /// whether to return the assets or not
        #[clap(long)]
        return_assets: Option<bool>,
        /// whether to return the offers or not
        #[clap(long)]
        return_offers: Option<bool>,
        /// whether to return the categories or not
        #[clap(long)]
        return_categories: Option<bool>,
        /// whether to return the filters or not
        #[clap(long)]
        return_filters: Option<bool>,
    },
    /// Search Rating Indexes
    SearchRatingIndexes {
        version: f64,
        /// Filter results by a ratable type {RETAILER_LOCATION}
        #[clap(value_parser = parse_json::<models::SearchRatingIndexesRatableTypeParameter>)]
        ratable_type: models::SearchRatingIndexesRatableTypeParameter,
        /// Comma separated list of ratable ids to filter the resuts by
        ratable_ids: Option<String>,
        /// Comma separated list of category ids to filter the results by
        category_ids: Option<String>,
        /// 
        secondary_type: Option<String>,
        /// The keyword used to search
        keyword: Option<String>,
        /// The column to sort the search on {ID, CREATED, UPDATED, ACTIVE, RATABLE_TYPE, RATABLE_ID, RATABLE_DISPLAY, CATEGORY_ID, CATEGORY_NAME, CATEGORY_SHORT_NAME, CATEGORY_DISPLAY, COUNT, SUMMATION, AVERAGE, VALUE}
        #[clap(value_parser = parse_json::<models::SearchRatingIndexesSortFieldParameter>)]
        sort_field: Option<models::SearchRatingIndexesSortFieldParameter>,
        /// The order to return the search results
        #[clap(short, long)]
        descending: Option<bool>,
        /// The record to begin the return set on
        start: Option<i32>,
        /// The number of records to return
        limit: Option<i32>,
        /// 
        latitude: Option<f64>,
        /// 
        longitude: Option<f64>,
        /// Determines whether to return the ratable object in the response
        #[clap(long)]
        return_ratable: Option<bool>,
        /// Determines whether to return the overall rating record instead
        #[clap(long)]
        return_overall_rating: Option<bool>,
    },
    /// Search Ratings
    SearchRatings {
        version: f64,
        /// The device id (deviceId or accountId required)
        device_id: Option<String>,
        /// The account id of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// Filter results for a particular account
        filter_account_id: Option<i64>,
        /// The ratable object type {RETAILER_LOCATION}
        ratable_type: Option<String>,
        /// The id of the ratable object
        ratable_id: Option<i64>,
        /// Comma separated list of category ids to filter the results by
        category_ids: Option<String>,
        /// The keyword used to search
        keyword: Option<String>,
        /// The column to sort the search on {ID, CREATED, UPDATED, ACTIVE, OWNER_DISPLAY, RATABLE_TYPE, RATABLE_ID, RATABLE_DISPLAY, CATEGORY_ID, CATEGORY_NAME, CATEGORY_SHORT_NAME, CATEGORY_DISPLAY, VALUE}
        #[clap(value_parser = parse_json::<models::SearchRatingsSortFieldParameter>)]
        sort_field: Option<models::SearchRatingsSortFieldParameter>,
        /// The order to return the search results
        #[clap(short, long)]
        descending: Option<bool>,
        /// The record to begin the return set on
        start: Option<i32>,
        /// The number of records to return
        limit: Option<i32>,
    },
    /// Update Rating
    UpdateRating {
        version: f64,
        /// The id of the rating (Note: this is not the ratable object id)
        rating_id: i64,
        /// The unique device identifier that made the request (either deviceId or accountId must be used)
        device_id: Option<String>,
        /// The unique accountId that made the request (either deviceId or accountId must be used)
        account_id: Option<i64>,
        /// The rating value to update
        rating_value: Option<i32>,
        /// 
        category_id: Option<i64>,
        /// A subject title for the user rating (limited to 255 characters)
        display: Option<String>,
        /// The description of the rating
        description: Option<String>,
        /// The description of the location
        location_description: Option<String>,
        /// The current location of the user
        latitude: Option<f64>,
        /// The current location of the user
        longitude: Option<f64>,
    },
    /// Create Region
    CreateRegion {
        version: f64,
        /// The id of the account sending the request
        account_id: i64,
        /// RegionClass of this region
        region_class: String,
        /// Short name of the region. This is optimized for search
        short_name: String,
        /// Full name of the region
        full_name: Option<String>,
        /// Comma separated region ids that are parents of this region
        parent_ids: Option<String>,
        /// Comma separated region ids that are children of this region
        children_ids: Option<String>,
        /// Comma separated postal code ids the region will include
        postal_code_ids: Option<String>,
        /// Sets of name,lat,long used to create new postal codes assigned to the region
        locations: Option<String>,
        /// the id of the retailer location that the region is being created for
        retailer_location_id: Option<i64>,
        /// The Visibility of the region
        #[clap(value_parser = parse_json::<models::AddAlbumCollectionVisibilityParameter>)]
        visibility: Option<models::AddAlbumCollectionVisibilityParameter>,
        /// the categories that the region is assigned to
        category_ids: Option<String>,
        /// the filters that the region is assigned to
        filter_ids: Option<String>,
        /// 
        start: Option<i64>,
        /// 
        end: Option<i64>,
        /// the polygon generated for the region
        polygon: Option<String>,
        /// the meta data associated with the region
        meta_data: Option<String>,
        /// the latitude of the region
        latitude: Option<f64>,
        /// the longitude of the region
        longitude: Option<f64>,
        /// the version code
        version_code: Option<i32>,
        /// If this is a root region or not. If true means this region has no parent regions
        #[clap(short, long)]
        root: Option<bool>,
        /// Active or inactive status of the region
        #[clap(long)]
        active: Option<bool>,
    },
    /// Delete Region
    DeleteRegion {
        version: f64,
        /// the id of the account logged in
        account_id: i64,
        /// the id of the region
        region_id: i64,
    },
    /// Get Region
    GetRegion {
        version: f64,
        /// the id of the region to get
        region_id: i64,
        /// the id of the logged in user
        account_id: Option<i64>,
    },
    /// Search Regions
    SearchRegions {
        version: f64,
        /// the owner account id of the region to be created
        account_id: Option<i64>,
        /// This parameter is deprecated. deprecated - use \"keyword\"
        query: Option<String>,
        /// the keyword to filter results on
        keyword: Option<String>,
        /// the latitude of the user
        latitude: Option<f64>,
        /// the longitude of the user
        longitude: Option<f64>,
        /// the search radius
        range: Option<f64>,
        /// 
        #[clap(value_parser = parse_json::<models::SearchRegionsRegionClassParameter>)]
        region_class: Option<models::SearchRegionsRegionClassParameter>,
        /// 
        #[clap(value_parser = parse_json::<models::AddAlbumCollectionVisibilityParameter>)]
        visibility: Option<models::AddAlbumCollectionVisibilityParameter>,
        /// the SearchIndexMode: RDS, LUCENE, or CLOUDINDEX. If not provided, will use the default defined in the Sirqul server
        #[clap(value_parser = parse_json::<models::SearchRegionsSearchModeParameter>)]
        search_mode: Option<models::SearchRegionsSearchModeParameter>,
        /// the field to order results by: ID, UPDATED, NAME, or DISTANCE. If not provided, will use the default which is by ID for text and DISTANCE when lat/long is provided.
        #[clap(value_parser = parse_json::<models::SearchRegionsSortFieldParameter>)]
        sort_field: Option<models::SearchRegionsSortFieldParameter>,
        /// determines if the results get ordered in descending order
        #[clap(short, long)]
        descending: Option<bool>,
        /// include the parent region or not
        #[clap(long)]
        include_parent: Option<bool>,
        /// include the chidren regions or not
        #[clap(long)]
        include_children: Option<bool>,
        /// include the postal codes associated with the region or not
        #[clap(long)]
        include_postal_codes: Option<bool>,
        /// search on the categories associated with the region
        category_ids: Option<String>,
        /// search on the filters associated with the region
        filter_ids: Option<String>,
        /// filter by a specific version code
        version_code: Option<i32>,
        /// filter to show only active results
        #[clap(long)]
        active_only: Option<bool>,
        /// If showDeleted is true and activeOnly is false, will return regions that have been deleted
        #[clap(short, long)]
        show_deleted: Option<bool>,
        /// only returns records that have last updated since this date \\(UTC timestamp in milliseconds\\)
        last_updated_since: Option<i64>,
        /// the start index for pagination
        start: Option<i32>,
        /// the limit for pagination
        limit: Option<i32>,
    },
    /// Update Region
    UpdateRegion {
        version: f64,
        /// The id of the account sending the request
        account_id: i64,
        /// The id of the region to be updated
        region_id: i64,
        /// RegionClass of this region
        region_class: Option<String>,
        /// Short name of the region. This is optimized for search
        short_name: Option<String>,
        /// Full name of the region
        full_name: Option<String>,
        /// Comma separated region ids that are parents of this region
        parent_ids: Option<String>,
        /// Comma separated region ids that are children of this region
        children_ids: Option<String>,
        /// Comma separated postal code ids the region will include
        postal_code_ids: Option<String>,
        /// Sets of name,lat,long used to create new postal codes assigned to the region
        locations: Option<String>,
        /// the retailer location ID that the region is associated with
        retailer_location_id: Option<i64>,
        /// The Visibility of the region
        #[clap(value_parser = parse_json::<models::AddAlbumCollectionVisibilityParameter>)]
        visibility: Option<models::AddAlbumCollectionVisibilityParameter>,
        /// the categories that the region is assigned to
        category_ids: Option<String>,
        /// the filters that the region is assigned to
        filter_ids: Option<String>,
        /// 
        start: Option<i64>,
        /// 
        end: Option<i64>,
        /// the polygon of the region
        polygon: Option<String>,
        /// the meta data of the region
        meta_data: Option<String>,
        /// the latitude of the region
        latitude: Option<f64>,
        /// the longitude of the region
        longitude: Option<f64>,
        /// the version code
        version_code: Option<i32>,
        /// If this is a root region or not. If true means this region has no parent regions
        #[clap(short, long)]
        root: Option<bool>,
        /// Active or inactive status of the region
        #[clap(long)]
        active: Option<bool>,
        /// If true clear the children and postal code lists before add new ones, otherwise just append.
        #[clap(short, long)]
        clear_lists: Option<bool>,
    },
    /// Create Offline Report
    CreateBatch {
        version: f64,
        /// The account id of the user for passing account related params
        account_id: i64,
        /// the status of the report
        #[clap(value_parser = parse_json::<models::CreateBatchStatusParameter>)]
        status: models::CreateBatchStatusParameter,
        /// the limit on how much you can preview of the batch report
        preview_limit: i32,
        /// The application key for passing application related params
        app_key: Option<String>,
        /// 
        endpoint: Option<String>,
        /// a json structure list of the parameter values, example: ```json {   \"string\":\"value\",    \"number\":3.345,   \"date\":\"2014-05-01 00:00:00\" } ``` 
        parameters: Option<String>,
        /// name of the batch report
        name: Option<String>,
        /// the start date of the batch report
        start_date: Option<i64>,
        /// the end date of the batch report
        end_date: Option<i64>,
        /// the description of the batch report
        description: Option<String>,
        /// 
        page_url: Option<String>,
    },
    /// Create Offline Report
    CreateRegionLegSummaryBatch {
        version: f64,
        #[clap(value_parser = parse_json::<Vec<models::RegionLegSummary>>, long)]
        body: Option<Vec<models::RegionLegSummary>>,
    },
    /// Delete Offline Report
    DeleteBatch {
        version: f64,
        /// the id of the account
        account_id: i64,
        /// the id of the batch to delete
        batch_id: i64,
    },
    /// Get Offline Report
    GetReportBatch {
        version: f64,
        /// the id of the logged in user
        account_id: i64,
        /// returned by /report/batch/create
        batch_id: i64,
        /// whether to return all batch results or not
        #[clap(long)]
        all_results: bool,
    },
    /// Run Report
    RunReport {
        version: f64,
        /// If true then descending order, false is ascending
        #[clap(short, long)]
        desc: bool,
        /// The account id of the user for passing account related params
        account_id: Option<i64>,
        /// The named identifier of the query
        query: Option<String>,
        /// Parameter values used in the query in JSON format, example: ```json {   \"string\":\"value\",    \"number\":3.345,   \"date\":\"2014-05-01 00:00:00\" } ``` 
        parameters: Option<String>,
        /// The order to use, must be a column name (see response results for list of column names)
        order: Option<String>,
        /// The start of the pagination
        start: Option<i64>,
        /// The limit of the pagination
        limit: Option<i64>,
        /// Determines what response format to return. Options are: JSON or CSV
        #[clap(value_parser = parse_json::<models::AggregatedFilteredUsageResponseFormatParameter>)]
        response_format: Option<models::AggregatedFilteredUsageResponseFormatParameter>,
    },
    /// Search Offline Reports
    SearchBatch {
        version: f64,
        /// the id of the account logged in
        account_id: i64,
        /// the start of the index and/or pagination
        start: i32,
        /// the limit of the index and/or pagination
        limit: i32,
        /// the names of the report batch to search on
        names: Option<String>,
        /// the application key
        app_key: Option<String>,
        /// the report batch status
        #[clap(value_parser = parse_json::<models::CreateBatchStatusParameter>)]
        status: Option<models::CreateBatchStatusParameter>,
        /// the global app to search on
        #[clap(short, long)]
        global_app_search: Option<bool>,
        /// the start date of the report batch to search on
        start_date: Option<i64>,
        /// the end date of the report batch to search on
        end_date: Option<i64>,
    },
    /// Create Reservation
    CreateReservation {
        version: f64,
        /// The device id (deviceId or accountId required)
        device_id: Option<String>,
        /// The account id of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// The start date
        start_date: Option<i64>,
        /// The end date
        end_date: Option<i64>,
        /// The id of the offer being added (offerId or offeLocationId required)
        offer_id: Option<i64>,
        /// The id of the offer location being added (offerId or offeLocationId required)
        offer_location_id: Option<i64>,
        /// The application requesting the reservation
        app_key: Option<String>,
        /// External custom client defined data
        meta_data: Option<String>,
    },
    /// Delete Reservation
    DeleteReservation {
        version: f64,
        /// The reservation id
        reservation_id: i64,
        /// The device id (deviceId or accountId required)
        device_id: Option<String>,
        /// The account id of the user (deviceId or accountId required)
        account_id: Option<i64>,
    },
    /// Update Availability
    ReservableAvailability {
        version: f64,
        /// the id of the reservation
        reservable_id: i64,
        /// the type of reservation
        #[clap(value_parser = parse_json::<models::SearchRatingIndexesRatableTypeParameter>)]
        reservable_type: models::SearchRatingIndexesRatableTypeParameter,
        /// the device id of the reservation
        device_id: Option<String>,
        /// the id of the logged in user
        account_id: Option<i64>,
        /// Availability
        availability: Option<String>,
        /// Availability Summary
        availability_summary: Option<String>,
    },
    /// Search Availability
    SearchAvailability {
        version: f64,
        /// the id of the reservation
        reservable_id: i64,
        /// the reservable type
        #[clap(value_parser = parse_json::<models::SearchRatingIndexesRatableTypeParameter>)]
        reservable_type: models::SearchRatingIndexesRatableTypeParameter,
        /// the device ID that the reservation is on
        device_id: Option<String>,
        /// the id of the logged in user
        account_id: Option<i64>,
        /// the start date of the reservation
        start_date: Option<i64>,
        /// the end date of the reservation
        end_date: Option<i64>,
        /// the start of the index and/or pagination
        start: Option<i32>,
        /// the limit of the index and/or pagination
        limit: Option<i32>,
    },
    /// Search Reservations
    SearchReservations {
        version: f64,
        /// Device Id
        device_id: Option<String>,
        /// Appilcation Key
        app_key: Option<String>,
        /// the id of the logged in user
        account_id: Option<i64>,
        /// filter reservations by account ID
        filter_account_id: Option<i64>,
        /// the reservation ID
        reservable_id: Option<i64>,
        /// the type of reservation
        #[clap(value_parser = parse_json::<models::SearchRatingIndexesRatableTypeParameter>)]
        reservable_type: Option<models::SearchRatingIndexesRatableTypeParameter>,
        /// the keyword to search the reservation on
        keyword: Option<String>,
        /// the start date of the reservation search
        start_date: Option<i64>,
        /// the end date of the reservation search
        end_date: Option<i64>,
        /// the start of the index and/or pagination
        start: Option<i32>,
        /// the limit of the index and/or pagination
        limit: Option<i32>,
    },
    /// Search Schedule
    SearchSchedule {
        version: f64,
        /// the id of the reservation
        reservable_id: i64,
        /// the reservation type
        #[clap(value_parser = parse_json::<models::SearchRatingIndexesRatableTypeParameter>)]
        reservable_type: models::SearchRatingIndexesRatableTypeParameter,
        /// the start date of the reservation
        start_date: i64,
        /// the end date of the reservation
        end_date: i64,
        /// the id of the device that the reservation is on
        device_id: Option<String>,
        /// the id of the logged in user
        account_id: Option<i64>,
        /// the length of time in minutes to search on for reservation
        time_bucket_mins: Option<i32>,
    },
    /// Create Retailer
    CreateRetailer {
        version: f64,
        /// The name of the retailer
        name: String,
        /// The device id (deviceId or accountId required)
        device_id: Option<String>,
        /// The account id of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// The street address of the retailer
        street_address: Option<String>,
        /// Additional address information (such as a suite number, floor number, building name, or PO Box)
        street_address2: Option<String>,
        /// The city of the retailer
        city: Option<String>,
        /// The state of the retailer
        state: Option<String>,
        /// The postal code of the retailer
        postal_code: Option<String>,
        /// the country of the retailer
        country: Option<String>,
        /// The business phone number of the retailer
        business_phone: Option<String>,
        /// The business phone extension of the retailer
        business_phone_ext: Option<String>,
        /// The website of the retailer
        website: Option<String>,
        /// The email of the retailer
        email: Option<String>,
        /// The facebook URL of the retailer
        facebook_url: Option<String>,
        /// The twitter URL of the retailer
        twitter_url: Option<String>,
        /// The retailer logo sent as a multipart binary file (you can optionally use logoAssetId if the asset has already been uploaded before)
        #[clap(value_parser = parse_json::<swagger::ByteArray>)]
        logo: Option<swagger::ByteArray>,
        /// The retailer logo asset id
        logo_asset_id: Option<i64>,
        /// Optional store-front pictures or product pictures or etc. A multipart binary file (you can optionally use picture1AssetId if the asset has already been uploaded before)
        #[clap(value_parser = parse_json::<swagger::ByteArray>)]
        picture1: Option<swagger::ByteArray>,
        /// An asset id
        picture1_asset_id: Option<i64>,
        /// Optional store-front pictures or product pictures or etc. A multipart binary file (you can optionally use picture2AssetId if the asset has already been uploaded before)
        #[clap(value_parser = parse_json::<swagger::ByteArray>)]
        picture2: Option<swagger::ByteArray>,
        /// An asset id
        picture2_asset_id: Option<i64>,
        /// Comma separated list of category IDs used to filter retailers by categories
        category_ids: Option<String>,
        /// Comma separated list of category IDs to add to the retailer
        category_ids_to_add: Option<String>,
        /// Comma separated list of category IDs to remove from the retailer
        category_ids_to_remove: Option<String>,
        /// Comma separated list of filter IDs used to filter retailers
        filter_ids: Option<String>,
        /// the latitude of the retailer
        latitude: Option<f64>,
        /// the longitude of the retailer
        longitude: Option<f64>,
        /// External custom client defined data
        meta_data: Option<String>,
        /// External custom search keywords
        search_tags: Option<String>,
        /// External custom type identifier
        retailer_type: Option<String>,
        /// 
        #[clap(value_parser = parse_json::<models::AddAlbumCollectionVisibilityParameter>)]
        visibility: Option<models::AddAlbumCollectionVisibilityParameter>,
        /// Determines whether to create a default location using the retailer information
        #[clap(short, long)]
        create_default_location: Option<bool>,
        /// The format of the returned response {JSON // default , HTML // for Dojo support when uploading assets}
        #[clap(value_parser = parse_json::<models::AggregatedFilteredUsageResponseFormatParameter>)]
        response_format: Option<models::AggregatedFilteredUsageResponseFormatParameter>,
    },
    /// Delete Retailer
    DeleteRetailer {
        version: f64,
        /// The device id (deviceId or accountId required)
        device_id: Option<String>,
        /// The account used to perform the delete, must have rights to edit the retailer.
        account_id: Option<i64>,
        /// The ID of the retailer to be deleted
        retailer_id: Option<i64>,
    },
    /// Get Retailer
    GetRetailer {
        version: f64,
        /// the ID of the retailer
        retailer_id: i64,
        /// the device id (deviceId or accountId required)
        device_id: Option<String>,
        /// the account id of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// Determines whether to include counts in the response (default true)
        #[clap(short, long)]
        include_counts: Option<bool>,
    },
    /// Search Retailers
    GetRetailers {
        version: f64,
        /// 
        #[clap(value_parser = parse_json::<models::AddAlbumCollectionVisibilityParameter>)]
        visibility: models::AddAlbumCollectionVisibilityParameter,
        /// The column to sort the search on
        #[clap(value_parser = parse_json::<models::GetRetailersSortFieldParameter>)]
        sort_field: models::GetRetailersSortFieldParameter,
        /// The order to return the search results
        #[clap(short, long)]
        descending: bool,
        /// The record to begin the return set on
        start: i32,
        /// The number of records to return
        limit: i32,
        /// Return only active results
        #[clap(long)]
        active_only: bool,
        /// The device id (deviceId or accountId required)
        device_id: Option<String>,
        /// The account id of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// This parameter is deprecated.
        q: Option<String>,
        /// The keyword used to search
        keyword: Option<String>,
        /// the categories that the retailer is associated with
        category_ids: Option<String>,
        /// the filters that the retailer is associated with
        filter_ids: Option<String>,
        /// This parameter is deprecated.
        _i: Option<i32>,
        /// This parameter is deprecated.
        _l: Option<i32>,
    },
    /// Login Retailer
    RetailerLoginCheck {
        version: f64,
        /// the user's email address they used to sign-up
        username: String,
        /// the password
        password: String,
        /// the device id (optional)
        device_id: Option<String>,
        /// the current latitude of the user
        latitude: Option<f64>,
        /// the current longitude of the user
        longitude: Option<f64>,
        /// the application key
        app_key: Option<String>,
    },
    /// Update Retailer
    UpdateRetailer {
        version: f64,
        /// The ID of the retailer to update
        retailer_id: i64,
        /// The device id (deviceId or accountId required)
        device_id: Option<String>,
        /// The account id of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// The name of the retailer
        name: Option<String>,
        /// The street address of the retailer
        street_address: Option<String>,
        /// Additional address information (such as a suite number, floor number, building name, or PO Box)
        street_address2: Option<String>,
        /// The city of the retailer
        city: Option<String>,
        /// The state of the retailer
        state: Option<String>,
        /// The postal code of the retailer
        postal_code: Option<String>,
        /// the country of the retailer
        country: Option<String>,
        /// The business phone of the retailer
        business_phone: Option<String>,
        /// The business phone extension of the retailer
        business_phone_ext: Option<String>,
        /// The website of the retailer
        website: Option<String>,
        /// The email of the retailer
        email: Option<String>,
        /// The facebook URL of the retailer
        facebook_url: Option<String>,
        /// The twitter URL of the retailer
        twitter_url: Option<String>,
        /// The retailer logo sent as a multipart binary file (you can optionally use logoAssetId if the asset has already been uploaded before)
        #[clap(value_parser = parse_json::<swagger::ByteArray>)]
        logo: Option<swagger::ByteArray>,
        /// The retailer logo asset id
        logo_asset_id: Option<i64>,
        /// Optional store-front pictures or product pictures or etc. A multipart binary file (you can optionally use picture1AssetId if the asset has already been uploaded before)
        #[clap(value_parser = parse_json::<swagger::ByteArray>)]
        picture1: Option<swagger::ByteArray>,
        /// An asset id
        picture1_asset_id: Option<i64>,
        /// Optional store-front pictures or product pictures or etc. A multipart binary file (you can optionally use picture2AssetId if the asset has already been uploaded before)
        #[clap(value_parser = parse_json::<swagger::ByteArray>)]
        picture2: Option<swagger::ByteArray>,
        /// An asset id
        picture2_asset_id: Option<i64>,
        /// Comma separated list of category IDs used to filter retailers by categories
        category_ids: Option<String>,
        /// Comma separated list of filter IDs used to filter retailers
        filter_ids: Option<String>,
        /// the latitude of the retailer
        latitude: Option<f64>,
        /// the longitude of the retailer
        longitude: Option<f64>,
        /// External custom client defined data
        meta_data: Option<String>,
        /// External custom search keywords
        search_tags: Option<String>,
        /// External custom type identifier
        retailer_type: Option<String>,
        /// 
        #[clap(value_parser = parse_json::<models::AddAlbumCollectionVisibilityParameter>)]
        visibility: Option<models::AddAlbumCollectionVisibilityParameter>,
        /// Sets whether the retailer is active or inactive (hidden from consumers)
        #[clap(long)]
        active: Option<bool>,
        /// The format of the returned response {JSON // default , HTML // for Dojo support when uploading assets}
        #[clap(value_parser = parse_json::<models::AggregatedFilteredUsageResponseFormatParameter>)]
        response_format: Option<models::AggregatedFilteredUsageResponseFormatParameter>,
    },
    /// Create Retailer Location (Consumer)
    CreateRetailerLocationConsumer {
        version: f64,
        /// the application key
        app_key: String,
        /// The name of the retailer location
        name: String,
        /// The device id (deviceId or accountId required)
        device_id: Option<String>,
        /// The account id of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// The street address of the retailer location
        street_address: Option<String>,
        /// Additional address information (such as a suite number, floor number, building name, or PO Box)
        street_address2: Option<String>,
        /// The city of the retailer location
        city: Option<String>,
        /// The state of the retailer location
        state: Option<String>,
        /// The postal code of the retailer location
        postal_code: Option<String>,
        /// the country of the retailer location
        country: Option<String>,
        /// The business phone
        business_phone: Option<String>,
        /// The business phone extension
        business_phone_ext: Option<String>,
        /// The website of the retailer location
        website: Option<String>,
        /// The email of the retailer location
        email: Option<String>,
        /// A brief description about the retailer location (255 character limit)
        details_header: Option<String>,
        /// A detailed description about the retailer location
        details_body: Option<String>,
        /// The hours of operation
        hours: Option<String>,
        /// Custom string field for doing full-text searches
        tags: Option<String>,
        /// The retailer location logo asset id
        logo_asset_id: Option<i64>,
        /// An asset id
        picture1_asset_id: Option<i64>,
        /// An asset id
        picture2_asset_id: Option<i64>,
        /// Comma separated list of category IDs used to filter retailer locations by categories
        category_ids: Option<String>,
        /// Comma separated list of filter IDs used to filter retailer locations
        filter_ids: Option<String>,
        /// External custom client defined data
        meta_data: Option<String>,
        /// Whether the location is public
        #[clap(short, long)]
        public_location: Option<bool>,
        /// whether the retailer location created should be active or not
        #[clap(long)]
        active: Option<bool>,
        /// External custom type identifier
        location_type: Option<String>,
        /// The latitude to center the search on
        latitude: Option<f64>,
        /// The longitude to center the search on
        longitude: Option<f64>,
    },
    /// Create Retailer Location
    CreateRetailerLocations {
        version: f64,
        /// The ID of the retailer
        retailer_id: i64,
        /// The name of the retailer location
        name: String,
        /// The street address of the retailer location
        street_address: String,
        /// The city of the retailer location
        city: String,
        /// The state of the retailer location
        state: String,
        /// The postal code of the retailer location
        postal_code: String,
        /// The device id (deviceId or accountId required)
        device_id: Option<String>,
        /// The account id of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// Additional address information (such as a suite number, floor number, building name, or PO Box)
        street_address2: Option<String>,
        /// the country of the retailer location
        country: Option<String>,
        /// The business phone number of the retailer location
        business_phone: Option<String>,
        /// The business phone extension
        business_phone_ext: Option<String>,
        /// The website of the retailer location
        website: Option<String>,
        /// The email of the retailer location
        email: Option<String>,
        /// An internal identifier used by the retailer
        internal_id: Option<String>,
        /// A brief description about the retailer location (255 character limit)
        details_header: Option<String>,
        /// A detailed description about the retailer location
        details_body: Option<String>,
        /// The hours of operation
        hours: Option<String>,
        /// The retailer location logo sent as a multipart binary file (you can optionally use logoAssetId if the asset has already been uploaded before)
        #[clap(value_parser = parse_json::<swagger::ByteArray>)]
        logo: Option<swagger::ByteArray>,
        /// The retailer location logo asset id
        logo_asset_id: Option<i64>,
        /// Optional store-front pictures or product pictures or etc. A multipart binary file (you can optionally use picture1AssetId if the asset has already been uploaded before)
        #[clap(value_parser = parse_json::<swagger::ByteArray>)]
        picture1: Option<swagger::ByteArray>,
        /// An asset id
        picture1_asset_id: Option<i64>,
        /// Optional store-front pictures or product pictures or etc. A multipart binary file (you can optionally use picture2AssetId if the asset has already been uploaded before)
        #[clap(value_parser = parse_json::<swagger::ByteArray>)]
        picture2: Option<swagger::ByteArray>,
        /// An asset id
        picture2_asset_id: Option<i64>,
        /// Comma separated list of category IDs used to filter retailer locations by categories
        category_ids: Option<String>,
        /// Comma separated list of filter IDs used to filter retailer locations
        filter_ids: Option<String>,
        /// the latitude of the retailer location
        latitude: Option<f64>,
        /// the longitude of the retailer location
        longitude: Option<f64>,
        /// 
        building: Option<String>,
        /// the ID of the Google Place that this retailer location is assigned to
        google_place_id: Option<String>,
        /// the Yelp ID that this retailer location is assigned to
        yelp_id: Option<String>,
        /// whether the retailer location should be active or inactive
        #[clap(long)]
        active: Option<bool>,
        /// Sets whether the location is public or not
        #[clap(short, long)]
        public_location: Option<bool>,
        /// External custom type identifier
        location_type: Option<String>,
        /// Comma separated list of audience IDs used to assign audiences to the retailer location
        audience_ids: Option<String>,
        /// Comma separated list of audience IDs to add to the retailer location
        audience_ids_to_add: Option<String>,
        /// Comma separated list of audience IDs to remove from the retailer location
        audience_ids_to_remove: Option<String>,
        /// The format of the returned response {JSON // default , HTML // for Dojo support when uploading assets}
        #[clap(value_parser = parse_json::<models::AggregatedFilteredUsageResponseFormatParameter>)]
        response_format: Option<models::AggregatedFilteredUsageResponseFormatParameter>,
        /// Comma separated list of response includes (e.g. RETAILER,ASSETS,OFFERS,CATEGORIES,FILTERS,AUDIENCES,QRCODE)
        response_includes: Option<String>,
    },
    /// Delete Retailer Location
    DeleteRetailerLocation {
        version: f64,
        /// the device id
        device_id: Option<String>,
        /// the id of the logged in user
        account_id: Option<i64>,
        /// the id of the retailer location to delete
        retailer_location_id: Option<i64>,
    },
    /// Get Retailer Location
    GetRetailerLocation {
        version: f64,
        /// The ID of the retailer location
        retailer_location_id: i64,
        /// The device id (deviceId or accountId required)
        device_id: Option<String>,
        /// The account id of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// the unique token of the retailer location
        retailer_location_token: Option<String>,
    },
    /// Get Retailer Location (Consumer)
    GetRetailerLocationConsumer {
        version: f64,
        /// The retailer location id
        retailer_location_id: i64,
        /// The device id for returning account information (i.e. favorites)
        device_id: Option<String>,
        /// The account id for returning account information (i.e. favorites)
        account_id: Option<i64>,
    },
    /// Distance Search Retailer Locations (Indexed)
    IndexedRetailerLocationDistanceSearch {
        version: f64,
        /// The latitude to center the search on
        latitude: f64,
        /// The longitude to center the search on
        longitude: f64,
        /// The search range in the distanceUnit specified; default is MILES.
        search_range: f64,
        /// The start index for pagination
        start: i32,
        /// The limit for pagination
        limit: i32,
        /// The account id of the user
        account_id: Option<i64>,
        /// Used to return results using this address as the center
        address: Option<String>,
        /// boolean to indicate whether to include retailer locations that have no offers
        #[clap(short, long)]
        has_offers: Option<bool>,
        /// Comma separate list of category ids
        categories: Option<String>,
        /// Comma separated list of filter ids
        filters: Option<String>,
        /// Comma separated list of audience ids
        audiences: Option<String>,
        /// Comma separated list of retailer ids
        retailer_ids: Option<String>,
        /// Comma separated list of retailer location ids
        retailer_location_ids: Option<String>,
        /// Does a full-text search on tags
        tags: Option<String>,
        /// Location type filter
        location_type: Option<String>,
        /// The field to sort the result set on. Possible values include: DISTANCE, RETAILER_NAME, RETAILER_LOCATION_NAME
        sort_field: Option<String>,
        /// Determines whether the sorted list is in descending or ascending order
        #[clap(short, long)]
        descending: Option<bool>,
        /// This parameter is deprecated.
        q: Option<String>,
        /// Search by keyword
        keyword: Option<String>,
        /// Determines the operator used when there are multiple words in the 'keyword' parameter
        keyword_operator: Option<String>,
        /// Search expression to further refine results
        search_expression: Option<String>,
        /// Unit of distance
        #[clap(value_parser = parse_json::<models::SearchOffersForConsumerDistanceUnitParameter>)]
        distance_unit: Option<models::SearchOffersForConsumerDistanceUnitParameter>,
        /// (deprecated) return favorited flag
        #[clap(long)]
        return_favorited: Option<bool>,
        /// Return retailer info
        #[clap(long)]
        return_retailer: Option<bool>,
        /// Return assets
        #[clap(long)]
        return_assets: Option<bool>,
        /// Return offers
        #[clap(long)]
        return_offers: Option<bool>,
        /// Return categories
        #[clap(long)]
        return_categories: Option<bool>,
        /// Return filters
        #[clap(long)]
        return_filters: Option<bool>,
        /// Return audiences
        #[clap(long)]
        return_audiences: Option<bool>,
        /// Return QR code info
        #[clap(long)]
        return_qr_code: Option<bool>,
        /// Return external category data
        #[clap(long)]
        return_external_category_data: Option<bool>,
        /// Include favorites in response
        #[clap(long)]
        include_favorite: Option<bool>,
        /// Include liked flag in response
        #[clap(long)]
        include_liked: Option<bool>,
        /// Include rating info in response
        #[clap(long)]
        include_rating: Option<bool>,
    },
    /// Keyword Search Retailer Locations (Indexed)
    IndexedRetailerLocationSearch {
        version: f64,
        /// The account id of the user
        account_id: Option<i64>,
        /// The start index for pagination
        start: Option<i32>,
        /// The limit for pagination
        limit: Option<i32>,
        /// boolean to indicate whether to include retailer locations that have no offers
        #[clap(short, long)]
        has_offers: Option<bool>,
        /// Comma separate list of category ids
        categories: Option<String>,
        /// Comma separated list of filter ids
        filters: Option<String>,
        /// Comma separated list of audience ids
        audiences: Option<String>,
        /// Comma separated list of retailer ids
        retailer_ids: Option<String>,
        /// Comma separated list of retailer location ids
        retailer_location_ids: Option<String>,
        /// Does a full-text search on tags
        tags: Option<String>,
        /// Location type filter
        location_type: Option<String>,
        /// The field to sort the result set on. Possible values include: RETAILER_NAME, RETAILER_LOCATION_NAME
        sort_field: Option<String>,
        /// Determines whether the sorted list is in descending or ascending order
        #[clap(short, long)]
        descending: Option<bool>,
        /// This parameter is deprecated.
        q: Option<String>,
        /// Search by keyword
        keyword: Option<String>,
        /// Determines the operator used when there are multiple words in the 'keyword' parameter
        keyword_operator: Option<String>,
        /// Search expression to further refine results
        search_expression: Option<String>,
        /// Return retailer info
        #[clap(long)]
        return_retailer: Option<bool>,
        /// Return assets
        #[clap(long)]
        return_assets: Option<bool>,
        /// Return offers
        #[clap(long)]
        return_offers: Option<bool>,
        /// Return categories
        #[clap(long)]
        return_categories: Option<bool>,
        /// Return filters
        #[clap(long)]
        return_filters: Option<bool>,
        /// Return audiences
        #[clap(long)]
        return_audiences: Option<bool>,
        /// Return QR code info
        #[clap(long)]
        return_qr_code: Option<bool>,
        /// Return external category data
        #[clap(long)]
        return_external_category_data: Option<bool>,
        /// Include favorites in response
        #[clap(long)]
        include_favorite: Option<bool>,
        /// Include liked flag in response
        #[clap(long)]
        include_liked: Option<bool>,
        /// Include rating info in response
        #[clap(long)]
        include_rating: Option<bool>,
    },
    /// Search Retailer Locations (Owned)
    SearchRetailerLocations {
        version: f64,
        /// The device id (deviceId or accountId required)
        device_id: Option<String>,
        /// The account id of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// This parameter is deprecated.
        q: Option<String>,
        /// The keyword used to search
        keyword: Option<String>,
        /// Comma separated list of retailer IDs which when passed in will filter the results to only return these retailers.
        retailer_ids: Option<String>,
        /// Comma separated list of retailer location IDs
        retailer_location_ids: Option<String>,
        /// Location type filter
        location_type: Option<String>,
        /// The column to sort the search on
        #[clap(value_parser = parse_json::<models::SearchRetailerLocationsSortFieldParameter>)]
        sort_field: Option<models::SearchRetailerLocationsSortFieldParameter>,
        /// The order to return the search results
        #[clap(short, long)]
        descending: Option<bool>,
        /// This parameter is deprecated.
        _i: Option<i32>,
        /// The record to begin the return set on
        start: Option<i32>,
        /// This parameter is deprecated.
        _l: Option<i32>,
        /// The number of records to return
        limit: Option<i32>,
        /// Whether to include public locations in the results
        #[clap(short, long)]
        show_public_locations: Option<bool>,
        /// Return only active results
        #[clap(long)]
        active_only: Option<bool>,
        /// Return retailer info
        #[clap(long)]
        return_retailer: Option<bool>,
        /// Return assets
        #[clap(long)]
        return_assets: Option<bool>,
        /// Return offers
        #[clap(long)]
        return_offers: Option<bool>,
        /// Return categories
        #[clap(long)]
        return_categories: Option<bool>,
        /// Return filters
        #[clap(long)]
        return_filters: Option<bool>,
        /// Return audiences
        #[clap(long)]
        return_audiences: Option<bool>,
        /// Return QR code info
        #[clap(long)]
        return_qr_code: Option<bool>,
        /// Include favorites in response
        #[clap(long)]
        include_favorite: Option<bool>,
        /// Include liked flag in response
        #[clap(long)]
        include_liked: Option<bool>,
        /// Include rating info in response
        #[clap(long)]
        include_rating: Option<bool>,
    },
    /// Update Retailer Location
    UpdateRetailerLocations {
        version: f64,
        /// The ID of the retailer location
        retailer_location_id: i64,
        /// The device id (deviceId or accountId required)
        device_id: Option<String>,
        /// The account id of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// The name of the retailer location
        name: Option<String>,
        /// The street address of the retailer location
        street_address: Option<String>,
        /// Additional address information (such as a suite number, floor number, building name, or PO Box)
        street_address2: Option<String>,
        /// The city of the retailer location
        city: Option<String>,
        /// The state of the retailer location
        state: Option<String>,
        /// The postal code of the retailer location
        postal_code: Option<String>,
        /// the country of the retailer location
        country: Option<String>,
        /// The business phone number of the retailer location
        business_phone: Option<String>,
        /// The business phone extension of the retailer location
        business_phone_ext: Option<String>,
        /// The website of the retailer location
        website: Option<String>,
        /// The email of the retailer location
        email: Option<String>,
        /// An internal identifier used by the retailer
        internal_id: Option<String>,
        /// A brief description about the retailer location (255 character limit)
        details_header: Option<String>,
        /// A detailed description about the retailer location
        details_body: Option<String>,
        /// The hours of operation
        hours: Option<String>,
        /// The retailer location logo sent as a multipart binary file (you can optionally use logoAssetId if the asset has already been uploaded before)
        #[clap(value_parser = parse_json::<swagger::ByteArray>)]
        logo: Option<swagger::ByteArray>,
        /// The retailer location logo asset id
        logo_asset_id: Option<i64>,
        /// Optional store-front pictures or product pictures or etc. A multipart binary file (you can optionally use picture1AssetId if the asset has already been uploaded before)
        #[clap(value_parser = parse_json::<swagger::ByteArray>)]
        picture1: Option<swagger::ByteArray>,
        /// An asset id
        picture1_asset_id: Option<i64>,
        /// Optional store-front pictures or product pictures or etc. A multipart binary file (you can optionally use picture2AssetId if the asset has already been uploaded before)
        #[clap(value_parser = parse_json::<swagger::ByteArray>)]
        picture2: Option<swagger::ByteArray>,
        /// An asset id
        picture2_asset_id: Option<i64>,
        /// Comma separated list of category IDs used to filter retailer locations by categories
        category_ids: Option<String>,
        /// Comma separated list of filter IDs used to filter retailer locations
        filter_ids: Option<String>,
        /// the latituede of the retailer location
        latitude: Option<f64>,
        /// the longitude of the retailer location
        longitude: Option<f64>,
        /// 
        building: Option<String>,
        /// the Google Place ID that the retailer location is associated with
        google_place_id: Option<String>,
        /// the Yelp ID that the retailer location is associated with
        yelp_id: Option<String>,
        /// External custom client defined data
        meta_data: Option<String>,
        /// Specifies which payment provider Sirqul will use when making payments
        payment_provider: Option<String>,
        /// Sets whether the retailer is active or inactive (hidden from consumers)
        #[clap(long)]
        active: Option<bool>,
        /// Sets whether the location is public or not
        #[clap(short, long)]
        public_location: Option<bool>,
        /// External custom type identifier
        location_type: Option<String>,
        /// Comma separated list of audience IDs used to assign audiences to the retailer location
        audience_ids: Option<String>,
        /// Comma separated list of audience IDs to add to the retailer location
        audience_ids_to_add: Option<String>,
        /// Comma separated list of audience IDs to remove from the retailer location
        audience_ids_to_remove: Option<String>,
        /// The format of the returned response {JSON // default , HTML // for Dojo support when uploading assets}
        #[clap(value_parser = parse_json::<models::AggregatedFilteredUsageResponseFormatParameter>)]
        response_format: Option<models::AggregatedFilteredUsageResponseFormatParameter>,
        /// Custom string field for doing full-text searches
        tags: Option<String>,
    },
    /// Get Retailer
    GetRetaokiler {
        version: f64,
        /// the id of the retailer
        retailer_id: i64,
        /// whether to return results that are active only or all
        #[clap(long)]
        active_only: bool,
        /// the keyword to search on to get retailer
        keyword: Option<String>,
        /// the field to sort on
        sort_field: Option<String>,
        /// the start of the index and/or pagination
        start: Option<i64>,
        /// the limit of the index and/or pagination
        limit: Option<i64>,
    },
    /// Create Route
    CreateRoute {
        version: f64,
        #[clap(value_parser = parse_json::<models::Route>)]
        body: Option<models::Route>,
    },
    /// Search Routes
    SearchRoutes {
        version: f64,
        /// The field to sort by
        sort_field: String,
        /// Determines whether the sorted list is in descending or ascending order
        #[clap(short, long)]
        descending: bool,
        /// The start index for pagination
        start: i32,
        /// The limit for pagination
        limit: i32,
        /// Return only active results
        #[clap(long)]
        active_only: bool,
        /// Include empty routes or not
        #[clap(short, long)]
        includes_empty: bool,
        /// Only return root instance routes
        #[clap(short, long)]
        root_only: bool,
        /// Display root route properties
        #[clap(long)]
        show_inherited_properties: bool,
        /// Filter results by service hub
        hub_id: Option<i64>,
        /// Filter results by program
        program_id: Option<i64>,
        /// The start date to filter the results by
        scheduled_start: Option<i64>,
        /// The end date to filter the results by
        scheduled_end: Option<i64>,
        /// The lower bound of updated date
        updated_start: Option<i64>,
        /// The upper bound of updated date
        updated_end: Option<i64>,
        /// The route is featured or not
        #[clap(long)]
        featured: Option<bool>,
        /// Has at least this many seat available
        seat_count: Option<i32>,
        /// Has been approved or not
        #[clap(long)]
        approved: Option<bool>,
        /// Has started or not
        #[clap(long)]
        started: Option<bool>,
        /// Has completed or not
        #[clap(short, long)]
        completed: Option<bool>,
        /// Is valid or not
        #[clap(short, long)]
        valid: Option<bool>,
        /// If it is a recurring route based on the parent route
        parent_id: Option<i64>,
    },
    /// Approve Route
    ApproveRoute {
        version: f64,
        /// the id of the route to approve
        route_id: i64,
    },
    /// Copy Route
    CopyRoute {
        version: f64,
        /// the id of the route to duplicate
        route_id: i64,
        #[clap(value_parser = parse_json::<models::Route>)]
        body: Option<models::Route>,
    },
    /// Update Route Directions
    CreateRouteDirections {
        version: f64,
        /// the id of the route to update directions for
        route_id: i64,
    },
    /// Create Route Polyline
    CreateRoutePolyline {
        version: f64,
        /// the id of the route to create a polyline for
        route_id: i64,
    },
    /// Delete Route
    DeleteRoute {
        version: f64,
        /// the id of the route
        route_id: i64,
    },
    /// Disapprove Route
    DisapproveRoute {
        version: f64,
        /// the id of the route to reject
        route_id: i64,
    },
    /// Get Route
    GetRoute {
        version: f64,
        /// the id of the route to get
        route_id: i64,
        /// return inherited properties from parent or not
        #[clap(short, long)]
        show_inherited_properties: bool,
    },
    /// Get Route Directions
    GetRouteDirections {
        version: f64,
        /// the id of the route to get directions for
        route_id: i64,
    },
    /// Get Route Shipments
    GetRouteShipments {
        version: f64,
        /// the id of the route to get shipments for
        route_id: i64,
    },
    /// Get Route Stops
    GetRouteStops {
        version: f64,
        /// the id of the route
        route_id: i64,
        /// only get stops that have been confirmed or not
        #[clap(short, long)]
        confirmed_only: bool,
    },
    /// Optimize Route
    OptimizeRoute {
        version: f64,
        /// the id of the route to optimize
        route_id: i64,
    },
    /// Reorder Route Stops
    ReorderRouteStopsPatch {
        version: f64,
        /// the id of the route
        route_id: i64,
        #[clap(value_parser = parse_json::<Vec<models::Stop>>, long)]
        body: Option<Vec<models::Stop>>,
    },
    /// Reorder Route Stops
    ReorderRouteStopsPost {
        version: f64,
        /// the id of the route
        route_id: i64,
        #[clap(value_parser = parse_json::<Vec<models::Stop>>, long)]
        body: Option<Vec<models::Stop>>,
    },
    /// Update Route
    UpdateRoute {
        version: f64,
        /// the id of the route
        route_id: i64,
        #[clap(value_parser = parse_json::<models::Route>)]
        body: Option<models::Route>,
    },
    /// Get Route Stop
    GetRouteStop {
        version: f64,
        /// the id of the route to get stops for
        route_id: i64,
        /// the id of the specific stop on the route
        stop_id: i64,
    },
    /// Get Shipments At Stop
    GetShipmentsAtStop {
        version: f64,
        /// the id of the route
        route_id: i64,
        /// the id of the stop to get shipments on
        stop_id: i64,
    },
    /// Delete Stop
    RemoveStop {
        version: f64,
        /// the id of the route
        route_id: i64,
        /// the id of the specific stop to delete on the route
        stop_id: i64,
    },
    /// Set Driver
    SetDriver {
        version: f64,
        /// the id of the route
        id: i64,
        /// the id of the driver
        driver_id: i64,
    },
    /// Update Route Stop
    UpdateRouteStop {
        version: f64,
        /// the id of the route to update stops for
        route_id: i64,
        /// the id of the specific stop to update on the route
        stop_id: i64,
        #[clap(value_parser = parse_json::<models::Stop>)]
        body: Option<models::Stop>,
    },
    /// Create Route Setting
    CreateRouteSettings {
        version: f64,
        #[clap(value_parser = parse_json::<models::RouteSettings>)]
        body: Option<models::RouteSettings>,
    },
    /// Search Route Settings
    SearchRouteSettings {
        version: f64,
        /// The field to sort by
        sort_field: String,
        /// Determines whether the sorted list is in descending or ascending order
        #[clap(short, long)]
        descending: bool,
        /// The start index for pagination
        start: i32,
        /// The limit for pagination
        limit: i32,
        /// Return only active results
        #[clap(long)]
        active_only: bool,
        /// The service hub that the route belongs under
        hub_id: Option<i64>,
        /// The program that the route belongs under
        program_id: Option<i64>,
        /// The keyword to search for the route
        keyword: Option<String>,
    },
    /// Delete Route Setting
    DeleteRouteSettings {
        version: f64,
        /// the id of the route setting to delete
        route_settings_id: i64,
    },
    /// Get Route Setting
    GetRouteSettings {
        version: f64,
        /// the id of the route settings to get
        route_settings_id: i64,
    },
    /// Update Route Setting
    UpdateRouteSettings {
        version: f64,
        /// the id of the route settings to update
        route_settings_id: i64,
        #[clap(value_parser = parse_json::<models::RouteSettings>)]
        body: Option<models::RouteSettings>,
    },
    /// Compute Route
    ComputeRouting {
        version: f64,
        /// Json object containing inputs for generating the routes. See description for more info. Also see RoutingRequest
        data: String,
    },
    /// Create Scheduled Notification
    CreateScheduledNotification {
        version: f64,
        /// The logged in user.
        account_id: i64,
        /// The name of the scheduled notification
        name: String,
        /// The type of scheduled notification. Supported values include: MOBILE_NOTIFICATION - sends push notifications via APNS and GCM EMAIL - sends email messages SMS - sends text messages
        param_type: String,
        /// The message to send
        message: String,
        /// The payload content ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.
        content_id: Option<i64>,
        /// The payload content name that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.
        content_name: Option<String>,
        /// The payload content type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.
        content_type: Option<String>,
        /// The payload parent ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.
        parent_id: Option<i64>,
        /// The payload parent type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.
        parent_type: Option<String>,
        /// The application that the notifications will send to. If connectionGroupIds, connectionAccountIds, and audienceIds is not set, this will send to all users who have used the application. This parameter is also required when sending push notifications via the MOBILE_NOTIFICATION type.
        app_key: Option<String>,
        /// Client defined identifier for grouping multiple scheduled notifications. This can be used with the search endpoint to return scheduled notifications with the same groupingId for display purposes. Only results that have been created by the user will be returned when using this feature.
        grouping_id: Option<String>,
        /// The connection groups to use to generate the list of recipients (comma separated list of connection group IDs)
        connection_group_ids: Option<String>,
        /// The connection accounts to use to generate the list of recipients (comma separated list of user account ids)
        connection_account_ids: Option<String>,
        /// This parameter is deprecated. The audience used to generate the list of recipients
        audience_id: Option<i64>,
        /// The audiences used to generate the list of recipients (comma separated list of audience IDs)
        audience_ids: Option<String>,
        /// The album ids to associate with the scheduled notification (comma separated list of album IDs)
        album_ids: Option<String>,
        /// The report used to generate the the list of recipients
        report_id: Option<i64>,
        /// The parameters to supply to the report used to generate the the list of recipients
        report_params: Option<String>,
        /// The URL for making an HTTP call
        endpoint_url: Option<String>,
        /// The parameters for making an HTTP call
        payload: Option<String>,
        /// The next time when the scheduled notification should begin processing (time in milliseconds). If this is left empty, then the startDate will be used.
        scheduled_date: Option<i64>,
        /// The start time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to be available now.
        start_date: Option<i64>,
        /// The end time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to not have an expiration date.
        end_date: Option<i64>,
        /// The cron expression that represents the processing schedule. This uses the unix cron expression format. For example: 0 0 * * * will run once a day at midnight UTC.
        cron_expression: Option<String>,
        /// The cron expression type: UNIX, CRON4J, QUARTZ
        cron_type: Option<String>,
        /// Additional metadata for the scheduled notification
        meta_data: Option<String>,
        /// Json input representing conditional logic that has to be met before running the scheduled notification
        conditional_input: Option<String>,
        /// This determines if the Scheduled Notification is a template which is used as a basis for dynamically generating re-occurring Scheduled Notifications. The available types include: REPORTING - saves an adhoc report to be able to run again at another time GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business owner) GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business employee, retailer location, etc) GEOFENCE_TRIGGER - template for sending notifications to the account that triggered the geofence/audience (i.e. the customer) GEOFENCE_HTTP_CALL - template for making http calls when the geofences are triggered
        template_type: Option<String>,
        /// Determines the scope of who is able to find and view the scheduled notification (PUBLIC - openly available to all Sirqul users, PRIVATE - only available to users that have been invited)
        #[clap(value_parser = parse_json::<models::AddAlbumCollectionVisibilityParameter>)]
        visibility: Option<models::AddAlbumCollectionVisibilityParameter>,
        /// Sets whether the Scheduled Notification is active or not (inactive Scheduled Notifications are not processed). This is a quick way to toggle on or off without altering its schedule. The default value is 'true'.
        #[clap(long)]
        active: Option<bool>,
        /// 
        #[clap(long)]
        send_now: Option<bool>,
        /// Sets the event type for the notification
        event_type: Option<String>,
        /// The payload deep link URI that can be used by the client app to direct users to a screen in the app
        deep_link_uri: Option<String>,
        /// Determines whether to send to all users of the app if set to true for push notifications (appKey is required)
        #[clap(long)]
        send_to_all: Option<bool>,
    },
    /// Delete Scheduled Notification
    DeleteScheduledNotification {
        version: f64,
        /// the id of the logged in user
        account_id: i64,
        /// the id of the scheduled notification to delete
        scheduled_notification_id: i64,
        /// If set to true, also deletes Scheduled Notifications under the same account with the same groupingId.
        #[clap(short, long)]
        delete_by_grouping_id: Option<bool>,
    },
    /// Get Scheduled Notification
    GetScheduledNotification {
        version: f64,
        /// the id of the account logged in
        account_id: i64,
        /// the id of the scheduled notification to get
        scheduled_notification_id: i64,
    },
    /// Generate Schedule Notifications
    ScheduleNotificationListings {
        version: f64,
        /// The logged in user.
        account_id: i64,
        /// The application to target
        app_key: String,
        /// The name of the report used to identify events. The report must return columns named: id, name, date, params, and type otherwise it will fail
        report_name: String,
        /// The message to be sent to the recipients. If you set %name% the report row name value will be swapped in. If you set %time% or %date% the report row start date/time value will be swapped in
        message: String,
        /// Time in munites before the event starts to notify recipients
        offset: i32,
        /// The report id used to generate the recipient list
        recipient_report_id: i64,
        /// The parameters of the report used to identify events in a json structure, example: ```json {   \"string\": \"value\",   \"number\": 3.345,   \"date\": \"2014-05-01 00:00:00\" } ``` 
        report_params: Option<String>,
        /// The type of scheduled notification; supported values are: MOBILE_NOTIFICATION
        param_type: Option<String>,
    },
    /// Search Scheduled Notifications
    SearchScheduledNotifications {
        version: f64,
        /// The logged in user.
        account_id: i64,
        /// Filter results by a grouping identifier defined by the client
        grouping_id: Option<String>,
        /// Filter results by audience
        audience_id: Option<i64>,
        /// a comma separated list of filters: MINE - Return scheduled notifications that the user has created. SHARED - Return scheduled notifications that have been shared to the user via addUsersToPermissionable. FOLLOWER - Return scheduled notifications that have been created by the users followers (the content needs to have been APPROVED or FEATURED). FOLLOWING - Return scheduled notifications that have been created by people who the user is following (the content needs to have been APPROVED or FEATURED). PUBLIC - Return all PUBLIC scheduled notifications that have been APPROVED or FEATURED. ALL_PUBLIC - Return all PUBLIC scheduled notifications regardless of whether they are approved or not (ignores the approval status). LIKED - Return all scheduled notifications that the user has liked. FEATURED - Return all scheduled notifications that have been featured. PENDING - Return all pending scheduled notifications.
        filter: Option<String>,
        /// Filter results by notification types (comma separated list). Values include: HTTP, EMAIL, SMS, MOBILE_NOTIFICATION
        types: Option<String>,
        /// search using content IDs
        content_ids: Option<String>,
        /// search using content types
        content_types: Option<String>,
        /// search using parent IDs
        parent_ids: Option<String>,
        /// search using parent types
        parent_types: Option<String>,
        /// Filter results by status (comma separated list). Possible values include: NEW - scheduled to run ERROR - encountered an error during processing COMPLETE - processing has completed and it is no longer scheduled to run PROCESSING - currently processing/sending
        statuses: Option<String>,
        /// 
        template_types: Option<String>,
        /// Filter the list by a specific application
        app_key: Option<String>,
        /// Keyword search on the scheduled notification names.
        keyword: Option<String>,
        /// The field to sort by. Possible values include: ID - order by the scheduledNotificationId CREATED - order by the timestamp it was created UPDATED - order by the timestamp it was last updated ACTIVE - order by whether it is active or inactive NAME - order by the scheduled notification name SCHEDULED_DATE - order by the next scheduled date START_DATE - order by the start date END_DATE - order by the end date
        sort_field: Option<String>,
        /// Determines whether the sorted list is in descending or ascending order
        #[clap(short, long)]
        descending: Option<bool>,
        /// Start the result set at some index.
        start: Option<i32>,
        /// Limit the result to some number.
        limit: Option<i32>,
        /// Determines whether to return only active results
        #[clap(long)]
        active_only: Option<bool>,
        /// Determines whether to group results with the same groupingId together.
        #[clap(short, long)]
        group_by_grouping_id: Option<bool>,
        /// If true, include audience account counts in the response
        #[clap(short, long)]
        return_audience_account_count: Option<bool>,
    },
    /// Update Scheduled Notification
    UpdateScheduledNotification {
        version: f64,
        /// The id of scheduled notification to update
        scheduled_notification_id: i64,
        /// The logged in user.
        account_id: i64,
        /// The name of the scheduled notification
        name: Option<String>,
        /// The type of scheduled notification. Supported values include: MOBILE_NOTIFICATION - sends push notifications via APNS and GCM EMAIL - sends email messages SMS - sends text messages
        param_type: Option<String>,
        /// The message to send
        message: Option<String>,
        /// The parameters for making an HTTP call
        payload: Option<String>,
        /// The payload content ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.
        content_id: Option<i64>,
        /// The payload content name that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.
        content_name: Option<String>,
        /// The payload content type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.
        content_type: Option<String>,
        /// The payload parent ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.
        parent_id: Option<i64>,
        /// The payload parent type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.
        parent_type: Option<String>,
        /// The application that the notifications will send to. If connectionGroupIds, connectionAccountIds, and audienceIds is not set, this will send to all users who have used the application. This parameter is also required when sending push notifications via the MOBILE_NOTIFICATION type.
        app_key: Option<String>,
        /// Client defined identifier for grouping multiple scheduled notifications. This can be used with the search endpoint to return scheduled notifications with the same groupingId for display purposes. Only results that have been created by the user will be returned when using this feature.
        grouping_id: Option<String>,
        /// The connection groups to use to generate the list of recipients (comma separated list of connection group IDs)
        connection_group_ids: Option<String>,
        /// The connection accounts to use to generate the list of recipients (comma separated list of user account ids)
        connection_account_ids: Option<String>,
        /// This parameter is deprecated. The audience used to generate the list of recipients
        audience_id: Option<i64>,
        /// The audiences used to generate the list of recipients (comma separated list of audience IDs)
        audience_ids: Option<String>,
        /// The album ids to associate with the scheduled notification (comma separated list of album IDs)
        album_ids: Option<String>,
        /// The report used to generate the the list of recipients
        report_id: Option<i64>,
        /// The parameters to supply to the report used to generate the the list of recipients
        report_params: Option<String>,
        /// The URL for making an HTTP call
        endpoint_url: Option<String>,
        /// The next time when the scheduled notification should begin processing (time in milliseconds). If this is left empty, then the startDate will be used.
        scheduled_date: Option<i64>,
        /// The start time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to be available now.
        start_date: Option<i64>,
        /// The end time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to not have an expiration date.
        end_date: Option<i64>,
        /// The cron expression that represents the processing schedule. This uses the unix cron expression format. For example: 0 0 * * * will run once a day at midnight UTC.
        cron_expression: Option<String>,
        /// The cron expression type: UNIX, CRON4J, QUARTZ
        cron_type: Option<String>,
        /// Additional metadata for the scheduled notification
        meta_data: Option<String>,
        /// Json input representing conditional logic that has to be met before running the scheduled notification
        conditional_input: Option<String>,
        /// This determines if the Scheduled Notification is a template which is used as a basis for dynamically generating re-occurring Scheduled Notifications. The available types include: REPORTING - saves an adhoc report to be able to run again at another time GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business owner) GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business employee, retailer location, etc) GEOFENCE_TRIGGER - template for sending notifications to the account that triggered the geofence/audience (i.e. the customer) GEOFENCE_HTTP_CALL - template for making http calls when the geofences are triggered
        template_type: Option<String>,
        /// Determines the scope of who is able to find and view the scheduled notification (PUBLIC - openly available to all Sirqul users, PRIVATE - only available to users that have been invited)
        #[clap(value_parser = parse_json::<models::AddAlbumCollectionVisibilityParameter>)]
        visibility: Option<models::AddAlbumCollectionVisibilityParameter>,
        /// Sets whether the Scheduled Notification is active or not (inactive Scheduled Notifications are not processed). This is a quick way to toggle on or off without altering its schedule.
        #[clap(long)]
        active: Option<bool>,
        /// the error message associated with the scheduled notification
        error_message: Option<String>,
        /// the status of the scheduled notification
        status: Option<String>,
        /// also updates ScheduledNotifications with the same groupingId and account
        #[clap(short, long)]
        update_by_grouping_id: Option<bool>,
        /// whether to send the scheduled notification now or not
        #[clap(long)]
        send_now: Option<bool>,
        /// Sets the event type for the notification
        event_type: Option<String>,
        /// The payload deep link URI that can be used by the client app to direct users to a screen in the app
        deep_link_uri: Option<String>,
        /// Determines whether to send to all users of the app if set to true for push notifications (appKey is required)
        #[clap(long)]
        send_to_all: Option<bool>,
    },
    /// Create Score
    CreateScore {
        version: f64,
        /// The logged in user.
        account_id: i64,
        /// The game application key to save the score for.
        app_key: String,
        /// The score
        points: i32,
        /// The missionId to score for, ignore if not playing mission.
        mission_id: Option<i64>,
        /// The gameId to score for, ignore if not playing mission.
        game_id: Option<i64>,
        /// The packId to score for, send -2 if playing community levels.
        pack_id: Option<i64>,
        /// The gameLevelId to score for.
        game_level_id: Option<i64>,
        /// The gameObjectId to score for, ignore if level based scoring.
        game_object_id: Option<i64>,
        /// The time taken to complete task
        time_taken: Option<i32>,
        /// 
        #[clap(short, long)]
        highest: Option<bool>,
    },
    /// Get Score
    GetScore {
        version: f64,
        /// The logged in user.
        account_id: i64,
        /// The game application key to get the level for.
        app_key: String,
        /// The missionId to score for, null if not playing mission.
        mission_id: Option<i64>,
        /// The gameId to score for, null if not playing mission.
        game_id: Option<i64>,
        /// The packId to score for, null if playing community levels.
        pack_id: Option<i64>,
        /// The gameLevelId to score for.
        game_level_id: Option<i64>,
        /// The gameObjectId to score for, null if level based scoring.
        game_object_id: Option<i64>,
        /// The object type to filter scores by (TicketObjectType)
        score_object_type: Option<String>,
        /// The status of the score to filter (ScoreStatus)
        score_status: Option<String>,
    },
    /// Search Score
    SearchScores {
        version: f64,
        /// The logged in user.
        account_id: i64,
        /// The game application key to get the level for.
        app_key: String,
        /// The missionId to score for, null if not playing mission.
        mission_id: Option<i64>,
        /// The gameId to score for, null if not playing mission.
        game_id: Option<i64>,
        /// The packId to score for, null if playing community levels.
        pack_id: Option<i64>,
        /// The gameLevelId to score for.
        game_level_id: Option<i64>,
        /// The gameObjectId to score for, null if level based scoring.
        game_object_id: Option<i64>,
    },
    /// Create Secure Application
    CreateSecureApplication {
        version: f64,
        /// The unique id of the user making the request
        account_id: i64,
        /// The application to secure
        app_key: String,
        /// 
        #[clap(value_parser = parse_json::<swagger::ByteArray>)]
        key_cert: swagger::ByteArray,
        /// 
        #[clap(value_parser = parse_json::<swagger::ByteArray>)]
        trust_store: swagger::ByteArray,
        /// 
        username: String,
        /// 
        password: String,
        /// 
        #[clap(long)]
        active: Option<bool>,
        /// The type of biometric, options are: - FINGERPRINT - IRIS - FACIAL
        #[clap(value_parser = parse_json::<models::CreateSecureApplicationBiometricTypeParameter>)]
        biometric_type: Option<models::CreateSecureApplicationBiometricTypeParameter>,
        /// The position for the biometric file uploaded
        #[clap(value_parser = parse_json::<models::CreateSecureApplicationBiometricPositionParameter>)]
        biometric_position: Option<models::CreateSecureApplicationBiometricPositionParameter>,
        /// The position for each the biometric2 file uploaded
        #[clap(value_parser = parse_json::<models::CreateSecureApplicationBiometricPositionParameter>)]
        biometric_position2: Option<models::CreateSecureApplicationBiometricPositionParameter>,
    },
    /// Delete Secure Application
    DeleteSecureApplication {
        version: f64,
        /// The unique id of the user making the request
        account_id: i64,
        /// The application to secure
        app_key: String,
    },
    /// Login Clear
    LoginSecure {
        version: f64,
        /// The application making the request, defines what type and position is required to make a secure login the request.
        app_key: String,
        /// The data file used to perform authentication
        #[clap(value_parser = parse_json::<swagger::ByteArray>)]
        biometric_file: swagger::ByteArray,
        /// The unique id of the device making the request
        device_id: Option<String>,
        /// The data file used to perform authentication
        #[clap(value_parser = parse_json::<swagger::ByteArray>)]
        biometric_file2: Option<swagger::ByteArray>,
        /// Checks user's birthday to see if they meet an age requirement. If the user is under age, an error message is returned.
        age_restriction: Option<i32>,
        /// Determines whether to return a ProfileResponse on success, or a PaymentTypesResponse
        #[clap(short, long)]
        return_profile: Option<bool>,
        /// If returnProfile is set to true, this determines how much of the profile should be returned, see ProfileFilters
        response_filters: Option<String>,
        /// Used to update the user's current location
        latitude: Option<f64>,
        /// Used to update the user's current location
        longitude: Option<f64>,
    },
    /// Purchase Clear
    PurchaseSecure {
        version: f64,
        /// The payment request object
        #[clap(value_parser = parse_json::<models::PaymentRequest>)]
        body: models::PaymentRequest,
    },
    /// Rest Secure Application
    ResetSecure {
        version: f64,
        /// The unique id of the user making the request
        account_id: i64,
        /// The application to secure
        app_key: String,
    },
    /// Update Secure Application
    UpdateSecureApplication {
        version: f64,
        /// The unique id of the user making the request
        account_id: i64,
        /// The application to secure
        app_key: String,
        /// 
        #[clap(long)]
        active: Option<bool>,
        /// 
        #[clap(value_parser = parse_json::<swagger::ByteArray>)]
        key_cert: Option<swagger::ByteArray>,
        /// 
        #[clap(value_parser = parse_json::<swagger::ByteArray>)]
        trust_store: Option<swagger::ByteArray>,
        /// 
        username: Option<String>,
        /// 
        password: Option<String>,
        /// The type of biometric, options are: - FINGERPRINT - IRIS - FACIAL
        #[clap(value_parser = parse_json::<models::UpdateSecureApplicationBiometricTypeParameter>)]
        biometric_type: Option<models::UpdateSecureApplicationBiometricTypeParameter>,
        /// The position for the biometric file uploaded
        #[clap(value_parser = parse_json::<models::UpdateSecureApplicationBiometricPositionParameter>)]
        biometric_position: Option<models::UpdateSecureApplicationBiometricPositionParameter>,
        /// The position for each the biometric2 file uploaded
        #[clap(value_parser = parse_json::<models::UpdateSecureApplicationBiometricPositionParameter>)]
        biometric_position2: Option<models::UpdateSecureApplicationBiometricPositionParameter>,
    },
    /// Create Service Hub
    CreateServiceHub {
        version: f64,
        #[clap(value_parser = parse_json::<models::ServiceHub>)]
        body: Option<models::ServiceHub>,
    },
    /// Search Service Hubs
    SearchServiceHubs {
        version: f64,
        /// The field to sort by
        sort_field: String,
        /// Determines whether the sorted list is in descending or ascending order
        #[clap(short, long)]
        descending: bool,
        /// The start index for pagination
        start: i32,
        /// The limit for pagination
        limit: i32,
        /// Return only active results
        #[clap(long)]
        active_only: bool,
        /// The keyword to search for
        keyword: Option<String>,
        /// The retailer belongs to
        retailer_id: Option<i64>,
    },
    /// Delete Service Hub
    DeleteServiceHub {
        version: f64,
        /// the id of the service hub to delete
        id: i64,
    },
    /// Get Service Hub
    GetServiceHub {
        version: f64,
        /// the id of the service hub to get
        id: i64,
    },
    /// Update Service Hub
    PostServiceHub {
        version: f64,
        /// the id of the service hub
        id: i64,
        #[clap(value_parser = parse_json::<models::ServiceHub>)]
        body: Option<models::ServiceHub>,
    },
    /// Update Service Hub
    PutServiceHub {
        version: f64,
        /// the id of the service hub
        id: i64,
        #[clap(value_parser = parse_json::<models::ServiceHub>)]
        body: Option<models::ServiceHub>,
    },
    /// Create Shipment
    CreateShipment {
        version: f64,
        #[clap(value_parser = parse_json::<models::Shipment>)]
        body: Option<models::Shipment>,
    },
    /// Search Shipments
    SearchShipments {
        version: f64,
        /// The field to sort by
        sort_field: String,
        /// Determines whether the sorted list is in descending or ascending order
        #[clap(short, long)]
        descending: bool,
        /// The start index for pagination
        start: i32,
        /// The limit for pagination
        limit: i32,
        /// Return only active results
        #[clap(long)]
        active_only: bool,
        /// The owner of the shipment
        owner_id: Option<i64>,
        /// The rider associate to this shipment
        rider_id: Option<i64>,
        /// The route associate to this shipment
        route_id: Option<i64>,
    },
    /// Cancel Shipment
    CancelShipment {
        version: f64,
        /// the id of the shipment to cancel
        id: i64,
    },
    /// Delete Shipment
    DeleteShipment {
        version: f64,
        /// the id of the shipment to delete
        id: i64,
    },
    /// Get Shipment
    GetShipment {
        version: f64,
        /// the id of the shipment to get
        id: i64,
    },
    /// Update Shipment
    UpdateShipment {
        version: f64,
        /// the id of the shipment to update
        id: i64,
        #[clap(value_parser = parse_json::<models::Shipment>)]
        body: Option<models::Shipment>,
    },
    /// Uupdate Shipment Status
    UpdateShipmentStatus {
        version: f64,
        /// the id of the shipment to update status
        id: i64,
        #[clap(value_parser = parse_json::<std::collections::HashMap<String, bool>>)]
        body: Option<std::collections::HashMap<String, bool>>,
    },
    /// Create Shipment Batch
    CreateShipmentBatch {
        version: f64,
        #[clap(value_parser = parse_json::<models::ShipmentBatch>)]
        body: Option<models::ShipmentBatch>,
    },
    /// Search Shipment Batch
    SearchShipmentBatch {
        version: f64,
        /// The associated service hub
        hub_id: i64,
        /// The field to sort by
        sort_field: String,
        /// Determines whether the sorted list is in descending or ascending order
        #[clap(short, long)]
        descending: bool,
        /// The start index for pagination
        start: i32,
        /// The limit for pagination
        limit: i32,
    },
    /// Delete Shipment Batch
    DeleteShipmentBatch {
        version: f64,
        /// the id of the shipment batch to delete
        batch_id: i64,
    },
    /// Get Shipment Batch
    GetShipmentBatch {
        version: f64,
        /// the id of the shipment batch to get
        batch_id: i64,
    },
    /// Get Shipment Batch Status
    GetShipmentBatchStatus {
        version: f64,
        /// The id of the requested shipment batch
        batch_id: i64,
        /// the id of the logged in user
        account_id: i64,
        /// The field to sort by
        sort_field: String,
        /// Determines whether the sorted list is in descending or ascending order
        #[clap(short, long)]
        descending: bool,
        /// The start index for pagination
        start: i32,
        /// The limit for pagination
        limit: i32,
        /// Valid import status only or not
        #[clap(short, long)]
        valid: Option<bool>,
        /// Started import status only
        #[clap(short, long)]
        started: Option<bool>,
        /// Completed import status only
        #[clap(short, long)]
        completed: Option<bool>,
        /// Has shipment associate to the status
        #[clap(long)]
        has_shipment: Option<bool>,
        /// Has route associate to the status
        #[clap(long)]
        has_route: Option<bool>,
        /// The keyword to search for
        keyword: Option<String>,
    },
    /// Routing Simulation
    Simulation {
        version: f64,
        /// JSON string in the following format: ```json {   \"startDate\": 1474268400000,   \"endDate\": 1474268700000,   \"checkoutStops\": [     {       \"latitude\": 25.060453943481615,       \"longitude\": 121.57487118216957     }   ],   \"requests\": [     {       \"vehicles\": [         {           \"id\": \"customer1\",           \"name\": \"Customer 1\",           \"depot\": {             \"latitude\": 25.060453943481615,             \"longitude\": 121.57487118216957           },           \"startWindow\": 1474268464537         }       ],       \"items\": [         {           \"id\": 152712,           \"name\": \"Appliance Product\",           \"pickup\": {             \"latitude\": 25.060306635544144,             \"longitude\": 121.5750770690688           }         },         {           \"id\": 152711,           \"name\": \"TV product\",           \"pickup\": {             \"latitude\": 25.060126352576326,             \"longitude\": 121.57505023621624           }         }       ]     }   ],   \"featuredItems\": [],   \"floorPlan\": {     \"metersPerX\": 0.81493109028875,     \"metersPerY\": 1.8525267552262,     \"width\": 75,     \"height\": 50,     \"exclusions\": [       { \"x\": 14, \"y\": 49 }     ],     \"southwest\": {       \"x\": 0,       \"y\": 0,       \"latitude\": 25.05961539530497,       \"longitude\": 121.57487591737885     }   } } ``` 
        data: String,
        /// determines whether to run the simulation and return the results in the same request
        #[clap(short, long)]
        real_time: bool,
    },
    /// Get Stop
    GetStop {
        version: f64,
        /// the id of the stop to get
        id: i64,
    },
    /// Update Stop
    UpdateStop {
        version: f64,
        /// the id of the stop to update
        id: i64,
        #[clap(value_parser = parse_json::<models::Stop>)]
        body: Option<models::Stop>,
    },
    /// Create Stripe Checkout Session
    CreateStripeCheckoutSession {
        version: f64,
        /// Sirqul Application Key
        app_key: String,
        /// Stripe Parameters
        stripe_parameters: String,
    },
    /// Create Subscription
    CreateSubscription {
        version: f64,
        /// The account used to perform the create, must be the responsible manager
        account_id: i64,
        /// The plan to subscribe to, if null use default plan
        plan_id: Option<i64>,
        /// Set a promo code for a discount.
        promo_code: Option<String>,
    },
    /// Delete Subscription
    DeleteSubscription {
        version: f64,
        /// The account used to perform the delete, must be the responsible manager
        account_id: i64,
    },
    /// Get Subscription
    GetSubscription {
        version: f64,
        /// The account used to perform the lookup
        account_id: i64,
    },
    /// Get Subscription Plan
    GetSubscriptionPlan {
        version: f64,
        /// The ID of the plan to get
        plan_id: i64,
    },
    /// List Subscription Plans
    GetSubscriptionPlans {
        version: f64,
        /// Include visible only (true), hidden only (false), or all (null)
        #[clap(short, long)]
        visible: Option<bool>,
        /// The role the plan is targeted for, values are: DEVELOPER, RETAILER, ADVERTISER
        role: Option<String>,
    },
    /// Get Subscription Usage
    GetSubscriptionUsage {
        version: f64,
        /// The account used to perform the lookup
        account_id: i64,
        /// Get for just 1 application instead of the BillableEntity
        application_id: Option<i64>,
        /// The start time frame
        start: Option<i64>,
        /// The end time frame
        end: Option<i64>,
    },
    /// Update Subscription
    UpdateSubscription {
        version: f64,
        /// The account used to perform the update, must be the responsible manager
        account_id: i64,
        /// The plan to subscribe to
        plan_id: Option<i64>,
        /// Set a promo code for a discount.
        promo_code: Option<String>,
        /// Set active status
        #[clap(long)]
        active: Option<bool>,
    },
    /// Create Task
    CreateTask {
        version: f64,
        /// The logged in user.
        account_id: i64,
        /// The name of the task
        name: String,
        /// The application to target
        app_key: Option<String>,
        /// Client defined identifier for grouping tasks
        grouping_id: Option<String>,
        /// The URL for making an HTTP call
        endpoint_url: Option<String>,
        /// The parameters for making an HTTP call
        payload: Option<String>,
        /// The date and time of the task
        scheduled_date: Option<i64>,
        /// The starting date of the task
        start_date: Option<i64>,
        /// The ending date of the task
        end_date: Option<i64>,
        /// The cron expression that represents the task's schedule
        cron_expression: Option<String>,
        /// The determines the scope of who is able to find and view the scheduled notification (PUBLIC - openly available to all Sirqul users, PRIVATE - only available to users that have been invited)
        #[clap(value_parser = parse_json::<models::AddAlbumCollectionVisibilityParameter>)]
        visibility: Option<models::AddAlbumCollectionVisibilityParameter>,
        /// Sets whether the Task is active or not (inactive Tasks are not processed)
        #[clap(long)]
        active: Option<bool>,
    },
    /// Delete Task
    DeleteTask {
        version: f64,
        /// The logged in user.
        account_id: i64,
        /// The id of the Task to delete.
        task_id: i64,
    },
    /// Get Task
    GetTask {
        version: f64,
        /// The logged in user.
        account_id: i64,
        /// The id of the Task to return.
        task_id: i64,
    },
    /// Search Tasks
    SearchTasks {
        version: f64,
        /// The logged in user.
        account_id: i64,
        /// Filter results by a grouping identifier defined by the client
        grouping_id: Option<String>,
        /// A comma separated list of filters:  * MINE - Return tasks that the user has created * SHARED - Return tasks that have been shared to the user * FOLLOWER - Return tasks that have been created by the user''s followers (the content needs to have been APPROVED or FEATURED) * FOLLOWING - Return tasks that have been created by people who the user is following (the content needs to have been APPROVED or FEATURED) * PUBLIC - Return all PUBLIC tasks that have been APPROVED or FEATURED * ALL_PUBLIC - Return all PUBLIC tasks regardless of whether they are approved or not (ignores the approval status) * LIKED - Return all tasks that the user has liked * FEATURED - Return all tasks that have been featured * PENDING - Return all pending tasks 
        filter: Option<String>,
        /// Filter results by status (comma separated list). Values include: NEW, ERROR, COMPLETE, PROCESSING, TEMPLATE
        statuses: Option<String>,
        /// Template Types
        template_types: Option<String>,
        /// Filter the list by a specific application
        app_key: Option<String>,
        /// Keyword search on the task names.
        keyword: Option<String>,
        /// The field to sort by. Possible values include: ID, CREATED, UPDATED, ACTIVE, NAME, SCHEDULED_DATE, START_DATE, END_DATE
        sort_field: Option<String>,
        /// Determines whether the sorted list is in descending or ascending order
        #[clap(short, long)]
        descending: Option<bool>,
        /// Start the result set at some index.
        start: Option<i32>,
        /// Limit the result to some number.
        limit: Option<i32>,
        /// Determines whether to return only active results
        #[clap(long)]
        active_only: Option<bool>,
    },
    /// Update Task
    UpdateTask {
        version: f64,
        /// Task Id
        task_id: i64,
        /// The logged in user.
        account_id: i64,
        /// The name of the task
        name: Option<String>,
        /// The application to target
        app_key: Option<String>,
        /// Client defined identifier for grouping tasks
        grouping_id: Option<String>,
        /// The URL for making an HTTP call
        endpoint_url: Option<String>,
        /// The parameters for making an HTTP call
        payload: Option<String>,
        /// The date and time of the task
        scheduled_date: Option<i64>,
        /// The starting date of the task
        start_date: Option<i64>,
        /// The ending date of the task
        end_date: Option<i64>,
        /// The cron expression that represents the task's schedule
        cron_expression: Option<String>,
        /// The determines the scope of who is able to find and view the scheduled notification (PUBLIC - openly available to all Sirqul users, PRIVATE - only available to users that have been invited)
        #[clap(value_parser = parse_json::<models::AddAlbumCollectionVisibilityParameter>)]
        visibility: Option<models::AddAlbumCollectionVisibilityParameter>,
        /// Sets whether the Task is active or not (inactive Tasks are not processed)
        #[clap(long)]
        active: Option<bool>,
    },
    /// Create Territory
    CreateTerritory {
        version: f64,
        /// The logged in user.
        account_id: i64,
        /// The name of the territory
        name: String,
        /// If true set the game level as active. Default is true.
        #[clap(long)]
        active: Option<bool>,
    },
    /// Delete Territory
    DeleteTerritory {
        version: f64,
        /// the id of the logged in user
        account_id: i64,
        /// the id of the territory to delete
        territory_id: i64,
    },
    /// Get Territory
    GetTerritory {
        version: f64,
        /// the id of the territory to get
        territory_id: i64,
    },
    /// Search Territories
    SearchTerritories {
        version: f64,
        /// the field to sort by. Supported values include: ID, CREATED, UPDATED, NAME
        #[clap(value_parser = parse_json::<models::SearchTerritoriesSortFieldParameter>)]
        sort_field: models::SearchTerritoriesSortFieldParameter,
        /// determines whether the sorted list is in descending or ascending order
        #[clap(short, long)]
        descending: bool,
        /// Return results that match this keyword.
        keyword: Option<String>,
        /// The start index for pagination
        start: Option<i32>,
        /// The limit for pagination
        limit: Option<i32>,
    },
    /// Update Territory
    UpdateTerritory {
        version: f64,
        /// The logged in user.
        account_id: i64,
        /// the id of the territory to update
        territory_id: i64,
        /// The name of the territory
        name: Option<String>,
        /// If true set the game level as active.
        #[clap(long)]
        active: Option<bool>,
    },
    /// Create/Update Theme
    AddOrUpdateThemeDescriptor {
        version: f64,
        /// determines whether the theme's participants have read permissions
        #[clap(long)]
        public_read: bool,
        /// determines whether the theme's participants have write permissions
        #[clap(long)]
        public_write: bool,
        /// determines whether the theme's participants have delete permissions
        #[clap(long)]
        public_delete: bool,
        /// 
        #[clap(long)]
        public_add: bool,
        /// the determines the theme's participants (PUBLIC - includes everyone in the system as a potential participant, PRIVATE - only considers people who have been invited as participants)
        #[clap(value_parser = parse_json::<models::AddAlbumCollectionVisibilityParameter>)]
        visibility: models::AddAlbumCollectionVisibilityParameter,
        /// flag to determine whether to share to the user's \"friends\" group
        #[clap(short, long)]
        include_friend_group: bool,
        /// determines whether to use default values to complete the theme
        #[clap(short, long)]
        complete_with_default_values: bool,
        /// a unique ID given by the device (deviceId or accountId required)
        device_id: Option<String>,
        /// the account ID of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// the application key
        game_type: Option<String>,
        /// the theme descriptor id used to update an existing theme, leave empty for creating a new theme
        theme_descriptor_id: Option<i64>,
        /// the title of the theme
        title: Option<String>,
        /// the description of the theme
        description: Option<String>,
        /// a comma separated list of connection IDs to share to users
        connection_ids_to_add: Option<String>,
        /// a comma separated list of connection group IDs to share to groups
        connection_group_ids_to_add: Option<String>,
        /// the application version the theme was created for
        app_version: Option<String>,
        /// a json array used to replace colors within the application. Example: ```json [   {     \"name\": \"sceneAtlas\",     \"valueString\": \"100,100,100,255\"   },   {     \"name\": \"bg\",     \"valueString\": \"100,100,100,255\"   } ] ``` 
        color_value_json: Option<String>,
        /// a json array used to replace strings within the application. Example: ```json [   {     \"name\": \"coins\",     \"valueString\": \"Gems\"   },   {     \"name\": \"lives\",     \"valueString\": \"lives\"   } ] ``` 
        string_replacer_json: Option<String>,
        /// a json object used by the scene atlas to position sprites. Example: ```json {   \"pShootingOffset\": [     {       \"name\": \"x\",       \"valueString\": \"2.2\"     },     {       \"name\": \"y\",       \"valueString\": \"-0.3\"     }   ],   \"e1ShootingOffset\": [     {       \"name\": \"x\",       \"valueString\": \"0.25\"     },     {       \"name\": \"y\",       \"valueString\": \"0.5\"     }   ] } ``` 
        custom_json_objects: Option<String>,
        /// a MultipartFile containing the image used as the theme icon
        #[clap(value_parser = parse_json::<swagger::ByteArray>)]
        icon_image: Option<swagger::ByteArray>,
        /// a MultipartFile containing the scene atlas
        #[clap(value_parser = parse_json::<swagger::ByteArray>)]
        scene_atlas_image: Option<swagger::ByteArray>,
        /// a MultipartFile containing the background image
        #[clap(value_parser = parse_json::<swagger::ByteArray>)]
        bg_image: Option<swagger::ByteArray>,
        /// a MultipartFile containing the background sound file (preferably in MP3 format)
        #[clap(value_parser = parse_json::<swagger::ByteArray>)]
        bg_sound: Option<swagger::ByteArray>,
        /// used to select a default sound file that already exists in the application
        music_selection: Option<String>,
        /// the description of the user's current location
        location_description: Option<String>,
        /// the current latitude of the user
        latitude: Option<f64>,
        /// the current longitude of the user
        longitude: Option<f64>,
    },
    /// Get Theme
    GetThemeDescriptor {
        version: f64,
        /// the theme id
        theme_descriptor_id: i64,
        /// a unique ID given by the device (deviceId or accountId required)
        device_id: Option<String>,
        /// the account ID of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// the application key
        game_type: Option<String>,
        /// latitude used to update the user's current location
        latitude: Option<f64>,
        /// longitude used to update the user's current location
        longitude: Option<f64>,
    },
    /// Search Themes
    GetThemeDescriptors {
        version: f64,
        /// a comma separated list of Ownership
        filter: String,
        /// the field to sort by. See ThemeDescriptorApiMap
        sort_field: String,
        /// determines whether the sorted list is in descending or ascending order
        #[clap(short, long)]
        descending: bool,
        /// the start parameter for pagination
        start: i32,
        /// the limit parameter for pagination
        limit: i32,
        /// a unique id given by the device (deviceId or accountId required)
        device_id: Option<String>,
        /// the account id of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// the unique title of an application given from the admin tool
        game_type: Option<String>,
        /// contest type
        contest_type: Option<String>,
        /// search on contests that an account has access to
        owner_id: Option<i64>,
        /// This parameter is deprecated.
        q: Option<String>,
        /// a keyword to search on
        keyword: Option<String>,
        /// This parameter is deprecated.
        _i: Option<i32>,
        /// This parameter is deprecated.
        _l: Option<i32>,
        /// filter on items that have been created before this date
        date_created: Option<i64>,
        /// application version of the theme to filter by
        app_version: Option<String>,
        /// latitude used to update the user's current location
        latitude: Option<f64>,
        /// longitude used to update the user's current location
        longitude: Option<f64>,
    },
    /// Delete Theme
    RemoveThemeDescriptor {
        version: f64,
        /// the theme id to remove
        theme_descriptor_id: i64,
        /// a unique id given by the device (deviceId or accountId required)
        device_id: Option<String>,
        /// the account id of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// the unique title of an application given from the admin tool
        game_type: Option<String>,
        /// latitude used to update the user's current location
        latitude: Option<f64>,
        /// longitude used to update the user's current location
        longitude: Option<f64>,
    },
    /// Create Credential
    CreateCredential {
        version: f64,
        /// the third party user account id
        third_party_id: String,
        /// the access token to authenticate with (ex: username or fb token or phone number)
        third_party_token: String,
        /// the access provider to authenticate against
        network_uid: String,
        /// the application key
        app_key: String,
        /// the unique id of the account that needs authenticating (optional for PHONE_V2)
        account_id: Option<i64>,
        /// the unique id of the device making the request
        device_id: Option<String>,
        /// the session id for the request
        session_id: Option<String>,
        /// the third party user's display name
        third_party_name: Option<String>,
        /// optional email address associated with the third party account
        email_address: Option<String>,
        /// when true will error out if can't find any accounts matching (signin only)
        #[clap(short, long)]
        signin_only_mode: Option<bool>,
        /// this determines how much of the profile should be returned, see ProfileFilters
        response_filters: Option<String>,
        /// the latitude of the user
        latitude: Option<f64>,
        /// the longitude of the user
        longitude: Option<f64>,
        /// External custom client defined data
        meta_data: Option<String>,
        /// optional refresh token for the third party
        third_party_refresh_token: Option<String>,
        /// audience ids to add to the account
        audience_ids_to_add: Option<String>,
        /// audience ids to remove from the account
        audience_ids_to_remove: Option<String>,
    },
    /// Create Network
    CreateNetwork {
        version: f64,
        /// The account id making the request
        account_id: i64,
        /// The name of the network
        name: String,
        /// Whether the network uses introspection calls
        #[clap(long)]
        enable_introspection: bool,
        /// The description of the network
        description: Option<String>,
        /// HTTP method to use for introspection calls (e.g., GET, POST)
        introspection_method: Option<String>,
        /// The HTTP URL of the introspection call
        introspection_url: Option<String>,
        /// The parameters of the introspection call
        introspection_params: Option<String>,
        /// Required response params
        required_root_field: Option<String>,
        /// Whether this network uses MFA
        #[clap(long)]
        enable_mfa: Option<bool>,
        /// Size of the MFA token
        size_mfa: Option<i32>,
        /// Shelf life (seconds) of the MFA token
        shelf_life_mfa: Option<i32>,
        /// OAuth token endpoint URL
        oauth_token_url: Option<String>,
        /// OAuth private key file (multipart)
        #[clap(value_parser = parse_json::<swagger::ByteArray>)]
        oauth_private_key: Option<swagger::ByteArray>,
        /// OAuth public key file (multipart)
        #[clap(value_parser = parse_json::<swagger::ByteArray>)]
        oauth_public_key: Option<swagger::ByteArray>,
        /// OAuth client id
        oauth_client_id: Option<String>,
        /// OAuth secret key
        oauth_secret_key: Option<String>,
        body: Option<String>,
    },
    /// Delete Credential
    DeleteCredential {
        version: f64,
        /// The account id of the user
        account_id: i64,
        /// The third party network identifier
        network_uid: String,
        /// The third party user id
        third_party_id: String,
        /// the application key
        app_key: String,
    },
    /// Delete Network
    DeleteNetwork {
        version: f64,
        /// the id of the logged in user
        account_id: i64,
        /// The unique identifier for the third party network defined by Sirqul
        network_uid: String,
    },
    /// Get Credential
    GetCredential {
        version: f64,
        /// the access provider to authenticate against
        network_uid: String,
        /// the application key
        app_key: String,
        /// the unique account id of a specific account that will be bound to the third-party credentials
        account_id: Option<i64>,
        /// the unique id of the device making the request
        device_id: Option<String>,
        /// the session id for the request
        session_id: Option<String>,
        /// the third-party credentials id from the response of the credential/create step
        third_party_credential_id: Option<i64>,
        /// the access token to authenticate with
        third_party_token: Option<String>,
        /// the secret code to authenticate with (used for MFA)
        third_party_secret: Option<String>,
        /// flag to force creation of a new account when no accountId is passed and user chooses not to use listed accounts
        #[clap(short, long)]
        create_new_account: Option<bool>,
        /// this determines how much of the profile should be returned, see ProfileFilters
        response_filters: Option<String>,
        /// the latitude of the user
        latitude: Option<f64>,
        /// the longitude of the user
        longitude: Option<f64>,
        /// audience ids to add to the account
        audience_ids_to_add: Option<String>,
        /// audience ids to remove from the account
        audience_ids_to_remove: Option<String>,
        /// account id of the referrer (inviter-invitee relationship)
        referral_account_id: Option<i64>,
    },
    /// Get Network
    GetNetwork {
        version: f64,
        /// The account id making the request
        account_id: i64,
        /// The unique identifier for the third party network defined by Sirqul
        network_uid: String,
    },
    /// Search Credentials
    SearchCredentials {
        version: f64,
        /// The account id of the user
        account_id: i64,
        /// The keyword used to search on the third party name and network string
        keyword: Option<String>,
        /// The network UID to filter results with
        network_uid: Option<String>,
        /// The order to return the search results
        #[clap(short, long)]
        descending: Option<bool>,
        /// The start of the pagination
        start: Option<i32>,
        /// The limit of the pagination
        limit: Option<i32>,
    },
    /// Search Networks
    SearchNetworks {
        version: f64,
        /// The account id making the request
        account_id: i64,
        /// The column to sort the search on, possible values include: UPDATED (default), CREATED, NAME
        #[clap(value_parser = parse_json::<models::SearchNetworksSortFieldParameter>)]
        sort_field: models::SearchNetworksSortFieldParameter,
        /// The order to return the search results
        #[clap(short, long)]
        descending: bool,
        /// The start of the pagination
        start: i32,
        /// The limit of the pagination
        limit: i32,
        /// Return only active results
        #[clap(long)]
        active_only: bool,
        /// The keyword used to search on the network name and description fields
        keyword: Option<String>,
        /// Determines whether to only return applications that the user has access to
        #[clap(long)]
        filter_billable: Option<bool>,
    },
    /// Send MFA Challenge
    SendMfaChallenge {
        version: f64,
        /// the third party network provider that has MFA enabled
        network_uid: String,
        /// the application key
        app_key: String,
        /// the access token to authenticate with
        third_party_token: Option<String>,
        /// optional id of the existing third party credential
        third_party_credential_id: Option<i64>,
        /// the unique id of the device making the request
        device_id: Option<String>,
    },
    /// Update Credential
    UpdateCredential {
        version: f64,
        /// the access provider to authenticate against
        network_uid: String,
        /// the third party user account id
        third_party_id: String,
        /// the application key
        app_key: String,
        /// the unique id of the device making the request
        device_id: Option<String>,
        /// the third party user name
        third_party_name: Option<String>,
        /// the access token to authenticate with (ex: username or fb token)
        third_party_token: Option<String>,
        /// this determines how much of the profile should be returned, see ProfileFilters
        response_filters: Option<String>,
        /// External custom client defined data
        meta_data: Option<String>,
        /// optional refresh token for the third party
        third_party_refresh_token: Option<String>,
    },
    /// Update Network
    UpdateNetwork {
        version: f64,
        /// The account id making the request
        account_id: i64,
        /// The unique identifier for the third party network defined by Sirqul
        network_uid: String,
        /// The name of the network
        name: Option<String>,
        /// The description of the network
        description: Option<String>,
        /// Whether the network uses introspection calls
        #[clap(long)]
        enable_introspection: Option<bool>,
        /// HTTP method to use for introspection calls (e.g., GET, POST)
        introspection_method: Option<String>,
        /// The HTTP URL of the introspection call
        introspection_url: Option<String>,
        /// The parameters of the introspection call
        introspection_params: Option<String>,
        /// Required response params
        required_root_field: Option<String>,
        /// Whether this network uses MFA
        #[clap(long)]
        enable_mfa: Option<bool>,
        /// Size of the MFA token
        size_mfa: Option<i32>,
        /// Shelf life (seconds) of the MFA token
        shelf_life_mfa: Option<i32>,
        /// OAuth token endpoint URL
        oauth_token_url: Option<String>,
        /// OAuth private key file (multipart)
        #[clap(value_parser = parse_json::<swagger::ByteArray>)]
        oauth_private_key: Option<swagger::ByteArray>,
        /// OAuth public key file (multipart)
        #[clap(value_parser = parse_json::<swagger::ByteArray>)]
        oauth_public_key: Option<swagger::ByteArray>,
        /// OAuth client id
        oauth_client_id: Option<String>,
        /// OAuth secret key
        oauth_secret_key: Option<String>,
        body: Option<String>,
    },
    /// Get Ticket Count
    GetTicketCount {
        version: f64,
        /// the id of the device that owns the tickets
        device_id: Option<String>,
        /// the id of the account that owns the tickets
        account_id: Option<i64>,
        /// this is deprecated.
        game_type: Option<String>,
        /// the applicationkey
        app_key: Option<String>,
        /// the type of ticket
        ticket_type: Option<String>,
    },
    /// Get Ticket List
    GetTicketList {
        version: f64,
        /// the id of the device that owns the tickets
        device_id: Option<String>,
        /// the id of the account that owns the tickets
        account_id: Option<i64>,
        /// comma separated list of TicketObjectType
        ticket_object_type: Option<String>,
        /// comma separated list of TicketActionType
        action_type: Option<String>,
        /// the ids of the tickets to get
        ticket_ids: Option<String>,
        /// the ids of the objects to get
        object_ids: Option<String>,
        /// 
        receipt_tokens: Option<String>,
        /// 
        game_type: Option<String>,
        /// the application key
        app_key: Option<String>,
    },
    /// Gift Tickets
    GiftPurchase {
        version: f64,
        /// the id of the account receiving the tickets
        receiver_account_id: i64,
        /// the id of the tickets
        ticket_id: i64,
        /// the id of the device
        device_id: Option<String>,
        /// the id of the gift owner
        account_id: Option<i64>,
        /// the id of the asset
        asset_id: Option<i64>,
        /// a message that can be written to go along with the gift
        custom_message: Option<String>,
        /// the type of game associated with the tickets
        game_type: Option<String>,
        /// the application key
        app_key: Option<String>,
    },
    /// Save Ticket
    SaveTicket {
        version: f64,
        /// the action being performed, values: COMPLETED, // ADD TICKETS FOR COMPLETING A MISSION, CHALLENGE, GAME, PACK, LEVEL, LEVEL OBJECT REDEEMED, // REMOVE TICKETS FOR BUYING PACKS, HINTS, AND PEN TOOLS OPTIONS, ETC USERS_PLAYED, // ADD TICKETS FOR LEVELS PLAYED BY OTHER USERS TOURNAMENT_OWNER, // ADD TICKETS FOR TOURNAMENTS BY OTHER USERS PURCHASED, // ADD TICKET VIA IN APP PURCHASING SUMATION, // SUMATION OF TICKETS EARNED FROM CHILDREN GIFTED, // TRANSFERING OF PURCHASE ITEMS TO OTHER PEOPLE REFUNDED // FOR REFUNDING TICKETS BACK TO THE USER
        action_type: String,
        /// the type of object being purchased, values: GAME_OBJECT, GAME_LEVEL, PACK, GAME, MISSION, PROFILE, APPLICATION, TICKETS, ASSET, CUSTOM
        ticket_object_type: String,
        /// whether to return nulls or not
        #[clap(long)]
        return_nulls: Option<bool>,
        /// the device id that owns the tickets
        device_id: Option<String>,
        /// the account id that owns the tickets
        account_id: Option<i64>,
        /// This parameter is deprecated. deprecated, use the appKey
        game_type: Option<String>,
        /// the application key
        app_key: Option<String>,
        /// the ID of the item being purchased
        object_id: Option<i64>,
        /// a unique string identifier defined by the application owner or Executive
        purchase_code: Option<String>,
        /// a unique transaction identifier from the purchase provider (i.e. the transaction ID from iTunes, Google Play, etc)
        receipt_token: Option<String>,
        /// the receipt/transaction data for validating a purchase via iTunes/Gooogle/etc. This should be in string format.
        receipt_data: Option<String>,
        /// the count of tickets
        count: Option<i64>,
        /// the ticket type
        ticket_type: Option<String>,
        /// the provider for making the purchase {ITUNES, ITUNES_SANDBOX, GOOGLE}
        purchase_provider: Option<String>,
        /// a comma separated list of purchase types { SIRQUL, // purchasing from the sirqul store using tickets IOS, // purchasing from the itunes store for iPhone, iPod, iPod Touch GOOGLE, // purchasing from the google android store AMAZON, // purchasing from the amazon android store MAC, // purchasing from the itunes store for OSX WP8, // purhasing from the windows phone 8 store FREE }
        purchase_type: Option<String>,
        /// returns a ProfileResponse if true, otherwise will return an AppResponse
        #[clap(long)]
        return_profile_response: Option<bool>,
        /// if returnProfileResponse is false, will return an AppResponse with profile data if true
        #[clap(short, long)]
        include_profile_response: Option<bool>,
        /// the application version
        app_version: Option<String>,
    },
    /// Save Ticket with Reciept
    SaveTicketViaFileUpload {
        version: f64,
        /// the action being performed { COMPLETED, // ADD TICKETS FOR COMPLETING A MISSION, CHALLENGE, GAME, PACK, LEVEL, LEVEL OBJECT REDEEMED, // REMOVE TICKETS FOR BUYING PACKS, HINTS, AND PEN TOOLS OPTIONS, ETC USERS_PLAYED, // ADD TICKETS FOR LEVELS PLAYED BY OTHER USERS TOURNAMENT_OWNER, // ADD TICKETS FOR TOURNAMENTS BY OTHER USERS PURCHASED, // ADD TICKET VIA IN APP PURCHASING SUMATION, // SUMATION OF TICKETS EARNED FROM CHILDREN GIFTED, // TRANSFERING OF PURCHASE ITEMS TO OTHER PEOPLE REFUNDED // FOR REFUNDING TICKETS BACK TO THE USER }
        action_type: String,
        /// the type of object being purchased {GAME_OBJECT, GAME_LEVEL, PACK, GAME, MISSION, PROFILE, APPLICATION, TICKETS, ASSET, CUSTOM}
        ticket_object_type: String,
        /// the receipt/transaction data for validating a purchase via iTunes/Gooogle/etc. This should be in binary format.
        #[clap(value_parser = parse_json::<swagger::ByteArray>)]
        receipt_data: swagger::ByteArray,
        /// whether to return nulls or not
        #[clap(long)]
        return_nulls: Option<bool>,
        /// the device id
        device_id: Option<String>,
        /// the account id
        account_id: Option<i64>,
        /// This parameter is deprecated. deprecated, use the appKey
        game_type: Option<String>,
        /// the application key
        app_key: Option<String>,
        /// the ID of the item being purchased
        object_id: Option<i64>,
        /// a unique string identifier defined by the application owner or Executive
        purchase_code: Option<String>,
        /// a unique transaction identifier from the purchase provider (i.e. the transaction ID from iTunes, Google Play, etc)
        receipt_token: Option<String>,
        /// the count of tickets
        count: Option<i64>,
        /// the ticket type
        ticket_type: Option<String>,
        /// the provider for making the purchase {ITUNES, ITUNES_SANDBOX, GOOGLE}
        purchase_provider: Option<String>,
        /// a comma separated list of purchase types { SIRQUL, // purchasing from the sirqul store using tickets IOS, // purchasing from the itunes store for iPhone, iPod, iPod Touch GOOGLE, // purchasing from the google android store AMAZON, // purchasing from the amazon android store MAC, // purchasing from the itunes store for OSX WP8, // purhasing from the windows phone 8 store FREE }
        purchase_type: Option<String>,
        /// returns a ProfileResponse if true, otherwise will return an AppResponse
        #[clap(long)]
        return_profile_response: Option<bool>,
        /// if returnProfileResponse is false, will return an AppResponse with profile data if true
        #[clap(short, long)]
        include_profile_response: Option<bool>,
        /// the application version
        app_version: Option<String>,
    },
    /// Get Ticket Offers
    TicketOffers {
        version: f64,
    },
    /// Create Tournament
    CreateTournament {
        version: f64,
        /// The logged in user.
        account_id: i64,
        /// The appKey the tournament is created for.
        app_key: String,
        /// The title of the tournament
        title: String,
        /// The number of tickets required to pay to enter the tournament
        cost_to_play: i32,
        /// The date/time to start the tournament
        start_date: i64,
        /// Custom string client apps can use for searching/filtering tournaments
        sub_type: Option<String>,
        /// The asset ID to attach to the tournament
        image_asset_id: Option<i64>,
        /// The number of seconds in between the start of each tournament game/group
        seconds_between_levels: Option<i32>,
        /// The number of seconds to extend the round end time in the case of a tie breaker
        seconds_for_tie_breaker: Option<i32>,
        /// The number of seconds in between the start of each tournament round
        seconds_between_packs: Option<i32>,
        /// The maximum number of seconds the match is expected to end at, which gets used to determine when a match should end when there is no activity
        maximum_level_length: Option<i32>,
        /// The type of ticket required to pay
        cost_to_play_type: Option<String>,
        /// The minimum number of players required to sign up for the tournament to be played
        minimum_to_play: Option<i32>,
        /// The starting number of players for a tournament (filled with AI's)
        starting_limit: Option<i32>,
        /// The maximum number of players for a tournament (currently 128 but not enforced)
        available_limit: Option<i32>,
        /// The description of the tournament
        description: Option<String>,
        /// External custom client defined data
        meta_data: Option<String>,
        /// The audiences associated with the tournament
        audience_ids: Option<String>,
        /// Activate/deactivate the tournament
        #[clap(long)]
        active: Option<bool>,
        /// Determines whether to allow players to buy back into a tournament
        #[clap(long)]
        enable_buy_back: Option<bool>,
        /// The list of offers to give as a reward beyond the tickets
        offer_ids: Option<String>,
        /// The artwork ID to attach to the reward tickets offers
        offer_asset_id: Option<i64>,
        /// If set then do not update the ticket reward, auto set to true if offerIds provided
        #[clap(long)]
        fixed_reward: Option<bool>,
        /// Set the rules for handling the reward in case of a tie, values: EVEN split the reward evenly ALL everyone gets the full reward value FIRST first score submitted RANDOM random player who scored
        #[clap(value_parser = parse_json::<models::CreateTournamentSplitRewardParameter>)]
        split_reward: Option<models::CreateTournamentSplitRewardParameter>,
        /// Flag to indicate owner should receive tickets for completed missions
        #[clap(long)]
        allocate_tickets: Option<bool>,
        /// A text based string that will be passed into each tournament setup to populate the content
        tournament_data: Option<String>,
        /// The style of tournament to build, options are: TOURNAMENT, POOLPLAY
        #[clap(value_parser = parse_json::<models::CreateTournamentMissionTypeParameter>)]
        mission_type: Option<models::CreateTournamentMissionTypeParameter>,
        /// Sets the visibility flag for the tournament
        #[clap(value_parser = parse_json::<models::CreateTournamentVisibilityParameter>)]
        visibility: Option<models::CreateTournamentVisibilityParameter>,
        /// The number of initial preliminary groups in a multi-stage tournament (this is expected to be a power of two number)
        preliminary_groups: Option<i32>,
        /// This determines how many people can advance per round in a preliminary group (this is a comma separated list of integers)
        preliminary_group_advancements: Option<String>,
        /// This determines if multiple submissions/entries are allowed in a multi-stage album tournament
        #[clap(long)]
        enable_multiple_entries: Option<bool>,
        /// This determines if users are allowed to vote multiple times per group in a multi-stage album tournament
        #[clap(long)]
        enable_multiple_votes: Option<bool>,
        /// This determines whether the tournament is \"featured\" or not
        #[clap(long)]
        featured: Option<bool>,
        /// This sets what analytic tag is used when a winner is determined
        winner_tag: Option<String>,
        /// This sets what analytic tag is used when a tie has occurred
        tie_tag: Option<String>,
    },
    /// Delete Tournament
    DeleteTournament {
        version: f64,
        /// the id of the logged in user
        account_id: i64,
        /// the id of the mission to delete
        mission_id: i64,
    },
    /// Get Tournament
    GetTournament {
        version: f64,
        /// The id of the logged in user
        account_id: i64,
        /// The id of the mission to return (either missionId or joinCode is required)
        mission_id: Option<i64>,
        /// Optional identifier for getting the tournament (either missionId or joinCode is required)
        join_code: Option<String>,
        /// Determines which type of scores are returned. Possible values include: ALL, MINE
        #[clap(value_parser = parse_json::<models::GetTournamentIncludeScoresParameter>)]
        include_scores: Option<models::GetTournamentIncludeScoresParameter>,
        /// Determines the max number of game objects that will get returned for each game level response
        object_preview_size: Option<i32>,
    },
    /// Search Tournament Objects
    SearchObjects {
        version: f64,
        /// the account ID
        account_id: i64,
        /// the game level id to filter results by
        game_level_id: i64,
        /// the field to sort by
        #[clap(value_parser = parse_json::<models::SearchObjectsSortFieldParameter>)]
        sort_field: Option<models::SearchObjectsSortFieldParameter>,
        /// determines whether the sorted list is in descending or ascending order
        #[clap(short, long)]
        descending: Option<bool>,
        /// the start index for pagination
        start: Option<i32>,
        /// the limit for pagination
        limit: Option<i32>,
    },
    /// Search Tournament Rounds
    SearchRounds {
        version: f64,
        /// the account ID
        account_id: i64,
        /// the application key
        app_key: String,
        /// comma separated list of statuses to filter results by
        status: Option<String>,
        /// The style of tournament to search for, options are: TOURNAMENT, POOLPLAY
        #[clap(value_parser = parse_json::<models::SearchRoundsMissionTypeParameter>)]
        mission_type: Option<models::SearchRoundsMissionTypeParameter>,
        /// search for games that are flagged current only
        #[clap(short, long)]
        current_only: Option<bool>,
        /// Filter tournament rounds by the mission visibility flag
        visibilities: Option<String>,
        /// the start index for pagination
        start: Option<i32>,
        /// the limit for pagination
        limit: Option<i32>,
    },
    /// Search Tournaments
    SearchTournaments {
        version: f64,
        /// The logged in user.
        account_id: i64,
        /// The application key
        app_key: String,
        /// the keyword to search tournament on
        keyword: Option<String>,
        /// filter results by subType
        sub_type: Option<String>,
        /// whether to include inactives in the search or not
        #[clap(short, long)]
        include_inactive: Option<bool>,
        /// comma separated list of mission types to filter results, possbile values include: TOURNAMENT, POOLPLAY, MULTISTAGE
        mission_types: Option<String>,
        /// filter tournaments by the tournament's current state
        #[clap(value_parser = parse_json::<models::SearchTournamentsFilterParameter>)]
        filter: Option<models::SearchTournamentsFilterParameter>,
        /// which field to sort on
        #[clap(value_parser = parse_json::<models::SearchTournamentsSortFieldParameter>)]
        sort_field: Option<models::SearchTournamentsSortFieldParameter>,
        /// Determines whether to return results in descending order. The default value will be true if the filter is \"PAST\", otherwise the default value will be false.
        #[clap(short, long)]
        descending: Option<bool>,
        /// Comma separated list of visibility flags for search for, possible values include: PUBLIC, LISTABLE, REWARDABLE, TRIGGERABLE, PRIVATE
        visibility: Option<String>,
        /// Start the result set at some index.
        start: Option<i32>,
        /// Limit the result to some number
        limit: Option<i32>,
    },
    /// Submit Tournament Score
    SubmitTournamentScore {
        version: f64,
        /// The logged in user account ID.
        account_id: i64,
        /// The application key.
        app_key: String,
        /// The missionId to score for
        mission_id: i64,
        /// The gameId to score for
        game_id: i64,
        /// The packId to score for
        pack_id: i64,
        /// a JSON Array of scores to submit for a tournament match ```json [   {     \"accountId\": 2,     \"points\": 3   },   {     \"accountId\": 1777662,     \"points\": 7   } ] ``` 
        scores: String,
        /// The gameLevelId to score for
        game_level_id: Option<i64>,
    },
    /// Submit a vote for a multi-stage album tournament.
    SubmitTournamentVote {
        version: f64,
        /// The logged in user.
        account_id: i64,
        /// The application to target
        app_key: String,
        /// The tournament's primary id
        mission_id: i64,
        /// The tournament game object the user wants to vote on
        game_object_id: i64,
        /// The unique id of the device making the request (optional)
        device_id: Option<String>,
        /// When true, check if the device already voted to prevent duplicate votes from the same device
        #[clap(short, long)]
        check_if_device_already_voted: Option<bool>,
    },
    /// Substitute Tournament Player
    SubstituteTournamentPlayer {
        version: f64,
        /// the id of the logged in user
        account_id: i64,
        /// the id of the mission
        mission_id: i64,
        /// the id of the pack
        pack_id: i64,
        /// the id of the game level
        game_level_id: i64,
    },
    /// Update Tournament
    UpdateTournament {
        version: f64,
        /// The logged in user.
        account_id: i64,
        /// The mission/tournament to update
        mission_id: i64,
        /// The title of the tournament
        title: Option<String>,
        /// Custom string client apps can use for searching/filtering missions
        sub_type: Option<String>,
        /// The asset ID to attach to the tournament
        image_asset_id: Option<i64>,
        /// The number of seconds in between the start of each tournament game
        seconds_between_levels: Option<i32>,
        /// The number of seconds to extend the round end time in the case of a tie breaker
        seconds_for_tie_breaker: Option<i32>,
        /// The number of seconds in between the start of each tournament round
        seconds_between_packs: Option<i32>,
        /// The maximum number of seconds the match is expected to end at, which gets used to determine when a match should end when there is no activity
        maximum_level_length: Option<i32>,
        /// The number of tickets required to pay to enter the tournament
        cost_to_play: Option<i32>,
        /// The type of ticket required to pay
        cost_to_play_type: Option<String>,
        /// The minimum number of players required to sign up for the tournament to be played
        minimum_to_play: Option<i32>,
        /// The starting number of players for a tournament (filled with AI's)
        starting_limit: Option<i32>,
        /// The maximum number of players for a tournament (currently 128 but not enforced)
        available_limit: Option<i32>,
        /// The description of the tournament
        description: Option<String>,
        /// External custom client defined data
        meta_data: Option<String>,
        /// The date/time to start the tournament
        start_date: Option<i64>,
        /// The audiences associated with the tournament
        audience_ids: Option<String>,
        /// Activate/deactivate the mission
        #[clap(long)]
        active: Option<bool>,
        /// Determines whether to allow players to buy back into a tournament
        #[clap(long)]
        enable_buy_back: Option<bool>,
        /// The list of offers to give as a reward beyond the tickets
        offer_ids: Option<String>,
        /// The artwork ID to attach to the reward offer
        offer_asset_id: Option<i64>,
        /// If set then do not update the ticket reward, auto set to true if offerIds provided
        #[clap(long)]
        fixed_reward: Option<bool>,
        /// Set the rules for handling the reward in case of a tie, values: EVEN split the reward evenly ALL everyone gets the full reward value FIRST first score submitted RANDOM random player who scored
        #[clap(value_parser = parse_json::<models::UpdateTournamentSplitRewardParameter>)]
        split_reward: Option<models::UpdateTournamentSplitRewardParameter>,
        /// Flag to indicate owner should receive tickets for completed missions
        #[clap(long)]
        allocate_tickets: Option<bool>,
        /// A text based string that will be passed into each tournament setup to populate the content
        tournament_data: Option<String>,
        /// Sets the visibility flag for the tournament
        #[clap(value_parser = parse_json::<models::CreateMediaOfferVisibilityParameter>)]
        visibility: Option<models::CreateMediaOfferVisibilityParameter>,
        /// The number of initial preliminary groups in a multi-stage tournament (this is expected to be a power of two number)
        preliminary_groups: Option<i32>,
        /// This determines how many people can advance per round in a preliminary group (this is a comma separated list of integers)
        preliminary_group_advancements: Option<String>,
        /// This determines if multiple submissions/entries are allowed in a multi-stage album tournament
        #[clap(long)]
        enable_multiple_entries: Option<bool>,
        /// This determines if users are allowed to vote multiple times per group in a multi-stage album tournament
        #[clap(long)]
        enable_multiple_votes: Option<bool>,
        /// This determines whether the tournament is \"featured\" or not
        #[clap(long)]
        featured: Option<bool>,
        /// This sets what analytic tag is used when a winner is determined
        winner_tag: Option<String>,
        /// This sets what analytic tag is used when a winner is determined
        tie_tag: Option<String>,
    },
    /// Create Batch Tracking
    BatchSaveTracking {
        version: f64,
        /// JSON array of tracking legs ```json [   \"distance\": \"0.08\",   \"duration\": \"10000\",   \"startLatitude\": \"47.614603\",   \"startLongitude\": \"-122.350518\",   \"endLatitude\": \"47.614384\",   \"endLongitude\": \"-122.349161\",   \"startDate\": \"1361924010000\",   \"endDate\": \"1361924020000\",   \"steps\": [     {       \"distance\": \"0.03\",       \"duration\": \"5000\",       \"startLat\": \"47.614603\",       \"startLng\": \"-122.350518\",       \"startDate\": \"1361924010000\",       \"endLat\": \"47.614941\",       \"endLng\": \"-122.350062\",       \"endDate\": \"1361924015000\"     },{       \"distance\": \"0.05\",       \"duration\": \"5000\",       \"startLat\": \"47.614941\",       \"startLng\": \"-122.350062\",       \"startDate\": \"1361924015000\",       \"endLat\": \"47.614384\",       \"endLng\": \"-122.349161\",       \"endDate\": \"1361924020000\"     }   ] ] ``` 
        data: String,
        /// the device id (deviceId or accountId required)
        device_id: Option<String>,
        /// the account id of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// Whether to generate accounts for tracking entries when the owner does not exist
        #[clap(short, long)]
        generate_accounts: Option<bool>,
        /// Whether to update the account's current location from the incoming tracking data
        #[clap(short, long)]
        update_account_locations: Option<bool>,
        /// The default tag to apply to incoming legs when no tag is provided
        default_tag: Option<String>,
        /// 
        slave_uid: Option<String>,
    },
    /// Get Predicted Locations
    GetPredictedLocations {
        version: f64,
        /// The account id of the customer
        account_id: i64,
        /// latitude to return a more likely result set based on the user's current location
        latitude: Option<f64>,
        /// longitude to return a more likely result set based on the user's current location
        longitude: Option<f64>,
        /// Used to specify which day to get predicted locations for. So if you want to look at where they might be tomorrow, pass in tomorrow's date (timestamp in milliseconds). If no value is passed in, the current date will be used.
        date_check: Option<i64>,
        /// Comma separated list of hours that will filter the results on the hours specified. For example, if you want to see predicted locations for the mornings and evening you can pass in \"8,9,10,11,17,18,19,20\".
        hour_check: Option<String>,
        /// The minimum number matches in 1 hour to be considered a likely location.
        threshold: Option<i64>,
        /// Determines which unit of measurement gets returned for distances: {MILES, KILOMETERS}
        #[clap(value_parser = parse_json::<models::GetOfferListCountsDistanceUnitParameter>)]
        distance_unit: Option<models::GetOfferListCountsDistanceUnitParameter>,
        /// Filter results so only locations within the specified radius will be returned. The distance can either be in miles or kilometers as specified in the distanceUnit parameter. A value of \"0\" (zero) will ignore the radius restriction.
        search_range: Option<f64>,
        /// The ordering algorithm for sorting the returned results: {MATCHES, DISTANCE, WEIGHTED}
        #[clap(value_parser = parse_json::<models::GetPredictedLocationsSortOrderParameter>)]
        sort_order: Option<models::GetPredictedLocationsSortOrderParameter>,
    },
    /// Get Tracking Path
    GetPredictedPath {
        version: f64,
        /// The account id of the customer
        account_id: i64,
        /// The stepId to begin from
        start_step_id: i64,
        /// The stepId to end with
        end_step_id: i64,
    },
    /// Search Preferred Locations
    GetPreferredLocations {
        version: f64,
        /// The account id of the customer
        account_id: i64,
        /// latitude to return a more likely result set based on the user's current location
        latitude: Option<f64>,
        /// longitude to return a more likely result set based on the user's current location
        longitude: Option<f64>,
        /// Used to specify which day to get preferred locations for. So if you want to look at where they might be tomorrow, pass in tomorrow's date (timestamp in milliseconds). If no value is passed in, results from all time will be returned.
        date_check: Option<i64>,
        /// Comma separated list of hours that will filter the results on the hours specified. For example, if you want to see preferred locations for the mornings and evening you can pass in \"8,9,10,11,17,18,19,20\".
        hour_check: Option<String>,
        /// Specifies how the results will be ordered. Supported values include: CREATED - the time of when the preferred location data was processed. PREFERRED_DATE - the time of when the user sent in the tracking data. HOUR - the hour of when the user sent in the tracking data. DURATION - the duration of the preferred location
        sort_field: Option<String>,
        /// Determines whether the sorted list is in descending or ascending order
        #[clap(short, long)]
        descending: Option<bool>,
        /// The start index for pagination
        start: Option<i32>,
        /// The limit for pagination
        limit: Option<i32>,
        /// Filter results so only locations within the specified radius will be returned. The distance can either be in miles or kilometers as specified in the distanceUnit parameter. A value of \"0\" (zero) will ignore the radius restriction.
        search_range: Option<f64>,
        /// Determines which unit of measurement gets returned for distances: {MILES, KILOMETERS}
        #[clap(value_parser = parse_json::<models::GetOfferListCountsDistanceUnitParameter>)]
        distance_unit: Option<models::GetOfferListCountsDistanceUnitParameter>,
    },
    /// Search Tracking
    GetTrackingLegs {
        version: f64,
        /// the device id (deviceId or accountId required)
        device_id: Option<String>,
        /// the account id of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// the account id of the person the user wants to tracking data for
        owner_id: Option<i64>,
        /// the id of the tracking device
        tracking_device_id: Option<String>,
        /// the start date in (UTC milliseconds) to filter the tracking results. If no startDate is passed in, the last 30 days will be returned.
        start_date: Option<i64>,
        /// the end date in (UTC milliseconds) to filter the tracking results
        end_date: Option<i64>,
        /// filter results by tag
        tags: Option<String>,
        /// gets the last known location of the user
        #[clap(short, long)]
        get_last_point: Option<bool>,
    },
    /// Create Tracking Leg
    SaveTrackingLeg {
        version: f64,
        /// the latitude of the first point
        start_lat: f64,
        /// the longitude of the first point
        start_lng: f64,
        /// the start date (in UTC milliseconds) of the first point
        start_date: i64,
        /// the latitude of the last point
        end_lat: f64,
        /// the longitude of the last point
        end_lng: f64,
        /// the end date (in UTC milliseconds) of the last point
        end_date: i64,
        /// the device id (deviceId or accountId required)
        device_id: Option<String>,
        /// the account id of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// the total distance
        distance: Option<f64>,
        /// the total duration
        duration: Option<i64>,
        /// JSON array of tracking vectors used for smoother pathing data. If null then the leg data will be used to generate a single step, if an empty array then no steps will be generated. ```json [{   \"distance\": \"0.03\",   \"duration\": \"5000\",   \"startLat\": \"47.614603\",   \"startLng\": \"-122.350518\",   \"startDate\": \"1361924010000\",   \"endLat\": \"47.614941\",   \"endLng\": \"-122.350062\",   \"endDate\": \"1361924015000\" }] ``` 
        steps: Option<String>,
        /// name the leg for searching
        tags: Option<String>,
    },
    /// Create Tracking Step
    SaveTrackingStep {
        version: f64,
        /// the leg to add the step to
        leg_id: i64,
        /// the latitude of the first point
        start_lat: f64,
        /// the longitude of the first point
        start_lng: f64,
        /// the start date (in UTC milliseconds) of the first point
        start_date: i64,
        /// the latitude of the last point
        end_lat: f64,
        /// the longitude of the last point
        end_lng: f64,
        /// the end date (in UTC milliseconds) of the last point
        end_date: i64,
        /// the device id (deviceId or accountId required)
        device_id: Option<String>,
        /// the account id of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// the total distance
        distance: Option<f64>,
        /// the total duration
        duration: Option<i64>,
    },
    /// List Tracking
    SearchAccountsWithTrackingLegs {
        version: f64,
        /// The account id of the user
        account_id: i64,
        /// Used for LIKE search of first or last name on the acocunt
        keyword: Option<String>,
        /// Range to begin in UTC milliseconds
        start_date: Option<i64>,
        /// Range to end in UTC milliseconds
        end_date: Option<i64>,
        /// Exact match on tag field of Legs's searchTag
        tags: Option<String>,
        /// 
        audience_ids: Option<String>,
        /// Origin latitude to perform searching constraints with given range
        latitude: Option<f64>,
        /// Origin longitude to perform searching constraints with given range
        longitude: Option<f64>,
        /// The radius, in miles, to perform the search for
        range: Option<f64>,
        /// The column to sort the search on. Possible values include: {LEG_START_DATE, ACCOUNT_DISPLAY}
        sort_field: Option<String>,
        /// The order to return the results. Default is false, which will return the results in ascending order.
        #[clap(short, long)]
        descending: Option<bool>,
        /// The index into the record set to start with. Default is 0.
        start: Option<i32>,
        /// The total number of records to return. Default is 20.
        limit: Option<i32>,
        /// Determines whether to return only active results. Default is false.
        #[clap(long)]
        active_only: Option<bool>,
    },
    /// Search Tracking (Billable)
    SearchTrackingLegs {
        version: f64,
        /// The account id to search tracking for
        account_id: i64,
        /// The application key
        app_key: String,
        /// The id of the tracking device
        tracking_device_id: Option<String>,
        /// The start date in (UTC milliseconds) to filter the tracking results
        start_date: Option<i64>,
        /// The end date in (UTC milliseconds) to filter the tracking results
        end_date: Option<i64>,
        /// Filter results by tag
        tags: Option<String>,
        /// The start index for pagination
        start: Option<i32>,
        /// The limit for pagination
        limit: Option<i32>,
    },
    /// Create Trigger
    CreateTrigger {
        version: f64,
        /// The logged in user
        account_id: i64,
        /// The name of the trigger
        name: String,
        /// The application to target
        app_key: Option<String>,
        /// Client defined identifier for grouping triggers
        grouping_id: Option<String>,
        /// The URL for making an HTTP call
        endpoint_url: Option<String>,
        /// The parameters for making an HTTP call
        payload: Option<String>,
        /// The date and time of the next trigger
        scheduled_date: Option<i64>,
        /// The starting date of the trigger
        start_date: Option<i64>,
        /// The ending date of the trigger
        end_date: Option<i64>,
        /// The cron expression that represents the trigger's schedule
        cron_expression: Option<String>,
        /// Json input representing conditional logic that has to be met before running the trigger
        conditional_input: Option<String>,
        /// The determines the scope of who is able to find and view the scheduled notification (PUBLIC - openly available to all Sirqul users, PRIVATE - only available to users that have been invited)
        #[clap(value_parser = parse_json::<models::AddAlbumCollectionVisibilityParameter>)]
        visibility: Option<models::AddAlbumCollectionVisibilityParameter>,
        /// Sets whether the Trigger is active or not (inactive Triggers are not processed)
        #[clap(long)]
        active: Option<bool>,
    },
    /// Delete Trigger
    DeleteTrigger {
        version: f64,
        /// The logged in user.
        account_id: i64,
        /// The id of the trigger to delete.
        trigger_id: i64,
    },
    /// Get Trigger
    GetTrigger {
        version: f64,
        /// The logged in user.
        account_id: i64,
        /// The id of the Trigger to return.
        trigger_id: i64,
    },
    /// Search Triggers
    SearchTriggers {
        version: f64,
        /// The logged in user.
        account_id: i64,
        /// Filter results by a grouping identifier defined by the client
        grouping_id: Option<String>,
        /// A comma separated list of filters. * MINE - Return triggers that the user has created * SHARED - Return triggers that have been shared to the user * FOLLOWER - Return triggers that have been created by the user''s followers (the content needs to have been APPROVED or FEATURED) * FOLLOWING - Return triggers that have been created by people who the user is following (the content needs to have been APPROVED or FEATURED) * PUBLIC - Return all PUBLIC triggers that have been APPROVED or FEATURED * ALL_PUBLIC - Return all PUBLIC triggers regardless of whether they are approved or not (ignores the approval status) * LIKED - Return all triggers that the user has liked * FEATURED - Return all triggers that have been featured * PENDING - Return all pending triggers 
        filter: Option<String>,
        /// Filter results by status (comma separated list). Values include: NEW, ERROR, COMPLETE, PROCESSING, TEMPLATE
        statuses: Option<String>,
        /// Template Types
        template_types: Option<String>,
        /// Filter the list by a specific application
        app_key: Option<String>,
        /// Keyword search on the trigger names.
        keyword: Option<String>,
        /// The field to sort by. Possible values include: ID, CREATED, UPDATED, ACTIVE, NAME, SCHEDULED_DATE, START_DATE, END_DATE
        sort_field: Option<String>,
        /// Determines whether the sorted list is in descending or ascending order
        #[clap(short, long)]
        descending: Option<bool>,
        /// Start the result set at some index.
        start: Option<i32>,
        /// Limit the result to some number.
        limit: Option<i32>,
        /// Determines whether to return only active results
        #[clap(long)]
        active_only: Option<bool>,
    },
    /// Update Trigger
    UpdateTrigger {
        version: f64,
        /// The trigger to update
        trigger_id: i64,
        /// The logged in user
        account_id: i64,
        /// The name of the trigger
        name: Option<String>,
        /// The application to target
        app_key: Option<String>,
        /// Client defined identifier for grouping triggers
        grouping_id: Option<String>,
        /// The URL for making an HTTP call
        endpoint_url: Option<String>,
        /// The parameters for making an HTTP call
        payload: Option<String>,
        /// The date and time of the next trigger
        scheduled_date: Option<i64>,
        /// The starting date of the trigger
        start_date: Option<i64>,
        /// The ending date of the trigger
        end_date: Option<i64>,
        /// The cron expression that represents the trigger's schedule
        cron_expression: Option<String>,
        /// Json input representing conditional logic that has to be met before running the trigger
        conditional_input: Option<String>,
        /// The determines the scope of who is able to find and view the scheduled notification (PUBLIC - openly available to all Sirqul users, PRIVATE - only available to users that have been invited)
        #[clap(value_parser = parse_json::<models::AddAlbumCollectionVisibilityParameter>)]
        visibility: Option<models::AddAlbumCollectionVisibilityParameter>,
        /// Sets whether the Trigger is active or not (inactive Triggers are not processed)
        #[clap(long)]
        active: Option<bool>,
    },
    /// Create Trip
    CreateTrip {
        version: f64,
        #[clap(value_parser = parse_json::<models::Trip>)]
        body: Option<models::Trip>,
    },
    /// Process Trip Matches
    ProcessTripMatches {
        version: f64,
        /// The lower bound date to process matchings
        start_date: Option<i64>,
        /// The upper bound date to process matchings
        end_date: Option<i64>,
        /// the id of the trip to process
        trip_id: Option<i64>,
    },
    /// Search Trips
    Search {
        version: f64,
        /// The owner of the trips
        account_id: i64,
        /// The field to sort by
        sort_field: String,
        /// Determines whether the sorted list is in descending or ascending order
        #[clap(short, long)]
        descending: bool,
        /// The start index for pagination
        start: i32,
        /// The limit for pagination
        limit: i32,
        /// Return only active results
        #[clap(long)]
        active_only: bool,
        /// The lower bound limit of time
        start_date: Option<i64>,
        /// The upper bound limit of time
        end_date: Option<i64>,
        /// whether to search on trips that have notifications or not
        #[clap(short, long)]
        has_notifications: Option<bool>,
    },
    /// Search Trips
    SearchTrips {
        version: f64,
        /// The owner of the trips
        account_id: i64,
        /// The field to sort by
        sort_field: String,
        /// Determines whether the sorted list is in descending or ascending order
        #[clap(short, long)]
        descending: bool,
        /// The start index for pagination
        start: i32,
        /// The limit for pagination
        limit: i32,
        /// Return only active results
        #[clap(long)]
        active_only: bool,
        /// The lower bound limit of time
        start_date: Option<i64>,
        /// The upper bound limit of time
        end_date: Option<i64>,
        /// Only return matchings that already have route assigned
        #[clap(long)]
        matched_has_route: Option<bool>,
        /// Only return matchings that already have driver assigned
        #[clap(long)]
        matched_has_driver: Option<bool>,
    },
    /// Trip Notifications
    UpdateTripNotifications {
        version: f64,
        /// the id of the trip
        id: i64,
        /// the notifications to update on the trip
        notifications: Option<String>,
    },
    /// Delete Trip
    Delete {
        version: f64,
        /// the id of the trip to delete
        id: i64,
    },
    /// Set Trip Preference Driver
    DriveTrip {
        version: f64,
        /// the id of the trip
        id: i64,
        /// the frequency of the trip (e.g. weekly, until 2018-08-09)
        #[clap(short, long)]
        recurrence: bool,
    },
    /// Set Trip Preference Flexible
    FlexibleTrip {
        version: f64,
        /// the id of the trip
        id: i64,
        /// the frequency of the trip (e.g. weekly, until 2018-08-09)
        #[clap(short, long)]
        recurrence: bool,
    },
    /// Get Trip
    GetTrip {
        version: f64,
        /// the id of the trip to get
        id: i64,
    },
    /// Get Trip Matches
    GetTripMatches {
        version: f64,
        /// The id The id of the trip to search for matches for
        id: i64,
        /// The field to sort by
        sort_field: String,
        /// Determines whether the sorted list is in descending or ascending order
        #[clap(short, long)]
        descending: bool,
        /// The start index for pagination
        start: i32,
        /// The limit for pagination
        limit: i32,
        /// Return only active results
        #[clap(long)]
        active_only: bool,
        /// Only return matchings that already have route assigned
        #[clap(long)]
        matched_has_route: Option<bool>,
        /// Only return matchings that already have driver assigned
        #[clap(long)]
        matched_has_driver: Option<bool>,
    },
    /// Set Trip Preference Rider
    Ride {
        version: f64,
        /// the id of the trip
        id: i64,
        /// the frequency of the trip (e.g. weekly, until 2018-08-09)
        #[clap(short, long)]
        recurrence: bool,
    },
    /// Update Trip Locations
    UpdateLocations {
        version: f64,
        /// the id of the trip to update locations for
        id: i64,
        #[clap(value_parser = parse_json::<models::Trip>)]
        body: Option<models::Trip>,
    },
    /// Update Recurrence Locations
    UpdateRecurrenceLocations {
        version: f64,
        /// the id of the trip
        id: i64,
        #[clap(value_parser = parse_json::<models::Trip>)]
        body: Option<models::Trip>,
    },
    /// Update Recurrence Shipments
    UpdateRecurrenceShipments {
        version: f64,
        /// the id of the trip
        id: i64,
        #[clap(value_parser = parse_json::<models::Trip>)]
        body: Option<models::Trip>,
    },
    /// Update Trip Shipments
    UpdateShipments {
        version: f64,
        /// the id of the trip shipments to update
        id: i64,
        #[clap(value_parser = parse_json::<models::Trip>)]
        body: Option<models::Trip>,
    },
    /// Update Trip
    UpdateTrip {
        version: f64,
        /// the id of the trip to update
        id: i64,
        #[clap(value_parser = parse_json::<models::Trip>)]
        body: Option<models::Trip>,
    },
    /// Buy Offer by SMS
    SmsBuyOffer {
        version: f64,
        /// the application key
        app_key: String,
        /// the message of the text
        body: String,
        /// the sender of the sms
        from: String,
        /// the type of currency
        currency_type: String,
    },
    /// Authorize Twitter
    AuthorizeTwitter {
        version: f64,
        /// the application key
        app_key: String,
    },
    /// Login Twitter
    LoginTwitter {
        version: f64,
        /// The access token
        access_token: String,
        /// The secret access token
        access_token_secret: String,
        /// The application key
        app_key: String,
        /// a comma separated list of ProfileFilters for filtering the returned response data
        response_filters: String,
        /// The device id
        device_id: Option<String>,
        /// The current latitude of the user
        latitude: Option<f64>,
        /// The current longitude of the user
        longitude: Option<f64>,
    },
    /// Add User
    AddUsersToPermissionable {
        version: f64,
        /// the permissionable type of the object
        #[clap(value_parser = parse_json::<models::AddUsersToPermissionablePermissionableTypeParameter>)]
        permissionable_type: models::AddUsersToPermissionablePermissionableTypeParameter,
        /// the id of the permissionable object
        permissionable_id: i64,
        /// the device id (deviceId or accountId required)
        device_id: Option<String>,
        /// the account id of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// the read permission of the users/groups
        #[clap(short, long)]
        read: Option<bool>,
        /// the write permission of the users/groups
        #[clap(short, long)]
        write: Option<bool>,
        /// the delete permission of the users/groups
        #[clap(short, long)]
        delete: Option<bool>,
        /// the add permission of the users/groups
        #[clap(long)]
        add: Option<bool>,
        /// a comma separated list of connection ids (NOT the account ids)
        connection_ids: Option<String>,
        /// a comma separated list of account ids
        connection_account_ids: Option<String>,
        /// a comma separated list of connection group ids (these are groups made by the user)
        connection_group_ids: Option<String>,
        /// sets whether the added users are marked as pending (and will require the album admins to accept) - admins can set this to false (to accept)
        #[clap(short, long)]
        pending: Option<bool>,
        /// sets whether the added users will become admins or not
        #[clap(long)]
        admin: Option<bool>,
        /// flag to determine whether to include the built-in \"friends\" group
        #[clap(short, long)]
        include_friend_group: Option<bool>,
        /// the current latitude of the user
        latitude: Option<f64>,
        /// the current longitude of the user
        longitude: Option<f64>,
        /// comma separated list of audience ids. This is a feature only available to the permissionable's application owner (and its employees). This will add all users from these audiences to the permissionable object. Notifications will not be sent to users if this feature is used.
        audience_ids: Option<String>,
    },
    /// Approve Permissionable
    ApprovePermissionable {
        version: f64,
        /// The permissionable type of the object
        #[clap(value_parser = parse_json::<models::AddUsersToPermissionablePermissionableTypeParameter>)]
        permissionable_type: models::AddUsersToPermissionablePermissionableTypeParameter,
        /// The id of the permissionable object
        permissionable_id: i64,
        /// A unique ID given by the device (deviceId or accountId required)
        device_id: Option<String>,
        /// The account ID of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// The approval status to set {PENDING, REJECTED, APPROVED, FEATURED}
        #[clap(value_parser = parse_json::<models::ApprovePermissionableApprovalStatusParameter>)]
        approval_status: Option<models::ApprovePermissionableApprovalStatusParameter>,
    },
    /// Leave
    LeaveFromPermissionable {
        version: f64,
        /// the permissionable type PermissionableType
        permissionable_type: String,
        /// the id of the permissionable object
        permissionable_id: i64,
        /// the device id (deviceId or accountId required)
        device_id: Option<String>,
        /// the account id of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// the current latitude of the user
        latitude: Option<f64>,
        /// the current longitude of the user
        longitude: Option<f64>,
    },
    /// Remove User
    RemoveUsersFromPermissionable {
        version: f64,
        /// the permissionable type of the object
        #[clap(value_parser = parse_json::<models::AddUsersToPermissionablePermissionableTypeParameter>)]
        permissionable_type: models::AddUsersToPermissionablePermissionableTypeParameter,
        /// the id of the permissionable object
        permissionable_id: i64,
        /// the device id (deviceId or accountId required)
        device_id: Option<String>,
        /// the account id of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// a comma separated list of connection ids (NOT the account ids)
        connection_ids: Option<String>,
        /// a comma separated list of account ids
        connection_account_ids: Option<String>,
        /// a comma separated list of connection group ids (these are groups made by the user)
        connection_group_ids: Option<String>,
        /// flag to determine whether to remove the built-in \"friends\" group
        #[clap(short, long)]
        remove_friend_group: Option<bool>,
        /// the current latitude of the user
        latitude: Option<f64>,
        /// the current longitude of the user
        longitude: Option<f64>,
        /// comma separated list of audience ids. This will remove all users from these audiences from the permissionable object. Notifications will not be sent to users if this feature is used.
        audience_ids: Option<String>,
    },
    /// Search Permissionables
    SearchPermissionables {
        version: f64,
        /// A unique ID given by the device (deviceId or accountId required)
        device_id: Option<String>,
        /// The account ID of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// Filter results for a specific user account
        connection_account_id: Option<i64>,
        /// Comma separated list of account IDs to filter results with
        connection_account_ids: Option<String>,
        /// Filter user permissions by the permissionable object type
        #[clap(value_parser = parse_json::<models::AddUsersToPermissionablePermissionableTypeParameter>)]
        permissionable_type: Option<models::AddUsersToPermissionablePermissionableTypeParameter>,
        /// The id of the permissionable object to filter by
        permissionable_id: Option<i64>,
        /// Keyword to search within permissionable records
        keyword: Option<String>,
        /// Field to sort results on
        sort_field: Option<String>,
        /// Sort descending when true
        #[clap(short, long)]
        descending: Option<bool>,
        /// Return user permissions that are pending
        #[clap(short, long)]
        pending: Option<bool>,
        /// Return user permissions that are admins
        #[clap(long)]
        admin: Option<bool>,
        /// the start index for pagination
        start: Option<i32>,
        /// the limit for pagination
        limit: Option<i32>,
    },
    /// Search Permissionables by Distnace
    SearchPermissionablesFollowingDistance {
        version: f64,
        /// The latitude of the current account
        latitude: f64,
        /// The longitude of the current account
        longitude: f64,
        /// A unique ID given by the device (deviceId or accountId required)
        device_id: Option<String>,
        /// The account ID of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// Filter results for a specific user account
        connection_account_id: Option<i64>,
        /// Comma separated list of account IDs to filter results with
        connection_account_ids: Option<String>,
        /// Filter user permissions by the permissionable object type
        #[clap(value_parser = parse_json::<models::AddUsersToPermissionablePermissionableTypeParameter>)]
        permissionable_type: Option<models::AddUsersToPermissionablePermissionableTypeParameter>,
        /// The id of the permissionable object to filter by
        permissionable_id: Option<i64>,
        /// The search range in miles
        search_range: Option<f64>,
        /// Keyword to search within permissionable records
        keyword: Option<String>,
        /// Return user permissions that are pending
        #[clap(short, long)]
        pending: Option<bool>,
        /// Return user permissions that are admins
        #[clap(long)]
        admin: Option<bool>,
        /// The start index for pagination
        start: Option<i32>,
        /// The limit for pagination
        limit: Option<i32>,
    },
    /// Create following
    CreateFollowing {
        version: f64,
        /// Sirqul Account Id
        account_id: i64,
        /// Vatom Parameters
        vatom_parameters: String,
        /// Return raw response
        #[clap(short, long)]
        return_raw_response: Option<bool>,
    },
    /// Create Vatom Space
    CreateSpace {
        version: f64,
        /// Sirqul Account Id
        account_id: i64,
        /// Sirqul Application Key
        app_key: String,
        /// Vatom Parameters
        vatom_parameters: String,
        /// Return raw response
        #[clap(short, long)]
        return_raw_response: Option<bool>,
    },
    /// Create Vatom Event
    CreateVatomEvent {
        version: f64,
        /// Sirqul Account Id
        account_id: i64,
        /// Sirqul Application Key
        app_key: String,
        /// Vatom Parameters
        vatom_parameters: String,
        /// Return raw response
        #[clap(short, long)]
        return_raw_response: Option<bool>,
    },
    /// Delete following
    DeleteFollowing {
        version: f64,
        /// Sirqul Account Id
        account_id: i64,
        /// Vatom Rels Key
        vatom_rels_key: String,
        /// Return raw response
        #[clap(short, long)]
        return_raw_response: Option<bool>,
    },
    /// Reset All Points Balance
    DeletePointsBalance {
        version: f64,
        /// Sirqul Account Id
        account_id: i64,
        /// Sirqul Application Key
        app_key: String,
        /// Vatom Campaign Id
        vatom_campaign_id: String,
        /// Return raw response
        #[clap(short, long)]
        return_raw_response: Option<bool>,
    },
    /// Delete Vatom Space
    DeleteSpace {
        version: f64,
        /// Sirqul Account Id
        account_id: i64,
        /// Sirqul Application Key
        app_key: String,
        /// Vatom Space Id
        vatom_space_id: String,
        /// Return raw response
        #[clap(short, long)]
        return_raw_response: Option<bool>,
    },
    /// Delete Vatom Event
    DeleteVatomEvent {
        version: f64,
        /// Sirqul Account Id
        account_id: i64,
        /// Sirqul Application Key
        app_key: String,
        /// Vatom Event Id
        vatom_event_id: String,
        /// Return raw response
        #[clap(short, long)]
        return_raw_response: Option<bool>,
    },
    /// Delete Vatom NFT
    DeleteVatomNft {
        version: f64,
        /// Sirqul Account Id
        account_id: i64,
        /// Vatom NFT Id
        vatom_id: String,
        /// Return raw response
        #[clap(short, long)]
        return_raw_response: Option<bool>,
    },
    /// Execute Action on NFT
    ExecuteActionOnNft {
        version: f64,
        /// Sirqul Account Id
        account_id: i64,
        /// Vatom NFT Id
        vatom_id: String,
        /// Vatom Parameters
        vatom_parameters: String,
        /// Return raw response
        #[clap(short, long)]
        return_raw_response: Option<bool>,
    },
    /// Search Vatom Geo Map
    GeomapSearch {
        version: f64,
        /// Sirqul Account Id
        account_id: i64,
        /// Vatom Parameters
        vatom_parameters: String,
        /// Return raw response
        #[clap(short, long)]
        return_raw_response: Option<bool>,
    },
    /// Get Vatom Business Behaviors
    GetBusinessBehaviors {
        version: f64,
        /// Sirqul Account Id
        account_id: i64,
        /// Sirqul Application Key
        app_key: String,
        /// Return raw response
        #[clap(short, long)]
        return_raw_response: Option<bool>,
    },
    /// Get the coins for a Business
    GetBusinessCoinsBalance {
        version: f64,
        /// Sirqul Account Id
        account_id: i64,
        /// Sirqul Application Key
        app_key: String,
        /// Return raw response
        #[clap(short, long)]
        return_raw_response: Option<bool>,
    },
    /// Get the user business ids
    GetBusinessIds {
        version: f64,
        /// Sirqul Account Id
        account_id: i64,
        /// Return raw response
        #[clap(short, long)]
        return_raw_response: Option<bool>,
    },
    /// Get Vatom Business Info
    GetBusinessInfo {
        version: f64,
        /// Sirqul Account Id
        account_id: i64,
        /// Sirqul Application Key
        app_key: String,
        /// Vatom Parameters
        vatom_parameters: Option<String>,
        /// Return raw response
        #[clap(short, long)]
        return_raw_response: Option<bool>,
    },
    /// Get Vatom Business Users
    GetBusinessUsers {
        version: f64,
        /// Sirqul Account Id
        account_id: i64,
        /// Sirqul Application Key
        app_key: String,
        /// Return raw response
        #[clap(short, long)]
        return_raw_response: Option<bool>,
    },
    /// Get Campaign Group Entities
    GetCampaignGroupEntities {
        version: f64,
        /// Sirqul Account Id
        account_id: i64,
        /// Sirqul Application Key
        app_key: String,
        /// Vatom Campaign Id
        vatom_campaign_id: String,
        /// Return raw response
        #[clap(short, long)]
        return_raw_response: Option<bool>,
    },
    /// Get Campaign Group Rules
    GetCampaignGroupRules {
        version: f64,
        /// Sirqul Account Id
        account_id: i64,
        /// Sirqul Application Key
        app_key: String,
        /// Vatom Campaign Id
        vatom_campaign_id: String,
        /// Return raw response
        #[clap(short, long)]
        return_raw_response: Option<bool>,
    },
    /// Get Campaign Group Stats
    GetCampaignGroupStats {
        version: f64,
        /// Sirqul Account Id
        account_id: i64,
        /// Sirqul Application Key
        app_key: String,
        /// Vatom Campaign Id
        vatom_campaign_id: String,
        /// Return raw response
        #[clap(short, long)]
        return_raw_response: Option<bool>,
    },
    /// Get Campaign Info
    GetCampaignInfo {
        version: f64,
        /// Sirqul Account Id
        account_id: i64,
        /// Sirqul Application Key
        app_key: String,
        /// Vatom Campaign Id
        vatom_campaign_id: String,
        /// Return raw response
        #[clap(short, long)]
        return_raw_response: Option<bool>,
    },
    /// Get Vatom Event Guest List
    GetEventGuestList {
        version: f64,
        /// Sirqul Account Id
        account_id: i64,
        /// Sirqul Application Key
        app_key: String,
        /// Vatom Event Id
        vatom_event_id: String,
        /// Return raw response
        #[clap(short, long)]
        return_raw_response: Option<bool>,
    },
    /// Get Vatom User's Inventory
    GetInventory {
        version: f64,
        /// Sirqul Account Id
        account_id: i64,
        /// Vatom Parameters
        vatom_parameters: String,
        /// Return raw response
        #[clap(short, long)]
        return_raw_response: Option<bool>,
    },
    /// Get following
    GetMyFollowing {
        version: f64,
        /// Sirqul Account Id
        account_id: i64,
        /// Return raw response
        #[clap(short, long)]
        return_raw_response: Option<bool>,
    },
    /// Get Points Balance
    GetPointsBalance {
        version: f64,
        /// Sirqul Account Id
        account_id: i64,
        /// Vatom User Id
        vatom_user_id: String,
        /// Vatom Campaign Id
        vatom_campaign_id: String,
        /// Return raw response
        #[clap(short, long)]
        return_raw_response: Option<bool>,
    },
    /// Get Points Balance as Business
    GetPointsBalanceAsBusiness {
        version: f64,
        /// Sirqul Account Id
        account_id: i64,
        /// Sirqul Application Key
        app_key: String,
        /// Vatom User Id
        vatom_user_id: String,
        /// Vatom Campaign Id
        vatom_campaign_id: String,
        /// Return raw response
        #[clap(short, long)]
        return_raw_response: Option<bool>,
    },
    /// Get Vatom Space
    GetSpace {
        version: f64,
        /// Sirqul Account Id
        account_id: i64,
        /// Sirqul Application Key
        app_key: String,
        /// Vatom Space Id
        vatom_space_id: String,
        /// Return raw response
        #[clap(short, long)]
        return_raw_response: Option<bool>,
    },
    /// Get the coins for a user (as a Business)
    GetUserCoinsAsBusiness {
        version: f64,
        /// Sirqul Account Id
        account_id: i64,
        /// Vatom User Id
        vatom_user_id: String,
        /// Sirqul Application Key
        app_key: String,
        /// Return raw response
        #[clap(short, long)]
        return_raw_response: Option<bool>,
    },
    /// Gets the coins balance for a Vatom User
    GetUserCoinsBalance {
        version: f64,
        /// Sirqul Account Id
        account_id: i64,
        /// Vatom User Id
        vatom_user_id: String,
        /// Vatom Parameters
        vatom_parameters: Option<String>,
        /// Return raw response
        #[clap(short, long)]
        return_raw_response: Option<bool>,
    },
    /// Get user followers
    GetUserFollowers {
        version: f64,
        /// Sirqul Account Id
        account_id: i64,
        /// Vatom User Id
        vatom_user_id: String,
        /// Return raw response
        #[clap(short, long)]
        return_raw_response: Option<bool>,
    },
    /// Get user following
    GetUserFollowing {
        version: f64,
        /// Sirqul Account Id
        account_id: i64,
        /// Vatom User Id
        vatom_user_id: String,
        /// Return raw response
        #[clap(short, long)]
        return_raw_response: Option<bool>,
    },
    /// Get User Info
    GetUserInfo {
        version: f64,
        /// Sirqul Account Id
        account_id: i64,
        /// Vatom User Id
        vatom_user_id: String,
        /// Return raw response
        #[clap(short, long)]
        return_raw_response: Option<bool>,
    },
    /// Get Vatom User Profile
    GetUserProfile {
        version: f64,
        /// Sirqul Account Id
        account_id: i64,
        /// Return raw response
        #[clap(short, long)]
        return_raw_response: Option<bool>,
    },
    /// Get Vatom Event
    GetVatomEvent {
        version: f64,
        /// Sirqul Account Id
        account_id: i64,
        /// Sirqul Application Key
        app_key: String,
        /// Vatom Event Id
        vatom_event_id: String,
        /// Return raw response
        #[clap(short, long)]
        return_raw_response: Option<bool>,
    },
    /// Get Vatom NFT Details
    GetVatomNft {
        version: f64,
        /// Sirqul Account Id
        account_id: i64,
        /// Vatom NFT Id
        vatom_id: String,
        /// Return raw response
        #[clap(short, long)]
        return_raw_response: Option<bool>,
    },
    /// List Vatom Communities
    ListCommunities {
        version: f64,
        /// Sirqul Account Id
        account_id: i64,
        /// Sirqul Application Key
        app_key: String,
        /// Vatom Parameters
        vatom_parameters: Option<String>,
        /// Return raw response
        #[clap(short, long)]
        return_raw_response: Option<bool>,
    },
    /// List Vatom Events
    ListEvents {
        version: f64,
        /// Sirqul Account Id
        account_id: i64,
        /// Sirqul Application Key
        app_key: String,
        /// Vatom Parameters
        vatom_parameters: Option<String>,
        /// Return raw response
        #[clap(short, long)]
        return_raw_response: Option<bool>,
    },
    /// List Vatom Spaces
    ListSpaces {
        version: f64,
        /// Sirqul Account Id
        account_id: i64,
        /// Sirqul Application Key
        app_key: String,
        /// Vatom Parameters
        vatom_parameters: Option<String>,
        /// Return raw response
        #[clap(short, long)]
        return_raw_response: Option<bool>,
    },
    /// List Coin Transactions for a Vatom User
    ListUserCoinTransactions {
        version: f64,
        /// Sirqul Account Id
        account_id: i64,
        /// Vatom User Id
        vatom_user_id: String,
        /// Vatom Parameters
        vatom_parameters: Option<String>,
        /// Return raw response
        #[clap(short, long)]
        return_raw_response: Option<bool>,
    },
    /// List coin transactions for a user (as a Business)
    ListUserCoinTransactionsAsBusiness {
        version: f64,
        /// Sirqul Account Id
        account_id: i64,
        /// Vatom User Id
        vatom_user_id: String,
        /// Sirqul Application Key
        app_key: String,
        /// Vatom Parameters
        vatom_parameters: Option<String>,
        /// Return raw response
        #[clap(short, long)]
        return_raw_response: Option<bool>,
    },
    /// Perform Action on NFT
    PerformActionOnNft {
        version: f64,
        /// Sirqul Account Id
        account_id: i64,
        /// Vatom NFT Id
        vatom_id: String,
        /// Vatom Action
        vatom_action: String,
        /// Vatom Parameters
        vatom_parameters: String,
        /// Return raw response
        #[clap(short, long)]
        return_raw_response: Option<bool>,
    },
    /// Redeem NFT
    RedeemNft {
        version: f64,
        /// Sirqul Account Id
        account_id: i64,
        /// Sirqul Application Key
        app_key: String,
        /// Vatom Parameters
        vatom_parameters: String,
        /// Return raw response
        #[clap(short, long)]
        return_raw_response: Option<bool>,
    },
    /// Redeem the coins for a user (as a Business)
    RedeemUserCoinsAsBusiness {
        version: f64,
        /// Sirqul Account Id
        account_id: i64,
        /// Vatom User Id
        vatom_user_id: String,
        /// Sirqul Application Key
        app_key: String,
        /// Vatom Parameters
        vatom_parameters: String,
        /// Return raw response
        #[clap(short, long)]
        return_raw_response: Option<bool>,
    },
    /// Search for Vatom Businesses
    SearchBusinesses {
        version: f64,
        /// Sirqul Account Id
        account_id: i64,
        /// Vatom Parameters
        vatom_parameters: Option<String>,
        /// Return raw response
        #[clap(short, long)]
        return_raw_response: Option<bool>,
    },
    /// Search Campaign Groups
    SearchCampaignGroups {
        version: f64,
        /// Sirqul Account Id
        account_id: i64,
        /// Sirqul Application Key
        app_key: String,
        /// Return raw response
        #[clap(short, long)]
        return_raw_response: Option<bool>,
    },
    /// Search User Identities
    SearchIdentities {
        version: f64,
        /// Sirqul Account Id
        account_id: i64,
        /// Return raw response
        #[clap(short, long)]
        return_raw_response: Option<bool>,
    },
    /// Search Vatom User's Inventory
    SearchInventory {
        version: f64,
        /// Sirqul Account Id
        account_id: i64,
        /// Vatom Parameters
        vatom_parameters: Option<String>,
        /// Return raw response
        #[clap(short, long)]
        return_raw_response: Option<bool>,
    },
    /// Send NFT
    SendNft {
        version: f64,
        /// Sirqul Account Id
        account_id: i64,
        /// Sirqul Application Key
        app_key: String,
        /// Vatom Campaign Id
        vatom_campaign_id: String,
        /// Vatom Parameters
        vatom_parameters: String,
        /// Return raw response
        #[clap(short, long)]
        return_raw_response: Option<bool>,
    },
    /// Set Points Balance as Business
    SetPointsBalanceAsBusiness {
        version: f64,
        /// Sirqul Account Id
        account_id: i64,
        /// Sirqul Application Key
        app_key: String,
        /// Vatom User Id
        vatom_user_id: String,
        /// Vatom Campaign Id
        vatom_campaign_id: String,
        /// Vatom Parameters
        vatom_parameters: String,
        /// Return raw response
        #[clap(short, long)]
        return_raw_response: Option<bool>,
    },
    /// Transfer coins from Vatom Users
    TransferUserCoins {
        version: f64,
        /// Sirqul Account Id
        account_id: i64,
        /// Vatom User Id
        vatom_user_id: String,
        /// Vatom Parameters
        vatom_parameters: String,
        /// Return raw response
        #[clap(short, long)]
        return_raw_response: Option<bool>,
    },
    /// Fund coins for a Business
    UpdateBusinessCoins {
        version: f64,
        /// Sirqul Account Id
        account_id: i64,
        /// Sirqul Application Key
        app_key: String,
        /// Vatom Parameters
        vatom_parameters: String,
        /// Return raw response
        #[clap(short, long)]
        return_raw_response: Option<bool>,
    },
    /// Update Vatom Event Guest List
    UpdateEventGuestList {
        version: f64,
        /// Sirqul Account Id
        account_id: i64,
        /// Sirqul Application Key
        app_key: String,
        /// Vatom Event Id
        vatom_event_id: String,
        /// Vatom Parameters
        vatom_parameters: String,
        /// Return raw response
        #[clap(short, long)]
        return_raw_response: Option<bool>,
    },
    /// Update Vatom Space
    UpdateSpace {
        version: f64,
        /// Sirqul Account Id
        account_id: i64,
        /// Sirqul Application Key
        app_key: String,
        /// Vatom Space Id
        vatom_space_id: String,
        /// Vatom Parameters
        vatom_parameters: String,
        /// Return raw response
        #[clap(short, long)]
        return_raw_response: Option<bool>,
    },
    /// Update the coins for a user (as a Business)
    UpdateUserCoinsAsBusiness {
        version: f64,
        /// Sirqul Account Id
        account_id: i64,
        /// Vatom User Id
        vatom_user_id: String,
        /// Sirqul Application Key
        app_key: String,
        /// Vatom Parameters
        vatom_parameters: String,
        /// Return raw response
        #[clap(short, long)]
        return_raw_response: Option<bool>,
    },
    /// Update Vatom User Profile
    UpdateUserProfile {
        version: f64,
        /// Sirqul Account Id
        account_id: i64,
        /// Vatom Parameters
        vatom_parameters: String,
        /// Return raw response
        #[clap(short, long)]
        return_raw_response: Option<bool>,
    },
    /// Update Vatom Event
    UpdateVatomEvent {
        version: f64,
        /// Sirqul Account Id
        account_id: i64,
        /// Sirqul Application Key
        app_key: String,
        /// Vatom Event Id
        vatom_event_id: String,
        /// Vatom Parameters
        vatom_parameters: String,
        /// Return raw response
        #[clap(short, long)]
        return_raw_response: Option<bool>,
    },
    /// Create Vehicle
    CreateVehicle {
        version: f64,
        /// A JSON representation of cargo type. ```json {   \"name\": \"Truck\",   \"vehicleType\": { \"id\": 1 },   \"hub\": { \"id\": 1 } } ``` 
        vehicle: String,
        #[clap(value_parser = parse_json::<models::Vehicle>)]
        body: Option<models::Vehicle>,
    },
    /// Search Vehicle
    SearchVehicle {
        version: f64,
        /// Filter by service hub
        hub_id: i64,
        /// The field to sort by
        sort_field: String,
        /// Determines whether the sorted list is in descending or ascending order
        #[clap(short, long)]
        descending: bool,
        /// The start index for pagination
        start: i32,
        /// The limit for pagination
        limit: i32,
        /// Return only active results
        #[clap(long)]
        active_only: bool,
        /// The keyword to search for
        keyword: Option<String>,
    },
    /// Delete Vehicle
    DeleteVehicle {
        version: f64,
        /// The id of the vehicle to delete
        id: i64,
    },
    /// Get Vehicle
    GetVehicle {
        version: f64,
        /// The id of the vehicle requested
        id: i64,
    },
    /// Update Vehicle
    UpdateVehicle {
        version: f64,
        /// The id of the vehicle to update
        id: i64,
        /// A JSON representation of cargo type, for example: ```json {   \"name\": \"Truck\",   \"vehicleType\": { \"id\": 1 },   \"hub\": { \"id\": 1 } } ``` 
        vehicle: String,
        #[clap(value_parser = parse_json::<models::Vehicle>)]
        body: Option<models::Vehicle>,
    },
    /// Create Vehicle Type
    CreateVehicleType {
        version: f64,
        /// A JSON representation of cargo type. ```json {   \"name\": \"Truck\",   \"width\": 100,   \"height\": 200,   \"depth\": 200,   \"maxWeight\": 5000,   \"hub\": { \"id\": 1 } } ``` 
        vehicle_type: String,
        #[clap(value_parser = parse_json::<models::VehicleType>)]
        body: Option<models::VehicleType>,
    },
    /// Search Vehicle Type
    SearchVehicleTypes {
        version: f64,
        /// The field to sort by
        sort_field: String,
        /// Determines whether the sorted list is in descending or ascending order
        #[clap(short, long)]
        descending: bool,
        /// The start index for pagination
        start: i32,
        /// The limit for pagination
        limit: i32,
        /// Return only active results
        #[clap(long)]
        active_only: bool,
        /// Filter by retailer
        retailer_id: Option<i64>,
        /// Filter by service hub
        hub_id: Option<i64>,
    },
    /// Delete Vehicle Type
    DeleteVehicleType {
        version: f64,
        /// The id of the requested vehicle type
        vehicle_type_id: i64,
    },
    /// Get Vehicle Type
    GetVehicleType {
        version: f64,
        /// The id of the requested vehicle type
        vehicle_type_id: i64,
    },
    /// Update Vehicle Type
    UpdateVehicleType {
        version: f64,
        /// The id of the vehicle type to update
        vehicle_type_id: i64,
        /// The new data for the vehicle type to update to. A JSON representation of cargo type, for example: ```json {   \"name\": \"Truck\",   \"width\": 100,   \"height\": 200,   \"depth\": 200,   \"maxWeight\": 5000,   \"hub\": { \"id\": 1 } } ``` 
        vehicle_type: String,
        #[clap(value_parser = parse_json::<models::VehicleType>)]
        body: Option<models::VehicleType>,
    },
    /// Create Wallet Offers
    CreateOfferTransaction {
        version: f64,
        /// The device id (deviceId or accountId required)
        device_id: Option<String>,
        /// The account id of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// The id of the offer being added (offerId or offeLocationId required)
        offer_id: Option<i64>,
        /// The id of the offer location being added (offerId or offeLocationId required)
        offer_location_id: Option<i64>,
        /// A JSON list of offers to purchase. ```json [   {     \"offerId\": 123,     \"offerLocationId\": 234,     \"quantity\": 2   },   {     \"offerId\": 456,     \"offerLocationId\": 567,     \"quantity\": 1   } ] ``` 
        offer_cart: Option<String>,
        /// The promoCode
        promo_code: Option<String>,
        /// Determines the method of purchasing offer. CASH = use card on file, POINTS = use points, TICKETS = use tickets
        currency_type: Option<String>,
        /// Sets the currencyType to POINTS
        #[clap(short, long)]
        use_points: Option<bool>,
        /// External custom client defined data
        meta_data: Option<String>,
        /// The application requesting the purchase, required when currencyType is TICKETS
        app_key: Option<String>,
        /// Custom status value to change to (0 or 1 for redeem, 5 or 6 for membership)
        status: Option<i32>,
    },
    /// Delete Wallet Offer
    DeleteOfferTransaction {
        version: f64,
        /// The offer transaction id to remove
        transaction_id: i64,
        /// The device id (deviceId or accountId required)
        device_id: Option<String>,
        /// The account id of the user (deviceId or accountId required)
        account_id: Option<i64>,
    },
    /// Get Wallet Offer
    GetOfferTransaction {
        version: f64,
        /// The offer transaction id to get details of
        transaction_id: i64,
        /// The device id (deviceId or accountId required)
        device_id: Option<String>,
        /// The account id of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// If true then include mission data, false to not include
        #[clap(short, long)]
        include_mission: Option<bool>,
        /// The latitude location of the user
        latitude: Option<f64>,
        /// The latitude location of the user
        longitude: Option<f64>,
        /// Determines whether to return a detailed version of the response
        #[clap(short, long)]
        return_full_response: Option<bool>,
    },
    /// Preview Wallet Offers
    PreviewOfferTransaction {
        version: f64,
        /// The device id (deviceId or accountId required)
        device_id: Option<String>,
        /// The account id of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// The id of the offer being added (offerId or offeLocationId required)
        offer_id: Option<i64>,
        /// The id of the offer location being added (offerId or offeLocationId required)
        offer_location_id: Option<i64>,
        /// A JSON list of offers to purchase.
        offer_cart: Option<String>,
        /// The promoCode
        promo_code: Option<String>,
        /// Determines the method of purchasing offer. CASH = use card on file, POINTS = use points, TICKETS = use tickets
        currency_type: Option<String>,
        /// Sets the currencyType to POINTS
        #[clap(short, long)]
        use_points: Option<bool>,
        /// External custom client defined data
        meta_data: Option<String>,
        /// The application requesting the purchase, required when currencyType is TICKETS
        app_key: Option<String>,
    },
    /// Search Wallet Offers
    SearchOfferTransactions {
        version: f64,
        /// The device id (deviceId or accountId required)
        device_id: Option<String>,
        /// The account id of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// The keyword to search for
        keyword: Option<String>,
        /// Filter results for this retailer
        retailer_id: Option<i64>,
        /// Filter results for a list of retailers
        retailer_ids: Option<String>,
        /// Filter results for this retailer location
        retailer_location_id: Option<i64>,
        /// Filter results for a list of retailer locations
        retailer_location_ids: Option<String>,
        /// Filter results to exclude retailer locations
        exclude_retailer_location_ids: Option<String>,
        /// Filter results for this offer
        offer_id: Option<i64>,
        /// Filter results for a list of offer
        offer_ids: Option<String>,
        /// Filter results for this offer location
        offer_location_id: Option<i64>,
        /// Filter results for a list of offer locations
        offer_location_ids: Option<String>,
        /// Filter results to return a specific offer type
        #[clap(value_parser = parse_json::<models::CreateOfferOfferTypeParameter>)]
        offer_type: Option<models::CreateOfferOfferTypeParameter>,
        /// Filter results to return specific offer types
        offer_types: Option<String>,
        /// Filter results to return a specific special offer type
        special_offer_type: Option<String>,
        /// Filter results to return specific special offer types
        special_offer_types: Option<String>,
        /// Category Ids
        category_ids: Option<String>,
        /// Filter Ids
        filter_ids: Option<String>,
        /// Offer Audience Ids
        offer_audience_ids: Option<String>,
        /// Determines what to sort the results by
        #[clap(value_parser = parse_json::<models::SearchOfferTransactionsSortFieldParameter>)]
        sort_field: Option<models::SearchOfferTransactionsSortFieldParameter>,
        /// Determines whether the results are in descending order
        #[clap(short, long)]
        descending: Option<bool>,
        /// The start index for pagination
        start: Option<i32>,
        /// The limit for pagination
        limit: Option<i32>,
        /// The latitude location of the user
        latitude: Option<f64>,
        /// The latitude location of the user
        longitude: Option<f64>,
        /// Filter results by the offer redeemable date
        redeemable_start_date: Option<i64>,
        /// Filter results by the offer redeemable date
        redeemable_end_date: Option<i64>,
        /// Apply params to offer's parent
        #[clap(long)]
        filter_by_parent_offer: Option<bool>,
        /// Filter results by the offer start date
        started_since: Option<i64>,
        /// Filter results by the offer start date
        started_before: Option<i64>,
        /// Filter results by the offer end date
        ended_since: Option<i64>,
        /// Filter results by the offer end date
        ended_before: Option<i64>,
        /// If true return redeemed transactions (status 2), otherwise return active transactions (status 0 or 1)
        #[clap(long)]
        redeemed: Option<bool>,
        /// Custom status value to change to (0 or 1 for redeem, 5 or 6 for membership)
        statuses: Option<String>,
        /// Returns only reservation transactions if true
        #[clap(long)]
        reservations_only: Option<bool>,
        /// Active Only
        #[clap(long)]
        active_only: Option<bool>,
        /// Determines whether to return a detailed version of the response
        #[clap(long)]
        return_full_response: Option<bool>,
        /// Filter results by the recurring billing start date
        recurring_started_since: Option<i64>,
        /// Filter results by the recurring billing start date
        recurring_started_before: Option<i64>,
        /// Filter results by the recurring billing expiration date
        recurring_expiration_since: Option<i64>,
        /// Filter results by the recurring billing expiration date
        recurring_expiration_before: Option<i64>,
    },
    /// Update Wallet Offer
    UpdateOfferTransaction {
        version: f64,
        /// The offer transaction id to remove
        transaction_id: i64,
        /// The status value to change to (0 or 1)
        status: i32,
        /// The device id (deviceId or accountId required)
        device_id: Option<String>,
        /// The account id of the user (deviceId or accountId required)
        account_id: Option<i64>,
        /// Offer Location Id
        offer_location_id: Option<i64>,
        /// Currency Type
        currency_type: Option<String>,
        /// Use Points
        #[clap(short, long)]
        use_points: Option<bool>,
        /// App Key
        app_key: Option<String>,
        /// The latitude location of the user
        latitude: Option<f64>,
        /// The latitude location of the user
        longitude: Option<f64>,
        /// External custom client defined data
        meta_data: Option<String>,
        /// Determines whether to return a detailed version of the response
        #[clap(short, long)]
        return_full_response: Option<bool>,
        /// Exception Offers, transaction audiences of these offers won't be removed out of the account when up
        exception_membership_offer_ids: Option<String>,
    },
    /// Search Weather
    SearchWeather {
        version: f64,
        /// Region Id
        region_id: Option<i64>,
        /// Latitude
        latitude: Option<f64>,
        /// Longitude
        longitude: Option<f64>,
        /// Timezone Offset
        timezone_offset: Option<i64>,
    },
    /// Create Word
    CreateWord {
        version: f64,
        /// The logged in user.
        account_id: i64,
        /// The text of the word.
        word: String,
        /// The definition of the word.
        definition: String,
        /// If true set the word to active. Default to false.
        #[clap(long)]
        active: bool,
        /// If true then scoring will give tickets. Default to false.
        #[clap(long)]
        allocate_tickets: bool,
        /// The number of tickets to reward
        ticket_count: i64,
        /// The asset id of the word.
        asset_id: Option<i64>,
        /// The type of ticket to reward, null means default type
        ticket_type: Option<String>,
        /// The number of points to award for completing a mission
        points: Option<i64>,
    },
    /// Delete Word
    DeleteWord {
        version: f64,
        /// The id of the word to delete.
        word_id: i64,
        /// The account vor validating permission
        account_id: i64,
    },
    /// Get Word
    GetWord {
        version: f64,
        /// The id of the word to get.
        word_id: i64,
        /// The logged in user.
        account_id: i64,
    },
    /// Search Words
    GetWords {
        version: f64,
        /// The logged in user.
        account_id: i64,
        /// The column to sort the search on
        sort_field: String,
        /// The order to return the search results
        #[clap(short, long)]
        descending: bool,
        /// Return only active results if set to true.
        #[clap(long)]
        active_only: bool,
        /// The record to begin the return set on.
        start: i32,
        /// The number of records to return.
        limit: i32,
        /// The keyword for searching words with matching definition or word text.
        keyword: Option<String>,
    },
    /// Update Word
    UpdateWord {
        version: f64,
        /// The id of the word to update.
        word_id: i64,
        /// The logged in user.
        account_id: i64,
        /// The number of tickets to reward
        ticket_count: i64,
        /// The text for the word
        word_text: Option<String>,
        /// The definition of the word.
        definition: Option<String>,
        /// The asset id of the word.
        asset_id: Option<i64>,
        /// If true set the word to active.
        #[clap(long)]
        active: Option<bool>,
        /// If true then scoring will give tickets.
        #[clap(long)]
        allocate_tickets: Option<bool>,
        /// The type of ticket to reward, null means default type
        ticket_type: Option<String>,
        /// The number of points to award for completing a mission
        points: Option<i64>,
    },
    /// Run Workflow
    RunWorkflow {
        version: f64,
        /// the account ID of the user
        account_id: i64,
        /// the workflow to run
        workflow_id: i64,
        /// this runs a particular sku on the workflow
        sku_id: Option<i64>,
        /// this runs a particular sku version on the workflow
        version_code: Option<i32>,
        /// Override parameters in JSON format. Example: ```json {   \"arguments_81\": { \"filter\": \"PUBLIC\" },   \"arguments_87\": { \"tag\": \"custom_tag\" } } ``` 
        parameters: Option<String>,
    },
}

// On Linux/Unix with OpenSSL (client-tls feature), support certificate pinning and mutual TLS
#[cfg(all(feature = "client-tls", not(any(target_os = "macos", target_os = "windows", target_os = "ios"))))]
fn create_client(args: &Cli, context: ClientContext) -> Result<Box<dyn ApiNoContext<ClientContext>>> {
    if args.client_certificate.is_some() {
        debug!("Using mutual TLS");
        let client = Client::try_new_https_mutual(
            &args.server_address,
            args.server_certificate.clone().unwrap(),
            args.client_key.clone().unwrap(),
            args.client_certificate.clone().unwrap(),
        )
        .context("Failed to create HTTPS client")?;
        Ok(Box::new(client.with_context(context)))
    } else if args.server_certificate.is_some() {
        debug!("Using TLS with pinned server certificate");
        let client =
            Client::try_new_https_pinned(&args.server_address, args.server_certificate.clone().unwrap())
                .context("Failed to create HTTPS client")?;
        Ok(Box::new(client.with_context(context)))
    } else {
        debug!("Using client without certificates");
        let client =
            Client::try_new(&args.server_address).context("Failed to create HTTP(S) client")?;
        Ok(Box::new(client.with_context(context)))
    }
}

// On macOS/Windows/iOS or without client-tls feature, use simple client (no cert pinning/mutual TLS)
#[cfg(any(
    not(feature = "client-tls"),
    all(feature = "client-tls", any(target_os = "macos", target_os = "windows", target_os = "ios"))
))]
fn create_client(args: &Cli, context: ClientContext) -> Result<Box<dyn ApiNoContext<ClientContext>>> {
    // Client::try_new() automatically detects the URL scheme (http:// or https://)
    // and creates the appropriate client.
    // Note: Certificate pinning and mutual TLS are only available on Linux/Unix with OpenSSL
    let client =
        Client::try_new(&args.server_address).context("Failed to create HTTP(S) client")?;
    Ok(Box::new(client.with_context(context)))
}

#[tokio::main]
async fn main() -> Result<()> {
    let args = Cli::parse();
    if let Some(log_level) = args.verbosity.log_level() {
        SimpleLogger::new().with_level(log_level.to_level_filter()).init()?;
    }

    debug!("Arguments: {:?}", &args);

    let auth_data: Option<AuthData> = None;

    #[allow(trivial_casts)]
    let context = swagger::make_context!(
        ContextBuilder,
        EmptyContext,
        auth_data,
        XSpanIdString::default()
    );

    let client = create_client(&args, context)?;

    let result = match args.operation {
        Operation::ConsumerCreate {
            version,
            app_key,
            name,
            hostname,
            username,
            password,
            data_mapping,
            device_id,
            account_id,
            port,
            virtual_host,
            exchanger,
            exchanger_type,
            workers,
            use_ssl,
        } => {
            info!("Performing a ConsumerCreate request on {:?}", (
                &version
            ));

            let result = client.consumer_create(
                version,
                app_key,
                name,
                hostname,
                username,
                password,
                data_mapping,
                device_id,
                account_id,
                port,
                virtual_host,
                exchanger,
                exchanger_type,
                workers,
                use_ssl,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                ConsumerCreateResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::ConsumerUpdate {
            version,
            app_key,
            queue_id,
            data_mapping,
            device_id,
            account_id,
            use_ssl,
        } => {
            info!("Performing a ConsumerUpdate request on {:?}", (
                &version
            ));

            let result = client.consumer_update(
                version,
                app_key,
                queue_id,
                data_mapping,
                device_id,
                account_id,
                use_ssl,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                ConsumerUpdateResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::QueueCreate {
            version,
            app_key,
            name,
            device_id,
            account_id,
            workers,
            analytic_tags,
            hostname,
            port,
            username,
            password,
            virtual_host,
            use_ssl,
        } => {
            info!("Performing a QueueCreate request on {:?}", (
                &version
            ));

            let result = client.queue_create(
                version,
                app_key,
                name,
                device_id,
                account_id,
                workers,
                analytic_tags,
                hostname,
                port,
                username,
                password,
                virtual_host,
                use_ssl,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                QueueCreateResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::QueueDelete {
            version,
            queue_id,
            device_id,
            account_id,
        } => {
            info!("Performing a QueueDelete request on {:?}", (
                &version
            ));

            let result = client.queue_delete(
                version,
                queue_id,
                device_id,
                account_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                QueueDeleteResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::QueueGet {
            version,
            device_id,
            account_id,
            queue_id,
            app_key,
            name,
            hostname,
            virtual_host,
        } => {
            info!("Performing a QueueGet request on {:?}", (
                &version
            ));

            let result = client.queue_get(
                version,
                device_id,
                account_id,
                queue_id,
                app_key,
                name,
                hostname,
                virtual_host,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                QueueGetResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::QueuePublish {
            version,
            message,
            queue_id,
            app_key,
            name,
            hostname,
            virtual_host,
        } => {
            info!("Performing a QueuePublish request on {:?}", (
                &version
            ));

            let result = client.queue_publish(
                version,
                message,
                queue_id,
                app_key,
                name,
                hostname,
                virtual_host,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                QueuePublishResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::QueueSearch {
            version,
            queue_id,
            device_id,
            account_id,
            name,
            start,
            limit,
        } => {
            info!("Performing a QueueSearch request on {:?}", (
                &version
            ));

            let result = client.queue_search(
                version,
                queue_id,
                device_id,
                account_id,
                name,
                start,
                limit,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                QueueSearchResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::QueueUpdate {
            version,
            queue_id,
            device_id,
            account_id,
            app_key,
            workers,
            analytic_tags,
            hostname,
            port,
            username,
            password,
            virtual_host,
            use_ssl,
        } => {
            info!("Performing a QueueUpdate request on {:?}", (
                &version
            ));

            let result = client.queue_update(
                version,
                queue_id,
                device_id,
                account_id,
                app_key,
                workers,
                analytic_tags,
                hostname,
                port,
                username,
                password,
                virtual_host,
                use_ssl,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                QueueUpdateResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::AccountLocationSearch {
            version,
            device_id,
            account_id,
            q,
            keyword,
            postal_code,
            latitude,
            longitude,
            app_key,
            range,
            location_last_updated,
            gender,
            min_age,
            max_age,
            companionship_index,
            _i,
            start,
            _l,
            limit,
            search_mode,
            sort_field,
            descending,
            roles,
            tags,
            experience,
            category_ids,
            audience_ids,
            audience_operator,
            update_current_location,
            update_preferred_settings,
            show_exact_locations,
            show_connection_to_searcher,
            flag_count_minimum,
            verified_user_only,
            content_admin_only,
        } => {
            info!("Performing a AccountLocationSearch request on {:?}", (
                &version
            ));

            let result = client.account_location_search(
                version,
                device_id,
                account_id,
                q,
                keyword,
                postal_code,
                latitude,
                longitude,
                app_key,
                range,
                location_last_updated,
                gender,
                min_age,
                max_age,
                companionship_index,
                _i,
                start,
                _l,
                limit,
                search_mode,
                sort_field,
                descending,
                roles,
                tags,
                experience,
                category_ids,
                audience_ids,
                audience_operator,
                update_current_location,
                update_preferred_settings,
                show_exact_locations,
                show_connection_to_searcher,
                flag_count_minimum,
                verified_user_only,
                content_admin_only,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                AccountLocationSearchResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::BlockAccount {
            version,
            account_id_being_blocked,
            device_id,
            account_id,
            block_flag_value,
            remove_from_groups_if_blocked,
            latitude,
            longitude,
        } => {
            info!("Performing a BlockAccount request on {:?}", (
                &version
            ));

            let result = client.block_account(
                version,
                account_id_being_blocked,
                device_id,
                account_id,
                block_flag_value,
                remove_from_groups_if_blocked,
                latitude,
                longitude,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                BlockAccountResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::CreateAccount {
            version,
            username,
            password,
            name,
            prefix_name,
            first_name,
            middle_name,
            last_name,
            suffix_name,
            title,
            device_id,
            device_id_type,
            email_address,
            asset_id,
            street_address,
            zipcode,
            gender,
            birthday,
            home_phone,
            cell_phone,
            cell_phone_carrier,
            business_phone,
            role,
            platforms,
            tags,
            about_us,
            game_experience,
            category_ids,
            hometown,
            height,
            height_index,
            ethnicity,
            body_type,
            marital_status,
            children,
            religion,
            education,
            education_index,
            smoke,
            drink,
            companionship,
            companionship_index,
            preferred_min_age,
            preferred_max_age,
            preferred_min_height,
            preferred_max_height,
            preferred_gender,
            preferred_education,
            preferred_education_index,
            preferred_body_type,
            preferred_ethnicity,
            preferred_location,
            preferred_location_range,
            latitude,
            longitude,
            accepted_terms,
            invite_token,
            referral_account_id,
            send_validation,
            game_type,
            app_key,
            app_version,
            response_type,
            audience_ids_to_add,
            app_blob,
            app_enable_push,
            app_enable_sms,
            app_enable_email,
            location_visibility,
            home_latitude,
            home_longitude,
            app_nickname,
            personal_audience_id,
        } => {
            info!("Performing a CreateAccount request on {:?}", (
                &version
            ));

            let result = client.create_account(
                version,
                username,
                password,
                name,
                prefix_name,
                first_name,
                middle_name,
                last_name,
                suffix_name,
                title,
                device_id,
                device_id_type,
                email_address,
                asset_id,
                street_address,
                zipcode,
                gender,
                birthday,
                home_phone,
                cell_phone,
                cell_phone_carrier,
                business_phone,
                role,
                platforms,
                tags,
                about_us,
                game_experience,
                category_ids,
                hometown,
                height,
                height_index,
                ethnicity,
                body_type,
                marital_status,
                children,
                religion,
                education,
                education_index,
                smoke,
                drink,
                companionship,
                companionship_index,
                preferred_min_age,
                preferred_max_age,
                preferred_min_height,
                preferred_max_height,
                preferred_gender,
                preferred_education,
                preferred_education_index,
                preferred_body_type,
                preferred_ethnicity,
                preferred_location,
                preferred_location_range,
                latitude,
                longitude,
                accepted_terms,
                invite_token,
                referral_account_id,
                send_validation,
                game_type,
                app_key,
                app_version,
                response_type,
                audience_ids_to_add,
                app_blob,
                app_enable_push,
                app_enable_sms,
                app_enable_email,
                location_visibility,
                home_latitude,
                home_longitude,
                app_nickname,
                personal_audience_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                CreateAccountResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::EditAccount {
            version,
            device_id,
            account_id,
            connection_account_id,
            role,
            asset_id,
            name,
            prefix_name,
            first_name,
            middle_name,
            last_name,
            suffix_name,
            title,
            gender,
            age,
            birthday,
            home_phone,
            cell_phone,
            cell_phone_carrier,
            business_phone,
            email_address,
            street_address,
            street_address2,
            city,
            state,
            zipcode,
            country,
            make_profile_info_public,
            make_game_info_public,
            make_friends_info_public,
            hometown,
            height,
            height_index,
            ethnicity,
            body_type,
            marital_status,
            children,
            religion,
            education,
            education_index,
            smoke,
            drink,
            companionship,
            companionship_index,
            preferred_min_age,
            preferred_max_age,
            preferred_min_height,
            preferred_max_height,
            preferred_gender,
            preferred_education,
            preferred_education_index,
            preferred_body_type,
            preferred_ethnicity,
            preferred_location,
            preferred_location_range,
            platforms,
            tags,
            about_us,
            match_token,
            game_experience,
            categories,
            category_ids,
            response_filters,
            show_as_zipcode,
            show_exact_location,
            show_others_exact_location,
            accepted_terms,
            location_visibility,
            app_blob,
            app_enable_push,
            app_enable_sms,
            app_enable_email,
            game_type,
            app_key,
            latitude,
            longitude,
            return_profile,
            audience_ids_to_add,
            audience_ids_to_remove,
            referral_account_id,
            app_nickname,
            personal_audience_id,
            non_guest_username,
        } => {
            info!("Performing a EditAccount request on {:?}", (
                &version
            ));

            let result = client.edit_account(
                version,
                device_id,
                account_id,
                connection_account_id,
                role,
                asset_id,
                name,
                prefix_name,
                first_name,
                middle_name,
                last_name,
                suffix_name,
                title,
                gender,
                age,
                birthday,
                home_phone,
                cell_phone,
                cell_phone_carrier,
                business_phone,
                email_address,
                street_address,
                street_address2,
                city,
                state,
                zipcode,
                country,
                make_profile_info_public,
                make_game_info_public,
                make_friends_info_public,
                hometown,
                height,
                height_index,
                ethnicity,
                body_type,
                marital_status,
                children,
                religion,
                education,
                education_index,
                smoke,
                drink,
                companionship,
                companionship_index,
                preferred_min_age,
                preferred_max_age,
                preferred_min_height,
                preferred_max_height,
                preferred_gender,
                preferred_education,
                preferred_education_index,
                preferred_body_type,
                preferred_ethnicity,
                preferred_location,
                preferred_location_range,
                platforms,
                tags,
                about_us,
                match_token,
                game_experience,
                categories,
                category_ids,
                response_filters,
                show_as_zipcode,
                show_exact_location,
                show_others_exact_location,
                accepted_terms,
                location_visibility,
                app_blob,
                app_enable_push,
                app_enable_sms,
                app_enable_email,
                game_type,
                app_key,
                latitude,
                longitude,
                return_profile,
                audience_ids_to_add,
                audience_ids_to_remove,
                referral_account_id,
                app_nickname,
                personal_audience_id,
                non_guest_username,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                EditAccountResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::EditUsername {
            version,
            device_id,
            account_id,
            email_address,
            username,
        } => {
            info!("Performing a EditUsername request on {:?}", (
                &version
            ));

            let result = client.edit_username(
                version,
                device_id,
                account_id,
                email_address,
                username,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                EditUsernameResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetAccount {
            version,
            return_nulls,
            device_id,
            account_id,
            connection_account_email,
            connection_account_id,
            response_filters,
            game_type,
            app_key,
            purchase_type,
            update_viewed_date,
            latitude,
            longitude,
        } => {
            info!("Performing a GetAccount request on {:?}", (
                &version
            ));

            let result = client.get_account(
                version,
                return_nulls,
                device_id,
                account_id,
                connection_account_email,
                connection_account_id,
                response_filters,
                game_type,
                app_key,
                purchase_type,
                update_viewed_date,
                latitude,
                longitude,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetAccountResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetProfileAssets {
            version,
            return_nulls,
            device_id,
            account_id,
            owner_id,
            media_types,
            mime_types,
            sort_field,
            descending,
            latitude,
            longitude,
            _i,
            start,
            _l,
            limit,
        } => {
            info!("Performing a GetProfileAssets request on {:?}", (
                &version
            ));

            let result = client.get_profile_assets(
                version,
                return_nulls,
                device_id,
                account_id,
                owner_id,
                media_types,
                mime_types,
                sort_field,
                descending,
                latitude,
                longitude,
                _i,
                start,
                _l,
                limit,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetProfileAssetsResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetReferralList {
            version,
            account_id,
            app_key,
            retrieve_type,
            level_limit,
            ancestor_level_limit,
            children_level_limit,
            ancestor_list_start,
            ancestor_list_limit,
            children_list_start,
            children_list_limit,
            children_children,
        } => {
            info!("Performing a GetReferralList request on {:?}", (
                &version
            ));

            let result = client.get_referral_list(
                version,
                account_id,
                app_key,
                retrieve_type,
                level_limit,
                ancestor_level_limit,
                children_level_limit,
                ancestor_list_start,
                ancestor_list_limit,
                children_list_start,
                children_list_limit,
                children_children,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetReferralListResponse::SuccessfulOperation
                => "SuccessfulOperation\n".to_string()
                    ,
            }
        }
        Operation::GetSettings {
            version,
            device_id,
            account_id,
            latitude,
            longitude,
        } => {
            info!("Performing a GetSettings request on {:?}", (
                &version
            ));

            let result = client.get_settings(
                version,
                device_id,
                account_id,
                latitude,
                longitude,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetSettingsResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::LoginDelegate {
            version,
            access_token,
            app_key,
            device_id,
            access_token_secret,
            delegated_account_id,
            delegated_username,
            network_uid,
            age_restriction,
            response_filters,
            latitude,
            longitude,
        } => {
            info!("Performing a LoginDelegate request on {:?}", (
                &version
            ));

            let result = client.login_delegate(
                version,
                access_token,
                app_key,
                device_id,
                access_token_secret,
                delegated_account_id,
                delegated_username,
                network_uid,
                age_restriction,
                response_filters,
                latitude,
                longitude,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                LoginDelegateResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::LoginGeneral {
            version,
            access_token,
            network_uid,
            app_key,
            device_id,
            device_id_type,
            access_token_secret,
            age_restriction,
            response_filters,
            latitude,
            longitude,
            email_match,
            chosen_account_id,
            third_party_credential_id,
        } => {
            info!("Performing a LoginGeneral request on {:?}", (
                &version
            ));

            let result = client.login_general(
                version,
                access_token,
                network_uid,
                app_key,
                device_id,
                device_id_type,
                access_token_secret,
                age_restriction,
                response_filters,
                latitude,
                longitude,
                email_match,
                chosen_account_id,
                third_party_credential_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                LoginGeneralResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::LoginUsername {
            version,
            username,
            password,
            device_id,
            latitude,
            longitude,
            app,
            game_type,
            app_key,
            return_profile,
            response_filters,
        } => {
            info!("Performing a LoginUsername request on {:?}", (
                &version
            ));

            let result = client.login_username(
                version,
                username,
                password,
                device_id,
                latitude,
                longitude,
                app,
                game_type,
                app_key,
                return_profile,
                response_filters,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                LoginUsernameResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::Logout {
            version,
            device_id,
            device_id_type,
            account_id,
            latitude,
            longitude,
        } => {
            info!("Performing a Logout request on {:?}", (
                &version
            ));

            let result = client.logout(
                version,
                device_id,
                device_id_type,
                account_id,
                latitude,
                longitude,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                LogoutResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::MergeAccount {
            version,
            merge_account_id,
            app_key,
            device_id,
            account_id,
        } => {
            info!("Performing a MergeAccount request on {:?}", (
                &version
            ));

            let result = client.merge_account(
                version,
                merge_account_id,
                app_key,
                device_id,
                account_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                MergeAccountResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::PasswordChange {
            version,
            account_id,
            old_password,
            new_password,
            confirm_password,
        } => {
            info!("Performing a PasswordChange request on {:?}", (
                &version
            ));

            let result = client.password_change(
                version,
                account_id,
                old_password,
                new_password,
                confirm_password,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                PasswordChangeResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::PasswordReset {
            version,
            token,
            password,
            confirm,
        } => {
            info!("Performing a PasswordReset request on {:?}", (
                &version
            ));

            let result = client.password_reset(
                version,
                token,
                password,
                confirm,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                PasswordResetResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::RequestPasswordReset {
            version,
            email,
            from,
            domain,
            sub_url,
            referer,
        } => {
            info!("Performing a RequestPasswordReset request on {:?}", (
                &version
            ));

            let result = client.request_password_reset(
                version,
                email,
                from,
                domain,
                sub_url,
                referer,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                RequestPasswordResetResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::RequestValidateAccount {
            version,
            account_id,
        } => {
            info!("Performing a RequestValidateAccount request on {:?}", (
                &version
            ));

            let result = client.request_validate_account(
                version,
                account_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                RequestValidateAccountResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::SearchAccounts {
            version,
            account_id,
            app_key,
            keyword,
            latitude,
            longitude,
            radius,
            gender,
            game_experience,
            age,
            category_ids,
            return_nulls,
            response_filters,
            purchase_type,
            sort_field,
            descending,
            start,
            limit,
            active_only,
        } => {
            info!("Performing a SearchAccounts request on {:?}", (
                &version
            ));

            let result = client.search_accounts(
                version,
                account_id,
                app_key,
                keyword,
                latitude,
                longitude,
                radius,
                gender,
                game_experience,
                age,
                category_ids,
                return_nulls,
                response_filters,
                purchase_type,
                sort_field,
                descending,
                start,
                limit,
                active_only,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                SearchAccountsResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::SecureLogin {
            version,
            username,
            password,
            game_type,
            device_id,
            charset_name,
            latitude,
            longitude,
            return_profile,
            response_filters,
        } => {
            info!("Performing a SecureLogin request on {:?}", (
                &version
            ));

            let result = client.secure_login(
                version,
                username,
                password,
                game_type,
                device_id,
                charset_name,
                latitude,
                longitude,
                return_profile,
                response_filters,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                SecureLoginResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::SecureSignup {
            version,
            device_id,
            username,
            password,
            name,
            invite_token,
            prefix_name,
            first_name,
            middle_name,
            last_name,
            suffix_name,
            title,
            device_id_type,
            email_address,
            asset_id,
            address,
            zipcode,
            gender,
            birthday,
            home_phone,
            cell_phone,
            cell_phone_carrier,
            business_phone,
            role,
            platforms,
            tags,
            about_us,
            game_experience,
            category_ids,
            hometown,
            height,
            height_index,
            ethnicity,
            body_type,
            marital_status,
            children,
            religion,
            education,
            education_index,
            smoke,
            drink,
            companionship,
            companionship_index,
            preferred_min_age,
            preferred_max_age,
            preferred_min_height,
            preferred_max_height,
            preferred_gender,
            preferred_education,
            preferred_education_index,
            preferred_body_type,
            preferred_ethnicity,
            preferred_location,
            preferred_location_range,
            latitude,
            longitude,
            accepted_terms,
            charset_name,
            game_type,
            app_key,
            app_version,
            response_type,
        } => {
            info!("Performing a SecureSignup request on {:?}", (
                &version
            ));

            let result = client.secure_signup(
                version,
                device_id,
                username,
                password,
                name,
                invite_token,
                prefix_name,
                first_name,
                middle_name,
                last_name,
                suffix_name,
                title,
                device_id_type,
                email_address,
                asset_id,
                address,
                zipcode,
                gender,
                birthday,
                home_phone,
                cell_phone,
                cell_phone_carrier,
                business_phone,
                role,
                platforms,
                tags,
                about_us,
                game_experience,
                category_ids,
                hometown,
                height,
                height_index,
                ethnicity,
                body_type,
                marital_status,
                children,
                religion,
                education,
                education_index,
                smoke,
                drink,
                companionship,
                companionship_index,
                preferred_min_age,
                preferred_max_age,
                preferred_min_height,
                preferred_max_height,
                preferred_gender,
                preferred_education,
                preferred_education_index,
                preferred_body_type,
                preferred_ethnicity,
                preferred_location,
                preferred_location_range,
                latitude,
                longitude,
                accepted_terms,
                charset_name,
                game_type,
                app_key,
                app_version,
                response_type,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                SecureSignupResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::SetMatchToken {
            version,
            device_id,
            account_id,
            match_token,
            game_type,
            app_key,
            latitude,
            longitude,
        } => {
            info!("Performing a SetMatchToken request on {:?}", (
                &version
            ));

            let result = client.set_match_token(
                version,
                device_id,
                account_id,
                match_token,
                game_type,
                app_key,
                latitude,
                longitude,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                SetMatchTokenResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::UpdateActveStatus {
            version,
            account_id,
            connection_account_id,
            active,
            device_id,
            app_key,
        } => {
            info!("Performing a UpdateActveStatus request on {:?}", (
                &version
            ));

            let result = client.update_actve_status(
                version,
                account_id,
                connection_account_id,
                active,
                device_id,
                app_key,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                UpdateActveStatusResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::UpdateLocation {
            version,
            device_id,
            account_id,
            latitude,
            longitude,
            client_time,
        } => {
            info!("Performing a UpdateLocation request on {:?}", (
                &version
            ));

            let result = client.update_location(
                version,
                device_id,
                account_id,
                latitude,
                longitude,
                client_time,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                UpdateLocationResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::UpdateSettings {
            version,
            device_id,
            account_id,
            blocked_notifications,
            suggestion_method,
            suggestion_count,
            suggestion_time_frame,
            show_others_exact_location,
            show_as_zipcode,
            show_exact_location,
            favorite_visibility,
            latitude,
            longitude,
        } => {
            info!("Performing a UpdateSettings request on {:?}", (
                &version
            ));

            let result = client.update_settings(
                version,
                device_id,
                account_id,
                blocked_notifications,
                suggestion_method,
                suggestion_count,
                suggestion_time_frame,
                show_others_exact_location,
                show_as_zipcode,
                show_exact_location,
                favorite_visibility,
                latitude,
                longitude,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                UpdateSettingsResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::ValidateAccountSignup {
            version,
            token,
        } => {
            info!("Performing a ValidateAccountSignup request on {:?}", (
                &version
            ));

            let result = client.validate_account_signup(
                version,
                token,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                ValidateAccountSignupResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::ValidatePasswordReset {
            version,
            token,
        } => {
            info!("Performing a ValidatePasswordReset request on {:?}", (
                &version
            ));

            let result = client.validate_password_reset(
                version,
                token,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                ValidatePasswordResetResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::ApiVersionAchievementTierSearchPost {
            version,
            device_id,
            account_id,
            app_key,
            keyword,
            achievement_type,
            rank_type,
            sort_field,
            descending,
            descending_goal,
            start,
            limit,
        } => {
            info!("Performing a ApiVersionAchievementTierSearchPost request on {:?}", (
                &version
            ));

            let result = client.api_version_achievement_tier_search_post(
                version,
                device_id,
                account_id,
                app_key,
                keyword,
                achievement_type,
                rank_type,
                sort_field,
                descending,
                descending_goal,
                start,
                limit,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                ApiVersionAchievementTierSearchPostResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::CreateAchievement {
            version,
            app_key,
            title,
            device_id,
            account_id,
            analytics_tag,
            description,
            rank_type,
            rank_increment,
            min_increment,
            max_increment,
            validate,
            active,
            trigger_definition,
        } => {
            info!("Performing a CreateAchievement request on {:?}", (
                &version
            ));

            let result = client.create_achievement(
                version,
                app_key,
                title,
                device_id,
                account_id,
                analytics_tag,
                description,
                rank_type,
                rank_increment,
                min_increment,
                max_increment,
                validate,
                active,
                trigger_definition,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                CreateAchievementResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::CreateAchievementTier {
            version,
            achievement_id,
            score_all_instances,
            device_id,
            account_id,
            icon,
            icon_asset_id,
            title,
            description,
            goal_count,
            mission_id,
            game_id,
            pack_id,
            game_level_id,
            game_object_id,
        } => {
            info!("Performing a CreateAchievementTier request on {:?}", (
                &version
            ));

            let result = client.create_achievement_tier(
                version,
                achievement_id,
                score_all_instances,
                device_id,
                account_id,
                icon,
                icon_asset_id,
                title,
                description,
                goal_count,
                mission_id,
                game_id,
                pack_id,
                game_level_id,
                game_object_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                CreateAchievementTierResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::DeleteAchievement {
            version,
            achievement_id,
            account_id,
        } => {
            info!("Performing a DeleteAchievement request on {:?}", (
                &version
            ));

            let result = client.delete_achievement(
                version,
                achievement_id,
                account_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                DeleteAchievementResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::DeleteAchievementTier {
            version,
            achievement_tier_id,
            account_id,
        } => {
            info!("Performing a DeleteAchievementTier request on {:?}", (
                &version
            ));

            let result = client.delete_achievement_tier(
                version,
                achievement_tier_id,
                account_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                DeleteAchievementTierResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetAchievement {
            version,
            achievement_id,
            device_id,
            account_id,
            achievement_type,
        } => {
            info!("Performing a GetAchievement request on {:?}", (
                &version
            ));

            let result = client.get_achievement(
                version,
                achievement_id,
                device_id,
                account_id,
                achievement_type,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetAchievementResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetAchievementTier {
            version,
            account_id,
            achievement_tier_id,
        } => {
            info!("Performing a GetAchievementTier request on {:?}", (
                &version
            ));

            let result = client.get_achievement_tier(
                version,
                account_id,
                achievement_tier_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetAchievementTierResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetUserAchievements {
            version,
            return_nulls,
            app_key,
            include_undiscovered,
            device_id,
            account_id,
            connection_account_email,
            connection_account_id,
            rank_type,
            achievement_type,
            latitude,
            longitude,
        } => {
            info!("Performing a GetUserAchievements request on {:?}", (
                &version
            ));

            let result = client.get_user_achievements(
                version,
                return_nulls,
                app_key,
                include_undiscovered,
                device_id,
                account_id,
                connection_account_email,
                connection_account_id,
                rank_type,
                achievement_type,
                latitude,
                longitude,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetUserAchievementsResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::ListAchievementTags {
            version,
            app_key,
        } => {
            info!("Performing a ListAchievementTags request on {:?}", (
                &version
            ));

            let result = client.list_achievement_tags(
                version,
                app_key,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                ListAchievementTagsResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::ListAchievements {
            version,
            sort_field,
            descending,
            start,
            limit,
            active_only,
            device_id,
            account_id,
            app_key,
            keyword,
            achievement_type,
            rank_type,
        } => {
            info!("Performing a ListAchievements request on {:?}", (
                &version
            ));

            let result = client.list_achievements(
                version,
                sort_field,
                descending,
                start,
                limit,
                active_only,
                device_id,
                account_id,
                app_key,
                keyword,
                achievement_type,
                rank_type,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                ListAchievementsResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::SearchAchievements {
            version,
            app_key,
            sort_field,
            descending,
            include_tiers,
            include_inactive_tiers,
            start,
            limit,
            device_id,
            account_id,
            keyword,
            achievement_type,
            rank_type,
        } => {
            info!("Performing a SearchAchievements request on {:?}", (
                &version
            ));

            let result = client.search_achievements(
                version,
                app_key,
                sort_field,
                descending,
                include_tiers,
                include_inactive_tiers,
                start,
                limit,
                device_id,
                account_id,
                keyword,
                achievement_type,
                rank_type,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                SearchAchievementsResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::UpdateAchievement {
            version,
            device_id,
            account_id,
            achievement_id,
            analytics_tag,
            title,
            description,
            rank_type,
            rank_increment,
            min_increment,
            null_min_increment,
            max_increment,
            null_max_increment,
            validate,
            active,
            trigger_definition,
        } => {
            info!("Performing a UpdateAchievement request on {:?}", (
                &version
            ));

            let result = client.update_achievement(
                version,
                device_id,
                account_id,
                achievement_id,
                analytics_tag,
                title,
                description,
                rank_type,
                rank_increment,
                min_increment,
                null_min_increment,
                max_increment,
                null_max_increment,
                validate,
                active,
                trigger_definition,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                UpdateAchievementResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::UpdateAchievementTier {
            version,
            achievement_tier_id,
            device_id,
            account_id,
            icon,
            icon_asset_id,
            title,
            description,
            goal_count,
            mission_id,
            game_id,
            pack_id,
            game_level_id,
            game_object_id,
            score_all_instances,
        } => {
            info!("Performing a UpdateAchievementTier request on {:?}", (
                &version
            ));

            let result = client.update_achievement_tier(
                version,
                achievement_tier_id,
                device_id,
                account_id,
                icon,
                icon_asset_id,
                title,
                description,
                goal_count,
                mission_id,
                game_id,
                pack_id,
                game_level_id,
                game_object_id,
                score_all_instances,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                UpdateAchievementTierResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::UpdateUserAchievement {
            version,
            account_id,
            achievement_id,
            tag,
            custom_id,
            increment,
            start_date,
            end_date,
            return_progress,
        } => {
            info!("Performing a UpdateUserAchievement request on {:?}", (
                &version
            ));

            let result = client.update_user_achievement(
                version,
                account_id,
                achievement_id,
                tag,
                custom_id,
                increment,
                start_date,
                end_date,
                return_progress,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                UpdateUserAchievementResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::CreateEntityReference {
            version,
            body,
        } => {
            info!("Performing a CreateEntityReference request on {:?}", (
                &version
            ));

            let result = client.create_entity_reference(
                version,
                body,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                CreateEntityReferenceResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::AddAlbumCollection {
            version,
            title,
            cover_asset_nullable,
            include_cover_in_asset_list,
            public_read,
            public_write,
            public_delete,
            public_add,
            anonymous,
            device_id,
            account_id,
            assets_to_add,
            media,
            media_url,
            asset_id,
            attached_media,
            attached_media_url,
            start_date,
            end_date,
            tags,
            description,
            album_type,
            album_type_id,
            sub_type,
            latitude,
            longitude,
            location_description,
            visibility,
            game_type,
            app_key,
            cell_phone,
            street_address,
            street_address2,
            city,
            state,
            postal_code,
            full_address,
            meta_data,
            category_ids,
            category_filter_ids,
            audience_ids,
            include_all_app_users_as_members,
            include_audiences_as_members,
            audience_operator,
            approval_status,
            linked_object_type,
            linked_object_id,
        } => {
            info!("Performing a AddAlbumCollection request on {:?}", (
                &version
            ));

            let result = client.add_album_collection(
                version,
                title,
                cover_asset_nullable,
                include_cover_in_asset_list,
                public_read,
                public_write,
                public_delete,
                public_add,
                anonymous,
                device_id,
                account_id,
                assets_to_add,
                media,
                media_url,
                asset_id,
                attached_media,
                attached_media_url,
                start_date,
                end_date,
                tags,
                description,
                album_type,
                album_type_id,
                sub_type,
                latitude,
                longitude,
                location_description,
                visibility,
                game_type,
                app_key,
                cell_phone,
                street_address,
                street_address2,
                city,
                state,
                postal_code,
                full_address,
                meta_data,
                category_ids,
                category_filter_ids,
                audience_ids,
                include_all_app_users_as_members,
                include_audiences_as_members,
                audience_operator,
                approval_status,
                linked_object_type,
                linked_object_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                AddAlbumCollectionResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::AddAlbumUsers {
            version,
            album_id,
            include_friend_group,
            device_id,
            account_id,
            read,
            write,
            delete,
            add,
            connections,
            connection_groups,
        } => {
            info!("Performing a AddAlbumUsers request on {:?}", (
                &version
            ));

            let result = client.add_album_users(
                version,
                album_id,
                include_friend_group,
                device_id,
                account_id,
                read,
                write,
                delete,
                add,
                connections,
                connection_groups,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                AddAlbumUsersResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::ApproveAlbum {
            version,
            album_id,
            device_id,
            account_id,
            approval_status,
            verified,
        } => {
            info!("Performing a ApproveAlbum request on {:?}", (
                &version
            ));

            let result = client.approve_album(
                version,
                album_id,
                device_id,
                account_id,
                approval_status,
                verified,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                ApproveAlbumResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetAlbumCollection {
            version,
            return_nulls,
            album_id,
            device_id,
            account_id,
            like_preview_size,
            asset_preview_size,
            note_preview_size,
            connection_preview_size,
            audience_preview_size,
        } => {
            info!("Performing a GetAlbumCollection request on {:?}", (
                &version
            ));

            let result = client.get_album_collection(
                version,
                return_nulls,
                album_id,
                device_id,
                account_id,
                like_preview_size,
                asset_preview_size,
                note_preview_size,
                connection_preview_size,
                audience_preview_size,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetAlbumCollectionResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::LeaveAlbum {
            version,
            album_id,
            device_id,
            account_id,
        } => {
            info!("Performing a LeaveAlbum request on {:?}", (
                &version
            ));

            let result = client.leave_album(
                version,
                album_id,
                device_id,
                account_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                LeaveAlbumResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::RemoveAlbum {
            version,
            album_id,
            device_id,
            account_id,
        } => {
            info!("Performing a RemoveAlbum request on {:?}", (
                &version
            ));

            let result = client.remove_album(
                version,
                album_id,
                device_id,
                account_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                RemoveAlbumResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::RemoveAlbumUsers {
            version,
            album_id,
            remove_friend_group,
            device_id,
            account_id,
            connections,
            connection_groups,
        } => {
            info!("Performing a RemoveAlbumUsers request on {:?}", (
                &version
            ));

            let result = client.remove_album_users(
                version,
                album_id,
                remove_friend_group,
                device_id,
                account_id,
                connections,
                connection_groups,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                RemoveAlbumUsersResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::SearchAlbums {
            version,
            filter,
            album_type_id,
            sub_type,
            include_inactive,
            sort_field,
            descending,
            start,
            limit,
            range,
            include_liked,
            include_favorited,
            include_permissions,
            like_preview_size,
            asset_preview_size,
            note_preview_size,
            connection_preview_size,
            audience_preview_size,
            device_id,
            account_id,
            connection_account_id,
            owner_id,
            album_ids,
            exclude_album_ids,
            media_id,
            keyword,
            album_type,
            limit_per_album_type,
            date_created,
            updated_since,
            updated_before,
            created_since,
            created_before,
            started_since,
            started_before,
            ended_since,
            ended_before,
            latitude,
            longitude,
            app_key,
            category_ids,
            category_filter_ids,
            audience_ids,
            exclude_audience_ids,
            include_completable,
            include_rating,
            search_mode,
            stack_search,
            stack_window_size,
            min_stack_per_page,
            stack_pagination_identifier,
            stack_details,
            flag_count_minimum,
            remove_flagged_content,
            verified_filter,
            linked_object_type,
            linked_object_id,
            order_audience_id,
            ignore_default_app_filter,
            search_expression,
            generate_albums,
        } => {
            info!("Performing a SearchAlbums request on {:?}", (
                &version
            ));

            let result = client.search_albums(
                version,
                filter,
                album_type_id,
                sub_type,
                include_inactive,
                sort_field,
                descending,
                start,
                limit,
                range,
                include_liked,
                include_favorited,
                include_permissions,
                like_preview_size,
                asset_preview_size,
                note_preview_size,
                connection_preview_size,
                audience_preview_size,
                device_id,
                account_id,
                connection_account_id,
                owner_id,
                album_ids,
                exclude_album_ids,
                media_id,
                keyword,
                album_type,
                limit_per_album_type,
                date_created,
                updated_since,
                updated_before,
                created_since,
                created_before,
                started_since,
                started_before,
                ended_since,
                ended_before,
                latitude,
                longitude,
                app_key,
                category_ids,
                category_filter_ids,
                audience_ids,
                exclude_audience_ids,
                include_completable,
                include_rating,
                search_mode,
                stack_search,
                stack_window_size,
                min_stack_per_page,
                stack_pagination_identifier,
                stack_details,
                flag_count_minimum,
                remove_flagged_content,
                verified_filter,
                linked_object_type,
                linked_object_id,
                order_audience_id,
                ignore_default_app_filter,
                search_expression,
                generate_albums,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                SearchAlbumsResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::UpdateAlbumCollection {
            version,
            album_id,
            device_id,
            account_id,
            assets_to_add,
            assets_to_remove,
            asset_id,
            media,
            media_url,
            active,
            title,
            start_date,
            end_date,
            tags,
            description,
            album_type,
            album_type_id,
            sub_type,
            public_read,
            public_write,
            public_delete,
            public_add,
            latitude,
            longitude,
            location_description,
            visibility,
            cell_phone,
            street_address,
            street_address2,
            city,
            state,
            postal_code,
            full_address,
            anonymous,
            meta_data,
            category_ids,
            category_filter_ids,
            audience_ids,
            audience_ids_to_add,
            audience_ids_to_remove,
            include_all_app_users_as_members,
            include_audiences_as_members,
            audience_operator,
            linked_object_type,
            linked_object_id,
            index_now,
        } => {
            info!("Performing a UpdateAlbumCollection request on {:?}", (
                &version
            ));

            let result = client.update_album_collection(
                version,
                album_id,
                device_id,
                account_id,
                assets_to_add,
                assets_to_remove,
                asset_id,
                media,
                media_url,
                active,
                title,
                start_date,
                end_date,
                tags,
                description,
                album_type,
                album_type_id,
                sub_type,
                public_read,
                public_write,
                public_delete,
                public_add,
                latitude,
                longitude,
                location_description,
                visibility,
                cell_phone,
                street_address,
                street_address2,
                city,
                state,
                postal_code,
                full_address,
                anonymous,
                meta_data,
                category_ids,
                category_filter_ids,
                audience_ids,
                audience_ids_to_add,
                audience_ids_to_remove,
                include_all_app_users_as_members,
                include_audiences_as_members,
                audience_operator,
                linked_object_type,
                linked_object_id,
                index_now,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                UpdateAlbumCollectionResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::Activities {
            version,
            start,
            limit,
            account_id,
        } => {
            info!("Performing a Activities request on {:?}", (
                &version
            ));

            let result = client.activities(
                version,
                start,
                limit,
                account_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                ActivitiesResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::AggregatedFilteredUsage {
            version,
            device_id,
            account_id,
            application_id,
            app_key,
            start_date,
            end_date,
            device_type,
            device,
            device_os,
            gender,
            age_group,
            country,
            state,
            city,
            zip,
            model,
            tag,
            user_account_id,
            user_account_display,
            user_account_username,
            group_by_root,
            group_by,
            distinct_count,
            sort_field,
            descending,
            hide_unknown,
            response_format,
            _l,
            limit,
            latitude,
            longitude,
        } => {
            info!("Performing a AggregatedFilteredUsage request on {:?}", (
                &version
            ));

            let result = client.aggregated_filtered_usage(
                version,
                device_id,
                account_id,
                application_id,
                app_key,
                start_date,
                end_date,
                device_type,
                device,
                device_os,
                gender,
                age_group,
                country,
                state,
                city,
                zip,
                model,
                tag,
                user_account_id,
                user_account_display,
                user_account_username,
                group_by_root,
                group_by,
                distinct_count,
                sort_field,
                descending,
                hide_unknown,
                response_format,
                _l,
                limit,
                latitude,
                longitude,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                AggregatedFilteredUsageResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::FilteredUsage {
            version,
            device_id,
            account_id,
            application_id,
            app_key,
            start_date,
            end_date,
            device_type,
            device,
            device_os,
            gender,
            age_group,
            country,
            state,
            city,
            zip,
            model,
            tag,
            user_account_id,
            user_account_display,
            user_account_username,
            custom_id,
            custom_type,
            custom_value,
            custom_value2,
            custom_long,
            custom_long2,
            custom_message,
            custom_message2,
            group_by,
            distinct_count,
            sum_column,
            sort_field,
            descending,
            hide_unknown,
            response_format,
            _l,
            limit,
            latitude,
            longitude,
        } => {
            info!("Performing a FilteredUsage request on {:?}", (
                &version
            ));

            let result = client.filtered_usage(
                version,
                device_id,
                account_id,
                application_id,
                app_key,
                start_date,
                end_date,
                device_type,
                device,
                device_os,
                gender,
                age_group,
                country,
                state,
                city,
                zip,
                model,
                tag,
                user_account_id,
                user_account_display,
                user_account_username,
                custom_id,
                custom_type,
                custom_value,
                custom_value2,
                custom_long,
                custom_long2,
                custom_message,
                custom_message2,
                group_by,
                distinct_count,
                sum_column,
                sort_field,
                descending,
                hide_unknown,
                response_format,
                _l,
                limit,
                latitude,
                longitude,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                FilteredUsageResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::Usage {
            version,
            tag,
            device_id,
            account_id,
            application_id,
            app_key,
            app_version,
            device,
            device_type,
            device_os,
            model,
            latitude,
            longitude,
            custom_id,
            custom_type,
            achievement_increment,
            city,
            state,
            country,
            zip,
            location_description,
            client_time,
            error_message,
            ip,
            user_agent,
            background_event,
            custom_message,
            custom_message2,
            custom_value,
            custom_value2,
            custom_long,
            custom_long2,
        } => {
            info!("Performing a Usage request on {:?}", (
                &version
            ));

            let result = client.usage(
                version,
                tag,
                device_id,
                account_id,
                application_id,
                app_key,
                app_version,
                device,
                device_type,
                device_os,
                model,
                latitude,
                longitude,
                custom_id,
                custom_type,
                achievement_increment,
                city,
                state,
                country,
                zip,
                location_description,
                client_time,
                error_message,
                ip,
                user_agent,
                background_event,
                custom_message,
                custom_message2,
                custom_value,
                custom_value2,
                custom_long,
                custom_long2,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                UsageResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::UsageBatch {
            version,
            app_key,
            device,
            data,
            device_id,
            account_id,
            app_version,
            device_type,
            device_os,
            model,
            update_ranking,
            return_summary_response,
        } => {
            info!("Performing a UsageBatch request on {:?}", (
                &version
            ));

            let result = client.usage_batch(
                version,
                app_key,
                device,
                data,
                device_id,
                account_id,
                app_version,
                device_type,
                device_os,
                model,
                update_ranking,
                return_summary_response,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                UsageBatchResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetAppData {
            version,
            start,
            limit,
            device_id,
            account_id,
            game_type,
            include_game_data,
            q,
            keyword,
            sort_field,
            descending,
            _i,
            _l,
            game_object_count,
            filter,
            date_created,
            owner_id,
            mission_ids,
            game_ids,
            pack_ids,
            game_level_ids,
            app_version,
            include_higher_version_packs,
            include_higher_version_levels,
            response_groups,
            purchase_type,
        } => {
            info!("Performing a GetAppData request on {:?}", (
                &version
            ));

            let result = client.get_app_data(
                version,
                start,
                limit,
                device_id,
                account_id,
                game_type,
                include_game_data,
                q,
                keyword,
                sort_field,
                descending,
                _i,
                _l,
                game_object_count,
                filter,
                date_created,
                owner_id,
                mission_ids,
                game_ids,
                pack_ids,
                game_level_ids,
                app_version,
                include_higher_version_packs,
                include_higher_version_levels,
                response_groups,
                purchase_type,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetAppDataResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::PostAppData {
            version,
            game_type,
            start,
            limit,
            data,
            device_id,
            account_id,
            include_game_data,
            q,
            keyword,
            sort_field,
            descending,
            _i,
            _l,
            game_object_count,
            filter,
            date_created,
            owner_id,
            mission_ids,
            game_ids,
            pack_ids,
            game_level_ids,
            app_version,
            include_higher_version_packs,
            include_higher_version_levels,
            response_groups,
            purchase_type,
        } => {
            info!("Performing a PostAppData request on {:?}", (
                &version
            ));

            let result = client.post_app_data(
                version,
                game_type,
                start,
                limit,
                data,
                device_id,
                account_id,
                include_game_data,
                q,
                keyword,
                sort_field,
                descending,
                _i,
                _l,
                game_object_count,
                filter,
                date_created,
                owner_id,
                mission_ids,
                game_ids,
                pack_ids,
                game_level_ids,
                app_version,
                include_higher_version_packs,
                include_higher_version_levels,
                response_groups,
                purchase_type,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                PostAppDataResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::RegenAppData {
            version,
            account_id,
            app_key,
            build_version,
            api_version,
        } => {
            info!("Performing a RegenAppData request on {:?}", (
                &version
            ));

            let result = client.regen_app_data(
                version,
                account_id,
                app_key,
                build_version,
                api_version,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                RegenAppDataResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::CreateApplication {
            version,
            app_name,
            device_id,
            account_id,
            about,
            bundle_id,
            app_icon_asset_id,
            app_logo_asset_id,
            facebook_app_id,
            facebook_app_secret,
            google_api_key,
            update_eula_date,
            eula_version,
            landing_page_url,
            show_in_activities,
            activity_description,
            invite_welcome_text,
            invite_page_url,
            url_scheme,
            platforms,
            download_urls,
            category_ids,
            scoring_type,
            hint_cost,
            max_score,
            tickets_per_point,
            has_game_data,
            public_notifications,
            use_matching_algorithm,
            global_tickets,
            build_version,
            api_version,
            placement_name,
            placement_description,
            placement_size,
            placement_height,
            placement_width,
            placement_refresh_interval,
            create_object_store,
            public_content_approval,
            production_mode,
            minimum_session_length,
            session_gap_length,
            local_ads_enabled,
            sqoot_api_key,
            trilat_processing_type,
            max_sample_size,
            min_rssi,
            modules,
            authorized_count,
            authorized_servers,
            default_timezone,
            smtp_pass,
            meta_data,
            placement_meta_data,
            ips_floor,
            enable_apns_badge,
            include_in_report,
            default_app_filter_id,
            enable_welcome_email,
            apple_app_id,
            apple_team_id,
            apple_auth_key_id,
            apple_auth_key,
            apple_issuer_id,
            app_store_key_id,
            app_store_key,
            google_private_key_file,
            authorize_net_api_key,
            authorize_net_transaction_key,
            email_sender,
            smtp_user,
            smtp_host,
            vatom_business_id,
            vatom_rest_client_id,
            vatom_rest_secret_key,
            twilio_account_sid,
            twilio_auth_token,
            twilio_sender_phone_number,
            open_ai_secret_key,
        } => {
            info!("Performing a CreateApplication request on {:?}", (
                &version
            ));

            let result = client.create_application(
                version,
                app_name,
                device_id,
                account_id,
                about,
                bundle_id,
                app_icon_asset_id,
                app_logo_asset_id,
                facebook_app_id,
                facebook_app_secret,
                google_api_key,
                update_eula_date,
                eula_version,
                landing_page_url,
                show_in_activities,
                activity_description,
                invite_welcome_text,
                invite_page_url,
                url_scheme,
                platforms,
                download_urls,
                category_ids,
                scoring_type,
                hint_cost,
                max_score,
                tickets_per_point,
                has_game_data,
                public_notifications,
                use_matching_algorithm,
                global_tickets,
                build_version,
                api_version,
                placement_name,
                placement_description,
                placement_size,
                placement_height,
                placement_width,
                placement_refresh_interval,
                create_object_store,
                public_content_approval,
                production_mode,
                minimum_session_length,
                session_gap_length,
                local_ads_enabled,
                sqoot_api_key,
                trilat_processing_type,
                max_sample_size,
                min_rssi,
                modules,
                authorized_count,
                authorized_servers,
                default_timezone,
                smtp_pass,
                meta_data,
                placement_meta_data,
                ips_floor,
                enable_apns_badge,
                include_in_report,
                default_app_filter_id,
                enable_welcome_email,
                apple_app_id,
                apple_team_id,
                apple_auth_key_id,
                apple_auth_key,
                apple_issuer_id,
                app_store_key_id,
                app_store_key,
                google_private_key_file,
                authorize_net_api_key,
                authorize_net_transaction_key,
                email_sender,
                smtp_user,
                smtp_host,
                vatom_business_id,
                vatom_rest_client_id,
                vatom_rest_secret_key,
                twilio_account_sid,
                twilio_auth_token,
                twilio_sender_phone_number,
                open_ai_secret_key,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                CreateApplicationResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::CreateApplicationPlacement {
            version,
            app_key,
            size,
            device_id,
            account_id,
            name,
            description,
            height,
            width,
            refresh_interval,
            default_image_id,
            active,
        } => {
            info!("Performing a CreateApplicationPlacement request on {:?}", (
                &version
            ));

            let result = client.create_application_placement(
                version,
                app_key,
                size,
                device_id,
                account_id,
                name,
                description,
                height,
                width,
                refresh_interval,
                default_image_id,
                active,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                CreateApplicationPlacementResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::DeleteApplication {
            version,
            account_id,
            app_key,
        } => {
            info!("Performing a DeleteApplication request on {:?}", (
                &version
            ));

            let result = client.delete_application(
                version,
                account_id,
                app_key,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                DeleteApplicationResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::DeleteApplicationPlacement {
            version,
            placement_id,
            device_id,
            account_id,
        } => {
            info!("Performing a DeleteApplicationPlacement request on {:?}", (
                &version
            ));

            let result = client.delete_application_placement(
                version,
                placement_id,
                device_id,
                account_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                DeleteApplicationPlacementResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetApplication {
            version,
            app_key,
            application_id,
        } => {
            info!("Performing a GetApplication request on {:?}", (
                &version
            ));

            let result = client.get_application(
                version,
                app_key,
                application_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetApplicationResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetApplicationPlacement {
            version,
            placement_id,
            device_id,
            account_id,
        } => {
            info!("Performing a GetApplicationPlacement request on {:?}", (
                &version
            ));

            let result = client.get_application_placement(
                version,
                placement_id,
                device_id,
                account_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetApplicationPlacementResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetApplicationVersions {
            version,
        } => {
            info!("Performing a GetApplicationVersions request on {:?}", (
                &version
            ));

            let result = client.get_application_versions(
                version,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetApplicationVersionsResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetUniqueUsersByApp {
            version,
            app_key,
            q,
            keyword,
            since,
            _i,
            start,
            _l,
            limit,
        } => {
            info!("Performing a GetUniqueUsersByApp request on {:?}", (
                &version
            ));

            let result = client.get_unique_users_by_app(
                version,
                app_key,
                q,
                keyword,
                since,
                _i,
                start,
                _l,
                limit,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetUniqueUsersByAppResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::ListApplications {
            version,
            account_id,
            q,
            keyword,
            platforms,
            device_ids,
            device_versions,
            category_ids,
            sort_field,
            has_ads,
            public_notifications,
            filter_billable,
            filter_content_admin,
            descending,
            _i,
            start,
            _l,
            limit,
            application_ids,
            has_object_store,
            active_only,
        } => {
            info!("Performing a ListApplications request on {:?}", (
                &version
            ));

            let result = client.list_applications(
                version,
                account_id,
                q,
                keyword,
                platforms,
                device_ids,
                device_versions,
                category_ids,
                sort_field,
                has_ads,
                public_notifications,
                filter_billable,
                filter_content_admin,
                descending,
                _i,
                start,
                _l,
                limit,
                application_ids,
                has_object_store,
                active_only,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                ListApplicationsResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::SearchApplicationPlacement {
            version,
            app_key,
            device_id,
            account_id,
            start,
            limit,
        } => {
            info!("Performing a SearchApplicationPlacement request on {:?}", (
                &version
            ));

            let result = client.search_application_placement(
                version,
                app_key,
                device_id,
                account_id,
                start,
                limit,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                SearchApplicationPlacementResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::SearchApplicationSettings {
            version,
            device_id,
            account_id,
            connection_account_id,
            keyword,
            sort_field,
            descending,
            start,
            limit,
        } => {
            info!("Performing a SearchApplicationSettings request on {:?}", (
                &version
            ));

            let result = client.search_application_settings(
                version,
                device_id,
                account_id,
                connection_account_id,
                keyword,
                sort_field,
                descending,
                start,
                limit,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                SearchApplicationSettingsResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::SearchApplications {
            version,
            device_id,
            account_id,
            latitude,
            longitude,
            q,
            keyword,
            q_search_fields,
            sort_field,
            descending,
            _i,
            start,
            _l,
            limit,
            has_ads,
            public_notifications,
            active_only,
        } => {
            info!("Performing a SearchApplications request on {:?}", (
                &version
            ));

            let result = client.search_applications(
                version,
                device_id,
                account_id,
                latitude,
                longitude,
                q,
                keyword,
                q_search_fields,
                sort_field,
                descending,
                _i,
                start,
                _l,
                limit,
                has_ads,
                public_notifications,
                active_only,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                SearchApplicationsResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::UpdateApplication {
            version,
            app_key,
            app_name,
            device_id,
            account_id,
            about,
            bundle_id,
            app_icon_asset_id,
            app_logo_asset_id,
            facebook_app_id,
            facebook_app_secret,
            google_api_key,
            update_eula_date,
            eula_version,
            landing_page_url,
            show_in_activities,
            activity_description,
            invite_welcome_text,
            invite_page_url,
            url_scheme,
            platforms,
            download_urls,
            category_ids,
            scoring_type,
            hint_cost,
            max_score,
            tickets_per_point,
            has_game_data,
            public_notifications,
            use_matching_algorithm,
            global_tickets,
            build_version,
            api_version,
            placement_name,
            placement_description,
            placement_size,
            placement_height,
            placement_width,
            placement_refresh_interval,
            create_object_store,
            public_content_approval,
            production_mode,
            minimum_session_length,
            session_gap_length,
            local_ads_enabled,
            sqoot_api_key,
            trilat_processing_type,
            max_sample_size,
            min_rssi,
            modules,
            authorized_count,
            authorized_servers,
            default_timezone,
            smtp_pass,
            meta_data,
            placement_meta_data,
            ips_floor,
            enable_apns_badge,
            include_in_report,
            default_app_filter_id,
            enable_welcome_email,
            apple_app_id,
            apple_team_id,
            apple_auth_key_id,
            apple_auth_key,
            apple_issuer_id,
            app_store_key_id,
            app_store_key,
            google_private_key_file,
            authorize_net_api_key,
            authorize_net_transaction_key,
            email_sender,
            smtp_user,
            smtp_host,
            vatom_business_id,
            vatom_rest_client_id,
            vatom_rest_secret_key,
            twilio_account_sid,
            twilio_auth_token,
            twilio_sender_phone_number,
            open_ai_secret_key,
        } => {
            info!("Performing a UpdateApplication request on {:?}", (
                &version
            ));

            let result = client.update_application(
                version,
                app_key,
                app_name,
                device_id,
                account_id,
                about,
                bundle_id,
                app_icon_asset_id,
                app_logo_asset_id,
                facebook_app_id,
                facebook_app_secret,
                google_api_key,
                update_eula_date,
                eula_version,
                landing_page_url,
                show_in_activities,
                activity_description,
                invite_welcome_text,
                invite_page_url,
                url_scheme,
                platforms,
                download_urls,
                category_ids,
                scoring_type,
                hint_cost,
                max_score,
                tickets_per_point,
                has_game_data,
                public_notifications,
                use_matching_algorithm,
                global_tickets,
                build_version,
                api_version,
                placement_name,
                placement_description,
                placement_size,
                placement_height,
                placement_width,
                placement_refresh_interval,
                create_object_store,
                public_content_approval,
                production_mode,
                minimum_session_length,
                session_gap_length,
                local_ads_enabled,
                sqoot_api_key,
                trilat_processing_type,
                max_sample_size,
                min_rssi,
                modules,
                authorized_count,
                authorized_servers,
                default_timezone,
                smtp_pass,
                meta_data,
                placement_meta_data,
                ips_floor,
                enable_apns_badge,
                include_in_report,
                default_app_filter_id,
                enable_welcome_email,
                apple_app_id,
                apple_team_id,
                apple_auth_key_id,
                apple_auth_key,
                apple_issuer_id,
                app_store_key_id,
                app_store_key,
                google_private_key_file,
                authorize_net_api_key,
                authorize_net_transaction_key,
                email_sender,
                smtp_user,
                smtp_host,
                vatom_business_id,
                vatom_rest_client_id,
                vatom_rest_secret_key,
                twilio_account_sid,
                twilio_auth_token,
                twilio_sender_phone_number,
                open_ai_secret_key,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                UpdateApplicationResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::UpdateApplicationActive {
            version,
            account_id,
            app_key,
            active,
        } => {
            info!("Performing a UpdateApplicationActive request on {:?}", (
                &version
            ));

            let result = client.update_application_active(
                version,
                account_id,
                app_key,
                active,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                UpdateApplicationActiveResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::UpdateApplicationPlacement {
            version,
            placement_id,
            device_id,
            account_id,
            name,
            description,
            size,
            height,
            width,
            refresh_interval,
            default_image_id,
            active,
        } => {
            info!("Performing a UpdateApplicationPlacement request on {:?}", (
                &version
            ));

            let result = client.update_application_placement(
                version,
                placement_id,
                device_id,
                account_id,
                name,
                description,
                size,
                height,
                width,
                refresh_interval,
                default_image_id,
                active,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                UpdateApplicationPlacementResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::UploadApplicationCertificate {
            version,
            app_key,
            device_id,
            account_id,
            certificate,
        } => {
            info!("Performing a UploadApplicationCertificate request on {:?}", (
                &version
            ));

            let result = client.upload_application_certificate(
                version,
                app_key,
                device_id,
                account_id,
                certificate,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                UploadApplicationCertificateResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::CreateApplicationConfig {
            version,
            account_id,
            app_key,
            config_version,
            asset_id,
            retailer_id,
            retailer_location_id,
            udid,
        } => {
            info!("Performing a CreateApplicationConfig request on {:?}", (
                &version
            ));

            let result = client.create_application_config(
                version,
                account_id,
                app_key,
                config_version,
                asset_id,
                retailer_id,
                retailer_location_id,
                udid,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                CreateApplicationConfigResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::DeleteApplicationConfig {
            version,
            account_id,
            config_id,
        } => {
            info!("Performing a DeleteApplicationConfig request on {:?}", (
                &version
            ));

            let result = client.delete_application_config(
                version,
                account_id,
                config_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                DeleteApplicationConfigResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetApplicationConfig {
            version,
            account_id,
            config_id,
        } => {
            info!("Performing a GetApplicationConfig request on {:?}", (
                &version
            ));

            let result = client.get_application_config(
                version,
                account_id,
                config_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetApplicationConfigResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetApplicationConfigByConfigVersion {
            version,
            app_key,
            config_version,
            retailer_id,
            retailer_location_id,
            udid,
            allow_older_versions,
        } => {
            info!("Performing a GetApplicationConfigByConfigVersion request on {:?}", (
                &version
            ));

            let result = client.get_application_config_by_config_version(
                version,
                app_key,
                config_version,
                retailer_id,
                retailer_location_id,
                udid,
                allow_older_versions,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetApplicationConfigByConfigVersionResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::SearchApplicationConfig {
            version,
            account_id,
            app_key,
            retailer_id,
            retailer_location_id,
            udid,
            config_version,
            sort_field,
            descending,
            start,
            limit,
        } => {
            info!("Performing a SearchApplicationConfig request on {:?}", (
                &version
            ));

            let result = client.search_application_config(
                version,
                account_id,
                app_key,
                retailer_id,
                retailer_location_id,
                udid,
                config_version,
                sort_field,
                descending,
                start,
                limit,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                SearchApplicationConfigResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::UpdateApplicationConfig {
            version,
            account_id,
            config_id,
            app_key,
            config_version,
            asset_id,
            retailer_id,
            retailer_location_id,
            udid,
        } => {
            info!("Performing a UpdateApplicationConfig request on {:?}", (
                &version
            ));

            let result = client.update_application_config(
                version,
                account_id,
                config_id,
                app_key,
                config_version,
                asset_id,
                retailer_id,
                retailer_location_id,
                udid,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                UpdateApplicationConfigResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::AssetMorph {
            version,
            offer_id,
            ad_size,
            creative_id,
            width,
            height,
            background_size,
            template,
        } => {
            info!("Performing a AssetMorph request on {:?}", (
                &version
            ));

            let result = client.asset_morph(
                version,
                offer_id,
                ad_size,
                creative_id,
                width,
                height,
                background_size,
                template,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                AssetMorphResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::CreateAsset {
            version,
            return_nulls,
            device_id,
            account_id,
            album_id,
            collection_id,
            add_to_default_album,
            add_to_media_library,
            version_code,
            version_name,
            meta_data,
            caption,
            asset_type,
            approval_status,
            assigned_account_id,
            media,
            media_url,
            media_string,
            media_string_file_name,
            media_string_content_type,
            media_height,
            media_width,
            attached_media,
            attached_media_url,
            attached_media_string,
            attached_media_string_file_name,
            attached_media_string_content_type,
            attached_media_height,
            attached_media_width,
            location_description,
            app,
            app_key,
            search_tags,
            latitude,
            longitude,
        } => {
            info!("Performing a CreateAsset request on {:?}", (
                &version
            ));

            let result = client.create_asset(
                version,
                return_nulls,
                device_id,
                account_id,
                album_id,
                collection_id,
                add_to_default_album,
                add_to_media_library,
                version_code,
                version_name,
                meta_data,
                caption,
                asset_type,
                approval_status,
                assigned_account_id,
                media,
                media_url,
                media_string,
                media_string_file_name,
                media_string_content_type,
                media_height,
                media_width,
                attached_media,
                attached_media_url,
                attached_media_string,
                attached_media_string_file_name,
                attached_media_string_content_type,
                attached_media_height,
                attached_media_width,
                location_description,
                app,
                app_key,
                search_tags,
                latitude,
                longitude,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                CreateAssetResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::DeleteAsset {
            version,
            asset_id,
            device_id,
            account_id,
            latitude,
            longitude,
        } => {
            info!("Performing a DeleteAsset request on {:?}", (
                &version
            ));

            let result = client.delete_asset(
                version,
                asset_id,
                device_id,
                account_id,
                latitude,
                longitude,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                DeleteAssetResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetAsset {
            version,
            asset_id,
            device_id,
            account_id,
            note_descending,
        } => {
            info!("Performing a GetAsset request on {:?}", (
                &version
            ));

            let result = client.get_asset(
                version,
                asset_id,
                device_id,
                account_id,
                note_descending,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetAssetResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::RemoveAsset {
            version,
            asset_id,
            device_id,
            account_id,
            album_id,
            collection_id,
            remove_from_default_albums,
            latitude,
            longitude,
        } => {
            info!("Performing a RemoveAsset request on {:?}", (
                &version
            ));

            let result = client.remove_asset(
                version,
                asset_id,
                device_id,
                account_id,
                album_id,
                collection_id,
                remove_from_default_albums,
                latitude,
                longitude,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                RemoveAssetResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::SearchAssets {
            version,
            device_id,
            account_id,
            album_ids,
            asset_ids,
            app_key,
            media_type,
            mime_type,
            keyword,
            version_code,
            version_name,
            updated_since,
            updated_before,
            sort_field,
            descending,
            search_media_library,
            filter_by_billable,
            active_only,
            return_app,
            start,
            limit,
            search_mode,
            asset_type,
            approval_status,
            assigned_account_id,
        } => {
            info!("Performing a SearchAssets request on {:?}", (
                &version
            ));

            let result = client.search_assets(
                version,
                device_id,
                account_id,
                album_ids,
                asset_ids,
                app_key,
                media_type,
                mime_type,
                keyword,
                version_code,
                version_name,
                updated_since,
                updated_before,
                sort_field,
                descending,
                search_media_library,
                filter_by_billable,
                active_only,
                return_app,
                start,
                limit,
                search_mode,
                asset_type,
                approval_status,
                assigned_account_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                SearchAssetsResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::UpdateAsset {
            version,
            asset_id,
            device_id,
            account_id,
            album_id,
            attached_asset_id,
            version_code,
            version_name,
            meta_data,
            caption,
            asset_type,
            approval_status,
            assigned_account_id,
            media,
            media_url,
            media_string,
            media_string_file_name,
            media_string_content_type,
            media_height,
            media_width,
            attached_media,
            attached_media_url,
            attached_media_string,
            attached_media_string_file_name,
            attached_media_string_content_type,
            attached_media_height,
            attached_media_width,
            location_description,
            search_tags,
            app_key,
            latitude,
            longitude,
        } => {
            info!("Performing a UpdateAsset request on {:?}", (
                &version
            ));

            let result = client.update_asset(
                version,
                asset_id,
                device_id,
                account_id,
                album_id,
                attached_asset_id,
                version_code,
                version_name,
                meta_data,
                caption,
                asset_type,
                approval_status,
                assigned_account_id,
                media,
                media_url,
                media_string,
                media_string_file_name,
                media_string_content_type,
                media_height,
                media_width,
                attached_media,
                attached_media_url,
                attached_media_string,
                attached_media_string_file_name,
                attached_media_string_content_type,
                attached_media_height,
                attached_media_width,
                location_description,
                search_tags,
                app_key,
                latitude,
                longitude,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                UpdateAssetResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::AssetDownload {
            version,
            filename,
        } => {
            info!("Performing a AssetDownload request on {:?}", (
                &version,
                &filename
            ));

            let result = client.asset_download(
                version,
                filename,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                AssetDownloadResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::AssigmentAssigneeAccountSearch {
            version,
            account_id,
            keyword,
        } => {
            info!("Performing a AssigmentAssigneeAccountSearch request on {:?}", (
                &version
            ));

            let result = client.assigment_assignee_account_search(
                version,
                account_id,
                keyword,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                AssigmentAssigneeAccountSearchResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::AssignmentCreate {
            version,
            account_id,
            name,
            assignee_account_id,
            description,
            retailer_location_id,
            tags,
            active,
        } => {
            info!("Performing a AssignmentCreate request on {:?}", (
                &version
            ));

            let result = client.assignment_create(
                version,
                account_id,
                name,
                assignee_account_id,
                description,
                retailer_location_id,
                tags,
                active,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                AssignmentCreateResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::AssignmentDelete {
            version,
            account_id,
            assignment_id,
        } => {
            info!("Performing a AssignmentDelete request on {:?}", (
                &version
            ));

            let result = client.assignment_delete(
                version,
                account_id,
                assignment_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                AssignmentDeleteResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::AssignmentGet {
            version,
            account_id,
            assignment_id,
        } => {
            info!("Performing a AssignmentGet request on {:?}", (
                &version
            ));

            let result = client.assignment_get(
                version,
                account_id,
                assignment_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                AssignmentGetResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::AssignmentSearch {
            version,
            account_id,
            sort_field,
            descending,
            active_only,
            start,
            limit,
            creator_account_id,
            assignee_account_ids,
            retailer_location_ids,
            current_status_type,
            keyword,
        } => {
            info!("Performing a AssignmentSearch request on {:?}", (
                &version
            ));

            let result = client.assignment_search(
                version,
                account_id,
                sort_field,
                descending,
                active_only,
                start,
                limit,
                creator_account_id,
                assignee_account_ids,
                retailer_location_ids,
                current_status_type,
                keyword,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                AssignmentSearchResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::AssignmentStatusCreate {
            version,
            account_id,
            assignment_id,
            scheduled_notification_id,
            to_do,
            connection,
            method,
            status,
            closure,
            message,
            follow_up,
            active,
        } => {
            info!("Performing a AssignmentStatusCreate request on {:?}", (
                &version
            ));

            let result = client.assignment_status_create(
                version,
                account_id,
                assignment_id,
                scheduled_notification_id,
                to_do,
                connection,
                method,
                status,
                closure,
                message,
                follow_up,
                active,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                AssignmentStatusCreateResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::AssignmentStatusDelete {
            version,
            account_id,
            assignment_status_id,
        } => {
            info!("Performing a AssignmentStatusDelete request on {:?}", (
                &version
            ));

            let result = client.assignment_status_delete(
                version,
                account_id,
                assignment_status_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                AssignmentStatusDeleteResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::AssignmentStatusGet {
            version,
            account_id,
            assignment_status_id,
        } => {
            info!("Performing a AssignmentStatusGet request on {:?}", (
                &version
            ));

            let result = client.assignment_status_get(
                version,
                account_id,
                assignment_status_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                AssignmentStatusGetResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::AssignmentStatusSearch {
            version,
            account_id,
            sort_field,
            descending,
            active_only,
            start,
            limit,
            assignment_id,
            creator_account_id,
            assignee_account_id,
            retailer_location_id,
            status_type,
            keyword,
        } => {
            info!("Performing a AssignmentStatusSearch request on {:?}", (
                &version
            ));

            let result = client.assignment_status_search(
                version,
                account_id,
                sort_field,
                descending,
                active_only,
                start,
                limit,
                assignment_id,
                creator_account_id,
                assignee_account_id,
                retailer_location_id,
                status_type,
                keyword,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                AssignmentStatusSearchResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::AssignmentStatusUpdate {
            version,
            account_id,
            assignment_status_id,
            scheduled_notification_id,
            to_do,
            connection,
            method,
            status,
            closure,
            message,
            follow_up,
            active,
        } => {
            info!("Performing a AssignmentStatusUpdate request on {:?}", (
                &version
            ));

            let result = client.assignment_status_update(
                version,
                account_id,
                assignment_status_id,
                scheduled_notification_id,
                to_do,
                connection,
                method,
                status,
                closure,
                message,
                follow_up,
                active,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                AssignmentStatusUpdateResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::AssignmentUpdate {
            version,
            account_id,
            assignment_id,
            name,
            description,
            assignee_account_id,
            retailer_location_id,
            tags,
            active,
        } => {
            info!("Performing a AssignmentUpdate request on {:?}", (
                &version
            ));

            let result = client.assignment_update(
                version,
                account_id,
                assignment_id,
                name,
                description,
                assignee_account_id,
                retailer_location_id,
                tags,
                active,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                AssignmentUpdateResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::CreateAudience {
            version,
            account_id,
            name,
            description,
            search_tags,
            gender,
            age_groups,
            category_ids,
            application_ids,
            game_experience_level,
            devices,
            device_ids,
            device_versions,
            locations,
            radius,
            start_time_offset,
            end_time_offset,
            send_suggestion,
            associate_description,
            associate_type,
            associate_id,
            grouping_id,
            meta_data,
            visibility,
            audience_type,
            use_order,
            cohort_regions_data,
            app_key,
            trilateration_types,
            unique_name,
        } => {
            info!("Performing a CreateAudience request on {:?}", (
                &version
            ));

            let result = client.create_audience(
                version,
                account_id,
                name,
                description,
                search_tags,
                gender,
                age_groups,
                category_ids,
                application_ids,
                game_experience_level,
                devices,
                device_ids,
                device_versions,
                locations,
                radius,
                start_time_offset,
                end_time_offset,
                send_suggestion,
                associate_description,
                associate_type,
                associate_id,
                grouping_id,
                meta_data,
                visibility,
                audience_type,
                use_order,
                cohort_regions_data,
                app_key,
                trilateration_types,
                unique_name,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                CreateAudienceResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::DeleteAudience {
            version,
            account_id,
            audience_id,
        } => {
            info!("Performing a DeleteAudience request on {:?}", (
                &version
            ));

            let result = client.delete_audience(
                version,
                account_id,
                audience_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                DeleteAudienceResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetAgeGroups {
            version,
        } => {
            info!("Performing a GetAgeGroups request on {:?}", (
                &version
            ));

            let result = client.get_age_groups(
                version,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetAgeGroupsResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetAudience {
            version,
            account_id,
            audience_id,
            app_key,
            return_account_count,
            return_album_count,
            album_types_for_count,
        } => {
            info!("Performing a GetAudience request on {:?}", (
                &version
            ));

            let result = client.get_audience(
                version,
                account_id,
                audience_id,
                app_key,
                return_account_count,
                return_album_count,
                album_types_for_count,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetAudienceResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetAudienceList {
            version,
            account_id,
            album_ids,
            keyword,
            keyword_fields,
            sort_field,
            descending,
            start,
            limit,
            send_suggestion,
            active_only,
            group_by_grouping_id,
            app_key,
            return_global,
            exact_keyword,
            audience_type,
            audience_types,
            return_account_count,
            return_album_count,
            album_types_for_count,
        } => {
            info!("Performing a GetAudienceList request on {:?}", (
                &version
            ));

            let result = client.get_audience_list(
                version,
                account_id,
                album_ids,
                keyword,
                keyword_fields,
                sort_field,
                descending,
                start,
                limit,
                send_suggestion,
                active_only,
                group_by_grouping_id,
                app_key,
                return_global,
                exact_keyword,
                audience_type,
                audience_types,
                return_account_count,
                return_album_count,
                album_types_for_count,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetAudienceListResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetDevices {
            version,
            include_inactive,
        } => {
            info!("Performing a GetDevices request on {:?}", (
                &version
            ));

            let result = client.get_devices(
                version,
                include_inactive,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetDevicesResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetExperiences {
            version,
        } => {
            info!("Performing a GetExperiences request on {:?}", (
                &version
            ));

            let result = client.get_experiences(
                version,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetExperiencesResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetGroupedAudiences {
            version,
            account_id,
            audience_grouping_id,
        } => {
            info!("Performing a GetGroupedAudiences request on {:?}", (
                &version
            ));

            let result = client.get_grouped_audiences(
                version,
                account_id,
                audience_grouping_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetGroupedAudiencesResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::ListByAccount {
            version,
            account_id,
            limit,
            suggestion_type,
        } => {
            info!("Performing a ListByAccount request on {:?}", (
                &version
            ));

            let result = client.list_by_account(
                version,
                account_id,
                limit,
                suggestion_type,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                ListByAccountResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::ListByAudience {
            version,
            limit,
            gender,
            age,
            category_ids,
            latitude,
            longitude,
        } => {
            info!("Performing a ListByAudience request on {:?}", (
                &version
            ));

            let result = client.list_by_audience(
                version,
                limit,
                gender,
                age,
                category_ids,
                latitude,
                longitude,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                ListByAudienceResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::ListLastestByAccount {
            version,
            account_id,
            timeframe,
            suggestion_type,
        } => {
            info!("Performing a ListLastestByAccount request on {:?}", (
                &version
            ));

            let result = client.list_lastest_by_account(
                version,
                account_id,
                timeframe,
                suggestion_type,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                ListLastestByAccountResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::SendByAccount {
            version,
            account_id,
            latitude,
            longitude,
        } => {
            info!("Performing a SendByAccount request on {:?}", (
                &version
            ));

            let result = client.send_by_account(
                version,
                account_id,
                latitude,
                longitude,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                SendByAccountResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::UpdateAudience {
            version,
            account_id,
            audience_id,
            name,
            description,
            search_tags,
            gender,
            age_groups,
            category_ids,
            application_ids,
            game_experience_level,
            devices,
            device_ids,
            device_versions,
            locations,
            radius,
            active,
            send_suggestion,
            start_time_offset,
            end_time_offset,
            associate_description,
            associate_type,
            associate_id,
            grouping_id,
            meta_data,
            visibility,
            audience_type,
            use_order,
            cohort_regions_data,
            app_key,
            trilateration_types,
            unique_name,
        } => {
            info!("Performing a UpdateAudience request on {:?}", (
                &version
            ));

            let result = client.update_audience(
                version,
                account_id,
                audience_id,
                name,
                description,
                search_tags,
                gender,
                age_groups,
                category_ids,
                application_ids,
                game_experience_level,
                devices,
                device_ids,
                device_versions,
                locations,
                radius,
                active,
                send_suggestion,
                start_time_offset,
                end_time_offset,
                associate_description,
                associate_type,
                associate_id,
                grouping_id,
                meta_data,
                visibility,
                audience_type,
                use_order,
                cohort_regions_data,
                app_key,
                trilateration_types,
                unique_name,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                UpdateAudienceResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::CreateBid {
            version,
            biddable_type,
            biddable_id,
            amount_per_view,
            amount_per_action,
            budget_amount,
            budget_schedule,
            device_id,
            account_id,
        } => {
            info!("Performing a CreateBid request on {:?}", (
                &version
            ));

            let result = client.create_bid(
                version,
                biddable_type,
                biddable_id,
                amount_per_view,
                amount_per_action,
                budget_amount,
                budget_schedule,
                device_id,
                account_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                CreateBidResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::DeleteBid {
            version,
            bid_id,
            device_id,
            account_id,
        } => {
            info!("Performing a DeleteBid request on {:?}", (
                &version
            ));

            let result = client.delete_bid(
                version,
                bid_id,
                device_id,
                account_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                DeleteBidResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetBid {
            version,
            bid_id,
            device_id,
            account_id,
        } => {
            info!("Performing a GetBid request on {:?}", (
                &version
            ));

            let result = client.get_bid(
                version,
                bid_id,
                device_id,
                account_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetBidResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::UpdateBid {
            version,
            bid_id,
            device_id,
            account_id,
            amount_per_view,
            amount_per_action,
            budget_amount,
            budget_schedule,
        } => {
            info!("Performing a UpdateBid request on {:?}", (
                &version
            ));

            let result = client.update_bid(
                version,
                bid_id,
                device_id,
                account_id,
                amount_per_view,
                amount_per_action,
                budget_amount,
                budget_schedule,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                UpdateBidResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::CreateBillableEntity {
            version,
            device_id,
            account_id,
            name,
            street_address,
            street_address2,
            city,
            state,
            postal_code,
            business_phone,
            business_phone_ext,
            authorize_net_api_key,
            authorize_net_transaction_key,
        } => {
            info!("Performing a CreateBillableEntity request on {:?}", (
                &version
            ));

            let result = client.create_billable_entity(
                version,
                device_id,
                account_id,
                name,
                street_address,
                street_address2,
                city,
                state,
                postal_code,
                business_phone,
                business_phone_ext,
                authorize_net_api_key,
                authorize_net_transaction_key,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                CreateBillableEntityResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::DeleteBillableEntity {
            version,
            device_id,
            account_id,
        } => {
            info!("Performing a DeleteBillableEntity request on {:?}", (
                &version
            ));

            let result = client.delete_billable_entity(
                version,
                device_id,
                account_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                DeleteBillableEntityResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetBillableEntity {
            version,
            device_id,
            account_id,
            include_counts,
            include_payments,
        } => {
            info!("Performing a GetBillableEntity request on {:?}", (
                &version
            ));

            let result = client.get_billable_entity(
                version,
                device_id,
                account_id,
                include_counts,
                include_payments,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetBillableEntityResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::UpdateBillableEntity {
            version,
            device_id,
            account_id,
            name,
            street_address,
            street_address2,
            city,
            state,
            postal_code,
            business_phone,
            business_phone_ext,
            authorize_net_api_key,
            authorize_net_transaction_key,
        } => {
            info!("Performing a UpdateBillableEntity request on {:?}", (
                &version
            ));

            let result = client.update_billable_entity(
                version,
                device_id,
                account_id,
                name,
                street_address,
                street_address2,
                city,
                state,
                postal_code,
                business_phone,
                business_phone_ext,
                authorize_net_api_key,
                authorize_net_transaction_key,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                UpdateBillableEntityResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::AddPaymentMethod {
            version,
            account_id,
            payment_method_id,
            account_name,
            first_name,
            last_name,
            address,
            city,
            state,
            postal_code,
            country,
            phone,
            credit_card_number,
            expiration_date,
            ccv,
            account_number,
            bank_name,
            routing_number,
            default_payment_method,
            payment_method_nickname,
            tax_id,
            provider_customer_profile_id,
            provider_payment_profile_id,
            meta_data,
        } => {
            info!("Performing a AddPaymentMethod request on {:?}", (
                &version
            ));

            let result = client.add_payment_method(
                version,
                account_id,
                payment_method_id,
                account_name,
                first_name,
                last_name,
                address,
                city,
                state,
                postal_code,
                country,
                phone,
                credit_card_number,
                expiration_date,
                ccv,
                account_number,
                bank_name,
                routing_number,
                default_payment_method,
                payment_method_nickname,
                tax_id,
                provider_customer_profile_id,
                provider_payment_profile_id,
                meta_data,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                AddPaymentMethodResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::CreatePaymentMethod {
            version,
            account_id,
            account_name,
            first_name,
            last_name,
            address,
            city,
            state,
            postal_code,
            country,
            phone,
            credit_card_number,
            expiration_date,
            ccv,
            account_number,
            bank_name,
            routing_number,
            payment_method_nickname,
            tax_id,
            default_payment_method,
            auth_token,
            provider,
            provider_customer_profile_id,
            provider_payment_profile_id,
            meta_data,
            app_key,
        } => {
            info!("Performing a CreatePaymentMethod request on {:?}", (
                &version
            ));

            let result = client.create_payment_method(
                version,
                account_id,
                account_name,
                first_name,
                last_name,
                address,
                city,
                state,
                postal_code,
                country,
                phone,
                credit_card_number,
                expiration_date,
                ccv,
                account_number,
                bank_name,
                routing_number,
                payment_method_nickname,
                tax_id,
                default_payment_method,
                auth_token,
                provider,
                provider_customer_profile_id,
                provider_payment_profile_id,
                meta_data,
                app_key,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                CreatePaymentMethodResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::CreateSmartContract {
            version,
            account_id,
            token_name,
            token_symbol,
            payment_method_id,
        } => {
            info!("Performing a CreateSmartContract request on {:?}", (
                &version
            ));

            let result = client.create_smart_contract(
                version,
                account_id,
                token_name,
                token_symbol,
                payment_method_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                CreateSmartContractResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetCryptoBalance {
            version,
            account_id,
            owner_account_id,
            payment_method_id,
        } => {
            info!("Performing a GetCryptoBalance request on {:?}", (
                &version
            ));

            let result = client.get_crypto_balance(
                version,
                account_id,
                owner_account_id,
                payment_method_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetCryptoBalanceResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetPaymentMethod {
            version,
            account_id,
            payment_method_id,
            get_current_balance,
        } => {
            info!("Performing a GetPaymentMethod request on {:?}", (
                &version
            ));

            let result = client.get_payment_method(
                version,
                account_id,
                payment_method_id,
                get_current_balance,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetPaymentMethodResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::SearchPaymentMethod {
            version,
            account_id,
            provider,
            param_type,
            keyword,
            sort_field,
            descending,
            start,
            limit,
        } => {
            info!("Performing a SearchPaymentMethod request on {:?}", (
                &version
            ));

            let result = client.search_payment_method(
                version,
                account_id,
                provider,
                param_type,
                keyword,
                sort_field,
                descending,
                start,
                limit,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                SearchPaymentMethodResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetStatusCsv {
            version,
            account_id,
            batch_id,
            response_group,
            start,
            limit,
        } => {
            info!("Performing a GetStatusCsv request on {:?}", (
                &version
            ));

            let result = client.get_status_csv(
                version,
                account_id,
                batch_id,
                response_group,
                start,
                limit,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetStatusCsvResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::ListStatusCsv {
            version,
            account_id,
            start,
            limit,
        } => {
            info!("Performing a ListStatusCsv request on {:?}", (
                &version
            ));

            let result = client.list_status_csv(
                version,
                account_id,
                start,
                limit,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                ListStatusCsvResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::StatusCsv {
            version,
            account_id,
            batch_id,
        } => {
            info!("Performing a StatusCsv request on {:?}", (
                &version
            ));

            let result = client.status_csv(
                version,
                account_id,
                batch_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                StatusCsvResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::UploadCsv {
            version,
            account_id,
            upload_type,
            import_file,
            file_format,
            app_key,
        } => {
            info!("Performing a UploadCsv request on {:?}", (
                &version
            ));

            let result = client.upload_csv(
                version,
                account_id,
                upload_type,
                import_file,
                file_format,
                app_key,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                UploadCsvResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::CreateCargoType {
            version,
            body,
        } => {
            info!("Performing a CreateCargoType request on {:?}", (
                &version
            ));

            let result = client.create_cargo_type(
                version,
                body,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                CreateCargoTypeResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::SearchCargoTypes {
            version,
            sort_field,
            descending,
            start,
            limit,
            active_only,
            retailer_id,
            hub_id,
        } => {
            info!("Performing a SearchCargoTypes request on {:?}", (
                &version
            ));

            let result = client.search_cargo_types(
                version,
                sort_field,
                descending,
                start,
                limit,
                active_only,
                retailer_id,
                hub_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                SearchCargoTypesResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::DeleteCargoType {
            version,
            cargo_type_id,
        } => {
            prompt(args.force, "This will delete the given entry, are you sure?")?;
            info!("Performing a DeleteCargoType request on {:?}", (
                &version,
                &cargo_type_id
            ));

            let result = client.delete_cargo_type(
                version,
                cargo_type_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                DeleteCargoTypeResponse::SuccessfulOperation
                => "SuccessfulOperation\n".to_string()
                    ,
            }
        }
        Operation::GetCargoType {
            version,
            cargo_type_id,
        } => {
            info!("Performing a GetCargoType request on {:?}", (
                &version,
                &cargo_type_id
            ));

            let result = client.get_cargo_type(
                version,
                cargo_type_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetCargoTypeResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::UpdateCargoType {
            version,
            cargo_type_id,
            body,
        } => {
            info!("Performing a UpdateCargoType request on {:?}", (
                &version,
                &cargo_type_id
            ));

            let result = client.update_cargo_type(
                version,
                cargo_type_id,
                body,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                UpdateCargoTypeResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::SearchCarriers {
            version,
            keyword,
            descending,
            start,
            limit,
            active_only,
        } => {
            info!("Performing a SearchCarriers request on {:?}", (
                &version
            ));

            let result = client.search_carriers(
                version,
                keyword,
                descending,
                start,
                limit,
                active_only,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                SearchCarriersResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::CategoryDistanceSearch {
            version,
            account_id,
            keyword,
            app_key,
            category_ids,
            parent_category_ids,
            root_only,
            sort_field,
            response_group,
            descending,
            start,
            limit,
            active_only,
            return_external,
            exact_match,
            param_type,
            external_type,
            min_offer_count,
            latitude,
            longitude,
            range,
        } => {
            info!("Performing a CategoryDistanceSearch request on {:?}", (
                &version
            ));

            let result = client.category_distance_search(
                version,
                account_id,
                keyword,
                app_key,
                category_ids,
                parent_category_ids,
                root_only,
                sort_field,
                response_group,
                descending,
                start,
                limit,
                active_only,
                return_external,
                exact_match,
                param_type,
                external_type,
                min_offer_count,
                latitude,
                longitude,
                range,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                CategoryDistanceSearchResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::CreateCategory {
            version,
            account_id,
            name,
            app_key,
            parent_category_id,
            description,
            param_type,
            asset_id,
            external_id,
            external_type,
            external_category_slug,
            sqoot_slug,
            active,
            meta_data,
            search_tags,
        } => {
            info!("Performing a CreateCategory request on {:?}", (
                &version
            ));

            let result = client.create_category(
                version,
                account_id,
                name,
                app_key,
                parent_category_id,
                description,
                param_type,
                asset_id,
                external_id,
                external_type,
                external_category_slug,
                sqoot_slug,
                active,
                meta_data,
                search_tags,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                CreateCategoryResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::DeleteCategory {
            version,
            account_id,
            category_id,
        } => {
            info!("Performing a DeleteCategory request on {:?}", (
                &version
            ));

            let result = client.delete_category(
                version,
                account_id,
                category_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                DeleteCategoryResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::DuplicateCategory {
            version,
            account_id,
            category_id,
            app_key,
            parent_category_id,
        } => {
            info!("Performing a DuplicateCategory request on {:?}", (
                &version
            ));

            let result = client.duplicate_category(
                version,
                account_id,
                category_id,
                app_key,
                parent_category_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                DuplicateCategoryResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetCategory {
            version,
            category_id,
            return_external,
        } => {
            info!("Performing a GetCategory request on {:?}", (
                &version
            ));

            let result = client.get_category(
                version,
                category_id,
                return_external,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetCategoryResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::SearchCategories {
            version,
            account_id,
            keyword,
            app_key,
            category_id,
            category_ids,
            parent_category_ids,
            root_only,
            sort_field,
            response_group,
            descending,
            start,
            limit,
            active_only,
            return_external,
            exact_match,
            param_type,
            external_type,
            exclude_external_type,
            min_offer_count,
            search_depth,
            search_mode,
        } => {
            info!("Performing a SearchCategories request on {:?}", (
                &version
            ));

            let result = client.search_categories(
                version,
                account_id,
                keyword,
                app_key,
                category_id,
                category_ids,
                parent_category_ids,
                root_only,
                sort_field,
                response_group,
                descending,
                start,
                limit,
                active_only,
                return_external,
                exact_match,
                param_type,
                external_type,
                exclude_external_type,
                min_offer_count,
                search_depth,
                search_mode,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                SearchCategoriesResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::UpdateCategory {
            version,
            account_id,
            category_id,
            parent_category_id,
            name,
            description,
            param_type,
            asset_id,
            external_id,
            external_type,
            external_category_slug,
            sqoot_slug,
            active,
            meta_data,
            search_tags,
        } => {
            info!("Performing a UpdateCategory request on {:?}", (
                &version
            ));

            let result = client.update_category(
                version,
                account_id,
                category_id,
                parent_category_id,
                name,
                description,
                param_type,
                asset_id,
                external_id,
                external_type,
                external_category_slug,
                sqoot_slug,
                active,
                meta_data,
                search_tags,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                UpdateCategoryResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::AddConnectionToGroup {
            version,
            return_nulls,
            group_id,
            device_id,
            account_id,
            connection_id,
            connection_account_id,
            pending_id,
            latitude,
            longitude,
        } => {
            info!("Performing a AddConnectionToGroup request on {:?}", (
                &version
            ));

            let result = client.add_connection_to_group(
                version,
                return_nulls,
                group_id,
                device_id,
                account_id,
                connection_id,
                connection_account_id,
                pending_id,
                latitude,
                longitude,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                AddConnectionToGroupResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::AddConnectionsToGroup {
            version,
            connection_group_id,
            device_id,
            account_id,
            connection_ids,
            connection_account_ids,
            latitude,
            longitude,
        } => {
            info!("Performing a AddConnectionsToGroup request on {:?}", (
                &version
            ));

            let result = client.add_connections_to_group(
                version,
                connection_group_id,
                device_id,
                account_id,
                connection_ids,
                connection_account_ids,
                latitude,
                longitude,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                AddConnectionsToGroupResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::AddSubGroups {
            version,
            return_nulls,
            group_id,
            sub_group_ids,
            device_id,
            account_id,
            latitude,
            longitude,
        } => {
            info!("Performing a AddSubGroups request on {:?}", (
                &version
            ));

            let result = client.add_sub_groups(
                version,
                return_nulls,
                group_id,
                sub_group_ids,
                device_id,
                account_id,
                latitude,
                longitude,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                AddSubGroupsResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::CreateOrUpdateConnection {
            version,
            device_id,
            account_id,
            connection_id,
            connection_account_id,
            pending_id,
            group_id,
            game_type,
            app_key,
            is_trusted,
            ignore_friend_request,
            is_contact,
            is_blocked,
            is_following,
            connection_response,
        } => {
            info!("Performing a CreateOrUpdateConnection request on {:?}", (
                &version
            ));

            let result = client.create_or_update_connection(
                version,
                device_id,
                account_id,
                connection_id,
                connection_account_id,
                pending_id,
                group_id,
                game_type,
                app_key,
                is_trusted,
                ignore_friend_request,
                is_contact,
                is_blocked,
                is_following,
                connection_response,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                CreateOrUpdateConnectionResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::CreateOrUpdateGroup {
            version,
            return_nulls,
            device_id,
            account_id,
            name,
            group_id,
            asset_id,
            connections,
            description,
            can_view_profile_info,
            can_view_game_info,
            can_view_friend_info,
            active,
            latitude,
            longitude,
        } => {
            info!("Performing a CreateOrUpdateGroup request on {:?}", (
                &version
            ));

            let result = client.create_or_update_group(
                version,
                return_nulls,
                device_id,
                account_id,
                name,
                group_id,
                asset_id,
                connections,
                description,
                can_view_profile_info,
                can_view_game_info,
                can_view_friend_info,
                active,
                latitude,
                longitude,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                CreateOrUpdateGroupResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::FollowAccept {
            version,
            account_id,
            connection_account_id,
            app_key,
        } => {
            info!("Performing a FollowAccept request on {:?}", (
                &version
            ));

            let result = client.follow_accept(
                version,
                account_id,
                connection_account_id,
                app_key,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                FollowAcceptResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::FollowReject {
            version,
            account_id,
            connection_account_id,
            app_key,
        } => {
            info!("Performing a FollowReject request on {:?}", (
                &version
            ));

            let result = client.follow_reject(
                version,
                account_id,
                connection_account_id,
                app_key,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                FollowRejectResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::FollowRemove {
            version,
            account_id,
            connection_account_id,
            app_key,
        } => {
            info!("Performing a FollowRemove request on {:?}", (
                &version
            ));

            let result = client.follow_remove(
                version,
                account_id,
                connection_account_id,
                app_key,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                FollowRemoveResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::FollowRequest {
            version,
            account_id,
            connection_account_id,
            app_key,
            approval_needed,
        } => {
            info!("Performing a FollowRequest request on {:?}", (
                &version
            ));

            let result = client.follow_request(
                version,
                account_id,
                connection_account_id,
                app_key,
                approval_needed,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                FollowRequestResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::FriendAccept {
            version,
            friend_account_id,
            notify_friend,
            device_id,
            account_id,
            game_type,
            app_key,
            notification_message,
        } => {
            info!("Performing a FriendAccept request on {:?}", (
                &version
            ));

            let result = client.friend_accept(
                version,
                friend_account_id,
                notify_friend,
                device_id,
                account_id,
                game_type,
                app_key,
                notification_message,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                FriendAcceptResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::FriendReject {
            version,
            friend_account_id,
            device_id,
            account_id,
            game_type,
            app_key,
            notify_friend,
            notification_message,
        } => {
            info!("Performing a FriendReject request on {:?}", (
                &version
            ));

            let result = client.friend_reject(
                version,
                friend_account_id,
                device_id,
                account_id,
                game_type,
                app_key,
                notify_friend,
                notification_message,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                FriendRejectResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::FriendRemove {
            version,
            friend_account_id,
            device_id,
            account_id,
            notify_friend,
            remove_from_groups,
        } => {
            info!("Performing a FriendRemove request on {:?}", (
                &version
            ));

            let result = client.friend_remove(
                version,
                friend_account_id,
                device_id,
                account_id,
                notify_friend,
                remove_from_groups,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                FriendRemoveResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::FriendRequest {
            version,
            friend_account_id,
            device_id,
            account_id,
            game_type,
            app_key,
            notification_message,
        } => {
            info!("Performing a FriendRequest request on {:?}", (
                &version
            ));

            let result = client.friend_request(
                version,
                friend_account_id,
                device_id,
                account_id,
                game_type,
                app_key,
                notification_message,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                FriendRequestResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetConnectionSentFriendRequests {
            version,
            device_id,
            account_id,
        } => {
            info!("Performing a GetConnectionSentFriendRequests request on {:?}", (
                &version
            ));

            let result = client.get_connection_sent_friend_requests(
                version,
                device_id,
                account_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetConnectionSentFriendRequestsResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetConnections {
            version,
            return_nulls,
            filter,
            sort_field,
            descending,
            start,
            limit,
            device_id,
            account_id,
            connection_account_id,
            q,
            keyword,
            _i,
            _l,
            latitude,
            longitude,
        } => {
            info!("Performing a GetConnections request on {:?}", (
                &version
            ));

            let result = client.get_connections(
                version,
                return_nulls,
                filter,
                sort_field,
                descending,
                start,
                limit,
                device_id,
                account_id,
                connection_account_id,
                q,
                keyword,
                _i,
                _l,
                latitude,
                longitude,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetConnectionsResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetGroupDetails {
            version,
            combine_connections,
            device_id,
            account_id,
            group_id,
            latitude,
            longitude,
        } => {
            info!("Performing a GetGroupDetails request on {:?}", (
                &version
            ));

            let result = client.get_group_details(
                version,
                combine_connections,
                device_id,
                account_id,
                group_id,
                latitude,
                longitude,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetGroupDetailsResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GroupSearch {
            version,
            sort_field,
            descending,
            active_only,
            start,
            limit,
            device_id,
            account_id,
            latitude,
            longitude,
            keyword,
        } => {
            info!("Performing a GroupSearch request on {:?}", (
                &version
            ));

            let result = client.group_search(
                version,
                sort_field,
                descending,
                active_only,
                start,
                limit,
                device_id,
                account_id,
                latitude,
                longitude,
                keyword,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GroupSearchResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::RemoveConnectionFromGroup {
            version,
            return_nulls,
            group_id,
            device_id,
            account_id,
            connection_id,
            connection_account_id,
            pending_id,
            latitude,
            longitude,
        } => {
            info!("Performing a RemoveConnectionFromGroup request on {:?}", (
                &version
            ));

            let result = client.remove_connection_from_group(
                version,
                return_nulls,
                group_id,
                device_id,
                account_id,
                connection_id,
                connection_account_id,
                pending_id,
                latitude,
                longitude,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                RemoveConnectionFromGroupResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::RemoveConnectionsFromGroup {
            version,
            connection_group_id,
            device_id,
            account_id,
            connection_ids,
            connection_account_ids,
            latitude,
            longitude,
        } => {
            info!("Performing a RemoveConnectionsFromGroup request on {:?}", (
                &version
            ));

            let result = client.remove_connections_from_group(
                version,
                connection_group_id,
                device_id,
                account_id,
                connection_ids,
                connection_account_ids,
                latitude,
                longitude,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                RemoveConnectionsFromGroupResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::RemoveGroup {
            version,
            return_nulls,
            group_id,
            device_id,
            account_id,
            latitude,
            longitude,
        } => {
            info!("Performing a RemoveGroup request on {:?}", (
                &version
            ));

            let result = client.remove_group(
                version,
                return_nulls,
                group_id,
                device_id,
                account_id,
                latitude,
                longitude,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                RemoveGroupResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::RemoveSubGroups {
            version,
            return_nulls,
            group_id,
            sub_group_ids,
            device_id,
            account_id,
            latitude,
            longitude,
        } => {
            info!("Performing a RemoveSubGroups request on {:?}", (
                &version
            ));

            let result = client.remove_sub_groups(
                version,
                return_nulls,
                group_id,
                sub_group_ids,
                device_id,
                account_id,
                latitude,
                longitude,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                RemoveSubGroupsResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::SearchConnections {
            version,
            return_nulls,
            start,
            limit,
            device_id,
            account_id,
            q,
            keyword,
            latitude,
            longitude,
            game_type,
            app_key,
            _i,
            _l,
            sort_field,
            has_location,
        } => {
            info!("Performing a SearchConnections request on {:?}", (
                &version
            ));

            let result = client.search_connections(
                version,
                return_nulls,
                start,
                limit,
                device_id,
                account_id,
                q,
                keyword,
                latitude,
                longitude,
                game_type,
                app_key,
                _i,
                _l,
                sort_field,
                has_location,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                SearchConnectionsResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::AddOrUpdateAlbumContest {
            version,
            public_read,
            public_write,
            public_delete,
            public_add,
            visibility,
            include_friend_group,
            device_id,
            account_id,
            game_type,
            app_key,
            contest_type,
            album_contest_id,
            title,
            description,
            album_id1,
            remove_album1,
            album_id2,
            remove_album2,
            start_date,
            end_date,
            location_description,
            connection_ids_to_add,
            connection_group_ids_to_add,
            latitude,
            longitude,
        } => {
            info!("Performing a AddOrUpdateAlbumContest request on {:?}", (
                &version
            ));

            let result = client.add_or_update_album_contest(
                version,
                public_read,
                public_write,
                public_delete,
                public_add,
                visibility,
                include_friend_group,
                device_id,
                account_id,
                game_type,
                app_key,
                contest_type,
                album_contest_id,
                title,
                description,
                album_id1,
                remove_album1,
                album_id2,
                remove_album2,
                start_date,
                end_date,
                location_description,
                connection_ids_to_add,
                connection_group_ids_to_add,
                latitude,
                longitude,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                AddOrUpdateAlbumContestResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::ApproveAlbumContest {
            version,
            album_contest_id,
            approval_status,
            device_id,
            account_id,
        } => {
            info!("Performing a ApproveAlbumContest request on {:?}", (
                &version
            ));

            let result = client.approve_album_contest(
                version,
                album_contest_id,
                approval_status,
                device_id,
                account_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                ApproveAlbumContestResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::DeleteContest {
            version,
            album_contest_id,
            device_id,
            account_id,
            latitude,
            longitude,
        } => {
            info!("Performing a DeleteContest request on {:?}", (
                &version
            ));

            let result = client.delete_contest(
                version,
                album_contest_id,
                device_id,
                account_id,
                latitude,
                longitude,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                DeleteContestResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetAlbumContest {
            version,
            album_contest_id,
            device_id,
            account_id,
            latitude,
            longitude,
        } => {
            info!("Performing a GetAlbumContest request on {:?}", (
                &version
            ));

            let result = client.get_album_contest(
                version,
                album_contest_id,
                device_id,
                account_id,
                latitude,
                longitude,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetAlbumContestResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetAlbumContests {
            version,
            filter,
            sort_field,
            descending,
            start,
            limit,
            device_id,
            account_id,
            game_type,
            app_key,
            app_type,
            contest_type,
            owner_id,
            q,
            keyword,
            _i,
            _l,
            date_created,
            latitude,
            longitude,
        } => {
            info!("Performing a GetAlbumContests request on {:?}", (
                &version
            ));

            let result = client.get_album_contests(
                version,
                filter,
                sort_field,
                descending,
                start,
                limit,
                device_id,
                account_id,
                game_type,
                app_key,
                app_type,
                contest_type,
                owner_id,
                q,
                keyword,
                _i,
                _l,
                date_created,
                latitude,
                longitude,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetAlbumContestsResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::VoteOnAlbumContest {
            version,
            album_contest_id,
            album_id,
            device_id,
            account_id,
            contest_type,
            latitude,
            longitude,
        } => {
            info!("Performing a VoteOnAlbumContest request on {:?}", (
                &version
            ));

            let result = client.vote_on_album_contest(
                version,
                album_contest_id,
                album_id,
                device_id,
                account_id,
                contest_type,
                latitude,
                longitude,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                VoteOnAlbumContestResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::AddPreview {
            version,
            account_id,
            creative_id,
        } => {
            info!("Performing a AddPreview request on {:?}", (
                &version
            ));

            let result = client.add_preview(
                version,
                account_id,
                creative_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                AddPreviewResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::AdsFind {
            version,
            app_key,
            randomize,
            targeted_ads_only,
            param_type,
            account_id,
            app_version,
            latitude,
            longitude,
            device,
            device_identifier,
            device_version,
            start,
            limit,
            include_audiences,
            allocates_tickets,
            mission_ids,
        } => {
            info!("Performing a AdsFind request on {:?}", (
                &version
            ));

            let result = client.ads_find(
                version,
                app_key,
                randomize,
                targeted_ads_only,
                param_type,
                account_id,
                app_version,
                latitude,
                longitude,
                device,
                device_identifier,
                device_version,
                start,
                limit,
                include_audiences,
                allocates_tickets,
                mission_ids,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                AdsFindResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::CreateCreative {
            version,
            account_id,
            name,
            active,
            wait_for_asset,
            description,
            asset_image_id,
            action,
            data,
            suffix,
            param_type,
            balance,
            reference_id,
            app_version,
            mission_id,
            offer_id,
        } => {
            info!("Performing a CreateCreative request on {:?}", (
                &version
            ));

            let result = client.create_creative(
                version,
                account_id,
                name,
                active,
                wait_for_asset,
                description,
                asset_image_id,
                action,
                data,
                suffix,
                param_type,
                balance,
                reference_id,
                app_version,
                mission_id,
                offer_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                CreateCreativeResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::DeleteCreative {
            version,
            account_id,
            creative_id,
        } => {
            info!("Performing a DeleteCreative request on {:?}", (
                &version
            ));

            let result = client.delete_creative(
                version,
                account_id,
                creative_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                DeleteCreativeResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetCreative {
            version,
            account_id,
            creative_id,
        } => {
            info!("Performing a GetCreative request on {:?}", (
                &version
            ));

            let result = client.get_creative(
                version,
                account_id,
                creative_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetCreativeResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetCreativesByApplication {
            version,
            account_id,
            app_key,
            start,
            limit,
            mission_id,
            keyword,
        } => {
            info!("Performing a GetCreativesByApplication request on {:?}", (
                &version
            ));

            let result = client.get_creatives_by_application(
                version,
                account_id,
                app_key,
                start,
                limit,
                mission_id,
                keyword,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetCreativesByApplicationResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::RemovePreview {
            version,
            account_id,
            creative_id,
        } => {
            info!("Performing a RemovePreview request on {:?}", (
                &version
            ));

            let result = client.remove_preview(
                version,
                account_id,
                creative_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                RemovePreviewResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::UpdateCreative {
            version,
            account_id,
            creative_id,
            name,
            description,
            asset_image_id,
            action,
            data,
            suffix,
            param_type,
            balance,
            active,
            reference_id,
            app_version,
            mission_id,
        } => {
            info!("Performing a UpdateCreative request on {:?}", (
                &version
            ));

            let result = client.update_creative(
                version,
                account_id,
                creative_id,
                name,
                description,
                asset_image_id,
                action,
                data,
                suffix,
                param_type,
                balance,
                active,
                reference_id,
                app_version,
                mission_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                UpdateCreativeResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::Create {
            version,
            account_id,
            body,
        } => {
            info!("Performing a Create request on {:?}", (
                &version,
                &account_id
            ));

            let result = client.create(
                version,
                account_id,
                body,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                CreateResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetDependents {
            version,
            account_id,
        } => {
            info!("Performing a GetDependents request on {:?}", (
                &version,
                &account_id
            ));

            let result = client.get_dependents(
                version,
                account_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetDependentsResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::RemoveDependent {
            version,
            account_id,
            dependent_id,
        } => {
            prompt(args.force, "This will delete the given entry, are you sure?")?;
            info!("Performing a RemoveDependent request on {:?}", (
                &version,
                &account_id,
                &dependent_id
            ));

            let result = client.remove_dependent(
                version,
                account_id,
                dependent_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                RemoveDependentResponse::SuccessfulOperation
                => "SuccessfulOperation\n".to_string()
                    ,
            }
        }
        Operation::CheckDisbursements {
            version,
            disbursement_id,
        } => {
            info!("Performing a CheckDisbursements request on {:?}", (
                &version
            ));

            let result = client.check_disbursements(
                version,
                disbursement_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                CheckDisbursementsResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::CreateDisbursement {
            version,
            account_id,
            receiver_account_id,
            original_sender_account_id,
            amount,
            provider,
            scheduled_date,
            title,
            comment,
            external_id,
            introspection_params,
        } => {
            info!("Performing a CreateDisbursement request on {:?}", (
                &version
            ));

            let result = client.create_disbursement(
                version,
                account_id,
                receiver_account_id,
                original_sender_account_id,
                amount,
                provider,
                scheduled_date,
                title,
                comment,
                external_id,
                introspection_params,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                CreateDisbursementResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetDisbursement {
            version,
            account_id,
            disbursement_id,
        } => {
            info!("Performing a GetDisbursement request on {:?}", (
                &version
            ));

            let result = client.get_disbursement(
                version,
                account_id,
                disbursement_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetDisbursementResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::SearchDisbursements {
            version,
            account_id,
            receiver_account_id,
            statuses,
            providers,
            before_date,
            after_date,
            start,
            limit,
            active_only,
            external_id,
        } => {
            info!("Performing a SearchDisbursements request on {:?}", (
                &version
            ));

            let result = client.search_disbursements(
                version,
                account_id,
                receiver_account_id,
                statuses,
                providers,
                before_date,
                after_date,
                start,
                limit,
                active_only,
                external_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                SearchDisbursementsResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::UpdateDisbursement {
            version,
            account_id,
            disbursement_id,
            amount,
            provider,
            scheduled_date,
            title,
            comment,
            external_id,
            retry,
            introspection_params,
        } => {
            info!("Performing a UpdateDisbursement request on {:?}", (
                &version
            ));

            let result = client.update_disbursement(
                version,
                account_id,
                disbursement_id,
                amount,
                provider,
                scheduled_date,
                title,
                comment,
                external_id,
                retry,
                introspection_params,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                UpdateDisbursementResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::AssignEmployee {
            version,
            account_id,
            manager_account_id,
            employee_account_id,
            role,
        } => {
            info!("Performing a AssignEmployee request on {:?}", (
                &version
            ));

            let result = client.assign_employee(
                version,
                account_id,
                manager_account_id,
                employee_account_id,
                role,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                AssignEmployeeResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::AssignToLocationEmployee {
            version,
            account_id,
            retailer_location_id,
            employee_account_id,
            assign,
        } => {
            info!("Performing a AssignToLocationEmployee request on {:?}", (
                &version
            ));

            let result = client.assign_to_location_employee(
                version,
                account_id,
                retailer_location_id,
                employee_account_id,
                assign,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                AssignToLocationEmployeeResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::CreateEmployee {
            version,
            account_id,
            manager_account_id,
            username,
            password,
            name,
            prefix_name,
            first_name,
            middle_name,
            last_name,
            suffix_name,
            title,
            about_us,
            asset_id,
            gender,
            home_phone,
            cell_phone,
            cell_phone_carrier,
            business_phone,
            email_address,
            street_address,
            street_address2,
            city,
            state,
            zipcode,
            country,
            role,
            retailer_location_ids,
            settings_app_key,
            app_blob,
            assigned_device_id,
        } => {
            info!("Performing a CreateEmployee request on {:?}", (
                &version
            ));

            let result = client.create_employee(
                version,
                account_id,
                manager_account_id,
                username,
                password,
                name,
                prefix_name,
                first_name,
                middle_name,
                last_name,
                suffix_name,
                title,
                about_us,
                asset_id,
                gender,
                home_phone,
                cell_phone,
                cell_phone_carrier,
                business_phone,
                email_address,
                street_address,
                street_address2,
                city,
                state,
                zipcode,
                country,
                role,
                retailer_location_ids,
                settings_app_key,
                app_blob,
                assigned_device_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                CreateEmployeeResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::DeleteEmployee {
            version,
            account_id,
            employee_account_id,
        } => {
            info!("Performing a DeleteEmployee request on {:?}", (
                &version
            ));

            let result = client.delete_employee(
                version,
                account_id,
                employee_account_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                DeleteEmployeeResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetEmployee {
            version,
            account_id,
            employee_account_id,
            settings_app_key,
        } => {
            info!("Performing a GetEmployee request on {:?}", (
                &version
            ));

            let result = client.get_employee(
                version,
                account_id,
                employee_account_id,
                settings_app_key,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetEmployeeResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::SearchEmployees {
            version,
            account_id,
            role,
            retailer_id,
            retailer_location_id,
            q,
            keyword,
            sort_field,
            descending,
            _i,
            start,
            _l,
            limit,
            active_only,
            managed_only,
            settings_app_key,
            category_ids,
            query,
        } => {
            info!("Performing a SearchEmployees request on {:?}", (
                &version
            ));

            let result = client.search_employees(
                version,
                account_id,
                role,
                retailer_id,
                retailer_location_id,
                q,
                keyword,
                sort_field,
                descending,
                _i,
                start,
                _l,
                limit,
                active_only,
                managed_only,
                settings_app_key,
                category_ids,
                query,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                SearchEmployeesResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::UnassignEmployee {
            version,
            account_id,
            employee_account_id,
        } => {
            info!("Performing a UnassignEmployee request on {:?}", (
                &version
            ));

            let result = client.unassign_employee(
                version,
                account_id,
                employee_account_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                UnassignEmployeeResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::UpdateEmployee {
            version,
            account_id,
            employee_account_id,
            manager_account_id,
            name,
            prefix_name,
            first_name,
            middle_name,
            last_name,
            suffix_name,
            title,
            asset_id,
            gender,
            home_phone,
            cell_phone,
            cell_phone_carrier,
            business_phone,
            email_address,
            street_address,
            street_address2,
            city,
            state,
            zipcode,
            country,
            role,
            active,
            password,
            retailer_location_ids,
            settings_app_key,
            app_blob,
            assigned_device_id,
        } => {
            info!("Performing a UpdateEmployee request on {:?}", (
                &version
            ));

            let result = client.update_employee(
                version,
                account_id,
                employee_account_id,
                manager_account_id,
                name,
                prefix_name,
                first_name,
                middle_name,
                last_name,
                suffix_name,
                title,
                asset_id,
                gender,
                home_phone,
                cell_phone,
                cell_phone_carrier,
                business_phone,
                email_address,
                street_address,
                street_address2,
                city,
                state,
                zipcode,
                country,
                role,
                active,
                password,
                retailer_location_ids,
                settings_app_key,
                app_blob,
                assigned_device_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                UpdateEmployeeResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::AttendEvent {
            version,
            device_id,
            account_id,
            app_key,
            listing_id,
            retailer_location_id,
            offer_location_id,
            transaction_id,
            status,
            latitude,
            longitude,
        } => {
            info!("Performing a AttendEvent request on {:?}", (
                &version
            ));

            let result = client.attend_event(
                version,
                device_id,
                account_id,
                app_key,
                listing_id,
                retailer_location_id,
                offer_location_id,
                transaction_id,
                status,
                latitude,
                longitude,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                AttendEventResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::CreateEvent {
            version,
            account_id,
            title,
            retailer_location_ids,
            sub_title,
            details,
            category_ids,
            filter_ids,
            active,
            image_asset_id,
            redeemable_start,
            redeemable_end,
            meta_data,
        } => {
            info!("Performing a CreateEvent request on {:?}", (
                &version
            ));

            let result = client.create_event(
                version,
                account_id,
                title,
                retailer_location_ids,
                sub_title,
                details,
                category_ids,
                filter_ids,
                active,
                image_asset_id,
                redeemable_start,
                redeemable_end,
                meta_data,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                CreateEventResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::DeleteEvent {
            version,
            account_id,
            event_id,
        } => {
            info!("Performing a DeleteEvent request on {:?}", (
                &version
            ));

            let result = client.delete_event(
                version,
                account_id,
                event_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                DeleteEventResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetEvent {
            version,
            account_id,
            event_id,
        } => {
            info!("Performing a GetEvent request on {:?}", (
                &version
            ));

            let result = client.get_event(
                version,
                account_id,
                event_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetEventResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::SearchEventTransactions {
            version,
            device_id,
            account_id,
            app_key,
            keyword,
            retailer_id,
            retailer_location_id,
            exclude_retailer_location_id,
            listing_id,
            offer_id,
            offer_location_id,
            customer_account_ids,
            affiliated_category_ids,
            start_date,
            end_date,
            statuses,
            sort_field,
            descending,
            start,
            limit,
        } => {
            info!("Performing a SearchEventTransactions request on {:?}", (
                &version
            ));

            let result = client.search_event_transactions(
                version,
                device_id,
                account_id,
                app_key,
                keyword,
                retailer_id,
                retailer_location_id,
                exclude_retailer_location_id,
                listing_id,
                offer_id,
                offer_location_id,
                customer_account_ids,
                affiliated_category_ids,
                start_date,
                end_date,
                statuses,
                sort_field,
                descending,
                start,
                limit,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                SearchEventTransactionsResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::SearchEvents {
            version,
            account_id,
            keyword,
            active_only,
            category_ids,
            filter_ids,
            offer_audience_ids,
            transaction_audience_ids,
            sort_field,
            descending,
            start_date,
            end_date,
            start,
            limit,
        } => {
            info!("Performing a SearchEvents request on {:?}", (
                &version
            ));

            let result = client.search_events(
                version,
                account_id,
                keyword,
                active_only,
                category_ids,
                filter_ids,
                offer_audience_ids,
                transaction_audience_ids,
                sort_field,
                descending,
                start_date,
                end_date,
                start,
                limit,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                SearchEventsResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::UpdateEvent {
            version,
            account_id,
            event_id,
            retailer_location_ids,
            title,
            sub_title,
            details,
            category_ids,
            filter_ids,
            active,
            image_asset_id,
            redeemable_start,
            redeemable_end,
        } => {
            info!("Performing a UpdateEvent request on {:?}", (
                &version
            ));

            let result = client.update_event(
                version,
                account_id,
                event_id,
                retailer_location_ids,
                title,
                sub_title,
                details,
                category_ids,
                filter_ids,
                active,
                image_asset_id,
                redeemable_start,
                redeemable_end,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                UpdateEventResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetToken {
            version,
            device_id,
            account_id,
            latitude,
            longitude,
        } => {
            info!("Performing a GetToken request on {:?}", (
                &version
            ));

            let result = client.get_token(
                version,
                device_id,
                account_id,
                latitude,
                longitude,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetTokenResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GraphInterface {
            version,
            event,
            device_id,
            account_id,
            permissionable_type,
            permissionable_id,
            asset_id,
            game_type,
            app_key,
            latitude,
            longitude,
        } => {
            info!("Performing a GraphInterface request on {:?}", (
                &version
            ));

            let result = client.graph_interface(
                version,
                event,
                device_id,
                account_id,
                permissionable_type,
                permissionable_id,
                asset_id,
                game_type,
                app_key,
                latitude,
                longitude,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GraphInterfaceResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::AddFavorite {
            version,
            favoritable_id,
            favoritable_type,
            device_id,
            account_id,
            latitude,
            longitude,
        } => {
            info!("Performing a AddFavorite request on {:?}", (
                &version
            ));

            let result = client.add_favorite(
                version,
                favoritable_id,
                favoritable_type,
                device_id,
                account_id,
                latitude,
                longitude,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                AddFavoriteResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::DeleteFavorite {
            version,
            device_id,
            account_id,
            favorite_id,
            favoritable_id,
            favoritable_type,
        } => {
            info!("Performing a DeleteFavorite request on {:?}", (
                &version
            ));

            let result = client.delete_favorite(
                version,
                device_id,
                account_id,
                favorite_id,
                favoritable_id,
                favoritable_type,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                DeleteFavoriteResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetFavorite {
            version,
            favorite_id,
            device_id,
            account_id,
            latitude,
            longitude,
        } => {
            info!("Performing a GetFavorite request on {:?}", (
                &version
            ));

            let result = client.get_favorite(
                version,
                favorite_id,
                device_id,
                account_id,
                latitude,
                longitude,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetFavoriteResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::SearchFavorites {
            version,
            favoritable_type,
            sort_field,
            descending,
            start,
            limit,
            active_only,
            return_full_response,
            device_id,
            account_id,
            connection_account_id,
            secondary_type,
            keyword,
            latitude,
            longitude,
        } => {
            info!("Performing a SearchFavorites request on {:?}", (
                &version
            ));

            let result = client.search_favorites(
                version,
                favoritable_type,
                sort_field,
                descending,
                start,
                limit,
                active_only,
                return_full_response,
                device_id,
                account_id,
                connection_account_id,
                secondary_type,
                keyword,
                latitude,
                longitude,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                SearchFavoritesResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::WhoHasFavorited {
            version,
            favoritable_id,
            favoritable_type,
            start,
            limit,
            device_id,
            account_id,
            latitude,
            longitude,
            keyword,
        } => {
            info!("Performing a WhoHasFavorited request on {:?}", (
                &version
            ));

            let result = client.who_has_favorited(
                version,
                favoritable_id,
                favoritable_type,
                start,
                limit,
                device_id,
                account_id,
                latitude,
                longitude,
                keyword,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                WhoHasFavoritedResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::CreateFilter {
            version,
            account_id,
            name,
            app_key,
            parent_filter_id,
            description,
            external_id,
            external_type,
            active,
            meta_data,
        } => {
            info!("Performing a CreateFilter request on {:?}", (
                &version
            ));

            let result = client.create_filter(
                version,
                account_id,
                name,
                app_key,
                parent_filter_id,
                description,
                external_id,
                external_type,
                active,
                meta_data,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                CreateFilterResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::DeleteFilter {
            version,
            account_id,
            filter_id,
        } => {
            info!("Performing a DeleteFilter request on {:?}", (
                &version
            ));

            let result = client.delete_filter(
                version,
                account_id,
                filter_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                DeleteFilterResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetFilter {
            version,
            filter_id,
        } => {
            info!("Performing a GetFilter request on {:?}", (
                &version
            ));

            let result = client.get_filter(
                version,
                filter_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetFilterResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::SearchFilters {
            version,
            account_id,
            keyword,
            app_key,
            response_group,
            root_only,
            sort_field,
            descending,
            start,
            limit,
            active_only,
        } => {
            info!("Performing a SearchFilters request on {:?}", (
                &version
            ));

            let result = client.search_filters(
                version,
                account_id,
                keyword,
                app_key,
                response_group,
                root_only,
                sort_field,
                descending,
                start,
                limit,
                active_only,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                SearchFiltersResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::UpdateFilter {
            version,
            account_id,
            filter_id,
            parent_filter_id,
            name,
            description,
            external_id,
            external_type,
            active,
            meta_data,
        } => {
            info!("Performing a UpdateFilter request on {:?}", (
                &version
            ));

            let result = client.update_filter(
                version,
                account_id,
                filter_id,
                parent_filter_id,
                name,
                description,
                external_id,
                external_type,
                active,
                meta_data,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                UpdateFilterResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::CreateFlag {
            version,
            flagable_type,
            flagable_id,
            device_id,
            account_id,
            flag_description,
            latitude,
            longitude,
        } => {
            info!("Performing a CreateFlag request on {:?}", (
                &version
            ));

            let result = client.create_flag(
                version,
                flagable_type,
                flagable_id,
                device_id,
                account_id,
                flag_description,
                latitude,
                longitude,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                CreateFlagResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::DeleteFlag {
            version,
            device_id,
            account_id,
            item_being_flagged_type,
            item_being_flagged_id,
            flagable_type,
            flagable_id,
        } => {
            info!("Performing a DeleteFlag request on {:?}", (
                &version
            ));

            let result = client.delete_flag(
                version,
                device_id,
                account_id,
                item_being_flagged_type,
                item_being_flagged_id,
                flagable_type,
                flagable_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                DeleteFlagResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetFlag {
            version,
            flagable_type,
            flagable_id,
            device_id,
            account_id,
            latitude,
            longitude,
        } => {
            info!("Performing a GetFlag request on {:?}", (
                &version
            ));

            let result = client.get_flag(
                version,
                flagable_type,
                flagable_id,
                device_id,
                account_id,
                latitude,
                longitude,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetFlagResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetFlagThreshold {
            version,
            item_being_flagged_type,
            app_key,
        } => {
            info!("Performing a GetFlagThreshold request on {:?}", (
                &version
            ));

            let result = client.get_flag_threshold(
                version,
                item_being_flagged_type,
                app_key,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetFlagThresholdResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::UpdateFlagThreshold {
            version,
            item_being_flagged_type,
            threshold,
            app_key,
            device_id,
            account_id,
        } => {
            info!("Performing a UpdateFlagThreshold request on {:?}", (
                &version
            ));

            let result = client.update_flag_threshold(
                version,
                item_being_flagged_type,
                threshold,
                app_key,
                device_id,
                account_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                UpdateFlagThresholdResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::CreateGame {
            version,
            account_id,
            app_key,
            title,
            description,
            meta_data,
            pack_ids,
            include_game_data,
        } => {
            info!("Performing a CreateGame request on {:?}", (
                &version
            ));

            let result = client.create_game(
                version,
                account_id,
                app_key,
                title,
                description,
                meta_data,
                pack_ids,
                include_game_data,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                CreateGameResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::DeleteGame {
            version,
            account_id,
            game_id,
        } => {
            info!("Performing a DeleteGame request on {:?}", (
                &version
            ));

            let result = client.delete_game(
                version,
                account_id,
                game_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                DeleteGameResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetGame {
            version,
            account_id,
            game_id,
            include_game_data,
        } => {
            info!("Performing a GetGame request on {:?}", (
                &version
            ));

            let result = client.get_game(
                version,
                account_id,
                game_id,
                include_game_data,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetGameResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::SearchGames {
            version,
            account_id,
            app_key,
            start,
            limit,
            keyword,
            app_version,
            include_game_data,
            include_inactive,
        } => {
            info!("Performing a SearchGames request on {:?}", (
                &version
            ));

            let result = client.search_games(
                version,
                account_id,
                app_key,
                start,
                limit,
                keyword,
                app_version,
                include_game_data,
                include_inactive,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                SearchGamesResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::UpdateGame {
            version,
            account_id,
            game_id,
            app_key,
            title,
            description,
            meta_data,
            pack_ids,
            include_game_data,
        } => {
            info!("Performing a UpdateGame request on {:?}", (
                &version
            ));

            let result = client.update_game(
                version,
                account_id,
                game_id,
                app_key,
                title,
                description,
                meta_data,
                pack_ids,
                include_game_data,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                UpdateGameResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::CreateGameLevel {
            version,
            account_id,
            name,
            game_data,
            game_data_suffix,
            app_key,
            description,
            difficulty,
            app_version,
            asset_image_id,
            asset_icon_id,
            visibility,
            friend_group,
            connection_ids,
            connection_group_ids,
            balance,
            active,
            allocate_tickets,
            ticket_count,
            ticket_type,
            points,
            tutorial_title,
            tutorial_message,
            tutorial_alignment,
            tutorial_image_asset_id,
            offer_id,
            meta_data,
        } => {
            info!("Performing a CreateGameLevel request on {:?}", (
                &version
            ));

            let result = client.create_game_level(
                version,
                account_id,
                name,
                game_data,
                game_data_suffix,
                app_key,
                description,
                difficulty,
                app_version,
                asset_image_id,
                asset_icon_id,
                visibility,
                friend_group,
                connection_ids,
                connection_group_ids,
                balance,
                active,
                allocate_tickets,
                ticket_count,
                ticket_type,
                points,
                tutorial_title,
                tutorial_message,
                tutorial_alignment,
                tutorial_image_asset_id,
                offer_id,
                meta_data,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                CreateGameLevelResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::DeleteGameLevel {
            version,
            account_id,
            level_id,
        } => {
            info!("Performing a DeleteGameLevel request on {:?}", (
                &version
            ));

            let result = client.delete_game_level(
                version,
                account_id,
                level_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                DeleteGameLevelResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetGameLevel {
            version,
            account_id,
            level_id,
            include_game_data,
        } => {
            info!("Performing a GetGameLevel request on {:?}", (
                &version
            ));

            let result = client.get_game_level(
                version,
                account_id,
                level_id,
                include_game_data,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetGameLevelResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetGameLevelsByApplication {
            version,
            account_id,
            app_key,
            keyword,
            sort_field,
            descending,
            start,
            limit,
            app_version,
            include_game_data,
            filters,
        } => {
            info!("Performing a GetGameLevelsByApplication request on {:?}", (
                &version
            ));

            let result = client.get_game_levels_by_application(
                version,
                account_id,
                app_key,
                keyword,
                sort_field,
                descending,
                start,
                limit,
                app_version,
                include_game_data,
                filters,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetGameLevelsByApplicationResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetGameLevelsByBillableEntity {
            version,
            account_id,
            app_key,
            keyword,
            sort_field,
            descending,
            active_only,
            start,
            limit,
        } => {
            info!("Performing a GetGameLevelsByBillableEntity request on {:?}", (
                &version
            ));

            let result = client.get_game_levels_by_billable_entity(
                version,
                account_id,
                app_key,
                keyword,
                sort_field,
                descending,
                active_only,
                start,
                limit,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetGameLevelsByBillableEntityResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetQuestionsInLevel {
            version,
            level_id,
            account_id,
        } => {
            info!("Performing a GetQuestionsInLevel request on {:?}", (
                &version
            ));

            let result = client.get_questions_in_level(
                version,
                level_id,
                account_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetQuestionsInLevelResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetWordsInLevel {
            version,
            level_id,
            account_id,
        } => {
            info!("Performing a GetWordsInLevel request on {:?}", (
                &version
            ));

            let result = client.get_words_in_level(
                version,
                level_id,
                account_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetWordsInLevelResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::UpdateGameLevel {
            version,
            account_id,
            level_id,
            app_key,
            name,
            description,
            difficulty,
            app_version,
            asset_image_id,
            asset_icon_id,
            game_data,
            game_data_suffix,
            visibility,
            friend_group,
            connection_ids,
            connection_group_ids,
            balance,
            active,
            allocate_tickets,
            ticket_count,
            ticket_type,
            points,
            tutorial_title,
            tutorial_message,
            tutorial_alignment,
            tutorial_image_asset_id,
            offer_id,
            meta_data,
        } => {
            info!("Performing a UpdateGameLevel request on {:?}", (
                &version
            ));

            let result = client.update_game_level(
                version,
                account_id,
                level_id,
                app_key,
                name,
                description,
                difficulty,
                app_version,
                asset_image_id,
                asset_icon_id,
                game_data,
                game_data_suffix,
                visibility,
                friend_group,
                connection_ids,
                connection_group_ids,
                balance,
                active,
                allocate_tickets,
                ticket_count,
                ticket_type,
                points,
                tutorial_title,
                tutorial_message,
                tutorial_alignment,
                tutorial_image_asset_id,
                offer_id,
                meta_data,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                UpdateGameLevelResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::UpdateQuestionsInLevel {
            version,
            level_id,
            account_id,
            question_ids,
        } => {
            info!("Performing a UpdateQuestionsInLevel request on {:?}", (
                &version
            ));

            let result = client.update_questions_in_level(
                version,
                level_id,
                account_id,
                question_ids,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                UpdateQuestionsInLevelResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::UpdateWordsInLevel {
            version,
            level_id,
            account_id,
            word_ids,
        } => {
            info!("Performing a UpdateWordsInLevel request on {:?}", (
                &version
            ));

            let result = client.update_words_in_level(
                version,
                level_id,
                account_id,
                word_ids,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                UpdateWordsInLevelResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::AcceptInvite {
            version,
            token,
            account_id,
            album_id,
            mission_id,
            album_contest_id,
            offer_id,
            offer_location_id,
            retailer_location_id,
            app_key,
            auto_friend,
            auto_attend_event,
            auto_favorite_offer,
            auto_favorite_offer_location,
            auto_favorite_retailer_location,
        } => {
            info!("Performing a AcceptInvite request on {:?}", (
                &version
            ));

            let result = client.accept_invite(
                version,
                token,
                account_id,
                album_id,
                mission_id,
                album_contest_id,
                offer_id,
                offer_location_id,
                retailer_location_id,
                app_key,
                auto_friend,
                auto_attend_event,
                auto_favorite_offer,
                auto_favorite_offer_location,
                auto_favorite_retailer_location,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                AcceptInviteResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::AlbumContestInvite {
            version,
            device_id,
            account_id,
            app_id,
            app_key,
            album_contest_id,
            latitude,
            longitude,
        } => {
            info!("Performing a AlbumContestInvite request on {:?}", (
                &version
            ));

            let result = client.album_contest_invite(
                version,
                device_id,
                account_id,
                app_id,
                app_key,
                album_contest_id,
                latitude,
                longitude,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                AlbumContestInviteResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::AlbumInvite {
            version,
            device_id,
            account_id,
            app_id,
            app_key,
            album_id,
            latitude,
            longitude,
        } => {
            info!("Performing a AlbumInvite request on {:?}", (
                &version
            ));

            let result = client.album_invite(
                version,
                device_id,
                account_id,
                app_id,
                app_key,
                album_id,
                latitude,
                longitude,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                AlbumInviteResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::EventInvite {
            version,
            account_id,
            app_key,
            listing_id,
            receiver_account_ids,
            retailer_location_id,
        } => {
            info!("Performing a EventInvite request on {:?}", (
                &version
            ));

            let result = client.event_invite(
                version,
                account_id,
                app_key,
                listing_id,
                receiver_account_ids,
                retailer_location_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                EventInviteResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GameInvite {
            version,
            device_id,
            account_id,
            app_id,
            app_key,
            game_level_id,
            latitude,
            longitude,
        } => {
            info!("Performing a GameInvite request on {:?}", (
                &version
            ));

            let result = client.game_invite(
                version,
                device_id,
                account_id,
                app_id,
                app_key,
                game_level_id,
                latitude,
                longitude,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GameInviteResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetInvite {
            version,
            account_id,
            token,
            album_id,
            mission_id,
            album_contest_id,
            offer_id,
            offer_location_id,
            retailer_location_id,
            app_key,
        } => {
            info!("Performing a GetInvite request on {:?}", (
                &version
            ));

            let result = client.get_invite(
                version,
                account_id,
                token,
                album_id,
                mission_id,
                album_contest_id,
                offer_id,
                offer_location_id,
                retailer_location_id,
                app_key,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetInviteResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::MissionInvite {
            version,
            device_id,
            account_id,
            app_id,
            app_key,
            mission_id,
            latitude,
            longitude,
        } => {
            info!("Performing a MissionInvite request on {:?}", (
                &version
            ));

            let result = client.mission_invite(
                version,
                device_id,
                account_id,
                app_id,
                app_key,
                mission_id,
                latitude,
                longitude,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                MissionInviteResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::OfferInvite {
            version,
            account_id,
            app_key,
            offer_id,
        } => {
            info!("Performing a OfferInvite request on {:?}", (
                &version
            ));

            let result = client.offer_invite(
                version,
                account_id,
                app_key,
                offer_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                OfferInviteResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::OfferLocationInvite {
            version,
            account_id,
            app_key,
            offer_location_id,
        } => {
            info!("Performing a OfferLocationInvite request on {:?}", (
                &version
            ));

            let result = client.offer_location_invite(
                version,
                account_id,
                app_key,
                offer_location_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                OfferLocationInviteResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::RetailerLocationInvite {
            version,
            account_id,
            app_key,
            retailer_location_id,
            album_id,
        } => {
            info!("Performing a RetailerLocationInvite request on {:?}", (
                &version
            ));

            let result = client.retailer_location_invite(
                version,
                account_id,
                app_key,
                retailer_location_id,
                album_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                RetailerLocationInviteResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::CreateLeaderboard {
            version,
            account_id,
            app_key,
            rank_type,
            leaderboard_mode,
            icon_media,
            icon_asset_id,
            banner_media,
            banner_asset_id,
            limitation,
            sort_field,
            title,
            description,
            meta_data,
        } => {
            info!("Performing a CreateLeaderboard request on {:?}", (
                &version
            ));

            let result = client.create_leaderboard(
                version,
                account_id,
                app_key,
                rank_type,
                leaderboard_mode,
                icon_media,
                icon_asset_id,
                banner_media,
                banner_asset_id,
                limitation,
                sort_field,
                title,
                description,
                meta_data,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                CreateLeaderboardResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::DeleteLeaderboard {
            version,
            leaderboard_id,
            account_id,
        } => {
            info!("Performing a DeleteLeaderboard request on {:?}", (
                &version
            ));

            let result = client.delete_leaderboard(
                version,
                leaderboard_id,
                account_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                DeleteLeaderboardResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetLeaderboard {
            version,
            leaderboard_id,
            account_id,
            include_full_ranking_list,
        } => {
            info!("Performing a GetLeaderboard request on {:?}", (
                &version
            ));

            let result = client.get_leaderboard(
                version,
                leaderboard_id,
                account_id,
                include_full_ranking_list,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetLeaderboardResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::SearchLeaderboards {
            version,
            account_id,
            app_key,
            global_only,
            keyword,
            leaderboard_ids,
            rank_types,
            sort_field,
            descending,
            include_inactive,
            include_app_response,
            start,
            limit,
        } => {
            info!("Performing a SearchLeaderboards request on {:?}", (
                &version
            ));

            let result = client.search_leaderboards(
                version,
                account_id,
                app_key,
                global_only,
                keyword,
                leaderboard_ids,
                rank_types,
                sort_field,
                descending,
                include_inactive,
                include_app_response,
                start,
                limit,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                SearchLeaderboardsResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::UpdateLeaderboard {
            version,
            leaderboard_id,
            account_id,
            app_key,
            rank_type,
            leaderboard_mode,
            sort_field,
            icon_media,
            icon_asset_id,
            banner_media,
            banner_asset_id,
            limitation,
            active,
            title,
            description,
            meta_data,
        } => {
            info!("Performing a UpdateLeaderboard request on {:?}", (
                &version
            ));

            let result = client.update_leaderboard(
                version,
                leaderboard_id,
                account_id,
                app_key,
                rank_type,
                leaderboard_mode,
                sort_field,
                icon_media,
                icon_asset_id,
                banner_media,
                banner_asset_id,
                limitation,
                active,
                title,
                description,
                meta_data,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                UpdateLeaderboardResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::RegisterLike {
            version,
            likable_type,
            likable_id,
            device_id,
            account_id,
            permissionable_type,
            permissionable_id,
            like,
            app,
            game_type,
            app_key,
            latitude,
            longitude,
        } => {
            info!("Performing a RegisterLike request on {:?}", (
                &version
            ));

            let result = client.register_like(
                version,
                likable_type,
                likable_id,
                device_id,
                account_id,
                permissionable_type,
                permissionable_id,
                like,
                app,
                game_type,
                app_key,
                latitude,
                longitude,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                RegisterLikeResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::RemoveLike {
            version,
            likable_type,
            likable_id,
            device_id,
            account_id,
            latitude,
            longitude,
        } => {
            info!("Performing a RemoveLike request on {:?}", (
                &version
            ));

            let result = client.remove_like(
                version,
                likable_type,
                likable_id,
                device_id,
                account_id,
                latitude,
                longitude,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                RemoveLikeResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::SearchLikes {
            version,
            likable_type,
            likable_id,
            device_id,
            account_id,
            connection_account_ids,
            sort_field,
            descending,
            updated_since,
            updated_before,
            start,
            limit,
        } => {
            info!("Performing a SearchLikes request on {:?}", (
                &version
            ));

            let result = client.search_likes(
                version,
                likable_type,
                likable_id,
                device_id,
                account_id,
                connection_account_ids,
                sort_field,
                descending,
                updated_since,
                updated_before,
                start,
                limit,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                SearchLikesResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::CreateListing {
            version,
            account_id,
            name,
            filter_ids,
            description,
            start,
            end,
            location_name,
            location_description,
            is_private,
            external_id,
            external_id2,
            external_group_id,
            active,
            meta_data,
        } => {
            info!("Performing a CreateListing request on {:?}", (
                &version
            ));

            let result = client.create_listing(
                version,
                account_id,
                name,
                filter_ids,
                description,
                start,
                end,
                location_name,
                location_description,
                is_private,
                external_id,
                external_id2,
                external_group_id,
                active,
                meta_data,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                CreateListingResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::DeleteListing {
            version,
            account_id,
            listing_id,
        } => {
            info!("Performing a DeleteListing request on {:?}", (
                &version
            ));

            let result = client.delete_listing(
                version,
                account_id,
                listing_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                DeleteListingResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetListing {
            version,
            listing_id,
        } => {
            info!("Performing a GetListing request on {:?}", (
                &version
            ));

            let result = client.get_listing(
                version,
                listing_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetListingResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::SearchListing {
            version,
            account_id,
            keyword,
            start,
            limit,
            active_only,
            latitude,
            longitude,
            start_date,
            end_date,
            category_ids,
            filter_ids,
            use_listing_order_ids,
            external_id,
            external_id2,
            external_group_id,
        } => {
            info!("Performing a SearchListing request on {:?}", (
                &version
            ));

            let result = client.search_listing(
                version,
                account_id,
                keyword,
                start,
                limit,
                active_only,
                latitude,
                longitude,
                start_date,
                end_date,
                category_ids,
                filter_ids,
                use_listing_order_ids,
                external_id,
                external_id2,
                external_group_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                SearchListingResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::SummaryListing {
            version,
            account_id,
            start_date,
            category_ids,
            days_to_include,
            use_listing_order_ids,
        } => {
            info!("Performing a SummaryListing request on {:?}", (
                &version
            ));

            let result = client.summary_listing(
                version,
                account_id,
                start_date,
                category_ids,
                days_to_include,
                use_listing_order_ids,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                SummaryListingResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::UpdateListing {
            version,
            account_id,
            listing_id,
            filter_ids,
            name,
            description,
            start,
            end,
            location_name,
            location_description,
            is_private,
            external_id,
            external_id2,
            external_group_id,
            active,
            meta_data,
        } => {
            info!("Performing a UpdateListing request on {:?}", (
                &version
            ));

            let result = client.update_listing(
                version,
                account_id,
                listing_id,
                filter_ids,
                name,
                description,
                start,
                end,
                location_name,
                location_description,
                is_private,
                external_id,
                external_id2,
                external_group_id,
                active,
                meta_data,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                UpdateListingResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::CacheTrilaterationData {
            version,
            udid,
            source_time,
            minimum_sample_size,
            data,
            data_file,
        } => {
            info!("Performing a CacheTrilaterationData request on {:?}", (
                &version
            ));

            let result = client.cache_trilateration_data(
                version,
                udid,
                source_time,
                minimum_sample_size,
                data,
                data_file,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                CacheTrilaterationDataResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::CacheTrilaterationDataGzip {
            version,
            body,
        } => {
            info!("Performing a CacheTrilaterationDataGzip request on {:?}", (
                &version
            ));

            let result = client.cache_trilateration_data_gzip(
                version,
                body,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                CacheTrilaterationDataGzipResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetLocationByIp {
            version,
            ip,
        } => {
            info!("Performing a GetLocationByIp request on {:?}", (
                &version
            ));

            let result = client.get_location_by_ip(
                version,
                ip,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetLocationByIpResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetLocationByTrilateration {
            version,
            account_id,
            latitude,
            longitude,
            data,
            response_filters,
        } => {
            info!("Performing a GetLocationByTrilateration request on {:?}", (
                &version
            ));

            let result = client.get_location_by_trilateration(
                version,
                account_id,
                latitude,
                longitude,
                data,
                response_filters,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetLocationByTrilaterationResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetLocations {
            version,
            device_id,
            account_id,
            currentlatitude,
            currentlongitude,
            current_latitude,
            current_longitude,
            query,
            zipcode,
            zip_code,
            selected_maplatitude,
            selected_maplongitude,
            selected_map_latitude,
            selected_map_longitude,
            search_range,
            use_geocode,
            _i,
            start,
            _l,
            limit,
        } => {
            info!("Performing a GetLocations request on {:?}", (
                &version
            ));

            let result = client.get_locations(
                version,
                device_id,
                account_id,
                currentlatitude,
                currentlongitude,
                current_latitude,
                current_longitude,
                query,
                zipcode,
                zip_code,
                selected_maplatitude,
                selected_maplongitude,
                selected_map_latitude,
                selected_map_longitude,
                search_range,
                use_geocode,
                _i,
                start,
                _l,
                limit,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetLocationsResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::CreateLocationV2 {
            version,
            body,
        } => {
            info!("Performing a CreateLocationV2 request on {:?}", (
                &version
            ));

            let result = client.create_location_v2(
                version,
                body,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                CreateLocationV2Response::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::UpdateLocationV2 {
            version,
            id,
            body,
        } => {
            info!("Performing a UpdateLocationV2 request on {:?}", (
                &version,
                &id
            ));

            let result = client.update_location_v2(
                version,
                id,
                body,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                UpdateLocationV2Response::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::CreateMedia {
            version,
            account_id,
            title,
            barcode_type,
            no_expiration,
            available_limit,
            available_limit_per_user,
            added_limit,
            view_limit,
            max_prints,
            ticket_price,
            full_price,
            discount_price,
            special_offer_type,
            offer_visibility,
            active,
            retailer_location_ids,
            sub_title,
            details,
            sub_details,
            fine_print,
            barcode_entry,
            external_redeem_options,
            external_url,
            tickets_reward_type,
            tickets_reward,
            activated,
            expires,
            ticket_price_type,
            show_remaining,
            show_redeemed,
            replaced,
            featured,
            category_ids,
            filter_ids,
            barcode_asset_id,
            image_asset_id,
            image_asset_id1,
            image_asset_id2,
            image_asset_id3,
            image_asset_id4,
            image_asset_id5,
            publisher,
            redeemable_start,
            redeemable_end,
            condition_type,
            isbn,
            asin,
            catalog_numbers,
            parental_rating,
            availability_date,
            media_type,
            duration,
            author,
            release_date,
            collection_ids,
            availability,
            availability_summary,
        } => {
            info!("Performing a CreateMedia request on {:?}", (
                &version
            ));

            let result = client.create_media(
                version,
                account_id,
                title,
                barcode_type,
                no_expiration,
                available_limit,
                available_limit_per_user,
                added_limit,
                view_limit,
                max_prints,
                ticket_price,
                full_price,
                discount_price,
                special_offer_type,
                offer_visibility,
                active,
                retailer_location_ids,
                sub_title,
                details,
                sub_details,
                fine_print,
                barcode_entry,
                external_redeem_options,
                external_url,
                tickets_reward_type,
                tickets_reward,
                activated,
                expires,
                ticket_price_type,
                show_remaining,
                show_redeemed,
                replaced,
                featured,
                category_ids,
                filter_ids,
                barcode_asset_id,
                image_asset_id,
                image_asset_id1,
                image_asset_id2,
                image_asset_id3,
                image_asset_id4,
                image_asset_id5,
                publisher,
                redeemable_start,
                redeemable_end,
                condition_type,
                isbn,
                asin,
                catalog_numbers,
                parental_rating,
                availability_date,
                media_type,
                duration,
                author,
                release_date,
                collection_ids,
                availability,
                availability_summary,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                CreateMediaResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::DeleteMedia {
            version,
            account_id,
            media_id,
        } => {
            info!("Performing a DeleteMedia request on {:?}", (
                &version
            ));

            let result = client.delete_media(
                version,
                account_id,
                media_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                DeleteMediaResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetMedia {
            version,
            account_id,
            media_id,
        } => {
            info!("Performing a GetMedia request on {:?}", (
                &version
            ));

            let result = client.get_media(
                version,
                account_id,
                media_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetMediaResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::SearchMedia {
            version,
            account_id,
            active_only,
            sort_field,
            descending,
            keyword,
            category_ids,
            filter_ids,
            start,
            limit,
        } => {
            info!("Performing a SearchMedia request on {:?}", (
                &version
            ));

            let result = client.search_media(
                version,
                account_id,
                active_only,
                sort_field,
                descending,
                keyword,
                category_ids,
                filter_ids,
                start,
                limit,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                SearchMediaResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::UpdateMedia {
            version,
            account_id,
            media_id,
            retailer_location_ids,
            offer_locations,
            title,
            sub_title,
            details,
            sub_details,
            fine_print,
            barcode_type,
            barcode_entry,
            external_redeem_options,
            external_url,
            tickets_reward_type,
            tickets_reward,
            activated,
            expires,
            no_expiration,
            available_limit,
            available_limit_per_user,
            added_limit,
            view_limit,
            max_prints,
            ticket_price_type,
            ticket_price,
            full_price,
            discount_price,
            show_remaining,
            show_redeemed,
            replaced,
            featured,
            special_offer_type,
            offer_visibility,
            category_ids,
            filter_ids,
            active,
            barcode_asset_id,
            image_asset_id,
            image_asset_id1,
            image_asset_id2,
            image_asset_id3,
            image_asset_id4,
            image_asset_id5,
            publisher,
            redeemable_start,
            redeemable_end,
            condition_type,
            isbn,
            asin,
            catalog_numbers,
            availability_date,
            parental_rating,
            media_type,
            duration,
            author,
            release_date,
            collection_ids,
            availability,
            availability_summary,
        } => {
            info!("Performing a UpdateMedia request on {:?}", (
                &version
            ));

            let result = client.update_media(
                version,
                account_id,
                media_id,
                retailer_location_ids,
                offer_locations,
                title,
                sub_title,
                details,
                sub_details,
                fine_print,
                barcode_type,
                barcode_entry,
                external_redeem_options,
                external_url,
                tickets_reward_type,
                tickets_reward,
                activated,
                expires,
                no_expiration,
                available_limit,
                available_limit_per_user,
                added_limit,
                view_limit,
                max_prints,
                ticket_price_type,
                ticket_price,
                full_price,
                discount_price,
                show_remaining,
                show_redeemed,
                replaced,
                featured,
                special_offer_type,
                offer_visibility,
                category_ids,
                filter_ids,
                active,
                barcode_asset_id,
                image_asset_id,
                image_asset_id1,
                image_asset_id2,
                image_asset_id3,
                image_asset_id4,
                image_asset_id5,
                publisher,
                redeemable_start,
                redeemable_end,
                condition_type,
                isbn,
                asin,
                catalog_numbers,
                availability_date,
                parental_rating,
                media_type,
                duration,
                author,
                release_date,
                collection_ids,
                availability,
                availability_summary,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                UpdateMediaResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::CreateMission {
            version,
            account_id,
            title,
            description,
            sub_type,
            start_date,
            end_date,
            active,
            game_level_ids,
            creative_ids,
            audience_ids,
            mission_task,
            format_type,
            offer_id,
            balance,
            advanced_reporting,
            allocate_tickets,
            ticket_count,
            ticket_type,
            points,
            meta_data,
            application_ids,
            devices,
            device_ids,
            device_versions,
            locations,
            radius,
        } => {
            info!("Performing a CreateMission request on {:?}", (
                &version
            ));

            let result = client.create_mission(
                version,
                account_id,
                title,
                description,
                sub_type,
                start_date,
                end_date,
                active,
                game_level_ids,
                creative_ids,
                audience_ids,
                mission_task,
                format_type,
                offer_id,
                balance,
                advanced_reporting,
                allocate_tickets,
                ticket_count,
                ticket_type,
                points,
                meta_data,
                application_ids,
                devices,
                device_ids,
                device_versions,
                locations,
                radius,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                CreateMissionResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::DeleteMission {
            version,
            account_id,
            mission_id,
        } => {
            info!("Performing a DeleteMission request on {:?}", (
                &version
            ));

            let result = client.delete_mission(
                version,
                account_id,
                mission_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                DeleteMissionResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::FindMissions {
            version,
            app_key,
            suffix,
            param_type,
            account_id,
            app_version,
            latitude,
            longitude,
            device,
            device_identifier,
            device_version,
            start,
            limit,
            include_game_data,
            include_audiences,
            allocates_tickets,
            randomize,
            targeted_ads_only,
            mission_ids,
            audience_operator,
        } => {
            info!("Performing a FindMissions request on {:?}", (
                &version
            ));

            let result = client.find_missions(
                version,
                app_key,
                suffix,
                param_type,
                account_id,
                app_version,
                latitude,
                longitude,
                device,
                device_identifier,
                device_version,
                start,
                limit,
                include_game_data,
                include_audiences,
                allocates_tickets,
                randomize,
                targeted_ads_only,
                mission_ids,
                audience_operator,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                FindMissionsResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetMission {
            version,
            account_id,
            mission_id,
            return_creative,
        } => {
            info!("Performing a GetMission request on {:?}", (
                &version
            ));

            let result = client.get_mission(
                version,
                account_id,
                mission_id,
                return_creative,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetMissionResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::ImportMission {
            version,
            account_id,
            latitude,
            longitude,
            app_key,
            keyword,
            start,
            limit,
            ad_size,
        } => {
            info!("Performing a ImportMission request on {:?}", (
                &version
            ));

            let result = client.import_mission(
                version,
                account_id,
                latitude,
                longitude,
                app_key,
                keyword,
                start,
                limit,
                ad_size,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                ImportMissionResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::SearchMissionFormats {
            version,
            start,
            limit,
            active_only,
        } => {
            info!("Performing a SearchMissionFormats request on {:?}", (
                &version
            ));

            let result = client.search_mission_formats(
                version,
                start,
                limit,
                active_only,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                SearchMissionFormatsResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::SearchMissions {
            version,
            account_id,
            keyword,
            sub_type,
            start,
            limit,
            include_game_data,
            include_audiences,
            include_inactive,
            suffix,
            sort_field,
            descending,
        } => {
            info!("Performing a SearchMissions request on {:?}", (
                &version
            ));

            let result = client.search_missions(
                version,
                account_id,
                keyword,
                sub_type,
                start,
                limit,
                include_game_data,
                include_audiences,
                include_inactive,
                suffix,
                sort_field,
                descending,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                SearchMissionsResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::SearchMissionsByBillableEntity {
            version,
            account_id,
            keyword,
            start,
            limit,
            include_game_data,
            include_audiences,
            include_inactive,
            suffix,
            sort_field,
            descending,
        } => {
            info!("Performing a SearchMissionsByBillableEntity request on {:?}", (
                &version
            ));

            let result = client.search_missions_by_billable_entity(
                version,
                account_id,
                keyword,
                start,
                limit,
                include_game_data,
                include_audiences,
                include_inactive,
                suffix,
                sort_field,
                descending,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                SearchMissionsByBillableEntityResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::UpdateMission {
            version,
            account_id,
            mission_id,
            title,
            description,
            sub_type,
            meta_data,
            start_date,
            end_date,
            active,
            game_level_ids,
            creative_ids,
            audience_ids,
            offer_id,
            balance,
            advanced_reporting,
            allocate_tickets,
            ticket_count,
            ticket_type,
            points,
            application_ids,
            devices,
            device_ids,
            device_versions,
            locations,
            radius,
        } => {
            info!("Performing a UpdateMission request on {:?}", (
                &version
            ));

            let result = client.update_mission(
                version,
                account_id,
                mission_id,
                title,
                description,
                sub_type,
                meta_data,
                start_date,
                end_date,
                active,
                game_level_ids,
                creative_ids,
                audience_ids,
                offer_id,
                balance,
                advanced_reporting,
                allocate_tickets,
                ticket_count,
                ticket_type,
                points,
                application_ids,
                devices,
                device_ids,
                device_versions,
                locations,
                radius,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                UpdateMissionResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::CreateMissionInvite {
            version,
            device_id,
            account_id,
            mission_id,
            join_code,
            include_game_data,
        } => {
            info!("Performing a CreateMissionInvite request on {:?}", (
                &version
            ));

            let result = client.create_mission_invite(
                version,
                device_id,
                account_id,
                mission_id,
                join_code,
                include_game_data,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                CreateMissionInviteResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::DeleteMissionInvite {
            version,
            device_id,
            account_id,
            mission_id,
            mission_invite_id,
            include_game_data,
        } => {
            info!("Performing a DeleteMissionInvite request on {:?}", (
                &version
            ));

            let result = client.delete_mission_invite(
                version,
                device_id,
                account_id,
                mission_id,
                mission_invite_id,
                include_game_data,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                DeleteMissionInviteResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetMissionInvite {
            version,
            device_id,
            account_id,
            mission_id,
            mission_invite_id,
            include_game_data,
            include_scores,
        } => {
            info!("Performing a GetMissionInvite request on {:?}", (
                &version
            ));

            let result = client.get_mission_invite(
                version,
                device_id,
                account_id,
                mission_id,
                mission_invite_id,
                include_game_data,
                include_scores,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetMissionInviteResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::SearchMissionInvites {
            version,
            device_id,
            account_id,
            app_key,
            app_version,
            mission_id,
            status,
            last_updated,
            start,
            limit,
            keyword,
            mission_types,
            filter_by_billable,
            include_game_data,
        } => {
            info!("Performing a SearchMissionInvites request on {:?}", (
                &version
            ));

            let result = client.search_mission_invites(
                version,
                device_id,
                account_id,
                app_key,
                app_version,
                mission_id,
                status,
                last_updated,
                start,
                limit,
                keyword,
                mission_types,
                filter_by_billable,
                include_game_data,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                SearchMissionInvitesResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::UpdateMissionInvite {
            version,
            device_id,
            account_id,
            app_key,
            mission_id,
            mission_invite_id,
            pack_id,
            game_level_id,
            status,
            permissionable_type,
            permissionable_id,
            include_game_data,
        } => {
            info!("Performing a UpdateMissionInvite request on {:?}", (
                &version
            ));

            let result = client.update_mission_invite(
                version,
                device_id,
                account_id,
                app_key,
                mission_id,
                mission_invite_id,
                pack_id,
                game_level_id,
                status,
                permissionable_type,
                permissionable_id,
                include_game_data,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                UpdateMissionInviteResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::BatchOperation {
            version,
            notable_id,
            notable_type,
            device_id,
            account_id,
            batch_operation,
        } => {
            info!("Performing a BatchOperation request on {:?}", (
                &version
            ));

            let result = client.batch_operation(
                version,
                notable_id,
                notable_type,
                device_id,
                account_id,
                batch_operation,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                BatchOperationResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::CreateNote {
            version,
            comment,
            device_id,
            account_id,
            notable_type,
            notable_id,
            note_type,
            asset_ids,
            tags,
            permissionable_type,
            permissionable_id,
            app_key,
            location_description,
            latitude,
            longitude,
            meta_data,
            receiver_account_ids,
            return_full_response,
            initialize_asset,
            asset_return_nulls,
            asset_album_id,
            asset_collection_id,
            asset_add_to_default_album,
            asset_add_to_media_library,
            asset_version_code,
            asset_version_name,
            asset_meta_data,
            asset_caption,
            asset_media,
            asset_media_url,
            asset_media_string,
            asset_media_string_file_name,
            asset_media_string_content_type,
            asset_attached_media,
            asset_attached_media_url,
            asset_attached_media_string,
            asset_attached_media_string_file_name,
            asset_attached_media_string_content_type,
            asset_location_description,
            asset_app,
            asset_search_tags,
            asset_latitude,
            asset_longitude,
        } => {
            info!("Performing a CreateNote request on {:?}", (
                &version
            ));

            let result = client.create_note(
                version,
                comment,
                device_id,
                account_id,
                notable_type,
                notable_id,
                note_type,
                asset_ids,
                tags,
                permissionable_type,
                permissionable_id,
                app_key,
                location_description,
                latitude,
                longitude,
                meta_data,
                receiver_account_ids,
                return_full_response,
                initialize_asset,
                asset_return_nulls,
                asset_album_id,
                asset_collection_id,
                asset_add_to_default_album,
                asset_add_to_media_library,
                asset_version_code,
                asset_version_name,
                asset_meta_data,
                asset_caption,
                asset_media,
                asset_media_url,
                asset_media_string,
                asset_media_string_file_name,
                asset_media_string_content_type,
                asset_attached_media,
                asset_attached_media_url,
                asset_attached_media_string,
                asset_attached_media_string_file_name,
                asset_attached_media_string_content_type,
                asset_location_description,
                asset_app,
                asset_search_tags,
                asset_latitude,
                asset_longitude,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                CreateNoteResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::DeleteNote {
            version,
            note_id,
            device_id,
            account_id,
            latitude,
            longitude,
            app_key,
        } => {
            info!("Performing a DeleteNote request on {:?}", (
                &version
            ));

            let result = client.delete_note(
                version,
                note_id,
                device_id,
                account_id,
                latitude,
                longitude,
                app_key,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                DeleteNoteResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetNote {
            version,
            note_id,
            device_id,
            account_id,
            return_full_response,
        } => {
            info!("Performing a GetNote request on {:?}", (
                &version
            ));

            let result = client.get_note(
                version,
                note_id,
                device_id,
                account_id,
                return_full_response,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetNoteResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::SearchNotes {
            version,
            device_id,
            account_id,
            notable_type,
            notable_id,
            note_types,
            app_key,
            keyword,
            flag_count_minimum,
            flags_exceed_threshold,
            include_inactive,
            sort_field,
            descending,
            return_full_response,
            updated_since,
            updated_before,
            start,
            limit,
        } => {
            info!("Performing a SearchNotes request on {:?}", (
                &version
            ));

            let result = client.search_notes(
                version,
                device_id,
                account_id,
                notable_type,
                notable_id,
                note_types,
                app_key,
                keyword,
                flag_count_minimum,
                flags_exceed_threshold,
                include_inactive,
                sort_field,
                descending,
                return_full_response,
                updated_since,
                updated_before,
                start,
                limit,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                SearchNotesResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::UpdateNote {
            version,
            note_id,
            device_id,
            account_id,
            comment,
            note_type,
            asset_ids,
            tags,
            permissionable_type,
            permissionable_id,
            app_key,
            location_description,
            latitude,
            longitude,
            meta_data,
            return_full_response,
            active,
            update_asset,
            asset_return_nulls,
            asset_album_id,
            asset_collection_id,
            asset_add_to_default_album,
            asset_add_to_media_library,
            asset_version_code,
            asset_version_name,
            asset_meta_data,
            asset_caption,
            asset_media,
            asset_media_url,
            asset_media_string,
            asset_media_string_file_name,
            asset_media_string_content_type,
            asset_attached_media,
            asset_attached_media_url,
            asset_attached_media_string,
            asset_attached_media_string_file_name,
            asset_attached_media_string_content_type,
            asset_location_description,
            asset_app,
            asset_search_tags,
            asset_latitude,
            asset_longitude,
        } => {
            info!("Performing a UpdateNote request on {:?}", (
                &version
            ));

            let result = client.update_note(
                version,
                note_id,
                device_id,
                account_id,
                comment,
                note_type,
                asset_ids,
                tags,
                permissionable_type,
                permissionable_id,
                app_key,
                location_description,
                latitude,
                longitude,
                meta_data,
                return_full_response,
                active,
                update_asset,
                asset_return_nulls,
                asset_album_id,
                asset_collection_id,
                asset_add_to_default_album,
                asset_add_to_media_library,
                asset_version_code,
                asset_version_name,
                asset_meta_data,
                asset_caption,
                asset_media,
                asset_media_url,
                asset_media_string,
                asset_media_string_file_name,
                asset_media_string_content_type,
                asset_attached_media,
                asset_attached_media_url,
                asset_attached_media_string,
                asset_attached_media_string_file_name,
                asset_attached_media_string_content_type,
                asset_location_description,
                asset_app,
                asset_search_tags,
                asset_latitude,
                asset_longitude,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                UpdateNoteResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::CreateNotificationTemplate {
            version,
            account_id,
            conduit,
            title,
            body,
            app_key,
            event,
            tags,
        } => {
            info!("Performing a CreateNotificationTemplate request on {:?}", (
                &version
            ));

            let result = client.create_notification_template(
                version,
                account_id,
                conduit,
                title,
                body,
                app_key,
                event,
                tags,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                CreateNotificationTemplateResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::CreateOrUpdateBlockedNotifications {
            version,
            app_key,
            data,
            account_id,
        } => {
            info!("Performing a CreateOrUpdateBlockedNotifications request on {:?}", (
                &version
            ));

            let result = client.create_or_update_blocked_notifications(
                version,
                app_key,
                data,
                account_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                CreateOrUpdateBlockedNotificationsResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::DeleteNotificationTemplate {
            version,
            account_id,
            notification_template_id,
        } => {
            info!("Performing a DeleteNotificationTemplate request on {:?}", (
                &version
            ));

            let result = client.delete_notification_template(
                version,
                account_id,
                notification_template_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                DeleteNotificationTemplateResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetNotificationTemplate {
            version,
            account_id,
            notification_template_id,
        } => {
            info!("Performing a GetNotificationTemplate request on {:?}", (
                &version
            ));

            let result = client.get_notification_template(
                version,
                account_id,
                notification_template_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetNotificationTemplateResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetNotifications {
            version,
            device_id,
            account_id,
            connection_account_id,
            app_key,
            event_type,
            content_ids,
            content_types,
            parent_ids,
            parent_types,
            action_category,
            conduits,
            keyword,
            return_read_messages,
            mark_as_read,
            from_date,
            latitude,
            longitude,
            return_sent,
            ignore_flagged,
            start,
            limit,
        } => {
            info!("Performing a GetNotifications request on {:?}", (
                &version
            ));

            let result = client.get_notifications(
                version,
                device_id,
                account_id,
                connection_account_id,
                app_key,
                event_type,
                content_ids,
                content_types,
                parent_ids,
                parent_types,
                action_category,
                conduits,
                keyword,
                return_read_messages,
                mark_as_read,
                from_date,
                latitude,
                longitude,
                return_sent,
                ignore_flagged,
                start,
                limit,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetNotificationsResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::RegisterNotificationToken {
            version,
            token,
            push_type,
            device_id,
            account_id,
            environment,
            app_key,
            game_type,
            active,
            latitude,
            longitude,
        } => {
            info!("Performing a RegisterNotificationToken request on {:?}", (
                &version
            ));

            let result = client.register_notification_token(
                version,
                token,
                push_type,
                device_id,
                account_id,
                environment,
                app_key,
                game_type,
                active,
                latitude,
                longitude,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                RegisterNotificationTokenResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::SearchBlockedNotifications {
            version,
            app_key,
            account_id,
            search_tags,
            events,
            conduits,
            custom_types,
            content_types,
            content_ids,
            sort_field,
            descending,
            start,
            limit,
        } => {
            info!("Performing a SearchBlockedNotifications request on {:?}", (
                &version
            ));

            let result = client.search_blocked_notifications(
                version,
                app_key,
                account_id,
                search_tags,
                events,
                conduits,
                custom_types,
                content_types,
                content_ids,
                sort_field,
                descending,
                start,
                limit,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                SearchBlockedNotificationsResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::SearchNotificationTemplate {
            version,
            account_id,
            sort_field,
            descending,
            start,
            limit,
            app_key,
            event,
            conduit,
            global_only,
            reserved_only,
            keyword,
        } => {
            info!("Performing a SearchNotificationTemplate request on {:?}", (
                &version
            ));

            let result = client.search_notification_template(
                version,
                account_id,
                sort_field,
                descending,
                start,
                limit,
                app_key,
                event,
                conduit,
                global_only,
                reserved_only,
                keyword,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                SearchNotificationTemplateResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::SearchRecipients {
            version,
            sort_field,
            device_id,
            account_id,
            app_key,
            conduit,
            keyword,
            audience_id,
            audience_ids,
            connection_group_ids,
            recipient_account_ids,
            descending,
            start,
            limit,
        } => {
            info!("Performing a SearchRecipients request on {:?}", (
                &version
            ));

            let result = client.search_recipients(
                version,
                sort_field,
                device_id,
                account_id,
                app_key,
                conduit,
                keyword,
                audience_id,
                audience_ids,
                connection_group_ids,
                recipient_account_ids,
                descending,
                start,
                limit,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                SearchRecipientsResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::SearchRecipientsCount {
            version,
            device_id,
            account_id,
            app_key,
            conduit,
            keyword,
            audience_id,
            audience_ids,
            connection_group_ids,
            sort_field,
            descending,
            start,
            limit,
        } => {
            info!("Performing a SearchRecipientsCount request on {:?}", (
                &version
            ));

            let result = client.search_recipients_count(
                version,
                device_id,
                account_id,
                app_key,
                conduit,
                keyword,
                audience_id,
                audience_ids,
                connection_group_ids,
                sort_field,
                descending,
                start,
                limit,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                SearchRecipientsCountResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::SendBatchNotifications {
            version,
            account_id,
            app_key,
            custom_message,
            conduit,
            content_id,
            content_name,
            content_type,
            parent_id,
            parent_type,
        } => {
            info!("Performing a SendBatchNotifications request on {:?}", (
                &version
            ));

            let result = client.send_batch_notifications(
                version,
                account_id,
                app_key,
                custom_message,
                conduit,
                content_id,
                content_name,
                content_type,
                parent_id,
                parent_type,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                SendBatchNotificationsResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::SendCustomNotifications {
            version,
            device_id,
            account_id,
            receiver_account_ids,
            include_friend_group,
            app_key,
            game_type,
            conduit,
            content_id,
            content_name,
            content_type,
            parent_id,
            parent_type,
            action_category,
            subject,
            custom_message,
            friend_only_apns,
            latitude,
            longitude,
        } => {
            info!("Performing a SendCustomNotifications request on {:?}", (
                &version
            ));

            let result = client.send_custom_notifications(
                version,
                device_id,
                account_id,
                receiver_account_ids,
                include_friend_group,
                app_key,
                game_type,
                conduit,
                content_id,
                content_name,
                content_type,
                parent_id,
                parent_type,
                action_category,
                subject,
                custom_message,
                friend_only_apns,
                latitude,
                longitude,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                SendCustomNotificationsResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::UpdateNotificationTemplate {
            version,
            account_id,
            notification_template_id,
            title,
            body,
            tags,
        } => {
            info!("Performing a UpdateNotificationTemplate request on {:?}", (
                &version
            ));

            let result = client.update_notification_template(
                version,
                account_id,
                notification_template_id,
                title,
                body,
                tags,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                UpdateNotificationTemplateResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::AddField {
            version,
            account_id,
            app_key,
            object_name,
            field_name,
            field_type,
        } => {
            info!("Performing a AddField request on {:?}", (
                &version
            ));

            let result = client.add_field(
                version,
                account_id,
                app_key,
                object_name,
                field_name,
                field_type,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                AddFieldResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::CreateObject {
            version,
            account_id,
            app_key,
            object_name,
        } => {
            info!("Performing a CreateObject request on {:?}", (
                &version
            ));

            let result = client.create_object(
                version,
                account_id,
                app_key,
                object_name,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                CreateObjectResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::DeleteField {
            version,
            account_id,
            app_key,
            object_name,
            field_name,
        } => {
            info!("Performing a DeleteField request on {:?}", (
                &version
            ));

            let result = client.delete_field(
                version,
                account_id,
                app_key,
                object_name,
                field_name,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                DeleteFieldResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::DeleteObject {
            version,
            account_id,
            app_key,
            object_name,
        } => {
            info!("Performing a DeleteObject request on {:?}", (
                &version
            ));

            let result = client.delete_object(
                version,
                account_id,
                app_key,
                object_name,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                DeleteObjectResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetObject {
            version,
            account_id,
            app_key,
            object_name,
        } => {
            info!("Performing a GetObject request on {:?}", (
                &version
            ));

            let result = client.get_object(
                version,
                account_id,
                app_key,
                object_name,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetObjectResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::SearchObject {
            version,
            account_id,
            app_key,
            start,
            limit,
            keyword,
        } => {
            info!("Performing a SearchObject request on {:?}", (
                &version
            ));

            let result = client.search_object(
                version,
                account_id,
                app_key,
                start,
                limit,
                keyword,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                SearchObjectResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::CreateData {
            version,
            object_name,
            account_id,
            body,
        } => {
            info!("Performing a CreateData request on {:?}", (
                &version,
                &object_name
            ));

            let result = client.create_data(
                version,
                object_name,
                account_id,
                body,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                CreateDataResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::SearchData {
            version,
            object_name,
            count,
            start,
            limit,
            account_id,
            criteria,
            order,
            include,
        } => {
            info!("Performing a SearchData request on {:?}", (
                &version,
                &object_name
            ));

            let result = client.search_data(
                version,
                object_name,
                count,
                start,
                limit,
                account_id,
                criteria,
                order,
                include,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                SearchDataResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::DeleteData {
            version,
            object_name,
            object_id,
            account_id,
        } => {
            prompt(args.force, "This will delete the given entry, are you sure?")?;
            info!("Performing a DeleteData request on {:?}", (
                &version,
                &object_name,
                &object_id
            ));

            let result = client.delete_data(
                version,
                object_name,
                object_id,
                account_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                DeleteDataResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetData {
            version,
            object_name,
            object_id,
            account_id,
            include,
        } => {
            info!("Performing a GetData request on {:?}", (
                &version,
                &object_name,
                &object_id
            ));

            let result = client.get_data(
                version,
                object_name,
                object_id,
                account_id,
                include,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetDataResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::UpdateData {
            version,
            object_name,
            object_id,
            account_id,
            body,
        } => {
            info!("Performing a UpdateData request on {:?}", (
                &version,
                &object_name,
                &object_id
            ));

            let result = client.update_data(
                version,
                object_name,
                object_id,
                account_id,
                body,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                UpdateDataResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::BatchUpdateOfferLocations {
            version,
            data,
            device_id,
            account_id,
        } => {
            info!("Performing a BatchUpdateOfferLocations request on {:?}", (
                &version
            ));

            let result = client.batch_update_offer_locations(
                version,
                data,
                device_id,
                account_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                BatchUpdateOfferLocationsResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::CreateOffer {
            version,
            include_offer_locations,
            title,
            barcode_type,
            no_expiration,
            available_limit,
            available_limit_per_user,
            added_limit,
            view_limit,
            max_prints,
            ticket_price,
            full_price,
            discount_price,
            offer_type,
            special_offer_type,
            offer_visibility,
            active,
            device_id,
            account_id,
            tags,
            parent_offer_id,
            retailer_location_ids,
            offer_locations,
            sub_title,
            details,
            sub_details,
            fine_print,
            barcode_entry,
            external_redeem_options,
            external_url,
            external_id,
            tickets_reward_type,
            tickets_reward,
            activated,
            expires,
            ticket_price_type,
            show_remaining,
            show_redeemed,
            replaced,
            featured,
            category_ids,
            filter_ids,
            barcode_asset_id,
            image_asset_id,
            image_asset_id1,
            image_asset_id2,
            image_asset_id3,
            image_asset_id4,
            image_asset_id5,
            publisher,
            redeemable_start,
            redeemable_end,
            brand,
            product_type,
            condition_type,
            isbn,
            asin,
            catalog_numbers,
            department,
            features,
            minimum_price,
            width,
            height,
            depth,
            weight,
            unit,
            studio,
            parental_rating,
            publish_date,
            availability_date,
            size_id,
            listing_id,
            media_type,
            duration,
            author,
            release_date,
            collection_ids,
            reboot_time_hour,
            reboot_time_minute,
            idle_timeout_in_second,
            serial_number,
            udid,
            device_type,
            device_power,
            device_interference,
            availability,
            availability_summary,
        } => {
            info!("Performing a CreateOffer request on {:?}", (
                &version
            ));

            let result = client.create_offer(
                version,
                include_offer_locations,
                title,
                barcode_type,
                no_expiration,
                available_limit,
                available_limit_per_user,
                added_limit,
                view_limit,
                max_prints,
                ticket_price,
                full_price,
                discount_price,
                offer_type,
                special_offer_type,
                offer_visibility,
                active,
                device_id,
                account_id,
                tags,
                parent_offer_id,
                retailer_location_ids,
                offer_locations,
                sub_title,
                details,
                sub_details,
                fine_print,
                barcode_entry,
                external_redeem_options,
                external_url,
                external_id,
                tickets_reward_type,
                tickets_reward,
                activated,
                expires,
                ticket_price_type,
                show_remaining,
                show_redeemed,
                replaced,
                featured,
                category_ids,
                filter_ids,
                barcode_asset_id,
                image_asset_id,
                image_asset_id1,
                image_asset_id2,
                image_asset_id3,
                image_asset_id4,
                image_asset_id5,
                publisher,
                redeemable_start,
                redeemable_end,
                brand,
                product_type,
                condition_type,
                isbn,
                asin,
                catalog_numbers,
                department,
                features,
                minimum_price,
                width,
                height,
                depth,
                weight,
                unit,
                studio,
                parental_rating,
                publish_date,
                availability_date,
                size_id,
                listing_id,
                media_type,
                duration,
                author,
                release_date,
                collection_ids,
                reboot_time_hour,
                reboot_time_minute,
                idle_timeout_in_second,
                serial_number,
                udid,
                device_type,
                device_power,
                device_interference,
                availability,
                availability_summary,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                CreateOfferResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::DeleteOffer {
            version,
            offer_id,
            device_id,
            account_id,
        } => {
            info!("Performing a DeleteOffer request on {:?}", (
                &version
            ));

            let result = client.delete_offer(
                version,
                offer_id,
                device_id,
                account_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                DeleteOfferResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::DeleteOfferLocation {
            version,
            offer_location_id,
            device_id,
            account_id,
        } => {
            info!("Performing a DeleteOfferLocation request on {:?}", (
                &version
            ));

            let result = client.delete_offer_location(
                version,
                offer_location_id,
                device_id,
                account_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                DeleteOfferLocationResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetOffer {
            version,
            offer_id,
            include_offer_locations,
            device_id,
            account_id,
        } => {
            info!("Performing a GetOffer request on {:?}", (
                &version
            ));

            let result = client.get_offer(
                version,
                offer_id,
                include_offer_locations,
                device_id,
                account_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetOfferResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetOfferDetails {
            version,
            device_id,
            account_id,
            offer_id,
            offer_location_id,
            distance,
            latitude,
            longitude,
            include_offer_locations,
            include_retailer_locations,
            include_child_offers,
        } => {
            info!("Performing a GetOfferDetails request on {:?}", (
                &version
            ));

            let result = client.get_offer_details(
                version,
                device_id,
                account_id,
                offer_id,
                offer_location_id,
                distance,
                latitude,
                longitude,
                include_offer_locations,
                include_retailer_locations,
                include_child_offers,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetOfferDetailsResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetOfferListCounts {
            version,
            latitude,
            longitude,
            search_range,
            distance_unit,
        } => {
            info!("Performing a GetOfferListCounts request on {:?}", (
                &version
            ));

            let result = client.get_offer_list_counts(
                version,
                latitude,
                longitude,
                search_range,
                distance_unit,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetOfferListCountsResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetOfferLocation {
            version,
            offer_location_id,
            udid,
        } => {
            info!("Performing a GetOfferLocation request on {:?}", (
                &version
            ));

            let result = client.get_offer_location(
                version,
                offer_location_id,
                udid,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetOfferLocationResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetOfferLocationsForRetailers {
            version,
            sort_field,
            descending,
            start,
            limit,
            active_only,
            include_retailer_location,
            device_id,
            account_id,
            keyword,
            retailer_id,
            retailer_location_id,
            offer_type,
            special_offer_type,
            barcode_type,
            barcode_entry,
            isbn,
            asin,
            device_status,
            needs_notification_sent,
            last_notification_sent,
        } => {
            info!("Performing a GetOfferLocationsForRetailers request on {:?}", (
                &version
            ));

            let result = client.get_offer_locations_for_retailers(
                version,
                sort_field,
                descending,
                start,
                limit,
                active_only,
                include_retailer_location,
                device_id,
                account_id,
                keyword,
                retailer_id,
                retailer_location_id,
                offer_type,
                special_offer_type,
                barcode_type,
                barcode_entry,
                isbn,
                asin,
                device_status,
                needs_notification_sent,
                last_notification_sent,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetOfferLocationsForRetailersResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetOffersForRetailers {
            version,
            offer_visibility,
            sort_field,
            descending,
            start,
            limit,
            available_only,
            active_only,
            include_categories,
            include_filters,
            include_offer_locations,
            device_id,
            account_id,
            category_ids,
            filter_ids,
            q,
            keyword,
            retailer_id,
            retailer_location_id,
            coupon_type,
            offer_type,
            offer_types,
            special_offer_type,
            _i,
            _l,
            barcode_type,
            barcode_entry,
            isbn,
            asin,
            device_status,
            needs_notification_sent,
            last_notification_sent,
        } => {
            info!("Performing a GetOffersForRetailers request on {:?}", (
                &version
            ));

            let result = client.get_offers_for_retailers(
                version,
                offer_visibility,
                sort_field,
                descending,
                start,
                limit,
                available_only,
                active_only,
                include_categories,
                include_filters,
                include_offer_locations,
                device_id,
                account_id,
                category_ids,
                filter_ids,
                q,
                keyword,
                retailer_id,
                retailer_location_id,
                coupon_type,
                offer_type,
                offer_types,
                special_offer_type,
                _i,
                _l,
                barcode_type,
                barcode_entry,
                isbn,
                asin,
                device_status,
                needs_notification_sent,
                last_notification_sent,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetOffersForRetailersResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::RedeemOfferTransaction {
            version,
            offer_transaction_id,
            status,
            device_id,
            account_id,
            offer_location_id,
        } => {
            info!("Performing a RedeemOfferTransaction request on {:?}", (
                &version
            ));

            let result = client.redeem_offer_transaction(
                version,
                offer_transaction_id,
                status,
                device_id,
                account_id,
                offer_location_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                RedeemOfferTransactionResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::SearchOfferTransactionsForRetailers {
            version,
            sort_field,
            descending,
            start,
            limit,
            active_only,
            device_id,
            account_id,
            q,
            keyword,
            retailer_id,
            retailer_location_id,
            offer_id,
            offer_location_id,
            redeemed,
            reservations_only,
            coupon_type,
            offer_type,
            special_offer_type,
            customer_account_ids,
            category_ids,
            redeemable_start_date,
            redeemable_end_date,
            _i,
            _l,
        } => {
            info!("Performing a SearchOfferTransactionsForRetailers request on {:?}", (
                &version
            ));

            let result = client.search_offer_transactions_for_retailers(
                version,
                sort_field,
                descending,
                start,
                limit,
                active_only,
                device_id,
                account_id,
                q,
                keyword,
                retailer_id,
                retailer_location_id,
                offer_id,
                offer_location_id,
                redeemed,
                reservations_only,
                coupon_type,
                offer_type,
                special_offer_type,
                customer_account_ids,
                category_ids,
                redeemable_start_date,
                redeemable_end_date,
                _i,
                _l,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                SearchOfferTransactionsForRetailersResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::SearchOffersForConsumer {
            version,
            latitude,
            longitude,
            recommendation_type,
            location_id,
            start,
            limit,
            max_recommendations,
            distance_unit,
            app_key,
            device_id,
            account_id,
            search_range,
            tags,
            supported_postal_codes,
            keyword,
            categories,
            filters,
            offer_types,
            param_type,
            sort_field,
            recommend_offer_ids,
            retailer_location_ids,
            offer_id,
            include_mission,
            include_categories,
            include_filters,
            include_expired,
            include_favorite,
            closest_offer_only,
            search_expression,
            group_by,
        } => {
            info!("Performing a SearchOffersForConsumer request on {:?}", (
                &version
            ));

            let result = client.search_offers_for_consumer(
                version,
                latitude,
                longitude,
                recommendation_type,
                location_id,
                start,
                limit,
                max_recommendations,
                distance_unit,
                app_key,
                device_id,
                account_id,
                search_range,
                tags,
                supported_postal_codes,
                keyword,
                categories,
                filters,
                offer_types,
                param_type,
                sort_field,
                recommend_offer_ids,
                retailer_location_ids,
                offer_id,
                include_mission,
                include_categories,
                include_filters,
                include_expired,
                include_favorite,
                closest_offer_only,
                search_expression,
                group_by,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                SearchOffersForConsumerResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::TopOfferTransactions {
            version,
            start,
            limit,
        } => {
            info!("Performing a TopOfferTransactions request on {:?}", (
                &version
            ));

            let result = client.top_offer_transactions(
                version,
                start,
                limit,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                TopOfferTransactionsResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::UpdateOffer {
            version,
            offer_id,
            include_offer_locations,
            device_id,
            account_id,
            parent_offer_id,
            retailer_location_ids,
            offer_locations,
            tags,
            title,
            sub_title,
            details,
            sub_details,
            fine_print,
            barcode_type,
            barcode_entry,
            external_redeem_options,
            external_url,
            external_id,
            tickets_reward_type,
            tickets_reward,
            activated,
            expires,
            no_expiration,
            available_limit,
            available_limit_per_user,
            added_limit,
            view_limit,
            max_prints,
            ticket_price_type,
            ticket_price,
            full_price,
            discount_price,
            show_remaining,
            show_redeemed,
            replaced,
            featured,
            offer_type,
            special_offer_type,
            offer_visibility,
            category_ids,
            filter_ids,
            active,
            barcode_asset_id,
            image_asset_id,
            image_asset_id1,
            image_asset_id2,
            image_asset_id3,
            image_asset_id4,
            image_asset_id5,
            publisher,
            redeemable_start,
            redeemable_end,
            brand,
            product_type,
            condition_type,
            isbn,
            asin,
            catalog_numbers,
            department,
            features,
            minimum_price,
            width,
            height,
            depth,
            weight,
            unit,
            studio,
            parental_rating,
            publish_date,
            availability_date,
            size_id,
            listing_id,
            media_type,
            duration,
            author,
            release_date,
            collection_ids,
            reboot_time_hour,
            reboot_time_minute,
            idle_timeout_in_second,
            serial_number,
            udid,
            device_type,
            device_power,
            device_interference,
            availability,
            availability_summary,
        } => {
            info!("Performing a UpdateOffer request on {:?}", (
                &version
            ));

            let result = client.update_offer(
                version,
                offer_id,
                include_offer_locations,
                device_id,
                account_id,
                parent_offer_id,
                retailer_location_ids,
                offer_locations,
                tags,
                title,
                sub_title,
                details,
                sub_details,
                fine_print,
                barcode_type,
                barcode_entry,
                external_redeem_options,
                external_url,
                external_id,
                tickets_reward_type,
                tickets_reward,
                activated,
                expires,
                no_expiration,
                available_limit,
                available_limit_per_user,
                added_limit,
                view_limit,
                max_prints,
                ticket_price_type,
                ticket_price,
                full_price,
                discount_price,
                show_remaining,
                show_redeemed,
                replaced,
                featured,
                offer_type,
                special_offer_type,
                offer_visibility,
                category_ids,
                filter_ids,
                active,
                barcode_asset_id,
                image_asset_id,
                image_asset_id1,
                image_asset_id2,
                image_asset_id3,
                image_asset_id4,
                image_asset_id5,
                publisher,
                redeemable_start,
                redeemable_end,
                brand,
                product_type,
                condition_type,
                isbn,
                asin,
                catalog_numbers,
                department,
                features,
                minimum_price,
                width,
                height,
                depth,
                weight,
                unit,
                studio,
                parental_rating,
                publish_date,
                availability_date,
                size_id,
                listing_id,
                media_type,
                duration,
                author,
                release_date,
                collection_ids,
                reboot_time_hour,
                reboot_time_minute,
                idle_timeout_in_second,
                serial_number,
                udid,
                device_type,
                device_power,
                device_interference,
                availability,
                availability_summary,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                UpdateOfferResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::UpdateOfferStatus {
            version,
            offer_ids,
            active,
            device_id,
            account_id,
        } => {
            info!("Performing a UpdateOfferStatus request on {:?}", (
                &version
            ));

            let result = client.update_offer_status(
                version,
                offer_ids,
                active,
                device_id,
                account_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                UpdateOfferStatusResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::CreateOfferTransactionStatus {
            version,
            name,
            code,
            device_id,
            account_id,
            latitude,
            longitude,
            description,
            role,
            active,
            application_ids,
        } => {
            info!("Performing a CreateOfferTransactionStatus request on {:?}", (
                &version
            ));

            let result = client.create_offer_transaction_status(
                version,
                name,
                code,
                device_id,
                account_id,
                latitude,
                longitude,
                description,
                role,
                active,
                application_ids,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                CreateOfferTransactionStatusResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::DeleteOfferTransactionStatus {
            version,
            status_id,
            device_id,
            account_id,
            latitude,
            longitude,
        } => {
            info!("Performing a DeleteOfferTransactionStatus request on {:?}", (
                &version
            ));

            let result = client.delete_offer_transaction_status(
                version,
                status_id,
                device_id,
                account_id,
                latitude,
                longitude,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                DeleteOfferTransactionStatusResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetOfferTransactionStatus {
            version,
            status_id,
            device_id,
            account_id,
            latitude,
            longitude,
        } => {
            info!("Performing a GetOfferTransactionStatus request on {:?}", (
                &version
            ));

            let result = client.get_offer_transaction_status(
                version,
                status_id,
                device_id,
                account_id,
                latitude,
                longitude,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetOfferTransactionStatusResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::SearchOfferTransactionStatuses {
            version,
            device_id,
            account_id,
            latitude,
            longitude,
            keyword,
            role,
            app_key,
            sort_field,
            descending,
            start,
            limit,
            include_inactive,
        } => {
            info!("Performing a SearchOfferTransactionStatuses request on {:?}", (
                &version
            ));

            let result = client.search_offer_transaction_statuses(
                version,
                device_id,
                account_id,
                latitude,
                longitude,
                keyword,
                role,
                app_key,
                sort_field,
                descending,
                start,
                limit,
                include_inactive,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                SearchOfferTransactionStatusesResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::UpdateOfferTransactionStatus {
            version,
            device_id,
            account_id,
            latitude,
            longitude,
            status_id,
            name,
            description,
            code,
            role,
            active,
            application_ids,
        } => {
            info!("Performing a UpdateOfferTransactionStatus request on {:?}", (
                &version
            ));

            let result = client.update_offer_transaction_status(
                version,
                device_id,
                account_id,
                latitude,
                longitude,
                status_id,
                name,
                description,
                code,
                role,
                active,
                application_ids,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                UpdateOfferTransactionStatusResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::ImageGeneration {
            version,
            account_id,
            post_body,
            return_raw_response,
        } => {
            info!("Performing a ImageGeneration request on {:?}", (
                &version
            ));

            let result = client.image_generation(
                version,
                account_id,
                post_body,
                return_raw_response,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                ImageGenerationResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::RequestOptimization {
            version,
            body,
        } => {
            info!("Performing a RequestOptimization request on {:?}", (
                &version
            ));

            let result = client.request_optimization(
                version,
                body,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                RequestOptimizationResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetOptimizationResult {
            version,
            batch_id,
            start,
            limit,
        } => {
            info!("Performing a GetOptimizationResult request on {:?}", (
                &version,
                &batch_id
            ));

            let result = client.get_optimization_result(
                version,
                batch_id,
                start,
                limit,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetOptimizationResultResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::AddMovie {
            version,
            account_id,
            movie_name,
            third_party_account_id,
            tags,
            file,
            url,
            callback,
        } => {
            info!("Performing a AddMovie request on {:?}", (
                &version
            ));

            let result = client.add_movie(
                version,
                account_id,
                movie_name,
                third_party_account_id,
                tags,
                file,
                url,
                callback,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                AddMovieResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::AiDocs {
            version,
            account_id,
            doc,
            return_topics,
            limit,
            offset,
        } => {
            info!("Performing a AiDocs request on {:?}", (
                &version
            ));

            let result = client.ai_docs(
                version,
                account_id,
                doc,
                return_topics,
                limit,
                offset,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                AiDocsResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::AiFindImages {
            version,
            account_id,
            text,
            parse_flag,
            fetch_flag,
            size,
        } => {
            info!("Performing a AiFindImages request on {:?}", (
                &version
            ));

            let result = client.ai_find_images(
                version,
                account_id,
                text,
                parse_flag,
                fetch_flag,
                size,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                AiFindImagesResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::AiTags {
            version,
            account_id,
            tags,
            conditional,
            limit,
            offset,
        } => {
            info!("Performing a AiTags request on {:?}", (
                &version
            ));

            let result = client.ai_tags(
                version,
                account_id,
                tags,
                conditional,
                limit,
                offset,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                AiTagsResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::AiText {
            version,
            account_id,
            terms,
            conditional,
            limit,
            offset,
        } => {
            info!("Performing a AiText request on {:?}", (
                &version
            ));

            let result = client.ai_text(
                version,
                account_id,
                terms,
                conditional,
                limit,
                offset,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                AiTextResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::Batch {
            version,
            account_id,
            third_party_account_id,
            limit,
            operations,
            file,
            url,
            callback,
        } => {
            info!("Performing a Batch request on {:?}", (
                &version
            ));

            let result = client.batch(
                version,
                account_id,
                third_party_account_id,
                limit,
                operations,
                file,
                url,
                callback,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                BatchResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::CreateInstantEpisode {
            version,
            account_id,
            data,
        } => {
            info!("Performing a CreateInstantEpisode request on {:?}", (
                &version
            ));

            let result = client.create_instant_episode(
                version,
                account_id,
                data,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                CreateInstantEpisodeResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::CreateVoiceCanvas {
            version,
            account_id,
            dimensions,
            third_party_account_id,
            text,
            file,
            url,
            parse_flag,
            fetch_flag,
            callback,
        } => {
            info!("Performing a CreateVoiceCanvas request on {:?}", (
                &version
            ));

            let result = client.create_voice_canvas(
                version,
                account_id,
                dimensions,
                third_party_account_id,
                text,
                file,
                url,
                parse_flag,
                fetch_flag,
                callback,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                CreateVoiceCanvasResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::Emotion {
            version,
            account_id,
            third_party_account_id,
            file,
            url,
            callback,
        } => {
            info!("Performing a Emotion request on {:?}", (
                &version
            ));

            let result = client.emotion(
                version,
                account_id,
                third_party_account_id,
                file,
                url,
                callback,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                EmotionResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::StartVideoRender {
            version,
            account_id,
            data,
        } => {
            info!("Performing a StartVideoRender request on {:?}", (
                &version
            ));

            let result = client.start_video_render(
                version,
                account_id,
                data,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                StartVideoRenderResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::Stt {
            version,
            account_id,
            third_party_account_id,
            source_language,
            target_language,
            file,
            url,
            callback,
        } => {
            info!("Performing a Stt request on {:?}", (
                &version
            ));

            let result = client.stt(
                version,
                account_id,
                third_party_account_id,
                source_language,
                target_language,
                file,
                url,
                callback,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                SttResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::SummarizeTopics {
            version,
            account_id,
            third_party_account_id,
            doc,
            file,
            url,
            limit,
            offset,
            callback,
        } => {
            info!("Performing a SummarizeTopics request on {:?}", (
                &version
            ));

            let result = client.summarize_topics(
                version,
                account_id,
                third_party_account_id,
                doc,
                file,
                url,
                limit,
                offset,
                callback,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                SummarizeTopicsResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::TechTune {
            version,
            account_id,
            num_faces_expected,
            third_party_account_id,
            file,
            url,
            callback,
        } => {
            info!("Performing a TechTune request on {:?}", (
                &version
            ));

            let result = client.tech_tune(
                version,
                account_id,
                num_faces_expected,
                third_party_account_id,
                file,
                url,
                callback,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                TechTuneResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::Tts {
            version,
            account_id,
            text,
            third_party_account_id,
            language,
            voice,
            callback,
        } => {
            info!("Performing a Tts request on {:?}", (
                &version
            ));

            let result = client.tts(
                version,
                account_id,
                text,
                third_party_account_id,
                language,
                voice,
                callback,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                TtsResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetAddMovieResult {
            version,
            request_id,
            account_id,
        } => {
            info!("Performing a GetAddMovieResult request on {:?}", (
                &version,
                &request_id
            ));

            let result = client.get_add_movie_result(
                version,
                request_id,
                account_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetAddMovieResultResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetBatch {
            version,
            request_id,
            account_id,
        } => {
            info!("Performing a GetBatch request on {:?}", (
                &version,
                &request_id
            ));

            let result = client.get_batch(
                version,
                request_id,
                account_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetBatchResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetEmotion {
            version,
            request_id,
            account_id,
        } => {
            info!("Performing a GetEmotion request on {:?}", (
                &version,
                &request_id
            ));

            let result = client.get_emotion(
                version,
                request_id,
                account_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetEmotionResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetEpisodeStatus {
            version,
            episode_id,
            account_id,
        } => {
            info!("Performing a GetEpisodeStatus request on {:?}", (
                &version,
                &episode_id
            ));

            let result = client.get_episode_status(
                version,
                episode_id,
                account_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetEpisodeStatusResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetRenderStatus {
            version,
            render_id,
            account_id,
        } => {
            info!("Performing a GetRenderStatus request on {:?}", (
                &version,
                &render_id
            ));

            let result = client.get_render_status(
                version,
                render_id,
                account_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetRenderStatusResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetStt {
            version,
            request_id,
            account_id,
        } => {
            info!("Performing a GetStt request on {:?}", (
                &version,
                &request_id
            ));

            let result = client.get_stt(
                version,
                request_id,
                account_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetSttResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetTechTune {
            version,
            request_id,
            account_id,
        } => {
            info!("Performing a GetTechTune request on {:?}", (
                &version,
                &request_id
            ));

            let result = client.get_tech_tune(
                version,
                request_id,
                account_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetTechTuneResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetTopics {
            version,
            request_id,
            account_id,
        } => {
            info!("Performing a GetTopics request on {:?}", (
                &version,
                &request_id
            ));

            let result = client.get_topics(
                version,
                request_id,
                account_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetTopicsResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetTts {
            version,
            request_id,
            account_id,
        } => {
            info!("Performing a GetTts request on {:?}", (
                &version,
                &request_id
            ));

            let result = client.get_tts(
                version,
                request_id,
                account_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetTtsResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetVoiceCanvas {
            version,
            request_id,
            account_id,
        } => {
            info!("Performing a GetVoiceCanvas request on {:?}", (
                &version,
                &request_id
            ));

            let result = client.get_voice_canvas(
                version,
                request_id,
                account_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetVoiceCanvasResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::CreatePack {
            version,
            account_id,
            title,
            pack_order,
            price,
            highest,
            allocate_tickets,
            ticket_count,
            description,
            search_tags,
            active,
            game_type,
            app_key,
            pack_type,
            sequence_type,
            background_id,
            image_id,
            start_date,
            end_date,
            author_override,
            price_type,
            game_level_ids,
            in_game,
            ticket_type,
            points,
        } => {
            info!("Performing a CreatePack request on {:?}", (
                &version
            ));

            let result = client.create_pack(
                version,
                account_id,
                title,
                pack_order,
                price,
                highest,
                allocate_tickets,
                ticket_count,
                description,
                search_tags,
                active,
                game_type,
                app_key,
                pack_type,
                sequence_type,
                background_id,
                image_id,
                start_date,
                end_date,
                author_override,
                price_type,
                game_level_ids,
                in_game,
                ticket_type,
                points,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                CreatePackResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::DeletePack {
            version,
            account_id,
            pack_id,
        } => {
            info!("Performing a DeletePack request on {:?}", (
                &version
            ));

            let result = client.delete_pack(
                version,
                account_id,
                pack_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                DeletePackResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetPack {
            version,
            account_id,
            pack_id,
            include_game_data,
        } => {
            info!("Performing a GetPack request on {:?}", (
                &version
            ));

            let result = client.get_pack(
                version,
                account_id,
                pack_id,
                include_game_data,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetPackResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::SearchPacks {
            version,
            account_id,
            sort_field,
            descending,
            keyword,
            pack_type,
            start,
            limit,
            include_game_data,
            include_inactive,
            app_key,
        } => {
            info!("Performing a SearchPacks request on {:?}", (
                &version
            ));

            let result = client.search_packs(
                version,
                account_id,
                sort_field,
                descending,
                keyword,
                pack_type,
                start,
                limit,
                include_game_data,
                include_inactive,
                app_key,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                SearchPacksResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::UpdatePack {
            version,
            account_id,
            pack_id,
            allocate_tickets,
            ticket_count,
            title,
            description,
            search_tags,
            active,
            game_type,
            app_key,
            pack_type,
            pack_order,
            sequence_type,
            background_id,
            image_id,
            start_date,
            end_date,
            author_override,
            price,
            price_type,
            game_level_ids,
            in_game,
            highest,
            ticket_type,
            points,
        } => {
            info!("Performing a UpdatePack request on {:?}", (
                &version
            ));

            let result = client.update_pack(
                version,
                account_id,
                pack_id,
                allocate_tickets,
                ticket_count,
                title,
                description,
                search_tags,
                active,
                game_type,
                app_key,
                pack_type,
                pack_order,
                sequence_type,
                background_id,
                image_id,
                start_date,
                end_date,
                author_override,
                price,
                price_type,
                game_level_ids,
                in_game,
                highest,
                ticket_type,
                points,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                UpdatePackResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::ProcessAllParticipants {
            version,
            account_id,
            app_key,
            use_short_name_as_id,
        } => {
            info!("Performing a ProcessAllParticipants request on {:?}", (
                &version
            ));

            let result = client.process_all_participants(
                version,
                account_id,
                app_key,
                use_short_name_as_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                ProcessAllParticipantsResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::ProcessParticipants {
            version,
            account_id,
            league,
            app_key,
            use_short_name_as_id,
            file,
        } => {
            info!("Performing a ProcessParticipants request on {:?}", (
                &version
            ));

            let result = client.process_participants(
                version,
                account_id,
                league,
                app_key,
                use_short_name_as_id,
                file,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                ProcessParticipantsResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::ComputePath {
            version,
            data,
            units,
            reduce_path,
            directions,
        } => {
            info!("Performing a ComputePath request on {:?}", (
                &version
            ));

            let result = client.compute_path(
                version,
                data,
                units,
                reduce_path,
                directions,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                ComputePathResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::CreatePostalCode {
            version,
            account_id,
            code,
            latitude,
            longitude,
            state_code,
            city,
            active,
        } => {
            info!("Performing a CreatePostalCode request on {:?}", (
                &version
            ));

            let result = client.create_postal_code(
                version,
                account_id,
                code,
                latitude,
                longitude,
                state_code,
                city,
                active,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                CreatePostalCodeResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::DeletePostalCode {
            version,
            account_id,
            postal_code_id,
        } => {
            info!("Performing a DeletePostalCode request on {:?}", (
                &version
            ));

            let result = client.delete_postal_code(
                version,
                account_id,
                postal_code_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                DeletePostalCodeResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetPostalCode {
            version,
            postal_code_id,
        } => {
            info!("Performing a GetPostalCode request on {:?}", (
                &version
            ));

            let result = client.get_postal_code(
                version,
                postal_code_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetPostalCodeResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetPostalCodes {
            version,
            sort_field,
            descending,
            latitude,
            longitude,
            keyword,
            miles,
            start,
            limit,
        } => {
            info!("Performing a GetPostalCodes request on {:?}", (
                &version
            ));

            let result = client.get_postal_codes(
                version,
                sort_field,
                descending,
                latitude,
                longitude,
                keyword,
                miles,
                start,
                limit,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetPostalCodesResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::UpdatePostalCode {
            version,
            account_id,
            postal_code_id,
            code,
            latitude,
            longitude,
            state_code,
            city,
            active,
        } => {
            info!("Performing a UpdatePostalCode request on {:?}", (
                &version
            ));

            let result = client.update_postal_code(
                version,
                account_id,
                postal_code_id,
                code,
                latitude,
                longitude,
                state_code,
                city,
                active,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                UpdatePostalCodeResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::CreatePersona {
            version,
            account_id,
            title,
            preview_accounts,
            date,
            age,
            gender,
            game_experience_level,
            latitude,
            longitude,
        } => {
            info!("Performing a CreatePersona request on {:?}", (
                &version
            ));

            let result = client.create_persona(
                version,
                account_id,
                title,
                preview_accounts,
                date,
                age,
                gender,
                game_experience_level,
                latitude,
                longitude,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                CreatePersonaResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::DeletePersona {
            version,
            account_id,
            persona_id,
        } => {
            info!("Performing a DeletePersona request on {:?}", (
                &version
            ));

            let result = client.delete_persona(
                version,
                account_id,
                persona_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                DeletePersonaResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetPersonaList {
            version,
            account_id,
            persona_id,
        } => {
            info!("Performing a GetPersonaList request on {:?}", (
                &version
            ));

            let result = client.get_persona_list(
                version,
                account_id,
                persona_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetPersonaListResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::SearchPersona {
            version,
            account_id,
            start,
            limit,
        } => {
            info!("Performing a SearchPersona request on {:?}", (
                &version
            ));

            let result = client.search_persona(
                version,
                account_id,
                start,
                limit,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                SearchPersonaResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::UpdatePersona {
            version,
            account_id,
            persona_id,
            title,
            preview_accounts,
            active,
            date,
            age,
            gender,
            game_experience_level,
            latitude,
            longitude,
        } => {
            info!("Performing a UpdatePersona request on {:?}", (
                &version
            ));

            let result = client.update_persona(
                version,
                account_id,
                persona_id,
                title,
                preview_accounts,
                active,
                date,
                age,
                gender,
                game_experience_level,
                latitude,
                longitude,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                UpdatePersonaResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::CreateProgram {
            version,
            body,
        } => {
            info!("Performing a CreateProgram request on {:?}", (
                &version
            ));

            let result = client.create_program(
                version,
                body,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                CreateProgramResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::SearchPrograms {
            version,
            sort_field,
            descending,
            start,
            limit,
            active_only,
            keyword,
        } => {
            info!("Performing a SearchPrograms request on {:?}", (
                &version
            ));

            let result = client.search_programs(
                version,
                sort_field,
                descending,
                start,
                limit,
                active_only,
                keyword,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                SearchProgramsResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::DeleteProgram {
            version,
            id,
        } => {
            prompt(args.force, "This will delete the given entry, are you sure?")?;
            info!("Performing a DeleteProgram request on {:?}", (
                &version,
                &id
            ));

            let result = client.delete_program(
                version,
                id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                DeleteProgramResponse::SuccessfulOperation
                => "SuccessfulOperation\n".to_string()
                    ,
            }
        }
        Operation::GetProgram {
            version,
            id,
        } => {
            info!("Performing a GetProgram request on {:?}", (
                &version,
                &id
            ));

            let result = client.get_program(
                version,
                id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetProgramResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::PostProgram {
            version,
            id,
            body,
        } => {
            info!("Performing a PostProgram request on {:?}", (
                &version,
                &id
            ));

            let result = client.post_program(
                version,
                id,
                body,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                PostProgramResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::PutProgram {
            version,
            id,
            body,
        } => {
            info!("Performing a PutProgram request on {:?}", (
                &version,
                &id
            ));

            let result = client.put_program(
                version,
                id,
                body,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                PutProgramResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::CreatePurchaseItem {
            version,
            app_key,
            name,
            purchase_type,
            device_id,
            account_id,
            description,
            tickets,
            price,
            purchase_code,
            secret_key,
            purchase_limit,
            service_action,
            cover_asset_id,
            promo_asset_id,
            giftable,
            assetable,
            allocate_tickets,
            ticket_type,
            points,
            offer_location_id,
        } => {
            info!("Performing a CreatePurchaseItem request on {:?}", (
                &version
            ));

            let result = client.create_purchase_item(
                version,
                app_key,
                name,
                purchase_type,
                device_id,
                account_id,
                description,
                tickets,
                price,
                purchase_code,
                secret_key,
                purchase_limit,
                service_action,
                cover_asset_id,
                promo_asset_id,
                giftable,
                assetable,
                allocate_tickets,
                ticket_type,
                points,
                offer_location_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                CreatePurchaseItemResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::DeletePurchaseItem {
            version,
            purchase_item_id,
            device_id,
            account_id,
        } => {
            info!("Performing a DeletePurchaseItem request on {:?}", (
                &version
            ));

            let result = client.delete_purchase_item(
                version,
                purchase_item_id,
                device_id,
                account_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                DeletePurchaseItemResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetPurchaseItem {
            version,
            purchase_item_id,
            device_id,
            account_id,
        } => {
            info!("Performing a GetPurchaseItem request on {:?}", (
                &version
            ));

            let result = client.get_purchase_item(
                version,
                purchase_item_id,
                device_id,
                account_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetPurchaseItemResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::SearchPurchaseItems {
            version,
            device_id,
            account_id,
            app_key,
            filter_by_billable,
            purchase_type,
            service_action,
            keyword,
            sort_field,
            descending,
            start,
            limit,
            active_only,
        } => {
            info!("Performing a SearchPurchaseItems request on {:?}", (
                &version
            ));

            let result = client.search_purchase_items(
                version,
                device_id,
                account_id,
                app_key,
                filter_by_billable,
                purchase_type,
                service_action,
                keyword,
                sort_field,
                descending,
                start,
                limit,
                active_only,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                SearchPurchaseItemsResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::UpdatePurchaseItem {
            version,
            purchase_item_id,
            device_id,
            account_id,
            name,
            description,
            tickets,
            price,
            purchase_type,
            purchase_code,
            secret_key,
            purchase_limit,
            service_action,
            cover_asset_id,
            promo_asset_id,
            giftable,
            assetable,
            active,
            allocate_tickets,
            ticket_type,
            points,
            offer_location_id,
        } => {
            info!("Performing a UpdatePurchaseItem request on {:?}", (
                &version
            ));

            let result = client.update_purchase_item(
                version,
                purchase_item_id,
                device_id,
                account_id,
                name,
                description,
                tickets,
                price,
                purchase_type,
                purchase_code,
                secret_key,
                purchase_limit,
                service_action,
                cover_asset_id,
                promo_asset_id,
                giftable,
                assetable,
                active,
                allocate_tickets,
                ticket_type,
                points,
                offer_location_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                UpdatePurchaseItemResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::CreateOrder {
            version,
            app_key,
            cart,
            device_id,
            account_id,
            description,
            currency_type,
            payment_method_id,
            external_order_id,
            external_payment_id,
            remote_ref_type,
            external_date,
            promo_code,
        } => {
            info!("Performing a CreateOrder request on {:?}", (
                &version
            ));

            let result = client.create_order(
                version,
                app_key,
                cart,
                device_id,
                account_id,
                description,
                currency_type,
                payment_method_id,
                external_order_id,
                external_payment_id,
                remote_ref_type,
                external_date,
                promo_code,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                CreateOrderResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::DeleteOrder {
            version,
            order_id,
            device_id,
            account_id,
        } => {
            info!("Performing a DeleteOrder request on {:?}", (
                &version
            ));

            let result = client.delete_order(
                version,
                order_id,
                device_id,
                account_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                DeleteOrderResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetOrder {
            version,
            device_id,
            account_id,
            order_id,
            external_order_id,
        } => {
            info!("Performing a GetOrder request on {:?}", (
                &version
            ));

            let result = client.get_order(
                version,
                device_id,
                account_id,
                order_id,
                external_order_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetOrderResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::PreviewOrder {
            version,
            app_key,
            cart,
            device_id,
            account_id,
            description,
            currency_type,
            payment_method_id,
            external_order_id,
            external_payment_id,
            remote_ref_type,
            external_date,
            promo_code,
        } => {
            info!("Performing a PreviewOrder request on {:?}", (
                &version
            ));

            let result = client.preview_order(
                version,
                app_key,
                cart,
                device_id,
                account_id,
                description,
                currency_type,
                payment_method_id,
                external_order_id,
                external_payment_id,
                remote_ref_type,
                external_date,
                promo_code,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                PreviewOrderResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::SearchOrders {
            version,
            app_key,
            device_id,
            account_id,
            start,
            limit,
            descending,
            active_only,
            ignore_customer_filter,
            order_item_types,
            order_item_ids,
            order_custom_types,
            order_custom_ids,
            sort_field,
            offer_types,
            special_offer_types,
            category_ids,
            filter_ids,
            offer_audience_ids,
            transaction_audience_ids,
            offer_ids,
            offer_location_ids,
            retailer_ids,
            retailer_location_ids,
            statuses,
            keyword,
            redeemable_start_date,
            redeemable_end_date,
            started_since,
            started_before,
            ended_since,
            ended_before,
        } => {
            info!("Performing a SearchOrders request on {:?}", (
                &version
            ));

            let result = client.search_orders(
                version,
                app_key,
                device_id,
                account_id,
                start,
                limit,
                descending,
                active_only,
                ignore_customer_filter,
                order_item_types,
                order_item_ids,
                order_custom_types,
                order_custom_ids,
                sort_field,
                offer_types,
                special_offer_types,
                category_ids,
                filter_ids,
                offer_audience_ids,
                transaction_audience_ids,
                offer_ids,
                offer_location_ids,
                retailer_ids,
                retailer_location_ids,
                statuses,
                keyword,
                redeemable_start_date,
                redeemable_end_date,
                started_since,
                started_before,
                ended_since,
                ended_before,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                SearchOrdersResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::UpdateOrder {
            version,
            order_id,
            app_key,
            cart,
            device_id,
            account_id,
            payment_transaction_id,
            description,
            currency_type,
            payment_method_id,
            external_payment_id,
            external_date,
        } => {
            info!("Performing a UpdateOrder request on {:?}", (
                &version
            ));

            let result = client.update_order(
                version,
                order_id,
                app_key,
                cart,
                device_id,
                account_id,
                payment_transaction_id,
                description,
                currency_type,
                payment_method_id,
                external_payment_id,
                external_date,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                UpdateOrderResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::CreateQuestion {
            version,
            account_id,
            question,
            answers,
            active,
            allocate_tickets,
            ticket_count,
            tags,
            video_url,
            asset_id,
            ticket_type,
            points,
        } => {
            info!("Performing a CreateQuestion request on {:?}", (
                &version
            ));

            let result = client.create_question(
                version,
                account_id,
                question,
                answers,
                active,
                allocate_tickets,
                ticket_count,
                tags,
                video_url,
                asset_id,
                ticket_type,
                points,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                CreateQuestionResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::DeleteQuestion {
            version,
            question_id,
            account_id,
        } => {
            info!("Performing a DeleteQuestion request on {:?}", (
                &version
            ));

            let result = client.delete_question(
                version,
                question_id,
                account_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                DeleteQuestionResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetQuestion {
            version,
            question_id,
            account_id,
        } => {
            info!("Performing a GetQuestion request on {:?}", (
                &version
            ));

            let result = client.get_question(
                version,
                question_id,
                account_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetQuestionResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::SearchQuestions {
            version,
            account_id,
            sort_field,
            descending,
            active_only,
            start,
            limit,
            keyword,
        } => {
            info!("Performing a SearchQuestions request on {:?}", (
                &version
            ));

            let result = client.search_questions(
                version,
                account_id,
                sort_field,
                descending,
                active_only,
                start,
                limit,
                keyword,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                SearchQuestionsResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::UpdateQuestion {
            version,
            question_id,
            account_id,
            ticket_count,
            question,
            answers,
            tags,
            video_url,
            asset_id,
            active,
            allocate_tickets,
            ticket_type,
            points,
        } => {
            info!("Performing a UpdateQuestion request on {:?}", (
                &version
            ));

            let result = client.update_question(
                version,
                question_id,
                account_id,
                ticket_count,
                question,
                answers,
                tags,
                video_url,
                asset_id,
                active,
                allocate_tickets,
                ticket_type,
                points,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                UpdateQuestionResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetHistoricalRankings {
            version,
            app_key,
            rank_type,
            start_date,
            end_date,
            device_id,
            account_id,
            sort_field,
            descending,
            start,
            limit,
        } => {
            info!("Performing a GetHistoricalRankings request on {:?}", (
                &version
            ));

            let result = client.get_historical_rankings(
                version,
                app_key,
                rank_type,
                start_date,
                end_date,
                device_id,
                account_id,
                sort_field,
                descending,
                start,
                limit,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetHistoricalRankingsResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetRankings {
            version,
            device_id,
            account_id,
            game_type,
            app_key,
            q,
            keyword,
            rank_type,
            leaderboard_mode,
            within_account_ids,
            return_user_rank,
            album_id,
            audience_id,
            sort_field,
            descending,
            _i,
            start,
            _l,
            limit,
        } => {
            info!("Performing a GetRankings request on {:?}", (
                &version
            ));

            let result = client.get_rankings(
                version,
                device_id,
                account_id,
                game_type,
                app_key,
                q,
                keyword,
                rank_type,
                leaderboard_mode,
                within_account_ids,
                return_user_rank,
                album_id,
                audience_id,
                sort_field,
                descending,
                _i,
                start,
                _l,
                limit,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetRankingsResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetUserRank {
            version,
            device_id,
            account_id,
            app_key,
            rank_type,
            return_user_rank,
            leaderboard_mode,
            sort_field,
            keyword,
            descending,
            start,
            limit,
        } => {
            info!("Performing a GetUserRank request on {:?}", (
                &version
            ));

            let result = client.get_user_rank(
                version,
                device_id,
                account_id,
                app_key,
                rank_type,
                return_user_rank,
                leaderboard_mode,
                sort_field,
                keyword,
                descending,
                start,
                limit,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetUserRankResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::OverrideUserRank {
            version,
            account_id,
            owner_account_id,
            app_key,
            rank_type,
            total_score,
            total_count,
            total_time,
            daily_score,
            daily_count,
            daily_time,
            weekly_score,
            weekly_count,
            weekly_time,
            monthly_score,
            monthly_count,
            monthly_time,
            top_score,
            lowest_score,
            streak_count,
            streak_best_count,
            start_date,
            end_date,
        } => {
            info!("Performing a OverrideUserRank request on {:?}", (
                &version
            ));

            let result = client.override_user_rank(
                version,
                account_id,
                owner_account_id,
                app_key,
                rank_type,
                total_score,
                total_count,
                total_time,
                daily_score,
                daily_count,
                daily_time,
                weekly_score,
                weekly_count,
                weekly_time,
                monthly_score,
                monthly_count,
                monthly_time,
                top_score,
                lowest_score,
                streak_count,
                streak_best_count,
                start_date,
                end_date,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                OverrideUserRankResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::UpdateRankings {
            version,
            account_id,
            app_key,
            rank_type,
            increment,
            time_increment,
            tag,
            start_date,
            end_date,
            update_global,
            create_leaderboard,
        } => {
            info!("Performing a UpdateRankings request on {:?}", (
                &version
            ));

            let result = client.update_rankings(
                version,
                account_id,
                app_key,
                rank_type,
                increment,
                time_increment,
                tag,
                start_date,
                end_date,
                update_global,
                create_leaderboard,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                UpdateRankingsResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::CreateRating {
            version,
            ratable_type,
            ratable_id,
            rating_value,
            device_id,
            account_id,
            category_id,
            display,
            description,
            location_description,
            latitude,
            longitude,
        } => {
            info!("Performing a CreateRating request on {:?}", (
                &version
            ));

            let result = client.create_rating(
                version,
                ratable_type,
                ratable_id,
                rating_value,
                device_id,
                account_id,
                category_id,
                display,
                description,
                location_description,
                latitude,
                longitude,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                CreateRatingResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::DeleteRating {
            version,
            rating_id,
            device_id,
            account_id,
        } => {
            info!("Performing a DeleteRating request on {:?}", (
                &version
            ));

            let result = client.delete_rating(
                version,
                rating_id,
                device_id,
                account_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                DeleteRatingResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::SearchLocationRatingIndexes {
            version,
            category_ids,
            keyword,
            location_type,
            sort_field,
            descending,
            start,
            limit,
            search_range,
            latitude,
            longitude,
            return_overall_rating,
            distance_unit,
            return_retailer,
            return_assets,
            return_offers,
            return_categories,
            return_filters,
        } => {
            info!("Performing a SearchLocationRatingIndexes request on {:?}", (
                &version
            ));

            let result = client.search_location_rating_indexes(
                version,
                category_ids,
                keyword,
                location_type,
                sort_field,
                descending,
                start,
                limit,
                search_range,
                latitude,
                longitude,
                return_overall_rating,
                distance_unit,
                return_retailer,
                return_assets,
                return_offers,
                return_categories,
                return_filters,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                SearchLocationRatingIndexesResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::SearchRatingIndexes {
            version,
            ratable_type,
            ratable_ids,
            category_ids,
            secondary_type,
            keyword,
            sort_field,
            descending,
            start,
            limit,
            latitude,
            longitude,
            return_ratable,
            return_overall_rating,
        } => {
            info!("Performing a SearchRatingIndexes request on {:?}", (
                &version
            ));

            let result = client.search_rating_indexes(
                version,
                ratable_type,
                ratable_ids,
                category_ids,
                secondary_type,
                keyword,
                sort_field,
                descending,
                start,
                limit,
                latitude,
                longitude,
                return_ratable,
                return_overall_rating,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                SearchRatingIndexesResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::SearchRatings {
            version,
            device_id,
            account_id,
            filter_account_id,
            ratable_type,
            ratable_id,
            category_ids,
            keyword,
            sort_field,
            descending,
            start,
            limit,
        } => {
            info!("Performing a SearchRatings request on {:?}", (
                &version
            ));

            let result = client.search_ratings(
                version,
                device_id,
                account_id,
                filter_account_id,
                ratable_type,
                ratable_id,
                category_ids,
                keyword,
                sort_field,
                descending,
                start,
                limit,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                SearchRatingsResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::UpdateRating {
            version,
            rating_id,
            device_id,
            account_id,
            rating_value,
            category_id,
            display,
            description,
            location_description,
            latitude,
            longitude,
        } => {
            info!("Performing a UpdateRating request on {:?}", (
                &version
            ));

            let result = client.update_rating(
                version,
                rating_id,
                device_id,
                account_id,
                rating_value,
                category_id,
                display,
                description,
                location_description,
                latitude,
                longitude,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                UpdateRatingResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::CreateRegion {
            version,
            account_id,
            region_class,
            short_name,
            full_name,
            parent_ids,
            children_ids,
            postal_code_ids,
            locations,
            retailer_location_id,
            visibility,
            category_ids,
            filter_ids,
            start,
            end,
            polygon,
            meta_data,
            latitude,
            longitude,
            version_code,
            root,
            active,
        } => {
            info!("Performing a CreateRegion request on {:?}", (
                &version
            ));

            let result = client.create_region(
                version,
                account_id,
                region_class,
                short_name,
                full_name,
                parent_ids,
                children_ids,
                postal_code_ids,
                locations,
                retailer_location_id,
                visibility,
                category_ids,
                filter_ids,
                start,
                end,
                polygon,
                meta_data,
                latitude,
                longitude,
                version_code,
                root,
                active,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                CreateRegionResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::DeleteRegion {
            version,
            account_id,
            region_id,
        } => {
            info!("Performing a DeleteRegion request on {:?}", (
                &version
            ));

            let result = client.delete_region(
                version,
                account_id,
                region_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                DeleteRegionResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetRegion {
            version,
            region_id,
            account_id,
        } => {
            info!("Performing a GetRegion request on {:?}", (
                &version
            ));

            let result = client.get_region(
                version,
                region_id,
                account_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetRegionResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::SearchRegions {
            version,
            account_id,
            query,
            keyword,
            latitude,
            longitude,
            range,
            region_class,
            visibility,
            search_mode,
            sort_field,
            descending,
            include_parent,
            include_children,
            include_postal_codes,
            category_ids,
            filter_ids,
            version_code,
            active_only,
            show_deleted,
            last_updated_since,
            start,
            limit,
        } => {
            info!("Performing a SearchRegions request on {:?}", (
                &version
            ));

            let result = client.search_regions(
                version,
                account_id,
                query,
                keyword,
                latitude,
                longitude,
                range,
                region_class,
                visibility,
                search_mode,
                sort_field,
                descending,
                include_parent,
                include_children,
                include_postal_codes,
                category_ids,
                filter_ids,
                version_code,
                active_only,
                show_deleted,
                last_updated_since,
                start,
                limit,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                SearchRegionsResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::UpdateRegion {
            version,
            account_id,
            region_id,
            region_class,
            short_name,
            full_name,
            parent_ids,
            children_ids,
            postal_code_ids,
            locations,
            retailer_location_id,
            visibility,
            category_ids,
            filter_ids,
            start,
            end,
            polygon,
            meta_data,
            latitude,
            longitude,
            version_code,
            root,
            active,
            clear_lists,
        } => {
            info!("Performing a UpdateRegion request on {:?}", (
                &version
            ));

            let result = client.update_region(
                version,
                account_id,
                region_id,
                region_class,
                short_name,
                full_name,
                parent_ids,
                children_ids,
                postal_code_ids,
                locations,
                retailer_location_id,
                visibility,
                category_ids,
                filter_ids,
                start,
                end,
                polygon,
                meta_data,
                latitude,
                longitude,
                version_code,
                root,
                active,
                clear_lists,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                UpdateRegionResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::CreateBatch {
            version,
            account_id,
            status,
            preview_limit,
            app_key,
            endpoint,
            parameters,
            name,
            start_date,
            end_date,
            description,
            page_url,
        } => {
            info!("Performing a CreateBatch request on {:?}", (
                &version
            ));

            let result = client.create_batch(
                version,
                account_id,
                status,
                preview_limit,
                app_key,
                endpoint,
                parameters,
                name,
                start_date,
                end_date,
                description,
                page_url,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                CreateBatchResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::CreateRegionLegSummaryBatch {
            version,
            body,
        } => {
            info!("Performing a CreateRegionLegSummaryBatch request on {:?}", (
                &version
            ));

            let result = client.create_region_leg_summary_batch(
                version,
                body.as_ref(),
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                CreateRegionLegSummaryBatchResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::DeleteBatch {
            version,
            account_id,
            batch_id,
        } => {
            info!("Performing a DeleteBatch request on {:?}", (
                &version
            ));

            let result = client.delete_batch(
                version,
                account_id,
                batch_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                DeleteBatchResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetReportBatch {
            version,
            account_id,
            batch_id,
            all_results,
        } => {
            info!("Performing a GetReportBatch request on {:?}", (
                &version
            ));

            let result = client.get_report_batch(
                version,
                account_id,
                batch_id,
                all_results,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetReportBatchResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::RunReport {
            version,
            desc,
            account_id,
            query,
            parameters,
            order,
            start,
            limit,
            response_format,
        } => {
            info!("Performing a RunReport request on {:?}", (
                &version
            ));

            let result = client.run_report(
                version,
                desc,
                account_id,
                query,
                parameters,
                order,
                start,
                limit,
                response_format,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                RunReportResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::SearchBatch {
            version,
            account_id,
            start,
            limit,
            names,
            app_key,
            status,
            global_app_search,
            start_date,
            end_date,
        } => {
            info!("Performing a SearchBatch request on {:?}", (
                &version
            ));

            let result = client.search_batch(
                version,
                account_id,
                start,
                limit,
                names,
                app_key,
                status,
                global_app_search,
                start_date,
                end_date,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                SearchBatchResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::CreateReservation {
            version,
            device_id,
            account_id,
            start_date,
            end_date,
            offer_id,
            offer_location_id,
            app_key,
            meta_data,
        } => {
            info!("Performing a CreateReservation request on {:?}", (
                &version
            ));

            let result = client.create_reservation(
                version,
                device_id,
                account_id,
                start_date,
                end_date,
                offer_id,
                offer_location_id,
                app_key,
                meta_data,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                CreateReservationResponse::SuccessfulOperation
                => "SuccessfulOperation\n".to_string()
                    ,
            }
        }
        Operation::DeleteReservation {
            version,
            reservation_id,
            device_id,
            account_id,
        } => {
            info!("Performing a DeleteReservation request on {:?}", (
                &version
            ));

            let result = client.delete_reservation(
                version,
                reservation_id,
                device_id,
                account_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                DeleteReservationResponse::SuccessfulOperation
                => "SuccessfulOperation\n".to_string()
                    ,
            }
        }
        Operation::ReservableAvailability {
            version,
            reservable_id,
            reservable_type,
            device_id,
            account_id,
            availability,
            availability_summary,
        } => {
            info!("Performing a ReservableAvailability request on {:?}", (
                &version
            ));

            let result = client.reservable_availability(
                version,
                reservable_id,
                reservable_type,
                device_id,
                account_id,
                availability,
                availability_summary,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                ReservableAvailabilityResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::SearchAvailability {
            version,
            reservable_id,
            reservable_type,
            device_id,
            account_id,
            start_date,
            end_date,
            start,
            limit,
        } => {
            info!("Performing a SearchAvailability request on {:?}", (
                &version
            ));

            let result = client.search_availability(
                version,
                reservable_id,
                reservable_type,
                device_id,
                account_id,
                start_date,
                end_date,
                start,
                limit,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                SearchAvailabilityResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::SearchReservations {
            version,
            device_id,
            app_key,
            account_id,
            filter_account_id,
            reservable_id,
            reservable_type,
            keyword,
            start_date,
            end_date,
            start,
            limit,
        } => {
            info!("Performing a SearchReservations request on {:?}", (
                &version
            ));

            let result = client.search_reservations(
                version,
                device_id,
                app_key,
                account_id,
                filter_account_id,
                reservable_id,
                reservable_type,
                keyword,
                start_date,
                end_date,
                start,
                limit,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                SearchReservationsResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::SearchSchedule {
            version,
            reservable_id,
            reservable_type,
            start_date,
            end_date,
            device_id,
            account_id,
            time_bucket_mins,
        } => {
            info!("Performing a SearchSchedule request on {:?}", (
                &version
            ));

            let result = client.search_schedule(
                version,
                reservable_id,
                reservable_type,
                start_date,
                end_date,
                device_id,
                account_id,
                time_bucket_mins,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                SearchScheduleResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::CreateRetailer {
            version,
            name,
            device_id,
            account_id,
            street_address,
            street_address2,
            city,
            state,
            postal_code,
            country,
            business_phone,
            business_phone_ext,
            website,
            email,
            facebook_url,
            twitter_url,
            logo,
            logo_asset_id,
            picture1,
            picture1_asset_id,
            picture2,
            picture2_asset_id,
            category_ids,
            category_ids_to_add,
            category_ids_to_remove,
            filter_ids,
            latitude,
            longitude,
            meta_data,
            search_tags,
            retailer_type,
            visibility,
            create_default_location,
            response_format,
        } => {
            info!("Performing a CreateRetailer request on {:?}", (
                &version
            ));

            let result = client.create_retailer(
                version,
                name,
                device_id,
                account_id,
                street_address,
                street_address2,
                city,
                state,
                postal_code,
                country,
                business_phone,
                business_phone_ext,
                website,
                email,
                facebook_url,
                twitter_url,
                logo,
                logo_asset_id,
                picture1,
                picture1_asset_id,
                picture2,
                picture2_asset_id,
                category_ids,
                category_ids_to_add,
                category_ids_to_remove,
                filter_ids,
                latitude,
                longitude,
                meta_data,
                search_tags,
                retailer_type,
                visibility,
                create_default_location,
                response_format,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                CreateRetailerResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::DeleteRetailer {
            version,
            device_id,
            account_id,
            retailer_id,
        } => {
            info!("Performing a DeleteRetailer request on {:?}", (
                &version
            ));

            let result = client.delete_retailer(
                version,
                device_id,
                account_id,
                retailer_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                DeleteRetailerResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetRetailer {
            version,
            retailer_id,
            device_id,
            account_id,
            include_counts,
        } => {
            info!("Performing a GetRetailer request on {:?}", (
                &version
            ));

            let result = client.get_retailer(
                version,
                retailer_id,
                device_id,
                account_id,
                include_counts,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetRetailerResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetRetailers {
            version,
            visibility,
            sort_field,
            descending,
            start,
            limit,
            active_only,
            device_id,
            account_id,
            q,
            keyword,
            category_ids,
            filter_ids,
            _i,
            _l,
        } => {
            info!("Performing a GetRetailers request on {:?}", (
                &version
            ));

            let result = client.get_retailers(
                version,
                visibility,
                sort_field,
                descending,
                start,
                limit,
                active_only,
                device_id,
                account_id,
                q,
                keyword,
                category_ids,
                filter_ids,
                _i,
                _l,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetRetailersResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::RetailerLoginCheck {
            version,
            username,
            password,
            device_id,
            latitude,
            longitude,
            app_key,
        } => {
            info!("Performing a RetailerLoginCheck request on {:?}", (
                &version
            ));

            let result = client.retailer_login_check(
                version,
                username,
                password,
                device_id,
                latitude,
                longitude,
                app_key,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                RetailerLoginCheckResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::UpdateRetailer {
            version,
            retailer_id,
            device_id,
            account_id,
            name,
            street_address,
            street_address2,
            city,
            state,
            postal_code,
            country,
            business_phone,
            business_phone_ext,
            website,
            email,
            facebook_url,
            twitter_url,
            logo,
            logo_asset_id,
            picture1,
            picture1_asset_id,
            picture2,
            picture2_asset_id,
            category_ids,
            filter_ids,
            latitude,
            longitude,
            meta_data,
            search_tags,
            retailer_type,
            visibility,
            active,
            response_format,
        } => {
            info!("Performing a UpdateRetailer request on {:?}", (
                &version
            ));

            let result = client.update_retailer(
                version,
                retailer_id,
                device_id,
                account_id,
                name,
                street_address,
                street_address2,
                city,
                state,
                postal_code,
                country,
                business_phone,
                business_phone_ext,
                website,
                email,
                facebook_url,
                twitter_url,
                logo,
                logo_asset_id,
                picture1,
                picture1_asset_id,
                picture2,
                picture2_asset_id,
                category_ids,
                filter_ids,
                latitude,
                longitude,
                meta_data,
                search_tags,
                retailer_type,
                visibility,
                active,
                response_format,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                UpdateRetailerResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::CreateRetailerLocationConsumer {
            version,
            app_key,
            name,
            device_id,
            account_id,
            street_address,
            street_address2,
            city,
            state,
            postal_code,
            country,
            business_phone,
            business_phone_ext,
            website,
            email,
            details_header,
            details_body,
            hours,
            tags,
            logo_asset_id,
            picture1_asset_id,
            picture2_asset_id,
            category_ids,
            filter_ids,
            meta_data,
            public_location,
            active,
            location_type,
            latitude,
            longitude,
        } => {
            info!("Performing a CreateRetailerLocationConsumer request on {:?}", (
                &version
            ));

            let result = client.create_retailer_location_consumer(
                version,
                app_key,
                name,
                device_id,
                account_id,
                street_address,
                street_address2,
                city,
                state,
                postal_code,
                country,
                business_phone,
                business_phone_ext,
                website,
                email,
                details_header,
                details_body,
                hours,
                tags,
                logo_asset_id,
                picture1_asset_id,
                picture2_asset_id,
                category_ids,
                filter_ids,
                meta_data,
                public_location,
                active,
                location_type,
                latitude,
                longitude,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                CreateRetailerLocationConsumerResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::CreateRetailerLocations {
            version,
            retailer_id,
            name,
            street_address,
            city,
            state,
            postal_code,
            device_id,
            account_id,
            street_address2,
            country,
            business_phone,
            business_phone_ext,
            website,
            email,
            internal_id,
            details_header,
            details_body,
            hours,
            logo,
            logo_asset_id,
            picture1,
            picture1_asset_id,
            picture2,
            picture2_asset_id,
            category_ids,
            filter_ids,
            latitude,
            longitude,
            building,
            google_place_id,
            yelp_id,
            active,
            public_location,
            location_type,
            audience_ids,
            audience_ids_to_add,
            audience_ids_to_remove,
            response_format,
            response_includes,
        } => {
            info!("Performing a CreateRetailerLocations request on {:?}", (
                &version
            ));

            let result = client.create_retailer_locations(
                version,
                retailer_id,
                name,
                street_address,
                city,
                state,
                postal_code,
                device_id,
                account_id,
                street_address2,
                country,
                business_phone,
                business_phone_ext,
                website,
                email,
                internal_id,
                details_header,
                details_body,
                hours,
                logo,
                logo_asset_id,
                picture1,
                picture1_asset_id,
                picture2,
                picture2_asset_id,
                category_ids,
                filter_ids,
                latitude,
                longitude,
                building,
                google_place_id,
                yelp_id,
                active,
                public_location,
                location_type,
                audience_ids,
                audience_ids_to_add,
                audience_ids_to_remove,
                response_format,
                response_includes,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                CreateRetailerLocationsResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::DeleteRetailerLocation {
            version,
            device_id,
            account_id,
            retailer_location_id,
        } => {
            info!("Performing a DeleteRetailerLocation request on {:?}", (
                &version
            ));

            let result = client.delete_retailer_location(
                version,
                device_id,
                account_id,
                retailer_location_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                DeleteRetailerLocationResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetRetailerLocation {
            version,
            retailer_location_id,
            device_id,
            account_id,
            retailer_location_token,
        } => {
            info!("Performing a GetRetailerLocation request on {:?}", (
                &version
            ));

            let result = client.get_retailer_location(
                version,
                retailer_location_id,
                device_id,
                account_id,
                retailer_location_token,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetRetailerLocationResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetRetailerLocationConsumer {
            version,
            retailer_location_id,
            device_id,
            account_id,
        } => {
            info!("Performing a GetRetailerLocationConsumer request on {:?}", (
                &version
            ));

            let result = client.get_retailer_location_consumer(
                version,
                retailer_location_id,
                device_id,
                account_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetRetailerLocationConsumerResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::IndexedRetailerLocationDistanceSearch {
            version,
            latitude,
            longitude,
            search_range,
            start,
            limit,
            account_id,
            address,
            has_offers,
            categories,
            filters,
            audiences,
            retailer_ids,
            retailer_location_ids,
            tags,
            location_type,
            sort_field,
            descending,
            q,
            keyword,
            keyword_operator,
            search_expression,
            distance_unit,
            return_favorited,
            return_retailer,
            return_assets,
            return_offers,
            return_categories,
            return_filters,
            return_audiences,
            return_qr_code,
            return_external_category_data,
            include_favorite,
            include_liked,
            include_rating,
        } => {
            info!("Performing a IndexedRetailerLocationDistanceSearch request on {:?}", (
                &version
            ));

            let result = client.indexed_retailer_location_distance_search(
                version,
                latitude,
                longitude,
                search_range,
                start,
                limit,
                account_id,
                address,
                has_offers,
                categories,
                filters,
                audiences,
                retailer_ids,
                retailer_location_ids,
                tags,
                location_type,
                sort_field,
                descending,
                q,
                keyword,
                keyword_operator,
                search_expression,
                distance_unit,
                return_favorited,
                return_retailer,
                return_assets,
                return_offers,
                return_categories,
                return_filters,
                return_audiences,
                return_qr_code,
                return_external_category_data,
                include_favorite,
                include_liked,
                include_rating,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                IndexedRetailerLocationDistanceSearchResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::IndexedRetailerLocationSearch {
            version,
            account_id,
            start,
            limit,
            has_offers,
            categories,
            filters,
            audiences,
            retailer_ids,
            retailer_location_ids,
            tags,
            location_type,
            sort_field,
            descending,
            q,
            keyword,
            keyword_operator,
            search_expression,
            return_retailer,
            return_assets,
            return_offers,
            return_categories,
            return_filters,
            return_audiences,
            return_qr_code,
            return_external_category_data,
            include_favorite,
            include_liked,
            include_rating,
        } => {
            info!("Performing a IndexedRetailerLocationSearch request on {:?}", (
                &version
            ));

            let result = client.indexed_retailer_location_search(
                version,
                account_id,
                start,
                limit,
                has_offers,
                categories,
                filters,
                audiences,
                retailer_ids,
                retailer_location_ids,
                tags,
                location_type,
                sort_field,
                descending,
                q,
                keyword,
                keyword_operator,
                search_expression,
                return_retailer,
                return_assets,
                return_offers,
                return_categories,
                return_filters,
                return_audiences,
                return_qr_code,
                return_external_category_data,
                include_favorite,
                include_liked,
                include_rating,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                IndexedRetailerLocationSearchResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::SearchRetailerLocations {
            version,
            device_id,
            account_id,
            q,
            keyword,
            retailer_ids,
            retailer_location_ids,
            location_type,
            sort_field,
            descending,
            _i,
            start,
            _l,
            limit,
            show_public_locations,
            active_only,
            return_retailer,
            return_assets,
            return_offers,
            return_categories,
            return_filters,
            return_audiences,
            return_qr_code,
            include_favorite,
            include_liked,
            include_rating,
        } => {
            info!("Performing a SearchRetailerLocations request on {:?}", (
                &version
            ));

            let result = client.search_retailer_locations(
                version,
                device_id,
                account_id,
                q,
                keyword,
                retailer_ids,
                retailer_location_ids,
                location_type,
                sort_field,
                descending,
                _i,
                start,
                _l,
                limit,
                show_public_locations,
                active_only,
                return_retailer,
                return_assets,
                return_offers,
                return_categories,
                return_filters,
                return_audiences,
                return_qr_code,
                include_favorite,
                include_liked,
                include_rating,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                SearchRetailerLocationsResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::UpdateRetailerLocations {
            version,
            retailer_location_id,
            device_id,
            account_id,
            name,
            street_address,
            street_address2,
            city,
            state,
            postal_code,
            country,
            business_phone,
            business_phone_ext,
            website,
            email,
            internal_id,
            details_header,
            details_body,
            hours,
            logo,
            logo_asset_id,
            picture1,
            picture1_asset_id,
            picture2,
            picture2_asset_id,
            category_ids,
            filter_ids,
            latitude,
            longitude,
            building,
            google_place_id,
            yelp_id,
            meta_data,
            payment_provider,
            active,
            public_location,
            location_type,
            audience_ids,
            audience_ids_to_add,
            audience_ids_to_remove,
            response_format,
            tags,
        } => {
            info!("Performing a UpdateRetailerLocations request on {:?}", (
                &version
            ));

            let result = client.update_retailer_locations(
                version,
                retailer_location_id,
                device_id,
                account_id,
                name,
                street_address,
                street_address2,
                city,
                state,
                postal_code,
                country,
                business_phone,
                business_phone_ext,
                website,
                email,
                internal_id,
                details_header,
                details_body,
                hours,
                logo,
                logo_asset_id,
                picture1,
                picture1_asset_id,
                picture2,
                picture2_asset_id,
                category_ids,
                filter_ids,
                latitude,
                longitude,
                building,
                google_place_id,
                yelp_id,
                meta_data,
                payment_provider,
                active,
                public_location,
                location_type,
                audience_ids,
                audience_ids_to_add,
                audience_ids_to_remove,
                response_format,
                tags,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                UpdateRetailerLocationsResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetRetaokiler {
            version,
            retailer_id,
            active_only,
            keyword,
            sort_field,
            start,
            limit,
        } => {
            info!("Performing a GetRetaokiler request on {:?}", (
                &version
            ));

            let result = client.get_retaokiler(
                version,
                retailer_id,
                active_only,
                keyword,
                sort_field,
                start,
                limit,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetRetaokilerResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::CreateRoute {
            version,
            body,
        } => {
            info!("Performing a CreateRoute request on {:?}", (
                &version
            ));

            let result = client.create_route(
                version,
                body,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                CreateRouteResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::SearchRoutes {
            version,
            sort_field,
            descending,
            start,
            limit,
            active_only,
            includes_empty,
            root_only,
            show_inherited_properties,
            hub_id,
            program_id,
            scheduled_start,
            scheduled_end,
            updated_start,
            updated_end,
            featured,
            seat_count,
            approved,
            started,
            completed,
            valid,
            parent_id,
        } => {
            info!("Performing a SearchRoutes request on {:?}", (
                &version
            ));

            let result = client.search_routes(
                version,
                sort_field,
                descending,
                start,
                limit,
                active_only,
                includes_empty,
                root_only,
                show_inherited_properties,
                hub_id,
                program_id,
                scheduled_start,
                scheduled_end,
                updated_start,
                updated_end,
                featured,
                seat_count,
                approved,
                started,
                completed,
                valid,
                parent_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                SearchRoutesResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::ApproveRoute {
            version,
            route_id,
        } => {
            info!("Performing a ApproveRoute request on {:?}", (
                &version,
                &route_id
            ));

            let result = client.approve_route(
                version,
                route_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                ApproveRouteResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::CopyRoute {
            version,
            route_id,
            body,
        } => {
            info!("Performing a CopyRoute request on {:?}", (
                &version,
                &route_id
            ));

            let result = client.copy_route(
                version,
                route_id,
                body,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                CopyRouteResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::CreateRouteDirections {
            version,
            route_id,
        } => {
            info!("Performing a CreateRouteDirections request on {:?}", (
                &version,
                &route_id
            ));

            let result = client.create_route_directions(
                version,
                route_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                CreateRouteDirectionsResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::CreateRoutePolyline {
            version,
            route_id,
        } => {
            info!("Performing a CreateRoutePolyline request on {:?}", (
                &version,
                &route_id
            ));

            let result = client.create_route_polyline(
                version,
                route_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                CreateRoutePolylineResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::DeleteRoute {
            version,
            route_id,
        } => {
            prompt(args.force, "This will delete the given entry, are you sure?")?;
            info!("Performing a DeleteRoute request on {:?}", (
                &version,
                &route_id
            ));

            let result = client.delete_route(
                version,
                route_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                DeleteRouteResponse::SuccessfulOperation
                => "SuccessfulOperation\n".to_string()
                    ,
            }
        }
        Operation::DisapproveRoute {
            version,
            route_id,
        } => {
            info!("Performing a DisapproveRoute request on {:?}", (
                &version,
                &route_id
            ));

            let result = client.disapprove_route(
                version,
                route_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                DisapproveRouteResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetRoute {
            version,
            route_id,
            show_inherited_properties,
        } => {
            info!("Performing a GetRoute request on {:?}", (
                &version,
                &route_id
            ));

            let result = client.get_route(
                version,
                route_id,
                show_inherited_properties,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetRouteResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetRouteDirections {
            version,
            route_id,
        } => {
            info!("Performing a GetRouteDirections request on {:?}", (
                &version,
                &route_id
            ));

            let result = client.get_route_directions(
                version,
                route_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetRouteDirectionsResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetRouteShipments {
            version,
            route_id,
        } => {
            info!("Performing a GetRouteShipments request on {:?}", (
                &version,
                &route_id
            ));

            let result = client.get_route_shipments(
                version,
                route_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetRouteShipmentsResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetRouteStops {
            version,
            route_id,
            confirmed_only,
        } => {
            info!("Performing a GetRouteStops request on {:?}", (
                &version,
                &route_id
            ));

            let result = client.get_route_stops(
                version,
                route_id,
                confirmed_only,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetRouteStopsResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::OptimizeRoute {
            version,
            route_id,
        } => {
            info!("Performing a OptimizeRoute request on {:?}", (
                &version,
                &route_id
            ));

            let result = client.optimize_route(
                version,
                route_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                OptimizeRouteResponse::SuccessfulOperation
                => "SuccessfulOperation\n".to_string()
                    ,
            }
        }
        Operation::ReorderRouteStopsPatch {
            version,
            route_id,
            body,
        } => {
            info!("Performing a ReorderRouteStopsPatch request on {:?}", (
                &version,
                &route_id
            ));

            let result = client.reorder_route_stops_patch(
                version,
                route_id,
                body.as_ref(),
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                ReorderRouteStopsPatchResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::ReorderRouteStopsPost {
            version,
            route_id,
            body,
        } => {
            info!("Performing a ReorderRouteStopsPost request on {:?}", (
                &version,
                &route_id
            ));

            let result = client.reorder_route_stops_post(
                version,
                route_id,
                body.as_ref(),
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                ReorderRouteStopsPostResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::UpdateRoute {
            version,
            route_id,
            body,
        } => {
            info!("Performing a UpdateRoute request on {:?}", (
                &version,
                &route_id
            ));

            let result = client.update_route(
                version,
                route_id,
                body,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                UpdateRouteResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetRouteStop {
            version,
            route_id,
            stop_id,
        } => {
            info!("Performing a GetRouteStop request on {:?}", (
                &version,
                &route_id,
                &stop_id
            ));

            let result = client.get_route_stop(
                version,
                route_id,
                stop_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetRouteStopResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetShipmentsAtStop {
            version,
            route_id,
            stop_id,
        } => {
            info!("Performing a GetShipmentsAtStop request on {:?}", (
                &version,
                &route_id,
                &stop_id
            ));

            let result = client.get_shipments_at_stop(
                version,
                route_id,
                stop_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetShipmentsAtStopResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::RemoveStop {
            version,
            route_id,
            stop_id,
        } => {
            prompt(args.force, "This will delete the given entry, are you sure?")?;
            info!("Performing a RemoveStop request on {:?}", (
                &version,
                &route_id,
                &stop_id
            ));

            let result = client.remove_stop(
                version,
                route_id,
                stop_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                RemoveStopResponse::SuccessfulOperation
                => "SuccessfulOperation\n".to_string()
                    ,
            }
        }
        Operation::SetDriver {
            version,
            id,
            driver_id,
        } => {
            info!("Performing a SetDriver request on {:?}", (
                &version,
                &id,
                &driver_id
            ));

            let result = client.set_driver(
                version,
                id,
                driver_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                SetDriverResponse::SuccessfulOperation
                => "SuccessfulOperation\n".to_string()
                    ,
            }
        }
        Operation::UpdateRouteStop {
            version,
            route_id,
            stop_id,
            body,
        } => {
            info!("Performing a UpdateRouteStop request on {:?}", (
                &version,
                &route_id,
                &stop_id
            ));

            let result = client.update_route_stop(
                version,
                route_id,
                stop_id,
                body,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                UpdateRouteStopResponse::SuccessfulOperation
                => "SuccessfulOperation\n".to_string()
                    ,
            }
        }
        Operation::CreateRouteSettings {
            version,
            body,
        } => {
            info!("Performing a CreateRouteSettings request on {:?}", (
                &version
            ));

            let result = client.create_route_settings(
                version,
                body,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                CreateRouteSettingsResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::SearchRouteSettings {
            version,
            sort_field,
            descending,
            start,
            limit,
            active_only,
            hub_id,
            program_id,
            keyword,
        } => {
            info!("Performing a SearchRouteSettings request on {:?}", (
                &version
            ));

            let result = client.search_route_settings(
                version,
                sort_field,
                descending,
                start,
                limit,
                active_only,
                hub_id,
                program_id,
                keyword,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                SearchRouteSettingsResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::DeleteRouteSettings {
            version,
            route_settings_id,
        } => {
            prompt(args.force, "This will delete the given entry, are you sure?")?;
            info!("Performing a DeleteRouteSettings request on {:?}", (
                &version,
                &route_settings_id
            ));

            let result = client.delete_route_settings(
                version,
                route_settings_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                DeleteRouteSettingsResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetRouteSettings {
            version,
            route_settings_id,
        } => {
            info!("Performing a GetRouteSettings request on {:?}", (
                &version,
                &route_settings_id
            ));

            let result = client.get_route_settings(
                version,
                route_settings_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetRouteSettingsResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::UpdateRouteSettings {
            version,
            route_settings_id,
            body,
        } => {
            info!("Performing a UpdateRouteSettings request on {:?}", (
                &version,
                &route_settings_id
            ));

            let result = client.update_route_settings(
                version,
                route_settings_id,
                body,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                UpdateRouteSettingsResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::ComputeRouting {
            version,
            data,
        } => {
            info!("Performing a ComputeRouting request on {:?}", (
                &version
            ));

            let result = client.compute_routing(
                version,
                data,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                ComputeRoutingResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::CreateScheduledNotification {
            version,
            account_id,
            name,
            param_type,
            message,
            content_id,
            content_name,
            content_type,
            parent_id,
            parent_type,
            app_key,
            grouping_id,
            connection_group_ids,
            connection_account_ids,
            audience_id,
            audience_ids,
            album_ids,
            report_id,
            report_params,
            endpoint_url,
            payload,
            scheduled_date,
            start_date,
            end_date,
            cron_expression,
            cron_type,
            meta_data,
            conditional_input,
            template_type,
            visibility,
            active,
            send_now,
            event_type,
            deep_link_uri,
            send_to_all,
        } => {
            info!("Performing a CreateScheduledNotification request on {:?}", (
                &version
            ));

            let result = client.create_scheduled_notification(
                version,
                account_id,
                name,
                param_type,
                message,
                content_id,
                content_name,
                content_type,
                parent_id,
                parent_type,
                app_key,
                grouping_id,
                connection_group_ids,
                connection_account_ids,
                audience_id,
                audience_ids,
                album_ids,
                report_id,
                report_params,
                endpoint_url,
                payload,
                scheduled_date,
                start_date,
                end_date,
                cron_expression,
                cron_type,
                meta_data,
                conditional_input,
                template_type,
                visibility,
                active,
                send_now,
                event_type,
                deep_link_uri,
                send_to_all,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                CreateScheduledNotificationResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::DeleteScheduledNotification {
            version,
            account_id,
            scheduled_notification_id,
            delete_by_grouping_id,
        } => {
            info!("Performing a DeleteScheduledNotification request on {:?}", (
                &version
            ));

            let result = client.delete_scheduled_notification(
                version,
                account_id,
                scheduled_notification_id,
                delete_by_grouping_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                DeleteScheduledNotificationResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetScheduledNotification {
            version,
            account_id,
            scheduled_notification_id,
        } => {
            info!("Performing a GetScheduledNotification request on {:?}", (
                &version
            ));

            let result = client.get_scheduled_notification(
                version,
                account_id,
                scheduled_notification_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetScheduledNotificationResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::ScheduleNotificationListings {
            version,
            account_id,
            app_key,
            report_name,
            message,
            offset,
            recipient_report_id,
            report_params,
            param_type,
        } => {
            info!("Performing a ScheduleNotificationListings request on {:?}", (
                &version
            ));

            let result = client.schedule_notification_listings(
                version,
                account_id,
                app_key,
                report_name,
                message,
                offset,
                recipient_report_id,
                report_params,
                param_type,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                ScheduleNotificationListingsResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::SearchScheduledNotifications {
            version,
            account_id,
            grouping_id,
            audience_id,
            filter,
            types,
            content_ids,
            content_types,
            parent_ids,
            parent_types,
            statuses,
            template_types,
            app_key,
            keyword,
            sort_field,
            descending,
            start,
            limit,
            active_only,
            group_by_grouping_id,
            return_audience_account_count,
        } => {
            info!("Performing a SearchScheduledNotifications request on {:?}", (
                &version
            ));

            let result = client.search_scheduled_notifications(
                version,
                account_id,
                grouping_id,
                audience_id,
                filter,
                types,
                content_ids,
                content_types,
                parent_ids,
                parent_types,
                statuses,
                template_types,
                app_key,
                keyword,
                sort_field,
                descending,
                start,
                limit,
                active_only,
                group_by_grouping_id,
                return_audience_account_count,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                SearchScheduledNotificationsResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::UpdateScheduledNotification {
            version,
            scheduled_notification_id,
            account_id,
            name,
            param_type,
            message,
            payload,
            content_id,
            content_name,
            content_type,
            parent_id,
            parent_type,
            app_key,
            grouping_id,
            connection_group_ids,
            connection_account_ids,
            audience_id,
            audience_ids,
            album_ids,
            report_id,
            report_params,
            endpoint_url,
            scheduled_date,
            start_date,
            end_date,
            cron_expression,
            cron_type,
            meta_data,
            conditional_input,
            template_type,
            visibility,
            active,
            error_message,
            status,
            update_by_grouping_id,
            send_now,
            event_type,
            deep_link_uri,
            send_to_all,
        } => {
            info!("Performing a UpdateScheduledNotification request on {:?}", (
                &version
            ));

            let result = client.update_scheduled_notification(
                version,
                scheduled_notification_id,
                account_id,
                name,
                param_type,
                message,
                payload,
                content_id,
                content_name,
                content_type,
                parent_id,
                parent_type,
                app_key,
                grouping_id,
                connection_group_ids,
                connection_account_ids,
                audience_id,
                audience_ids,
                album_ids,
                report_id,
                report_params,
                endpoint_url,
                scheduled_date,
                start_date,
                end_date,
                cron_expression,
                cron_type,
                meta_data,
                conditional_input,
                template_type,
                visibility,
                active,
                error_message,
                status,
                update_by_grouping_id,
                send_now,
                event_type,
                deep_link_uri,
                send_to_all,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                UpdateScheduledNotificationResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::CreateScore {
            version,
            account_id,
            app_key,
            points,
            mission_id,
            game_id,
            pack_id,
            game_level_id,
            game_object_id,
            time_taken,
            highest,
        } => {
            info!("Performing a CreateScore request on {:?}", (
                &version
            ));

            let result = client.create_score(
                version,
                account_id,
                app_key,
                points,
                mission_id,
                game_id,
                pack_id,
                game_level_id,
                game_object_id,
                time_taken,
                highest,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                CreateScoreResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetScore {
            version,
            account_id,
            app_key,
            mission_id,
            game_id,
            pack_id,
            game_level_id,
            game_object_id,
            score_object_type,
            score_status,
        } => {
            info!("Performing a GetScore request on {:?}", (
                &version
            ));

            let result = client.get_score(
                version,
                account_id,
                app_key,
                mission_id,
                game_id,
                pack_id,
                game_level_id,
                game_object_id,
                score_object_type,
                score_status,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetScoreResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::SearchScores {
            version,
            account_id,
            app_key,
            mission_id,
            game_id,
            pack_id,
            game_level_id,
            game_object_id,
        } => {
            info!("Performing a SearchScores request on {:?}", (
                &version
            ));

            let result = client.search_scores(
                version,
                account_id,
                app_key,
                mission_id,
                game_id,
                pack_id,
                game_level_id,
                game_object_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                SearchScoresResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::CreateSecureApplication {
            version,
            account_id,
            app_key,
            key_cert,
            trust_store,
            username,
            password,
            active,
            biometric_type,
            biometric_position,
            biometric_position2,
        } => {
            info!("Performing a CreateSecureApplication request on {:?}", (
                &version
            ));

            let result = client.create_secure_application(
                version,
                account_id,
                app_key,
                key_cert,
                trust_store,
                username,
                password,
                active,
                biometric_type,
                biometric_position,
                biometric_position2,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                CreateSecureApplicationResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::DeleteSecureApplication {
            version,
            account_id,
            app_key,
        } => {
            info!("Performing a DeleteSecureApplication request on {:?}", (
                &version
            ));

            let result = client.delete_secure_application(
                version,
                account_id,
                app_key,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                DeleteSecureApplicationResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::LoginSecure {
            version,
            app_key,
            biometric_file,
            device_id,
            biometric_file2,
            age_restriction,
            return_profile,
            response_filters,
            latitude,
            longitude,
        } => {
            info!("Performing a LoginSecure request on {:?}", (
                &version
            ));

            let result = client.login_secure(
                version,
                app_key,
                biometric_file,
                device_id,
                biometric_file2,
                age_restriction,
                return_profile,
                response_filters,
                latitude,
                longitude,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                LoginSecureResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::PurchaseSecure {
            version,
            body,
        } => {
            info!("Performing a PurchaseSecure request on {:?}", (
                &version
            ));

            let result = client.purchase_secure(
                version,
                body,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                PurchaseSecureResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::ResetSecure {
            version,
            account_id,
            app_key,
        } => {
            info!("Performing a ResetSecure request on {:?}", (
                &version
            ));

            let result = client.reset_secure(
                version,
                account_id,
                app_key,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                ResetSecureResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::UpdateSecureApplication {
            version,
            account_id,
            app_key,
            active,
            key_cert,
            trust_store,
            username,
            password,
            biometric_type,
            biometric_position,
            biometric_position2,
        } => {
            info!("Performing a UpdateSecureApplication request on {:?}", (
                &version
            ));

            let result = client.update_secure_application(
                version,
                account_id,
                app_key,
                active,
                key_cert,
                trust_store,
                username,
                password,
                biometric_type,
                biometric_position,
                biometric_position2,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                UpdateSecureApplicationResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::CreateServiceHub {
            version,
            body,
        } => {
            info!("Performing a CreateServiceHub request on {:?}", (
                &version
            ));

            let result = client.create_service_hub(
                version,
                body,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                CreateServiceHubResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::SearchServiceHubs {
            version,
            sort_field,
            descending,
            start,
            limit,
            active_only,
            keyword,
            retailer_id,
        } => {
            info!("Performing a SearchServiceHubs request on {:?}", (
                &version
            ));

            let result = client.search_service_hubs(
                version,
                sort_field,
                descending,
                start,
                limit,
                active_only,
                keyword,
                retailer_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                SearchServiceHubsResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::DeleteServiceHub {
            version,
            id,
        } => {
            prompt(args.force, "This will delete the given entry, are you sure?")?;
            info!("Performing a DeleteServiceHub request on {:?}", (
                &version,
                &id
            ));

            let result = client.delete_service_hub(
                version,
                id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                DeleteServiceHubResponse::SuccessfulOperation
                => "SuccessfulOperation\n".to_string()
                    ,
            }
        }
        Operation::GetServiceHub {
            version,
            id,
        } => {
            info!("Performing a GetServiceHub request on {:?}", (
                &version,
                &id
            ));

            let result = client.get_service_hub(
                version,
                id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetServiceHubResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::PostServiceHub {
            version,
            id,
            body,
        } => {
            info!("Performing a PostServiceHub request on {:?}", (
                &version,
                &id
            ));

            let result = client.post_service_hub(
                version,
                id,
                body,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                PostServiceHubResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::PutServiceHub {
            version,
            id,
            body,
        } => {
            info!("Performing a PutServiceHub request on {:?}", (
                &version,
                &id
            ));

            let result = client.put_service_hub(
                version,
                id,
                body,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                PutServiceHubResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::CreateShipment {
            version,
            body,
        } => {
            info!("Performing a CreateShipment request on {:?}", (
                &version
            ));

            let result = client.create_shipment(
                version,
                body,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                CreateShipmentResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::SearchShipments {
            version,
            sort_field,
            descending,
            start,
            limit,
            active_only,
            owner_id,
            rider_id,
            route_id,
        } => {
            info!("Performing a SearchShipments request on {:?}", (
                &version
            ));

            let result = client.search_shipments(
                version,
                sort_field,
                descending,
                start,
                limit,
                active_only,
                owner_id,
                rider_id,
                route_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                SearchShipmentsResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::CancelShipment {
            version,
            id,
        } => {
            info!("Performing a CancelShipment request on {:?}", (
                &version,
                &id
            ));

            let result = client.cancel_shipment(
                version,
                id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                CancelShipmentResponse::SuccessfulOperation
                => "SuccessfulOperation\n".to_string()
                    ,
            }
        }
        Operation::DeleteShipment {
            version,
            id,
        } => {
            prompt(args.force, "This will delete the given entry, are you sure?")?;
            info!("Performing a DeleteShipment request on {:?}", (
                &version,
                &id
            ));

            let result = client.delete_shipment(
                version,
                id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                DeleteShipmentResponse::SuccessfulOperation
                => "SuccessfulOperation\n".to_string()
                    ,
            }
        }
        Operation::GetShipment {
            version,
            id,
        } => {
            info!("Performing a GetShipment request on {:?}", (
                &version,
                &id
            ));

            let result = client.get_shipment(
                version,
                id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetShipmentResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::UpdateShipment {
            version,
            id,
            body,
        } => {
            info!("Performing a UpdateShipment request on {:?}", (
                &version,
                &id
            ));

            let result = client.update_shipment(
                version,
                id,
                body,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                UpdateShipmentResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::UpdateShipmentStatus {
            version,
            id,
            body,
        } => {
            info!("Performing a UpdateShipmentStatus request on {:?}", (
                &version,
                &id
            ));

            let result = client.update_shipment_status(
                version,
                id,
                body,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                UpdateShipmentStatusResponse::SuccessfulOperation
                => "SuccessfulOperation\n".to_string()
                    ,
            }
        }
        Operation::CreateShipmentBatch {
            version,
            body,
        } => {
            info!("Performing a CreateShipmentBatch request on {:?}", (
                &version
            ));

            let result = client.create_shipment_batch(
                version,
                body,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                CreateShipmentBatchResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::SearchShipmentBatch {
            version,
            hub_id,
            sort_field,
            descending,
            start,
            limit,
        } => {
            info!("Performing a SearchShipmentBatch request on {:?}", (
                &version
            ));

            let result = client.search_shipment_batch(
                version,
                hub_id,
                sort_field,
                descending,
                start,
                limit,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                SearchShipmentBatchResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::DeleteShipmentBatch {
            version,
            batch_id,
        } => {
            prompt(args.force, "This will delete the given entry, are you sure?")?;
            info!("Performing a DeleteShipmentBatch request on {:?}", (
                &version,
                &batch_id
            ));

            let result = client.delete_shipment_batch(
                version,
                batch_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                DeleteShipmentBatchResponse::SuccessfulOperation
                => "SuccessfulOperation\n".to_string()
                    ,
            }
        }
        Operation::GetShipmentBatch {
            version,
            batch_id,
        } => {
            info!("Performing a GetShipmentBatch request on {:?}", (
                &version,
                &batch_id
            ));

            let result = client.get_shipment_batch(
                version,
                batch_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetShipmentBatchResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetShipmentBatchStatus {
            version,
            batch_id,
            account_id,
            sort_field,
            descending,
            start,
            limit,
            valid,
            started,
            completed,
            has_shipment,
            has_route,
            keyword,
        } => {
            info!("Performing a GetShipmentBatchStatus request on {:?}", (
                &version,
                &batch_id
            ));

            let result = client.get_shipment_batch_status(
                version,
                batch_id,
                account_id,
                sort_field,
                descending,
                start,
                limit,
                valid,
                started,
                completed,
                has_shipment,
                has_route,
                keyword,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetShipmentBatchStatusResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::Simulation {
            version,
            data,
            real_time,
        } => {
            info!("Performing a Simulation request on {:?}", (
                &version
            ));

            let result = client.simulation(
                version,
                data,
                real_time,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                SimulationResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetStop {
            version,
            id,
        } => {
            info!("Performing a GetStop request on {:?}", (
                &version,
                &id
            ));

            let result = client.get_stop(
                version,
                id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetStopResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::UpdateStop {
            version,
            id,
            body,
        } => {
            info!("Performing a UpdateStop request on {:?}", (
                &version,
                &id
            ));

            let result = client.update_stop(
                version,
                id,
                body,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                UpdateStopResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::CreateStripeCheckoutSession {
            version,
            app_key,
            stripe_parameters,
        } => {
            info!("Performing a CreateStripeCheckoutSession request on {:?}", (
                &version
            ));

            let result = client.create_stripe_checkout_session(
                version,
                app_key,
                stripe_parameters,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                CreateStripeCheckoutSessionResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::CreateSubscription {
            version,
            account_id,
            plan_id,
            promo_code,
        } => {
            info!("Performing a CreateSubscription request on {:?}", (
                &version
            ));

            let result = client.create_subscription(
                version,
                account_id,
                plan_id,
                promo_code,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                CreateSubscriptionResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::DeleteSubscription {
            version,
            account_id,
        } => {
            info!("Performing a DeleteSubscription request on {:?}", (
                &version
            ));

            let result = client.delete_subscription(
                version,
                account_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                DeleteSubscriptionResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetSubscription {
            version,
            account_id,
        } => {
            info!("Performing a GetSubscription request on {:?}", (
                &version
            ));

            let result = client.get_subscription(
                version,
                account_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetSubscriptionResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetSubscriptionPlan {
            version,
            plan_id,
        } => {
            info!("Performing a GetSubscriptionPlan request on {:?}", (
                &version
            ));

            let result = client.get_subscription_plan(
                version,
                plan_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetSubscriptionPlanResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetSubscriptionPlans {
            version,
            visible,
            role,
        } => {
            info!("Performing a GetSubscriptionPlans request on {:?}", (
                &version
            ));

            let result = client.get_subscription_plans(
                version,
                visible,
                role,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetSubscriptionPlansResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetSubscriptionUsage {
            version,
            account_id,
            application_id,
            start,
            end,
        } => {
            info!("Performing a GetSubscriptionUsage request on {:?}", (
                &version
            ));

            let result = client.get_subscription_usage(
                version,
                account_id,
                application_id,
                start,
                end,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetSubscriptionUsageResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::UpdateSubscription {
            version,
            account_id,
            plan_id,
            promo_code,
            active,
        } => {
            info!("Performing a UpdateSubscription request on {:?}", (
                &version
            ));

            let result = client.update_subscription(
                version,
                account_id,
                plan_id,
                promo_code,
                active,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                UpdateSubscriptionResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::CreateTask {
            version,
            account_id,
            name,
            app_key,
            grouping_id,
            endpoint_url,
            payload,
            scheduled_date,
            start_date,
            end_date,
            cron_expression,
            visibility,
            active,
        } => {
            info!("Performing a CreateTask request on {:?}", (
                &version
            ));

            let result = client.create_task(
                version,
                account_id,
                name,
                app_key,
                grouping_id,
                endpoint_url,
                payload,
                scheduled_date,
                start_date,
                end_date,
                cron_expression,
                visibility,
                active,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                CreateTaskResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::DeleteTask {
            version,
            account_id,
            task_id,
        } => {
            info!("Performing a DeleteTask request on {:?}", (
                &version
            ));

            let result = client.delete_task(
                version,
                account_id,
                task_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                DeleteTaskResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetTask {
            version,
            account_id,
            task_id,
        } => {
            info!("Performing a GetTask request on {:?}", (
                &version
            ));

            let result = client.get_task(
                version,
                account_id,
                task_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetTaskResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::SearchTasks {
            version,
            account_id,
            grouping_id,
            filter,
            statuses,
            template_types,
            app_key,
            keyword,
            sort_field,
            descending,
            start,
            limit,
            active_only,
        } => {
            info!("Performing a SearchTasks request on {:?}", (
                &version
            ));

            let result = client.search_tasks(
                version,
                account_id,
                grouping_id,
                filter,
                statuses,
                template_types,
                app_key,
                keyword,
                sort_field,
                descending,
                start,
                limit,
                active_only,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                SearchTasksResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::UpdateTask {
            version,
            task_id,
            account_id,
            name,
            app_key,
            grouping_id,
            endpoint_url,
            payload,
            scheduled_date,
            start_date,
            end_date,
            cron_expression,
            visibility,
            active,
        } => {
            info!("Performing a UpdateTask request on {:?}", (
                &version
            ));

            let result = client.update_task(
                version,
                task_id,
                account_id,
                name,
                app_key,
                grouping_id,
                endpoint_url,
                payload,
                scheduled_date,
                start_date,
                end_date,
                cron_expression,
                visibility,
                active,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                UpdateTaskResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::CreateTerritory {
            version,
            account_id,
            name,
            active,
        } => {
            info!("Performing a CreateTerritory request on {:?}", (
                &version
            ));

            let result = client.create_territory(
                version,
                account_id,
                name,
                active,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                CreateTerritoryResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::DeleteTerritory {
            version,
            account_id,
            territory_id,
        } => {
            info!("Performing a DeleteTerritory request on {:?}", (
                &version
            ));

            let result = client.delete_territory(
                version,
                account_id,
                territory_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                DeleteTerritoryResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetTerritory {
            version,
            territory_id,
        } => {
            info!("Performing a GetTerritory request on {:?}", (
                &version
            ));

            let result = client.get_territory(
                version,
                territory_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetTerritoryResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::SearchTerritories {
            version,
            sort_field,
            descending,
            keyword,
            start,
            limit,
        } => {
            info!("Performing a SearchTerritories request on {:?}", (
                &version
            ));

            let result = client.search_territories(
                version,
                sort_field,
                descending,
                keyword,
                start,
                limit,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                SearchTerritoriesResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::UpdateTerritory {
            version,
            account_id,
            territory_id,
            name,
            active,
        } => {
            info!("Performing a UpdateTerritory request on {:?}", (
                &version
            ));

            let result = client.update_territory(
                version,
                account_id,
                territory_id,
                name,
                active,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                UpdateTerritoryResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::AddOrUpdateThemeDescriptor {
            version,
            public_read,
            public_write,
            public_delete,
            public_add,
            visibility,
            include_friend_group,
            complete_with_default_values,
            device_id,
            account_id,
            game_type,
            theme_descriptor_id,
            title,
            description,
            connection_ids_to_add,
            connection_group_ids_to_add,
            app_version,
            color_value_json,
            string_replacer_json,
            custom_json_objects,
            icon_image,
            scene_atlas_image,
            bg_image,
            bg_sound,
            music_selection,
            location_description,
            latitude,
            longitude,
        } => {
            info!("Performing a AddOrUpdateThemeDescriptor request on {:?}", (
                &version
            ));

            let result = client.add_or_update_theme_descriptor(
                version,
                public_read,
                public_write,
                public_delete,
                public_add,
                visibility,
                include_friend_group,
                complete_with_default_values,
                device_id,
                account_id,
                game_type,
                theme_descriptor_id,
                title,
                description,
                connection_ids_to_add,
                connection_group_ids_to_add,
                app_version,
                color_value_json,
                string_replacer_json,
                custom_json_objects,
                icon_image,
                scene_atlas_image,
                bg_image,
                bg_sound,
                music_selection,
                location_description,
                latitude,
                longitude,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                AddOrUpdateThemeDescriptorResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetThemeDescriptor {
            version,
            theme_descriptor_id,
            device_id,
            account_id,
            game_type,
            latitude,
            longitude,
        } => {
            info!("Performing a GetThemeDescriptor request on {:?}", (
                &version
            ));

            let result = client.get_theme_descriptor(
                version,
                theme_descriptor_id,
                device_id,
                account_id,
                game_type,
                latitude,
                longitude,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetThemeDescriptorResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetThemeDescriptors {
            version,
            filter,
            sort_field,
            descending,
            start,
            limit,
            device_id,
            account_id,
            game_type,
            contest_type,
            owner_id,
            q,
            keyword,
            _i,
            _l,
            date_created,
            app_version,
            latitude,
            longitude,
        } => {
            info!("Performing a GetThemeDescriptors request on {:?}", (
                &version
            ));

            let result = client.get_theme_descriptors(
                version,
                filter,
                sort_field,
                descending,
                start,
                limit,
                device_id,
                account_id,
                game_type,
                contest_type,
                owner_id,
                q,
                keyword,
                _i,
                _l,
                date_created,
                app_version,
                latitude,
                longitude,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetThemeDescriptorsResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::RemoveThemeDescriptor {
            version,
            theme_descriptor_id,
            device_id,
            account_id,
            game_type,
            latitude,
            longitude,
        } => {
            info!("Performing a RemoveThemeDescriptor request on {:?}", (
                &version
            ));

            let result = client.remove_theme_descriptor(
                version,
                theme_descriptor_id,
                device_id,
                account_id,
                game_type,
                latitude,
                longitude,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                RemoveThemeDescriptorResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::CreateCredential {
            version,
            third_party_id,
            third_party_token,
            network_uid,
            app_key,
            account_id,
            device_id,
            session_id,
            third_party_name,
            email_address,
            signin_only_mode,
            response_filters,
            latitude,
            longitude,
            meta_data,
            third_party_refresh_token,
            audience_ids_to_add,
            audience_ids_to_remove,
        } => {
            info!("Performing a CreateCredential request on {:?}", (
                &version
            ));

            let result = client.create_credential(
                version,
                third_party_id,
                third_party_token,
                network_uid,
                app_key,
                account_id,
                device_id,
                session_id,
                third_party_name,
                email_address,
                signin_only_mode,
                response_filters,
                latitude,
                longitude,
                meta_data,
                third_party_refresh_token,
                audience_ids_to_add,
                audience_ids_to_remove,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                CreateCredentialResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::CreateNetwork {
            version,
            account_id,
            name,
            enable_introspection,
            description,
            introspection_method,
            introspection_url,
            introspection_params,
            required_root_field,
            enable_mfa,
            size_mfa,
            shelf_life_mfa,
            oauth_token_url,
            oauth_private_key,
            oauth_public_key,
            oauth_client_id,
            oauth_secret_key,
            body,
        } => {
            info!("Performing a CreateNetwork request on {:?}", (
                &version
            ));

            let result = client.create_network(
                version,
                account_id,
                name,
                enable_introspection,
                description,
                introspection_method,
                introspection_url,
                introspection_params,
                required_root_field,
                enable_mfa,
                size_mfa,
                shelf_life_mfa,
                oauth_token_url,
                oauth_private_key,
                oauth_public_key,
                oauth_client_id,
                oauth_secret_key,
                body,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                CreateNetworkResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::DeleteCredential {
            version,
            account_id,
            network_uid,
            third_party_id,
            app_key,
        } => {
            info!("Performing a DeleteCredential request on {:?}", (
                &version
            ));

            let result = client.delete_credential(
                version,
                account_id,
                network_uid,
                third_party_id,
                app_key,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                DeleteCredentialResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::DeleteNetwork {
            version,
            account_id,
            network_uid,
        } => {
            info!("Performing a DeleteNetwork request on {:?}", (
                &version
            ));

            let result = client.delete_network(
                version,
                account_id,
                network_uid,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                DeleteNetworkResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetCredential {
            version,
            network_uid,
            app_key,
            account_id,
            device_id,
            session_id,
            third_party_credential_id,
            third_party_token,
            third_party_secret,
            create_new_account,
            response_filters,
            latitude,
            longitude,
            audience_ids_to_add,
            audience_ids_to_remove,
            referral_account_id,
        } => {
            info!("Performing a GetCredential request on {:?}", (
                &version
            ));

            let result = client.get_credential(
                version,
                network_uid,
                app_key,
                account_id,
                device_id,
                session_id,
                third_party_credential_id,
                third_party_token,
                third_party_secret,
                create_new_account,
                response_filters,
                latitude,
                longitude,
                audience_ids_to_add,
                audience_ids_to_remove,
                referral_account_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetCredentialResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetNetwork {
            version,
            account_id,
            network_uid,
        } => {
            info!("Performing a GetNetwork request on {:?}", (
                &version
            ));

            let result = client.get_network(
                version,
                account_id,
                network_uid,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetNetworkResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::SearchCredentials {
            version,
            account_id,
            keyword,
            network_uid,
            descending,
            start,
            limit,
        } => {
            info!("Performing a SearchCredentials request on {:?}", (
                &version
            ));

            let result = client.search_credentials(
                version,
                account_id,
                keyword,
                network_uid,
                descending,
                start,
                limit,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                SearchCredentialsResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::SearchNetworks {
            version,
            account_id,
            sort_field,
            descending,
            start,
            limit,
            active_only,
            keyword,
            filter_billable,
        } => {
            info!("Performing a SearchNetworks request on {:?}", (
                &version
            ));

            let result = client.search_networks(
                version,
                account_id,
                sort_field,
                descending,
                start,
                limit,
                active_only,
                keyword,
                filter_billable,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                SearchNetworksResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::SendMfaChallenge {
            version,
            network_uid,
            app_key,
            third_party_token,
            third_party_credential_id,
            device_id,
        } => {
            info!("Performing a SendMfaChallenge request on {:?}", (
                &version
            ));

            let result = client.send_mfa_challenge(
                version,
                network_uid,
                app_key,
                third_party_token,
                third_party_credential_id,
                device_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                SendMfaChallengeResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::UpdateCredential {
            version,
            network_uid,
            third_party_id,
            app_key,
            device_id,
            third_party_name,
            third_party_token,
            response_filters,
            meta_data,
            third_party_refresh_token,
        } => {
            info!("Performing a UpdateCredential request on {:?}", (
                &version
            ));

            let result = client.update_credential(
                version,
                network_uid,
                third_party_id,
                app_key,
                device_id,
                third_party_name,
                third_party_token,
                response_filters,
                meta_data,
                third_party_refresh_token,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                UpdateCredentialResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::UpdateNetwork {
            version,
            account_id,
            network_uid,
            name,
            description,
            enable_introspection,
            introspection_method,
            introspection_url,
            introspection_params,
            required_root_field,
            enable_mfa,
            size_mfa,
            shelf_life_mfa,
            oauth_token_url,
            oauth_private_key,
            oauth_public_key,
            oauth_client_id,
            oauth_secret_key,
            body,
        } => {
            info!("Performing a UpdateNetwork request on {:?}", (
                &version
            ));

            let result = client.update_network(
                version,
                account_id,
                network_uid,
                name,
                description,
                enable_introspection,
                introspection_method,
                introspection_url,
                introspection_params,
                required_root_field,
                enable_mfa,
                size_mfa,
                shelf_life_mfa,
                oauth_token_url,
                oauth_private_key,
                oauth_public_key,
                oauth_client_id,
                oauth_secret_key,
                body,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                UpdateNetworkResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetTicketCount {
            version,
            device_id,
            account_id,
            game_type,
            app_key,
            ticket_type,
        } => {
            info!("Performing a GetTicketCount request on {:?}", (
                &version
            ));

            let result = client.get_ticket_count(
                version,
                device_id,
                account_id,
                game_type,
                app_key,
                ticket_type,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetTicketCountResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetTicketList {
            version,
            device_id,
            account_id,
            ticket_object_type,
            action_type,
            ticket_ids,
            object_ids,
            receipt_tokens,
            game_type,
            app_key,
        } => {
            info!("Performing a GetTicketList request on {:?}", (
                &version
            ));

            let result = client.get_ticket_list(
                version,
                device_id,
                account_id,
                ticket_object_type,
                action_type,
                ticket_ids,
                object_ids,
                receipt_tokens,
                game_type,
                app_key,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetTicketListResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GiftPurchase {
            version,
            receiver_account_id,
            ticket_id,
            device_id,
            account_id,
            asset_id,
            custom_message,
            game_type,
            app_key,
        } => {
            info!("Performing a GiftPurchase request on {:?}", (
                &version
            ));

            let result = client.gift_purchase(
                version,
                receiver_account_id,
                ticket_id,
                device_id,
                account_id,
                asset_id,
                custom_message,
                game_type,
                app_key,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GiftPurchaseResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::SaveTicket {
            version,
            action_type,
            ticket_object_type,
            return_nulls,
            device_id,
            account_id,
            game_type,
            app_key,
            object_id,
            purchase_code,
            receipt_token,
            receipt_data,
            count,
            ticket_type,
            purchase_provider,
            purchase_type,
            return_profile_response,
            include_profile_response,
            app_version,
        } => {
            info!("Performing a SaveTicket request on {:?}", (
                &version
            ));

            let result = client.save_ticket(
                version,
                action_type,
                ticket_object_type,
                return_nulls,
                device_id,
                account_id,
                game_type,
                app_key,
                object_id,
                purchase_code,
                receipt_token,
                receipt_data,
                count,
                ticket_type,
                purchase_provider,
                purchase_type,
                return_profile_response,
                include_profile_response,
                app_version,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                SaveTicketResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::SaveTicketViaFileUpload {
            version,
            action_type,
            ticket_object_type,
            receipt_data,
            return_nulls,
            device_id,
            account_id,
            game_type,
            app_key,
            object_id,
            purchase_code,
            receipt_token,
            count,
            ticket_type,
            purchase_provider,
            purchase_type,
            return_profile_response,
            include_profile_response,
            app_version,
        } => {
            info!("Performing a SaveTicketViaFileUpload request on {:?}", (
                &version
            ));

            let result = client.save_ticket_via_file_upload(
                version,
                action_type,
                ticket_object_type,
                receipt_data,
                return_nulls,
                device_id,
                account_id,
                game_type,
                app_key,
                object_id,
                purchase_code,
                receipt_token,
                count,
                ticket_type,
                purchase_provider,
                purchase_type,
                return_profile_response,
                include_profile_response,
                app_version,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                SaveTicketViaFileUploadResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::TicketOffers {
            version,
        } => {
            info!("Performing a TicketOffers request on {:?}", (
                &version
            ));

            let result = client.ticket_offers(
                version,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                TicketOffersResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::CreateTournament {
            version,
            account_id,
            app_key,
            title,
            cost_to_play,
            start_date,
            sub_type,
            image_asset_id,
            seconds_between_levels,
            seconds_for_tie_breaker,
            seconds_between_packs,
            maximum_level_length,
            cost_to_play_type,
            minimum_to_play,
            starting_limit,
            available_limit,
            description,
            meta_data,
            audience_ids,
            active,
            enable_buy_back,
            offer_ids,
            offer_asset_id,
            fixed_reward,
            split_reward,
            allocate_tickets,
            tournament_data,
            mission_type,
            visibility,
            preliminary_groups,
            preliminary_group_advancements,
            enable_multiple_entries,
            enable_multiple_votes,
            featured,
            winner_tag,
            tie_tag,
        } => {
            info!("Performing a CreateTournament request on {:?}", (
                &version
            ));

            let result = client.create_tournament(
                version,
                account_id,
                app_key,
                title,
                cost_to_play,
                start_date,
                sub_type,
                image_asset_id,
                seconds_between_levels,
                seconds_for_tie_breaker,
                seconds_between_packs,
                maximum_level_length,
                cost_to_play_type,
                minimum_to_play,
                starting_limit,
                available_limit,
                description,
                meta_data,
                audience_ids,
                active,
                enable_buy_back,
                offer_ids,
                offer_asset_id,
                fixed_reward,
                split_reward,
                allocate_tickets,
                tournament_data,
                mission_type,
                visibility,
                preliminary_groups,
                preliminary_group_advancements,
                enable_multiple_entries,
                enable_multiple_votes,
                featured,
                winner_tag,
                tie_tag,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                CreateTournamentResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::DeleteTournament {
            version,
            account_id,
            mission_id,
        } => {
            info!("Performing a DeleteTournament request on {:?}", (
                &version
            ));

            let result = client.delete_tournament(
                version,
                account_id,
                mission_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                DeleteTournamentResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetTournament {
            version,
            account_id,
            mission_id,
            join_code,
            include_scores,
            object_preview_size,
        } => {
            info!("Performing a GetTournament request on {:?}", (
                &version
            ));

            let result = client.get_tournament(
                version,
                account_id,
                mission_id,
                join_code,
                include_scores,
                object_preview_size,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetTournamentResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::SearchObjects {
            version,
            account_id,
            game_level_id,
            sort_field,
            descending,
            start,
            limit,
        } => {
            info!("Performing a SearchObjects request on {:?}", (
                &version
            ));

            let result = client.search_objects(
                version,
                account_id,
                game_level_id,
                sort_field,
                descending,
                start,
                limit,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                SearchObjectsResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::SearchRounds {
            version,
            account_id,
            app_key,
            status,
            mission_type,
            current_only,
            visibilities,
            start,
            limit,
        } => {
            info!("Performing a SearchRounds request on {:?}", (
                &version
            ));

            let result = client.search_rounds(
                version,
                account_id,
                app_key,
                status,
                mission_type,
                current_only,
                visibilities,
                start,
                limit,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                SearchRoundsResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::SearchTournaments {
            version,
            account_id,
            app_key,
            keyword,
            sub_type,
            include_inactive,
            mission_types,
            filter,
            sort_field,
            descending,
            visibility,
            start,
            limit,
        } => {
            info!("Performing a SearchTournaments request on {:?}", (
                &version
            ));

            let result = client.search_tournaments(
                version,
                account_id,
                app_key,
                keyword,
                sub_type,
                include_inactive,
                mission_types,
                filter,
                sort_field,
                descending,
                visibility,
                start,
                limit,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                SearchTournamentsResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::SubmitTournamentScore {
            version,
            account_id,
            app_key,
            mission_id,
            game_id,
            pack_id,
            scores,
            game_level_id,
        } => {
            info!("Performing a SubmitTournamentScore request on {:?}", (
                &version
            ));

            let result = client.submit_tournament_score(
                version,
                account_id,
                app_key,
                mission_id,
                game_id,
                pack_id,
                scores,
                game_level_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                SubmitTournamentScoreResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::SubmitTournamentVote {
            version,
            account_id,
            app_key,
            mission_id,
            game_object_id,
            device_id,
            check_if_device_already_voted,
        } => {
            info!("Performing a SubmitTournamentVote request on {:?}", (
                &version
            ));

            let result = client.submit_tournament_vote(
                version,
                account_id,
                app_key,
                mission_id,
                game_object_id,
                device_id,
                check_if_device_already_voted,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                SubmitTournamentVoteResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::SubstituteTournamentPlayer {
            version,
            account_id,
            mission_id,
            pack_id,
            game_level_id,
        } => {
            info!("Performing a SubstituteTournamentPlayer request on {:?}", (
                &version
            ));

            let result = client.substitute_tournament_player(
                version,
                account_id,
                mission_id,
                pack_id,
                game_level_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                SubstituteTournamentPlayerResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::UpdateTournament {
            version,
            account_id,
            mission_id,
            title,
            sub_type,
            image_asset_id,
            seconds_between_levels,
            seconds_for_tie_breaker,
            seconds_between_packs,
            maximum_level_length,
            cost_to_play,
            cost_to_play_type,
            minimum_to_play,
            starting_limit,
            available_limit,
            description,
            meta_data,
            start_date,
            audience_ids,
            active,
            enable_buy_back,
            offer_ids,
            offer_asset_id,
            fixed_reward,
            split_reward,
            allocate_tickets,
            tournament_data,
            visibility,
            preliminary_groups,
            preliminary_group_advancements,
            enable_multiple_entries,
            enable_multiple_votes,
            featured,
            winner_tag,
            tie_tag,
        } => {
            info!("Performing a UpdateTournament request on {:?}", (
                &version
            ));

            let result = client.update_tournament(
                version,
                account_id,
                mission_id,
                title,
                sub_type,
                image_asset_id,
                seconds_between_levels,
                seconds_for_tie_breaker,
                seconds_between_packs,
                maximum_level_length,
                cost_to_play,
                cost_to_play_type,
                minimum_to_play,
                starting_limit,
                available_limit,
                description,
                meta_data,
                start_date,
                audience_ids,
                active,
                enable_buy_back,
                offer_ids,
                offer_asset_id,
                fixed_reward,
                split_reward,
                allocate_tickets,
                tournament_data,
                visibility,
                preliminary_groups,
                preliminary_group_advancements,
                enable_multiple_entries,
                enable_multiple_votes,
                featured,
                winner_tag,
                tie_tag,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                UpdateTournamentResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::BatchSaveTracking {
            version,
            data,
            device_id,
            account_id,
            generate_accounts,
            update_account_locations,
            default_tag,
            slave_uid,
        } => {
            info!("Performing a BatchSaveTracking request on {:?}", (
                &version
            ));

            let result = client.batch_save_tracking(
                version,
                data,
                device_id,
                account_id,
                generate_accounts,
                update_account_locations,
                default_tag,
                slave_uid,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                BatchSaveTrackingResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetPredictedLocations {
            version,
            account_id,
            latitude,
            longitude,
            date_check,
            hour_check,
            threshold,
            distance_unit,
            search_range,
            sort_order,
        } => {
            info!("Performing a GetPredictedLocations request on {:?}", (
                &version
            ));

            let result = client.get_predicted_locations(
                version,
                account_id,
                latitude,
                longitude,
                date_check,
                hour_check,
                threshold,
                distance_unit,
                search_range,
                sort_order,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetPredictedLocationsResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetPredictedPath {
            version,
            account_id,
            start_step_id,
            end_step_id,
        } => {
            info!("Performing a GetPredictedPath request on {:?}", (
                &version
            ));

            let result = client.get_predicted_path(
                version,
                account_id,
                start_step_id,
                end_step_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetPredictedPathResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetPreferredLocations {
            version,
            account_id,
            latitude,
            longitude,
            date_check,
            hour_check,
            sort_field,
            descending,
            start,
            limit,
            search_range,
            distance_unit,
        } => {
            info!("Performing a GetPreferredLocations request on {:?}", (
                &version
            ));

            let result = client.get_preferred_locations(
                version,
                account_id,
                latitude,
                longitude,
                date_check,
                hour_check,
                sort_field,
                descending,
                start,
                limit,
                search_range,
                distance_unit,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetPreferredLocationsResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetTrackingLegs {
            version,
            device_id,
            account_id,
            owner_id,
            tracking_device_id,
            start_date,
            end_date,
            tags,
            get_last_point,
        } => {
            info!("Performing a GetTrackingLegs request on {:?}", (
                &version
            ));

            let result = client.get_tracking_legs(
                version,
                device_id,
                account_id,
                owner_id,
                tracking_device_id,
                start_date,
                end_date,
                tags,
                get_last_point,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetTrackingLegsResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::SaveTrackingLeg {
            version,
            start_lat,
            start_lng,
            start_date,
            end_lat,
            end_lng,
            end_date,
            device_id,
            account_id,
            distance,
            duration,
            steps,
            tags,
        } => {
            info!("Performing a SaveTrackingLeg request on {:?}", (
                &version
            ));

            let result = client.save_tracking_leg(
                version,
                start_lat,
                start_lng,
                start_date,
                end_lat,
                end_lng,
                end_date,
                device_id,
                account_id,
                distance,
                duration,
                steps,
                tags,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                SaveTrackingLegResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::SaveTrackingStep {
            version,
            leg_id,
            start_lat,
            start_lng,
            start_date,
            end_lat,
            end_lng,
            end_date,
            device_id,
            account_id,
            distance,
            duration,
        } => {
            info!("Performing a SaveTrackingStep request on {:?}", (
                &version
            ));

            let result = client.save_tracking_step(
                version,
                leg_id,
                start_lat,
                start_lng,
                start_date,
                end_lat,
                end_lng,
                end_date,
                device_id,
                account_id,
                distance,
                duration,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                SaveTrackingStepResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::SearchAccountsWithTrackingLegs {
            version,
            account_id,
            keyword,
            start_date,
            end_date,
            tags,
            audience_ids,
            latitude,
            longitude,
            range,
            sort_field,
            descending,
            start,
            limit,
            active_only,
        } => {
            info!("Performing a SearchAccountsWithTrackingLegs request on {:?}", (
                &version
            ));

            let result = client.search_accounts_with_tracking_legs(
                version,
                account_id,
                keyword,
                start_date,
                end_date,
                tags,
                audience_ids,
                latitude,
                longitude,
                range,
                sort_field,
                descending,
                start,
                limit,
                active_only,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                SearchAccountsWithTrackingLegsResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::SearchTrackingLegs {
            version,
            account_id,
            app_key,
            tracking_device_id,
            start_date,
            end_date,
            tags,
            start,
            limit,
        } => {
            info!("Performing a SearchTrackingLegs request on {:?}", (
                &version
            ));

            let result = client.search_tracking_legs(
                version,
                account_id,
                app_key,
                tracking_device_id,
                start_date,
                end_date,
                tags,
                start,
                limit,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                SearchTrackingLegsResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::CreateTrigger {
            version,
            account_id,
            name,
            app_key,
            grouping_id,
            endpoint_url,
            payload,
            scheduled_date,
            start_date,
            end_date,
            cron_expression,
            conditional_input,
            visibility,
            active,
        } => {
            info!("Performing a CreateTrigger request on {:?}", (
                &version
            ));

            let result = client.create_trigger(
                version,
                account_id,
                name,
                app_key,
                grouping_id,
                endpoint_url,
                payload,
                scheduled_date,
                start_date,
                end_date,
                cron_expression,
                conditional_input,
                visibility,
                active,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                CreateTriggerResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::DeleteTrigger {
            version,
            account_id,
            trigger_id,
        } => {
            info!("Performing a DeleteTrigger request on {:?}", (
                &version
            ));

            let result = client.delete_trigger(
                version,
                account_id,
                trigger_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                DeleteTriggerResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetTrigger {
            version,
            account_id,
            trigger_id,
        } => {
            info!("Performing a GetTrigger request on {:?}", (
                &version
            ));

            let result = client.get_trigger(
                version,
                account_id,
                trigger_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetTriggerResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::SearchTriggers {
            version,
            account_id,
            grouping_id,
            filter,
            statuses,
            template_types,
            app_key,
            keyword,
            sort_field,
            descending,
            start,
            limit,
            active_only,
        } => {
            info!("Performing a SearchTriggers request on {:?}", (
                &version
            ));

            let result = client.search_triggers(
                version,
                account_id,
                grouping_id,
                filter,
                statuses,
                template_types,
                app_key,
                keyword,
                sort_field,
                descending,
                start,
                limit,
                active_only,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                SearchTriggersResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::UpdateTrigger {
            version,
            trigger_id,
            account_id,
            name,
            app_key,
            grouping_id,
            endpoint_url,
            payload,
            scheduled_date,
            start_date,
            end_date,
            cron_expression,
            conditional_input,
            visibility,
            active,
        } => {
            info!("Performing a UpdateTrigger request on {:?}", (
                &version
            ));

            let result = client.update_trigger(
                version,
                trigger_id,
                account_id,
                name,
                app_key,
                grouping_id,
                endpoint_url,
                payload,
                scheduled_date,
                start_date,
                end_date,
                cron_expression,
                conditional_input,
                visibility,
                active,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                UpdateTriggerResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::CreateTrip {
            version,
            body,
        } => {
            info!("Performing a CreateTrip request on {:?}", (
                &version
            ));

            let result = client.create_trip(
                version,
                body,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                CreateTripResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::ProcessTripMatches {
            version,
            start_date,
            end_date,
            trip_id,
        } => {
            info!("Performing a ProcessTripMatches request on {:?}", (
                &version
            ));

            let result = client.process_trip_matches(
                version,
                start_date,
                end_date,
                trip_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                ProcessTripMatchesResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::Search {
            version,
            account_id,
            sort_field,
            descending,
            start,
            limit,
            active_only,
            start_date,
            end_date,
            has_notifications,
        } => {
            info!("Performing a Search request on {:?}", (
                &version
            ));

            let result = client.search(
                version,
                account_id,
                sort_field,
                descending,
                start,
                limit,
                active_only,
                start_date,
                end_date,
                has_notifications,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                SearchResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::SearchTrips {
            version,
            account_id,
            sort_field,
            descending,
            start,
            limit,
            active_only,
            start_date,
            end_date,
            matched_has_route,
            matched_has_driver,
        } => {
            info!("Performing a SearchTrips request on {:?}", (
                &version
            ));

            let result = client.search_trips(
                version,
                account_id,
                sort_field,
                descending,
                start,
                limit,
                active_only,
                start_date,
                end_date,
                matched_has_route,
                matched_has_driver,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                SearchTripsResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::UpdateTripNotifications {
            version,
            id,
            notifications,
        } => {
            info!("Performing a UpdateTripNotifications request on {:?}", (
                &version
            ));

            let result = client.update_trip_notifications(
                version,
                id,
                notifications,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                UpdateTripNotificationsResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::Delete {
            version,
            id,
        } => {
            prompt(args.force, "This will delete the given entry, are you sure?")?;
            info!("Performing a Delete request on {:?}", (
                &version,
                &id
            ));

            let result = client.delete(
                version,
                id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                DeleteResponse::SuccessfulOperation
                => "SuccessfulOperation\n".to_string()
                    ,
            }
        }
        Operation::DriveTrip {
            version,
            id,
            recurrence,
        } => {
            info!("Performing a DriveTrip request on {:?}", (
                &version,
                &id
            ));

            let result = client.drive_trip(
                version,
                id,
                recurrence,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                DriveTripResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::FlexibleTrip {
            version,
            id,
            recurrence,
        } => {
            info!("Performing a FlexibleTrip request on {:?}", (
                &version,
                &id
            ));

            let result = client.flexible_trip(
                version,
                id,
                recurrence,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                FlexibleTripResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetTrip {
            version,
            id,
        } => {
            info!("Performing a GetTrip request on {:?}", (
                &version,
                &id
            ));

            let result = client.get_trip(
                version,
                id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetTripResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetTripMatches {
            version,
            id,
            sort_field,
            descending,
            start,
            limit,
            active_only,
            matched_has_route,
            matched_has_driver,
        } => {
            info!("Performing a GetTripMatches request on {:?}", (
                &version,
                &id
            ));

            let result = client.get_trip_matches(
                version,
                id,
                sort_field,
                descending,
                start,
                limit,
                active_only,
                matched_has_route,
                matched_has_driver,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetTripMatchesResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::Ride {
            version,
            id,
            recurrence,
        } => {
            info!("Performing a Ride request on {:?}", (
                &version,
                &id
            ));

            let result = client.ride(
                version,
                id,
                recurrence,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                RideResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::UpdateLocations {
            version,
            id,
            body,
        } => {
            info!("Performing a UpdateLocations request on {:?}", (
                &version,
                &id
            ));

            let result = client.update_locations(
                version,
                id,
                body,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                UpdateLocationsResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::UpdateRecurrenceLocations {
            version,
            id,
            body,
        } => {
            info!("Performing a UpdateRecurrenceLocations request on {:?}", (
                &version,
                &id
            ));

            let result = client.update_recurrence_locations(
                version,
                id,
                body,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                UpdateRecurrenceLocationsResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::UpdateRecurrenceShipments {
            version,
            id,
            body,
        } => {
            info!("Performing a UpdateRecurrenceShipments request on {:?}", (
                &version,
                &id
            ));

            let result = client.update_recurrence_shipments(
                version,
                id,
                body,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                UpdateRecurrenceShipmentsResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::UpdateShipments {
            version,
            id,
            body,
        } => {
            info!("Performing a UpdateShipments request on {:?}", (
                &version,
                &id
            ));

            let result = client.update_shipments(
                version,
                id,
                body,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                UpdateShipmentsResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::UpdateTrip {
            version,
            id,
            body,
        } => {
            info!("Performing a UpdateTrip request on {:?}", (
                &version,
                &id
            ));

            let result = client.update_trip(
                version,
                id,
                body,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                UpdateTripResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::SmsBuyOffer {
            version,
            app_key,
            body,
            from,
            currency_type,
        } => {
            info!("Performing a SmsBuyOffer request on {:?}", (
                &version,
                &app_key
            ));

            let result = client.sms_buy_offer(
                version,
                app_key,
                body,
                from,
                currency_type,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                SmsBuyOfferResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::AuthorizeTwitter {
            version,
            app_key,
        } => {
            info!("Performing a AuthorizeTwitter request on {:?}", (
                &version
            ));

            let result = client.authorize_twitter(
                version,
                app_key,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                AuthorizeTwitterResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::LoginTwitter {
            version,
            access_token,
            access_token_secret,
            app_key,
            response_filters,
            device_id,
            latitude,
            longitude,
        } => {
            info!("Performing a LoginTwitter request on {:?}", (
                &version
            ));

            let result = client.login_twitter(
                version,
                access_token,
                access_token_secret,
                app_key,
                response_filters,
                device_id,
                latitude,
                longitude,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                LoginTwitterResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::AddUsersToPermissionable {
            version,
            permissionable_type,
            permissionable_id,
            device_id,
            account_id,
            read,
            write,
            delete,
            add,
            connection_ids,
            connection_account_ids,
            connection_group_ids,
            pending,
            admin,
            include_friend_group,
            latitude,
            longitude,
            audience_ids,
        } => {
            info!("Performing a AddUsersToPermissionable request on {:?}", (
                &version
            ));

            let result = client.add_users_to_permissionable(
                version,
                permissionable_type,
                permissionable_id,
                device_id,
                account_id,
                read,
                write,
                delete,
                add,
                connection_ids,
                connection_account_ids,
                connection_group_ids,
                pending,
                admin,
                include_friend_group,
                latitude,
                longitude,
                audience_ids,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                AddUsersToPermissionableResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::ApprovePermissionable {
            version,
            permissionable_type,
            permissionable_id,
            device_id,
            account_id,
            approval_status,
        } => {
            info!("Performing a ApprovePermissionable request on {:?}", (
                &version
            ));

            let result = client.approve_permissionable(
                version,
                permissionable_type,
                permissionable_id,
                device_id,
                account_id,
                approval_status,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                ApprovePermissionableResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::LeaveFromPermissionable {
            version,
            permissionable_type,
            permissionable_id,
            device_id,
            account_id,
            latitude,
            longitude,
        } => {
            info!("Performing a LeaveFromPermissionable request on {:?}", (
                &version
            ));

            let result = client.leave_from_permissionable(
                version,
                permissionable_type,
                permissionable_id,
                device_id,
                account_id,
                latitude,
                longitude,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                LeaveFromPermissionableResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::RemoveUsersFromPermissionable {
            version,
            permissionable_type,
            permissionable_id,
            device_id,
            account_id,
            connection_ids,
            connection_account_ids,
            connection_group_ids,
            remove_friend_group,
            latitude,
            longitude,
            audience_ids,
        } => {
            info!("Performing a RemoveUsersFromPermissionable request on {:?}", (
                &version
            ));

            let result = client.remove_users_from_permissionable(
                version,
                permissionable_type,
                permissionable_id,
                device_id,
                account_id,
                connection_ids,
                connection_account_ids,
                connection_group_ids,
                remove_friend_group,
                latitude,
                longitude,
                audience_ids,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                RemoveUsersFromPermissionableResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::SearchPermissionables {
            version,
            device_id,
            account_id,
            connection_account_id,
            connection_account_ids,
            permissionable_type,
            permissionable_id,
            keyword,
            sort_field,
            descending,
            pending,
            admin,
            start,
            limit,
        } => {
            info!("Performing a SearchPermissionables request on {:?}", (
                &version
            ));

            let result = client.search_permissionables(
                version,
                device_id,
                account_id,
                connection_account_id,
                connection_account_ids,
                permissionable_type,
                permissionable_id,
                keyword,
                sort_field,
                descending,
                pending,
                admin,
                start,
                limit,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                SearchPermissionablesResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::SearchPermissionablesFollowingDistance {
            version,
            latitude,
            longitude,
            device_id,
            account_id,
            connection_account_id,
            connection_account_ids,
            permissionable_type,
            permissionable_id,
            search_range,
            keyword,
            pending,
            admin,
            start,
            limit,
        } => {
            info!("Performing a SearchPermissionablesFollowingDistance request on {:?}", (
                &version
            ));

            let result = client.search_permissionables_following_distance(
                version,
                latitude,
                longitude,
                device_id,
                account_id,
                connection_account_id,
                connection_account_ids,
                permissionable_type,
                permissionable_id,
                search_range,
                keyword,
                pending,
                admin,
                start,
                limit,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                SearchPermissionablesFollowingDistanceResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::CreateFollowing {
            version,
            account_id,
            vatom_parameters,
            return_raw_response,
        } => {
            info!("Performing a CreateFollowing request on {:?}", (
                &version
            ));

            let result = client.create_following(
                version,
                account_id,
                vatom_parameters,
                return_raw_response,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                CreateFollowingResponse::SuccessfulOperation
                => "SuccessfulOperation\n".to_string()
                    ,
            }
        }
        Operation::CreateSpace {
            version,
            account_id,
            app_key,
            vatom_parameters,
            return_raw_response,
        } => {
            info!("Performing a CreateSpace request on {:?}", (
                &version
            ));

            let result = client.create_space(
                version,
                account_id,
                app_key,
                vatom_parameters,
                return_raw_response,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                CreateSpaceResponse::SuccessfulOperation
                => "SuccessfulOperation\n".to_string()
                    ,
            }
        }
        Operation::CreateVatomEvent {
            version,
            account_id,
            app_key,
            vatom_parameters,
            return_raw_response,
        } => {
            info!("Performing a CreateVatomEvent request on {:?}", (
                &version
            ));

            let result = client.create_vatom_event(
                version,
                account_id,
                app_key,
                vatom_parameters,
                return_raw_response,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                CreateVatomEventResponse::SuccessfulOperation
                => "SuccessfulOperation\n".to_string()
                    ,
            }
        }
        Operation::DeleteFollowing {
            version,
            account_id,
            vatom_rels_key,
            return_raw_response,
        } => {
            info!("Performing a DeleteFollowing request on {:?}", (
                &version
            ));

            let result = client.delete_following(
                version,
                account_id,
                vatom_rels_key,
                return_raw_response,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                DeleteFollowingResponse::SuccessfulOperation
                => "SuccessfulOperation\n".to_string()
                    ,
            }
        }
        Operation::DeletePointsBalance {
            version,
            account_id,
            app_key,
            vatom_campaign_id,
            return_raw_response,
        } => {
            info!("Performing a DeletePointsBalance request on {:?}", (
                &version
            ));

            let result = client.delete_points_balance(
                version,
                account_id,
                app_key,
                vatom_campaign_id,
                return_raw_response,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                DeletePointsBalanceResponse::SuccessfulOperation
                => "SuccessfulOperation\n".to_string()
                    ,
            }
        }
        Operation::DeleteSpace {
            version,
            account_id,
            app_key,
            vatom_space_id,
            return_raw_response,
        } => {
            info!("Performing a DeleteSpace request on {:?}", (
                &version
            ));

            let result = client.delete_space(
                version,
                account_id,
                app_key,
                vatom_space_id,
                return_raw_response,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                DeleteSpaceResponse::SuccessfulOperation
                => "SuccessfulOperation\n".to_string()
                    ,
            }
        }
        Operation::DeleteVatomEvent {
            version,
            account_id,
            app_key,
            vatom_event_id,
            return_raw_response,
        } => {
            info!("Performing a DeleteVatomEvent request on {:?}", (
                &version
            ));

            let result = client.delete_vatom_event(
                version,
                account_id,
                app_key,
                vatom_event_id,
                return_raw_response,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                DeleteVatomEventResponse::SuccessfulOperation
                => "SuccessfulOperation\n".to_string()
                    ,
            }
        }
        Operation::DeleteVatomNft {
            version,
            account_id,
            vatom_id,
            return_raw_response,
        } => {
            info!("Performing a DeleteVatomNft request on {:?}", (
                &version
            ));

            let result = client.delete_vatom_nft(
                version,
                account_id,
                vatom_id,
                return_raw_response,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                DeleteVatomNftResponse::SuccessfulOperation
                => "SuccessfulOperation\n".to_string()
                    ,
            }
        }
        Operation::ExecuteActionOnNft {
            version,
            account_id,
            vatom_id,
            vatom_parameters,
            return_raw_response,
        } => {
            info!("Performing a ExecuteActionOnNft request on {:?}", (
                &version
            ));

            let result = client.execute_action_on_nft(
                version,
                account_id,
                vatom_id,
                vatom_parameters,
                return_raw_response,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                ExecuteActionOnNftResponse::SuccessfulOperation
                => "SuccessfulOperation\n".to_string()
                    ,
            }
        }
        Operation::GeomapSearch {
            version,
            account_id,
            vatom_parameters,
            return_raw_response,
        } => {
            info!("Performing a GeomapSearch request on {:?}", (
                &version
            ));

            let result = client.geomap_search(
                version,
                account_id,
                vatom_parameters,
                return_raw_response,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GeomapSearchResponse::SuccessfulOperation
                => "SuccessfulOperation\n".to_string()
                    ,
            }
        }
        Operation::GetBusinessBehaviors {
            version,
            account_id,
            app_key,
            return_raw_response,
        } => {
            info!("Performing a GetBusinessBehaviors request on {:?}", (
                &version
            ));

            let result = client.get_business_behaviors(
                version,
                account_id,
                app_key,
                return_raw_response,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetBusinessBehaviorsResponse::SuccessfulOperation
                => "SuccessfulOperation\n".to_string()
                    ,
            }
        }
        Operation::GetBusinessCoinsBalance {
            version,
            account_id,
            app_key,
            return_raw_response,
        } => {
            info!("Performing a GetBusinessCoinsBalance request on {:?}", (
                &version
            ));

            let result = client.get_business_coins_balance(
                version,
                account_id,
                app_key,
                return_raw_response,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetBusinessCoinsBalanceResponse::SuccessfulOperation
                => "SuccessfulOperation\n".to_string()
                    ,
            }
        }
        Operation::GetBusinessIds {
            version,
            account_id,
            return_raw_response,
        } => {
            info!("Performing a GetBusinessIds request on {:?}", (
                &version
            ));

            let result = client.get_business_ids(
                version,
                account_id,
                return_raw_response,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetBusinessIdsResponse::SuccessfulOperation
                => "SuccessfulOperation\n".to_string()
                    ,
            }
        }
        Operation::GetBusinessInfo {
            version,
            account_id,
            app_key,
            vatom_parameters,
            return_raw_response,
        } => {
            info!("Performing a GetBusinessInfo request on {:?}", (
                &version
            ));

            let result = client.get_business_info(
                version,
                account_id,
                app_key,
                vatom_parameters,
                return_raw_response,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetBusinessInfoResponse::SuccessfulOperation
                => "SuccessfulOperation\n".to_string()
                    ,
            }
        }
        Operation::GetBusinessUsers {
            version,
            account_id,
            app_key,
            return_raw_response,
        } => {
            info!("Performing a GetBusinessUsers request on {:?}", (
                &version
            ));

            let result = client.get_business_users(
                version,
                account_id,
                app_key,
                return_raw_response,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetBusinessUsersResponse::SuccessfulOperation
                => "SuccessfulOperation\n".to_string()
                    ,
            }
        }
        Operation::GetCampaignGroupEntities {
            version,
            account_id,
            app_key,
            vatom_campaign_id,
            return_raw_response,
        } => {
            info!("Performing a GetCampaignGroupEntities request on {:?}", (
                &version
            ));

            let result = client.get_campaign_group_entities(
                version,
                account_id,
                app_key,
                vatom_campaign_id,
                return_raw_response,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetCampaignGroupEntitiesResponse::SuccessfulOperation
                => "SuccessfulOperation\n".to_string()
                    ,
            }
        }
        Operation::GetCampaignGroupRules {
            version,
            account_id,
            app_key,
            vatom_campaign_id,
            return_raw_response,
        } => {
            info!("Performing a GetCampaignGroupRules request on {:?}", (
                &version
            ));

            let result = client.get_campaign_group_rules(
                version,
                account_id,
                app_key,
                vatom_campaign_id,
                return_raw_response,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetCampaignGroupRulesResponse::SuccessfulOperation
                => "SuccessfulOperation\n".to_string()
                    ,
            }
        }
        Operation::GetCampaignGroupStats {
            version,
            account_id,
            app_key,
            vatom_campaign_id,
            return_raw_response,
        } => {
            info!("Performing a GetCampaignGroupStats request on {:?}", (
                &version
            ));

            let result = client.get_campaign_group_stats(
                version,
                account_id,
                app_key,
                vatom_campaign_id,
                return_raw_response,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetCampaignGroupStatsResponse::SuccessfulOperation
                => "SuccessfulOperation\n".to_string()
                    ,
            }
        }
        Operation::GetCampaignInfo {
            version,
            account_id,
            app_key,
            vatom_campaign_id,
            return_raw_response,
        } => {
            info!("Performing a GetCampaignInfo request on {:?}", (
                &version
            ));

            let result = client.get_campaign_info(
                version,
                account_id,
                app_key,
                vatom_campaign_id,
                return_raw_response,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetCampaignInfoResponse::SuccessfulOperation
                => "SuccessfulOperation\n".to_string()
                    ,
            }
        }
        Operation::GetEventGuestList {
            version,
            account_id,
            app_key,
            vatom_event_id,
            return_raw_response,
        } => {
            info!("Performing a GetEventGuestList request on {:?}", (
                &version
            ));

            let result = client.get_event_guest_list(
                version,
                account_id,
                app_key,
                vatom_event_id,
                return_raw_response,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetEventGuestListResponse::SuccessfulOperation
                => "SuccessfulOperation\n".to_string()
                    ,
            }
        }
        Operation::GetInventory {
            version,
            account_id,
            vatom_parameters,
            return_raw_response,
        } => {
            info!("Performing a GetInventory request on {:?}", (
                &version
            ));

            let result = client.get_inventory(
                version,
                account_id,
                vatom_parameters,
                return_raw_response,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetInventoryResponse::SuccessfulOperation
                => "SuccessfulOperation\n".to_string()
                    ,
            }
        }
        Operation::GetMyFollowing {
            version,
            account_id,
            return_raw_response,
        } => {
            info!("Performing a GetMyFollowing request on {:?}", (
                &version
            ));

            let result = client.get_my_following(
                version,
                account_id,
                return_raw_response,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetMyFollowingResponse::SuccessfulOperation
                => "SuccessfulOperation\n".to_string()
                    ,
            }
        }
        Operation::GetPointsBalance {
            version,
            account_id,
            vatom_user_id,
            vatom_campaign_id,
            return_raw_response,
        } => {
            info!("Performing a GetPointsBalance request on {:?}", (
                &version
            ));

            let result = client.get_points_balance(
                version,
                account_id,
                vatom_user_id,
                vatom_campaign_id,
                return_raw_response,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetPointsBalanceResponse::SuccessfulOperation
                => "SuccessfulOperation\n".to_string()
                    ,
            }
        }
        Operation::GetPointsBalanceAsBusiness {
            version,
            account_id,
            app_key,
            vatom_user_id,
            vatom_campaign_id,
            return_raw_response,
        } => {
            info!("Performing a GetPointsBalanceAsBusiness request on {:?}", (
                &version
            ));

            let result = client.get_points_balance_as_business(
                version,
                account_id,
                app_key,
                vatom_user_id,
                vatom_campaign_id,
                return_raw_response,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetPointsBalanceAsBusinessResponse::SuccessfulOperation
                => "SuccessfulOperation\n".to_string()
                    ,
            }
        }
        Operation::GetSpace {
            version,
            account_id,
            app_key,
            vatom_space_id,
            return_raw_response,
        } => {
            info!("Performing a GetSpace request on {:?}", (
                &version
            ));

            let result = client.get_space(
                version,
                account_id,
                app_key,
                vatom_space_id,
                return_raw_response,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetSpaceResponse::SuccessfulOperation
                => "SuccessfulOperation\n".to_string()
                    ,
            }
        }
        Operation::GetUserCoinsAsBusiness {
            version,
            account_id,
            vatom_user_id,
            app_key,
            return_raw_response,
        } => {
            info!("Performing a GetUserCoinsAsBusiness request on {:?}", (
                &version
            ));

            let result = client.get_user_coins_as_business(
                version,
                account_id,
                vatom_user_id,
                app_key,
                return_raw_response,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetUserCoinsAsBusinessResponse::SuccessfulOperation
                => "SuccessfulOperation\n".to_string()
                    ,
            }
        }
        Operation::GetUserCoinsBalance {
            version,
            account_id,
            vatom_user_id,
            vatom_parameters,
            return_raw_response,
        } => {
            info!("Performing a GetUserCoinsBalance request on {:?}", (
                &version
            ));

            let result = client.get_user_coins_balance(
                version,
                account_id,
                vatom_user_id,
                vatom_parameters,
                return_raw_response,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetUserCoinsBalanceResponse::SuccessfulOperation
                => "SuccessfulOperation\n".to_string()
                    ,
            }
        }
        Operation::GetUserFollowers {
            version,
            account_id,
            vatom_user_id,
            return_raw_response,
        } => {
            info!("Performing a GetUserFollowers request on {:?}", (
                &version
            ));

            let result = client.get_user_followers(
                version,
                account_id,
                vatom_user_id,
                return_raw_response,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetUserFollowersResponse::SuccessfulOperation
                => "SuccessfulOperation\n".to_string()
                    ,
            }
        }
        Operation::GetUserFollowing {
            version,
            account_id,
            vatom_user_id,
            return_raw_response,
        } => {
            info!("Performing a GetUserFollowing request on {:?}", (
                &version
            ));

            let result = client.get_user_following(
                version,
                account_id,
                vatom_user_id,
                return_raw_response,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetUserFollowingResponse::SuccessfulOperation
                => "SuccessfulOperation\n".to_string()
                    ,
            }
        }
        Operation::GetUserInfo {
            version,
            account_id,
            vatom_user_id,
            return_raw_response,
        } => {
            info!("Performing a GetUserInfo request on {:?}", (
                &version
            ));

            let result = client.get_user_info(
                version,
                account_id,
                vatom_user_id,
                return_raw_response,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetUserInfoResponse::SuccessfulOperation
                => "SuccessfulOperation\n".to_string()
                    ,
            }
        }
        Operation::GetUserProfile {
            version,
            account_id,
            return_raw_response,
        } => {
            info!("Performing a GetUserProfile request on {:?}", (
                &version
            ));

            let result = client.get_user_profile(
                version,
                account_id,
                return_raw_response,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetUserProfileResponse::SuccessfulOperation
                => "SuccessfulOperation\n".to_string()
                    ,
            }
        }
        Operation::GetVatomEvent {
            version,
            account_id,
            app_key,
            vatom_event_id,
            return_raw_response,
        } => {
            info!("Performing a GetVatomEvent request on {:?}", (
                &version
            ));

            let result = client.get_vatom_event(
                version,
                account_id,
                app_key,
                vatom_event_id,
                return_raw_response,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetVatomEventResponse::SuccessfulOperation
                => "SuccessfulOperation\n".to_string()
                    ,
            }
        }
        Operation::GetVatomNft {
            version,
            account_id,
            vatom_id,
            return_raw_response,
        } => {
            info!("Performing a GetVatomNft request on {:?}", (
                &version
            ));

            let result = client.get_vatom_nft(
                version,
                account_id,
                vatom_id,
                return_raw_response,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetVatomNftResponse::SuccessfulOperation
                => "SuccessfulOperation\n".to_string()
                    ,
            }
        }
        Operation::ListCommunities {
            version,
            account_id,
            app_key,
            vatom_parameters,
            return_raw_response,
        } => {
            info!("Performing a ListCommunities request on {:?}", (
                &version
            ));

            let result = client.list_communities(
                version,
                account_id,
                app_key,
                vatom_parameters,
                return_raw_response,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                ListCommunitiesResponse::SuccessfulOperation
                => "SuccessfulOperation\n".to_string()
                    ,
            }
        }
        Operation::ListEvents {
            version,
            account_id,
            app_key,
            vatom_parameters,
            return_raw_response,
        } => {
            info!("Performing a ListEvents request on {:?}", (
                &version
            ));

            let result = client.list_events(
                version,
                account_id,
                app_key,
                vatom_parameters,
                return_raw_response,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                ListEventsResponse::SuccessfulOperation
                => "SuccessfulOperation\n".to_string()
                    ,
            }
        }
        Operation::ListSpaces {
            version,
            account_id,
            app_key,
            vatom_parameters,
            return_raw_response,
        } => {
            info!("Performing a ListSpaces request on {:?}", (
                &version
            ));

            let result = client.list_spaces(
                version,
                account_id,
                app_key,
                vatom_parameters,
                return_raw_response,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                ListSpacesResponse::SuccessfulOperation
                => "SuccessfulOperation\n".to_string()
                    ,
            }
        }
        Operation::ListUserCoinTransactions {
            version,
            account_id,
            vatom_user_id,
            vatom_parameters,
            return_raw_response,
        } => {
            info!("Performing a ListUserCoinTransactions request on {:?}", (
                &version
            ));

            let result = client.list_user_coin_transactions(
                version,
                account_id,
                vatom_user_id,
                vatom_parameters,
                return_raw_response,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                ListUserCoinTransactionsResponse::SuccessfulOperation
                => "SuccessfulOperation\n".to_string()
                    ,
            }
        }
        Operation::ListUserCoinTransactionsAsBusiness {
            version,
            account_id,
            vatom_user_id,
            app_key,
            vatom_parameters,
            return_raw_response,
        } => {
            info!("Performing a ListUserCoinTransactionsAsBusiness request on {:?}", (
                &version
            ));

            let result = client.list_user_coin_transactions_as_business(
                version,
                account_id,
                vatom_user_id,
                app_key,
                vatom_parameters,
                return_raw_response,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                ListUserCoinTransactionsAsBusinessResponse::SuccessfulOperation
                => "SuccessfulOperation\n".to_string()
                    ,
            }
        }
        Operation::PerformActionOnNft {
            version,
            account_id,
            vatom_id,
            vatom_action,
            vatom_parameters,
            return_raw_response,
        } => {
            info!("Performing a PerformActionOnNft request on {:?}", (
                &version
            ));

            let result = client.perform_action_on_nft(
                version,
                account_id,
                vatom_id,
                vatom_action,
                vatom_parameters,
                return_raw_response,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                PerformActionOnNftResponse::SuccessfulOperation
                => "SuccessfulOperation\n".to_string()
                    ,
            }
        }
        Operation::RedeemNft {
            version,
            account_id,
            app_key,
            vatom_parameters,
            return_raw_response,
        } => {
            info!("Performing a RedeemNft request on {:?}", (
                &version
            ));

            let result = client.redeem_nft(
                version,
                account_id,
                app_key,
                vatom_parameters,
                return_raw_response,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                RedeemNftResponse::SuccessfulOperation
                => "SuccessfulOperation\n".to_string()
                    ,
            }
        }
        Operation::RedeemUserCoinsAsBusiness {
            version,
            account_id,
            vatom_user_id,
            app_key,
            vatom_parameters,
            return_raw_response,
        } => {
            info!("Performing a RedeemUserCoinsAsBusiness request on {:?}", (
                &version
            ));

            let result = client.redeem_user_coins_as_business(
                version,
                account_id,
                vatom_user_id,
                app_key,
                vatom_parameters,
                return_raw_response,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                RedeemUserCoinsAsBusinessResponse::SuccessfulOperation
                => "SuccessfulOperation\n".to_string()
                    ,
            }
        }
        Operation::SearchBusinesses {
            version,
            account_id,
            vatom_parameters,
            return_raw_response,
        } => {
            info!("Performing a SearchBusinesses request on {:?}", (
                &version
            ));

            let result = client.search_businesses(
                version,
                account_id,
                vatom_parameters,
                return_raw_response,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                SearchBusinessesResponse::SuccessfulOperation
                => "SuccessfulOperation\n".to_string()
                    ,
            }
        }
        Operation::SearchCampaignGroups {
            version,
            account_id,
            app_key,
            return_raw_response,
        } => {
            info!("Performing a SearchCampaignGroups request on {:?}", (
                &version
            ));

            let result = client.search_campaign_groups(
                version,
                account_id,
                app_key,
                return_raw_response,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                SearchCampaignGroupsResponse::SuccessfulOperation
                => "SuccessfulOperation\n".to_string()
                    ,
            }
        }
        Operation::SearchIdentities {
            version,
            account_id,
            return_raw_response,
        } => {
            info!("Performing a SearchIdentities request on {:?}", (
                &version
            ));

            let result = client.search_identities(
                version,
                account_id,
                return_raw_response,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                SearchIdentitiesResponse::SuccessfulOperation
                => "SuccessfulOperation\n".to_string()
                    ,
            }
        }
        Operation::SearchInventory {
            version,
            account_id,
            vatom_parameters,
            return_raw_response,
        } => {
            info!("Performing a SearchInventory request on {:?}", (
                &version
            ));

            let result = client.search_inventory(
                version,
                account_id,
                vatom_parameters,
                return_raw_response,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                SearchInventoryResponse::SuccessfulOperation
                => "SuccessfulOperation\n".to_string()
                    ,
            }
        }
        Operation::SendNft {
            version,
            account_id,
            app_key,
            vatom_campaign_id,
            vatom_parameters,
            return_raw_response,
        } => {
            info!("Performing a SendNft request on {:?}", (
                &version
            ));

            let result = client.send_nft(
                version,
                account_id,
                app_key,
                vatom_campaign_id,
                vatom_parameters,
                return_raw_response,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                SendNftResponse::SuccessfulOperation
                => "SuccessfulOperation\n".to_string()
                    ,
            }
        }
        Operation::SetPointsBalanceAsBusiness {
            version,
            account_id,
            app_key,
            vatom_user_id,
            vatom_campaign_id,
            vatom_parameters,
            return_raw_response,
        } => {
            info!("Performing a SetPointsBalanceAsBusiness request on {:?}", (
                &version
            ));

            let result = client.set_points_balance_as_business(
                version,
                account_id,
                app_key,
                vatom_user_id,
                vatom_campaign_id,
                vatom_parameters,
                return_raw_response,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                SetPointsBalanceAsBusinessResponse::SuccessfulOperation
                => "SuccessfulOperation\n".to_string()
                    ,
            }
        }
        Operation::TransferUserCoins {
            version,
            account_id,
            vatom_user_id,
            vatom_parameters,
            return_raw_response,
        } => {
            info!("Performing a TransferUserCoins request on {:?}", (
                &version
            ));

            let result = client.transfer_user_coins(
                version,
                account_id,
                vatom_user_id,
                vatom_parameters,
                return_raw_response,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                TransferUserCoinsResponse::SuccessfulOperation
                => "SuccessfulOperation\n".to_string()
                    ,
            }
        }
        Operation::UpdateBusinessCoins {
            version,
            account_id,
            app_key,
            vatom_parameters,
            return_raw_response,
        } => {
            info!("Performing a UpdateBusinessCoins request on {:?}", (
                &version
            ));

            let result = client.update_business_coins(
                version,
                account_id,
                app_key,
                vatom_parameters,
                return_raw_response,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                UpdateBusinessCoinsResponse::SuccessfulOperation
                => "SuccessfulOperation\n".to_string()
                    ,
            }
        }
        Operation::UpdateEventGuestList {
            version,
            account_id,
            app_key,
            vatom_event_id,
            vatom_parameters,
            return_raw_response,
        } => {
            info!("Performing a UpdateEventGuestList request on {:?}", (
                &version
            ));

            let result = client.update_event_guest_list(
                version,
                account_id,
                app_key,
                vatom_event_id,
                vatom_parameters,
                return_raw_response,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                UpdateEventGuestListResponse::SuccessfulOperation
                => "SuccessfulOperation\n".to_string()
                    ,
            }
        }
        Operation::UpdateSpace {
            version,
            account_id,
            app_key,
            vatom_space_id,
            vatom_parameters,
            return_raw_response,
        } => {
            info!("Performing a UpdateSpace request on {:?}", (
                &version
            ));

            let result = client.update_space(
                version,
                account_id,
                app_key,
                vatom_space_id,
                vatom_parameters,
                return_raw_response,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                UpdateSpaceResponse::SuccessfulOperation
                => "SuccessfulOperation\n".to_string()
                    ,
            }
        }
        Operation::UpdateUserCoinsAsBusiness {
            version,
            account_id,
            vatom_user_id,
            app_key,
            vatom_parameters,
            return_raw_response,
        } => {
            info!("Performing a UpdateUserCoinsAsBusiness request on {:?}", (
                &version
            ));

            let result = client.update_user_coins_as_business(
                version,
                account_id,
                vatom_user_id,
                app_key,
                vatom_parameters,
                return_raw_response,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                UpdateUserCoinsAsBusinessResponse::SuccessfulOperation
                => "SuccessfulOperation\n".to_string()
                    ,
            }
        }
        Operation::UpdateUserProfile {
            version,
            account_id,
            vatom_parameters,
            return_raw_response,
        } => {
            info!("Performing a UpdateUserProfile request on {:?}", (
                &version
            ));

            let result = client.update_user_profile(
                version,
                account_id,
                vatom_parameters,
                return_raw_response,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                UpdateUserProfileResponse::SuccessfulOperation
                => "SuccessfulOperation\n".to_string()
                    ,
            }
        }
        Operation::UpdateVatomEvent {
            version,
            account_id,
            app_key,
            vatom_event_id,
            vatom_parameters,
            return_raw_response,
        } => {
            info!("Performing a UpdateVatomEvent request on {:?}", (
                &version
            ));

            let result = client.update_vatom_event(
                version,
                account_id,
                app_key,
                vatom_event_id,
                vatom_parameters,
                return_raw_response,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                UpdateVatomEventResponse::SuccessfulOperation
                => "SuccessfulOperation\n".to_string()
                    ,
            }
        }
        Operation::CreateVehicle {
            version,
            vehicle,
            body,
        } => {
            info!("Performing a CreateVehicle request on {:?}", (
                &version
            ));

            let result = client.create_vehicle(
                version,
                vehicle,
                body,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                CreateVehicleResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::SearchVehicle {
            version,
            hub_id,
            sort_field,
            descending,
            start,
            limit,
            active_only,
            keyword,
        } => {
            info!("Performing a SearchVehicle request on {:?}", (
                &version
            ));

            let result = client.search_vehicle(
                version,
                hub_id,
                sort_field,
                descending,
                start,
                limit,
                active_only,
                keyword,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                SearchVehicleResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::DeleteVehicle {
            version,
            id,
        } => {
            prompt(args.force, "This will delete the given entry, are you sure?")?;
            info!("Performing a DeleteVehicle request on {:?}", (
                &version,
                &id
            ));

            let result = client.delete_vehicle(
                version,
                id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                DeleteVehicleResponse::SuccessfulOperation
                => "SuccessfulOperation\n".to_string()
                    ,
            }
        }
        Operation::GetVehicle {
            version,
            id,
        } => {
            info!("Performing a GetVehicle request on {:?}", (
                &version,
                &id
            ));

            let result = client.get_vehicle(
                version,
                id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetVehicleResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::UpdateVehicle {
            version,
            id,
            vehicle,
            body,
        } => {
            info!("Performing a UpdateVehicle request on {:?}", (
                &version,
                &id
            ));

            let result = client.update_vehicle(
                version,
                id,
                vehicle,
                body,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                UpdateVehicleResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::CreateVehicleType {
            version,
            vehicle_type,
            body,
        } => {
            info!("Performing a CreateVehicleType request on {:?}", (
                &version
            ));

            let result = client.create_vehicle_type(
                version,
                vehicle_type,
                body,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                CreateVehicleTypeResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::SearchVehicleTypes {
            version,
            sort_field,
            descending,
            start,
            limit,
            active_only,
            retailer_id,
            hub_id,
        } => {
            info!("Performing a SearchVehicleTypes request on {:?}", (
                &version
            ));

            let result = client.search_vehicle_types(
                version,
                sort_field,
                descending,
                start,
                limit,
                active_only,
                retailer_id,
                hub_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                SearchVehicleTypesResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::DeleteVehicleType {
            version,
            vehicle_type_id,
        } => {
            prompt(args.force, "This will delete the given entry, are you sure?")?;
            info!("Performing a DeleteVehicleType request on {:?}", (
                &version,
                &vehicle_type_id
            ));

            let result = client.delete_vehicle_type(
                version,
                vehicle_type_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                DeleteVehicleTypeResponse::SuccessfulOperation
                => "SuccessfulOperation\n".to_string()
                    ,
            }
        }
        Operation::GetVehicleType {
            version,
            vehicle_type_id,
        } => {
            info!("Performing a GetVehicleType request on {:?}", (
                &version,
                &vehicle_type_id
            ));

            let result = client.get_vehicle_type(
                version,
                vehicle_type_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetVehicleTypeResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::UpdateVehicleType {
            version,
            vehicle_type_id,
            vehicle_type,
            body,
        } => {
            info!("Performing a UpdateVehicleType request on {:?}", (
                &version,
                &vehicle_type_id
            ));

            let result = client.update_vehicle_type(
                version,
                vehicle_type_id,
                vehicle_type,
                body,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                UpdateVehicleTypeResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::CreateOfferTransaction {
            version,
            device_id,
            account_id,
            offer_id,
            offer_location_id,
            offer_cart,
            promo_code,
            currency_type,
            use_points,
            meta_data,
            app_key,
            status,
        } => {
            info!("Performing a CreateOfferTransaction request on {:?}", (
                &version
            ));

            let result = client.create_offer_transaction(
                version,
                device_id,
                account_id,
                offer_id,
                offer_location_id,
                offer_cart,
                promo_code,
                currency_type,
                use_points,
                meta_data,
                app_key,
                status,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                CreateOfferTransactionResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::DeleteOfferTransaction {
            version,
            transaction_id,
            device_id,
            account_id,
        } => {
            info!("Performing a DeleteOfferTransaction request on {:?}", (
                &version
            ));

            let result = client.delete_offer_transaction(
                version,
                transaction_id,
                device_id,
                account_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                DeleteOfferTransactionResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetOfferTransaction {
            version,
            transaction_id,
            device_id,
            account_id,
            include_mission,
            latitude,
            longitude,
            return_full_response,
        } => {
            info!("Performing a GetOfferTransaction request on {:?}", (
                &version
            ));

            let result = client.get_offer_transaction(
                version,
                transaction_id,
                device_id,
                account_id,
                include_mission,
                latitude,
                longitude,
                return_full_response,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetOfferTransactionResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::PreviewOfferTransaction {
            version,
            device_id,
            account_id,
            offer_id,
            offer_location_id,
            offer_cart,
            promo_code,
            currency_type,
            use_points,
            meta_data,
            app_key,
        } => {
            info!("Performing a PreviewOfferTransaction request on {:?}", (
                &version
            ));

            let result = client.preview_offer_transaction(
                version,
                device_id,
                account_id,
                offer_id,
                offer_location_id,
                offer_cart,
                promo_code,
                currency_type,
                use_points,
                meta_data,
                app_key,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                PreviewOfferTransactionResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::SearchOfferTransactions {
            version,
            device_id,
            account_id,
            keyword,
            retailer_id,
            retailer_ids,
            retailer_location_id,
            retailer_location_ids,
            exclude_retailer_location_ids,
            offer_id,
            offer_ids,
            offer_location_id,
            offer_location_ids,
            offer_type,
            offer_types,
            special_offer_type,
            special_offer_types,
            category_ids,
            filter_ids,
            offer_audience_ids,
            sort_field,
            descending,
            start,
            limit,
            latitude,
            longitude,
            redeemable_start_date,
            redeemable_end_date,
            filter_by_parent_offer,
            started_since,
            started_before,
            ended_since,
            ended_before,
            redeemed,
            statuses,
            reservations_only,
            active_only,
            return_full_response,
            recurring_started_since,
            recurring_started_before,
            recurring_expiration_since,
            recurring_expiration_before,
        } => {
            info!("Performing a SearchOfferTransactions request on {:?}", (
                &version
            ));

            let result = client.search_offer_transactions(
                version,
                device_id,
                account_id,
                keyword,
                retailer_id,
                retailer_ids,
                retailer_location_id,
                retailer_location_ids,
                exclude_retailer_location_ids,
                offer_id,
                offer_ids,
                offer_location_id,
                offer_location_ids,
                offer_type,
                offer_types,
                special_offer_type,
                special_offer_types,
                category_ids,
                filter_ids,
                offer_audience_ids,
                sort_field,
                descending,
                start,
                limit,
                latitude,
                longitude,
                redeemable_start_date,
                redeemable_end_date,
                filter_by_parent_offer,
                started_since,
                started_before,
                ended_since,
                ended_before,
                redeemed,
                statuses,
                reservations_only,
                active_only,
                return_full_response,
                recurring_started_since,
                recurring_started_before,
                recurring_expiration_since,
                recurring_expiration_before,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                SearchOfferTransactionsResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::UpdateOfferTransaction {
            version,
            transaction_id,
            status,
            device_id,
            account_id,
            offer_location_id,
            currency_type,
            use_points,
            app_key,
            latitude,
            longitude,
            meta_data,
            return_full_response,
            exception_membership_offer_ids,
        } => {
            info!("Performing a UpdateOfferTransaction request on {:?}", (
                &version
            ));

            let result = client.update_offer_transaction(
                version,
                transaction_id,
                status,
                device_id,
                account_id,
                offer_location_id,
                currency_type,
                use_points,
                app_key,
                latitude,
                longitude,
                meta_data,
                return_full_response,
                exception_membership_offer_ids,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                UpdateOfferTransactionResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::SearchWeather {
            version,
            region_id,
            latitude,
            longitude,
            timezone_offset,
        } => {
            info!("Performing a SearchWeather request on {:?}", (
                &version
            ));

            let result = client.search_weather(
                version,
                region_id,
                latitude,
                longitude,
                timezone_offset,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                SearchWeatherResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::CreateWord {
            version,
            account_id,
            word,
            definition,
            active,
            allocate_tickets,
            ticket_count,
            asset_id,
            ticket_type,
            points,
        } => {
            info!("Performing a CreateWord request on {:?}", (
                &version
            ));

            let result = client.create_word(
                version,
                account_id,
                word,
                definition,
                active,
                allocate_tickets,
                ticket_count,
                asset_id,
                ticket_type,
                points,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                CreateWordResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::DeleteWord {
            version,
            word_id,
            account_id,
        } => {
            prompt(args.force, "This will delete the given entry, are you sure?")?;
            info!("Performing a DeleteWord request on {:?}", (
                &version
            ));

            let result = client.delete_word(
                version,
                word_id,
                account_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                DeleteWordResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetWord {
            version,
            word_id,
            account_id,
        } => {
            info!("Performing a GetWord request on {:?}", (
                &version
            ));

            let result = client.get_word(
                version,
                word_id,
                account_id,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetWordResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::GetWords {
            version,
            account_id,
            sort_field,
            descending,
            active_only,
            start,
            limit,
            keyword,
        } => {
            info!("Performing a GetWords request on {:?}", (
                &version
            ));

            let result = client.get_words(
                version,
                account_id,
                sort_field,
                descending,
                active_only,
                start,
                limit,
                keyword,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                GetWordsResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::UpdateWord {
            version,
            word_id,
            account_id,
            ticket_count,
            word_text,
            definition,
            asset_id,
            active,
            allocate_tickets,
            ticket_type,
            points,
        } => {
            info!("Performing a UpdateWord request on {:?}", (
                &version
            ));

            let result = client.update_word(
                version,
                word_id,
                account_id,
                ticket_count,
                word_text,
                definition,
                asset_id,
                active,
                allocate_tickets,
                ticket_type,
                points,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                UpdateWordResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
        Operation::RunWorkflow {
            version,
            account_id,
            workflow_id,
            sku_id,
            version_code,
            parameters,
        } => {
            info!("Performing a RunWorkflow request on {:?}", (
                &version
            ));

            let result = client.run_workflow(
                version,
                account_id,
                workflow_id,
                sku_id,
                version_code,
                parameters,
            ).await?;
            debug!("Result: {:?}", result);

            match result {
                RunWorkflowResponse::SuccessfulOperation
                (body)
                => "SuccessfulOperation\n".to_string()
                   +
                    &serde_json::to_string_pretty(&body)?,
            }
        }
    };

    if let Some(output_file) = args.output_file {
        std::fs::write(output_file, result)?
    } else {
        println!("{}", result);
    }
    Ok(())
}

fn prompt(force: bool, text: &str) -> Result<()> {
    if force || Confirm::new().with_prompt(text).interact()? {
        Ok(())
    } else {
        Err(anyhow!("Aborting"))
    }
}

// May be unused if all inputs are primitive types
#[allow(dead_code)]
fn parse_json<T: serde::de::DeserializeOwned>(json_string: &str) -> Result<T> {
    serde_json::from_str(json_string).map_err(|err| anyhow!("Error parsing input: {}", err))
}
