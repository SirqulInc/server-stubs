package org.openapitools.api

import org.openapitools.model.Account
import org.openapitools.model.AccountListResponse
import org.openapitools.model.AccountLoginResponse
import org.openapitools.model.AccountMiniResponse
import org.openapitools.model.AccountResponse
import org.openapitools.model.AchievementProgressResponse
import org.openapitools.model.AchievementResponse
import org.openapitools.model.AchievementShortResponse
import org.openapitools.model.AchievementTierResponse
import org.openapitools.model.ActivityResponse
import org.openapitools.model.AgeGroupResponse
import org.openapitools.model.AlbumContestListResponse
import org.openapitools.model.AlbumContestResponse
import org.openapitools.model.AlbumFullResponse
import org.openapitools.model.AlbumResponse
import org.openapitools.model.AppResponse
import org.openapitools.model.ApplicationConfigResponse
import org.openapitools.model.ApplicationResponse
import org.openapitools.model.ApplicationSettingsResponse
import org.openapitools.model.ApplicationShortResponse
import org.openapitools.model.ApplicationUsageResponse
import org.openapitools.model.AssetFullResponse
import org.openapitools.model.AssetListResponse
import org.openapitools.model.AssetResponse
import org.openapitools.model.AssetShortResponse
import org.openapitools.model.AssignmentResponse
import org.openapitools.model.AssignmentStatusResponse
import org.openapitools.model.AudienceDeviceResponse
import org.openapitools.model.AudienceResponse
import org.openapitools.model.AvailabilityResponse
import org.openapitools.model.BidResponse
import org.openapitools.model.BillableEntityResponse
import org.openapitools.model.BlockedNotificationResponse
import org.openapitools.model.CargoType
import org.openapitools.model.CategoryResponse
import org.openapitools.model.CategoryTreeResponse
import org.openapitools.model.CellCarrierResponse
import org.openapitools.model.ChartData
import org.openapitools.model.ConnectionGroupResponse
import org.openapitools.model.ConnectionInfoResponse
import org.openapitools.model.ConnectionListResponse
import org.openapitools.model.ConnectionResponse
import org.openapitools.model.ConsumerInviteResponse
import org.openapitools.model.CoordsResponse
import org.openapitools.model.CountResponse
import org.openapitools.model.CreativeResponse
import org.openapitools.model.CsvImportResponse
import org.openapitools.model.Direction
import org.openapitools.model.DisbursementResponse
import org.openapitools.model.EmployeeResponse
import org.openapitools.model.EntityReference
import org.openapitools.model.EventAttendanceResponse
import org.openapitools.model.FilterResponse
import org.openapitools.model.FilterTreeResponse
import org.openapitools.model.FlagResponse
import org.openapitools.model.GameLevelListResponse
import org.openapitools.model.GameLevelResponse
import org.openapitools.model.GameResponse
import org.openapitools.model.GeoPointResponse
import org.openapitools.model.ImportStatuses
import org.openapitools.model.InviteResponse
import org.openapitools.model.LeaderboardResponse
import org.openapitools.model.Leg
import org.openapitools.model.LegResponse
import org.openapitools.model.LikableResponse
import org.openapitools.model.ListCountResponse
import org.openapitools.model.ListingFullResponse
import org.openapitools.model.ListingGroupResponse
import org.openapitools.model.ListingResponse
import org.openapitools.model.Location
import org.openapitools.model.LocationSearchResponse
import org.openapitools.model.MediaOfferResponse
import org.openapitools.model.MissionFormatResponse
import org.openapitools.model.MissionResponse
import org.openapitools.model.MissionShortResponse
import org.openapitools.model.NoteResponse
import org.openapitools.model.NotificationMessageListResponse
import org.openapitools.model.NotificationRecipientResponse
import org.openapitools.model.NotificationRecipientResponseListResponse
import org.openapitools.model.NotificationTemplateResponse
import org.openapitools.model.ObjectStoreResponse
import org.openapitools.model.OfferListResponse
import org.openapitools.model.OfferResponse
import org.openapitools.model.OfferShortResponse
import org.openapitools.model.OfferTransactionResponse
import org.openapitools.model.OfferTransactionStatusResponse
import org.openapitools.model.OrderResponse
import org.openapitools.model.Orders
import org.openapitools.model.OrsonAiAddMovieResponse
import org.openapitools.model.OrsonAiBatchResponse
import org.openapitools.model.OrsonAiEmotionsResponse
import org.openapitools.model.OrsonAiProtoResponse
import org.openapitools.model.OrsonAiSTTResponse
import org.openapitools.model.OrsonAiTTSResponse
import org.openapitools.model.OrsonAiTechTuneResponse
import org.openapitools.model.OrsonAiTopicsResponse
import org.openapitools.model.OrsonAiVoiceCanvasResponse
import org.openapitools.model.OrsonEpisodeResponse
import org.openapitools.model.OrsonRenderResponse
import org.openapitools.model.PackResponse
import org.openapitools.model.PathingResponse
import org.openapitools.model.PaymentRequest
import org.openapitools.model.PaymentTypesResponse
import org.openapitools.model.PlacementResponse
import org.openapitools.model.PostalCodeResponse
import org.openapitools.model.PredictedLocationResponse
import org.openapitools.model.PreferredLocationResponse
import org.openapitools.model.PreviewPersonaResponse
import org.openapitools.model.ProfileInfoResponse
import org.openapitools.model.ProfileResponse
import org.openapitools.model.Program
import org.openapitools.model.PurchaseItemFullResponse
import org.openapitools.model.PurchaseItemListResponse
import org.openapitools.model.PurchaseItemResponse
import org.openapitools.model.QuestionResponse
import org.openapitools.model.QueueResponse
import org.openapitools.model.RankFullResponse
import org.openapitools.model.RatingIndexResponse
import org.openapitools.model.RatingResponse
import org.openapitools.model.RegionLegSummary
import org.openapitools.model.RegionResponse
import org.openapitools.model.ReportBatchResponse
import org.openapitools.model.ReportRegionLegSummaryBatchResponse
import org.openapitools.model.ReportResponse
import org.openapitools.model.ReservationResponse
import org.openapitools.model.RetailerFullResponse
import org.openapitools.model.RetailerLocationResponse
import org.openapitools.model.RetailerOfferResponse
import org.openapitools.model.RetailerResponse
import org.openapitools.model.Route
import org.openapitools.model.RouteSettings
import org.openapitools.model.RoutingListResponse
import org.openapitools.model.ScheduledNotificationFullResponse
import org.openapitools.model.ScoreResponse
import org.openapitools.model.SearchResponse
import org.openapitools.model.ServiceHub
import org.openapitools.model.Shipment
import org.openapitools.model.ShipmentBatch
import org.openapitools.model.ShipmentImportStatus
import org.openapitools.model.ShipmentOrder
import org.openapitools.model.SirqulResponse
import org.openapitools.model.StepResponse
import org.openapitools.model.Stop
import org.openapitools.model.SubscriptionPlanResponse
import org.openapitools.model.SubscriptionResponse
import org.openapitools.model.TaskResponse
import org.openapitools.model.TerritoryResponse
import org.openapitools.model.ThemeDescriptorResponse
import org.openapitools.model.ThirdPartyCredentialResponse
import org.openapitools.model.ThirdPartyNetworkResponse
import org.openapitools.model.ThirdPartyNetworkShortResponse
import org.openapitools.model.TicketListResponse
import org.openapitools.model.TicketOfferResponse
import org.openapitools.model.TimeSlotResponse
import org.openapitools.model.TokenResponse
import org.openapitools.model.TournamentResponse
import org.openapitools.model.TriggerResponse
import org.openapitools.model.TrilatCacheRequest
import org.openapitools.model.Trip
import org.openapitools.model.TwiMLResponse
import org.openapitools.model.UserActivityResponse
import org.openapitools.model.UserLocationSearchResponse
import org.openapitools.model.UserPermissionsResponse
import org.openapitools.model.UserSettingsResponse
import org.openapitools.model.Vehicle
import org.openapitools.model.VehicleType
import org.openapitools.model.WeatherResponse
import org.openapitools.model.WordzWordResponse
import org.openapitools.model.WrappedProxyItemResponse
import org.openapitools.model.WrappedResponse
import io.swagger.v3.oas.annotations.*
import io.swagger.v3.oas.annotations.enums.*
import io.swagger.v3.oas.annotations.media.*
import io.swagger.v3.oas.annotations.responses.*
import io.swagger.v3.oas.annotations.security.*
import org.springframework.http.HttpStatus
import org.springframework.http.MediaType
import org.springframework.http.ResponseEntity

import org.springframework.web.bind.annotation.*
import org.springframework.validation.annotation.Validated
import org.springframework.web.context.request.NativeWebRequest
import org.springframework.beans.factory.annotation.Autowired

import javax.validation.Valid
import javax.validation.constraints.DecimalMax
import javax.validation.constraints.DecimalMin
import javax.validation.constraints.Email
import javax.validation.constraints.Max
import javax.validation.constraints.Min
import javax.validation.constraints.NotNull
import javax.validation.constraints.Pattern
import javax.validation.constraints.Size

import kotlin.collections.List
import kotlin.collections.Map

@RestController
@Validated
@RequestMapping("\${api.base-path:}")
class ApiApiController() {

    @Operation(
        summary = "Accept Invite",
        operationId = "acceptInvite",
        description = """Allows a user to accept an invite. The user could also become the inviter's friend.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = ConsumerInviteResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/invite/accept"
        value = [PATH_ACCEPT_INVITE],
        produces = ["*/*"]
    )
    fun acceptInvite(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the invite token", required = true) @Valid @RequestParam(value = "token", required = true) token: kotlin.String,
        @NotNull @Parameter(description = "the accountId of the user who is accepting the invite", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @Parameter(description = "the album id associated with this invite (if applicable)") @Valid @RequestParam(value = "albumId", required = false) albumId: kotlin.Long?,
        @Parameter(description = "the mission id associated with this invite (if applicable)") @Valid @RequestParam(value = "missionId", required = false) missionId: kotlin.Long?,
        @Parameter(description = "the album contest id associated with this invite (if applicable)") @Valid @RequestParam(value = "albumContestId", required = false) albumContestId: kotlin.Long?,
        @Parameter(description = "the offer id associated with this invite (if applicable)") @Valid @RequestParam(value = "offerId", required = false) offerId: kotlin.Long?,
        @Parameter(description = "the offer location id associated with this invite (if applicable)") @Valid @RequestParam(value = "offerLocationId", required = false) offerLocationId: kotlin.Long?,
        @Parameter(description = "the retailer location id associated with this invite (if applicable)") @Valid @RequestParam(value = "retailerLocationId", required = false) retailerLocationId: kotlin.Long?,
        @Parameter(description = "the application key") @Valid @RequestParam(value = "appKey", required = false) appKey: kotlin.String?,
        @Parameter(description = "whether to auto-friend the invite sender and receiver", schema = Schema(defaultValue = "true")) @Valid @RequestParam(value = "autoFriend", required = false, defaultValue = "true") autoFriend: kotlin.Boolean,
        @Parameter(description = "whether to mark the event as attending automatically after invite is accepted", schema = Schema(defaultValue = "false")) @Valid @RequestParam(value = "autoAttendEvent", required = false, defaultValue = "false") autoAttendEvent: kotlin.Boolean,
        @Parameter(description = "whether to mark the offer as favorited automatically after invite is accepted", schema = Schema(defaultValue = "false")) @Valid @RequestParam(value = "autoFavoriteOffer", required = false, defaultValue = "false") autoFavoriteOffer: kotlin.Boolean,
        @Parameter(description = "whether to mark the offer location as favorited automatically after invite is accepted", schema = Schema(defaultValue = "false")) @Valid @RequestParam(value = "autoFavoriteOfferLocation", required = false, defaultValue = "false") autoFavoriteOfferLocation: kotlin.Boolean,
        @Parameter(description = "whether to mark the retailer location as favorited automatically after invite is accepted", schema = Schema(defaultValue = "false")) @Valid @RequestParam(value = "autoFavoriteRetailerLocation", required = false, defaultValue = "false") autoFavoriteRetailerLocation: kotlin.Boolean
    ): ResponseEntity<ConsumerInviteResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Search Accounts by Location",
        operationId = "accountLocationSearch",
        description = """Search accounts by their location. This only searches on users that have location data. Use ConnectionApi to perform a regular search on accounts.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = UserLocationSearchResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/account/search"
        value = [PATH_ACCOUNT_LOCATION_SEARCH],
        produces = ["*/*"]
    )
    fun accountLocationSearch(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "The device id (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "The account id of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "Deprecated - legacy query parameter") @Valid @RequestParam(value = "q", required = false) q: kotlin.String?,
        @Parameter(description = "An optional keyword to search on, will be ignore if empty (NOT implemented yet)") @Valid @RequestParam(value = "keyword", required = false) keyword: kotlin.String?,
        @Parameter(description = "The postal code to search on, either postalCode or the user's exact location is required") @Valid @RequestParam(value = "postalCode", required = false) postalCode: kotlin.String?,
        @Parameter(description = "The latitude of the user, either postalCode or the user's exact location is required") @Valid @RequestParam(value = "latitude", required = false) latitude: kotlin.Double?,
        @Parameter(description = "The longitude of the user, either postalCode or the user's exact location is required") @Valid @RequestParam(value = "longitude", required = false) longitude: kotlin.Double?,
        @Parameter(description = "The application key") @Valid @RequestParam(value = "appKey", required = false) appKey: kotlin.String?,
        @Parameter(description = "The range to search on", schema = Schema(defaultValue = "10.0")) @Valid @RequestParam(value = "range", required = false, defaultValue = "10.0") range: kotlin.Double,
        @Parameter(description = "Searches for user's that has updated their location since this date") @Valid @RequestParam(value = "locationLastUpdated", required = false) locationLastUpdated: kotlin.Long?,
        @Parameter(description = "The preferred gender") @Valid @RequestParam(value = "gender", required = false) gender: kotlin.String?,
        @Parameter(description = "The preferred min age") @Valid @RequestParam(value = "minAge", required = false) minAge: kotlin.Int?,
        @Parameter(description = "The preferred max age") @Valid @RequestParam(value = "maxAge", required = false) maxAge: kotlin.Int?,
        @Parameter(description = "The preferred companionship index") @Valid @RequestParam(value = "companionshipIndex", required = false) companionshipIndex: kotlin.Int?,
        @Parameter(description = "this is the start index of a query") @Valid @RequestParam(value = "_i", required = false) i: kotlin.Int?,
        @Parameter(description = "Start of the pagination", schema = Schema(defaultValue = "0")) @Valid @RequestParam(value = "start", required = false, defaultValue = "0") start: kotlin.Int,
        @Parameter(description = "this is the limit index of a query") @Valid @RequestParam(value = "_l", required = false) l: kotlin.Int?,
        @Parameter(description = "Limit of the pagination", schema = Schema(defaultValue = "100")) @Valid @RequestParam(value = "limit", required = false, defaultValue = "100") limit: kotlin.Int,
        @Parameter(description = "Search mode to use for index searches (e.g. CLOUDINDEX, OPENSEARCH)") @Valid @RequestParam(value = "searchMode", required = false) searchMode: kotlin.String?,
        @Parameter(description = "Sorting field for results (default: DISTANCE)") @Valid @RequestParam(value = "sortField", required = false) sortField: kotlin.String?,
        @Parameter(description = "Whether to sort descending (default: false)") @Valid @RequestParam(value = "descending", required = false) descending: kotlin.Boolean?,
        @Parameter(description = "Roles to filter on") @Valid @RequestParam(value = "roles", required = false) roles: kotlin.String?,
        @Parameter(description = "Tags to filter on") @Valid @RequestParam(value = "tags", required = false) tags: kotlin.String?,
        @Parameter(description = "The experience to filter on") @Valid @RequestParam(value = "experience", required = false) experience: kotlin.String?,
        @Parameter(description = "The category ids to filter on (comma separated)") @Valid @RequestParam(value = "categoryIds", required = false) categoryIds: kotlin.String?,
        @Parameter(description = "The audience ids to filter on (comma separated)") @Valid @RequestParam(value = "audienceIds", required = false) audienceIds: kotlin.String?,
        @Parameter(description = "Operator used to combine audience filters (default: AND)", schema = Schema(defaultValue = "AND")) @Valid @RequestParam(value = "audienceOperator", required = false, defaultValue = "AND") audienceOperator: kotlin.String,
        @Parameter(description = "Whether to use the given lat & long to update the user's current location", schema = Schema(defaultValue = "false")) @Valid @RequestParam(value = "updateCurrentLocation", required = false, defaultValue = "false") updateCurrentLocation: kotlin.Boolean,
        @Parameter(description = "Whether to use the given parameters to update the user's preferred settings", schema = Schema(defaultValue = "false")) @Valid @RequestParam(value = "updatePreferredSettings", required = false, defaultValue = "false") updatePreferredSettings: kotlin.Boolean,
        @Parameter(description = "Determines whether to always display user exact locations", schema = Schema(defaultValue = "true")) @Valid @RequestParam(value = "showExactLocations", required = false, defaultValue = "true") showExactLocations: kotlin.Boolean,
        @Parameter(description = "Return connection of the accounts in the result to the passed in account if there exists any", schema = Schema(defaultValue = "false")) @Valid @RequestParam(value = "showConnectionToSearcher", required = false, defaultValue = "false") showConnectionToSearcher: kotlin.Boolean,
        @Parameter(description = "Return any results that have a minimum of the specified flag count (even ones that have met the flag threshold)") @Valid @RequestParam(value = "flagCountMinimum", required = false) flagCountMinimum: kotlin.Long?,
        @Parameter(description = "Returns only verified users") @Valid @RequestParam(value = "verifiedUserOnly", required = false) verifiedUserOnly: kotlin.Boolean?,
        @Parameter(description = "Returns only content admin users") @Valid @RequestParam(value = "contentAdminOnly", required = false) contentAdminOnly: kotlin.Boolean?
    ): ResponseEntity<UserLocationSearchResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get User Activity",
        operationId = "activities",
        description = """Get an activity feed by user.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(array = ArraySchema(schema = Schema(implementation = UserActivityResponse::class)))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/analytics/useractivity"
        value = [PATH_ACTIVITIES],
        produces = ["*/*"]
    )
    fun activities(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The start of the pagination", required = true) @Valid @RequestParam(value = "start", required = true) start: kotlin.Int,
        @NotNull @Parameter(description = "The limit of the pagination", required = true) @Valid @RequestParam(value = "limit", required = true) limit: kotlin.Int,
        @NotNull @Parameter(description = "the account id of the user", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long
    ): ResponseEntity<List<UserActivityResponse>> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Create Album",
        operationId = "addAlbumCollection",
        description = """Create an Album.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SearchResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/album/create"
        value = [PATH_ADD_ALBUM_COLLECTION],
        produces = ["*/*"]
    )
    fun addAlbumCollection(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the title of the album", required = true) @Valid @RequestParam(value = "title", required = true) title: kotlin.String,
        @NotNull @Parameter(description = "determines whether the cover image of the album can be empty, else will use the user's profile picture as the cover image", required = true) @Valid @RequestParam(value = "coverAssetNullable", required = true) coverAssetNullable: kotlin.Boolean,
        @NotNull @Parameter(description = "determines whether the cover image should be added to the album asset list", required = true) @Valid @RequestParam(value = "includeCoverInAssetList", required = true) includeCoverInAssetList: kotlin.Boolean,
        @NotNull @Parameter(description = "determines whether the album's participants has read permissions", required = true) @Valid @RequestParam(value = "publicRead", required = true) publicRead: kotlin.Boolean,
        @NotNull @Parameter(description = "determines whether the album's participants has write permissions", required = true) @Valid @RequestParam(value = "publicWrite", required = true) publicWrite: kotlin.Boolean,
        @NotNull @Parameter(description = "determines whether the album's participants has delete permissions", required = true) @Valid @RequestParam(value = "publicDelete", required = true) publicDelete: kotlin.Boolean,
        @NotNull @Parameter(description = "determines whether the album's participants has add permissions", required = true) @Valid @RequestParam(value = "publicAdd", required = true) publicAdd: kotlin.Boolean,
        @NotNull @Parameter(description = "determines whether the album is posted anonymously", required = true) @Valid @RequestParam(value = "anonymous", required = true) anonymous: kotlin.Boolean,
        @Parameter(description = "a unique ID given by the device (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "the account ID of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "Comma separated list of asset IDs to add to the album's asset list (use \"assetId\" for setting the cover of the album)") @Valid @RequestParam(value = "assetsToAdd", required = false) assetsToAdd: kotlin.String?,
        @Parameter(description = "a MultipartFile containing the cover image of the album (this will only be used if \"assetId\" is empty)") @Valid @RequestParam(value = "media", required = false) media: org.springframework.web.multipart.MultipartFile,
        @Parameter(description = "this can be used if the \"media\" is a link (this will only be used if \"assetId\" and media are empty)") @Valid @RequestParam(value = "mediaURL", required = false) mediaURL: kotlin.String?,
        @Parameter(description = "The asset ID to set the album cover image") @Valid @RequestParam(value = "assetId", required = false) assetId: kotlin.Long?,
        @Parameter(description = "a MultipartFile containing an asset that the \"media\" file references. Example to upload a video: the \"media\" file should contain a screen capture of the video, and the \"attachedMedia\" should be the actual video.") @Valid @RequestParam(value = "attachedMedia", required = false) attachedMedia: org.springframework.web.multipart.MultipartFile,
        @Parameter(description = "this can be used if the \"attachedMedia\" is a link (i.e. a Youtube video, etc)") @Valid @RequestParam(value = "attachedMediaURL", required = false) attachedMediaURL: kotlin.String?,
        @Parameter(description = "the start date") @Valid @RequestParam(value = "startDate", required = false) startDate: kotlin.Long?,
        @Parameter(description = "the end date") @Valid @RequestParam(value = "endDate", required = false) endDate: kotlin.Long?,
        @Parameter(description = "the tags") @Valid @RequestParam(value = "tags", required = false) tags: kotlin.String?,
        @Parameter(description = "the description of the album") @Valid @RequestParam(value = "description", required = false) description: kotlin.String?,
        @Parameter(description = "a custom field used for aggregation and searching") @Valid @RequestParam(value = "albumType", required = false) albumType: kotlin.String?,
        @Parameter(description = "a custom indexed number used for aggregation and searching") @Valid @RequestParam(value = "albumTypeId", required = false) albumTypeId: kotlin.Long?,
        @Parameter(description = "a custom string field used for aggregation and searching") @Valid @RequestParam(value = "subType", required = false) subType: kotlin.String?,
        @Parameter(description = "latitude used to update the album's location") @Valid @RequestParam(value = "latitude", required = false) latitude: kotlin.Double?,
        @Parameter(description = "longitude used to update the album's location") @Valid @RequestParam(value = "longitude", required = false) longitude: kotlin.Double?,
        @Parameter(description = "the location description") @Valid @RequestParam(value = "locationDescription", required = false) locationDescription: kotlin.String?,
        @Parameter(description = "the determines the album's participants (PUBLIC - includes everyone in the system as a potential participant, PRIVATE - only considers people who have been invited as participants)", schema = Schema(allowableValues = ["PUBLIC", "PRIVATE", "FRIENDS"])) @Valid @RequestParam(value = "visibility", required = false) visibility: kotlin.String?,
        @Parameter(description = "@deprecated, use the appKey") @Valid @RequestParam(value = "gameType", required = false) gameType: kotlin.String?,
        @Parameter(description = "the application key") @Valid @RequestParam(value = "appKey", required = false) appKey: kotlin.String?,
        @Parameter(description = "the cell phone number") @Valid @RequestParam(value = "cellPhone", required = false) cellPhone: kotlin.String?,
        @Parameter(description = "The street address of the location") @Valid @RequestParam(value = "streetAddress", required = false) streetAddress: kotlin.String?,
        @Parameter(description = "Additional address information (such as a suite number, floor number, building name, or PO Box)") @Valid @RequestParam(value = "streetAddress2", required = false) streetAddress2: kotlin.String?,
        @Parameter(description = "The city of the location") @Valid @RequestParam(value = "city", required = false) city: kotlin.String?,
        @Parameter(description = "The state of of the location") @Valid @RequestParam(value = "state", required = false) state: kotlin.String?,
        @Parameter(description = "The postal code of the location") @Valid @RequestParam(value = "postalCode", required = false) postalCode: kotlin.String?,
        @Parameter(description = "The full address of the location which should include the street address, city, state, and postal code") @Valid @RequestParam(value = "fullAddress", required = false) fullAddress: kotlin.String?,
        @Parameter(description = "External custom client defined data") @Valid @RequestParam(value = "metaData", required = false) metaData: kotlin.String?,
        @Parameter(description = "comma separated category ids string associated with the Album") @Valid @RequestParam(value = "categoryIds", required = false) categoryIds: kotlin.String?,
        @Parameter(description = "comma separated filter ids string associated with the Album") @Valid @RequestParam(value = "categoryFilterIds", required = false) categoryFilterIds: kotlin.String?,
        @Parameter(description = "comma separated audience ids string associated with the album") @Valid @RequestParam(value = "audienceIds", required = false) audienceIds: kotlin.String?,
        @Parameter(description = "determines whether to include all app users as members (only admins of the app can do this)") @Valid @RequestParam(value = "includeAllAppUsersAsMembers", required = false) includeAllAppUsersAsMembers: kotlin.Boolean?,
        @Parameter(description = "determines whether to include all users of the audiences as members (only admins of the app can do this)") @Valid @RequestParam(value = "includeAudiencesAsMembers", required = false) includeAudiencesAsMembers: kotlin.Boolean?,
        @Parameter(description = "determines whether to use ands or ors when using the audience list to add users") @Valid @RequestParam(value = "audienceOperator", required = false) audienceOperator: kotlin.String?,
        @Parameter(description = "The approval status to set {PENDING, REJECTED, APPROVED, FEATURED}", schema = Schema(allowableValues = ["PENDING", "REJECTED", "APPROVED", "FEATURED"])) @Valid @RequestParam(value = "approvalStatus", required = false) approvalStatus: kotlin.String?,
        @Parameter(description = "sets a linked object so that it can be returned as part of the album response") @Valid @RequestParam(value = "linkedObjectType", required = false) linkedObjectType: kotlin.String?,
        @Parameter(description = "sets a linked object id so that it can be returned as part of the album response") @Valid @RequestParam(value = "linkedObjectId", required = false) linkedObjectId: kotlin.Long?
    ): ResponseEntity<SearchResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Add Album Users",
        operationId = "addAlbumUsers",
        description = """Add users to an album as participants.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/album/user/add"
        value = [PATH_ADD_ALBUM_USERS],
        produces = ["*/*"]
    )
    fun addAlbumUsers(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the album ID", required = true) @Valid @RequestParam(value = "albumId", required = true) albumId: kotlin.Long,
        @NotNull @Parameter(description = "determines whether to include all friends as participants", required = true) @Valid @RequestParam(value = "includeFriendGroup", required = true) includeFriendGroup: kotlin.Boolean,
        @Parameter(description = "a unique ID given by the device (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "the account ID of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "determines whether the users being added have read permissions") @Valid @RequestParam(value = "read", required = false) read: kotlin.Boolean?,
        @Parameter(description = "determines whether the users being added have write permissions") @Valid @RequestParam(value = "write", required = false) write: kotlin.Boolean?,
        @Parameter(description = "determines whether the users being added have delete permissions") @Valid @RequestParam(value = "delete", required = false) delete: kotlin.Boolean?,
        @Parameter(description = "determines whether the users being added have add permissions") @Valid @RequestParam(value = "add", required = false) add: kotlin.Boolean?,
        @Parameter(description = "comma separated list of connection IDs") @Valid @RequestParam(value = "connections", required = false) connections: kotlin.String?,
        @Parameter(description = "comma separated list of connection group IDs") @Valid @RequestParam(value = "connectionGroups", required = false) connectionGroups: kotlin.String?
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Add Connection",
        operationId = "addConnectionToGroup",
        description = """Adds a connection to a group.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/consumer/connection/group/addConnection"
        value = [PATH_ADD_CONNECTION_TO_GROUP],
        produces = ["*/*"]
    )
    fun addConnectionToGroup(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "whether to return nulls or not", required = true) @Valid @RequestParam(value = "returnNulls", required = true) returnNulls: kotlin.Boolean,
        @NotNull @Parameter(description = "the group id", required = true) @Valid @RequestParam(value = "groupId", required = true) groupId: kotlin.Long,
        @Parameter(description = "the device id (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "the account id of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "the connection id") @Valid @RequestParam(value = "connectionId", required = false) connectionId: kotlin.Long?,
        @Parameter(description = "the connection account id") @Valid @RequestParam(value = "connectionAccountId", required = false) connectionAccountId: kotlin.Long?,
        @Parameter(description = "the pending id") @Valid @RequestParam(value = "pendingId", required = false) pendingId: kotlin.Long?,
        @Parameter(description = "the current latitude of the user") @Valid @RequestParam(value = "latitude", required = false) latitude: kotlin.Double?,
        @Parameter(description = "the current longitude of the user") @Valid @RequestParam(value = "longitude", required = false) longitude: kotlin.Double?
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Add Connections",
        operationId = "addConnectionsToGroup",
        description = """Adds a list of connections to a group.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/connection/group/addConnections"
        value = [PATH_ADD_CONNECTIONS_TO_GROUP],
        produces = ["*/*"]
    )
    fun addConnectionsToGroup(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the connection group ID", required = true) @Valid @RequestParam(value = "connectionGroupId", required = true) connectionGroupId: kotlin.Long,
        @Parameter(description = "the device id (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "the account id of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "comma separated list of connection ids") @Valid @RequestParam(value = "connectionIds", required = false) connectionIds: kotlin.String?,
        @Parameter(description = "comma separated list of connection account ids") @Valid @RequestParam(value = "connectionAccountIds", required = false) connectionAccountIds: kotlin.String?,
        @Parameter(description = "the current latitude of the user") @Valid @RequestParam(value = "latitude", required = false) latitude: kotlin.Double?,
        @Parameter(description = "the current longitude of the user") @Valid @RequestParam(value = "longitude", required = false) longitude: kotlin.Double?
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Create Favorite",
        operationId = "addFavorite",
        description = """Adds an offer, offer location, retailer location, or category to your favorites.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = WrappedResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/favorite/create"
        value = [PATH_ADD_FAVORITE],
        produces = ["*/*"]
    )
    fun addFavorite(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The ID of the object to favorite {offerId, offerLocationId, retailerLocationId, categoryId}", required = true) @Valid @RequestParam(value = "favoritableId", required = true) favoritableId: kotlin.Long,
        @NotNull @Parameter(description = "The type of the object to favorite {OFFER, OFFER_LOCATION, RETAILER_LOCATION, CATEGORY, ALBUM}", required = true) @Valid @RequestParam(value = "favoritableType", required = true) favoritableType: kotlin.String,
        @Parameter(description = "The unique ID given by the device (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "The account ID of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "The current latitude of the user") @Valid @RequestParam(value = "latitude", required = false) latitude: kotlin.Double?,
        @Parameter(description = "The current longitude of the user") @Valid @RequestParam(value = "longitude", required = false) longitude: kotlin.Double?
    ): ResponseEntity<WrappedResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Create Field",
        operationId = "addField",
        description = """Add a field to a specific object.  The field name should be camel   case with the first letter lower case, for example: myFieldName.

Duplicate   field names are not allowed. 

The field name cannot be any of the following   reserved words: ACCESSIBLE, ADD, ALL, ALTER, ANALYZE, AND, AS, ASC, ASENSITIVE,   BEFORE, BETWEEN, BIGINT, BINARY, BLOB, BOTH, BY, CALL, CASCADE, CASE, CHANGE,   CHAR, CHARACTER, CHECK, COLLATE, COLUMN, CONDITION, CONSTRAINT, CONTINUE,   CONVERT, CREATE, CROSS, CURRENT_, ATE, CURRENT_TIME, CURRENT_TIMESTAMP,   CURRENT_USER, CURSOR, DATABASE, DATABASES, DAY_HOUR, DAY_MICROSECOND, DAY_MINUTE,   DAY_SECOND, DEC, DECIMAL, DECLARE, DEFAULT, DELAYED, DELETE, DESC, DESCRIBE,   DETERMINISTIC, DISTINCT, DISTINCTROW, DIV, DOUBLE, DROP, DUAL, EACH, ELSE,   ELSEIF, ENCLOSED, ESCAPED, EXISTS, EXIT, EXPLAIN, FALSE, FETCH, FLOAT, FLOAT4,   FLOAT8, FOR, FORCE, FOREIGN, FROM, FULLTEXT, GRANT, GROUP, HAVING, HIGH_PRIORITY,   HOUR_MICROSECOND, HOUR_MINUTE, HOUR_SECOND, IF, IGNORE, IN, INDEX, INFILE,   INNER, INOUT, INSENSITIVE, INSERT, INT, INT1, INT2, INT3, INT4, INT8, INTEGER,   INTERVAL, INTO, IS, ITERATE, JOIN, KEY, KEYS, KILL, LEADING, LEAVE, LEFT,   LIKE, LIMIT, LINEAR, LINES, LOAD, LOCALTIME, LOCALTIMESTAMP, LOCK, LONG,   LONGBLOB, LONGT, XT, LOOP, LOW_PRIORITY, MASTER_SSL_VERIFY_SERVER_CERT,   MATCH, MAXVALUE, MEDIUMBLOB, MEDIUMINT, MEDIUMTEXT, MIDDLEINT, MINUTE_MICROSECOND,   MINUTE_SECOND, MOD, MODIFIES, NATURAL, NOT, NO_WRITE_TO_BINLOG, NULL, NUMERIC,   ON, OPTIMIZE, OPTION, OPTIONALLY, OR, ORDER, OUT, OUTER, OUTFILE, PRECISION,   PRIMARY, PROCEDURE, PURGE, RANGE, READ, READS, READ_WRITE, REAL, REFERENCES,   REGEXP, RELEASE, RENAME, REPEAT, REPLACE, REQUIRE, RESIGNAL, RESTRICT, RETURN,   REVOKE, RIGHT, RLIKE, SCHEMA, SCHEMAS, SECOND_MICROSECOND, SELECT, SENSITIVE,   SEPARATOR, SET, SHOW, SIGNAL, SMALLINT, SPATIAL, SPECIFIC, SQL, SQLEXCEPTION,   SQLSTATE, SQLWARNING, SQL_BIG_RESULT, SQL_CALC_FOUND_ROWS, SQL_SMALL_RESULT,   SSL, STARTING, STRAIGHT_JOIN, TABLE, TERMINATED, THEN, TINYBLOB, TINYINT,   TINYTEXT, TO, TRAILING, TRIGGER, TRUE, NDO, UNION, UNIQUE, UNLOCK, UNSIGNED,   UPDATE, USAGE, USE, USING, UTC_DATE, UTC_TIME, UTC_TIMESTAMP, VALUES, VARBINARY,   VARCHAR, VARCHARACTER, VARYING, WHEN, WHERE, WHILE, WITH, WRITE, XOR, YEAR_MONTH,   ZEROFILL, GENERAL, IGNORE_SERVER_IDS, MASTER_HEARTBEAT_PERIOD, SLOW. 

  The following field names are reserved (cannot be used directly) and are automatically   included during object creation: ID, OBJECTID, CREATED, UPDATED, DELETED.   Additionally the field names must start with a letter or number.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = ObjectStoreResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/object/field/add"
        value = [PATH_ADD_FIELD],
        produces = ["*/*"]
    )
    fun addField(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The account id of the logged in user", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "The application key for updating an existing application", required = true) @Valid @RequestParam(value = "appKey", required = true) appKey: kotlin.String,
        @NotNull @Parameter(description = "The name of the object to add the field to", required = true) @Valid @RequestParam(value = "objectName", required = true) objectName: kotlin.String,
        @NotNull @Parameter(description = "field name The name of the field to add.", required = true) @Valid @RequestParam(value = "fieldName", required = true) fieldName: kotlin.String,
        @NotNull @Parameter(description = "field type The field type to create, supported types are: STRING, DATE, NUMBER, BOOLEAN, IDENTITY", required = true) @Valid @RequestParam(value = "fieldType", required = true) fieldType: kotlin.String
    ): ResponseEntity<ObjectStoreResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Add Movie",
        operationId = "addMovie",
        description = """Add a movie to be indexed for Topics. Indexing a movie analyses the content and incorporates it into the topics model for future /topics calls. This does not store the movie file long-term.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = OrsonAiAddMovieResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/orson/ai/addMovie"
        value = [PATH_ADD_MOVIE],
        produces = ["*/*"]
    )
    fun addMovie(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "Sirqul Account Id", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "Movie Name", required = true) @Valid @RequestParam(value = "movieName", required = true) movieName: kotlin.String,
        @Parameter(description = "A third-party account id that is meaningful to your systems") @Valid @RequestParam(value = "thirdPartyAccountId", required = false) thirdPartyAccountId: kotlin.String?,
        @Parameter(description = "A user defined list (comma-delimited) of tags associated with the movie") @Valid @RequestParam(value = "tags", required = false) tags: kotlin.String?,
        @Parameter(description = "An uploaded recording to analyze (Currently limited to 10MB)") @Valid @RequestParam(value = "file", required = false) file: org.springframework.web.multipart.MultipartFile,
        @Parameter(description = "A recording file to download and analyze (Size limit: 1GB)") @Valid @RequestParam(value = "url", required = false) url: kotlin.String?,
        @Parameter(description = "When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open") @Valid @RequestParam(value = "callback", required = false) paramCallback: kotlin.String?
    ): ResponseEntity<OrsonAiAddMovieResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Create or Update Contest",
        operationId = "addOrUpdateAlbumContest",
        description = """Creates or updates a contest.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = AlbumContestResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/consumer/album/contest"
        value = [PATH_ADD_OR_UPDATE_ALBUM_CONTEST],
        produces = ["*/*"]
    )
    fun addOrUpdateAlbumContest(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "determines whether the contest's participants has read permissions", required = true) @Valid @RequestParam(value = "publicRead", required = true) publicRead: kotlin.Boolean,
        @NotNull @Parameter(description = "determines whether the contest's participants has write permissions", required = true) @Valid @RequestParam(value = "publicWrite", required = true) publicWrite: kotlin.Boolean,
        @NotNull @Parameter(description = "determines whether the contest's participants has delete permissions", required = true) @Valid @RequestParam(value = "publicDelete", required = true) publicDelete: kotlin.Boolean,
        @NotNull @Parameter(description = "determines whether the contest's participants has add permissions", required = true) @Valid @RequestParam(value = "publicAdd", required = true) publicAdd: kotlin.Boolean,
        @NotNull @Parameter(description = "the determines the album's participants (PUBLIC - includes everyone in the system as a potential participant, PRIVATE - only considers people who have been invited as participants)", required = true, schema = Schema(allowableValues = ["PUBLIC", "PRIVATE", "FRIENDS"])) @Valid @RequestParam(value = "visibility", required = true) visibility: kotlin.String,
        @NotNull @Parameter(description = "determines whether to include all friends as participants", required = true) @Valid @RequestParam(value = "includeFriendGroup", required = true) includeFriendGroup: kotlin.Boolean,
        @Parameter(description = "a unique ID given by the device (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "the account ID of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "This parameter is deprecated. the application key") @Valid @RequestParam(value = "gameType", required = false) gameType: kotlin.String?,
        @Parameter(description = "the application key") @Valid @RequestParam(value = "appKey", required = false) appKey: kotlin.String?,
        @Parameter(description = "a custom field used for aggregation and searching") @Valid @RequestParam(value = "contestType", required = false) contestType: kotlin.String?,
        @Parameter(description = "the album contest ID for updating (don't pass in if creating)") @Valid @RequestParam(value = "albumContestId", required = false) albumContestId: kotlin.Long?,
        @Parameter(description = "the title of the contest") @Valid @RequestParam(value = "title", required = false) title: kotlin.String?,
        @Parameter(description = "the description of the contest") @Valid @RequestParam(value = "description", required = false) description: kotlin.String?,
        @Parameter(description = "the album ID for the first album") @Valid @RequestParam(value = "albumId1", required = false) albumId1: kotlin.Long?,
        @Parameter(description = "removes album1 from the contest") @Valid @RequestParam(value = "removeAlbum1", required = false) removeAlbum1: kotlin.Boolean?,
        @Parameter(description = "the album ID for the second album") @Valid @RequestParam(value = "albumId2", required = false) albumId2: kotlin.Long?,
        @Parameter(description = "removes album2 from the contest") @Valid @RequestParam(value = "removeAlbum2", required = false) removeAlbum2: kotlin.Boolean?,
        @Parameter(description = "the start date of the contest (time-stamp in milliseconds)") @Valid @RequestParam(value = "startDate", required = false) startDate: kotlin.Long?,
        @Parameter(description = "the end date of the contest (time-stamp in milliseconds)") @Valid @RequestParam(value = "endDate", required = false) endDate: kotlin.Long?,
        @Parameter(description = "the location description of the contest taking place") @Valid @RequestParam(value = "locationDescription", required = false) locationDescription: kotlin.String?,
        @Parameter(description = "comma separated list of connection IDs") @Valid @RequestParam(value = "connectionIdsToAdd", required = false) connectionIdsToAdd: kotlin.String?,
        @Parameter(description = "comma separated list of connection group IDs") @Valid @RequestParam(value = "connectionGroupIdsToAdd", required = false) connectionGroupIdsToAdd: kotlin.String?,
        @Parameter(description = "latitude used to update the user's current location") @Valid @RequestParam(value = "latitude", required = false) latitude: kotlin.Double?,
        @Parameter(description = "longitude used to update the user's current location") @Valid @RequestParam(value = "longitude", required = false) longitude: kotlin.Double?
    ): ResponseEntity<AlbumContestResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Create/Update Theme",
        operationId = "addOrUpdateThemeDescriptor",
        description = """Creates or updates a theme descriptor that can be used to give applications a customized look and feel. The theme can be created by consumers and shared to other users, allowing them to use and/or collaborate on making the theme.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = ThemeDescriptorResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/consumer/theme"
        value = [PATH_ADD_OR_UPDATE_THEME_DESCRIPTOR],
        produces = ["*/*"]
    )
    fun addOrUpdateThemeDescriptor(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "determines whether the theme's participants have read permissions", required = true) @Valid @RequestParam(value = "publicRead", required = true) publicRead: kotlin.Boolean,
        @NotNull @Parameter(description = "determines whether the theme's participants have write permissions", required = true) @Valid @RequestParam(value = "publicWrite", required = true) publicWrite: kotlin.Boolean,
        @NotNull @Parameter(description = "determines whether the theme's participants have delete permissions", required = true) @Valid @RequestParam(value = "publicDelete", required = true) publicDelete: kotlin.Boolean,
        @NotNull @Parameter(description = "", required = true) @Valid @RequestParam(value = "publicAdd", required = true) publicAdd: kotlin.Boolean,
        @NotNull @Parameter(description = "the determines the theme's participants (PUBLIC - includes everyone in the system as a potential participant, PRIVATE - only considers people who have been invited as participants)", required = true, schema = Schema(allowableValues = ["PUBLIC", "PRIVATE", "FRIENDS"])) @Valid @RequestParam(value = "visibility", required = true) visibility: kotlin.String,
        @NotNull @Parameter(description = "flag to determine whether to share to the user's \"friends\" group", required = true) @Valid @RequestParam(value = "includeFriendGroup", required = true) includeFriendGroup: kotlin.Boolean,
        @NotNull @Parameter(description = "determines whether to use default values to complete the theme", required = true) @Valid @RequestParam(value = "completeWithDefaultValues", required = true) completeWithDefaultValues: kotlin.Boolean,
        @Parameter(description = "a unique ID given by the device (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "the account ID of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "the application key") @Valid @RequestParam(value = "gameType", required = false) gameType: kotlin.String?,
        @Parameter(description = "the theme descriptor id used to update an existing theme, leave empty for creating a new theme") @Valid @RequestParam(value = "themeDescriptorId", required = false) themeDescriptorId: kotlin.Long?,
        @Parameter(description = "the title of the theme") @Valid @RequestParam(value = "title", required = false) title: kotlin.String?,
        @Parameter(description = "the description of the theme") @Valid @RequestParam(value = "description", required = false) description: kotlin.String?,
        @Parameter(description = "a comma separated list of connection IDs to share to users") @Valid @RequestParam(value = "connectionIdsToAdd", required = false) connectionIdsToAdd: kotlin.String?,
        @Parameter(description = "a comma separated list of connection group IDs to share to groups") @Valid @RequestParam(value = "connectionGroupIdsToAdd", required = false) connectionGroupIdsToAdd: kotlin.String?,
        @Parameter(description = "the application version the theme was created for") @Valid @RequestParam(value = "appVersion", required = false) appVersion: kotlin.String?,
        @Parameter(description = "a json array used to replace colors within the application. Example: ```json [   {     \"name\": \"sceneAtlas\",     \"valueString\": \"100,100,100,255\"   },   {     \"name\": \"bg\",     \"valueString\": \"100,100,100,255\"   } ] ``` ") @Valid @RequestParam(value = "colorValueJson", required = false) colorValueJson: kotlin.String?,
        @Parameter(description = "a json array used to replace strings within the application. Example: ```json [   {     \"name\": \"coins\",     \"valueString\": \"Gems\"   },   {     \"name\": \"lives\",     \"valueString\": \"lives\"   } ] ``` ") @Valid @RequestParam(value = "stringReplacerJson", required = false) stringReplacerJson: kotlin.String?,
        @Parameter(description = "a json object used by the scene atlas to position sprites. Example: ```json {   \"pShootingOffset\": [     {       \"name\": \"x\",       \"valueString\": \"2.2\"     },     {       \"name\": \"y\",       \"valueString\": \"-0.3\"     }   ],   \"e1ShootingOffset\": [     {       \"name\": \"x\",       \"valueString\": \"0.25\"     },     {       \"name\": \"y\",       \"valueString\": \"0.5\"     }   ] } ``` ") @Valid @RequestParam(value = "customJsonObjects", required = false) customJsonObjects: kotlin.String?,
        @Parameter(description = "a MultipartFile containing the image used as the theme icon") @Valid @RequestParam(value = "iconImage", required = false) iconImage: org.springframework.web.multipart.MultipartFile,
        @Parameter(description = "a MultipartFile containing the scene atlas") @Valid @RequestParam(value = "sceneAtlasImage", required = false) sceneAtlasImage: org.springframework.web.multipart.MultipartFile,
        @Parameter(description = "a MultipartFile containing the background image") @Valid @RequestParam(value = "bgImage", required = false) bgImage: org.springframework.web.multipart.MultipartFile,
        @Parameter(description = "a MultipartFile containing the background sound file (preferably in MP3 format)") @Valid @RequestParam(value = "bgSound", required = false) bgSound: org.springframework.web.multipart.MultipartFile,
        @Parameter(description = "used to select a default sound file that already exists in the application") @Valid @RequestParam(value = "musicSelection", required = false) musicSelection: kotlin.String?,
        @Parameter(description = "the description of the user's current location") @Valid @RequestParam(value = "locationDescription", required = false) locationDescription: kotlin.String?,
        @Parameter(description = "the current latitude of the user") @Valid @RequestParam(value = "latitude", required = false) latitude: kotlin.Double?,
        @Parameter(description = "the current longitude of the user") @Valid @RequestParam(value = "longitude", required = false) longitude: kotlin.Double?
    ): ResponseEntity<ThemeDescriptorResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Update Payment Method",
        operationId = "addPaymentMethod",
        description = """Update a method of payment. If the paymentMethodId is not passed in then will update their default payment method.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = PaymentTypesResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/billing/update"
        value = [PATH_ADD_PAYMENT_METHOD],
        produces = ["*/*"]
    )
    fun addPaymentMethod(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The account used to perform the the request", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @Parameter(description = "Payment Method Id") @Valid @RequestParam(value = "paymentMethodId", required = false) paymentMethodId: kotlin.Long?,
        @Parameter(description = "the name of the account") @Valid @RequestParam(value = "accountName", required = false) accountName: kotlin.String?,
        @Parameter(description = "First Name that the account is filed as") @Valid @RequestParam(value = "firstName", required = false) firstName: kotlin.String?,
        @Parameter(description = "Last Name that the account is filed as") @Valid @RequestParam(value = "lastName", required = false) lastName: kotlin.String?,
        @Parameter(description = "Address that the account is filed as") @Valid @RequestParam(value = "address", required = false) address: kotlin.String?,
        @Parameter(description = "City that the account is filed as") @Valid @RequestParam(value = "city", required = false) city: kotlin.String?,
        @Parameter(description = "State that the account is filed as") @Valid @RequestParam(value = "state", required = false) state: kotlin.String?,
        @Parameter(description = "Postal Code that the account is filed as") @Valid @RequestParam(value = "postalCode", required = false) postalCode: kotlin.String?,
        @Parameter(description = "Country that the account is filed as") @Valid @RequestParam(value = "country", required = false) country: kotlin.String?,
        @Parameter(description = "Phone that the account is filed as") @Valid @RequestParam(value = "phone", required = false) phone: kotlin.String?,
        @Parameter(description = "The full credit card number to store on file") @Valid @RequestParam(value = "creditCardNumber", required = false) creditCardNumber: kotlin.String?,
        @Parameter(description = "The credit card expiration date YYYY-MM") @Valid @RequestParam(value = "expirationDate", required = false) expirationDate: kotlin.String?,
        @Parameter(description = "The 3 digit confirmation code") @Valid @RequestParam(value = "ccv", required = false) ccv: kotlin.String?,
        @Parameter(description = "The bank account number") @Valid @RequestParam(value = "accountNumber", required = false) accountNumber: kotlin.String?,
        @Parameter(description = "The bank name") @Valid @RequestParam(value = "bankName", required = false) bankName: kotlin.String?,
        @Parameter(description = "Routing Number") @Valid @RequestParam(value = "routingNumber", required = false) routingNumber: kotlin.String?,
        @Parameter(description = "Default Payment Method") @Valid @RequestParam(value = "defaultPaymentMethod", required = false) defaultPaymentMethod: kotlin.Boolean?,
        @Parameter(description = "Payment Method Nickname") @Valid @RequestParam(value = "paymentMethodNickname", required = false) paymentMethodNickname: kotlin.String?,
        @Parameter(description = "Tax Id") @Valid @RequestParam(value = "taxId", required = false) taxId: kotlin.String?,
        @Parameter(description = "Provider customer profile Id") @Valid @RequestParam(value = "providerCustomerProfileId", required = false) providerCustomerProfileId: kotlin.String?,
        @Parameter(description = "Provider customer payment profile Id") @Valid @RequestParam(value = "providerPaymentProfileId", required = false) providerPaymentProfileId: kotlin.String?,
        @Parameter(description = "Meta Data") @Valid @RequestParam(value = "metaData", required = false) metaData: kotlin.String?
    ): ResponseEntity<PaymentTypesResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Add Preview",
        operationId = "addPreview",
        description = """Enable this ad for preview for this account.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/creative/addpreview"
        value = [PATH_ADD_PREVIEW],
        produces = ["*/*"]
    )
    fun addPreview(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the id of the account", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "The id of the creative that want to enable preview. The type of the creative should be CONFIG, otherwise no action will be applied.", required = true) @Valid @RequestParam(value = "creativeId", required = true) creativeId: kotlin.Long
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Add Connection Groups",
        operationId = "addSubGroups",
        description = """Add sub groups to a group.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = ConnectionGroupResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/consumer/connection/group/addSubGroup"
        value = [PATH_ADD_SUB_GROUPS],
        produces = ["*/*"]
    )
    fun addSubGroups(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "whether to return nulls or not", required = true) @Valid @RequestParam(value = "returnNulls", required = true) returnNulls: kotlin.Boolean,
        @NotNull @Parameter(description = "the parent group id", required = true) @Valid @RequestParam(value = "groupId", required = true) groupId: kotlin.Long,
        @NotNull @Parameter(description = "comma separated list of group IDs to add to the parent group", required = true) @Valid @RequestParam(value = "subGroupIds", required = true) subGroupIds: kotlin.String,
        @Parameter(description = "the device id (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "the account id of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "the current latitude of the user") @Valid @RequestParam(value = "latitude", required = false) latitude: kotlin.Double?,
        @Parameter(description = "the current longitude of the user") @Valid @RequestParam(value = "longitude", required = false) longitude: kotlin.Double?
    ): ResponseEntity<ConnectionGroupResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Add User",
        operationId = "addUsersToPermissionable",
        description = """Adds a user to a permissionable object.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/consumer/permissions/add"
        value = [PATH_ADD_USERS_TO_PERMISSIONABLE],
        produces = ["*/*"]
    )
    fun addUsersToPermissionable(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the permissionable type of the object", required = true, schema = Schema(allowableValues = ["ACCOUNT", "GAMELEVEL", "ALBUM_CONTEST", "THEME_DESCRIPTOR", "SCHEDULED_NOTIFICATION", "TASK", "TRIGGER"])) @Valid @RequestParam(value = "permissionableType", required = true) permissionableType: kotlin.String,
        @NotNull @Parameter(description = "the id of the permissionable object", required = true) @Valid @RequestParam(value = "permissionableId", required = true) permissionableId: kotlin.Long,
        @Parameter(description = "the device id (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "the account id of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "the read permission of the users/groups", schema = Schema(defaultValue = "true")) @Valid @RequestParam(value = "read", required = false, defaultValue = "true") read: kotlin.Boolean,
        @Parameter(description = "the write permission of the users/groups", schema = Schema(defaultValue = "false")) @Valid @RequestParam(value = "write", required = false, defaultValue = "false") write: kotlin.Boolean,
        @Parameter(description = "the delete permission of the users/groups", schema = Schema(defaultValue = "false")) @Valid @RequestParam(value = "delete", required = false, defaultValue = "false") delete: kotlin.Boolean,
        @Parameter(description = "the add permission of the users/groups", schema = Schema(defaultValue = "false")) @Valid @RequestParam(value = "add", required = false, defaultValue = "false") add: kotlin.Boolean,
        @Parameter(description = "a comma separated list of connection ids (NOT the account ids)") @Valid @RequestParam(value = "connectionIds", required = false) connectionIds: kotlin.String?,
        @Parameter(description = "a comma separated list of account ids") @Valid @RequestParam(value = "connectionAccountIds", required = false) connectionAccountIds: kotlin.String?,
        @Parameter(description = "a comma separated list of connection group ids (these are groups made by the user)") @Valid @RequestParam(value = "connectionGroupIds", required = false) connectionGroupIds: kotlin.String?,
        @Parameter(description = "sets whether the added users are marked as pending (and will require the album admins to accept) - admins can set this to false (to accept)", schema = Schema(defaultValue = "false")) @Valid @RequestParam(value = "pending", required = false, defaultValue = "false") pending: kotlin.Boolean,
        @Parameter(description = "sets whether the added users will become admins or not") @Valid @RequestParam(value = "admin", required = false) admin: kotlin.Boolean?,
        @Parameter(description = "flag to determine whether to include the built-in \"friends\" group", schema = Schema(defaultValue = "false")) @Valid @RequestParam(value = "includeFriendGroup", required = false, defaultValue = "false") includeFriendGroup: kotlin.Boolean,
        @Parameter(description = "the current latitude of the user") @Valid @RequestParam(value = "latitude", required = false) latitude: kotlin.Double?,
        @Parameter(description = "the current longitude of the user") @Valid @RequestParam(value = "longitude", required = false) longitude: kotlin.Double?,
        @Parameter(description = "comma separated list of audience ids. This is a feature only available to the permissionable's application owner (and its employees). This will add all users from these audiences to the permissionable object. Notifications will not be sent to users if this feature is used.") @Valid @RequestParam(value = "audienceIds", required = false) audienceIds: kotlin.String?
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Find Missions",
        operationId = "adsFind",
        description = """Get a set of ad filtered by the parameters provided.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(array = ArraySchema(schema = Schema(implementation = MissionResponse::class)))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/ads/find"
        value = [PATH_ADS_FIND],
        produces = ["*/*"]
    )
    fun adsFind(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The application key, if provided return missions specific for the app. Will always return mission levels that are app agnostic.", required = true) @Valid @RequestParam(value = "appKey", required = true) appKey: kotlin.String,
        @NotNull @Parameter(description = "return a random set of results, default is true. If false returns in nature order.", required = true) @Valid @RequestParam(value = "randomize", required = true) randomize: kotlin.Boolean,
        @NotNull @Parameter(description = "return only ads targets to the specific app, no global ads.", required = true) @Valid @RequestParam(value = "targetedAdsOnly", required = true) targetedAdsOnly: kotlin.Boolean,
        @Parameter(description = "The type of ads to get, possible values are: BANNER, LEADERBOARD, SKYSCRAPER, FULL, VIDEO, ZIP, CONFIG. Use this instead of suffix.") @Valid @RequestParam(value = "type", required = false) type: kotlin.String?,
        @Parameter(description = "The logged in user.") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "The version of the application, will not return levels newer than the appVersion.") @Valid @RequestParam(value = "appVersion", required = false) appVersion: kotlin.String?,
        @Parameter(description = "The current location of the requesting device") @Valid @RequestParam(value = "latitude", required = false) latitude: kotlin.Double?,
        @Parameter(description = "The current location of the requesting device") @Valid @RequestParam(value = "longitude", required = false) longitude: kotlin.Double?,
        @Parameter(description = "Should use deviceId if possible. The name of the requesting device; possible values are: Android, iPhone, iPad, iPod, etc. use /audience/devices for list.") @Valid @RequestParam(value = "device", required = false) device: kotlin.String?,
        @Parameter(description = "The device ID of the requesting device, use /audience/devices for list") @Valid @RequestParam(value = "deviceIdentifier", required = false) deviceIdentifier: kotlin.Long?,
        @Parameter(description = "The requesting device version; examples are: 2.3, 5.1.4, 6.1.4. Supports X, X.X, or X.X.X formated string.") @Valid @RequestParam(value = "deviceVersion", required = false) deviceVersion: kotlin.String?,
        @Parameter(description = "The index into the record set to start with.") @Valid @RequestParam(value = "start", required = false) start: kotlin.Int?,
        @Parameter(description = "The total number of record to return.") @Valid @RequestParam(value = "limit", required = false) limit: kotlin.Int?,
        @Parameter(description = "If true then return the audience data in the response. Default is false.") @Valid @RequestParam(value = "includeAudiences", required = false) includeAudiences: kotlin.Boolean?,
        @Parameter(description = "If true/false only return missions whose game levels allocate (or don't allocate) tickets. Do not provide a value to return both.") @Valid @RequestParam(value = "allocatesTickets", required = false) allocatesTickets: kotlin.Boolean?,
        @Parameter(description = "return only ads from the specified campaigns.") @Valid @RequestParam(value = "missionIds", required = false) missionIds: kotlin.String?
    ): ResponseEntity<List<MissionResponse>> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get Aggregated Filtered Usage",
        operationId = "aggregatedFilteredUsage",
        description = """Query analytics to get data used for nested graphs and charts""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = ChartData::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/analytics/aggregatedFilteredUsage"
        value = [PATH_AGGREGATED_FILTERED_USAGE],
        produces = ["*/*"]
    )
    fun aggregatedFilteredUsage(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "The unique id of the device making the request (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "The account id of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "This parameter is deprecated.") @Valid @RequestParam(value = "applicationId", required = false) applicationId: kotlin.Long?,
        @Parameter(description = "The application key used to filter results by application") @Valid @RequestParam(value = "appKey", required = false) appKey: kotlin.String?,
        @Parameter(description = "Used to search for results after or equal to this date (UNIX time-stamp in milliseconds)") @Valid @RequestParam(value = "startDate", required = false) startDate: kotlin.Long?,
        @Parameter(description = "Used to search for results before or equal to this date (UNIX time-stamp in milliseconds)") @Valid @RequestParam(value = "endDate", required = false) endDate: kotlin.Long?,
        @Parameter(description = "The device type to filter results by (performs a LIKE search)") @Valid @RequestParam(value = "deviceType", required = false) deviceType: kotlin.String?,
        @Parameter(description = "The device to filter results by (performs a LIKE search)") @Valid @RequestParam(value = "device", required = false) device: kotlin.String?,
        @Parameter(description = "The device OS to filter results by (performs a LIKE search)") @Valid @RequestParam(value = "deviceOS", required = false) deviceOS: kotlin.String?,
        @Parameter(description = "The gender to filter results by {MALE, FEMALE}") @Valid @RequestParam(value = "gender", required = false) gender: kotlin.String?,
        @Parameter(description = "Comma separated list of age groups to filter by {AGE_0_13, AGE_14_17, AGE_18_22, AGE_23_30, AGE_31_54, AGE_55_PLUS}") @Valid @RequestParam(value = "ageGroup", required = false) ageGroup: kotlin.String?,
        @Parameter(description = "The country to filter results by (performs a wild-card search)") @Valid @RequestParam(value = "country", required = false) country: kotlin.String?,
        @Parameter(description = "The state to filter results by (performs a wild-card search)") @Valid @RequestParam(value = "state", required = false) state: kotlin.String?,
        @Parameter(description = "The city to filter results by (performs a wild-card search)") @Valid @RequestParam(value = "city", required = false) city: kotlin.String?,
        @Parameter(description = "The zip to filter results by (performs a wild-card search)") @Valid @RequestParam(value = "zip", required = false) zip: kotlin.String?,
        @Parameter(description = "The model to filter results by (performs a wild-card search)") @Valid @RequestParam(value = "model", required = false) model: kotlin.String?,
        @Parameter(description = "The tag to filter results by (performs a wild-card search)") @Valid @RequestParam(value = "tag", required = false) tag: kotlin.String?,
        @Parameter(description = "The account id to filter results for a particular user") @Valid @RequestParam(value = "userAccountId", required = false) userAccountId: kotlin.Long?,
        @Parameter(description = "The user display to filter results by (performs a wild-card search)") @Valid @RequestParam(value = "userAccountDisplay", required = false) userAccountDisplay: kotlin.String?,
        @Parameter(description = "The username to filter results by (performs a wild-card search)") @Valid @RequestParam(value = "userAccountUsername", required = false) userAccountUsername: kotlin.String?,
        @Parameter(description = "Determines how to group results. For example, passing in 'CREATED' will return results by date. Passing in 'ACCOUNT' will return results by user {TAG, CUSTOM_ID, TOKEN, MODEL, DEVICE_TYPE, DEVICE, DEVICE_OS, IP_ADDRESS, STATE, CITY, ZIP, COUNTRY, ACCOUNT, APPLICATION_ID, APPLICATION_NAME_BY_ID}", schema = Schema(allowableValues = ["TAG_COUNT", "TAG", "TOKEN", "MODEL", "DEVICE_TYPE", "DEVICE", "DEVICE_OS", "DEVICE_ID", "IP_ADDRESS", "STATE", "CITY", "ZIP", "COUNTRY", "CREATED", "UPDATED", "LAST_UPDATED", "CLIENT_TIME", "ACTIVE", "CUSTOM_ID", "CUSTOM_TYPE", "CUSTOM_VALUE", "CUSTOM_VALUE2", "CUSTOM_LONG", "CUSTOM_LONG2", "CUSTOM_MESSAGE", "CUSTOM_MESSAGE2", "ACCOUNT_ID", "ACCOUNT_USERNAME", "ACCOUNT_DISPLAY", "ACCOUNT_CREATED", "ACCOUNT_GENDER", "ACCOUNT_AGE_GROUP", "APPLICATION_ID", "APPLICATION_KEY", "APPLICATION_NAME"])) @Valid @RequestParam(value = "groupByRoot", required = false) groupByRoot: kotlin.String?,
        @Parameter(description = "Determines how to group the nested data. {TAG, CUSTOM_ID, TOKEN, MODEL, DEVICE_TYPE, DEVICE, DEVICE_OS, IP_ADDRESS, STATE, CITY, ZIP, COUNTRY, ACCOUNT, APPLICATION_ID, APPLICATION_NAME_BY_ID}", schema = Schema(allowableValues = ["TAG_COUNT", "TAG", "TOKEN", "MODEL", "DEVICE_TYPE", "DEVICE", "DEVICE_OS", "DEVICE_ID", "IP_ADDRESS", "STATE", "CITY", "ZIP", "COUNTRY", "CREATED", "UPDATED", "LAST_UPDATED", "CLIENT_TIME", "ACTIVE", "CUSTOM_ID", "CUSTOM_TYPE", "CUSTOM_VALUE", "CUSTOM_VALUE2", "CUSTOM_LONG", "CUSTOM_LONG2", "CUSTOM_MESSAGE", "CUSTOM_MESSAGE2", "ACCOUNT_ID", "ACCOUNT_USERNAME", "ACCOUNT_DISPLAY", "ACCOUNT_CREATED", "ACCOUNT_GENDER", "ACCOUNT_AGE_GROUP", "APPLICATION_ID", "APPLICATION_KEY", "APPLICATION_NAME"])) @Valid @RequestParam(value = "groupBy", required = false) groupBy: kotlin.String?,
        @Parameter(description = "Performs a unique query on the specified column. For example, passing in 'ACCOUNT' will return the number of unique users. {TAG, CUSTOM_ID, TOKEN, MODEL, DEVICE_TYPE, DEVICE, DEVICE_OS, IP_ADDRESS, STATE, CITY, ZIP, COUNTRY, ACCOUNT, APPLICATION_ID, NEW_ACCOUNT}", schema = Schema(allowableValues = ["TAG_COUNT", "TAG", "TOKEN", "MODEL", "DEVICE_TYPE", "DEVICE", "DEVICE_OS", "DEVICE_ID", "IP_ADDRESS", "STATE", "CITY", "ZIP", "COUNTRY", "CREATED", "UPDATED", "LAST_UPDATED", "CLIENT_TIME", "ACTIVE", "CUSTOM_ID", "CUSTOM_TYPE", "CUSTOM_VALUE", "CUSTOM_VALUE2", "CUSTOM_LONG", "CUSTOM_LONG2", "CUSTOM_MESSAGE", "CUSTOM_MESSAGE2", "ACCOUNT_ID", "ACCOUNT_USERNAME", "ACCOUNT_DISPLAY", "ACCOUNT_CREATED", "ACCOUNT_GENDER", "ACCOUNT_AGE_GROUP", "APPLICATION_ID", "APPLICATION_KEY", "APPLICATION_NAME"])) @Valid @RequestParam(value = "distinctCount", required = false) distinctCount: kotlin.String?,
        @Parameter(description = "Determines whether the results will be sorted by day or by number of hits {CREATED, TAG_COUNT}", schema = Schema(allowableValues = ["TAG_COUNT", "TAG", "TOKEN", "MODEL", "DEVICE_TYPE", "DEVICE", "DEVICE_OS", "DEVICE_ID", "IP_ADDRESS", "STATE", "CITY", "ZIP", "COUNTRY", "CREATED", "UPDATED", "LAST_UPDATED", "CLIENT_TIME", "ACTIVE", "CUSTOM_ID", "CUSTOM_TYPE", "CUSTOM_VALUE", "CUSTOM_VALUE2", "CUSTOM_LONG", "CUSTOM_LONG2", "CUSTOM_MESSAGE", "CUSTOM_MESSAGE2", "ACCOUNT_ID", "ACCOUNT_USERNAME", "ACCOUNT_DISPLAY", "ACCOUNT_CREATED", "ACCOUNT_GENDER", "ACCOUNT_AGE_GROUP", "APPLICATION_ID", "APPLICATION_KEY", "APPLICATION_NAME"])) @Valid @RequestParam(value = "sortField", required = false) sortField: kotlin.String?,
        @Parameter(description = "Determines whether to return results in descending order") @Valid @RequestParam(value = "descending", required = false) descending: kotlin.Boolean?,
        @Parameter(description = "Determines whether to return data that has empty or unknown values") @Valid @RequestParam(value = "hideUnknown", required = false) hideUnknown: kotlin.Boolean?,
        @Parameter(description = "Determines whether to return a JOSN or XML representation of the graph results", schema = Schema(allowableValues = ["HTML", "XML", "JSON", "CSV"])) @Valid @RequestParam(value = "responseFormat", required = false) responseFormat: kotlin.String?,
        @Parameter(description = "This parameter is deprecated.") @Valid @RequestParam(value = "_l", required = false) l: kotlin.Int?,
        @Parameter(description = "Used to limit results to get a cleaner graph. The results that gets filtered out will be combined") @Valid @RequestParam(value = "limit", required = false) limit: kotlin.Int?,
        @Parameter(description = "the current latitude of the user") @Valid @RequestParam(value = "latitude", required = false) latitude: kotlin.Double?,
        @Parameter(description = "the current longitude of the user") @Valid @RequestParam(value = "longitude", required = false) longitude: kotlin.Double?
    ): ResponseEntity<ChartData> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Search Docs",
        operationId = "aiDocs",
        description = """Takes in a text string representing one or more sentences and it returns a list of documents which are related to the provided document.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = OrsonAiProtoResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/orson/ai/docs"
        value = [PATH_AI_DOCS],
        produces = ["*/*"]
    )
    fun aiDocs(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "Sirqul Account Id", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "Doc", required = true) @Valid @RequestParam(value = "doc", required = true) doc: kotlin.String,
        @Parameter(description = "Return Topics") @Valid @RequestParam(value = "return_topics", required = false) returnTopics: kotlin.Boolean?,
        @Parameter(description = "Limit") @Valid @RequestParam(value = "limit", required = false) limit: kotlin.Int?,
        @Parameter(description = "Offset") @Valid @RequestParam(value = "offset", required = false) offset: kotlin.Int?
    ): ResponseEntity<OrsonAiProtoResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Find images",
        operationId = "aiFindImages",
        description = """Returns a list of URIs of images that match the text.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = OrsonAiProtoResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/orson/ai/img"
        value = [PATH_AI_FIND_IMAGES],
        produces = ["*/*"]
    )
    fun aiFindImages(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "Sirqul Account Id", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "Text", required = true) @Valid @RequestParam(value = "text", required = true) text: kotlin.String,
        @Parameter(description = "Parse Flag") @Valid @RequestParam(value = "parse_flag", required = false) parseFlag: kotlin.String?,
        @Parameter(description = "Fetch Flag") @Valid @RequestParam(value = "fetch_flag", required = false) fetchFlag: kotlin.String?,
        @Parameter(description = "Size") @Valid @RequestParam(value = "size", required = false) size: kotlin.String?
    ): ResponseEntity<OrsonAiProtoResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Search Tags",
        operationId = "aiTags",
        description = """Search the tags column of user provided tags using this endpoint.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = OrsonAiProtoResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/orson/ai/tags"
        value = [PATH_AI_TAGS],
        produces = ["*/*"]
    )
    fun aiTags(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "Sirqul Account Id", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "Tags", required = true) @Valid @RequestParam(value = "tags", required = true) tags: kotlin.String,
        @Parameter(description = "Conditional") @Valid @RequestParam(value = "conditional", required = false) conditional: kotlin.String?,
        @Parameter(description = "Limit") @Valid @RequestParam(value = "limit", required = false) limit: kotlin.Int?,
        @Parameter(description = "Offset") @Valid @RequestParam(value = "offset", required = false) offset: kotlin.Int?
    ): ResponseEntity<OrsonAiProtoResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Search Text",
        operationId = "aiText",
        description = """Search the movie text column of movie text using this endpoint.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = OrsonAiProtoResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/orson/ai/text"
        value = [PATH_AI_TEXT],
        produces = ["*/*"]
    )
    fun aiText(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "Sirqul Account Id", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "Terms", required = true) @Valid @RequestParam(value = "terms", required = true) terms: kotlin.String,
        @Parameter(description = "Conditional") @Valid @RequestParam(value = "conditional", required = false) conditional: kotlin.String?,
        @Parameter(description = "Limit") @Valid @RequestParam(value = "limit", required = false) limit: kotlin.Int?,
        @Parameter(description = "Offset") @Valid @RequestParam(value = "offset", required = false) offset: kotlin.Int?
    ): ResponseEntity<OrsonAiProtoResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Invite to Contest",
        operationId = "albumContestInvite",
        description = """Allows a user to invite people to gain access to a contest. This will generate an invite token, which when used, will give the invitee access to a contest (whether it is private or not). The invitee will also become the user's friend when the invitation is accepted.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = InviteResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/invite/albumContest"
        value = [PATH_ALBUM_CONTEST_INVITE],
        produces = ["*/*"]
    )
    fun albumContestInvite(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "a unique ID given by the device (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "the account ID of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "This parameter is deprecated.") @Valid @RequestParam(value = "appId", required = false) appId: kotlin.Long?,
        @Parameter(description = "the application key") @Valid @RequestParam(value = "appKey", required = false) appKey: kotlin.String?,
        @Parameter(description = "the album contest to share") @Valid @RequestParam(value = "albumContestId", required = false) albumContestId: kotlin.Long?,
        @Parameter(description = "the current latitude of the user") @Valid @RequestParam(value = "latitude", required = false) latitude: kotlin.Double?,
        @Parameter(description = "the current longitude of the user") @Valid @RequestParam(value = "longitude", required = false) longitude: kotlin.Double?
    ): ResponseEntity<InviteResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Invite to Collection",
        operationId = "albumInvite",
        description = """Allows a user to invite people to gain access to a collection. This will generate an invite token, which when used, will give the invitee access to a collection (whether it is private or not). The invitee will also become the user's friend when the invitation is accepted.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = InviteResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/invite/album"
        value = [PATH_ALBUM_INVITE],
        produces = ["*/*"]
    )
    fun albumInvite(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "a unique ID given by the device (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "the account ID of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "This parameter is deprecated.") @Valid @RequestParam(value = "appId", required = false) appId: kotlin.Long?,
        @Parameter(description = "the application key") @Valid @RequestParam(value = "appKey", required = false) appKey: kotlin.String?,
        @Parameter(description = "the album to share") @Valid @RequestParam(value = "albumId", required = false) albumId: kotlin.Long?,
        @Parameter(description = "the current latitude of the user") @Valid @RequestParam(value = "latitude", required = false) latitude: kotlin.Double?,
        @Parameter(description = "the current longitude of the user") @Valid @RequestParam(value = "longitude", required = false) longitude: kotlin.Double?
    ): ResponseEntity<InviteResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Searches an Achievement Tier",
        operationId = "apiVersionAchievementTierSearchPost",
        description = """Searches a tier of an achievement (for developer/retailer use). User must have permissions to the application the achievement is created for.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = AchievementTierResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/achievement/tier/search"
        value = [PATH_API_VERSION_ACHIEVEMENT_TIER_SEARCH_POST],
        produces = ["*/*"]
    )
    fun apiVersionAchievementTierSearchPost(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "a unique id given by the device (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "the account id of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "the application key") @Valid @RequestParam(value = "appKey", required = false) appKey: kotlin.String?,
        @Parameter(description = "the keyword used to filter resutls with (this returns results that have the keyword in the title or the description of the achievement tier)") @Valid @RequestParam(value = "keyword", required = false) keyword: kotlin.String?,
        @Parameter(description = "filter results by achievementType (these are exact case sensitive matches)") @Valid @RequestParam(value = "achievementType", required = false) achievementType: kotlin.Long?,
        @Parameter(description = "filter results by the rankType (these are the exact case sensitive matches)") @Valid @RequestParam(value = "rankType", required = false) rankType: kotlin.String?,
        @Parameter(description = "the field to sort by. See {@link AchievementApiMap}") @Valid @RequestParam(value = "sortField", required = false) sortField: kotlin.String?,
        @Parameter(description = "determines whether the sort list is in descending or ascending order (of the achievement)") @Valid @RequestParam(value = "descending", required = false) descending: kotlin.Boolean?,
        @Parameter(description = "determines whether the results are in descending or ascending order by the tier goal count (after the initial sort on the achievement)") @Valid @RequestParam(value = "descendingGoal", required = false) descendingGoal: kotlin.Boolean?,
        @Parameter(description = "The start of the index for pagination") @Valid @RequestParam(value = "start", required = false) start: kotlin.Long?,
        @Parameter(description = "the limit for pagination (has a hard limit of 1000)") @Valid @RequestParam(value = "limit", required = false) limit: kotlin.Long?
    ): ResponseEntity<AchievementTierResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Approve Album",
        operationId = "approveAlbum",
        description = """Sets the approval status of an Album.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/album/approve"
        value = [PATH_APPROVE_ALBUM],
        produces = ["*/*"]
    )
    fun approveAlbum(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The ID of the album", required = true) @Valid @RequestParam(value = "albumId", required = true) albumId: kotlin.Long,
        @Parameter(description = "A unique ID given by the device (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "The account ID of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "The approval status to set {PENDING, REJECTED, APPROVED, FEATURED}", schema = Schema(allowableValues = ["PENDING", "REJECTED", "APPROVED", "FEATURED"])) @Valid @RequestParam(value = "approvalStatus", required = false) approvalStatus: kotlin.String?,
        @Parameter(description = "Sets whether the album should be marked as \"verified\"") @Valid @RequestParam(value = "verified", required = false) verified: kotlin.Boolean?
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Approve Contest",
        operationId = "approveAlbumContest",
        description = """Sets the approval status of a contest.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/consumer/album/contest/approve"
        value = [PATH_APPROVE_ALBUM_CONTEST],
        produces = ["*/*"]
    )
    fun approveAlbumContest(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The ID of the album contest", required = true) @Valid @RequestParam(value = "albumContestId", required = true) albumContestId: kotlin.Long,
        @NotNull @Parameter(description = "The approval status to set {PENDING, REJECTED, APPROVED, FEATURED}", required = true, schema = Schema(allowableValues = ["PENDING", "REJECTED", "APPROVED", "FEATURED"])) @Valid @RequestParam(value = "approvalStatus", required = true) approvalStatus: kotlin.String,
        @Parameter(description = "A unique ID given by the device (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "The account ID of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Approve Permissionable",
        operationId = "approvePermissionable",
        description = """Sets the approval status of a permissionable object.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/permissionable/approve"
        value = [PATH_APPROVE_PERMISSIONABLE],
        produces = ["*/*"]
    )
    fun approvePermissionable(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The permissionable type of the object", required = true, schema = Schema(allowableValues = ["ACCOUNT", "GAMELEVEL", "ALBUM_CONTEST", "THEME_DESCRIPTOR", "SCHEDULED_NOTIFICATION", "TASK", "TRIGGER"])) @Valid @RequestParam(value = "permissionableType", required = true) permissionableType: kotlin.String,
        @NotNull @Parameter(description = "The id of the permissionable object", required = true) @Valid @RequestParam(value = "permissionableId", required = true) permissionableId: kotlin.Long,
        @Parameter(description = "A unique ID given by the device (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "The account ID of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "The approval status to set {PENDING, REJECTED, APPROVED, FEATURED}", schema = Schema(allowableValues = ["PENDING", "REJECTED", "APPROVED", "FEATURED"], defaultValue = "APPROVED")) @Valid @RequestParam(value = "approvalStatus", required = false, defaultValue = "APPROVED") approvalStatus: kotlin.String
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Approve Route",
        operationId = "approveRoute",
        description = """Approve a route""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = Route::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/route/{routeId}/approve"
        value = [PATH_APPROVE_ROUTE],
        produces = ["*/*"]
    )
    fun approveRoute(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "the id of the route to approve", required = true) @PathVariable("routeId") routeId: kotlin.Long
    ): ResponseEntity<Route> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Download Asset",
        operationId = "assetDownload",
        description = """Downloads an asset from the server for assets that have been uploaded to the server.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/asset/download/{filename}"
        value = [PATH_ASSET_DOWNLOAD],
        produces = ["*/*"]
    )
    fun assetDownload(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Pattern(regexp=".+") @Parameter(description = "the filename in the following formats: {assetId}-{suffix}.{extension} | {assetId}.{extension} | {assetId}", required = true) @PathVariable("filename") filename: kotlin.String
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Convert Offer to Creative",
        operationId = "assetMorph",
        description = """Converts an offer image + text into a creative image.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = AssetShortResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/asset/morph"
        value = [PATH_ASSET_MORPH],
        produces = ["*/*"]
    )
    fun assetMorph(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "offer id used for inserting offer text/flavor", required = true) @Valid @RequestParam(value = "offerId", required = true) offerId: kotlin.Long,
        @NotNull @Parameter(description = "the ad size used for selecting a format for the creative image", required = true, schema = Schema(allowableValues = ["CONFIG", "BANNER", "LEADERBOARD", "SKYSCRAPER", "VIDEO", "ZIP", "INTERSTITIAL", "CUSTOM1", "CUSTOM2", "CUSTOM3", "CUSTOM4", "CUSTOM5", "CUSTOM6", "CUSTOM7", "CUSTOM8", "CUSTOM9", "CUSTOM10"])) @Valid @RequestParam(value = "adSize", required = true) adSize: kotlin.String,
        @Parameter(description = "used for inserting the newly created image into") @Valid @RequestParam(value = "creativeId", required = false) creativeId: kotlin.Long?,
        @Parameter(description = "total width of the creative image") @Valid @RequestParam(value = "width", required = false) width: kotlin.Int?,
        @Parameter(description = "total height of the creative image") @Valid @RequestParam(value = "height", required = false) height: kotlin.Int?,
        @Parameter(description = "the size of the background") @Valid @RequestParam(value = "backgroundSize", required = false) backgroundSize: kotlin.String?,
        @Parameter(description = "the template to use") @Valid @RequestParam(value = "template", required = false) template: kotlin.String?
    ): ResponseEntity<AssetShortResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Search Assignment Assignees",
        operationId = "assigmentAssigneeAccountSearch",
        description = """Search for avaiable users for creating or updating assignment.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(array = ArraySchema(schema = Schema(implementation = AccountMiniResponse::class)))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/assignment/assignee/search"
        value = [PATH_ASSIGMENT_ASSIGNEE_ACCOUNT_SEARCH],
        produces = ["*/*"]
    )
    fun assigmentAssigneeAccountSearch(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The account id sending the request", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @Parameter(description = "The keyword to filter the returned results") @Valid @RequestParam(value = "keyword", required = false) keyword: kotlin.String?
    ): ResponseEntity<List<AccountMiniResponse>> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Assign Employee",
        operationId = "assignEmployee",
        description = """Assign An existing account to be an employee""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = EmployeeResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/employee/assign"
        value = [PATH_ASSIGN_EMPLOYEE],
        produces = ["*/*"]
    )
    fun assignEmployee(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The account id of the logged in user", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "The account id of the manager to assign under", required = true) @Valid @RequestParam(value = "managerAccountId", required = true) managerAccountId: kotlin.Long,
        @NotNull @Parameter(description = "The account id of the user to be assigned as employee", required = true) @Valid @RequestParam(value = "employeeAccountId", required = true) employeeAccountId: kotlin.Long,
        @Parameter(description = "The role to assign to the employee (e.g. RETAILER or RETAILER_LIMITED)") @Valid @RequestParam(value = "role", required = false) role: kotlin.String?
    ): ResponseEntity<EmployeeResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Assign Employee to Location",
        operationId = "assignToLocationEmployee",
        description = """Assign or unassign the account to a retailer location.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/employee/assignToLocation"
        value = [PATH_ASSIGN_TO_LOCATION_EMPLOYEE],
        produces = ["*/*"]
    )
    fun assignToLocationEmployee(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The account id of the logged in user", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "The retailer location to apply the change to", required = true) @Valid @RequestParam(value = "retailerLocationId", required = true) retailerLocationId: kotlin.Long,
        @Parameter(description = "The account id of the user to apply the change to") @Valid @RequestParam(value = "employeeAccountId", required = false) employeeAccountId: kotlin.Long?,
        @Parameter(description = "If true (default) assign to the location, otherwise remove from the retailer", schema = Schema(defaultValue = "true")) @Valid @RequestParam(value = "assign", required = false, defaultValue = "true") assign: kotlin.Boolean
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Create Assignment",
        operationId = "assignmentCreate",
        description = """Create an assignment.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = AssignmentResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/assignment/create"
        value = [PATH_ASSIGNMENT_CREATE],
        produces = ["*/*"]
    )
    fun assignmentCreate(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the user account id", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "the name for the assignment", required = true) @Valid @RequestParam(value = "name", required = true) name: kotlin.String,
        @NotNull @Parameter(description = "the account id to assign to", required = true) @Valid @RequestParam(value = "assigneeAccountId", required = true) assigneeAccountId: kotlin.Long,
        @Parameter(description = "the desciprtion for the assignment") @Valid @RequestParam(value = "description", required = false) description: kotlin.String?,
        @Parameter(description = "the retailer location id") @Valid @RequestParam(value = "retailerLocationId", required = false) retailerLocationId: kotlin.Long?,
        @Parameter(description = "the tags") @Valid @RequestParam(value = "tags", required = false) tags: kotlin.String?,
        @Parameter(description = "determines whether the assignment is active or inactive") @Valid @RequestParam(value = "active", required = false) active: kotlin.Boolean?
    ): ResponseEntity<AssignmentResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Delete Assignment",
        operationId = "assignmentDelete",
        description = """Delete an assignment.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/assignment/delete"
        value = [PATH_ASSIGNMENT_DELETE],
        produces = ["*/*"]
    )
    fun assignmentDelete(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the user account id", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "the assignment id", required = true) @Valid @RequestParam(value = "assignmentId", required = true) assignmentId: kotlin.Long
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get Assignment",
        operationId = "assignmentGet",
        description = """Get the details of an assignment.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = AssignmentResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/assignment/get"
        value = [PATH_ASSIGNMENT_GET],
        produces = ["*/*"]
    )
    fun assignmentGet(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the user account id", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "the assignment id", required = true) @Valid @RequestParam(value = "assignmentId", required = true) assignmentId: kotlin.Long
    ): ResponseEntity<AssignmentResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Search Assignments",
        operationId = "assignmentSearch",
        description = """Search for assignments by the given parameters.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(array = ArraySchema(schema = Schema(implementation = AssignmentResponse::class)))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/assignment/search"
        value = [PATH_ASSIGNMENT_SEARCH],
        produces = ["*/*"]
    )
    fun assignmentSearch(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the account sending the request", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "sort by table field", required = true, schema = Schema(allowableValues = ["ID", "CREATED", "UPDATED", "DELETED", "SEARCH_TAGS", "ACTIVE", "ASSIGNEE_ID", "CREATOR_ID", "LOCATION_ID", "LOCATION_NAME", "CURRENT_STATUS", "CURRENT_STATUS_TYPE", "STATUSES"])) @Valid @RequestParam(value = "sortField", required = true) sortField: kotlin.String,
        @NotNull @Parameter(description = "return results in descending order or not", required = true) @Valid @RequestParam(value = "descending", required = true) descending: kotlin.Boolean,
        @NotNull @Parameter(description = "return active results only or not", required = true) @Valid @RequestParam(value = "activeOnly", required = true) activeOnly: kotlin.Boolean,
        @NotNull @Parameter(description = "The record to begin the return set on", required = true) @Valid @RequestParam(value = "start", required = true) start: kotlin.Int,
        @NotNull @Parameter(description = "The number of records to return", required = true) @Valid @RequestParam(value = "limit", required = true) limit: kotlin.Int,
        @Parameter(description = "the creator of the assignment") @Valid @RequestParam(value = "creatorAccountId", required = false) creatorAccountId: kotlin.Long?,
        @Parameter(description = "filter results by assignee accounts. If not provided, all assignments that are assigned to accounts that are managed by the requested account will be returned.") @Valid @RequestParam(value = "assigneeAccountIds", required = false) assigneeAccountIds: kotlin.String?,
        @Parameter(description = "filter results by retailer locations") @Valid @RequestParam(value = "retailerLocationIds", required = false) retailerLocationIds: kotlin.String?,
        @Parameter(description = "filter results by assignment status", schema = Schema(allowableValues = ["NEW", "IN_PROGRESS", "SUBSCRIBED", "ARCHIVED"])) @Valid @RequestParam(value = "currentStatusType", required = false) currentStatusType: kotlin.String?,
        @Parameter(description = "filter results by keyword search that matches the assignee, creator, or retailer location name") @Valid @RequestParam(value = "keyword", required = false) keyword: kotlin.String?
    ): ResponseEntity<List<AssignmentResponse>> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Create Assignment Status",
        operationId = "assignmentStatusCreate",
        description = """Create an assignment status.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = AssignmentStatusResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/assignment/status/create"
        value = [PATH_ASSIGNMENT_STATUS_CREATE],
        produces = ["*/*"]
    )
    fun assignmentStatusCreate(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the user account id", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "the assignment id", required = true) @Valid @RequestParam(value = "assignmentId", required = true) assignmentId: kotlin.Long,
        @Parameter(description = "the scheduled notification id for reminders") @Valid @RequestParam(value = "scheduledNotificationId", required = false) scheduledNotificationId: kotlin.Long?,
        @Parameter(description = "the type of to do. Possible values include: SITE_VISIT, PHONE, RECONTACT, RENEWAL, CREDIT", schema = Schema(allowableValues = ["SITE_VISIT", "PHONE", "RECONTACT", "RENEWAL", "CREDIT"])) @Valid @RequestParam(value = "toDo", required = false) toDo: kotlin.String?,
        @Parameter(description = "the connection type. Possible values include: INITIAL, FOLLOW_UP, DECLINED", schema = Schema(allowableValues = ["INITIAL", "FOLLOW_UP", "DECLINED"])) @Valid @RequestParam(value = "connection", required = false) connection: kotlin.String?,
        @Parameter(description = "the communication method type. Possible values include: PHONE, SITE_VISIT, EMAIL", schema = Schema(allowableValues = ["PHONE", "SITE_VISIT", "EMAIL"])) @Valid @RequestParam(value = "method", required = false) method: kotlin.String?,
        @Parameter(description = "the status type. Possible values include: ARCHIVED, SUBSCRIBED, UNSUBSCRIBED, CONTACTED, DECLINED, NOT_CONTACTED", schema = Schema(allowableValues = ["ARCHIVED", "SUBSCRIBED", "UNSUBSCRIBED", "CONTACTED", "DECLINED", "NOT_CONTACTED"])) @Valid @RequestParam(value = "status", required = false) status: kotlin.String?,
        @Parameter(description = "the closure type. Possible values include: PHONE, SITE_VISIT, PHONE_SITE, WEB", schema = Schema(allowableValues = ["PHONE", "SITE_VISIT", "PHONE_SITE", "WEB"])) @Valid @RequestParam(value = "closure", required = false) closure: kotlin.String?,
        @Parameter(description = "the message from the assignee") @Valid @RequestParam(value = "message", required = false) message: kotlin.String?,
        @Parameter(description = "the date to follow up by") @Valid @RequestParam(value = "followUp", required = false) followUp: kotlin.Long?,
        @Parameter(description = "determines whether the assignment status is active or inactive") @Valid @RequestParam(value = "active", required = false) active: kotlin.Boolean?
    ): ResponseEntity<AssignmentStatusResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Deletes Assignment Status",
        operationId = "assignmentStatusDelete",
        description = """Deletes an assignment status.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/assignment/status/delete"
        value = [PATH_ASSIGNMENT_STATUS_DELETE],
        produces = ["*/*"]
    )
    fun assignmentStatusDelete(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the user account id", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "the assignment status id", required = true) @Valid @RequestParam(value = "assignmentStatusId", required = true) assignmentStatusId: kotlin.Long
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get Assignment Status",
        operationId = "assignmentStatusGet",
        description = """Get an assignment status.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = AssignmentStatusResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/assignment/status/get"
        value = [PATH_ASSIGNMENT_STATUS_GET],
        produces = ["*/*"]
    )
    fun assignmentStatusGet(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the user account id", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "the assignment status id", required = true) @Valid @RequestParam(value = "assignmentStatusId", required = true) assignmentStatusId: kotlin.Long
    ): ResponseEntity<AssignmentStatusResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Search Assignment Statuses",
        operationId = "assignmentStatusSearch",
        description = """Search on assignment statuses.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(array = ArraySchema(schema = Schema(implementation = AssignmentStatusResponse::class)))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/assignment/status/search"
        value = [PATH_ASSIGNMENT_STATUS_SEARCH],
        produces = ["*/*"]
    )
    fun assignmentStatusSearch(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the user account id", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "the field to sort by. Possible values include: ID, CREATED, UPDATED, DELETED, SEARCH_TAGS, ACTIVE, CURRENT_STATUS, TODO, CONNECTION, METHOD, STATUS, CLOSURE, MESSAGE, FOLLOW_UP", required = true, schema = Schema(allowableValues = ["ID", "CREATED", "UPDATED", "DELETED", "SEARCH_TAGS", "ACTIVE", "ASSIGNEE_ID", "CREATOR_ID", "LOCATION_ID", "LOCATION_NAME", "CURRENT_STATUS", "CURRENT_STATUS_TYPE", "TODO", "CONNECTION", "METHOD", "STATUS", "CLOSURE", "MESSAGE", "FOLLOW_UP"])) @Valid @RequestParam(value = "sortField", required = true) sortField: kotlin.String,
        @NotNull @Parameter(description = "determines whether the sorted list is in descending or ascending order", required = true) @Valid @RequestParam(value = "descending", required = true) descending: kotlin.Boolean,
        @NotNull @Parameter(description = "determines whether to only return active results", required = true) @Valid @RequestParam(value = "activeOnly", required = true) activeOnly: kotlin.Boolean,
        @NotNull @Parameter(description = "the start index for pagination", required = true) @Valid @RequestParam(value = "start", required = true) start: kotlin.Int,
        @NotNull @Parameter(description = "the limit for pagination", required = true) @Valid @RequestParam(value = "limit", required = true) limit: kotlin.Int,
        @Parameter(description = "the assignment id") @Valid @RequestParam(value = "assignmentId", required = false) assignmentId: kotlin.Long?,
        @Parameter(description = "filter results by the account who created the status") @Valid @RequestParam(value = "creatorAccountId", required = false) creatorAccountId: kotlin.Long?,
        @Parameter(description = "filter results by the assignee account") @Valid @RequestParam(value = "assigneeAccountId", required = false) assigneeAccountId: kotlin.Long?,
        @Parameter(description = "filter results by by retailer location") @Valid @RequestParam(value = "retailerLocationId", required = false) retailerLocationId: kotlin.Long?,
        @Parameter(description = "filter results by the status type", schema = Schema(allowableValues = ["ARCHIVED", "SUBSCRIBED", "UNSUBSCRIBED", "CONTACTED", "DECLINED", "NOT_CONTACTED"])) @Valid @RequestParam(value = "statusType", required = false) statusType: kotlin.String?,
        @Parameter(description = "filter results by keyword search") @Valid @RequestParam(value = "keyword", required = false) keyword: kotlin.String?
    ): ResponseEntity<List<AssignmentStatusResponse>> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Update Assignment Status",
        operationId = "assignmentStatusUpdate",
        description = """Updates an assignment status.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = AssignmentStatusResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/assignment/status/update"
        value = [PATH_ASSIGNMENT_STATUS_UPDATE],
        produces = ["*/*"]
    )
    fun assignmentStatusUpdate(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the user account id", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "the assignment status id", required = true) @Valid @RequestParam(value = "assignmentStatusId", required = true) assignmentStatusId: kotlin.Long,
        @Parameter(description = "the scheduled notification id for reminders") @Valid @RequestParam(value = "scheduledNotificationId", required = false) scheduledNotificationId: kotlin.Long?,
        @Parameter(description = "the type of to do. Possible values include: SITE_VISIT, PHONE, RECONTACT, RENEWAL, CREDIT", schema = Schema(allowableValues = ["SITE_VISIT", "PHONE", "RECONTACT", "RENEWAL", "CREDIT"])) @Valid @RequestParam(value = "toDo", required = false) toDo: kotlin.String?,
        @Parameter(description = "the connection type. Possible values include: INITIAL, FOLLOW_UP, DECLINED", schema = Schema(allowableValues = ["INITIAL", "FOLLOW_UP", "DECLINED"])) @Valid @RequestParam(value = "connection", required = false) connection: kotlin.String?,
        @Parameter(description = "the communication method type. Possible values include: PHONE, SITE_VISIT, EMAIL", schema = Schema(allowableValues = ["PHONE", "SITE_VISIT", "EMAIL"])) @Valid @RequestParam(value = "method", required = false) method: kotlin.String?,
        @Parameter(description = "the status type. Possible values include: ARCHIVED, SUBSCRIBED, UNSUBSCRIBED, CONTACTED, DECLINED, NOT_CONTACTED", schema = Schema(allowableValues = ["ARCHIVED", "SUBSCRIBED", "UNSUBSCRIBED", "CONTACTED", "DECLINED", "NOT_CONTACTED"])) @Valid @RequestParam(value = "status", required = false) status: kotlin.String?,
        @Parameter(description = "the closure type. Possible values include: PHONE, SITE_VISIT, PHONE_SITE, WEB", schema = Schema(allowableValues = ["PHONE", "SITE_VISIT", "PHONE_SITE", "WEB"])) @Valid @RequestParam(value = "closure", required = false) closure: kotlin.String?,
        @Parameter(description = "the message from the assignee") @Valid @RequestParam(value = "message", required = false) message: kotlin.String?,
        @Parameter(description = "the date to follow up by") @Valid @RequestParam(value = "followUp", required = false) followUp: kotlin.Long?,
        @Parameter(description = "determines whether the assignment status is active or inactive") @Valid @RequestParam(value = "active", required = false) active: kotlin.Boolean?
    ): ResponseEntity<AssignmentStatusResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Update Assignment",
        operationId = "assignmentUpdate",
        description = """Updates an assignment.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = AssignmentResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/assignment/update"
        value = [PATH_ASSIGNMENT_UPDATE],
        produces = ["*/*"]
    )
    fun assignmentUpdate(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the user account id", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "the assignment id", required = true) @Valid @RequestParam(value = "assignmentId", required = true) assignmentId: kotlin.Long,
        @Parameter(description = "the name of the assignment") @Valid @RequestParam(value = "name", required = false) name: kotlin.String?,
        @Parameter(description = "the description of the assignment") @Valid @RequestParam(value = "description", required = false) description: kotlin.String?,
        @Parameter(description = "the account id to assign to") @Valid @RequestParam(value = "assigneeAccountId", required = false) assigneeAccountId: kotlin.Long?,
        @Parameter(description = "the retailer location id") @Valid @RequestParam(value = "retailerLocationId", required = false) retailerLocationId: kotlin.Long?,
        @Parameter(description = "the tags") @Valid @RequestParam(value = "tags", required = false) tags: kotlin.String?,
        @Parameter(description = "determines whether the assignment is active or inactive") @Valid @RequestParam(value = "active", required = false) active: kotlin.Boolean?
    ): ResponseEntity<AssignmentResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Attend Event",
        operationId = "attendEvent",
        description = """ Specify whether the user is attending an event at a particular location. This can also be used as a "check-in" action.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = OfferResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/event/attend"
        value = [PATH_ATTEND_EVENT],
        produces = ["*/*"]
    )
    fun attendEvent(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "The device id (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "The account id (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "The application of where to send notifications about the attend action") @Valid @RequestParam(value = "appKey", required = false) appKey: kotlin.String?,
        @Parameter(description = "The scheduled broadcast or marketing experience id") @Valid @RequestParam(value = "listingId", required = false) listingId: kotlin.Long?,
        @Parameter(description = "The retailer location where the event is being held") @Valid @RequestParam(value = "retailerLocationId", required = false) retailerLocationId: kotlin.Long?,
        @Parameter(description = "The actual event being held") @Valid @RequestParam(value = "offerLocationId", required = false) offerLocationId: kotlin.Long?,
        @Parameter(description = "The wallet item to update the status of, if provided then ignore the listingId, retailerLocationId, and the offerLocationId") @Valid @RequestParam(value = "transactionId", required = false) transactionId: kotlin.Long?,
        @Parameter(description = "Sets whether the user is: undecided (0), attending (1), attending and checked in (2), or not attending (3)") @Valid @RequestParam(value = "status", required = false) status: kotlin.Int?,
        @Parameter(description = "The location of the status update") @Valid @RequestParam(value = "latitude", required = false) latitude: kotlin.Double?,
        @Parameter(description = "The location of the status update") @Valid @RequestParam(value = "longitude", required = false) longitude: kotlin.Double?
    ): ResponseEntity<OfferResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Authorize Twitter",
        operationId = "authorizeTwitter",
        description = """Makes an authorization call to twitter for a user to login and allow any app permissions.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/twitter/authorize"
        value = [PATH_AUTHORIZE_TWITTER],
        produces = ["*/*"]
    )
    fun authorizeTwitter(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the application key", required = true) @Valid @RequestParam(value = "appKey", required = true) appKey: kotlin.String
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Batch Analysis",
        operationId = "batch",
        description = """Run several types of analysis on an audio or video file in a single API call, instead of calling several operations for the same file..""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = OrsonAiBatchResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/orson/ai/batch"
        value = [PATH_BATCH],
        produces = ["*/*"]
    )
    fun batch(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "Sirqul Account Id", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @Parameter(description = "A third-party account id that is meaningful to your systems") @Valid @RequestParam(value = "thirdPartyAccountId", required = false) thirdPartyAccountId: kotlin.String?,
        @Parameter(description = "The number of topics to return") @Valid @RequestParam(value = "limit", required = false) limit: kotlin.Int?,
        @Parameter(description = "The comma-delimited list of A/V batch analysis operations to run on this file. Possible values: Transcript,Topics,Emotions") @Valid @RequestParam(value = "operations", required = false) operations: kotlin.String?,
        @Parameter(description = "An uploaded recording to analyze (Currently limited to 10MB)") @Valid @RequestParam(value = "file", required = false) file: org.springframework.web.multipart.MultipartFile,
        @Parameter(description = "A recording file to download and analyze (Size limit: 1GB)") @Valid @RequestParam(value = "url", required = false) url: kotlin.String?,
        @Parameter(description = "When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open") @Valid @RequestParam(value = "callback", required = false) paramCallback: kotlin.String?
    ): ResponseEntity<OrsonAiBatchResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Batch Note Operation",
        operationId = "batchOperation",
        description = """Perform a batch operation on notes for a notable object (for example: DELETE_ALL_NOTES_IN_NOTABLE).
""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/note/batch"
        value = [PATH_BATCH_OPERATION],
        produces = ["*/*"]
    )
    fun batchOperation(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The id of the notable object the batch operation will affect", required = true) @Valid @RequestParam(value = "notableId", required = true) notableId: kotlin.Long,
        @NotNull @Parameter(description = "The notable object type (for example ALBUM, ASSET, OFFER, etc.)", required = true) @Valid @RequestParam(value = "notableType", required = true) notableType: kotlin.String,
        @Parameter(description = "The device id (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "The account id of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "The batch operation to perform (e.g., DELETE_ALL_NOTES_IN_NOTABLE). Optional.") @Valid @RequestParam(value = "batchOperation", required = false) batchOperation: kotlin.String?
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Create Batch Tracking",
        operationId = "batchSaveTracking",
        description = """Batch create tracking legs""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(array = ArraySchema(schema = Schema(implementation = Leg::class)))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/tracking/batch/create"
        value = [PATH_BATCH_SAVE_TRACKING],
        produces = ["*/*"]
    )
    fun batchSaveTracking(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "JSON array of tracking legs ```json [   \"distance\": \"0.08\",   \"duration\": \"10000\",   \"startLatitude\": \"47.614603\",   \"startLongitude\": \"-122.350518\",   \"endLatitude\": \"47.614384\",   \"endLongitude\": \"-122.349161\",   \"startDate\": \"1361924010000\",   \"endDate\": \"1361924020000\",   \"steps\": [     {       \"distance\": \"0.03\",       \"duration\": \"5000\",       \"startLat\": \"47.614603\",       \"startLng\": \"-122.350518\",       \"startDate\": \"1361924010000\",       \"endLat\": \"47.614941\",       \"endLng\": \"-122.350062\",       \"endDate\": \"1361924015000\"     },{       \"distance\": \"0.05\",       \"duration\": \"5000\",       \"startLat\": \"47.614941\",       \"startLng\": \"-122.350062\",       \"startDate\": \"1361924015000\",       \"endLat\": \"47.614384\",       \"endLng\": \"-122.349161\",       \"endDate\": \"1361924020000\"     }   ] ] ``` ", required = true) @Valid @RequestParam(value = "data", required = true) `data`: kotlin.String,
        @Parameter(description = "the device id (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "the account id of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "Whether to generate accounts for tracking entries when the owner does not exist") @Valid @RequestParam(value = "generateAccounts", required = false) generateAccounts: kotlin.Boolean?,
        @Parameter(description = "Whether to update the account's current location from the incoming tracking data") @Valid @RequestParam(value = "updateAccountLocations", required = false) updateAccountLocations: kotlin.Boolean?,
        @Parameter(description = "The default tag to apply to incoming legs when no tag is provided", schema = Schema(defaultValue = "PASSIVE")) @Valid @RequestParam(value = "defaultTag", required = false, defaultValue = "PASSIVE") defaultTag: kotlin.String,
        @Parameter(description = "") @Valid @RequestParam(value = "slaveUID", required = false) slaveUID: kotlin.String?
    ): ResponseEntity<List<Leg>> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Update Offer Locations",
        operationId = "batchUpdateOfferLocations",
        description = """Batch update offer locations.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/retailer/offer/location/batchUpdate"
        value = [PATH_BATCH_UPDATE_OFFER_LOCATIONS],
        produces = ["*/*"]
    )
    fun batchUpdateOfferLocations(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "JSON string in the following format: ```json [{   \"offerLocationId\": 1705,   \"latitude\": 54.0,   \"longitude\": -122.0,   \"altitude\": 1.0,   \"locationDetail\": \"floor 1\",   \"locationDescription\": \"behind the Coke sign\" }, {   \"offerLocationId\": 1704,   \"latitude\": 54.1,   \"longitude\": -122.1 }] ``` ", required = true) @Valid @RequestParam(value = "data", required = true) `data`: kotlin.String,
        @Parameter(description = "The device id (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "The account id of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Block Account",
        operationId = "blockAccount",
        description = """Moves or removes an account into the user's blocked group.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/account/block"
        value = [PATH_BLOCK_ACCOUNT],
        produces = ["*/*"]
    )
    fun blockAccount(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The id of the account to be blocked/unblocked", required = true) @Valid @RequestParam(value = "accountIdBeingBlocked", required = true) accountIdBeingBlocked: kotlin.Long,
        @Parameter(description = "The device id (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "The account id of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "Determines whether the account is blocked or unblocked", schema = Schema(defaultValue = "true")) @Valid @RequestParam(value = "blockFlagValue", required = false, defaultValue = "true") blockFlagValue: kotlin.Boolean,
        @Parameter(description = "Determines whether the account is removed from all other groups if blocked", schema = Schema(defaultValue = "false")) @Valid @RequestParam(value = "removeFromGroupsIfBlocked", required = false, defaultValue = "false") removeFromGroupsIfBlocked: kotlin.Boolean,
        @Parameter(description = "The current latitude of the user") @Valid @RequestParam(value = "latitude", required = false) latitude: kotlin.Double?,
        @Parameter(description = "The current longitude of the user") @Valid @RequestParam(value = "longitude", required = false) longitude: kotlin.Double?
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Create Trilateration Data with File",
        operationId = "cacheTrilaterationData",
        description = """Creates trilateration samples for a source device (i.e. a router).""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/location/trilaterate/cache"
        value = [PATH_CACHE_TRILATERATION_DATA],
        produces = ["*/*"]
    )
    fun cacheTrilaterationData(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The unique identifier of the source device", required = true) @Valid @RequestParam(value = "udid", required = true) udid: kotlin.String,
        @Parameter(description = "The current timestamp of the source device") @Valid @RequestParam(value = "sourceTime", required = false) sourceTime: kotlin.Long?,
        @Parameter(description = "the minimum number of Edysen devices that must be used to be able to trilaterate a device") @Valid @RequestParam(value = "minimumSampleSize", required = false) minimumSampleSize: kotlin.Int?,
        @Parameter(description = "The json formated sample data:  ```json {    \"count\": 2,   \"timespan\": 10,    \"samples\": [     {       \"deviceId\": \"device1\",       \"randomizedId\": true,        \"deviceSignature\": \"probe:xyz...\",        \"alternativeId\":\"adc123\",        \"rssi\": [-63, -75]     },      {       \"deviceId\": \"device2\",       \"randomizedId\": true,        \"deviceSignature\": \"probe:xyz...\",        \"alternativeId\": \"adc123\",        \"rssi\": [-83, -79]     }   ] } ``` ") @Valid @RequestParam(value = "data", required = false) `data`: kotlin.String?,
        @Parameter(description = "Binary file containing data (multipart upload)") @Valid @RequestParam(value = "dataFile", required = false) dataFile: org.springframework.web.multipart.MultipartFile
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Create Trilateration Data with Rest",
        operationId = "cacheTrilaterationDataGzip",
        description = """Creates trilateration samples for a source device (i.e. a router).""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/location/trilaterate/cache/submit"
        value = [PATH_CACHE_TRILATERATION_DATA_GZIP],
        produces = ["*/*"]
    )
    fun cacheTrilaterationDataGzip(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "") @Valid @RequestBody(required = false) body: TrilatCacheRequest?
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Cancel Shipment",
        operationId = "cancelShipment",
        description = """Remove shipment from route""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation") ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/shipment/{id}/cancel"
        value = [PATH_CANCEL_SHIPMENT]
    )
    fun cancelShipment(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "the id of the shipment to cancel", required = true) @PathVariable("id") id: kotlin.Long
    ): ResponseEntity<Unit> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Search Categories by Distance",
        operationId = "categoryDistanceSearch",
        description = """Search for categories by distance.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(array = ArraySchema(schema = Schema(implementation = CategoryResponse::class)))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/category/distancesearch"
        value = [PATH_CATEGORY_DISTANCE_SEARCH],
        produces = ["*/*"]
    )
    fun categoryDistanceSearch(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "The account id of the user") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "The keyword string to search on") @Valid @RequestParam(value = "keyword", required = false) keyword: kotlin.String?,
        @Parameter(description = "the appKey of the application to retrieve categories for, if not specified then search on the global application.") @Valid @RequestParam(value = "appKey", required = false) appKey: kotlin.String?,
        @Parameter(description = "Restrict the search by specific categories") @Valid @RequestParam(value = "categoryIds", required = false) categoryIds: kotlin.String?,
        @Parameter(description = "Restrict the search by specific parent categories so that only its sub children are searched.") @Valid @RequestParam(value = "parentCategoryIds", required = false) parentCategoryIds: kotlin.String?,
        @Parameter(description = "Restrict the search to only those categories with no parent category assigned.") @Valid @RequestParam(value = "rootOnly", required = false) rootOnly: kotlin.Boolean?,
        @Parameter(description = "The column to sort the search on. Possible values include: ID, CREATED, UPDATED, ACTIVE, NAME, DISPLAY", schema = Schema(allowableValues = ["ID", "CREATED", "UPDATED", "DELETED", "SEARCH_TAGS", "ACTIVE", "NAME", "DISPLAY"], defaultValue = "DISPLAY")) @Valid @RequestParam(value = "sortField", required = false, defaultValue = "DISPLAY") sortField: kotlin.String,
        @Parameter(description = "The group of categories to return: ALL, GLOBAL or MINE. ALL returns both global and application specific matches, GLOBAL only returns global matches, and MINE only returns the application specific matches. If not provided search on the application provided.", schema = Schema(allowableValues = ["ALL", "GLOBAL", "MINE"])) @Valid @RequestParam(value = "responseGroup", required = false) responseGroup: kotlin.String?,
        @Parameter(description = "The order to return the search results", schema = Schema(defaultValue = "false")) @Valid @RequestParam(value = "descending", required = false, defaultValue = "false") descending: kotlin.Boolean,
        @Parameter(description = "The record to begin the return set on", schema = Schema(defaultValue = "0")) @Valid @RequestParam(value = "start", required = false, defaultValue = "0") start: kotlin.Int,
        @Parameter(description = "The number of records to return", schema = Schema(defaultValue = "20")) @Valid @RequestParam(value = "limit", required = false, defaultValue = "20") limit: kotlin.Int,
        @Parameter(description = "Determines whether to return only active categories", schema = Schema(defaultValue = "true")) @Valid @RequestParam(value = "activeOnly", required = false, defaultValue = "true") activeOnly: kotlin.Boolean,
        @Parameter(description = "Determines whether to return extra info about the category's \"Participant\" reference") @Valid @RequestParam(value = "returnExternal", required = false) returnExternal: kotlin.Boolean?,
        @Parameter(description = "If true search categories using the exact keyword, if false then do a partial match (like) search.") @Valid @RequestParam(value = "exactMatch", required = false) exactMatch: kotlin.Boolean?,
        @Parameter(description = "Filters results by the Category's type") @Valid @RequestParam(value = "type", required = false) type: kotlin.String?,
        @Parameter(description = "Filters results by externalType") @Valid @RequestParam(value = "externalType", required = false) externalType: kotlin.String?,
        @Parameter(description = "Filters results to only return Categories that have been referenced by a minimum number of Offers") @Valid @RequestParam(value = "minOfferCount", required = false) minOfferCount: kotlin.Int?,
        @Parameter(description = "the latitude of where the search is centered on") @Valid @RequestParam(value = "latitude", required = false) latitude: kotlin.Double?,
        @Parameter(description = "the longitude of where the search is centered on") @Valid @RequestParam(value = "longitude", required = false) longitude: kotlin.Double?,
        @Parameter(description = "the maximum range the category can be from the center") @Valid @RequestParam(value = "range", required = false) range: kotlin.Double?
    ): ResponseEntity<List<CategoryResponse>> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Check Disbursements",
        operationId = "checkDisbursements",
        description = """Checks the status of a captured disbrusement to see if it has been settled.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = DisbursementResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/disbursement/check"
        value = [PATH_CHECK_DISBURSEMENTS],
        produces = ["*/*"]
    )
    fun checkDisbursements(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the ID of the disbursement being checked on", required = true) @Valid @RequestParam(value = "disbursementId", required = true) disbursementId: kotlin.Long
    ): ResponseEntity<DisbursementResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Calculate Path",
        operationId = "computePath",
        description = """Calculates the shortest path from point to point on a grid""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = PathingResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/pathing/compute"
        value = [PATH_COMPUTE_PATH],
        produces = ["*/*"]
    )
    fun computePath(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the data to with start, end point and exclusion points", required = true) @Valid @RequestParam(value = "data", required = true) `data`: kotlin.String,
        @NotNull @Parameter(description = "the system of measurement for directions: {METRIC, IMPERIAL}", required = true, schema = Schema(allowableValues = ["METRIC", "IMPERIAL"])) @Valid @RequestParam(value = "units", required = true) units: kotlin.String,
        @NotNull @Parameter(description = "determines whether to reduce the path to go in diagonal lines", required = true) @Valid @RequestParam(value = "reducePath", required = true) reducePath: kotlin.Boolean,
        @NotNull @Parameter(description = "determines whether to return text directions", required = true) @Valid @RequestParam(value = "directions", required = true) directions: kotlin.Boolean
    ): ResponseEntity<PathingResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Compute Route",
        operationId = "computeRouting",
        description = """This service finds the most optimal routes for delivering items between locations (reducing transit time/resources). It can take in a list of vehicles and a list of items (to be transported).All load items have pick-up and drop-off locations with time windows for when the item is expected to be picked-up and dropped-off. """,
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = RoutingListResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/routing/compute"
        value = [PATH_COMPUTE_ROUTING],
        produces = ["*/*"]
    )
    fun computeRouting(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "Json object containing inputs for generating the routes. See description for more info. Also see RoutingRequest", required = true) @Valid @RequestParam(value = "data", required = true) `data`: kotlin.String
    ): ResponseEntity<RoutingListResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Create Consumer",
        operationId = "consumerCreate",
        description = """Create a connection to an existing amqp queue and register as a consumer.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = QueueResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/queue/consumer/create"
        value = [PATH_CONSUMER_CREATE],
        produces = ["*/*"]
    )
    fun consumerCreate(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The application key to use when creating an analytic or service request. The account needs to have permissions to the applicaton or it will be denied.", required = true) @Valid @RequestParam(value = "appKey", required = true) appKey: kotlin.String,
        @NotNull @Parameter(description = "The name of the queue to connect to", required = true) @Valid @RequestParam(value = "name", required = true) name: kotlin.String,
        @NotNull @Parameter(description = "The hostname of the server the queue is hosted on", required = true) @Valid @RequestParam(value = "hostname", required = true) hostname: kotlin.String,
        @NotNull @Parameter(description = "The username to access the server the queue is hosted on", required = true) @Valid @RequestParam(value = "username", required = true) username: kotlin.String,
        @NotNull @Parameter(description = "The password to access the queue to connect to", required = true) @Valid @RequestParam(value = "password", required = true) password: kotlin.String,
        @NotNull @Parameter(description = "The data mapping information in the format of AMQPRequest", required = true) @Valid @RequestParam(value = "dataMapping", required = true) dataMapping: kotlin.String,
        @Parameter(description = "The client deviceID") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "The logged in user ID") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "The port of the server the queue is hosted on", schema = Schema(defaultValue = "5672")) @Valid @RequestParam(value = "port", required = false, defaultValue = "5672") port: kotlin.Int,
        @Parameter(description = "The virtual host defined on the server the queue is associated on") @Valid @RequestParam(value = "virtualHost", required = false) virtualHost: kotlin.String?,
        @Parameter(description = "The exchanger of the queue to connect to") @Valid @RequestParam(value = "exchanger", required = false) exchanger: kotlin.String?,
        @Parameter(description = "The exchanger type of the queue to connect to") @Valid @RequestParam(value = "exchangerType", required = false) exchangerType: kotlin.String?,
        @Parameter(description = "The number of workers to generate ", schema = Schema(defaultValue = "1")) @Valid @RequestParam(value = "workers", required = false, defaultValue = "1") workers: kotlin.Int,
        @Parameter(description = "Use SSL") @Valid @RequestParam(value = "useSSL", required = false) useSSL: kotlin.Boolean?
    ): ResponseEntity<QueueResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Update Consumer",
        operationId = "consumerUpdate",
        description = """Update an existing amqp queue's data mapping.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = QueueResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/queue/consumer/update"
        value = [PATH_CONSUMER_UPDATE],
        produces = ["*/*"]
    )
    fun consumerUpdate(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The application key to use when creating an analytic or service request. The account needs to have permissions to the applicaton or it will be denied.", required = true) @Valid @RequestParam(value = "appKey", required = true) appKey: kotlin.String,
        @NotNull @Parameter(description = "The queue to update", required = true) @Valid @RequestParam(value = "queueId", required = true) queueId: kotlin.Long,
        @NotNull @Parameter(description = "The data mapping information in the format of AMQPRequest", required = true) @Valid @RequestParam(value = "dataMapping", required = true) dataMapping: kotlin.String,
        @Parameter(description = "The client deviceID") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "The logged in user ID") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "Use SSL") @Valid @RequestParam(value = "useSSL", required = false) useSSL: kotlin.Boolean?
    ): ResponseEntity<QueueResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Copy Route",
        operationId = "copyRoute",
        description = """Make an copy of the given route with optional overriding properties""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = Route::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/route/{routeId}/copy"
        value = [PATH_COPY_ROUTE],
        produces = ["*/*"]
    )
    fun copyRoute(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "the id of the route to duplicate", required = true) @PathVariable("routeId") routeId: kotlin.Long,
        @Parameter(description = "") @Valid @RequestBody(required = false) body: Route?
    ): ResponseEntity<Route> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Create Dependent",
        operationId = "create",
        description = """Create dependent of the account""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.PUT],
        // "/api/{version}/cargo/dependent/{accountId}"
        value = [PATH_CREATE],
        produces = ["*/*"]
    )
    fun create(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "the id of the parent account to create a dependent for", required = true) @PathVariable("accountId") accountId: kotlin.Long,
        @Parameter(description = "") @Valid @RequestBody(required = false) body: Account?
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Create Account",
        operationId = "createAccount",
        description = """Create a new account by role.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = AccountLoginResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/account/create"
        value = [PATH_CREATE_ACCOUNT],
        produces = ["*/*"]
    )
    fun createAccount(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The access token to authenticate with (ex: username)", required = true) @Valid @RequestParam(value = "username", required = true) username: kotlin.String,
        @NotNull @Parameter(description = "The secret to authenticate with (ex: password)", required = true) @Valid @RequestParam(value = "password", required = true) password: kotlin.String,
        @Parameter(description = "The full name of the user. If this parameter is NOT empty, the following parameters will be ignored: prefixName, firstName, middleName, lastName, and suffixName") @Valid @RequestParam(value = "name", required = false) name: kotlin.String?,
        @Parameter(description = "If the parameter 'name' is empty or not present, this field will be used to set the prefix of the user's name") @Valid @RequestParam(value = "prefixName", required = false) prefixName: kotlin.String?,
        @Parameter(description = "If the parameter 'name' is empty or not present, this field will be used to set the user's first name") @Valid @RequestParam(value = "firstName", required = false) firstName: kotlin.String?,
        @Parameter(description = "If the parameter 'name' is empty or not present, this field will be used to set the user's middle name") @Valid @RequestParam(value = "middleName", required = false) middleName: kotlin.String?,
        @Parameter(description = "If the parameter 'name' is empty or not present, this field will be used to set the user's last name") @Valid @RequestParam(value = "lastName", required = false) lastName: kotlin.String?,
        @Parameter(description = "If the parameter 'name' is empty or not present, this field will be used to set the suffix of the user's name") @Valid @RequestParam(value = "suffixName", required = false) suffixName: kotlin.String?,
        @Parameter(description = "This field will be used to set the user's job title") @Valid @RequestParam(value = "title", required = false) title: kotlin.String?,
        @Parameter(description = "The unique id of the device making the request") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "The type of device id (this is defined by the client), ie. MAC_ADDRESS, APPLE_UDID, etc") @Valid @RequestParam(value = "deviceIdType", required = false) deviceIdType: kotlin.String?,
        @Parameter(description = "The user's contact email address (NOT the username)") @Valid @RequestParam(value = "emailAddress", required = false) emailAddress: kotlin.String?,
        @Parameter(description = "The asset id to set the user's profile image") @Valid @RequestParam(value = "assetId", required = false) assetId: kotlin.Long?,
        @Parameter(description = "The street address of the user's contact location") @Valid @RequestParam(value = "streetAddress", required = false) streetAddress: kotlin.String?,
        @Parameter(description = "The zipcode of the user's contact location") @Valid @RequestParam(value = "zipcode", required = false) zipcode: kotlin.String?,
        @Parameter(description = "The gender of the user (AudienceGender)") @Valid @RequestParam(value = "gender", required = false) gender: kotlin.String?,
        @Parameter(description = "The birthday date of the user in UTC milliseconds") @Valid @RequestParam(value = "birthday", required = false) birthday: kotlin.Long?,
        @Parameter(description = "The home phone number") @Valid @RequestParam(value = "homePhone", required = false) homePhone: kotlin.String?,
        @Parameter(description = "The cellular phone number") @Valid @RequestParam(value = "cellPhone", required = false) cellPhone: kotlin.String?,
        @Parameter(description = "The cellular service provider") @Valid @RequestParam(value = "cellPhoneCarrier", required = false) cellPhoneCarrier: kotlin.String?,
        @Parameter(description = "The business phone number") @Valid @RequestParam(value = "businessPhone", required = false) businessPhone: kotlin.String?,
        @Parameter(description = "The account role (default: MEMBER)") @Valid @RequestParam(value = "role", required = false) role: kotlin.String?,
        @Parameter(description = "Comma separated list of development platforms") @Valid @RequestParam(value = "platforms", required = false) platforms: kotlin.String?,
        @Parameter(description = "Search tags") @Valid @RequestParam(value = "tags", required = false) tags: kotlin.String?,
        @Parameter(description = "About us information") @Valid @RequestParam(value = "aboutUs", required = false) aboutUs: kotlin.String?,
        @Parameter(description = "Game experience of the user") @Valid @RequestParam(value = "gameExperience", required = false) gameExperience: kotlin.String?,
        @Parameter(description = "A list of category ids that represent interests and associations") @Valid @RequestParam(value = "categoryIds", required = false) categoryIds: kotlin.String?,
        @Parameter(description = "The user's hometown") @Valid @RequestParam(value = "hometown", required = false) hometown: kotlin.String?,
        @Parameter(description = "The user's height") @Valid @RequestParam(value = "height", required = false) height: kotlin.String?,
        @Parameter(description = "The user's height in a numerical value that can be used for ordering/searching") @Valid @RequestParam(value = "heightIndex", required = false) heightIndex: kotlin.Int?,
        @Parameter(description = "The user's ethnicity") @Valid @RequestParam(value = "ethnicity", required = false) ethnicity: kotlin.String?,
        @Parameter(description = "The user's body type") @Valid @RequestParam(value = "bodyType", required = false) bodyType: kotlin.String?,
        @Parameter(description = "The user's marital status") @Valid @RequestParam(value = "maritalStatus", required = false) maritalStatus: kotlin.String?,
        @Parameter(description = "The user's children status") @Valid @RequestParam(value = "children", required = false) children: kotlin.String?,
        @Parameter(description = "The user's religion") @Valid @RequestParam(value = "religion", required = false) religion: kotlin.String?,
        @Parameter(description = "The user's education") @Valid @RequestParam(value = "education", required = false) education: kotlin.String?,
        @Parameter(description = "The user's education in a numerical value that can be used for ordering/searching") @Valid @RequestParam(value = "educationIndex", required = false) educationIndex: kotlin.Int?,
        @Parameter(description = "The user's smoke status") @Valid @RequestParam(value = "smoke", required = false) smoke: kotlin.String?,
        @Parameter(description = "The user's drink status") @Valid @RequestParam(value = "drink", required = false) drink: kotlin.String?,
        @Parameter(description = "The user's companionship status") @Valid @RequestParam(value = "companionship", required = false) companionship: kotlin.String?,
        @Parameter(description = "The user's companionship index") @Valid @RequestParam(value = "companionshipIndex", required = false) companionshipIndex: kotlin.Int?,
        @Parameter(description = "The preferred minimum age in the account location search") @Valid @RequestParam(value = "preferredMinAge", required = false) preferredMinAge: kotlin.Int?,
        @Parameter(description = "The preferred maximum age in the account location search") @Valid @RequestParam(value = "preferredMaxAge", required = false) preferredMaxAge: kotlin.Int?,
        @Parameter(description = "The preferred minimum height in the account location search") @Valid @RequestParam(value = "preferredMinHeight", required = false) preferredMinHeight: kotlin.Int?,
        @Parameter(description = "The preferred maximum height in the account location search") @Valid @RequestParam(value = "preferredMaxHeight", required = false) preferredMaxHeight: kotlin.Int?,
        @Parameter(description = "The preferred gender in the account location search") @Valid @RequestParam(value = "preferredGender", required = false) preferredGender: kotlin.String?,
        @Parameter(description = "The preferred education in the account location search") @Valid @RequestParam(value = "preferredEducation", required = false) preferredEducation: kotlin.String?,
        @Parameter(description = "The preferred education in a numerical value that can be used for ordering/searching") @Valid @RequestParam(value = "preferredEducationIndex", required = false) preferredEducationIndex: kotlin.Int?,
        @Parameter(description = "The preferred body type in the account location search") @Valid @RequestParam(value = "preferredBodyType", required = false) preferredBodyType: kotlin.String?,
        @Parameter(description = "The preferred ethnicity in the account location search") @Valid @RequestParam(value = "preferredEthnicity", required = false) preferredEthnicity: kotlin.String?,
        @Parameter(description = "The preferred location in the account location search") @Valid @RequestParam(value = "preferredLocation", required = false) preferredLocation: kotlin.String?,
        @Parameter(description = "The preferred location range in the account location search") @Valid @RequestParam(value = "preferredLocationRange", required = false) preferredLocationRange: kotlin.Double?,
        @Parameter(description = "The current latitude of the user") @Valid @RequestParam(value = "latitude", required = false) latitude: kotlin.Double?,
        @Parameter(description = "The current longitude of the user") @Valid @RequestParam(value = "longitude", required = false) longitude: kotlin.Double?,
        @Parameter(description = "Accepted Terms") @Valid @RequestParam(value = "acceptedTerms", required = false) acceptedTerms: kotlin.Boolean?,
        @Parameter(description = "The inviteToken that the referrer used for this account to sign up") @Valid @RequestParam(value = "inviteToken", required = false) inviteToken: kotlin.String?,
        @Parameter(description = "The accountId of the referrer (used if there is no inviteToken)") @Valid @RequestParam(value = "referralAccountId", required = false) referralAccountId: kotlin.Long?,
        @Parameter(description = "Whether to send validation email") @Valid @RequestParam(value = "sendValidation", required = false) sendValidation: kotlin.Boolean?,
        @Parameter(description = "Deprecated: use appKey") @Valid @RequestParam(value = "gameType", required = false) gameType: kotlin.String?,
        @Parameter(description = "The application key") @Valid @RequestParam(value = "appKey", required = false) appKey: kotlin.String?,
        @Parameter(description = "The application version") @Valid @RequestParam(value = "appVersion", required = false) appVersion: kotlin.String?,
        @Parameter(description = "Returns an AccountLoginResponse if \"AccountLoginResponse\" is passed in") @Valid @RequestParam(value = "responseType", required = false) responseType: kotlin.String?,
        @Parameter(description = "Comma separated list of audience ids to assign to the user") @Valid @RequestParam(value = "audienceIdsToAdd", required = false) audienceIdsToAdd: kotlin.String?,
        @Parameter(description = "Application blob data") @Valid @RequestParam(value = "appBlob", required = false) appBlob: kotlin.String?,
        @Parameter(description = "Enable push for the app") @Valid @RequestParam(value = "appEnablePush", required = false) appEnablePush: kotlin.Boolean?,
        @Parameter(description = "Enable SMS for the app") @Valid @RequestParam(value = "appEnableSMS", required = false) appEnableSMS: kotlin.Boolean?,
        @Parameter(description = "Enable email for the app") @Valid @RequestParam(value = "appEnableEmail", required = false) appEnableEmail: kotlin.Boolean?,
        @Parameter(description = "Location visibility setting") @Valid @RequestParam(value = "locationVisibility", required = false) locationVisibility: kotlin.String?,
        @Parameter(description = "Home latitude") @Valid @RequestParam(value = "homeLatitude", required = false) homeLatitude: kotlin.Double?,
        @Parameter(description = "Home longitude") @Valid @RequestParam(value = "homeLongitude", required = false) homeLongitude: kotlin.Double?,
        @Parameter(description = "The nickname used in the application for this account") @Valid @RequestParam(value = "appNickname", required = false) appNickname: kotlin.String?,
        @Parameter(description = "Personal audience id to associate with this account") @Valid @RequestParam(value = "personalAudienceId", required = false) personalAudienceId: kotlin.Long?
    ): ResponseEntity<AccountLoginResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Create Achievement",
        operationId = "createAchievement",
        description = """Updates an achievement (for developer/retailer use). User must have permissions to the application the achievement is created for.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = AchievementResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/achievement/create"
        value = [PATH_CREATE_ACHIEVEMENT],
        produces = ["*/*"]
    )
    fun createAchievement(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the application key the achievement is for", required = true) @Valid @RequestParam(value = "appKey", required = true) appKey: kotlin.String,
        @NotNull @Parameter(description = "the title of the achievement (255 character limit)", required = true) @Valid @RequestParam(value = "title", required = true) title: kotlin.String,
        @Parameter(description = "a unique id given by the device (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "the account id of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "the analytics tag that will trigger when a user's achievement count gets updated") @Valid @RequestParam(value = "analyticsTag", required = false) analyticsTag: kotlin.String?,
        @Parameter(description = "the description of the achievement") @Valid @RequestParam(value = "description", required = false) description: kotlin.String?,
        @Parameter(description = "the rank type for updating leader boards") @Valid @RequestParam(value = "rankType", required = false) rankType: kotlin.String?,
        @Parameter(description = "determines how much the rank count is incremented") @Valid @RequestParam(value = "rankIncrement", required = false) rankIncrement: kotlin.Int?,
        @Parameter(description = "restrict scores to be above or equal to this minimum value") @Valid @RequestParam(value = "minIncrement", required = false) minIncrement: kotlin.Int?,
        @Parameter(description = "restrict scores to be below or equal to this maximum value") @Valid @RequestParam(value = "maxIncrement", required = false) maxIncrement: kotlin.Int?,
        @Parameter(description = "determines whether the customId on analytics are used to validate a user's achievement progress.") @Valid @RequestParam(value = "validate", required = false) validate: kotlin.Boolean?,
        @Parameter(description = "achievement is active or inactive") @Valid @RequestParam(value = "active", required = false) active: kotlin.Boolean?,
        @Parameter(description = "if provided will define what triggers to run after a tier is completed") @Valid @RequestParam(value = "triggerDefinition", required = false) triggerDefinition: kotlin.String?
    ): ResponseEntity<AchievementResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Create Achievement Tier",
        operationId = "createAchievementTier",
        description = """Create a tier of an achievement (for developer/retailer use). User must have permissions to the application the achievement is created for.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = AchievementTierResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/achievement/tier/create"
        value = [PATH_CREATE_ACHIEVEMENT_TIER],
        produces = ["*/*"]
    )
    fun createAchievementTier(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the achievement id for adding a new tier", required = true) @Valid @RequestParam(value = "achievementId", required = true) achievementId: kotlin.Long,
        @NotNull @Parameter(description = "score all instances", required = true) @Valid @RequestParam(value = "scoreAllInstances", required = true) scoreAllInstances: kotlin.Boolean,
        @Parameter(description = "a unique id given by the device (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "the account id of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "achievement tier icon image file") @Valid @RequestParam(value = "icon", required = false) icon: org.springframework.web.multipart.MultipartFile,
        @Parameter(description = "the icon assetId, if icon is provided, icon will overrule") @Valid @RequestParam(value = "iconAssetId", required = false) iconAssetId: kotlin.Long?,
        @Parameter(description = "the title of the achievement tier") @Valid @RequestParam(value = "title", required = false) title: kotlin.String?,
        @Parameter(description = "the description of the achievement tier") @Valid @RequestParam(value = "description", required = false) description: kotlin.String?,
        @Parameter(description = "the count requirement for completing the achievement tier") @Valid @RequestParam(value = "goalCount", required = false) goalCount: kotlin.Long?,
        @Parameter(description = "The ID of the mission to associate with the achievement") @Valid @RequestParam(value = "missionId", required = false) missionId: kotlin.Long?,
        @Parameter(description = "The ID of the game to associate with the achievement") @Valid @RequestParam(value = "gameId", required = false) gameId: kotlin.Long?,
        @Parameter(description = "The ID of the pack to associate with the achievement") @Valid @RequestParam(value = "packId", required = false) packId: kotlin.Long?,
        @Parameter(description = "The ID of the game level to associate with the achievement") @Valid @RequestParam(value = "gameLevelId", required = false) gameLevelId: kotlin.Long?,
        @Parameter(description = "The ID of the game object to associate with the achievement") @Valid @RequestParam(value = "gameObjectId", required = false) gameObjectId: kotlin.Int?
    ): ResponseEntity<AchievementTierResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Create Application",
        operationId = "createApplication",
        description = """Create an application record and one placement record for that application. You can create more placements for this application by using {@link createApplicationPlacement}.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = ApplicationResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/application/create"
        value = [PATH_CREATE_APPLICATION],
        produces = ["*/*"]
    )
    fun createApplication(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The name of the application", required = true) @Valid @RequestParam(value = "appName", required = true) appName: kotlin.String,
        @Parameter(description = "The unique id of the device making the request (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "The account id of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "The description of the application") @Valid @RequestParam(value = "about", required = false) about: kotlin.String?,
        @Parameter(description = "The application bundle identifier (format - com.company.appName)") @Valid @RequestParam(value = "bundleId", required = false) bundleId: kotlin.String?,
        @Parameter(description = "The application icon asset id") @Valid @RequestParam(value = "appIconAssetId", required = false) appIconAssetId: kotlin.Long?,
        @Parameter(description = "The application logo asset id") @Valid @RequestParam(value = "appLogoAssetId", required = false) appLogoAssetId: kotlin.Long?,
        @Parameter(description = "The Facebook application id") @Valid @RequestParam(value = "facebookAppId", required = false) facebookAppId: kotlin.String?,
        @Parameter(description = "The Facebook application secret") @Valid @RequestParam(value = "facebookAppSecret", required = false) facebookAppSecret: kotlin.String?,
        @Parameter(description = "This is the either the 'server key' or 'browser key' generated from google to enable Google Cloud Messaging") @Valid @RequestParam(value = "googleApiKey", required = false) googleApiKey: kotlin.String?,
        @Parameter(description = "Determines whether to update the EULA date") @Valid @RequestParam(value = "updateEULADate", required = false) updateEULADate: kotlin.Boolean?,
        @Parameter(description = "The EULA version") @Valid @RequestParam(value = "eulaVersion", required = false) eulaVersion: kotlin.String?,
        @Parameter(description = "The landing page URL") @Valid @RequestParam(value = "landingPageUrl", required = false) landingPageUrl: kotlin.String?,
        @Parameter(description = "Determines whether to show the application in the activity feed") @Valid @RequestParam(value = "showInActivities", required = false) showInActivities: kotlin.Boolean?,
        @Parameter(description = "The description of the application in the activity feed") @Valid @RequestParam(value = "activityDescription", required = false) activityDescription: kotlin.String?,
        @Parameter(description = "The text to display on the invite page") @Valid @RequestParam(value = "inviteWelcomeText", required = false) inviteWelcomeText: kotlin.String?,
        @Parameter(description = "The url to the application invite page") @Valid @RequestParam(value = "invitePageUrl", required = false) invitePageUrl: kotlin.String?,
        @Parameter(description = "The protocal the app uses to load the app via a browser") @Valid @RequestParam(value = "urlScheme", required = false) urlScheme: kotlin.String?,
        @Parameter(description = "A json object with a list of supported platforms.  ```json {   \"platforms\": [     {       \"deviceId\": 1,       \"minimum\": 230,       \"maximum\": 421,       \"downloadUrl\": \"http://app.store.com/download\",       \"description\": \"description and version info\"     }   ] } ``` ") @Valid @RequestParam(value = "platforms", required = false) platforms: kotlin.String?,
        @Parameter(description = "Json formatted downloadUrls.  ```json {   \"ios\": \"the-url-to-app-store\",    \"android\": \"the-url-to-google-play\" } ```  ") @Valid @RequestParam(value = "downloadUrls", required = false) downloadUrls: kotlin.String?,
        @Parameter(description = "List of categories to apply") @Valid @RequestParam(value = "categoryIds", required = false) categoryIds: kotlin.String?,
        @Parameter(description = "The type of scoring this application will use {GAME_LEVEL, GAME_OBJECT", schema = Schema(allowableValues = ["GAME_LEVEL", "GAME_OBJECT"], defaultValue = "GAME_LEVEL")) @Valid @RequestParam(value = "scoringType", required = false, defaultValue = "GAME_LEVEL") scoringType: kotlin.String,
        @Parameter(description = "The cost of hints", schema = Schema(defaultValue = "11")) @Valid @RequestParam(value = "hintCost", required = false, defaultValue = "11") hintCost: kotlin.Int,
        @Parameter(description = "The maximum score that will be possible", schema = Schema(defaultValue = "125")) @Valid @RequestParam(value = "maxScore", required = false, defaultValue = "125") maxScore: kotlin.Int,
        @Parameter(description = "The point-to-ticket conversion ratio", schema = Schema(defaultValue = "0.037f")) @Valid @RequestParam(value = "ticketsPerPoint", required = false, defaultValue = "0.037f") ticketsPerPoint: kotlin.Float,
        @Parameter(description = "Determines whether the application uses services to save custom game objects", schema = Schema(defaultValue = "true")) @Valid @RequestParam(value = "hasGameData", required = false, defaultValue = "true") hasGameData: kotlin.Boolean,
        @Parameter(description = "Public Notifications") @Valid @RequestParam(value = "publicNotifications", required = false) publicNotifications: kotlin.Boolean?,
        @Parameter(description = "Use Matching Algorithm") @Valid @RequestParam(value = "useMatchingAlgorithm", required = false) useMatchingAlgorithm: kotlin.Boolean?,
        @Parameter(description = "Determines whether earned tickets are applied across all applications", schema = Schema(defaultValue = "false")) @Valid @RequestParam(value = "globalTickets", required = false, defaultValue = "false") globalTickets: kotlin.Boolean,
        @Parameter(description = "The current build version of the application", schema = Schema(defaultValue = "1f")) @Valid @RequestParam(value = "buildVersion", required = false, defaultValue = "1f") buildVersion: kotlin.Float,
        @Parameter(description = "The current API version the application uses") @Valid @RequestParam(value = "apiVersion", required = false) apiVersion: kotlin.Float?,
        @Parameter(description = "The name of the placement") @Valid @RequestParam(value = "placementName", required = false) placementName: kotlin.String?,
        @Parameter(description = "The description of the placement") @Valid @RequestParam(value = "placementDescription", required = false) placementDescription: kotlin.String?,
        @Parameter(description = "The ad placement size {BANNER, LEADERBOARD, SKYSCRAPER, INTERSTITIAL, CUSTOM (this is required if a placements is to be created)", schema = Schema(allowableValues = ["CONFIG", "BANNER", "LEADERBOARD", "SKYSCRAPER", "VIDEO", "ZIP", "INTERSTITIAL", "CUSTOM1", "CUSTOM2", "CUSTOM3", "CUSTOM4", "CUSTOM5", "CUSTOM6", "CUSTOM7", "CUSTOM8", "CUSTOM9", "CUSTOM10"])) @Valid @RequestParam(value = "placementSize", required = false) placementSize: kotlin.String?,
        @Parameter(description = "The height of a custom ad size") @Valid @RequestParam(value = "placementHeight", required = false) placementHeight: kotlin.Int?,
        @Parameter(description = "The width of a custom ad size") @Valid @RequestParam(value = "placementWidth", required = false) placementWidth: kotlin.Int?,
        @Parameter(description = "The refresh interval in seconds") @Valid @RequestParam(value = "placementRefreshInterval", required = false) placementRefreshInterval: kotlin.Int?,
        @Parameter(description = "Generate a custom object store to use", schema = Schema(defaultValue = "true")) @Valid @RequestParam(value = "createObjectStore", required = false, defaultValue = "true") createObjectStore: kotlin.Boolean,
        @Parameter(description = "Determine whether or not public content requires admin approval before it becomes public", schema = Schema(defaultValue = "false")) @Valid @RequestParam(value = "publicContentApproval", required = false, defaultValue = "false") publicContentApproval: kotlin.Boolean,
        @Parameter(description = "Determines whether the application uses production or sandbox services", schema = Schema(defaultValue = "false")) @Valid @RequestParam(value = "productionMode", required = false, defaultValue = "false") productionMode: kotlin.Boolean,
        @Parameter(description = "Minimum Session Length") @Valid @RequestParam(value = "minimumSessionLength", required = false) minimumSessionLength: kotlin.Int?,
        @Parameter(description = "Session Gap Length") @Valid @RequestParam(value = "sessionGapLength", required = false) sessionGapLength: kotlin.Int?,
        @Parameter(description = "Local Ads Enabled", schema = Schema(defaultValue = "false")) @Valid @RequestParam(value = "localAdsEnabled", required = false, defaultValue = "false") localAdsEnabled: kotlin.Boolean,
        @Parameter(description = "Sqoot Api Key") @Valid @RequestParam(value = "sqootApiKey", required = false) sqootApiKey: kotlin.String?,
        @Parameter(description = "Determines how to process trilateration data. Possible values include: DEFAULT, FINGERPRINT", schema = Schema(allowableValues = ["DEFAULT", "FINGERPRINT", "FINGERPRINT_V2"], defaultValue = "FINGERPRINT")) @Valid @RequestParam(value = "trilatProcessingType", required = false, defaultValue = "FINGERPRINT") trilatProcessingType: kotlin.String,
        @Parameter(description = "Determines what the maximum sample size during trilateration") @Valid @RequestParam(value = "maxSampleSize", required = false) maxSampleSize: kotlin.Int?,
        @Parameter(description = "Determines what the minimum acceptable RSSI value") @Valid @RequestParam(value = "minRSSI", required = false) minRSSI: kotlin.Double?,
        @Parameter(description = "List modules allowed to be served by the server, possible values include: COMMON, MEDIA, OFFER, GAME, SOCIAL, CONSUMER_WEBSITE, ALL", schema = Schema(defaultValue = "ALL")) @Valid @RequestParam(value = "modules", required = false, defaultValue = "ALL") modules: kotlin.String,
        @Parameter(description = "How many servers the license will support", schema = Schema(defaultValue = "1")) @Valid @RequestParam(value = "authorizedCount", required = false, defaultValue = "1") authorizedCount: kotlin.Int,
        @Parameter(description = "The list of ip addresses of servers the license will support, leave null for any server") @Valid @RequestParam(value = "authorizedServers", required = false) authorizedServers: kotlin.String?,
        @Parameter(description = "Sets the default timezone for the app (used for leaderboards and other time specific content)") @Valid @RequestParam(value = "defaultTimezone", required = false) defaultTimezone: kotlin.String?,
        @Parameter(description = "SMTP Pass") @Valid @RequestParam(value = "smtpPass", required = false) smtpPass: kotlin.String?,
        @Parameter(description = "The application meta data. Defined by the client") @Valid @RequestParam(value = "metaData", required = false) metaData: kotlin.String?,
        @Parameter(description = "The ad placement meta data. Defined by the client") @Valid @RequestParam(value = "placementMetaData", required = false) placementMetaData: kotlin.String?,
        @Parameter(description = "Create floor tables for Ips", schema = Schema(defaultValue = "false")) @Valid @RequestParam(value = "ipsFloor", required = false, defaultValue = "false") ipsFloor: kotlin.Boolean,
        @Parameter(description = "Enables setting the APNS badge value in the payload", schema = Schema(defaultValue = "true")) @Valid @RequestParam(value = "enableAPNSBadge", required = false, defaultValue = "true") enableAPNSBadge: kotlin.Boolean,
        @Parameter(description = "Enables using the application in session reports", schema = Schema(defaultValue = "true")) @Valid @RequestParam(value = "includeInReport", required = false, defaultValue = "true") includeInReport: kotlin.Boolean,
        @Parameter(description = "Sets the default filter to use (if none is passed in) for certain search APIs including Album Search.") @Valid @RequestParam(value = "defaultAppFilterId", required = false) defaultAppFilterId: kotlin.Long?,
        @Parameter(description = "Enables whether the default welcome email will be sent for new app users") @Valid @RequestParam(value = "enableWelcomeEmail", required = false) enableWelcomeEmail: kotlin.Boolean?,
        @Parameter(description = "The Apple Application ID") @Valid @RequestParam(value = "appleAppId", required = false) appleAppId: kotlin.String?,
        @Parameter(description = "The Apple Team ID") @Valid @RequestParam(value = "appleTeamId", required = false) appleTeamId: kotlin.String?,
        @Parameter(description = "The Apple Auth Key ID") @Valid @RequestParam(value = "appleAuthKeyId", required = false) appleAuthKeyId: kotlin.String?,
        @Parameter(description = "The Apple Auth Signin Key (p8) File") @Valid @RequestParam(value = "appleAuthKey", required = false) appleAuthKey: org.springframework.web.multipart.MultipartFile,
        @Parameter(description = "The Apple Issuer ID") @Valid @RequestParam(value = "appleIssuerId", required = false) appleIssuerId: kotlin.String?,
        @Parameter(description = "The Apple App Store Key ID") @Valid @RequestParam(value = "appStoreKeyId", required = false) appStoreKeyId: kotlin.String?,
        @Parameter(description = "The Apple App Store Key (p8) File") @Valid @RequestParam(value = "appStoreKey", required = false) appStoreKey: org.springframework.web.multipart.MultipartFile,
        @Parameter(description = "This is the private key file for your Google service account.") @Valid @RequestParam(value = "googlePrivateKeyFile", required = false) googlePrivateKeyFile: org.springframework.web.multipart.MultipartFile,
        @Parameter(description = "Authorize Net Api Key") @Valid @RequestParam(value = "authorizeNetApiKey", required = false) authorizeNetApiKey: kotlin.String?,
        @Parameter(description = "Authorize Net Transaction Key") @Valid @RequestParam(value = "authorizeNetTransactionKey", required = false) authorizeNetTransactionKey: kotlin.String?,
        @Parameter(description = "Email Sender") @Valid @RequestParam(value = "emailSender", required = false) emailSender: kotlin.String?,
        @Parameter(description = "SMTP User") @Valid @RequestParam(value = "smtpUser", required = false) smtpUser: kotlin.String?,
        @Parameter(description = "SMTP Host") @Valid @RequestParam(value = "smtpHost", required = false) smtpHost: kotlin.String?,
        @Parameter(description = "Vatom Business Id") @Valid @RequestParam(value = "vatomBusinessId", required = false) vatomBusinessId: kotlin.String?,
        @Parameter(description = "Vatom REST Client Id") @Valid @RequestParam(value = "vatomRestClientId", required = false) vatomRestClientId: kotlin.String?,
        @Parameter(description = "Vatom Secret Key") @Valid @RequestParam(value = "vatomRestSecretKey", required = false) vatomRestSecretKey: kotlin.String?,
        @Parameter(description = "Twilio Account SID") @Valid @RequestParam(value = "twilioAccountSID", required = false) twilioAccountSID: kotlin.String?,
        @Parameter(description = "Twilio Auth Token") @Valid @RequestParam(value = "twilioAuthToken", required = false) twilioAuthToken: kotlin.String?,
        @Parameter(description = "Twilio Sender Phone Number") @Valid @RequestParam(value = "twilioSenderPhoneNumber", required = false) twilioSenderPhoneNumber: kotlin.String?,
        @Parameter(description = "OpenAI Secret API Key") @Valid @RequestParam(value = "openAISecretKey", required = false) openAISecretKey: kotlin.String?
    ): ResponseEntity<ApplicationResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Create AppConfig",
        operationId = "createApplicationConfig",
        description = """Creates a new application configuration. If the configVersion provided already exists for the given app, an invalid response is returned and the application configuration won't be created.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = ApplicationConfigResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/appconfig/create"
        value = [PATH_CREATE_APPLICATION_CONFIG],
        produces = ["*/*"]
    )
    fun createApplicationConfig(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The account ID of the user", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "The application key that the newly created applicationConfig will be associated to", required = true) @Valid @RequestParam(value = "appKey", required = true) appKey: kotlin.String,
        @NotNull @Parameter(description = "The application configuration, has to be unique within the application", required = true) @Valid @RequestParam(value = "configVersion", required = true) configVersion: kotlin.String,
        @NotNull @Parameter(description = "The json assetId that stores the configuration detail.", required = true) @Valid @RequestParam(value = "assetId", required = true) assetId: kotlin.Long,
        @Parameter(description = "The retailer id for retailer specific configurations") @Valid @RequestParam(value = "retailerId", required = false) retailerId: kotlin.Long?,
        @Parameter(description = "The retailer location id for retailer location specific configurations") @Valid @RequestParam(value = "retailerLocationId", required = false) retailerLocationId: kotlin.Long?,
        @Parameter(description = "The device udid for device specific configurations") @Valid @RequestParam(value = "udid", required = false) udid: kotlin.String?
    ): ResponseEntity<ApplicationConfigResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Create Ad Placement",
        operationId = "createApplicationPlacement",
        description = """Creates a new ad placement for an application.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = PlacementResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/application/placement/create"
        value = [PATH_CREATE_APPLICATION_PLACEMENT],
        produces = ["*/*"]
    )
    fun createApplicationPlacement(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The appKey of the application the ad placement is for", required = true) @Valid @RequestParam(value = "appKey", required = true) appKey: kotlin.String,
        @NotNull @Parameter(description = "The ad placement size {BANNER, LEADERBOARD, SKYSCRAPER, INTERSTITIAL, CUSTOM", required = true, schema = Schema(allowableValues = ["CONFIG", "BANNER", "LEADERBOARD", "SKYSCRAPER", "VIDEO", "ZIP", "INTERSTITIAL", "CUSTOM1", "CUSTOM2", "CUSTOM3", "CUSTOM4", "CUSTOM5", "CUSTOM6", "CUSTOM7", "CUSTOM8", "CUSTOM9", "CUSTOM10"])) @Valid @RequestParam(value = "size", required = true) size: kotlin.String,
        @Parameter(description = "The unique id of the device making the request (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "The account id of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "The name of the placement") @Valid @RequestParam(value = "name", required = false) name: kotlin.String?,
        @Parameter(description = "The description of the placement") @Valid @RequestParam(value = "description", required = false) description: kotlin.String?,
        @Parameter(description = "The height of a custom ad size") @Valid @RequestParam(value = "height", required = false) height: kotlin.Int?,
        @Parameter(description = "The width of a custom ad size") @Valid @RequestParam(value = "width", required = false) width: kotlin.Int?,
        @Parameter(description = "The refresh interval in seconds") @Valid @RequestParam(value = "refreshInterval", required = false) refreshInterval: kotlin.Int?,
        @Parameter(description = "Default Image Id") @Valid @RequestParam(value = "defaultImageId", required = false) defaultImageId: kotlin.Long?,
        @Parameter(description = "Active") @Valid @RequestParam(value = "active", required = false) active: kotlin.Boolean?
    ): ResponseEntity<PlacementResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Create Asset",
        operationId = "createAsset",
        description = """Uploads an asset to server and returns an asset id which can be used to assign to various objects.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = AssetResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/asset/create"
        value = [PATH_CREATE_ASSET],
        produces = ["*/*"]
    )
    fun createAsset(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "to return nulls") @Valid @RequestParam(value = "returnNulls", required = false) returnNulls: kotlin.Boolean?,
        @Parameter(description = "a unique ID given by the device (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "the account ID of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "the album the asset will be added to (optional)") @Valid @RequestParam(value = "albumId", required = false) albumId: kotlin.Long?,
        @Parameter(description = "Deprecated: use collections via the collection endpoints.") @Valid @RequestParam(value = "collectionId", required = false) collectionId: kotlin.Long?,
        @Parameter(description = "Whether to add to a default album") @Valid @RequestParam(value = "addToDefaultAlbum", required = false) addToDefaultAlbum: kotlin.String?,
        @Parameter(description = "Whether to add to the media library") @Valid @RequestParam(value = "addToMediaLibrary", required = false) addToMediaLibrary: kotlin.Boolean?,
        @Parameter(description = "the version code") @Valid @RequestParam(value = "versionCode", required = false) versionCode: kotlin.Int?,
        @Parameter(description = "the version name") @Valid @RequestParam(value = "versionName", required = false) versionName: kotlin.String?,
        @Parameter(description = "External custom client defined data") @Valid @RequestParam(value = "metaData", required = false) metaData: kotlin.String?,
        @Parameter(description = "the caption (optional)") @Valid @RequestParam(value = "caption", required = false) caption: kotlin.String?,
        @Parameter(description = "the asset type") @Valid @RequestParam(value = "assetType", required = false) assetType: kotlin.String?,
        @Parameter(description = "approval status for the asset") @Valid @RequestParam(value = "approvalStatus", required = false) approvalStatus: kotlin.String?,
        @Parameter(description = "account id assigned to the asset") @Valid @RequestParam(value = "assignedAccountId", required = false) assignedAccountId: kotlin.Long?,
        @Parameter(description = "a MultipartFile containing the mimetype, etc") @Valid @RequestParam(value = "media", required = false) media: org.springframework.web.multipart.MultipartFile,
        @Parameter(description = "this can be used if the \"media\" is a link (optional)") @Valid @RequestParam(value = "mediaUrl", required = false) mediaUrl: kotlin.String?,
        @Parameter(description = "the media content as a string (optional)") @Valid @RequestParam(value = "mediaString", required = false) mediaString: kotlin.String?,
        @Parameter(description = "file name for mediaString (optional)") @Valid @RequestParam(value = "mediaStringFileName", required = false) mediaStringFileName: kotlin.String?,
        @Parameter(description = "content type for mediaString (optional)") @Valid @RequestParam(value = "mediaStringContentType", required = false) mediaStringContentType: kotlin.String?,
        @Parameter(description = "the media height (optional)") @Valid @RequestParam(value = "mediaHeight", required = false) mediaHeight: kotlin.Int?,
        @Parameter(description = "the media width (optional)") @Valid @RequestParam(value = "mediaWidth", required = false) mediaWidth: kotlin.Int?,
        @Parameter(description = "a MultipartFile containing an asset that the \"media\" file references (optional). Example: to upload a video the \"media\" file should contain a screen capture and the \"attachedMedia\" should be the actual video.") @Valid @RequestParam(value = "attachedMedia", required = false) attachedMedia: org.springframework.web.multipart.MultipartFile,
        @Parameter(description = "this can be used if the \"attachedMedia\" is a link (i.e. a Youtube video, etc) (optional)") @Valid @RequestParam(value = "attachedMediaUrl", required = false) attachedMediaUrl: kotlin.String?,
        @Parameter(description = "attached media content as a string (optional)") @Valid @RequestParam(value = "attachedMediaString", required = false) attachedMediaString: kotlin.String?,
        @Parameter(description = "file name for attachedMediaString (optional)") @Valid @RequestParam(value = "attachedMediaStringFileName", required = false) attachedMediaStringFileName: kotlin.String?,
        @Parameter(description = "content type for attachedMediaString (optional)") @Valid @RequestParam(value = "attachedMediaStringContentType", required = false) attachedMediaStringContentType: kotlin.String?,
        @Parameter(description = "the attached media height (optional)") @Valid @RequestParam(value = "attachedMediaHeight", required = false) attachedMediaHeight: kotlin.Int?,
        @Parameter(description = "the attached media width (optional)") @Valid @RequestParam(value = "attachedMediaWidth", required = false) attachedMediaWidth: kotlin.Int?,
        @Parameter(description = "the location description (optional)") @Valid @RequestParam(value = "locationDescription", required = false) locationDescription: kotlin.String?,
        @Parameter(description = "Deprecated: app parameter") @Valid @RequestParam(value = "app", required = false) app: kotlin.String?,
        @Parameter(description = "the application key") @Valid @RequestParam(value = "appKey", required = false) appKey: kotlin.String?,
        @Parameter(description = "the search tags") @Valid @RequestParam(value = "searchTags", required = false) searchTags: kotlin.String?,
        @Parameter(description = "the latitude (optional)") @Valid @RequestParam(value = "latitude", required = false) latitude: kotlin.Double?,
        @Parameter(description = "the longitude (optional)") @Valid @RequestParam(value = "longitude", required = false) longitude: kotlin.Double?
    ): ResponseEntity<AssetResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Create Audience",
        operationId = "createAudience",
        description = """Create a user defined audience.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = AudienceResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/audience/create"
        value = [PATH_CREATE_AUDIENCE],
        produces = ["*/*"]
    )
    fun createAudience(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The logged in user.", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "The name of the audience", required = true) @Valid @RequestParam(value = "name", required = true) name: kotlin.String,
        @Parameter(description = "The description of the audience") @Valid @RequestParam(value = "description", required = false) description: kotlin.String?,
        @Parameter(description = "The search tags") @Valid @RequestParam(value = "searchTags", required = false) searchTags: kotlin.String?,
        @Parameter(description = "The gender; possible values are: MALE, FEMALE, ANY") @Valid @RequestParam(value = "gender", required = false) gender: kotlin.String?,
        @Parameter(description = "The list of age groups, comma separated; possible values are AGE_0_13, AGE_14_17, AGE_18_22, AGE_23_30, AGE_31_54, AGE_55_PLUS, AGE_ANY (to reset to none)") @Valid @RequestParam(value = "ageGroups", required = false) ageGroups: kotlin.String?,
        @Parameter(description = "The list of category ids, comma separated; possible values are retrieved via /api/{version}/category/search (pass in id values)") @Valid @RequestParam(value = "categoryIds", required = false) categoryIds: kotlin.String?,
        @Parameter(description = "The list of application ids, comma separated; possible values are retrieved via /api/{version}/application/list (pass in id values)") @Valid @RequestParam(value = "applicationIds", required = false) applicationIds: kotlin.String?,
        @Parameter(description = "The experience level of the player; possible values are: ANY, NEW, BEGINNER, INTERMEDIATE, EXPERT") @Valid @RequestParam(value = "gameExperienceLevel", required = false) gameExperienceLevel: kotlin.String?,
        @Parameter(description = "(Deprecated) Use deviceIds. The list of targeted device names, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in name values)") @Valid @RequestParam(value = "devices", required = false) devices: kotlin.String?,
        @Parameter(description = "The list of targeted device ids, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in id values)") @Valid @RequestParam(value = "deviceIds", required = false) deviceIds: kotlin.String?,
        @Parameter(description = "The list of targeted device version ranges that are aligned with the provided devices list, comma separated (examples: 2.3-X, 0-5.1.4, 4.3.1-6.1.4)") @Valid @RequestParam(value = "deviceVersions", required = false) deviceVersions: kotlin.String?,
        @Parameter(description = "The list of locations to build the center around; comma separated list of latitude/longitude pairs (example: lat1,long1,lat2,long2)") @Valid @RequestParam(value = "locations", required = false) locations: kotlin.String?,
        @Parameter(description = "The list of radius of influence for the audience, in miles; comma separated list. Either provide 1 to be applied to all location pairs or a matching list to each lat/long pair.") @Valid @RequestParam(value = "radius", required = false) radius: kotlin.String?,
        @Parameter(description = "Seconds from the start time of an event") @Valid @RequestParam(value = "startTimeOffset", required = false) startTimeOffset: kotlin.Int?,
        @Parameter(description = "Seconds from the end time of an event") @Valid @RequestParam(value = "endTimeOffset", required = false) endTimeOffset: kotlin.Int?,
        @Parameter(description = "If true, then notify matching users when they are inside the radius", schema = Schema(defaultValue = "true")) @Valid @RequestParam(value = "sendSuggestion", required = false, defaultValue = "true") sendSuggestion: kotlin.Boolean,
        @Parameter(description = "The description of the associated object") @Valid @RequestParam(value = "associateDescription", required = false) associateDescription: kotlin.String?,
        @Parameter(description = "The type of the object to center the audience geofence") @Valid @RequestParam(value = "associateType", required = false) associateType: kotlin.String?,
        @Parameter(description = "The ID of the object to center the audience geofence") @Valid @RequestParam(value = "associateId", required = false) associateId: kotlin.Long?,
        @Parameter(description = "Optional grouping id for the audience") @Valid @RequestParam(value = "groupingId", required = false) groupingId: kotlin.String?,
        @Parameter(description = "External custom client defined data") @Valid @RequestParam(value = "metaData", required = false) metaData: kotlin.String?,
        @Parameter(description = "Visibility of the audience") @Valid @RequestParam(value = "visibility", required = false) visibility: kotlin.String?,
        @Parameter(description = "Type of audience") @Valid @RequestParam(value = "audienceType", required = false) audienceType: kotlin.String?,
        @Parameter(description = "Use order for cohort") @Valid @RequestParam(value = "useOrder", required = false) useOrder: kotlin.Boolean?,
        @Parameter(description = "Cohort data for \"cohort\" audience type") @Valid @RequestParam(value = "cohortRegionsData", required = false) cohortRegionsData: kotlin.String?,
        @Parameter(description = "Filter results by application key") @Valid @RequestParam(value = "appKey", required = false) appKey: kotlin.String?,
        @Parameter(description = "Trilateration types") @Valid @RequestParam(value = "trilaterationTypes", required = false) trilaterationTypes: kotlin.String?,
        @Parameter(description = "If true, makes sure the audience name is unique") @Valid @RequestParam(value = "uniqueName", required = false) uniqueName: kotlin.Boolean?
    ): ResponseEntity<AudienceResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Create Offline Report",
        operationId = "createBatch",
        description = """Create an entry for the batch for offline report""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = ReportBatchResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/report/batch/create"
        value = [PATH_CREATE_BATCH],
        produces = ["*/*"]
    )
    fun createBatch(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The account id of the user for passing account related params", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "the status of the report", required = true, schema = Schema(allowableValues = ["NEW", "ERROR", "COMPLETE", "PARSE_ERROR", "PROCESSING", "DUPLICATE", "SAVEONLY"])) @Valid @RequestParam(value = "status", required = true) status: kotlin.String,
        @NotNull @Parameter(description = "the limit on how much you can preview of the batch report", required = true) @Valid @RequestParam(value = "previewLimit", required = true) previewLimit: kotlin.Int,
        @Parameter(description = "The application key for passing application related params") @Valid @RequestParam(value = "appKey", required = false) appKey: kotlin.String?,
        @Parameter(description = "") @Valid @RequestParam(value = "endpoint", required = false) endpoint: kotlin.String?,
        @Parameter(description = "a json structure list of the parameter values, example: ```json {   \"string\":\"value\",    \"number\":3.345,   \"date\":\"2014-05-01 00:00:00\" } ``` ") @Valid @RequestParam(value = "parameters", required = false) parameters: kotlin.String?,
        @Parameter(description = "name of the batch report") @Valid @RequestParam(value = "name", required = false) name: kotlin.String?,
        @Parameter(description = "the start date of the batch report") @Valid @RequestParam(value = "startDate", required = false) startDate: kotlin.Long?,
        @Parameter(description = "the end date of the batch report") @Valid @RequestParam(value = "endDate", required = false) endDate: kotlin.Long?,
        @Parameter(description = "the description of the batch report") @Valid @RequestParam(value = "description", required = false) description: kotlin.String?,
        @Parameter(description = "") @Valid @RequestParam(value = "pageUrl", required = false) pageUrl: kotlin.String?
    ): ResponseEntity<ReportBatchResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Create Bid",
        operationId = "createBid",
        description = """Creates a bid on a biddable object""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = BidResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/bid/create"
        value = [PATH_CREATE_BID],
        produces = ["*/*"]
    )
    fun createBid(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "A biddable object type. Possible values include: CREATIVE (ads).", required = true) @Valid @RequestParam(value = "biddableType", required = true) biddableType: kotlin.String,
        @NotNull @Parameter(description = "The id of the biddable object", required = true) @Valid @RequestParam(value = "biddableId", required = true) biddableId: kotlin.Long,
        @NotNull @Parameter(description = "The bid amount for views. For ads, this is the amount that will be taken for each impression.", required = true) @Valid @RequestParam(value = "amountPerView", required = true) amountPerView: kotlin.Double,
        @NotNull @Parameter(description = "The bid amount for actions. For ads, this is the amount that will be taken for each click.", required = true) @Valid @RequestParam(value = "amountPerAction", required = true) amountPerAction: kotlin.Double,
        @NotNull @Parameter(description = "The allocated budget amount that will be used", required = true) @Valid @RequestParam(value = "budgetAmount", required = true) budgetAmount: kotlin.Double,
        @NotNull @Parameter(description = "The schedule for when the allocated budget amount is reset", required = true) @Valid @RequestParam(value = "budgetSchedule", required = true) budgetSchedule: kotlin.String,
        @Parameter(description = "The device id (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "The account id of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?
    ): ResponseEntity<BidResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Create Billable",
        operationId = "createBillableEntity",
        description = """reate a billable entity for an account. The creator is assumed to be the responsible account. An account can only have one billable entity""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = BillableEntityResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/billable/create"
        value = [PATH_CREATE_BILLABLE_ENTITY],
        produces = ["*/*"]
    )
    fun createBillableEntity(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "The unique device identifier that made the request (either deviceId or accountId must be used)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "The unique accountId that made the request (either deviceId or accountId must be used)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "The name of the entity responsible for billing ") @Valid @RequestParam(value = "name", required = false) name: kotlin.String?,
        @Parameter(description = "The street address of the billable entity") @Valid @RequestParam(value = "streetAddress", required = false) streetAddress: kotlin.String?,
        @Parameter(description = "Additional address information (such as a suite number, floor number, building name, or PO Box) ") @Valid @RequestParam(value = "streetAddress2", required = false) streetAddress2: kotlin.String?,
        @Parameter(description = "The city of the billable entity") @Valid @RequestParam(value = "city", required = false) city: kotlin.String?,
        @Parameter(description = "The state of the billable entity") @Valid @RequestParam(value = "state", required = false) state: kotlin.String?,
        @Parameter(description = "The postal code of the billable entity") @Valid @RequestParam(value = "postalCode", required = false) postalCode: kotlin.String?,
        @Parameter(description = "The business phone of the billable entity") @Valid @RequestParam(value = "businessPhone", required = false) businessPhone: kotlin.String?,
        @Parameter(description = "The business phone extension") @Valid @RequestParam(value = "businessPhoneExt", required = false) businessPhoneExt: kotlin.String?,
        @Parameter(description = "Authorize Net Api Key") @Valid @RequestParam(value = "authorizeNetApiKey", required = false) authorizeNetApiKey: kotlin.String?,
        @Parameter(description = "Authorize Net Transaction Key") @Valid @RequestParam(value = "authorizeNetTransactionKey", required = false) authorizeNetTransactionKey: kotlin.String?
    ): ResponseEntity<BillableEntityResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Create Cargo Type",
        operationId = "createCargoType",
        description = """Create new cargo type""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = CargoType::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/cargo/type"
        value = [PATH_CREATE_CARGO_TYPE],
        produces = ["*/*"]
    )
    fun createCargoType(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "") @Valid @RequestBody(required = false) body: CargoType?
    ): ResponseEntity<CargoType> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Create Category",
        operationId = "createCategory",
        description = """Create a new category.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = CategoryTreeResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/category/create"
        value = [PATH_CREATE_CATEGORY],
        produces = ["*/*"]
    )
    fun createCategory(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The account id of the user (must have permissions to the target application)", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "The name of the category", required = true) @Valid @RequestParam(value = "name", required = true) name: kotlin.String,
        @Parameter(description = "The appKey of the application to assign the category to, if not provided then the category will be applied to the global application (if the account has permissions)") @Valid @RequestParam(value = "appKey", required = false) appKey: kotlin.String?,
        @Parameter(description = "The ID of the parent category, if not provided then the parent category will be null") @Valid @RequestParam(value = "parentCategoryId", required = false) parentCategoryId: kotlin.Long?,
        @Parameter(description = "The description of the category") @Valid @RequestParam(value = "description", required = false) description: kotlin.String?,
        @Parameter(description = "The type of the category") @Valid @RequestParam(value = "type", required = false) type: kotlin.String?,
        @Parameter(description = "The ID of the image asset previously uploaded using the media service") @Valid @RequestParam(value = "assetId", required = false) assetId: kotlin.Long?,
        @Parameter(description = "A string identifier used by client applications to store external information") @Valid @RequestParam(value = "externalId", required = false) externalId: kotlin.String?,
        @Parameter(description = "A string type used by client applications to store external information") @Valid @RequestParam(value = "externalType", required = false) externalType: kotlin.String?,
        @Parameter(description = "external category slug") @Valid @RequestParam(value = "externalCategorySlug", required = false) externalCategorySlug: kotlin.String?,
        @Parameter(description = "sqoot slug") @Valid @RequestParam(value = "sqootSlug", required = false) sqootSlug: kotlin.String?,
        @Parameter(description = "Sets whether the category is active or inactive (hidden from consumers)") @Valid @RequestParam(value = "active", required = false) active: kotlin.Boolean?,
        @Parameter(description = "external custom client defined data") @Valid @RequestParam(value = "metaData", required = false) metaData: kotlin.String?,
        @Parameter(description = "user defined strings for searching") @Valid @RequestParam(value = "searchTags", required = false) searchTags: kotlin.String?
    ): ResponseEntity<CategoryTreeResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Create Creative",
        operationId = "createCreative",
        description = """Create a creative""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = CreativeResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/creative/create"
        value = [PATH_CREATE_CREATIVE],
        produces = ["*/*"]
    )
    fun createCreative(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The logged in user.", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "The name of the level.", required = true) @Valid @RequestParam(value = "name", required = true) name: kotlin.String,
        @NotNull @Parameter(description = "If true set the game level as active. Default is false.", required = true) @Valid @RequestParam(value = "active", required = true) active: kotlin.Boolean,
        @NotNull @Parameter(description = "determines whether the response will wait until the asset gets created", required = true) @Valid @RequestParam(value = "waitForAsset", required = true) waitForAsset: kotlin.Boolean,
        @Parameter(description = "The description of the level.") @Valid @RequestParam(value = "description", required = false) description: kotlin.String?,
        @Parameter(description = "The asset Id of the level image.") @Valid @RequestParam(value = "assetImageId", required = false) assetImageId: kotlin.Long?,
        @Parameter(description = "This parameter is deprecated. deprecated use data field") @Valid @RequestParam(value = "action", required = false) action: kotlin.String?,
        @Parameter(description = "The creative data, json based format depending on type. If not using action then data is required.") @Valid @RequestParam(value = "data", required = false) `data`: kotlin.String?,
        @Parameter(description = "This parameter is deprecated. deprecated use type field") @Valid @RequestParam(value = "suffix", required = false) suffix: kotlin.String?,
        @Parameter(description = "The type of creative. If not using suffix then type is required.") @Valid @RequestParam(value = "type", required = false) type: kotlin.String?,
        @Parameter(description = "Set the amount of money available to spend, once 0 deactivate level. Set to a negative value for unlimited.") @Valid @RequestParam(value = "balance", required = false) balance: kotlin.Double?,
        @Parameter(description = "if creative related so some other content provided the id") @Valid @RequestParam(value = "referenceId", required = false) referenceId: kotlin.Long?,
        @Parameter(description = "The version of the application, will not return creatives newer than the appVersion. Only used when requesting application configuration creatives.") @Valid @RequestParam(value = "appVersion", required = false) appVersion: kotlin.String?,
        @Parameter(description = "Assign the creative to a campaign for timing and audience matching.") @Valid @RequestParam(value = "missionId", required = false) missionId: kotlin.Long?,
        @Parameter(description = "the id of the offer") @Valid @RequestParam(value = "offerId", required = false) offerId: kotlin.Long?
    ): ResponseEntity<CreativeResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Create Credential",
        operationId = "createCredential",
        description = """This endpoint creates a third-party login for a Sirqul account. A third party login is a way for external systems (Third Party Networks) to link their own user accounts with a Sirqul account. 

The thirdPartyId parameter is used to determine if the user already exists in Sirqul or not. This parameter needs to be unique for each user in the Third Party Network (identified by the networkUID parameter). Note that subsequent calls will update the user's third-party login credentials for the user with the same thirdPartyId and networkUID combination. 

 The thirdPartyToken parameter acts as a shared secret and used by client applications to log users into Sirqul without providing a Sirqul username and password. """,
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = ProfileResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/thirdparty/credential/create"
        value = [PATH_CREATE_CREDENTIAL],
        produces = ["*/*"]
    )
    fun createCredential(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the third party user account id", required = true) @Valid @RequestParam(value = "thirdPartyId", required = true) thirdPartyId: kotlin.String,
        @NotNull @Parameter(description = "the access token to authenticate with (ex: username or fb token or phone number)", required = true) @Valid @RequestParam(value = "thirdPartyToken", required = true) thirdPartyToken: kotlin.String,
        @NotNull @Parameter(description = "the access provider to authenticate against", required = true) @Valid @RequestParam(value = "networkUID", required = true) networkUID: kotlin.String,
        @NotNull @Parameter(description = "the application key", required = true) @Valid @RequestParam(value = "appKey", required = true) appKey: kotlin.String,
        @Parameter(description = "the unique id of the account that needs authenticating (optional for PHONE_V2)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "the unique id of the device making the request") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "the session id for the request") @Valid @RequestParam(value = "sessionId", required = false) sessionId: kotlin.String?,
        @Parameter(description = "the third party user's display name") @Valid @RequestParam(value = "thirdPartyName", required = false) thirdPartyName: kotlin.String?,
        @Parameter(description = "optional email address associated with the third party account") @Valid @RequestParam(value = "emailAddress", required = false) emailAddress: kotlin.String?,
        @Parameter(description = "when true will error out if can't find any accounts matching (signin only)", schema = Schema(defaultValue = "false")) @Valid @RequestParam(value = "signinOnlyMode", required = false, defaultValue = "false") signinOnlyMode: kotlin.Boolean,
        @Parameter(description = "this determines how much of the profile should be returned, see ProfileFilters") @Valid @RequestParam(value = "responseFilters", required = false) responseFilters: kotlin.String?,
        @Parameter(description = "the latitude of the user") @Valid @RequestParam(value = "latitude", required = false) latitude: kotlin.Double?,
        @Parameter(description = "the longitude of the user") @Valid @RequestParam(value = "longitude", required = false) longitude: kotlin.Double?,
        @Parameter(description = "External custom client defined data") @Valid @RequestParam(value = "metaData", required = false) metaData: kotlin.String?,
        @Parameter(description = "optional refresh token for the third party") @Valid @RequestParam(value = "thirdPartyRefreshToken", required = false) thirdPartyRefreshToken: kotlin.String?,
        @Parameter(description = "audience ids to add to the account") @Valid @RequestParam(value = "audienceIdsToAdd", required = false) audienceIdsToAdd: kotlin.String?,
        @Parameter(description = "audience ids to remove from the account") @Valid @RequestParam(value = "audienceIdsToRemove", required = false) audienceIdsToRemove: kotlin.String?
    ): ResponseEntity<ProfileResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Create Data",
        operationId = "createData",
        description = """Create a record for the specified object.  If the object does not exist then a new one will be created prior to inserting the record.  If any of the fields included does not exist for the object then they are added to the object. """,
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = ObjectStoreResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/object/data/{objectName}"
        value = [PATH_CREATE_DATA],
        produces = ["*/*"]
    )
    fun createData(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "the name of the object to create data for", required = true) @PathVariable("objectName") objectName: kotlin.String,
        @Parameter(description = "the account id") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "") @Valid @RequestBody(required = false) body: kotlin.String?
    ): ResponseEntity<ObjectStoreResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Create Disbursement",
        operationId = "createDisbursement",
        description = """Creates a Disbursement for sending money to a retailer""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = DisbursementResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/disbursement/create"
        value = [PATH_CREATE_DISBURSEMENT],
        produces = ["*/*"]
    )
    fun createDisbursement(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the ID of the logging in user (must be an EXECUTIVE account)", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "the ID of the account receiving the disbursement", required = true) @Valid @RequestParam(value = "receiverAccountId", required = true) receiverAccountId: kotlin.Long,
        @NotNull @Parameter(description = "the ID of the original sender account", required = true) @Valid @RequestParam(value = "originalSenderAccountId", required = true) originalSenderAccountId: kotlin.Long,
        @NotNull @Parameter(description = "the dollar amount of the disbursement", required = true) @Valid @RequestParam(value = "amount", required = true) amount: java.math.BigDecimal,
        @NotNull @Parameter(description = "the provider (e.g. Authorize.net, Bill.com, etc.)", required = true, schema = Schema(allowableValues = ["AUTHORIZE_NET", "AMAZON_FPS", "BILL_COM"])) @Valid @RequestParam(value = "provider", required = true) provider: kotlin.String,
        @Parameter(description = "the date that the disbursement is scheduled to go out to the payment provider") @Valid @RequestParam(value = "scheduledDate", required = false) scheduledDate: kotlin.Long?,
        @Parameter(description = "a title given for the disbursement") @Valid @RequestParam(value = "title", required = false) title: kotlin.String?,
        @Parameter(description = "a comment that could be made for a disbursement") @Valid @RequestParam(value = "comment", required = false) comment: kotlin.String?,
        @Parameter(description = "external ID, which can be used as a way to reference the disbursement") @Valid @RequestParam(value = "externalId", required = false) externalId: kotlin.String?,
        @Parameter(description = "This is for specifying parameters to make an http callback request for validating that the disbursement is valid") @Valid @RequestParam(value = "introspectionParams", required = false) introspectionParams: kotlin.String?
    ): ResponseEntity<DisbursementResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Create Employee",
        operationId = "createEmployee",
        description = """Create a new account record with the provided information.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = EmployeeResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/employee/create"
        value = [PATH_CREATE_EMPLOYEE],
        produces = ["*/*"]
    )
    fun createEmployee(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The account id of the logged in user", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "The account id of the manager to assign under", required = true) @Valid @RequestParam(value = "managerAccountId", required = true) managerAccountId: kotlin.Long,
        @NotNull @Parameter(description = "The username/email for the new user. This must be unique across the entire the system.", required = true) @Valid @RequestParam(value = "username", required = true) username: kotlin.String,
        @NotNull @Parameter(description = "The password for the new user", required = true) @Valid @RequestParam(value = "password", required = true) password: kotlin.String,
        @Parameter(description = "a name field") @Valid @RequestParam(value = "name", required = false) name: kotlin.String?,
        @Parameter(description = "The name prefix; Mr, Mrs, etc") @Valid @RequestParam(value = "prefixName", required = false) prefixName: kotlin.String?,
        @Parameter(description = "The first name") @Valid @RequestParam(value = "firstName", required = false) firstName: kotlin.String?,
        @Parameter(description = "The middle name") @Valid @RequestParam(value = "middleName", required = false) middleName: kotlin.String?,
        @Parameter(description = "The last name") @Valid @RequestParam(value = "lastName", required = false) lastName: kotlin.String?,
        @Parameter(description = "The name suffix; Jr, Sr, III, etc") @Valid @RequestParam(value = "suffixName", required = false) suffixName: kotlin.String?,
        @Parameter(description = "The title of the user") @Valid @RequestParam(value = "title", required = false) title: kotlin.String?,
        @Parameter(description = "Additional about/biography text") @Valid @RequestParam(value = "aboutUs", required = false) aboutUs: kotlin.String?,
        @Parameter(description = "the asset id to set the user's profile image") @Valid @RequestParam(value = "assetId", required = false) assetId: kotlin.Long?,
        @Parameter(description = "The gender", schema = Schema(allowableValues = ["MALE", "FEMALE", "ANY"])) @Valid @RequestParam(value = "gender", required = false) gender: kotlin.String?,
        @Parameter(description = "The home phone number") @Valid @RequestParam(value = "homePhone", required = false) homePhone: kotlin.String?,
        @Parameter(description = "The cellular phone number") @Valid @RequestParam(value = "cellPhone", required = false) cellPhone: kotlin.String?,
        @Parameter(description = "The cellular service provider. This is required for sending SMS. Leave this empty if the provider is not on the list of supported carriers.") @Valid @RequestParam(value = "cellPhoneCarrier", required = false) cellPhoneCarrier: kotlin.String?,
        @Parameter(description = "The business phone number") @Valid @RequestParam(value = "businessPhone", required = false) businessPhone: kotlin.String?,
        @Parameter(description = "The user's contact email address (NOT the username)") @Valid @RequestParam(value = "emailAddress", required = false) emailAddress: kotlin.String?,
        @Parameter(description = "The street address of the user's contact location") @Valid @RequestParam(value = "streetAddress", required = false) streetAddress: kotlin.String?,
        @Parameter(description = "Additional address information (such as a suite number, floor number, building name, or PO Box)") @Valid @RequestParam(value = "streetAddress2", required = false) streetAddress2: kotlin.String?,
        @Parameter(description = "The city of the user's contact location") @Valid @RequestParam(value = "city", required = false) city: kotlin.String?,
        @Parameter(description = "The state of the user's contact location") @Valid @RequestParam(value = "state", required = false) state: kotlin.String?,
        @Parameter(description = "The zipcode of the user's contact location") @Valid @RequestParam(value = "zipcode", required = false) zipcode: kotlin.String?,
        @Parameter(description = "The country of the user's contact location") @Valid @RequestParam(value = "country", required = false) country: kotlin.String?,
        @Parameter(description = "The role; RETAILER or RETAILER_LIMITED, defaulted to RETAILER_LIMITED") @Valid @RequestParam(value = "role", required = false) role: kotlin.String?,
        @Parameter(description = "the retailer location IDs the employee is associated with") @Valid @RequestParam(value = "retailerLocationIds", required = false) retailerLocationIds: kotlin.String?,
        @Parameter(description = "Determines whether to return the application settings for the employee for a particular application") @Valid @RequestParam(value = "settingsAppKey", required = false) settingsAppKey: kotlin.String?,
        @Parameter(description = "external custom client defined data (per Application)") @Valid @RequestParam(value = "appBlob", required = false) appBlob: kotlin.String?,
        @Parameter(description = "The device id to assign to the user (used for IPS beacon tracking)") @Valid @RequestParam(value = "assignedDeviceId", required = false) assignedDeviceId: kotlin.String?
    ): ResponseEntity<EmployeeResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Create an entity reference.",
        operationId = "createEntityReference",
        description = """Creates a reference for an entity for syncing data between servers.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = ActivityResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/entity/reference"
        value = [PATH_CREATE_ENTITY_REFERENCE],
        produces = ["application/json"],
        consumes = ["application/json"]
    )
    fun createEntityReference(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "The entity reference object", required = true) @Valid @RequestBody body: EntityReference
    ): ResponseEntity<ActivityResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Create Event",
        operationId = "createEvent",
        description = """Create a private event to share with associates.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = OfferResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/event/create"
        value = [PATH_CREATE_EVENT],
        produces = ["*/*"]
    )
    fun createEvent(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The logged in user.", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "The event title", required = true) @Valid @RequestParam(value = "title", required = true) title: kotlin.String,
        @Parameter(description = "The retailer location to have the event at") @Valid @RequestParam(value = "retailerLocationIds", required = false) retailerLocationIds: kotlin.String?,
        @Parameter(description = "The event sub title") @Valid @RequestParam(value = "subTitle", required = false) subTitle: kotlin.String?,
        @Parameter(description = "The event details") @Valid @RequestParam(value = "details", required = false) details: kotlin.String?,
        @Parameter(description = "The categories the associate the event with") @Valid @RequestParam(value = "categoryIds", required = false) categoryIds: kotlin.String?,
        @Parameter(description = "The filters the associate the event with") @Valid @RequestParam(value = "filterIds", required = false) filterIds: kotlin.String?,
        @Parameter(description = "Is this event active") @Valid @RequestParam(value = "active", required = false) active: kotlin.Boolean?,
        @Parameter(description = "The image to show for the event") @Valid @RequestParam(value = "imageAssetId", required = false) imageAssetId: kotlin.Long?,
        @Parameter(description = "The event start date/time") @Valid @RequestParam(value = "redeemableStart", required = false) redeemableStart: kotlin.Long?,
        @Parameter(description = "The event end date/time") @Valid @RequestParam(value = "redeemableEnd", required = false) redeemableEnd: kotlin.Long?,
        @Parameter(description = "external custom client defined data") @Valid @RequestParam(value = "metaData", required = false) metaData: kotlin.String?
    ): ResponseEntity<OfferResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Create Filter",
        operationId = "createFilter",
        description = """Create a filter""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = FilterTreeResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/filter/create"
        value = [PATH_CREATE_FILTER],
        produces = ["*/*"]
    )
    fun createFilter(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The account id of the user (must have permissions to the target application)", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "The name of the filter", required = true) @Valid @RequestParam(value = "name", required = true) name: kotlin.String,
        @Parameter(description = "The appKey of the application to assign the filter to, if not provided then the filter will be applied to the global application (if the account has permissions)") @Valid @RequestParam(value = "appKey", required = false) appKey: kotlin.String?,
        @Parameter(description = "The ID of the parent filter, if not provided then the parent filter will be null") @Valid @RequestParam(value = "parentFilterId", required = false) parentFilterId: kotlin.Long?,
        @Parameter(description = "The description of the filter") @Valid @RequestParam(value = "description", required = false) description: kotlin.String?,
        @Parameter(description = "A string identifier used by client applications to store external information") @Valid @RequestParam(value = "externalId", required = false) externalId: kotlin.String?,
        @Parameter(description = "A string type used by client applications to store external information") @Valid @RequestParam(value = "externalType", required = false) externalType: kotlin.String?,
        @Parameter(description = "Sets whether the filter is active or inactive (hidden from consumers)") @Valid @RequestParam(value = "active", required = false) active: kotlin.Boolean?,
        @Parameter(description = "external custom client defined data") @Valid @RequestParam(value = "metaData", required = false) metaData: kotlin.String?
    ): ResponseEntity<FilterTreeResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Create Flag",
        operationId = "createFlag",
        description = """Allows a user to flag an object that the user deems inappropriate or offensive. Flagable objects include accounts, albums, album contests, assets, game levels, and theme descriptors""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/flag/create"
        value = [PATH_CREATE_FLAG],
        produces = ["*/*"]
    )
    fun createFlag(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The flagable object type {ACCOUNT, ALBUM, ALBUM_CONTEST, ASSET, GAME_LEVEL, THEME_DESCRIPTOR, NOTE, OFFER}", required = true) @Valid @RequestParam(value = "flagableType", required = true) flagableType: kotlin.String,
        @NotNull @Parameter(description = "The flagable object id", required = true) @Valid @RequestParam(value = "flagableId", required = true) flagableId: kotlin.Long,
        @Parameter(description = "The unique device identifier that made the request (either deviceId or accountId must be used)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "The unique accountId that made the request (either deviceId or accountId must be used)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "An optional description of why is it being flagged") @Valid @RequestParam(value = "flagDescription", required = false) flagDescription: kotlin.String?,
        @Parameter(description = "The current location of the user") @Valid @RequestParam(value = "latitude", required = false) latitude: kotlin.Double?,
        @Parameter(description = "The current location of the user") @Valid @RequestParam(value = "longitude", required = false) longitude: kotlin.Double?
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Create following",
        operationId = "createFollowing",
        description = """Create following.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation") ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/vatom/me/rels/following/create"
        value = [PATH_CREATE_FOLLOWING]
    )
    fun createFollowing(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "Sirqul Account Id", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "Vatom Parameters", required = true) @Valid @RequestParam(value = "vatomParameters", required = true) vatomParameters: kotlin.String,
        @Parameter(description = "Return raw response") @Valid @RequestParam(value = "returnRawResponse", required = false) returnRawResponse: kotlin.Boolean?
    ): ResponseEntity<Unit> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Create a Game",
        operationId = "createGame",
        description = """Create a Game.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = GameResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/game/create"
        value = [PATH_CREATE_GAME],
        produces = ["*/*"]
    )
    fun createGame(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "The logged in user.") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "The game application key to save the level for.") @Valid @RequestParam(value = "appKey", required = false) appKey: kotlin.String?,
        @Parameter(description = "Title of the game.") @Valid @RequestParam(value = "title", required = false) title: kotlin.String?,
        @Parameter(description = "Description of the game.") @Valid @RequestParam(value = "description", required = false) description: kotlin.String?,
        @Parameter(description = "metaData of the Game.") @Valid @RequestParam(value = "metaData", required = false) metaData: kotlin.String?,
        @Parameter(description = "comma separated String of pack Ids that will associate with the game.") @Valid @RequestParam(value = "packIds", required = false) packIds: kotlin.String?,
        @Parameter(description = "Show more details in response.") @Valid @RequestParam(value = "includeGameData", required = false) includeGameData: kotlin.Boolean?
    ): ResponseEntity<GameResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Create Game Level",
        operationId = "createGameLevel",
        description = """Create a game level. Currently does NOT support game objects.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = GameLevelResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/level/create"
        value = [PATH_CREATE_GAME_LEVEL],
        produces = ["*/*"]
    )
    fun createGameLevel(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The logged in user.", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "The name of the level.", required = true) @Valid @RequestParam(value = "name", required = true) name: kotlin.String,
        @NotNull @Parameter(description = "The game level data: xml, json, or other text based format.", required = true) @Valid @RequestParam(value = "gameData", required = true) gameData: kotlin.String,
        @NotNull @Parameter(description = "The game level data format type.", required = true) @Valid @RequestParam(value = "gameDataSuffix", required = true) gameDataSuffix: kotlin.String,
        @Parameter(description = "The game application key to save the level for.") @Valid @RequestParam(value = "appKey", required = false) appKey: kotlin.String?,
        @Parameter(description = "The description of the level.") @Valid @RequestParam(value = "description", required = false) description: kotlin.String?,
        @Parameter(description = "The difficulty, possible values are: VERY_EASY, EASY, MEDIUM, HARD, VERY_HARD.") @Valid @RequestParam(value = "difficulty", required = false) difficulty: kotlin.String?,
        @Parameter(description = "The version number of the application required to correctly load/play the level.") @Valid @RequestParam(value = "appVersion", required = false) appVersion: kotlin.String?,
        @Parameter(description = "The asset Id of the level image.") @Valid @RequestParam(value = "assetImageId", required = false) assetImageId: kotlin.Long?,
        @Parameter(description = "The asset Id of the level icon.") @Valid @RequestParam(value = "assetIconId", required = false) assetIconId: kotlin.Long?,
        @Parameter(description = "Is the level visible to others, possible values are: PUBLIC, PRIVATE.") @Valid @RequestParam(value = "visibility", required = false) visibility: kotlin.String?,
        @Parameter(description = "Make the level be readable by all friends.") @Valid @RequestParam(value = "friendGroup", required = false) friendGroup: kotlin.Boolean?,
        @Parameter(description = "Make the level be readable by connections in this list.") @Valid @RequestParam(value = "connectionIds", required = false) connectionIds: kotlin.String?,
        @Parameter(description = "Make the level be readable by connection groups in this list.") @Valid @RequestParam(value = "connectionGroupIds", required = false) connectionGroupIds: kotlin.String?,
        @Parameter(description = "Set the amount of money available to spend, once 0 deactivate level. Set to a negative value for unlimited.") @Valid @RequestParam(value = "balance", required = false) balance: kotlin.Double?,
        @Parameter(description = "If true set the game level as active. Default is false.") @Valid @RequestParam(value = "active", required = false) active: kotlin.Boolean?,
        @Parameter(description = "If true then scoring will give tickets. Default is false.") @Valid @RequestParam(value = "allocateTickets", required = false) allocateTickets: kotlin.Boolean?,
        @Parameter(description = "The number of tickets to reward") @Valid @RequestParam(value = "ticketCount", required = false) ticketCount: kotlin.Long?,
        @Parameter(description = "The type of ticket to reward, null means default type") @Valid @RequestParam(value = "ticketType", required = false) ticketType: kotlin.String?,
        @Parameter(description = "The number of points to award for completing a level") @Valid @RequestParam(value = "points", required = false) points: kotlin.Long?,
        @Parameter(description = "Title of the tutorial.") @Valid @RequestParam(value = "tutorialTitle", required = false) tutorialTitle: kotlin.String?,
        @Parameter(description = "Message of the tutotrial.") @Valid @RequestParam(value = "tutorialMessage", required = false) tutorialMessage: kotlin.String?,
        @Parameter(description = "Alignment of the tutorial image. Default to NONE. Possible values are: NONE, IMAGE_ABOVE, IMAGE_BELOW, IMAGE_LEFT, IMAGE_RIGHT, IMAGE_ONLY, TEXT_ONLY") @Valid @RequestParam(value = "tutorialAlignment", required = false) tutorialAlignment: kotlin.String?,
        @Parameter(description = "Asset id of the tutorial image.") @Valid @RequestParam(value = "tutorialImageAssetId", required = false) tutorialImageAssetId: kotlin.Long?,
        @Parameter(description = "id of the offer") @Valid @RequestParam(value = "offerId", required = false) offerId: kotlin.Long?,
        @Parameter(description = "external custom client defined data") @Valid @RequestParam(value = "metaData", required = false) metaData: kotlin.String?
    ): ResponseEntity<GameLevelResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Creates an instant episode",
        operationId = "createInstantEpisode",
        description = """Creates an instant episode for a given StoryStrip by providing all necessary inputs, interview recordings, and pictures, kicking off a render immediately.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = OrsonEpisodeResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/orson/stories/episodes/instant"
        value = [PATH_CREATE_INSTANT_EPISODE],
        produces = ["*/*"]
    )
    fun createInstantEpisode(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "Sirqul Account Id", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "Request Data String", required = true) @Valid @RequestParam(value = "data", required = true) `data`: kotlin.String
    ): ResponseEntity<OrsonEpisodeResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Create a leaderboard based on the rankingType, rankMode(leaderboardMode), sortField and limitation",
        operationId = "createLeaderboard",
        description = """Create a leaderboard based on the rankingType, rankMode(leaderboardMode), sortField and limitation""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = LeaderboardResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/leaderboard/create"
        value = [PATH_CREATE_LEADERBOARD],
        produces = ["*/*"]
    )
    fun createLeaderboard(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "The account id of the user creating the leaderboard.") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "The application key") @Valid @RequestParam(value = "appKey", required = false) appKey: kotlin.String?,
        @Parameter(description = "a unique label for identifying the ranking. This can be any alphanumeric string with a maximum length of 64 characters. There are also default rank types to use which include: POINTS, DOWNLOADS, INVITATIONS, CREATIONS, VOTES, REDEEMED, ACTIONS") @Valid @RequestParam(value = "rankType", required = false) rankType: kotlin.String?,
        @Parameter(description = "the type of search to perform. Possible values include: GLOBAL - searches scores globally (all users in the system are included in the ranking); LOCAL - filters results by select users and on users that have logged into the same device; SEARCH - does a GLOBAL search by keyword; CUSTOM - does a LOCAL search by keyword") @Valid @RequestParam(value = "leaderboardMode", required = false) leaderboardMode: kotlin.String?,
        @Parameter(description = "a MultipartFile containing the icon image of the leaderboard (this will only be used if \"iconAssetId\" is empty)") @Valid @RequestParam(value = "iconMedia", required = false) iconMedia: org.springframework.web.multipart.MultipartFile,
        @Parameter(description = "The asset ID to set the leaderboard icon") @Valid @RequestParam(value = "iconAssetId", required = false) iconAssetId: kotlin.Long?,
        @Parameter(description = "a MultipartFile containing the icon banner of the leaderboard (this will only be used if \"bannerAssetId\" is empty)") @Valid @RequestParam(value = "bannerMedia", required = false) bannerMedia: org.springframework.web.multipart.MultipartFile,
        @Parameter(description = "The asset ID to set the leaderboard banner") @Valid @RequestParam(value = "bannerAssetId", required = false) bannerAssetId: kotlin.Long?,
        @Parameter(description = "limit number of rankings for each leaderboard") @Valid @RequestParam(value = "limitation", required = false) limitation: kotlin.Int?,
        @Parameter(description = "determines how to order and rank the results. Possible values include: TOTAL, WEEKLY, DAILY, TOP, LOWEST") @Valid @RequestParam(value = "sortField", required = false) sortField: kotlin.String?,
        @Parameter(description = "leaderboard's title") @Valid @RequestParam(value = "title", required = false) title: kotlin.String?,
        @Parameter(description = "leaderboard's description") @Valid @RequestParam(value = "description", required = false) description: kotlin.String?,
        @Parameter(description = "custom meta data for the leaderboard") @Valid @RequestParam(value = "metaData", required = false) metaData: kotlin.String?
    ): ResponseEntity<LeaderboardResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Create Listing",
        operationId = "createListing",
        description = """Creates a listing.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = ListingFullResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/listing/create"
        value = [PATH_CREATE_LISTING],
        produces = ["*/*"]
    )
    fun createListing(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the user's account ID", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "the name of the listing", required = true) @Valid @RequestParam(value = "name", required = true) name: kotlin.String,
        @Parameter(description = "comma separated list of filter IDs") @Valid @RequestParam(value = "filterIds", required = false) filterIds: kotlin.String?,
        @Parameter(description = "the description of the listing") @Valid @RequestParam(value = "description", required = false) description: kotlin.String?,
        @Parameter(description = "the start date of the listing") @Valid @RequestParam(value = "start", required = false) start: kotlin.Long?,
        @Parameter(description = "the end date of the listing") @Valid @RequestParam(value = "end", required = false) end: kotlin.Long?,
        @Parameter(description = "the name of the location the listing will be held at") @Valid @RequestParam(value = "locationName", required = false) locationName: kotlin.String?,
        @Parameter(description = "the description of the location the listing will be held at") @Valid @RequestParam(value = "locationDescription", required = false) locationDescription: kotlin.String?,
        @Parameter(description = "determines whether the listing is public or private", schema = Schema(defaultValue = "false")) @Valid @RequestParam(value = "isPrivate", required = false, defaultValue = "false") isPrivate: kotlin.Boolean,
        @Parameter(description = "external identifier used by a third party") @Valid @RequestParam(value = "externalId", required = false) externalId: kotlin.String?,
        @Parameter(description = "secondary external identifier used by a third party") @Valid @RequestParam(value = "externalId2", required = false) externalId2: kotlin.String?,
        @Parameter(description = "external group identifier used by a third party") @Valid @RequestParam(value = "externalGroupId", required = false) externalGroupId: kotlin.String?,
        @Parameter(description = "Sets the active flag") @Valid @RequestParam(value = "active", required = false) active: kotlin.Boolean?,
        @Parameter(description = "external custom client defined data") @Valid @RequestParam(value = "metaData", required = false) metaData: kotlin.String?
    ): ResponseEntity<ListingFullResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Create new location",
        operationId = "createLocationV2",
        description = """Create a new location from a real object location.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/location"
        value = [PATH_CREATE_LOCATION_V2],
        produces = ["*/*"]
    )
    fun createLocationV2(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "") @Valid @RequestBody(required = false) body: Location?
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Create Media",
        operationId = "createMedia",
        description = """Create a media offering.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = MediaOfferResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/media/create"
        value = [PATH_CREATE_MEDIA],
        produces = ["*/*"]
    )
    fun createMedia(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The account id of the logged in user", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "The title (255 char limit)", required = true) @Valid @RequestParam(value = "title", required = true) title: kotlin.String,
        @NotNull @Parameter(description = "The bar code type {NONE, UPC, CODE_128, QR, CUSTOM_MEDIA}", required = true, schema = Schema(allowableValues = ["NONE", "UPC", "CODE_128", "QR", "CUSTOM_MEDIA"])) @Valid @RequestParam(value = "barcodeType", required = true) barcodeType: kotlin.String,
        @NotNull @Parameter(description = "Overrides the expiration date so that the offer does not expire", required = true) @Valid @RequestParam(value = "noExpiration", required = true) noExpiration: kotlin.Boolean,
        @NotNull @Parameter(description = "The limit of how many times the offer can be used by consumers", required = true) @Valid @RequestParam(value = "availableLimit", required = true) availableLimit: kotlin.Int,
        @NotNull @Parameter(description = "The limit of how many times a user can used the same offer", required = true) @Valid @RequestParam(value = "availableLimitPerUser", required = true) availableLimitPerUser: kotlin.Int,
        @NotNull @Parameter(description = "The limit of how many times the offer can be added to consumer wallets", required = true) @Valid @RequestParam(value = "addedLimit", required = true) addedLimit: kotlin.Int,
        @NotNull @Parameter(description = "The limit of how many times the offer can be viewed", required = true) @Valid @RequestParam(value = "viewLimit", required = true) viewLimit: kotlin.Int,
        @NotNull @Parameter(description = "The maximum number of times the offer can be printed", required = true) @Valid @RequestParam(value = "maxPrints", required = true) maxPrints: kotlin.Int,
        @NotNull @Parameter(description = "The cost of the offer in tickets", required = true) @Valid @RequestParam(value = "ticketPrice", required = true) ticketPrice: kotlin.Long,
        @NotNull @Parameter(description = "The retail/full price cost of the offer in real currency", required = true) @Valid @RequestParam(value = "fullPrice", required = true) fullPrice: kotlin.Double,
        @NotNull @Parameter(description = "The cost of the offer at a discounted price (what the consumer pays)", required = true) @Valid @RequestParam(value = "discountPrice", required = true) discountPrice: kotlin.Double,
        @NotNull @Parameter(description = "The special offer type {ALL, REGULAR_OFFER, ACT_NOW, GET_THERE_NOW}", required = true, schema = Schema(allowableValues = ["ALL", "RESERVABLE", "REGULAR_OFFER", "ACT_NOW", "GET_THERE_NOW", "SQOOT", "TICKETS", "YIPIT"])) @Valid @RequestParam(value = "specialOfferType", required = true) specialOfferType: kotlin.String,
        @NotNull @Parameter(description = "The offer visibility {PUBLIC, REWARDABLE, TRIGGERABLE}", required = true, schema = Schema(allowableValues = ["PUBLIC", "LISTABLE", "REWARDABLE", "TRIGGERABLE", "PRIVATE"])) @Valid @RequestParam(value = "offerVisibility", required = true) offerVisibility: kotlin.String,
        @NotNull @Parameter(description = "Sets the active flag", required = true) @Valid @RequestParam(value = "active", required = true) active: kotlin.Boolean,
        @Parameter(description = "Comma separated list of retailer location ids. This will assign the offer to these retailer locations.") @Valid @RequestParam(value = "retailerLocationIds", required = false) retailerLocationIds: kotlin.String?,
        @Parameter(description = "The sub title (255 char limit)") @Valid @RequestParam(value = "subTitle", required = false) subTitle: kotlin.String?,
        @Parameter(description = "The details of the media") @Valid @RequestParam(value = "details", required = false) details: kotlin.String?,
        @Parameter(description = "A string for custom details (255 char limit)") @Valid @RequestParam(value = "subDetails", required = false) subDetails: kotlin.String?,
        @Parameter(description = "The fine print of the media") @Valid @RequestParam(value = "finePrint", required = false) finePrint: kotlin.String?,
        @Parameter(description = "The bar code entry string") @Valid @RequestParam(value = "barcodeEntry", required = false) barcodeEntry: kotlin.String?,
        @Parameter(description = "An external identifier. What the identifier will be used for and how it is formatted is up to the frontend developer") @Valid @RequestParam(value = "externalRedeemOptions", required = false) externalRedeemOptions: kotlin.String?,
        @Parameter(description = "The clickUrl of the offer") @Valid @RequestParam(value = "externalUrl", required = false) externalUrl: kotlin.String?,
        @Parameter(description = "The type of ticket to reward, null means default type") @Valid @RequestParam(value = "ticketsRewardType", required = false) ticketsRewardType: kotlin.String?,
        @Parameter(description = "Determines how many tickets are awarded") @Valid @RequestParam(value = "ticketsReward", required = false) ticketsReward: kotlin.Long?,
        @Parameter(description = "The date of when the offer will be visible to consumers") @Valid @RequestParam(value = "activated", required = false) activated: kotlin.Long?,
        @Parameter(description = "The date of when the offer expires") @Valid @RequestParam(value = "expires", required = false) expires: kotlin.Long?,
        @Parameter(description = "the type of ticket needed to buy offer") @Valid @RequestParam(value = "ticketPriceType", required = false) ticketPriceType: kotlin.String?,
        @Parameter(description = "show how many of the media is remaining (if there is a limit)") @Valid @RequestParam(value = "showRemaining", required = false) showRemaining: kotlin.Boolean?,
        @Parameter(description = "show how many of the media has been redeemed") @Valid @RequestParam(value = "showRedeemed", required = false) showRedeemed: kotlin.Boolean?,
        @Parameter(description = "if the media has been replaced") @Valid @RequestParam(value = "replaced", required = false) replaced: kotlin.Boolean?,
        @Parameter(description = "if the media should be featured or not") @Valid @RequestParam(value = "featured", required = false) featured: kotlin.Boolean?,
        @Parameter(description = "Comma separated list of category ids") @Valid @RequestParam(value = "categoryIds", required = false) categoryIds: kotlin.String?,
        @Parameter(description = "Comma separated list of filter ids") @Valid @RequestParam(value = "filterIds", required = false) filterIds: kotlin.String?,
        @Parameter(description = "The id of the barcode asset") @Valid @RequestParam(value = "barcodeAssetId", required = false) barcodeAssetId: kotlin.Long?,
        @Parameter(description = "The id of the an offer asset") @Valid @RequestParam(value = "imageAssetId", required = false) imageAssetId: kotlin.Long?,
        @Parameter(description = "The id of the an offer asset") @Valid @RequestParam(value = "imageAssetId1", required = false) imageAssetId1: kotlin.Long?,
        @Parameter(description = "The id of the an offer asset") @Valid @RequestParam(value = "imageAssetId2", required = false) imageAssetId2: kotlin.Long?,
        @Parameter(description = "The id of the an offer asset") @Valid @RequestParam(value = "imageAssetId3", required = false) imageAssetId3: kotlin.Long?,
        @Parameter(description = "The id of the an offer asset") @Valid @RequestParam(value = "imageAssetId4", required = false) imageAssetId4: kotlin.Long?,
        @Parameter(description = "The id of the an offer asset") @Valid @RequestParam(value = "imageAssetId5", required = false) imageAssetId5: kotlin.Long?,
        @Parameter(description = "The maker of the item.") @Valid @RequestParam(value = "publisher", required = false) publisher: kotlin.String?,
        @Parameter(description = "The redeemable start date/time of the offer.") @Valid @RequestParam(value = "redeemableStart", required = false) redeemableStart: kotlin.Long?,
        @Parameter(description = "The redeemable start date/time of the offer.") @Valid @RequestParam(value = "redeemableEnd", required = false) redeemableEnd: kotlin.Long?,
        @Parameter(description = "The condition type of the media", schema = Schema(allowableValues = ["NEW", "USED", "REFURBISHED", "OTHER"])) @Valid @RequestParam(value = "conditionType", required = false) conditionType: kotlin.String?,
        @Parameter(description = "The ISBN id") @Valid @RequestParam(value = "isbn", required = false) isbn: kotlin.String?,
        @Parameter(description = "The ASIN id") @Valid @RequestParam(value = "asin", required = false) asin: kotlin.String?,
        @Parameter(description = "The list of catelog numbers, comma seperated") @Valid @RequestParam(value = "catalogNumbers", required = false) catalogNumbers: kotlin.String?,
        @Parameter(description = "The parental control rating") @Valid @RequestParam(value = "parentalRating", required = false) parentalRating: kotlin.String?,
        @Parameter(description = "The date the media is available to use") @Valid @RequestParam(value = "availabilityDate", required = false) availabilityDate: kotlin.Long?,
        @Parameter(description = "the media type", schema = Schema(allowableValues = ["APK", "APPLICATION", "IMAGE", "AUDIO", "VIDEO", "MULTIPART", "BAR_CODE", "TEXT", "OTHER"])) @Valid @RequestParam(value = "mediaType", required = false) mediaType: kotlin.String?,
        @Parameter(description = "The total playing time of the media item") @Valid @RequestParam(value = "duration", required = false) duration: kotlin.Int?,
        @Parameter(description = "The created/author of the media item") @Valid @RequestParam(value = "author", required = false) author: kotlin.String?,
        @Parameter(description = "The date/time of when the media item was originally released") @Valid @RequestParam(value = "releaseDate", required = false) releaseDate: kotlin.Long?,
        @Parameter(description = "the IDs of the collections this media should be assigned to") @Valid @RequestParam(value = "collectionIds", required = false) collectionIds: kotlin.String?,
        @Parameter(description = "ability to assign if this media should active or not") @Valid @RequestParam(value = "availability", required = false) availability: kotlin.String?,
        @Parameter(description = "ability to assign when the media expires") @Valid @RequestParam(value = "availabilitySummary", required = false) availabilitySummary: kotlin.String?
    ): ResponseEntity<MediaOfferResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Create Mission",
        operationId = "createMission",
        description = """Create a user defined mission.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = MissionResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/mission/create"
        value = [PATH_CREATE_MISSION],
        produces = ["*/*"]
    )
    fun createMission(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The logged in user.", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "The title of the mission", required = true) @Valid @RequestParam(value = "title", required = true) title: kotlin.String,
        @Parameter(description = "The description of the mission") @Valid @RequestParam(value = "description", required = false) description: kotlin.String?,
        @Parameter(description = "Custom string client apps can use for searching/filtering missions") @Valid @RequestParam(value = "subType", required = false) subType: kotlin.String?,
        @Parameter(description = "The date/time to start the mission, send 0 to unset") @Valid @RequestParam(value = "startDate", required = false) startDate: kotlin.Long?,
        @Parameter(description = "The date/time to end the mission, send 0 to unset") @Valid @RequestParam(value = "endDate", required = false) endDate: kotlin.Long?,
        @Parameter(description = "Activate/deactivate the mission") @Valid @RequestParam(value = "active", required = false) active: kotlin.Boolean?,
        @Parameter(description = "the game level ids to include in the mission, comma separated") @Valid @RequestParam(value = "gameLevelIds", required = false) gameLevelIds: kotlin.String?,
        @Parameter(description = "creatives to associate with the mission") @Valid @RequestParam(value = "creativeIds", required = false) creativeIds: kotlin.String?,
        @Parameter(description = "audiences to associate with the mission") @Valid @RequestParam(value = "audienceIds", required = false) audienceIds: kotlin.String?,
        @Parameter(description = "This parameter is deprecated.") @Valid @RequestParam(value = "missionTask", required = false) missionTask: kotlin.String?,
        @Parameter(description = "The string identifier for a mission format (this is not the missionFormatId)") @Valid @RequestParam(value = "formatType", required = false) formatType: kotlin.String?,
        @Parameter(description = "The offerId to give as a reward") @Valid @RequestParam(value = "offerId", required = false) offerId: kotlin.Long?,
        @Parameter(description = "Set the amount of money available to spend, once 0 deactivate mission. Set to a negative value for unlimited.") @Valid @RequestParam(value = "balance", required = false) balance: kotlin.Double?,
        @Parameter(description = "Flag to mark the mission as eligible for advanced reporting") @Valid @RequestParam(value = "advancedReporting", required = false) advancedReporting: kotlin.Boolean?,
        @Parameter(description = "Flag to indicate owner should receive tickets for completed missions") @Valid @RequestParam(value = "allocateTickets", required = false) allocateTickets: kotlin.Boolean?,
        @Parameter(description = "The number of tickets to reward") @Valid @RequestParam(value = "ticketCount", required = false) ticketCount: kotlin.Long?,
        @Parameter(description = "The type of ticket to reward, null means default type") @Valid @RequestParam(value = "ticketType", required = false) ticketType: kotlin.String?,
        @Parameter(description = "The number of points to award for completing a mission") @Valid @RequestParam(value = "points", required = false) points: kotlin.Long?,
        @Parameter(description = "external custom client defined data") @Valid @RequestParam(value = "metaData", required = false) metaData: kotlin.String?,
        @Parameter(description = "Comma separated list of application ids") @Valid @RequestParam(value = "applicationIds", required = false) applicationIds: kotlin.String?,
        @Parameter(description = "Deprecated parameter for device names") @Valid @RequestParam(value = "devices", required = false) devices: kotlin.String?,
        @Parameter(description = "Comma separated list of device ids") @Valid @RequestParam(value = "deviceIds", required = false) deviceIds: kotlin.String?,
        @Parameter(description = "Comma separated list of device version ranges") @Valid @RequestParam(value = "deviceVersions", required = false) deviceVersions: kotlin.String?,
        @Parameter(description = "List of lat/long pairs for mission locations") @Valid @RequestParam(value = "locations", required = false) locations: kotlin.String?,
        @Parameter(description = "Comma separated list of radii for locations") @Valid @RequestParam(value = "radius", required = false) radius: kotlin.String?
    ): ResponseEntity<MissionResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Create Mission Invite",
        operationId = "createMissionInvite",
        description = """Create the mission invite. An account can only be invited to a mission one time. For missions that require user submission and reviewing the permissionableType and permissionableId need to be provided.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = MissionResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/mission/invite/create"
        value = [PATH_CREATE_MISSION_INVITE],
        produces = ["*/*"]
    )
    fun createMissionInvite(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "the device id (deviceId or accountId required).") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "the account id of the user (deviceId or accountId required).") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "The mission to find the invite for.") @Valid @RequestParam(value = "missionId", required = false) missionId: kotlin.Long?,
        @Parameter(description = "code to be entered for user to join the mission") @Valid @RequestParam(value = "joinCode", required = false) joinCode: kotlin.String?,
        @Parameter(description = "Include the game level data with the mission.") @Valid @RequestParam(value = "includeGameData", required = false) includeGameData: kotlin.Boolean?
    ): ResponseEntity<MissionResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Create Network",
        operationId = "createNetwork",
        description = """Creates a custom third party network.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = ThirdPartyNetworkResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/thirdparty/network/create"
        value = [PATH_CREATE_NETWORK],
        produces = ["*/*"]
    )
    fun createNetwork(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The account id making the request", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "The name of the network", required = true) @Valid @RequestParam(value = "name", required = true) name: kotlin.String,
        @NotNull @Parameter(description = "Whether the network uses introspection calls", required = true) @Valid @RequestParam(value = "enableIntrospection", required = true) enableIntrospection: kotlin.Boolean,
        @Parameter(description = "The description of the network") @Valid @RequestParam(value = "description", required = false) description: kotlin.String?,
        @Parameter(description = "HTTP method to use for introspection calls (e.g., GET, POST)") @Valid @RequestParam(value = "introspectionMethod", required = false) introspectionMethod: kotlin.String?,
        @Parameter(description = "The HTTP URL of the introspection call") @Valid @RequestParam(value = "introspectionURL", required = false) introspectionURL: kotlin.String?,
        @Parameter(description = "The parameters of the introspection call") @Valid @RequestParam(value = "introspectionParams", required = false) introspectionParams: kotlin.String?,
        @Parameter(description = "Required response params") @Valid @RequestParam(value = "requiredRootField", required = false) requiredRootField: kotlin.String?,
        @Parameter(description = "Whether this network uses MFA") @Valid @RequestParam(value = "enableMFA", required = false) enableMFA: kotlin.Boolean?,
        @Parameter(description = "Size of the MFA token") @Valid @RequestParam(value = "sizeMFA", required = false) sizeMFA: kotlin.Int?,
        @Parameter(description = "Shelf life (seconds) of the MFA token") @Valid @RequestParam(value = "shelfLifeMFA", required = false) shelfLifeMFA: kotlin.Int?,
        @Parameter(description = "OAuth token endpoint URL") @Valid @RequestParam(value = "oauthTokenURL", required = false) oauthTokenURL: kotlin.String?,
        @Parameter(description = "OAuth private key file (multipart)") @Valid @RequestParam(value = "oauthPrivateKey", required = false) oauthPrivateKey: org.springframework.web.multipart.MultipartFile,
        @Parameter(description = "OAuth public key file (multipart)") @Valid @RequestParam(value = "oauthPublicKey", required = false) oauthPublicKey: org.springframework.web.multipart.MultipartFile,
        @Parameter(description = "OAuth client id") @Valid @RequestParam(value = "oauthClientId", required = false) oauthClientId: kotlin.String?,
        @Parameter(description = "OAuth secret key") @Valid @RequestParam(value = "oauthSecretKey", required = false) oauthSecretKey: kotlin.String?,
        @Parameter(description = "") @Valid @RequestBody(required = false) body: kotlin.String?
    ): ResponseEntity<ThirdPartyNetworkResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Create Note",
        operationId = "createNote",
        description = """This is used to leave a comment (note) on a notable object (i.e. albums, album contests, assets, game levels, offers, offer locations, retailers, retailer locations, and theme descriptors). Leaving a comment on a notable object will be visiable to everyone who has access to view the object.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = NoteResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/note/create"
        value = [PATH_CREATE_NOTE],
        produces = ["*/*"]
    )
    fun createNote(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The message the user wishes to leave a comment on", required = true) @Valid @RequestParam(value = "comment", required = true) comment: kotlin.String,
        @Parameter(description = "The unique device identifier that made the request (either deviceId or accountId must be used)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "The unique accountId that made the request (either deviceId or accountId must be used)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "The notable object type {ALBUM, ALBUM_CONTEST, ASSET, GAME_LEVEL, OFFER, OFFER_LOCATION, RETAILER, RETAILER_LOCATION, THEME_DESCRIPTOR}") @Valid @RequestParam(value = "notableType", required = false) notableType: kotlin.String?,
        @Parameter(description = "The id of the notable object") @Valid @RequestParam(value = "notableId", required = false) notableId: kotlin.Long?,
        @Parameter(description = "The custom string defined by the client (used for differentiating various note types)") @Valid @RequestParam(value = "noteType", required = false) noteType: kotlin.String?,
        @Parameter(description = "A comma separated list of asset IDs to add with the note") @Valid @RequestParam(value = "assetIds", required = false) assetIds: kotlin.String?,
        @Parameter(description = "search tags") @Valid @RequestParam(value = "tags", required = false) tags: kotlin.String?,
        @Parameter(description = "This is used for sending out group notifications. For example, when someone adds a note to an asset which is also a part of an album, everyone in the album will receive a notification. This is achieved by passing in the permissionable type (in this case \"album\"), and the permissionable id (the album id). Possible types: {ALBUM, ALBUM_CONTEST, GAME_LEVEL, THEME_DESCRIPTOR}") @Valid @RequestParam(value = "permissionableType", required = false) permissionableType: kotlin.String?,
        @Parameter(description = "The id of the permissionable object (for sending group notifications)") @Valid @RequestParam(value = "permissionableId", required = false) permissionableId: kotlin.Long?,
        @Parameter(description = "The application key used to identify the application") @Valid @RequestParam(value = "appKey", required = false) appKey: kotlin.String?,
        @Parameter(description = "The description of the location") @Valid @RequestParam(value = "locationDescription", required = false) locationDescription: kotlin.String?,
        @Parameter(description = "The current location of the user") @Valid @RequestParam(value = "latitude", required = false) latitude: kotlin.Double?,
        @Parameter(description = "The current location of the user") @Valid @RequestParam(value = "longitude", required = false) longitude: kotlin.Double?,
        @Parameter(description = "External custom client defined data") @Valid @RequestParam(value = "metaData", required = false) metaData: kotlin.String?,
        @Parameter(description = "Comma separated list of additional account IDs that will receive the note notifications") @Valid @RequestParam(value = "receiverAccountIds", required = false) receiverAccountIds: kotlin.String?,
        @Parameter(description = "whether to return the full response or not") @Valid @RequestParam(value = "returnFullResponse", required = false) returnFullResponse: kotlin.Boolean?,
        @Parameter(description = "Check true if need to initialize an asset and assign to current note") @Valid @RequestParam(value = "initializeAsset", required = false) initializeAsset: kotlin.Boolean?,
        @Parameter(description = "Return null fields for asset response when creating an asset") @Valid @RequestParam(value = "assetReturnNulls", required = false) assetReturnNulls: kotlin.Boolean?,
        @Parameter(description = "the album the asset will be added to (optional)") @Valid @RequestParam(value = "assetAlbumId", required = false) assetAlbumId: kotlin.Long?,
        @Parameter(description = "the collection ID that the asset is associated with") @Valid @RequestParam(value = "assetCollectionId", required = false) assetCollectionId: kotlin.Long?,
        @Parameter(description = "the default album to add the asset to") @Valid @RequestParam(value = "assetAddToDefaultAlbum", required = false) assetAddToDefaultAlbum: kotlin.String?,
        @Parameter(description = "the media library to add the asset to") @Valid @RequestParam(value = "assetAddToMediaLibrary", required = false) assetAddToMediaLibrary: kotlin.Boolean?,
        @Parameter(description = "the version code of the asset") @Valid @RequestParam(value = "assetVersionCode", required = false) assetVersionCode: kotlin.Int?,
        @Parameter(description = "the version name of the asset") @Valid @RequestParam(value = "assetVersionName", required = false) assetVersionName: kotlin.String?,
        @Parameter(description = "the meta data of the asset") @Valid @RequestParam(value = "assetMetaData", required = false) assetMetaData: kotlin.String?,
        @Parameter(description = "the caption of the asset") @Valid @RequestParam(value = "assetCaption", required = false) assetCaption: kotlin.String?,
        @Parameter(description = "the media of the asset") @Valid @RequestParam(value = "assetMedia", required = false) assetMedia: org.springframework.web.multipart.MultipartFile,
        @Parameter(description = "the media URL of the asset") @Valid @RequestParam(value = "assetMediaUrl", required = false) assetMediaUrl: kotlin.String?,
        @Parameter(description = "the media string of the asset") @Valid @RequestParam(value = "assetMediaString", required = false) assetMediaString: kotlin.String?,
        @Parameter(description = "the media string file name of the asset") @Valid @RequestParam(value = "assetMediaStringFileName", required = false) assetMediaStringFileName: kotlin.String?,
        @Parameter(description = "the media string content type of the asset") @Valid @RequestParam(value = "assetMediaStringContentType", required = false) assetMediaStringContentType: kotlin.String?,
        @Parameter(description = "the attached media of the asset") @Valid @RequestParam(value = "assetAttachedMedia", required = false) assetAttachedMedia: org.springframework.web.multipart.MultipartFile,
        @Parameter(description = "the attached media URL of the asset") @Valid @RequestParam(value = "assetAttachedMediaUrl", required = false) assetAttachedMediaUrl: kotlin.String?,
        @Parameter(description = "the attached media string of the asset") @Valid @RequestParam(value = "assetAttachedMediaString", required = false) assetAttachedMediaString: kotlin.String?,
        @Parameter(description = "the attached media string file name of the asset") @Valid @RequestParam(value = "assetAttachedMediaStringFileName", required = false) assetAttachedMediaStringFileName: kotlin.String?,
        @Parameter(description = "the attached media string content type of the asset") @Valid @RequestParam(value = "assetAttachedMediaStringContentType", required = false) assetAttachedMediaStringContentType: kotlin.String?,
        @Parameter(description = "the location description for the asset") @Valid @RequestParam(value = "assetLocationDescription", required = false) assetLocationDescription: kotlin.String?,
        @Parameter(description = "the application for the asset") @Valid @RequestParam(value = "assetApp", required = false) assetApp: kotlin.String?,
        @Parameter(description = "the search tags used for the asset") @Valid @RequestParam(value = "assetSearchTags", required = false) assetSearchTags: kotlin.String?,
        @Parameter(description = "the latitude of the asset") @Valid @RequestParam(value = "assetLatitude", required = false) assetLatitude: kotlin.Double?,
        @Parameter(description = "the longitude of the asset") @Valid @RequestParam(value = "assetLongitude", required = false) assetLongitude: java.math.BigDecimal?
    ): ResponseEntity<NoteResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Create Notification Template",
        operationId = "createNotificationTemplate",
        description = """Create a notification template. Developers will only be able to create notification templates for their own applications.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = NotificationTemplateResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/notification/template/create"
        value = [PATH_CREATE_NOTIFICATION_TEMPLATE],
        produces = ["*/*"]
    )
    fun createNotificationTemplate(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The account ID of the user.", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "Filter results by notification type: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION.", required = true) @Valid @RequestParam(value = "conduit", required = true) conduit: kotlin.String,
        @NotNull @Parameter(description = "title of the notification template", required = true) @Valid @RequestParam(value = "title", required = true) title: kotlin.String,
        @NotNull @Parameter(description = "body of the notification template", required = true) @Valid @RequestParam(value = "body", required = true) body: kotlin.String,
        @Parameter(description = "Filter results by application.") @Valid @RequestParam(value = "appKey", required = false) appKey: kotlin.String?,
        @Parameter(description = "Filter results by event.") @Valid @RequestParam(value = "event", required = false) event: kotlin.String?,
        @Parameter(description = "tags associated with the note template") @Valid @RequestParam(value = "tags", required = false) tags: kotlin.String?
    ): ResponseEntity<NotificationTemplateResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Create Object",
        operationId = "createObject",
        description = """Create an Object Store table.  By default tables will have the columns: id, created, updated, deleted.  Names og objects should be camel case with the first letter capitalized, for example: MyTableName. 

Duplicate object names are not allowed. 

The object name cannot be any of the following reserved words: ACCESSIBLE, ADD, ALL, ALTER, ANALYZE, AND, AS, ASC, ASENSITIVE, BEFORE, BETWEEN, BIGINT, BINARY, BLOB, BOTH, BY, CALL, CASCADE, CASE, CHANGE, CHAR, CHARACTER, CHECK, COLLATE, COLUMN, CONDITION, CONSTRAINT, CONTINUE, CONVERT, CREATE, CROSS, CURRENT_, ATE, CURRENT_TIME, CURRENT_TIMESTAMP, CURRENT_USER, CURSOR, DATABASE, DATABASES, DAY_HOUR, DAY_MICROSECOND, DAY_MINUTE, DAY_SECOND, DEC, DECIMAL, DECLARE, DEFAULT, DELAYED, DELETE, DESC, DESCRIBE, DETERMINISTIC, DISTINCT, DISTINCTROW, DIV, DOUBLE, DROP, DUAL, EACH, ELSE, ELSEIF, ENCLOSED, ESCAPED, EXISTS, EXIT, EXPLAIN, FALSE, FETCH, FLOAT, FLOAT4, FLOAT8, FOR, FORCE, FOREIGN, FROM, FULLTEXT, GRANT, GROUP, HAVING, HIGH_PRIORITY, HOUR_MICROSECOND, HOUR_MINUTE, HOUR_SECOND, IF, IGNORE, IN, INDEX, INFILE, INNER, INOUT, INSENSITIVE, INSERT, INT, INT1, INT2, INT3, INT4, INT8, INTEGER, INTERVAL, INTO, IS, ITERATE, JOIN, KEY, KEYS, KILL, LEADING, LEAVE, LEFT, LIKE, LIMIT, LINEAR, LINES, LOAD, LOCALTIME, LOCALTIMESTAMP, LOCK, LONG, LONGBLOB, LONGT, XT, LOOP, LOW_PRIORITY, MASTER_SSL_VERIFY_SERVER_CERT, MATCH, MAXVALUE, MEDIUMBLOB, MEDIUMINT, MEDIUMTEXT, MIDDLEINT, MINUTE_MICROSECOND, MINUTE_SECOND, MOD, MODIFIES, NATURAL, NOT, NO_WRITE_TO_BINLOG, NULL, NUMERIC, ON, OPTIMIZE, OPTION, OPTIONALLY, OR, ORDER, OUT, OUTER, OUTFILE, PRECISION, PRIMARY, PROCEDURE, PURGE, RANGE, READ, READS, READ_WRITE, REAL, REFERENCES, REGEXP, RELEASE, RENAME, REPEAT, REPLACE, REQUIRE, RESIGNAL, RESTRICT, RETURN, REVOKE, RIGHT, RLIKE, SCHEMA, SCHEMAS, SECOND_MICROSECOND, SELECT, SENSITIVE, SEPARATOR, SET, SHOW, SIGNAL, SMALLINT, SPATIAL, SPECIFIC, SQL, SQLEXCEPTION, SQLSTATE, SQLWARNING, SQL_BIG_RESULT, SQL_CALC_FOUND_ROWS, SQL_SMALL_RESULT, SSL, STARTING, STRAIGHT_JOIN, TABLE, TERMINATED, THEN, TINYBLOB, TINYINT, TINYTEXT, TO, TRAILING, TRIGGER, TRUE, NDO, UNION, UNIQUE, UNLOCK, UNSIGNED, UPDATE, USAGE, USE, USING, UTC_DATE, UTC_TIME, UTC_TIMESTAMP, VALUES, VARBINARY, VARCHAR, VARCHARACTER, VARYING, WHEN, WHERE, WHILE, WITH, WRITE, XOR, YEAR_MONTH, ZEROFILL, GENERAL, IGNORE_SERVER_IDS, MASTER_HEARTBEAT_PERIOD, SLOW. """,
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = ObjectStoreResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/object/create"
        value = [PATH_CREATE_OBJECT],
        produces = ["*/*"]
    )
    fun createObject(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The account id of the logged in user", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "The application key for updating an existing application", required = true) @Valid @RequestParam(value = "appKey", required = true) appKey: kotlin.String,
        @NotNull @Parameter(description = "The name of the object to create", required = true) @Valid @RequestParam(value = "objectName", required = true) objectName: kotlin.String
    ): ResponseEntity<ObjectStoreResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Create Offer",
        operationId = "createOffer",
        description = """Create an offer and assign it to the provided retailer locations.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = RetailerOfferResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/retailer/offer/create"
        value = [PATH_CREATE_OFFER],
        produces = ["*/*"]
    )
    fun createOffer(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "If true return all the offer locations associated with the offer", required = true) @Valid @RequestParam(value = "includeOfferLocations", required = true) includeOfferLocations: kotlin.Boolean,
        @NotNull @Parameter(description = "The title (255 char limit)", required = true) @Valid @RequestParam(value = "title", required = true) title: kotlin.String,
        @NotNull @Parameter(description = "The bar code type {NONE, UPC, CODE_128, QR, CUSTOM_MEDIA}", required = true, schema = Schema(allowableValues = ["NONE", "UPC", "CODE_128", "QR", "CUSTOM_MEDIA"])) @Valid @RequestParam(value = "barcodeType", required = true) barcodeType: kotlin.String,
        @NotNull @Parameter(description = "Overrides the expiration date so that the offer does not expire", required = true) @Valid @RequestParam(value = "noExpiration", required = true) noExpiration: kotlin.Boolean,
        @NotNull @Parameter(description = "The limit of how many times the offer can be used by consumers", required = true) @Valid @RequestParam(value = "availableLimit", required = true) availableLimit: kotlin.Int,
        @NotNull @Parameter(description = "The limit of how many times a user can used the same offer", required = true) @Valid @RequestParam(value = "availableLimitPerUser", required = true) availableLimitPerUser: kotlin.Int,
        @NotNull @Parameter(description = "The limit of how many times the offer can be added to consumer wallets", required = true) @Valid @RequestParam(value = "addedLimit", required = true) addedLimit: kotlin.Int,
        @NotNull @Parameter(description = "The limit of how many times the offer can be viewed", required = true) @Valid @RequestParam(value = "viewLimit", required = true) viewLimit: kotlin.Int,
        @NotNull @Parameter(description = "The maximum number of times the offer can be printed", required = true) @Valid @RequestParam(value = "maxPrints", required = true) maxPrints: kotlin.Int,
        @NotNull @Parameter(description = "The cost of the offer in tickets", required = true) @Valid @RequestParam(value = "ticketPrice", required = true) ticketPrice: kotlin.Long,
        @NotNull @Parameter(description = "The retail/full price cost of the offer in real currency", required = true) @Valid @RequestParam(value = "fullPrice", required = true) fullPrice: kotlin.Double,
        @NotNull @Parameter(description = "The cost of the offer at a discounted price (what the consumer pays)", required = true) @Valid @RequestParam(value = "discountPrice", required = true) discountPrice: kotlin.Double,
        @NotNull @Parameter(description = "The offer type {VOUCHER, COUPON, PRODUCT, EVENT, MEDIA, DEVICE}", required = true, schema = Schema(allowableValues = ["VOUCHER", "COUPON", "PRODUCT", "MEDIA", "EVENT", "DEVICE"])) @Valid @RequestParam(value = "offerType", required = true) offerType: kotlin.String,
        @NotNull @Parameter(description = "The special offer type {ALL, REGULAR_OFFER, ACT_NOW, GET_THERE_NOW}", required = true, schema = Schema(allowableValues = ["ALL", "RESERVABLE", "REGULAR_OFFER", "ACT_NOW", "GET_THERE_NOW", "SQOOT", "TICKETS", "YIPIT"])) @Valid @RequestParam(value = "specialOfferType", required = true) specialOfferType: kotlin.String,
        @NotNull @Parameter(description = "The offer visibility {PUBLIC, REWARDABLE, TRIGGERABLE}", required = true, schema = Schema(allowableValues = ["PUBLIC", "LISTABLE", "REWARDABLE", "TRIGGERABLE", "PRIVATE"])) @Valid @RequestParam(value = "offerVisibility", required = true) offerVisibility: kotlin.String,
        @NotNull @Parameter(description = "Sets the active flag", required = true) @Valid @RequestParam(value = "active", required = true) active: kotlin.Boolean,
        @Parameter(description = "The device id (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "The account id (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "Custom string field for doing full-text searches") @Valid @RequestParam(value = "tags", required = false) tags: kotlin.String?,
        @Parameter(description = "the parent offer id") @Valid @RequestParam(value = "parentOfferId", required = false) parentOfferId: kotlin.Long?,
        @Parameter(description = "Comma separated list of retailer location ids. This will assign the offer to these retailer locations.") @Valid @RequestParam(value = "retailerLocationIds", required = false) retailerLocationIds: kotlin.String?,
        @Parameter(description = "A list of json data that has offer location specific values.") @Valid @RequestParam(value = "offerLocations", required = false) offerLocations: kotlin.String?,
        @Parameter(description = "The sub title (255 char limit)") @Valid @RequestParam(value = "subTitle", required = false) subTitle: kotlin.String?,
        @Parameter(description = "The details") @Valid @RequestParam(value = "details", required = false) details: kotlin.String?,
        @Parameter(description = "A string for custom details (255 char limit)") @Valid @RequestParam(value = "subDetails", required = false) subDetails: kotlin.String?,
        @Parameter(description = "The fine print") @Valid @RequestParam(value = "finePrint", required = false) finePrint: kotlin.String?,
        @Parameter(description = "The bar code entry string") @Valid @RequestParam(value = "barcodeEntry", required = false) barcodeEntry: kotlin.String?,
        @Parameter(description = "An external identifier. What the identifier will be used for and how it is formatted is up to the frontend developer") @Valid @RequestParam(value = "externalRedeemOptions", required = false) externalRedeemOptions: kotlin.String?,
        @Parameter(description = "The clickUrl of the offer") @Valid @RequestParam(value = "externalUrl", required = false) externalUrl: kotlin.String?,
        @Parameter(description = "an external identifier. What the identifier will be used for and how it is formatted is up to the frontend developer") @Valid @RequestParam(value = "externalId", required = false) externalId: kotlin.String?,
        @Parameter(description = "The type of ticket to reward, null means default type") @Valid @RequestParam(value = "ticketsRewardType", required = false) ticketsRewardType: kotlin.String?,
        @Parameter(description = "Determines how many tickets are awarded") @Valid @RequestParam(value = "ticketsReward", required = false) ticketsReward: kotlin.Long?,
        @Parameter(description = "The date of when the offer will be visible to consumers") @Valid @RequestParam(value = "activated", required = false) activated: kotlin.Long?,
        @Parameter(description = "The date of when the offer expires") @Valid @RequestParam(value = "expires", required = false) expires: kotlin.Long?,
        @Parameter(description = "the type of ticket needed to buy offer") @Valid @RequestParam(value = "ticketPriceType", required = false) ticketPriceType: kotlin.String?,
        @Parameter(description = "show remaining offers available") @Valid @RequestParam(value = "showRemaining", required = false) showRemaining: kotlin.Boolean?,
        @Parameter(description = "show how many offers have been redeemed") @Valid @RequestParam(value = "showRedeemed", required = false) showRedeemed: kotlin.Boolean?,
        @Parameter(description = "") @Valid @RequestParam(value = "replaced", required = false) replaced: kotlin.Boolean?,
        @Parameter(description = "flag if offer is featured or not") @Valid @RequestParam(value = "featured", required = false) featured: kotlin.Boolean?,
        @Parameter(description = "Comma separated list of category ids") @Valid @RequestParam(value = "categoryIds", required = false) categoryIds: kotlin.String?,
        @Parameter(description = "Comma separated list of filter ids") @Valid @RequestParam(value = "filterIds", required = false) filterIds: kotlin.String?,
        @Parameter(description = "The id of the barcode asset") @Valid @RequestParam(value = "barcodeAssetId", required = false) barcodeAssetId: kotlin.Long?,
        @Parameter(description = "The id of the an offer asset") @Valid @RequestParam(value = "imageAssetId", required = false) imageAssetId: kotlin.Long?,
        @Parameter(description = "The id of the an offer asset") @Valid @RequestParam(value = "imageAssetId1", required = false) imageAssetId1: kotlin.Long?,
        @Parameter(description = "The id of the an offer asset") @Valid @RequestParam(value = "imageAssetId2", required = false) imageAssetId2: kotlin.Long?,
        @Parameter(description = "The id of the an offer asset") @Valid @RequestParam(value = "imageAssetId3", required = false) imageAssetId3: kotlin.Long?,
        @Parameter(description = "The id of the an offer asset") @Valid @RequestParam(value = "imageAssetId4", required = false) imageAssetId4: kotlin.Long?,
        @Parameter(description = "The id of the an offer asset") @Valid @RequestParam(value = "imageAssetId5", required = false) imageAssetId5: kotlin.Long?,
        @Parameter(description = "The maker of the item.") @Valid @RequestParam(value = "publisher", required = false) publisher: kotlin.String?,
        @Parameter(description = "The redeemable start date/time of the offer.") @Valid @RequestParam(value = "redeemableStart", required = false) redeemableStart: kotlin.Long?,
        @Parameter(description = "The redeemable start date/time of the offer.") @Valid @RequestParam(value = "redeemableEnd", required = false) redeemableEnd: kotlin.Long?,
        @Parameter(description = "The brand. OfferType PRODUCT only.") @Valid @RequestParam(value = "brand", required = false) brand: kotlin.String?,
        @Parameter(description = "The product type. OfferType PRODUCT only.", schema = Schema(allowableValues = ["APPAREL", "APPLIANCES", "APPS", "ARTS_CRAFTS", "AUTOMOTIVE", "BABY", "BEAUTY", "BOOKS", "CLASSICAL", "COLLECTIBLES", "DVD", "ELECTRONICS", "GIFT_CARDS", "GOURMET_FOOD", "GROCERY", "HEALTH_PERSONAL_CARE", "HOME_GARDEN", "INDUSTRIAL", "JEWELRY", "KITCHEN", "LAWN_GARDEN", "MAGAZINES", "MISCELLANEOUS", "MUSICAL_INSTRUMENTS", "OFFICE_PRODUCTS", "OTHER", "OUTDOOR_LIVING", "PC_HARDWARE", "PET_SUPPLIES", "SHOES", "SOFTWARE", "SPORTING_GOODS", "TOOLS", "TOYS", "VIDEO_GAMES", "WATCHES", "WIRELESS", "WIRELESS_ACCESSORIES"])) @Valid @RequestParam(value = "productType", required = false) productType: kotlin.String?,
        @Parameter(description = "The condition. OfferType PRODUCT only.", schema = Schema(allowableValues = ["NEW", "USED", "REFURBISHED", "OTHER"])) @Valid @RequestParam(value = "conditionType", required = false) conditionType: kotlin.String?,
        @Parameter(description = "The ISBN id. OfferType PRODUCT only.") @Valid @RequestParam(value = "isbn", required = false) isbn: kotlin.String?,
        @Parameter(description = "The ASIN id. OfferType PRODUCT only.") @Valid @RequestParam(value = "asin", required = false) asin: kotlin.String?,
        @Parameter(description = "The list of catelog numbers, comma seperated. OfferType PRODUCT only.") @Valid @RequestParam(value = "catalogNumbers", required = false) catalogNumbers: kotlin.String?,
        @Parameter(description = "The department name. The OfferType PRODUCT only.") @Valid @RequestParam(value = "department", required = false) department: kotlin.String?,
        @Parameter(description = "The list of features, comma seperated. OfferType PRODUCT only.") @Valid @RequestParam(value = "features", required = false) features: kotlin.String?,
        @Parameter(description = "The MAP price. OfferType PRODUCT only.") @Valid @RequestParam(value = "minimumPrice", required = false) minimumPrice: kotlin.Double?,
        @Parameter(description = "The width of the item. OfferType PRODUCT only.") @Valid @RequestParam(value = "width", required = false) width: kotlin.Double?,
        @Parameter(description = "The height of the item. OfferType PRODUCT only.") @Valid @RequestParam(value = "height", required = false) height: kotlin.Double?,
        @Parameter(description = "The depth of the item. OfferType PRODUCT only.") @Valid @RequestParam(value = "depth", required = false) depth: kotlin.Double?,
        @Parameter(description = "The weight of the item. OfferType PRODUCT only.") @Valid @RequestParam(value = "weight", required = false) weight: kotlin.Double?,
        @Parameter(description = "The unit of measurement. OfferType PRODUCT only.", schema = Schema(allowableValues = ["MILIMETER", "CENTIMETER", "METER", "INCH", "FOOT", "YARD"])) @Valid @RequestParam(value = "unit", required = false) unit: kotlin.String?,
        @Parameter(description = "The studio name. OfferType PRODUCT only.") @Valid @RequestParam(value = "studio", required = false) studio: kotlin.String?,
        @Parameter(description = "The parental control rating. OfferType PRODUCT only.") @Valid @RequestParam(value = "parentalRating", required = false) parentalRating: kotlin.String?,
        @Parameter(description = "The date published. OfferType PRODUCT only.") @Valid @RequestParam(value = "publishDate", required = false) publishDate: kotlin.Long?,
        @Parameter(description = "The date available. OfferType PRODUCT only.") @Valid @RequestParam(value = "availabilityDate", required = false) availabilityDate: kotlin.Long?,
        @Parameter(description = "") @Valid @RequestParam(value = "sizeId", required = false) sizeId: kotlin.Long?,
        @Parameter(description = "The ID of the event listing") @Valid @RequestParam(value = "listingId", required = false) listingId: kotlin.Long?,
        @Parameter(description = "the media type of the offer", schema = Schema(allowableValues = ["APK", "APPLICATION", "IMAGE", "AUDIO", "VIDEO", "MULTIPART", "BAR_CODE", "TEXT", "OTHER"])) @Valid @RequestParam(value = "mediaType", required = false) mediaType: kotlin.String?,
        @Parameter(description = "The total playing time of the media item. OfferType MEDIA only.") @Valid @RequestParam(value = "duration", required = false) duration: kotlin.Int?,
        @Parameter(description = "The created/author of the media item. OfferType MEDIA only.") @Valid @RequestParam(value = "author", required = false) author: kotlin.String?,
        @Parameter(description = "The date/time of when the media item was originally released. OfferType MEDIA only.") @Valid @RequestParam(value = "releaseDate", required = false) releaseDate: kotlin.Long?,
        @Parameter(description = "") @Valid @RequestParam(value = "collectionIds", required = false) collectionIds: kotlin.String?,
        @Parameter(description = "The reboot hour time ranging from 0 to 23") @Valid @RequestParam(value = "rebootTimeHour", required = false) rebootTimeHour: kotlin.Int?,
        @Parameter(description = "The reboot minute time ranging from 0 to 59") @Valid @RequestParam(value = "rebootTimeMinute", required = false) rebootTimeMinute: kotlin.Int?,
        @Parameter(description = "If the device is idle for idleTimeoutInSecond then the device should timeout") @Valid @RequestParam(value = "idleTimeoutInSecond", required = false) idleTimeoutInSecond: kotlin.Int?,
        @Parameter(description = "The serial number on the device") @Valid @RequestParam(value = "serialNumber", required = false) serialNumber: kotlin.String?,
        @Parameter(description = "The unique device id for the device") @Valid @RequestParam(value = "udid", required = false) udid: kotlin.String?,
        @Parameter(description = "The type of the device, for example: \"Kiosk\", \"Beacon\".") @Valid @RequestParam(value = "deviceType", required = false) deviceType: kotlin.String?,
        @Parameter(description = "Edysen device power level setting") @Valid @RequestParam(value = "devicePower", required = false) devicePower: kotlin.Double?,
        @Parameter(description = "Edysen device inteference setting") @Valid @RequestParam(value = "deviceInterference", required = false) deviceInterference: kotlin.Double?,
        @Parameter(description = "") @Valid @RequestParam(value = "availability", required = false) availability: kotlin.String?,
        @Parameter(description = "") @Valid @RequestParam(value = "availabilitySummary", required = false) availabilitySummary: kotlin.String?
    ): ResponseEntity<RetailerOfferResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Create Wallet Offers",
        operationId = "createOfferTransaction",
        description = """Adds offers to the wallet""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(array = ArraySchema(schema = Schema(implementation = OfferTransactionResponse::class)))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/wallet/create"
        value = [PATH_CREATE_OFFER_TRANSACTION],
        produces = ["*/*"]
    )
    fun createOfferTransaction(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "The device id (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "The account id of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "The id of the offer being added (offerId or offeLocationId required)") @Valid @RequestParam(value = "offerId", required = false) offerId: kotlin.Long?,
        @Parameter(description = "The id of the offer location being added (offerId or offeLocationId required)") @Valid @RequestParam(value = "offerLocationId", required = false) offerLocationId: kotlin.Long?,
        @Parameter(description = "A JSON list of offers to purchase. ```json [   {     \"offerId\": 123,     \"offerLocationId\": 234,     \"quantity\": 2   },   {     \"offerId\": 456,     \"offerLocationId\": 567,     \"quantity\": 1   } ] ``` ") @Valid @RequestParam(value = "offerCart", required = false) offerCart: kotlin.String?,
        @Parameter(description = "The promoCode") @Valid @RequestParam(value = "promoCode", required = false) promoCode: kotlin.String?,
        @Parameter(description = "Determines the method of purchasing offer. CASH = use card on file, POINTS = use points, TICKETS = use tickets", schema = Schema(defaultValue = "CASH")) @Valid @RequestParam(value = "currencyType", required = false, defaultValue = "CASH") currencyType: kotlin.String,
        @Parameter(description = "Sets the currencyType to POINTS") @Valid @RequestParam(value = "usePoints", required = false) usePoints: kotlin.Boolean?,
        @Parameter(description = "External custom client defined data") @Valid @RequestParam(value = "metaData", required = false) metaData: kotlin.String?,
        @Parameter(description = "The application requesting the purchase, required when currencyType is TICKETS") @Valid @RequestParam(value = "appKey", required = false) appKey: kotlin.String?,
        @Parameter(description = "Custom status value to change to (0 or 1 for redeem, 5 or 6 for membership)") @Valid @RequestParam(value = "status", required = false) status: kotlin.Int?
    ): ResponseEntity<List<OfferTransactionResponse>> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Create Offer Status",
        operationId = "createOfferTransactionStatus",
        description = """Create an offer status record""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = OfferTransactionStatusResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/offer/status/create"
        value = [PATH_CREATE_OFFER_TRANSACTION_STATUS],
        produces = ["*/*"]
    )
    fun createOfferTransactionStatus(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The name of the status", required = true) @Valid @RequestParam(value = "name", required = true) name: kotlin.String,
        @NotNull @Parameter(description = "The status code, must be unique ", required = true) @Valid @RequestParam(value = "code", required = true) code: kotlin.Int,
        @Parameter(description = "The device id (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "The account id of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "Used to update the user's current location") @Valid @RequestParam(value = "latitude", required = false) latitude: kotlin.Double?,
        @Parameter(description = "Used to update the user's current location") @Valid @RequestParam(value = "longitude", required = false) longitude: kotlin.Double?,
        @Parameter(description = "The description of the status") @Valid @RequestParam(value = "description", required = false) description: kotlin.String?,
        @Parameter(description = "The actor that uses the status", schema = Schema(defaultValue = "ANY")) @Valid @RequestParam(value = "role", required = false, defaultValue = "ANY") role: kotlin.String,
        @Parameter(description = "The active status", schema = Schema(defaultValue = "true")) @Valid @RequestParam(value = "active", required = false, defaultValue = "true") active: kotlin.Boolean,
        @Parameter(description = "The applications to associate the status with, if null then for all.") @Valid @RequestParam(value = "applicationIds", required = false) applicationIds: kotlin.String?
    ): ResponseEntity<OfferTransactionStatusResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Create or update blocked notification settings",
        operationId = "createOrUpdateBlockedNotifications",
        description = """Create or update blocked notification settings""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = BlockedNotificationResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/notification/blocked/batch"
        value = [PATH_CREATE_OR_UPDATE_BLOCKED_NOTIFICATIONS],
        produces = ["*/*"]
    )
    fun createOrUpdateBlockedNotifications(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The application key", required = true) @Valid @RequestParam(value = "appKey", required = true) appKey: kotlin.String,
        @NotNull @Parameter(description = "batch data payload (application specific)", required = true) @Valid @RequestParam(value = "data", required = true) `data`: kotlin.String,
        @Parameter(description = "the account id of the user") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?
    ): ResponseEntity<BlockedNotificationResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Create or Update Connection",
        operationId = "createOrUpdateConnection",
        description = """Creates or updates the connection of the user and another account. Allows a user to follow, block, mark as trusted, and/or add someone to a group.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = ConnectionResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/consumer/connection/add"
        value = [PATH_CREATE_OR_UPDATE_CONNECTION],
        produces = ["*/*"]
    )
    fun createOrUpdateConnection(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "the device id (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "the account id of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "the connection id for editing") @Valid @RequestParam(value = "connectionId", required = false) connectionId: kotlin.Long?,
        @Parameter(description = "the connection account id (i.e. the account id of another user)") @Valid @RequestParam(value = "connectionAccountId", required = false) connectionAccountId: kotlin.Long?,
        @Parameter(description = "the pending id (usually for people who do not have a Sirqul account but are already friends via other third party apps)") @Valid @RequestParam(value = "pendingId", required = false) pendingId: kotlin.Long?,
        @Parameter(description = "optional group id if the user wants to add this person into a group") @Valid @RequestParam(value = "groupId", required = false) groupId: kotlin.Long?,
        @Parameter(description = "This parameter is deprecated.") @Valid @RequestParam(value = "gameType", required = false) gameType: kotlin.String?,
        @Parameter(description = "the application key") @Valid @RequestParam(value = "appKey", required = false) appKey: kotlin.String?,
        @Parameter(description = "determines whether the user is trusting this account") @Valid @RequestParam(value = "isTrusted", required = false) isTrusted: kotlin.Boolean?,
        @Parameter(description = "determines whether the user has set to ignore the user's friend request") @Valid @RequestParam(value = "ignoreFriendRequest", required = false) ignoreFriendRequest: kotlin.Boolean?,
        @Parameter(description = "determines whether the user is a contact of this account") @Valid @RequestParam(value = "isContact", required = false) isContact: kotlin.Boolean?,
        @Parameter(description = "determines whether the user is blocking this account") @Valid @RequestParam(value = "isBlocked", required = false) isBlocked: kotlin.Boolean?,
        @Parameter(description = "determines whether the user is following this account") @Valid @RequestParam(value = "isFollowing", required = false) isFollowing: kotlin.Boolean?,
        @Parameter(description = "whether to return the connection response or not") @Valid @RequestParam(value = "connectionResponse", required = false) connectionResponse: kotlin.Boolean?
    ): ResponseEntity<ConnectionResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Create or Update Connection Group",
        operationId = "createOrUpdateGroup",
        description = """Creates a new private group.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/consumer/connection/group"
        value = [PATH_CREATE_OR_UPDATE_GROUP],
        produces = ["*/*"]
    )
    fun createOrUpdateGroup(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "whether to return nulls or not", required = true) @Valid @RequestParam(value = "returnNulls", required = true) returnNulls: kotlin.Boolean,
        @Parameter(description = "the device id (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "the account id of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "the name of the group") @Valid @RequestParam(value = "name", required = false) name: kotlin.String?,
        @Parameter(description = "the group id to update a group (don't pass anything in if you want to create a new group)") @Valid @RequestParam(value = "groupId", required = false) groupId: kotlin.Long?,
        @Parameter(description = "the asset to attach to the group") @Valid @RequestParam(value = "assetId", required = false) assetId: kotlin.Long?,
        @Parameter(description = "comma separated list of connection IDs") @Valid @RequestParam(value = "connections", required = false) connections: kotlin.String?,
        @Parameter(description = "the description of the group") @Valid @RequestParam(value = "description", required = false) description: kotlin.String?,
        @Parameter(description = "determines whether the connections in the group can see the user's profile info") @Valid @RequestParam(value = "canViewProfileInfo", required = false) canViewProfileInfo: kotlin.Boolean?,
        @Parameter(description = "determines whether the connections in the group can see the user's game info") @Valid @RequestParam(value = "canViewGameInfo", required = false) canViewGameInfo: kotlin.Boolean?,
        @Parameter(description = "determines whether the connections in the group can see the user's friends/connections") @Valid @RequestParam(value = "canViewFriendInfo", required = false) canViewFriendInfo: kotlin.Boolean?,
        @Parameter(description = "Sets whether the connection group is active or inactive") @Valid @RequestParam(value = "active", required = false) active: kotlin.Boolean?,
        @Parameter(description = "the latitude of the group") @Valid @RequestParam(value = "latitude", required = false) latitude: kotlin.Double?,
        @Parameter(description = "the longitude of the group") @Valid @RequestParam(value = "longitude", required = false) longitude: kotlin.Double?
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Create Order",
        operationId = "createOrder",
        description = """Creates a new purchase with some number of items associated with it. The purchase is added to the order that was created""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = OrderResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/order/create"
        value = [PATH_CREATE_ORDER],
        produces = ["*/*"]
    )
    fun createOrder(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The application requesting the purchase", required = true) @Valid @RequestParam(value = "appKey", required = true) appKey: kotlin.String,
        @NotNull @Parameter(description = "```json [   { \"orderItemType\": \"OFFER\", \"orderItemId\": 234, \"orderCustomType\": \"OfferLocation\", \"orderCustomId\": 123, \"retailerLocationId\": 1234, \"quantity\": 2 },   { \"orderItemType\": \"OFFER\", \"orderItemId\": 235, \"quantity\": 2 },   { \"orderItemType\": \"CUSTOM\", \"amount\": 10.50, \"orderCustomType\": \"ServiceFee\" },   { \"orderItemType\": \"CUSTOM\", \"amount\": 25.10, \"quantity\": 2, \"orderCustomType\": \"Hat\", \"orderCustomId\": 123 } ] ``` ", required = true) @Valid @RequestParam(value = "cart", required = true) cart: kotlin.String,
        @Parameter(description = "The device id (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "The account id of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "A description of the purchase") @Valid @RequestParam(value = "description", required = false) description: kotlin.String?,
        @Parameter(description = "Determines the method of purchasing offer.  * VOID: used for when there is no payment involved (ie. for updating the status of a purchase order)  * CASH: use card on file  * POINTS: use account balance  * TICKETS: use tickets  * REFUND: not allowed for a create, requires a paymentTransactionId.  * CREDIT: add to the account balance  * RELOAD: charge a credit card then add to the account balance  ", schema = Schema(allowableValues = ["VOID", "CASH", "POINTS", "TICKETS", "REFUND", "CREDIT", "RELOAD"], defaultValue = "CASH")) @Valid @RequestParam(value = "currencyType", required = false, defaultValue = "CASH") currencyType: kotlin.String,
        @Parameter(description = "Use a specific payment method (CASH), if not provided use default") @Valid @RequestParam(value = "paymentMethodId", required = false) paymentMethodId: kotlin.Long?,
        @Parameter(description = "Store identifier from external system") @Valid @RequestParam(value = "externalOrderId", required = false) externalOrderId: kotlin.String?,
        @Parameter(description = "Store identifier from external system") @Valid @RequestParam(value = "externalPaymentId", required = false) externalPaymentId: kotlin.String?,
        @Parameter(description = "Remote Reference type") @Valid @RequestParam(value = "remoteRefType", required = false) remoteRefType: kotlin.String?,
        @Parameter(description = "External Date") @Valid @RequestParam(value = "externalDate", required = false) externalDate: kotlin.Long?,
        @Parameter(description = "The Promo Code") @Valid @RequestParam(value = "promoCode", required = false) promoCode: kotlin.String?
    ): ResponseEntity<OrderResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Create Pack",
        operationId = "createPack",
        description = """Create a pack.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = PackResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/pack/create"
        value = [PATH_CREATE_PACK],
        produces = ["*/*"]
    )
    fun createPack(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The logged in user.", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "The title of the pack", required = true) @Valid @RequestParam(value = "title", required = true) title: kotlin.String,
        @NotNull @Parameter(description = "The order of the pack", required = true) @Valid @RequestParam(value = "packOrder", required = true) packOrder: kotlin.Long,
        @NotNull @Parameter(description = "The price in tickets to purchase this pack", required = true) @Valid @RequestParam(value = "price", required = true) price: kotlin.Int,
        @NotNull @Parameter(description = "The scoring is highest is best", required = true) @Valid @RequestParam(value = "highest", required = true) highest: kotlin.Boolean,
        @NotNull @Parameter(description = "Flag to indicate owner should receive tickets for completed packs", required = true) @Valid @RequestParam(value = "allocateTickets", required = true) allocateTickets: kotlin.Boolean,
        @NotNull @Parameter(description = "The number of tickets to reward", required = true) @Valid @RequestParam(value = "ticketCount", required = true) ticketCount: kotlin.Long,
        @Parameter(description = "The description of the pack") @Valid @RequestParam(value = "description", required = false) description: kotlin.String?,
        @Parameter(description = "The tags for searching the pack, comma separated") @Valid @RequestParam(value = "searchTags", required = false) searchTags: kotlin.String?,
        @Parameter(description = "Activate/deactivate the pack") @Valid @RequestParam(value = "active", required = false) active: kotlin.Boolean?,
        @Parameter(description = "This parameter is deprecated.") @Valid @RequestParam(value = "gameType", required = false) gameType: kotlin.String?,
        @Parameter(description = "The application key used to identify the application") @Valid @RequestParam(value = "appKey", required = false) appKey: kotlin.String?,
        @Parameter(description = "The type of the pack", schema = Schema(allowableValues = ["TUTORIAL", "BUILTIN", "DOWNLOAD", "THRESHOLD", "THEME", "TOURNAMENT"])) @Valid @RequestParam(value = "packType", required = false) packType: kotlin.String?,
        @Parameter(description = "The type of game sequence of the pack", schema = Schema(allowableValues = ["FIRST_AVAILABLE", "ALL_AVAILABLE"])) @Valid @RequestParam(value = "sequenceType", required = false) sequenceType: kotlin.String?,
        @Parameter(description = "The background asset id of the pack") @Valid @RequestParam(value = "backgroundId", required = false) backgroundId: kotlin.Long?,
        @Parameter(description = "The image asset id of the pack") @Valid @RequestParam(value = "imageId", required = false) imageId: kotlin.Long?,
        @Parameter(description = "The date/time to start the pack, send 0 to unset") @Valid @RequestParam(value = "startDate", required = false) startDate: kotlin.Long?,
        @Parameter(description = "The date/time to end the pack, send 0 to unset") @Valid @RequestParam(value = "endDate", required = false) endDate: kotlin.Long?,
        @Parameter(description = "") @Valid @RequestParam(value = "authorOverride", required = false) authorOverride: kotlin.String?,
        @Parameter(description = "the type of ticket required to purchase this pack") @Valid @RequestParam(value = "priceType", required = false) priceType: kotlin.String?,
        @Parameter(description = "the game level ids to include in the pack, comma separated") @Valid @RequestParam(value = "gameLevelIds", required = false) gameLevelIds: kotlin.String?,
        @Parameter(description = "") @Valid @RequestParam(value = "inGame", required = false) inGame: kotlin.Boolean?,
        @Parameter(description = "The type of ticket to reward, null means default type") @Valid @RequestParam(value = "ticketType", required = false) ticketType: kotlin.String?,
        @Parameter(description = "The number of points to award for completing a pack") @Valid @RequestParam(value = "points", required = false) points: kotlin.Long?
    ): ResponseEntity<PackResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Create Payment Method",
        operationId = "createPaymentMethod",
        description = """Add a new method of payment.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = PaymentTypesResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/billing/create"
        value = [PATH_CREATE_PAYMENT_METHOD],
        produces = ["*/*"]
    )
    fun createPaymentMethod(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The account used to perform the the request", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @Parameter(description = "Account Name of the credit card user") @Valid @RequestParam(value = "accountName", required = false) accountName: kotlin.String?,
        @Parameter(description = "The first name on the credit card") @Valid @RequestParam(value = "firstName", required = false) firstName: kotlin.String?,
        @Parameter(description = "The last name on the credit card") @Valid @RequestParam(value = "lastName", required = false) lastName: kotlin.String?,
        @Parameter(description = "The billing address of the credit card") @Valid @RequestParam(value = "address", required = false) address: kotlin.String?,
        @Parameter(description = "The billing city of the credit card") @Valid @RequestParam(value = "city", required = false) city: kotlin.String?,
        @Parameter(description = "The billing state of the credit card") @Valid @RequestParam(value = "state", required = false) state: kotlin.String?,
        @Parameter(description = "The billing zip code of the credit card") @Valid @RequestParam(value = "postalCode", required = false) postalCode: kotlin.String?,
        @Parameter(description = "Country of the credit card") @Valid @RequestParam(value = "country", required = false) country: kotlin.String?,
        @Parameter(description = "The billing phone of the credit card") @Valid @RequestParam(value = "phone", required = false) phone: kotlin.String?,
        @Parameter(description = "The full credit card number to store on file") @Valid @RequestParam(value = "creditCardNumber", required = false) creditCardNumber: kotlin.String?,
        @Parameter(description = "The credit card expiration date YYYY-MM") @Valid @RequestParam(value = "expirationDate", required = false) expirationDate: kotlin.String?,
        @Parameter(description = "The 3 digit confirmation code") @Valid @RequestParam(value = "ccv", required = false) ccv: kotlin.String?,
        @Parameter(description = "The bank account number") @Valid @RequestParam(value = "accountNumber", required = false) accountNumber: kotlin.String?,
        @Parameter(description = "The bank name") @Valid @RequestParam(value = "bankName", required = false) bankName: kotlin.String?,
        @Parameter(description = "The bank routing number") @Valid @RequestParam(value = "routingNumber", required = false) routingNumber: kotlin.String?,
        @Parameter(description = "The nickname to give the payment method") @Valid @RequestParam(value = "paymentMethodNickname", required = false) paymentMethodNickname: kotlin.String?,
        @Parameter(description = "Tax Id") @Valid @RequestParam(value = "taxId", required = false) taxId: kotlin.String?,
        @Parameter(description = "Whether this should be the default payment method", schema = Schema(defaultValue = "true")) @Valid @RequestParam(value = "defaultPaymentMethod", required = false, defaultValue = "true") defaultPaymentMethod: kotlin.Boolean,
        @Parameter(description = "An authorization token for providers that provide this (like Amazon Payments)") @Valid @RequestParam(value = "authToken", required = false) authToken: kotlin.String?,
        @Parameter(description = "The payment provider (see PaymentMethodProvider)", schema = Schema(defaultValue = "AUTHORIZE_NET")) @Valid @RequestParam(value = "provider", required = false, defaultValue = "AUTHORIZE_NET") provider: kotlin.String,
        @Parameter(description = "Provider customer profile Id") @Valid @RequestParam(value = "providerCustomerProfileId", required = false) providerCustomerProfileId: kotlin.String?,
        @Parameter(description = "Provider customer payment profile Id") @Valid @RequestParam(value = "providerPaymentProfileId", required = false) providerPaymentProfileId: kotlin.String?,
        @Parameter(description = "Meta Data") @Valid @RequestParam(value = "metaData", required = false) metaData: kotlin.String?,
        @Parameter(description = "Application Key") @Valid @RequestParam(value = "appKey", required = false) appKey: kotlin.String?
    ): ResponseEntity<PaymentTypesResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Create Persona",
        operationId = "createPersona",
        description = """Creates a new persona. If the given params are null those attributes will be override by null.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = PreviewPersonaResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/persona/create"
        value = [PATH_CREATE_PERSONA],
        produces = ["*/*"]
    )
    fun createPersona(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the account ID of the user", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "the title of the persona", required = true) @Valid @RequestParam(value = "title", required = true) title: kotlin.String,
        @Parameter(description = "the accounts that are able to preview from this persona") @Valid @RequestParam(value = "previewAccounts", required = false) previewAccounts: kotlin.String?,
        @Parameter(description = "the sepcified date that this persona is viewing the app") @Valid @RequestParam(value = "date", required = false) date: kotlin.Long?,
        @Parameter(description = "the specified age of this persona") @Valid @RequestParam(value = "age", required = false) age: kotlin.Int?,
        @Parameter(description = "the specified gender of this persona") @Valid @RequestParam(value = "gender", required = false) gender: kotlin.String?,
        @Parameter(description = "the specified experience level of the persona") @Valid @RequestParam(value = "gameExperienceLevel", required = false) gameExperienceLevel: kotlin.String?,
        @Parameter(description = "the specified latitude of the persona") @Valid @RequestParam(value = "latitude", required = false) latitude: kotlin.Double?,
        @Parameter(description = "the specified longitude of the persona") @Valid @RequestParam(value = "longitude", required = false) longitude: kotlin.Double?
    ): ResponseEntity<PreviewPersonaResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Create Postal Code",
        operationId = "createPostalCode",
        description = """Create a Postal Code""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = PostalCodeResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/postalCode/create"
        value = [PATH_CREATE_POSTAL_CODE],
        produces = ["*/*"]
    )
    fun createPostalCode(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the id of the logged in user", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "the postal code", required = true) @Valid @RequestParam(value = "code", required = true) code: kotlin.String,
        @NotNull @Parameter(description = "the latitude of the postal code", required = true) @Valid @RequestParam(value = "latitude", required = true) latitude: kotlin.Double,
        @NotNull @Parameter(description = "the longitude of the postal code", required = true) @Valid @RequestParam(value = "longitude", required = true) longitude: kotlin.Double,
        @Parameter(description = "the state code (e.g WA, WV, WI) that the postal code is located") @Valid @RequestParam(value = "stateCode", required = false) stateCode: kotlin.String?,
        @Parameter(description = "the city that the postal code is located") @Valid @RequestParam(value = "city", required = false) city: kotlin.String?,
        @Parameter(description = "whether the postal code created should be active or inactive") @Valid @RequestParam(value = "active", required = false) active: kotlin.Boolean?
    ): ResponseEntity<PostalCodeResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Create Program",
        operationId = "createProgram",
        description = """Create a new program""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = Program::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/program"
        value = [PATH_CREATE_PROGRAM],
        produces = ["*/*"]
    )
    fun createProgram(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "") @Valid @RequestBody(required = false) body: Program?
    ): ResponseEntity<Program> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Create Purchase",
        operationId = "createPurchaseItem",
        description = """Creates a purchase item for in app purchases""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = PurchaseItemFullResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/purchase/create"
        value = [PATH_CREATE_PURCHASE_ITEM],
        produces = ["*/*"]
    )
    fun createPurchaseItem(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The application key that the purchase can be used in", required = true) @Valid @RequestParam(value = "appKey", required = true) appKey: kotlin.String,
        @NotNull @Parameter(description = "The name of the purchase item", required = true) @Valid @RequestParam(value = "name", required = true) name: kotlin.String,
        @NotNull @Parameter(description = "The purchase provider <ul> <li>SIRQUL - the Sirqul store to make purchases using tickets</li> <li>IOS - the iTunes store for iPhone, iPod, iPod Touch</li> <li>GOOGLE - the Google Play store</li> <li>AMAZON - the Amazon Android store</li> <li>MAC - the iTunes store for OSX</li> <li>WP8 - the Windows Phone 8 store</li> <li>FREE - used for purchase items that are free (can be used for development/testing purposes)</li> </ul>", required = true, schema = Schema(allowableValues = ["SIRQUL", "IOS", "GOOGLE", "AMAZON", "MAC", "WP8", "FREE"])) @Valid @RequestParam(value = "purchaseType", required = true) purchaseType: kotlin.String,
        @Parameter(description = "The device id (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "The account id of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "The description of the purchase item") @Valid @RequestParam(value = "description", required = false) description: kotlin.String?,
        @Parameter(description = "How much the purchase item is worth in tickets") @Valid @RequestParam(value = "tickets", required = false) tickets: kotlin.Int?,
        @Parameter(description = "How much the purchase item will cost in real money") @Valid @RequestParam(value = "price", required = false) price: kotlin.Float?,
        @Parameter(description = "The unique identifier used by purchase providers to identify in-app-purchases") @Valid @RequestParam(value = "purchaseCode", required = false) purchaseCode: kotlin.String?,
        @Parameter(description = "A secret key from purchase providers that would be used for validation") @Valid @RequestParam(value = "secretKey", required = false) secretKey: kotlin.String?,
        @Parameter(description = "How many times a user acquire the same purchase item", schema = Schema(defaultValue = "0")) @Valid @RequestParam(value = "purchaseLimit", required = false, defaultValue = "0") purchaseLimit: kotlin.Int,
        @Parameter(description = "Determines whether the purchase item will enable certain features <ul> <li>DAY_PREMIUM - subscribes a user for a day of membership</li> <li>WEEK_PREMIUM - subscribes a user for a week of membership</li> <li>MONTH_PREMIUM - subscribes a user for a month of membership</li> <li>ADD_TICKET - allows a user to add more tickets to their account</li> <li>ADD_GIFT - allows a user to send/recieve the purchase item as a gift</li> </ul>", schema = Schema(allowableValues = ["DAY_PREMIUM", "WEEK_PREMIUM", "MONTH_PREMIUM", "YEAR_PREMIUM", "LIFETIME_PREMIUM", "ADD_TICKET", "ADD_GIFT", "ADD_POINTS"])) @Valid @RequestParam(value = "serviceAction", required = false) serviceAction: kotlin.String?,
        @Parameter(description = "The cover image of the purchase item") @Valid @RequestParam(value = "coverAssetId", required = false) coverAssetId: kotlin.Long?,
        @Parameter(description = "An application specific asset that can be used to store/provide additional data") @Valid @RequestParam(value = "promoAssetId", required = false) promoAssetId: kotlin.Long?,
        @Parameter(description = "Determines whether the purchase item can be gifted to other users") @Valid @RequestParam(value = "giftable", required = false) giftable: kotlin.Boolean?,
        @Parameter(description = "Determines whether users can attach their own media/asset to the purchase item") @Valid @RequestParam(value = "assetable", required = false) assetable: kotlin.Boolean?,
        @Parameter(description = "Flag to indicate owner should receive tickets for completed missions", schema = Schema(defaultValue = "false")) @Valid @RequestParam(value = "allocateTickets", required = false, defaultValue = "false") allocateTickets: kotlin.Boolean,
        @Parameter(description = "The type of ticket to reward, null means default type") @Valid @RequestParam(value = "ticketType", required = false) ticketType: kotlin.String?,
        @Parameter(description = "The number of points to award for completing a mission") @Valid @RequestParam(value = "points", required = false) points: kotlin.Long?,
        @Parameter(description = "The offer location that will get added to the user's wallet after purchase.") @Valid @RequestParam(value = "offerLocationId", required = false) offerLocationId: kotlin.Long?
    ): ResponseEntity<PurchaseItemFullResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Create Question",
        operationId = "createQuestion",
        description = """Create a question and related answers by the given params.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = QuestionResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/game/question/create"
        value = [PATH_CREATE_QUESTION],
        produces = ["*/*"]
    )
    fun createQuestion(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the id of the logged in user", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "the text of the question", required = true) @Valid @RequestParam(value = "question", required = true) question: kotlin.String,
        @NotNull @Parameter(description = "```json [   {     \"text\": \"1942\",     \"image\": 123,     \"videoURL\": \"http://www.here.com\",     \"correct\": true   },   {     \"text\": \"1943\",     \"image\": 124,     \"videoURL\": \"http://www.there.com\",     \"correct\": false   } ] ``` ", required = true) @Valid @RequestParam(value = "answers", required = true) answers: kotlin.String,
        @NotNull @Parameter(description = "If true set the question to active. Default to false.", required = true) @Valid @RequestParam(value = "active", required = true) active: kotlin.Boolean,
        @NotNull @Parameter(description = "If true then scoring will give tickets. Default to false.", required = true) @Valid @RequestParam(value = "allocateTickets", required = true) allocateTickets: kotlin.Boolean,
        @NotNull @Parameter(description = "The number of tickets to reward", required = true) @Valid @RequestParam(value = "ticketCount", required = true) ticketCount: kotlin.Long,
        @Parameter(description = "The tags of the question for search.") @Valid @RequestParam(value = "tags", required = false) tags: kotlin.String?,
        @Parameter(description = "The video link for the question.") @Valid @RequestParam(value = "videoURL", required = false) videoURL: kotlin.String?,
        @Parameter(description = "The asset id of the question.") @Valid @RequestParam(value = "assetId", required = false) assetId: kotlin.Long?,
        @Parameter(description = "The type of ticket to reward, null means default type") @Valid @RequestParam(value = "ticketType", required = false) ticketType: kotlin.String?,
        @Parameter(description = "The number of points to award for completing a mission") @Valid @RequestParam(value = "points", required = false) points: kotlin.Long?
    ): ResponseEntity<QuestionResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Create Rating",
        operationId = "createRating",
        description = """This is used to leave rating on a ratable object (i.e. retailer locations). Each user can only rate on a ratable object once per category. If a user rates on the same object and category, the previous rating will be overwritten. Leaving a rating on a ratable object will be visible to everyone who has access to view the object.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = RatingResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/rating/create"
        value = [PATH_CREATE_RATING],
        produces = ["*/*"]
    )
    fun createRating(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The ratable object type {RETAILER_LOCATION}", required = true) @Valid @RequestParam(value = "ratableType", required = true) ratableType: kotlin.String,
        @NotNull @Parameter(description = "The id of the ratable object", required = true) @Valid @RequestParam(value = "ratableId", required = true) ratableId: kotlin.Long,
        @NotNull @Parameter(description = "The integer value of 0-100", required = true) @Valid @RequestParam(value = "ratingValue", required = true) ratingValue: kotlin.Int,
        @Parameter(description = "The unique device identifier that made the request (either deviceId or accountId must be used)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "The unique accountId that made the request (either deviceId or accountId must be used)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "") @Valid @RequestParam(value = "categoryId", required = false) categoryId: kotlin.Long?,
        @Parameter(description = "A subject title for the user rating (limited to 255 characters)") @Valid @RequestParam(value = "display", required = false) display: kotlin.String?,
        @Parameter(description = "The description of the rating") @Valid @RequestParam(value = "description", required = false) description: kotlin.String?,
        @Parameter(description = "The description of the location") @Valid @RequestParam(value = "locationDescription", required = false) locationDescription: kotlin.String?,
        @Parameter(description = "The current location of the user") @Valid @RequestParam(value = "latitude", required = false) latitude: kotlin.Double?,
        @Parameter(description = "The current location of the user") @Valid @RequestParam(value = "longitude", required = false) longitude: kotlin.Double?
    ): ResponseEntity<RatingResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Create Region",
        operationId = "createRegion",
        description = """Create a region.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = RegionResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/region/create"
        value = [PATH_CREATE_REGION],
        produces = ["*/*"]
    )
    fun createRegion(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The id of the account sending the request", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "RegionClass of this region", required = true) @Valid @RequestParam(value = "regionClass", required = true) regionClass: kotlin.String,
        @NotNull @Parameter(description = "Short name of the region. This is optimized for search", required = true) @Valid @RequestParam(value = "shortName", required = true) shortName: kotlin.String,
        @Parameter(description = "Full name of the region") @Valid @RequestParam(value = "fullName", required = false) fullName: kotlin.String?,
        @Parameter(description = "Comma separated region ids that are parents of this region") @Valid @RequestParam(value = "parentIds", required = false) parentIds: kotlin.String?,
        @Parameter(description = "Comma separated region ids that are children of this region") @Valid @RequestParam(value = "childrenIds", required = false) childrenIds: kotlin.String?,
        @Parameter(description = "Comma separated postal code ids the region will include") @Valid @RequestParam(value = "postalCodeIds", required = false) postalCodeIds: kotlin.String?,
        @Parameter(description = "Sets of name,lat,long used to create new postal codes assigned to the region") @Valid @RequestParam(value = "locations", required = false) locations: kotlin.String?,
        @Parameter(description = "the id of the retailer location that the region is being created for") @Valid @RequestParam(value = "retailerLocationId", required = false) retailerLocationId: kotlin.Long?,
        @Parameter(description = "The Visibility of the region", schema = Schema(allowableValues = ["PUBLIC", "PRIVATE", "FRIENDS"])) @Valid @RequestParam(value = "visibility", required = false) visibility: kotlin.String?,
        @Parameter(description = "the categories that the region is assigned to") @Valid @RequestParam(value = "categoryIds", required = false) categoryIds: kotlin.String?,
        @Parameter(description = "the filters that the region is assigned to") @Valid @RequestParam(value = "filterIds", required = false) filterIds: kotlin.String?,
        @Parameter(description = "") @Valid @RequestParam(value = "start", required = false) start: kotlin.Long?,
        @Parameter(description = "") @Valid @RequestParam(value = "end", required = false) end: kotlin.Long?,
        @Parameter(description = "the polygon generated for the region") @Valid @RequestParam(value = "polygon", required = false) polygon: kotlin.String?,
        @Parameter(description = "the meta data associated with the region") @Valid @RequestParam(value = "metaData", required = false) metaData: kotlin.String?,
        @Parameter(description = "the latitude of the region") @Valid @RequestParam(value = "latitude", required = false) latitude: kotlin.Double?,
        @Parameter(description = "the longitude of the region") @Valid @RequestParam(value = "longitude", required = false) longitude: kotlin.Double?,
        @Parameter(description = "the version code") @Valid @RequestParam(value = "versionCode", required = false) versionCode: kotlin.Int?,
        @Parameter(description = "If this is a root region or not. If true means this region has no parent regions") @Valid @RequestParam(value = "root", required = false) root: kotlin.Boolean?,
        @Parameter(description = "Active or inactive status of the region") @Valid @RequestParam(value = "active", required = false) active: kotlin.Boolean?
    ): ResponseEntity<RegionResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Create Offline Report",
        operationId = "createRegionLegSummaryBatch",
        description = """Create an entry for the batch for offline report""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = ReportRegionLegSummaryBatchResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/report/region/summary/batch"
        value = [PATH_CREATE_REGION_LEG_SUMMARY_BATCH],
        produces = ["*/*"]
    )
    fun createRegionLegSummaryBatch(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "") @Valid @RequestBody(required = false) body: kotlin.collections.List<RegionLegSummary>?
    ): ResponseEntity<ReportRegionLegSummaryBatchResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Create Reservation",
        operationId = "createReservation",
        description = """Creates a reservation on an offer object""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation") ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/reservation/create"
        value = [PATH_CREATE_RESERVATION]
    )
    fun createReservation(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "The device id (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "The account id of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "The start date") @Valid @RequestParam(value = "startDate", required = false) startDate: kotlin.Long?,
        @Parameter(description = "The end date") @Valid @RequestParam(value = "endDate", required = false) endDate: kotlin.Long?,
        @Parameter(description = "The id of the offer being added (offerId or offeLocationId required)") @Valid @RequestParam(value = "offerId", required = false) offerId: kotlin.Long?,
        @Parameter(description = "The id of the offer location being added (offerId or offeLocationId required)") @Valid @RequestParam(value = "offerLocationId", required = false) offerLocationId: kotlin.Long?,
        @Parameter(description = "The application requesting the reservation") @Valid @RequestParam(value = "appKey", required = false) appKey: kotlin.String?,
        @Parameter(description = "External custom client defined data") @Valid @RequestParam(value = "metaData", required = false) metaData: kotlin.String?
    ): ResponseEntity<Unit> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Create Retailer",
        operationId = "createRetailer",
        description = """Create a retailer record. A billable entity must be created first before a retailer record can be made.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = RetailerFullResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/retailer/create"
        value = [PATH_CREATE_RETAILER],
        produces = ["*/*"]
    )
    fun createRetailer(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The name of the retailer", required = true) @Valid @RequestParam(value = "name", required = true) name: kotlin.String,
        @Parameter(description = "The device id (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "The account id of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "The street address of the retailer") @Valid @RequestParam(value = "streetAddress", required = false) streetAddress: kotlin.String?,
        @Parameter(description = "Additional address information (such as a suite number, floor number, building name, or PO Box)") @Valid @RequestParam(value = "streetAddress2", required = false) streetAddress2: kotlin.String?,
        @Parameter(description = "The city of the retailer") @Valid @RequestParam(value = "city", required = false) city: kotlin.String?,
        @Parameter(description = "The state of the retailer") @Valid @RequestParam(value = "state", required = false) state: kotlin.String?,
        @Parameter(description = "The postal code of the retailer") @Valid @RequestParam(value = "postalCode", required = false) postalCode: kotlin.String?,
        @Parameter(description = "the country of the retailer") @Valid @RequestParam(value = "country", required = false) country: kotlin.String?,
        @Parameter(description = "The business phone number of the retailer") @Valid @RequestParam(value = "businessPhone", required = false) businessPhone: kotlin.String?,
        @Parameter(description = "The business phone extension of the retailer") @Valid @RequestParam(value = "businessPhoneExt", required = false) businessPhoneExt: kotlin.String?,
        @Parameter(description = "The website of the retailer") @Valid @RequestParam(value = "website", required = false) website: kotlin.String?,
        @Parameter(description = "The email of the retailer") @Valid @RequestParam(value = "email", required = false) email: kotlin.String?,
        @Parameter(description = "The facebook URL of the retailer") @Valid @RequestParam(value = "facebookUrl", required = false) facebookUrl: kotlin.String?,
        @Parameter(description = "The twitter URL of the retailer") @Valid @RequestParam(value = "twitterUrl", required = false) twitterUrl: kotlin.String?,
        @Parameter(description = "The retailer logo sent as a multipart binary file (you can optionally use logoAssetId if the asset has already been uploaded before)") @Valid @RequestParam(value = "logo", required = false) logo: org.springframework.web.multipart.MultipartFile,
        @Parameter(description = "The retailer logo asset id") @Valid @RequestParam(value = "logoAssetId", required = false) logoAssetId: kotlin.Long?,
        @Parameter(description = "Optional store-front pictures or product pictures or etc. A multipart binary file (you can optionally use picture1AssetId if the asset has already been uploaded before)") @Valid @RequestParam(value = "picture1", required = false) picture1: org.springframework.web.multipart.MultipartFile,
        @Parameter(description = "An asset id") @Valid @RequestParam(value = "picture1AssetId", required = false) picture1AssetId: kotlin.Long?,
        @Parameter(description = "Optional store-front pictures or product pictures or etc. A multipart binary file (you can optionally use picture2AssetId if the asset has already been uploaded before)") @Valid @RequestParam(value = "picture2", required = false) picture2: org.springframework.web.multipart.MultipartFile,
        @Parameter(description = "An asset id") @Valid @RequestParam(value = "picture2AssetId", required = false) picture2AssetId: kotlin.Long?,
        @Parameter(description = "Comma separated list of category IDs used to filter retailers by categories") @Valid @RequestParam(value = "categoryIds", required = false) categoryIds: kotlin.String?,
        @Parameter(description = "Comma separated list of category IDs to add to the retailer") @Valid @RequestParam(value = "categoryIdsToAdd", required = false) categoryIdsToAdd: kotlin.String?,
        @Parameter(description = "Comma separated list of category IDs to remove from the retailer") @Valid @RequestParam(value = "categoryIdsToRemove", required = false) categoryIdsToRemove: kotlin.String?,
        @Parameter(description = "Comma separated list of filter IDs used to filter retailers") @Valid @RequestParam(value = "filterIds", required = false) filterIds: kotlin.String?,
        @Parameter(description = "the latitude of the retailer") @Valid @RequestParam(value = "latitude", required = false) latitude: kotlin.Double?,
        @Parameter(description = "the longitude of the retailer") @Valid @RequestParam(value = "longitude", required = false) longitude: kotlin.Double?,
        @Parameter(description = "External custom client defined data") @Valid @RequestParam(value = "metaData", required = false) metaData: kotlin.String?,
        @Parameter(description = "External custom search keywords") @Valid @RequestParam(value = "searchTags", required = false) searchTags: kotlin.String?,
        @Parameter(description = "External custom type identifier") @Valid @RequestParam(value = "retailerType", required = false) retailerType: kotlin.String?,
        @Parameter(description = "", schema = Schema(allowableValues = ["PUBLIC", "PRIVATE", "FRIENDS"])) @Valid @RequestParam(value = "visibility", required = false) visibility: kotlin.String?,
        @Parameter(description = "Determines whether to create a default location using the retailer information") @Valid @RequestParam(value = "createDefaultLocation", required = false) createDefaultLocation: kotlin.Boolean?,
        @Parameter(description = "The format of the returned response {JSON // default , HTML // for Dojo support when uploading assets}", schema = Schema(allowableValues = ["HTML", "XML", "JSON", "CSV"])) @Valid @RequestParam(value = "responseFormat", required = false) responseFormat: kotlin.String?
    ): ResponseEntity<RetailerFullResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Create Retailer Location (Consumer)",
        operationId = "createRetailerLocationConsumer",
        description = """Creates a location record for an application that can support crowd sourced locations.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = RetailerLocationResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/location/create"
        value = [PATH_CREATE_RETAILER_LOCATION_CONSUMER],
        produces = ["*/*"]
    )
    fun createRetailerLocationConsumer(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the application key", required = true) @Valid @RequestParam(value = "appKey", required = true) appKey: kotlin.String,
        @NotNull @Parameter(description = "The name of the retailer location", required = true) @Valid @RequestParam(value = "name", required = true) name: kotlin.String,
        @Parameter(description = "The device id (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "The account id of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "The street address of the retailer location") @Valid @RequestParam(value = "streetAddress", required = false) streetAddress: kotlin.String?,
        @Parameter(description = "Additional address information (such as a suite number, floor number, building name, or PO Box)") @Valid @RequestParam(value = "streetAddress2", required = false) streetAddress2: kotlin.String?,
        @Parameter(description = "The city of the retailer location") @Valid @RequestParam(value = "city", required = false) city: kotlin.String?,
        @Parameter(description = "The state of the retailer location") @Valid @RequestParam(value = "state", required = false) state: kotlin.String?,
        @Parameter(description = "The postal code of the retailer location") @Valid @RequestParam(value = "postalCode", required = false) postalCode: kotlin.String?,
        @Parameter(description = "the country of the retailer location") @Valid @RequestParam(value = "country", required = false) country: kotlin.String?,
        @Parameter(description = "The business phone") @Valid @RequestParam(value = "businessPhone", required = false) businessPhone: kotlin.String?,
        @Parameter(description = "The business phone extension") @Valid @RequestParam(value = "businessPhoneExt", required = false) businessPhoneExt: kotlin.String?,
        @Parameter(description = "The website of the retailer location") @Valid @RequestParam(value = "website", required = false) website: kotlin.String?,
        @Parameter(description = "The email of the retailer location") @Valid @RequestParam(value = "email", required = false) email: kotlin.String?,
        @Parameter(description = "A brief description about the retailer location (255 character limit)") @Valid @RequestParam(value = "detailsHeader", required = false) detailsHeader: kotlin.String?,
        @Parameter(description = "A detailed description about the retailer location") @Valid @RequestParam(value = "detailsBody", required = false) detailsBody: kotlin.String?,
        @Parameter(description = "The hours of operation") @Valid @RequestParam(value = "hours", required = false) hours: kotlin.String?,
        @Parameter(description = "Custom string field for doing full-text searches") @Valid @RequestParam(value = "tags", required = false) tags: kotlin.String?,
        @Parameter(description = "The retailer location logo asset id") @Valid @RequestParam(value = "logoAssetId", required = false) logoAssetId: kotlin.Long?,
        @Parameter(description = "An asset id") @Valid @RequestParam(value = "picture1AssetId", required = false) picture1AssetId: kotlin.Long?,
        @Parameter(description = "An asset id") @Valid @RequestParam(value = "picture2AssetId", required = false) picture2AssetId: kotlin.Long?,
        @Parameter(description = "Comma separated list of category IDs used to filter retailer locations by categories") @Valid @RequestParam(value = "categoryIds", required = false) categoryIds: kotlin.String?,
        @Parameter(description = "Comma separated list of filter IDs used to filter retailer locations") @Valid @RequestParam(value = "filterIds", required = false) filterIds: kotlin.String?,
        @Parameter(description = "External custom client defined data") @Valid @RequestParam(value = "metaData", required = false) metaData: kotlin.String?,
        @Parameter(description = "Whether the location is public") @Valid @RequestParam(value = "publicLocation", required = false) publicLocation: kotlin.Boolean?,
        @Parameter(description = "whether the retailer location created should be active or not") @Valid @RequestParam(value = "active", required = false) active: kotlin.Boolean?,
        @Parameter(description = "External custom type identifier") @Valid @RequestParam(value = "locationType", required = false) locationType: kotlin.String?,
        @Parameter(description = "The latitude to center the search on") @Valid @RequestParam(value = "latitude", required = false) latitude: kotlin.Double?,
        @Parameter(description = "The longitude to center the search on") @Valid @RequestParam(value = "longitude", required = false) longitude: kotlin.Double?
    ): ResponseEntity<RetailerLocationResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Create Retailer Location",
        operationId = "createRetailerLocations",
        description = """Creates a location record for a retailer. Only the owner and the employees of the retailer have access to do this.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = RetailerLocationResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/retailer/location/create"
        value = [PATH_CREATE_RETAILER_LOCATIONS],
        produces = ["*/*"]
    )
    fun createRetailerLocations(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The ID of the retailer", required = true) @Valid @RequestParam(value = "retailerId", required = true) retailerId: kotlin.Long,
        @NotNull @Parameter(description = "The name of the retailer location", required = true) @Valid @RequestParam(value = "name", required = true) name: kotlin.String,
        @NotNull @Parameter(description = "The street address of the retailer location", required = true) @Valid @RequestParam(value = "streetAddress", required = true) streetAddress: kotlin.String,
        @NotNull @Parameter(description = "The city of the retailer location", required = true) @Valid @RequestParam(value = "city", required = true) city: kotlin.String,
        @NotNull @Parameter(description = "The state of the retailer location", required = true) @Valid @RequestParam(value = "state", required = true) state: kotlin.String,
        @NotNull @Parameter(description = "The postal code of the retailer location", required = true) @Valid @RequestParam(value = "postalCode", required = true) postalCode: kotlin.String,
        @Parameter(description = "The device id (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "The account id of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "Additional address information (such as a suite number, floor number, building name, or PO Box)") @Valid @RequestParam(value = "streetAddress2", required = false) streetAddress2: kotlin.String?,
        @Parameter(description = "the country of the retailer location") @Valid @RequestParam(value = "country", required = false) country: kotlin.String?,
        @Parameter(description = "The business phone number of the retailer location") @Valid @RequestParam(value = "businessPhone", required = false) businessPhone: kotlin.String?,
        @Parameter(description = "The business phone extension") @Valid @RequestParam(value = "businessPhoneExt", required = false) businessPhoneExt: kotlin.String?,
        @Parameter(description = "The website of the retailer location") @Valid @RequestParam(value = "website", required = false) website: kotlin.String?,
        @Parameter(description = "The email of the retailer location") @Valid @RequestParam(value = "email", required = false) email: kotlin.String?,
        @Parameter(description = "An internal identifier used by the retailer") @Valid @RequestParam(value = "internalId", required = false) internalId: kotlin.String?,
        @Parameter(description = "A brief description about the retailer location (255 character limit)") @Valid @RequestParam(value = "detailsHeader", required = false) detailsHeader: kotlin.String?,
        @Parameter(description = "A detailed description about the retailer location") @Valid @RequestParam(value = "detailsBody", required = false) detailsBody: kotlin.String?,
        @Parameter(description = "The hours of operation") @Valid @RequestParam(value = "hours", required = false) hours: kotlin.String?,
        @Parameter(description = "The retailer location logo sent as a multipart binary file (you can optionally use logoAssetId if the asset has already been uploaded before)") @Valid @RequestParam(value = "logo", required = false) logo: org.springframework.web.multipart.MultipartFile,
        @Parameter(description = "The retailer location logo asset id") @Valid @RequestParam(value = "logoAssetId", required = false) logoAssetId: kotlin.Long?,
        @Parameter(description = "Optional store-front pictures or product pictures or etc. A multipart binary file (you can optionally use picture1AssetId if the asset has already been uploaded before)") @Valid @RequestParam(value = "picture1", required = false) picture1: org.springframework.web.multipart.MultipartFile,
        @Parameter(description = "An asset id") @Valid @RequestParam(value = "picture1AssetId", required = false) picture1AssetId: kotlin.Long?,
        @Parameter(description = "Optional store-front pictures or product pictures or etc. A multipart binary file (you can optionally use picture2AssetId if the asset has already been uploaded before)") @Valid @RequestParam(value = "picture2", required = false) picture2: org.springframework.web.multipart.MultipartFile,
        @Parameter(description = "An asset id") @Valid @RequestParam(value = "picture2AssetId", required = false) picture2AssetId: kotlin.Long?,
        @Parameter(description = "Comma separated list of category IDs used to filter retailer locations by categories") @Valid @RequestParam(value = "categoryIds", required = false) categoryIds: kotlin.String?,
        @Parameter(description = "Comma separated list of filter IDs used to filter retailer locations") @Valid @RequestParam(value = "filterIds", required = false) filterIds: kotlin.String?,
        @Parameter(description = "the latitude of the retailer location") @Valid @RequestParam(value = "latitude", required = false) latitude: kotlin.Double?,
        @Parameter(description = "the longitude of the retailer location") @Valid @RequestParam(value = "longitude", required = false) longitude: kotlin.Double?,
        @Parameter(description = "") @Valid @RequestParam(value = "building", required = false) building: kotlin.String?,
        @Parameter(description = "the ID of the Google Place that this retailer location is assigned to") @Valid @RequestParam(value = "googlePlaceId", required = false) googlePlaceId: kotlin.String?,
        @Parameter(description = "the Yelp ID that this retailer location is assigned to") @Valid @RequestParam(value = "yelpId", required = false) yelpId: kotlin.String?,
        @Parameter(description = "whether the retailer location should be active or inactive") @Valid @RequestParam(value = "active", required = false) active: kotlin.Boolean?,
        @Parameter(description = "Sets whether the location is public or not") @Valid @RequestParam(value = "publicLocation", required = false) publicLocation: kotlin.Boolean?,
        @Parameter(description = "External custom type identifier") @Valid @RequestParam(value = "locationType", required = false) locationType: kotlin.String?,
        @Parameter(description = "Comma separated list of audience IDs used to assign audiences to the retailer location") @Valid @RequestParam(value = "audienceIds", required = false) audienceIds: kotlin.String?,
        @Parameter(description = "Comma separated list of audience IDs to add to the retailer location") @Valid @RequestParam(value = "audienceIdsToAdd", required = false) audienceIdsToAdd: kotlin.String?,
        @Parameter(description = "Comma separated list of audience IDs to remove from the retailer location") @Valid @RequestParam(value = "audienceIdsToRemove", required = false) audienceIdsToRemove: kotlin.String?,
        @Parameter(description = "The format of the returned response {JSON // default , HTML // for Dojo support when uploading assets}", schema = Schema(allowableValues = ["HTML", "XML", "JSON", "CSV"])) @Valid @RequestParam(value = "responseFormat", required = false) responseFormat: kotlin.String?,
        @Parameter(description = "Comma separated list of response includes (e.g. RETAILER,ASSETS,OFFERS,CATEGORIES,FILTERS,AUDIENCES,QRCODE)") @Valid @RequestParam(value = "responseIncludes", required = false) responseIncludes: kotlin.String?
    ): ResponseEntity<RetailerLocationResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Create Route",
        operationId = "createRoute",
        description = """Create new route""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = Route::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/route"
        value = [PATH_CREATE_ROUTE],
        produces = ["*/*"]
    )
    fun createRoute(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "") @Valid @RequestBody(required = false) body: Route?
    ): ResponseEntity<Route> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Update Route Directions",
        operationId = "createRouteDirections",
        description = """Regenerate the directions of a route""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(array = ArraySchema(schema = Schema(implementation = Direction::class)))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.PUT],
        // "/api/{version}/route/{routeId}/directions"
        value = [PATH_CREATE_ROUTE_DIRECTIONS],
        produces = ["*/*"]
    )
    fun createRouteDirections(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "the id of the route to update directions for", required = true) @PathVariable("routeId") routeId: kotlin.Long
    ): ResponseEntity<List<Direction>> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Create Route Polyline",
        operationId = "createRoutePolyline",
        description = """Update the polyline of the requested route""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = Route::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.PUT],
        // "/api/{version}/route/{routeId}/polyline"
        value = [PATH_CREATE_ROUTE_POLYLINE],
        produces = ["*/*"]
    )
    fun createRoutePolyline(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "the id of the route to create a polyline for", required = true) @PathVariable("routeId") routeId: kotlin.Long
    ): ResponseEntity<Route> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Create Route Setting",
        operationId = "createRouteSettings",
        description = """Create a new route setting""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = RouteSettings::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/route/setting"
        value = [PATH_CREATE_ROUTE_SETTINGS],
        produces = ["*/*"]
    )
    fun createRouteSettings(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "") @Valid @RequestBody(required = false) body: RouteSettings?
    ): ResponseEntity<RouteSettings> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Create Scheduled Notification",
        operationId = "createScheduledNotification",
        description = """This endpoint creates a Scheduled Notification message that can be configured to process and send periodically at set time periods""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = ScheduledNotificationFullResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/notification/schedule/create"
        value = [PATH_CREATE_SCHEDULED_NOTIFICATION],
        produces = ["*/*"]
    )
    fun createScheduledNotification(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The logged in user.", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "The name of the scheduled notification", required = true) @Valid @RequestParam(value = "name", required = true) name: kotlin.String,
        @NotNull @Parameter(description = "The type of scheduled notification. Supported values include: MOBILE_NOTIFICATION - sends push notifications via APNS and GCM EMAIL - sends email messages SMS - sends text messages", required = true) @Valid @RequestParam(value = "type", required = true) type: kotlin.String,
        @NotNull @Parameter(description = "The message to send", required = true) @Valid @RequestParam(value = "message", required = true) message: kotlin.String,
        @Parameter(description = "The payload content ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.") @Valid @RequestParam(value = "contentId", required = false) contentId: kotlin.Long?,
        @Parameter(description = "The payload content name that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.") @Valid @RequestParam(value = "contentName", required = false) contentName: kotlin.String?,
        @Parameter(description = "The payload content type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.") @Valid @RequestParam(value = "contentType", required = false) contentType: kotlin.String?,
        @Parameter(description = "The payload parent ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.") @Valid @RequestParam(value = "parentId", required = false) parentId: kotlin.Long?,
        @Parameter(description = "The payload parent type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.") @Valid @RequestParam(value = "parentType", required = false) parentType: kotlin.String?,
        @Parameter(description = "The application that the notifications will send to. If connectionGroupIds, connectionAccountIds, and audienceIds is not set, this will send to all users who have used the application. This parameter is also required when sending push notifications via the MOBILE_NOTIFICATION type.") @Valid @RequestParam(value = "appKey", required = false) appKey: kotlin.String?,
        @Parameter(description = "Client defined identifier for grouping multiple scheduled notifications. This can be used with the search endpoint to return scheduled notifications with the same groupingId for display purposes. Only results that have been created by the user will be returned when using this feature.") @Valid @RequestParam(value = "groupingId", required = false) groupingId: kotlin.String?,
        @Parameter(description = "The connection groups to use to generate the list of recipients (comma separated list of connection group IDs)") @Valid @RequestParam(value = "connectionGroupIds", required = false) connectionGroupIds: kotlin.String?,
        @Parameter(description = "The connection accounts to use to generate the list of recipients (comma separated list of user account ids)") @Valid @RequestParam(value = "connectionAccountIds", required = false) connectionAccountIds: kotlin.String?,
        @Parameter(description = "This parameter is deprecated. The audience used to generate the list of recipients") @Valid @RequestParam(value = "audienceId", required = false) audienceId: kotlin.Long?,
        @Parameter(description = "The audiences used to generate the list of recipients (comma separated list of audience IDs)") @Valid @RequestParam(value = "audienceIds", required = false) audienceIds: kotlin.String?,
        @Parameter(description = "The album ids to associate with the scheduled notification (comma separated list of album IDs)") @Valid @RequestParam(value = "albumIds", required = false) albumIds: kotlin.String?,
        @Parameter(description = "The report used to generate the the list of recipients") @Valid @RequestParam(value = "reportId", required = false) reportId: kotlin.Long?,
        @Parameter(description = "The parameters to supply to the report used to generate the the list of recipients") @Valid @RequestParam(value = "reportParams", required = false) reportParams: kotlin.String?,
        @Parameter(description = "The URL for making an HTTP call") @Valid @RequestParam(value = "endpointURL", required = false) endpointURL: kotlin.String?,
        @Parameter(description = "The parameters for making an HTTP call") @Valid @RequestParam(value = "payload", required = false) payload: kotlin.String?,
        @Parameter(description = "The next time when the scheduled notification should begin processing (time in milliseconds). If this is left empty, then the startDate will be used.") @Valid @RequestParam(value = "scheduledDate", required = false) scheduledDate: kotlin.Long?,
        @Parameter(description = "The start time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to be available now.") @Valid @RequestParam(value = "startDate", required = false) startDate: kotlin.Long?,
        @Parameter(description = "The end time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to not have an expiration date.") @Valid @RequestParam(value = "endDate", required = false) endDate: kotlin.Long?,
        @Parameter(description = "The cron expression that represents the processing schedule. This uses the unix cron expression format. For example: 0 0 * * * will run once a day at midnight UTC.") @Valid @RequestParam(value = "cronExpression", required = false) cronExpression: kotlin.String?,
        @Parameter(description = "The cron expression type: UNIX, CRON4J, QUARTZ") @Valid @RequestParam(value = "cronType", required = false) cronType: kotlin.String?,
        @Parameter(description = "Additional metadata for the scheduled notification") @Valid @RequestParam(value = "metaData", required = false) metaData: kotlin.String?,
        @Parameter(description = "Json input representing conditional logic that has to be met before running the scheduled notification") @Valid @RequestParam(value = "conditionalInput", required = false) conditionalInput: kotlin.String?,
        @Parameter(description = "This determines if the Scheduled Notification is a template which is used as a basis for dynamically generating re-occurring Scheduled Notifications. The available types include: REPORTING - saves an adhoc report to be able to run again at another time GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business owner) GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business employee, retailer location, etc) GEOFENCE_TRIGGER - template for sending notifications to the account that triggered the geofence/audience (i.e. the customer) GEOFENCE_HTTP_CALL - template for making http calls when the geofences are triggered") @Valid @RequestParam(value = "templateType", required = false) templateType: kotlin.String?,
        @Parameter(description = "Determines the scope of who is able to find and view the scheduled notification (PUBLIC - openly available to all Sirqul users, PRIVATE - only available to users that have been invited)", schema = Schema(allowableValues = ["PUBLIC", "PRIVATE", "FRIENDS"])) @Valid @RequestParam(value = "visibility", required = false) visibility: kotlin.String?,
        @Parameter(description = "Sets whether the Scheduled Notification is active or not (inactive Scheduled Notifications are not processed). This is a quick way to toggle on or off without altering its schedule. The default value is 'true'.") @Valid @RequestParam(value = "active", required = false) active: kotlin.Boolean?,
        @Parameter(description = "") @Valid @RequestParam(value = "sendNow", required = false) sendNow: kotlin.Boolean?,
        @Parameter(description = "Sets the event type for the notification", schema = Schema(defaultValue = "CUSTOM")) @Valid @RequestParam(value = "eventType", required = false, defaultValue = "CUSTOM") eventType: kotlin.String,
        @Parameter(description = "The payload deep link URI that can be used by the client app to direct users to a screen in the app") @Valid @RequestParam(value = "deepLinkURI", required = false) deepLinkURI: kotlin.String?,
        @Parameter(description = "Determines whether to send to all users of the app if set to true for push notifications (appKey is required)") @Valid @RequestParam(value = "sendToAll", required = false) sendToAll: kotlin.Boolean?
    ): ResponseEntity<ScheduledNotificationFullResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Create Score",
        operationId = "createScore",
        description = """Create a score.  The response object will contain a series of   coded messages detailing what items were completed, the score registered,   and any tickets allocated.  Scoring a  level could complete the pack it   is in, completing that pack could complete the game, which  in turn could   complete the mission.  This completion chain is indicated to the client   via 
a list of {@link MessageResponse}.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = ScoreResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/score/create"
        value = [PATH_CREATE_SCORE],
        produces = ["*/*"]
    )
    fun createScore(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The logged in user.", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "The game application key to save the score for.", required = true) @Valid @RequestParam(value = "appKey", required = true) appKey: kotlin.String,
        @NotNull @Parameter(description = "The score", required = true) @Valid @RequestParam(value = "points", required = true) points: kotlin.Int,
        @Parameter(description = "The missionId to score for, ignore if not playing mission.") @Valid @RequestParam(value = "missionId", required = false) missionId: kotlin.Long?,
        @Parameter(description = "The gameId to score for, ignore if not playing mission.") @Valid @RequestParam(value = "gameId", required = false) gameId: kotlin.Long?,
        @Parameter(description = "The packId to score for, send -2 if playing community levels.") @Valid @RequestParam(value = "packId", required = false) packId: kotlin.Long?,
        @Parameter(description = "The gameLevelId to score for.") @Valid @RequestParam(value = "gameLevelId", required = false) gameLevelId: kotlin.Long?,
        @Parameter(description = "The gameObjectId to score for, ignore if level based scoring.") @Valid @RequestParam(value = "gameObjectId", required = false) gameObjectId: kotlin.Long?,
        @Parameter(description = "The time taken to complete task") @Valid @RequestParam(value = "timeTaken", required = false) timeTaken: kotlin.Int?,
        @Parameter(description = "") @Valid @RequestParam(value = "highest", required = false) highest: kotlin.Boolean?
    ): ResponseEntity<ScoreResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Create Secure Application",
        operationId = "createSecureApplication",
        description = """Create a secure application record.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/secure/application/create"
        value = [PATH_CREATE_SECURE_APPLICATION],
        produces = ["*/*"]
    )
    fun createSecureApplication(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The unique id of the user making the request", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "The application to secure", required = true) @Valid @RequestParam(value = "appKey", required = true) appKey: kotlin.String,
        @NotNull @Parameter(description = "", required = true) @Valid @RequestParam(value = "keyCert", required = true) keyCert: org.springframework.web.multipart.MultipartFile,
        @NotNull @Parameter(description = "", required = true) @Valid @RequestParam(value = "trustStore", required = true) trustStore: org.springframework.web.multipart.MultipartFile,
        @NotNull @Parameter(description = "", required = true) @Valid @RequestParam(value = "username", required = true) username: kotlin.String,
        @NotNull @Parameter(description = "", required = true) @Valid @RequestParam(value = "password", required = true) password: kotlin.String,
        @Parameter(description = "", schema = Schema(defaultValue = "true")) @Valid @RequestParam(value = "active", required = false, defaultValue = "true") active: kotlin.Boolean,
        @Parameter(description = "The type of biometric, options are: - FINGERPRINT - IRIS - FACIAL", schema = Schema(allowableValues = ["FINGERPRINT", "IRIS", "FACIAL"], defaultValue = "FACIAL")) @Valid @RequestParam(value = "biometricType", required = false, defaultValue = "FACIAL") biometricType: kotlin.String,
        @Parameter(description = "The position for the biometric file uploaded", schema = Schema(allowableValues = ["UNKNOWN", "LEFT_INDEX", "LEFT_MIDDLE", "LEFT_RING", "LEFT_LITTLE", "LEFT_THUMB", "RIGHT_INDEX", "RIGHT_MIDDLE", "RIGHT_RING", "RIGHT_LITTLE", "RIGHT_THUMB", "LEFT", "RIGHT"], defaultValue = "UNKNOWN")) @Valid @RequestParam(value = "biometricPosition", required = false, defaultValue = "UNKNOWN") biometricPosition: kotlin.String,
        @Parameter(description = "The position for each the biometric2 file uploaded", schema = Schema(allowableValues = ["UNKNOWN", "LEFT_INDEX", "LEFT_MIDDLE", "LEFT_RING", "LEFT_LITTLE", "LEFT_THUMB", "RIGHT_INDEX", "RIGHT_MIDDLE", "RIGHT_RING", "RIGHT_LITTLE", "RIGHT_THUMB", "LEFT", "RIGHT"], defaultValue = "UNKNOWN")) @Valid @RequestParam(value = "biometricPosition2", required = false, defaultValue = "UNKNOWN") biometricPosition2: kotlin.String
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Create Service Hub",
        operationId = "createServiceHub",
        description = """Create new service hub""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = ServiceHub::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/hub"
        value = [PATH_CREATE_SERVICE_HUB],
        produces = ["*/*"]
    )
    fun createServiceHub(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "") @Valid @RequestBody(required = false) body: ServiceHub?
    ): ResponseEntity<ServiceHub> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Create Shipment",
        operationId = "createShipment",
        description = """Create new shipment""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = Shipment::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/shipment"
        value = [PATH_CREATE_SHIPMENT],
        produces = ["*/*"]
    )
    fun createShipment(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "") @Valid @RequestBody(required = false) body: Shipment?
    ): ResponseEntity<Shipment> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Create Shipment Batch",
        operationId = "createShipmentBatch",
        description = """Create a new shipment batch""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = ShipmentBatch::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/shipment/batch"
        value = [PATH_CREATE_SHIPMENT_BATCH],
        produces = ["*/*"]
    )
    fun createShipmentBatch(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "") @Valid @RequestBody(required = false) body: ShipmentBatch?
    ): ResponseEntity<ShipmentBatch> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Create Smart Contract",
        operationId = "createSmartContract",
        description = """Adds a smart contract.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = PaymentTypesResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/billing/crypto/transfer"
        value = [PATH_CREATE_SMART_CONTRACT],
        produces = ["*/*"]
    )
    fun createSmartContract(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The account used to perform the the request", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "The token name", required = true) @Valid @RequestParam(value = "tokenName", required = true) tokenName: kotlin.String,
        @NotNull @Parameter(description = "The token symbol", required = true) @Valid @RequestParam(value = "tokenSymbol", required = true) tokenSymbol: kotlin.String,
        @Parameter(description = "The payment method to return details on. If this is not set, then the user's default payment method will be returned.") @Valid @RequestParam(value = "paymentMethodId", required = false) paymentMethodId: kotlin.Long?
    ): ResponseEntity<PaymentTypesResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Create Vatom Space",
        operationId = "createSpace",
        description = """Create a Vatom space.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation") ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/vatom/b/spaces/create"
        value = [PATH_CREATE_SPACE]
    )
    fun createSpace(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "Sirqul Account Id", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "Sirqul Application Key", required = true) @Valid @RequestParam(value = "appKey", required = true) appKey: kotlin.String,
        @NotNull @Parameter(description = "Vatom Parameters", required = true) @Valid @RequestParam(value = "vatomParameters", required = true) vatomParameters: kotlin.String,
        @Parameter(description = "Return raw response") @Valid @RequestParam(value = "returnRawResponse", required = false) returnRawResponse: kotlin.Boolean?
    ): ResponseEntity<Unit> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Create Stripe Checkout Session",
        operationId = "createStripeCheckoutSession",
        description = """Create a Stripe checkout session""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/stripe/checkout/session/create"
        value = [PATH_CREATE_STRIPE_CHECKOUT_SESSION],
        produces = ["*/*"]
    )
    fun createStripeCheckoutSession(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "Sirqul Application Key", required = true) @Valid @RequestParam(value = "appKey", required = true) appKey: kotlin.String,
        @NotNull @Parameter(description = "Stripe Parameters", required = true) @Valid @RequestParam(value = "stripeParameters", required = true) stripeParameters: kotlin.String
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Create Subscription",
        operationId = "createSubscription",
        description = """Create a subscription for a billable entity.  Provide a planId, if not provided then the base plan will be assigned.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SubscriptionResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/subscription/create"
        value = [PATH_CREATE_SUBSCRIPTION],
        produces = ["*/*"]
    )
    fun createSubscription(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The account used to perform the create, must be the responsible manager", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @Parameter(description = "The plan to subscribe to, if null use default plan") @Valid @RequestParam(value = "planId", required = false) planId: kotlin.Long?,
        @Parameter(description = "Set a promo code for a discount.") @Valid @RequestParam(value = "promoCode", required = false) promoCode: kotlin.String?
    ): ResponseEntity<SubscriptionResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Create Task",
        operationId = "createTask",
        description = """Create a Task""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = TaskResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/task/create"
        value = [PATH_CREATE_TASK],
        produces = ["*/*"]
    )
    fun createTask(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The logged in user.", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "The name of the task", required = true) @Valid @RequestParam(value = "name", required = true) name: kotlin.String,
        @Parameter(description = "The application to target") @Valid @RequestParam(value = "appKey", required = false) appKey: kotlin.String?,
        @Parameter(description = "Client defined identifier for grouping tasks") @Valid @RequestParam(value = "groupingId", required = false) groupingId: kotlin.String?,
        @Parameter(description = "The URL for making an HTTP call") @Valid @RequestParam(value = "endpointURL", required = false) endpointURL: kotlin.String?,
        @Parameter(description = "The parameters for making an HTTP call") @Valid @RequestParam(value = "payload", required = false) payload: kotlin.String?,
        @Parameter(description = "The date and time of the task") @Valid @RequestParam(value = "scheduledDate", required = false) scheduledDate: kotlin.Long?,
        @Parameter(description = "The starting date of the task") @Valid @RequestParam(value = "startDate", required = false) startDate: kotlin.Long?,
        @Parameter(description = "The ending date of the task") @Valid @RequestParam(value = "endDate", required = false) endDate: kotlin.Long?,
        @Parameter(description = "The cron expression that represents the task's schedule") @Valid @RequestParam(value = "cronExpression", required = false) cronExpression: kotlin.String?,
        @Parameter(description = "The determines the scope of who is able to find and view the scheduled notification (PUBLIC - openly available to all Sirqul users, PRIVATE - only available to users that have been invited)", schema = Schema(allowableValues = ["PUBLIC", "PRIVATE", "FRIENDS"])) @Valid @RequestParam(value = "visibility", required = false) visibility: kotlin.String?,
        @Parameter(description = "Sets whether the Task is active or not (inactive Tasks are not processed)", schema = Schema(defaultValue = "true")) @Valid @RequestParam(value = "active", required = false, defaultValue = "true") active: kotlin.Boolean
    ): ResponseEntity<TaskResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Create Territory",
        operationId = "createTerritory",
        description = """Creates a territory.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = TerritoryResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/territory/create"
        value = [PATH_CREATE_TERRITORY],
        produces = ["*/*"]
    )
    fun createTerritory(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The logged in user.", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "The name of the territory", required = true) @Valid @RequestParam(value = "name", required = true) name: kotlin.String,
        @Parameter(description = "If true set the game level as active. Default is true.") @Valid @RequestParam(value = "active", required = false) active: kotlin.Boolean?
    ): ResponseEntity<TerritoryResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Create Tournament",
        operationId = "createTournament",
        description = """Create a tournament.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = TournamentResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/tournament/create"
        value = [PATH_CREATE_TOURNAMENT],
        produces = ["*/*"]
    )
    fun createTournament(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The logged in user.", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "The appKey the tournament is created for.", required = true) @Valid @RequestParam(value = "appKey", required = true) appKey: kotlin.String,
        @NotNull @Parameter(description = "The title of the tournament", required = true) @Valid @RequestParam(value = "title", required = true) title: kotlin.String,
        @NotNull @Parameter(description = "The number of tickets required to pay to enter the tournament", required = true) @Valid @RequestParam(value = "costToPlay", required = true) costToPlay: kotlin.Int,
        @NotNull @Parameter(description = "The date/time to start the tournament", required = true) @Valid @RequestParam(value = "startDate", required = true) startDate: kotlin.Long,
        @Parameter(description = "Custom string client apps can use for searching/filtering tournaments") @Valid @RequestParam(value = "subType", required = false) subType: kotlin.String?,
        @Parameter(description = "The asset ID to attach to the tournament") @Valid @RequestParam(value = "imageAssetId", required = false) imageAssetId: kotlin.Long?,
        @Parameter(description = "The number of seconds in between the start of each tournament game/group", schema = Schema(defaultValue = "600")) @Valid @RequestParam(value = "secondsBetweenLevels", required = false, defaultValue = "600") secondsBetweenLevels: kotlin.Int,
        @Parameter(description = "The number of seconds to extend the round end time in the case of a tie breaker", schema = Schema(defaultValue = "600")) @Valid @RequestParam(value = "secondsForTieBreaker", required = false, defaultValue = "600") secondsForTieBreaker: kotlin.Int,
        @Parameter(description = "The number of seconds in between the start of each tournament round", schema = Schema(defaultValue = "86400")) @Valid @RequestParam(value = "secondsBetweenPacks", required = false, defaultValue = "86400") secondsBetweenPacks: kotlin.Int,
        @Parameter(description = "The maximum number of seconds the match is expected to end at, which gets used to determine when a match should end when there is no activity", schema = Schema(defaultValue = "1800")) @Valid @RequestParam(value = "maximumLevelLength", required = false, defaultValue = "1800") maximumLevelLength: kotlin.Int,
        @Parameter(description = "The type of ticket required to pay") @Valid @RequestParam(value = "costToPlayType", required = false) costToPlayType: kotlin.String?,
        @Parameter(description = "The minimum number of players required to sign up for the tournament to be played", schema = Schema(defaultValue = "1")) @Valid @RequestParam(value = "minimumToPlay", required = false, defaultValue = "1") minimumToPlay: kotlin.Int,
        @Parameter(description = "The starting number of players for a tournament (filled with AI's)") @Valid @RequestParam(value = "startingLimit", required = false) startingLimit: kotlin.Int?,
        @Parameter(description = "The maximum number of players for a tournament (currently 128 but not enforced)") @Valid @RequestParam(value = "availableLimit", required = false) availableLimit: kotlin.Int?,
        @Parameter(description = "The description of the tournament") @Valid @RequestParam(value = "description", required = false) description: kotlin.String?,
        @Parameter(description = "External custom client defined data") @Valid @RequestParam(value = "metaData", required = false) metaData: kotlin.String?,
        @Parameter(description = "The audiences associated with the tournament") @Valid @RequestParam(value = "audienceIds", required = false) audienceIds: kotlin.String?,
        @Parameter(description = "Activate/deactivate the tournament") @Valid @RequestParam(value = "active", required = false) active: kotlin.Boolean?,
        @Parameter(description = "Determines whether to allow players to buy back into a tournament", schema = Schema(defaultValue = "false")) @Valid @RequestParam(value = "enableBuyBack", required = false, defaultValue = "false") enableBuyBack: kotlin.Boolean,
        @Parameter(description = "The list of offers to give as a reward beyond the tickets") @Valid @RequestParam(value = "offerIds", required = false) offerIds: kotlin.String?,
        @Parameter(description = "The artwork ID to attach to the reward tickets offers") @Valid @RequestParam(value = "offerAssetId", required = false) offerAssetId: kotlin.Long?,
        @Parameter(description = "If set then do not update the ticket reward, auto set to true if offerIds provided", schema = Schema(defaultValue = "false")) @Valid @RequestParam(value = "fixedReward", required = false, defaultValue = "false") fixedReward: kotlin.Boolean,
        @Parameter(description = "Set the rules for handling the reward in case of a tie, values: EVEN split the reward evenly ALL everyone gets the full reward value FIRST first score submitted RANDOM random player who scored", schema = Schema(allowableValues = ["EVEN", "ALL", "FIRST", "RANDOM"], defaultValue = "ALL")) @Valid @RequestParam(value = "splitReward", required = false, defaultValue = "ALL") splitReward: kotlin.String,
        @Parameter(description = "Flag to indicate owner should receive tickets for completed missions") @Valid @RequestParam(value = "allocateTickets", required = false) allocateTickets: kotlin.Boolean?,
        @Parameter(description = "A text based string that will be passed into each tournament setup to populate the content") @Valid @RequestParam(value = "tournamentData", required = false) tournamentData: kotlin.String?,
        @Parameter(description = "The style of tournament to build, options are: TOURNAMENT, POOLPLAY", schema = Schema(allowableValues = ["TOURNAMENT", "POOLPLAY", "MULTISTAGE"], defaultValue = "MULTISTAGE")) @Valid @RequestParam(value = "missionType", required = false, defaultValue = "MULTISTAGE") missionType: kotlin.String,
        @Parameter(description = "Sets the visibility flag for the tournament", schema = Schema(allowableValues = ["PUBLIC", "LISTABLE", "REWARDABLE", "TRIGGERABLE", "PRIVATE"], defaultValue = "PUBLIC")) @Valid @RequestParam(value = "visibility", required = false, defaultValue = "PUBLIC") visibility: kotlin.String,
        @Parameter(description = "The number of initial preliminary groups in a multi-stage tournament (this is expected to be a power of two number)", schema = Schema(defaultValue = "1")) @Valid @RequestParam(value = "preliminaryGroups", required = false, defaultValue = "1") preliminaryGroups: kotlin.Int,
        @Parameter(description = "This determines how many people can advance per round in a preliminary group (this is a comma separated list of integers)", schema = Schema(defaultValue = "1")) @Valid @RequestParam(value = "preliminaryGroupAdvancements", required = false, defaultValue = "1") preliminaryGroupAdvancements: kotlin.String,
        @Parameter(description = "This determines if multiple submissions/entries are allowed in a multi-stage album tournament", schema = Schema(defaultValue = "false")) @Valid @RequestParam(value = "enableMultipleEntries", required = false, defaultValue = "false") enableMultipleEntries: kotlin.Boolean,
        @Parameter(description = "This determines if users are allowed to vote multiple times per group in a multi-stage album tournament", schema = Schema(defaultValue = "false")) @Valid @RequestParam(value = "enableMultipleVotes", required = false, defaultValue = "false") enableMultipleVotes: kotlin.Boolean,
        @Parameter(description = "This determines whether the tournament is \"featured\" or not", schema = Schema(defaultValue = "false")) @Valid @RequestParam(value = "featured", required = false, defaultValue = "false") featured: kotlin.Boolean,
        @Parameter(description = "This sets what analytic tag is used when a winner is determined") @Valid @RequestParam(value = "winnerTag", required = false) winnerTag: kotlin.String?,
        @Parameter(description = "This sets what analytic tag is used when a tie has occurred") @Valid @RequestParam(value = "tieTag", required = false) tieTag: kotlin.String?
    ): ResponseEntity<TournamentResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Create Trigger",
        operationId = "createTrigger",
        description = """Create a trigger""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = TriggerResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/trigger/create"
        value = [PATH_CREATE_TRIGGER],
        produces = ["*/*"]
    )
    fun createTrigger(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The logged in user", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "The name of the trigger", required = true) @Valid @RequestParam(value = "name", required = true) name: kotlin.String,
        @Parameter(description = "The application to target") @Valid @RequestParam(value = "appKey", required = false) appKey: kotlin.String?,
        @Parameter(description = "Client defined identifier for grouping triggers") @Valid @RequestParam(value = "groupingId", required = false) groupingId: kotlin.String?,
        @Parameter(description = "The URL for making an HTTP call") @Valid @RequestParam(value = "endpointURL", required = false) endpointURL: kotlin.String?,
        @Parameter(description = "The parameters for making an HTTP call") @Valid @RequestParam(value = "payload", required = false) payload: kotlin.String?,
        @Parameter(description = "The date and time of the next trigger") @Valid @RequestParam(value = "scheduledDate", required = false) scheduledDate: kotlin.Long?,
        @Parameter(description = "The starting date of the trigger") @Valid @RequestParam(value = "startDate", required = false) startDate: kotlin.Long?,
        @Parameter(description = "The ending date of the trigger") @Valid @RequestParam(value = "endDate", required = false) endDate: kotlin.Long?,
        @Parameter(description = "The cron expression that represents the trigger's schedule") @Valid @RequestParam(value = "cronExpression", required = false) cronExpression: kotlin.String?,
        @Parameter(description = "Json input representing conditional logic that has to be met before running the trigger") @Valid @RequestParam(value = "conditionalInput", required = false) conditionalInput: kotlin.String?,
        @Parameter(description = "The determines the scope of who is able to find and view the scheduled notification (PUBLIC - openly available to all Sirqul users, PRIVATE - only available to users that have been invited)", schema = Schema(allowableValues = ["PUBLIC", "PRIVATE", "FRIENDS"])) @Valid @RequestParam(value = "visibility", required = false) visibility: kotlin.String?,
        @Parameter(description = "Sets whether the Trigger is active or not (inactive Triggers are not processed)", schema = Schema(defaultValue = "true")) @Valid @RequestParam(value = "active", required = false, defaultValue = "true") active: kotlin.Boolean
    ): ResponseEntity<TriggerResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Create Trip",
        operationId = "createTrip",
        description = """Create a new trip""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = Trip::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/trip"
        value = [PATH_CREATE_TRIP],
        produces = ["*/*"]
    )
    fun createTrip(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "") @Valid @RequestBody(required = false) body: Trip?
    ): ResponseEntity<Trip> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Create Vatom Event",
        operationId = "createVatomEvent",
        description = """Create a Vatom event.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation") ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/vatom/b/events/create"
        value = [PATH_CREATE_VATOM_EVENT]
    )
    fun createVatomEvent(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "Sirqul Account Id", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "Sirqul Application Key", required = true) @Valid @RequestParam(value = "appKey", required = true) appKey: kotlin.String,
        @NotNull @Parameter(description = "Vatom Parameters", required = true) @Valid @RequestParam(value = "vatomParameters", required = true) vatomParameters: kotlin.String,
        @Parameter(description = "Return raw response") @Valid @RequestParam(value = "returnRawResponse", required = false) returnRawResponse: kotlin.Boolean?
    ): ResponseEntity<Unit> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Create Vehicle",
        operationId = "createVehicle",
        description = """Create new vehicle""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = Vehicle::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/vehicle"
        value = [PATH_CREATE_VEHICLE],
        produces = ["*/*"]
    )
    fun createVehicle(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "A JSON representation of cargo type. ```json {   \"name\": \"Truck\",   \"vehicleType\": { \"id\": 1 },   \"hub\": { \"id\": 1 } } ``` ", required = true) @Valid @RequestParam(value = "vehicle", required = true) vehicle: kotlin.String,
        @Parameter(description = "") @Valid @RequestBody(required = false) body: Vehicle?
    ): ResponseEntity<Vehicle> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Create Vehicle Type",
        operationId = "createVehicleType",
        description = """Create a new vehicle type""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = VehicleType::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/vehicle/type"
        value = [PATH_CREATE_VEHICLE_TYPE],
        produces = ["*/*"]
    )
    fun createVehicleType(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "A JSON representation of cargo type. ```json {   \"name\": \"Truck\",   \"width\": 100,   \"height\": 200,   \"depth\": 200,   \"maxWeight\": 5000,   \"hub\": { \"id\": 1 } } ``` ", required = true) @Valid @RequestParam(value = "vehicleType", required = true) vehicleType: kotlin.String,
        @Parameter(description = "") @Valid @RequestBody(required = false) body: VehicleType?
    ): ResponseEntity<VehicleType> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Create VoiceCanvas images",
        operationId = "createVoiceCanvas",
        description = """Create VoiceCanvas images for provided text, file upload, or file URL""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = OrsonAiVoiceCanvasResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/orson/ai/voiceCanvas"
        value = [PATH_CREATE_VOICE_CANVAS],
        produces = ["*/*"]
    )
    fun createVoiceCanvas(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "Sirqul Account Id", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "Enum: \"256x256\" \"512x512\" \"1024x1024\"", required = true) @Valid @RequestParam(value = "dimensions", required = true) dimensions: kotlin.String,
        @Parameter(description = "A third-party account id that is meaningful to your systems") @Valid @RequestParam(value = "thirdPartyAccountId", required = false) thirdPartyAccountId: kotlin.String?,
        @Parameter(description = "Provide a transcript or previously extracted topics for image generation") @Valid @RequestParam(value = "text", required = false) text: kotlin.String?,
        @Parameter(description = "An uploaded recording to analyze (Currently limited to 10MB)") @Valid @RequestParam(value = "file", required = false) file: org.springframework.web.multipart.MultipartFile,
        @Parameter(description = "A recording file to download and analyze (Size limit: 1GB)") @Valid @RequestParam(value = "url", required = false) url: kotlin.String?,
        @Parameter(description = "When false, uses the raw value from text instead of identifying topics to fetch/generate from") @Valid @RequestParam(value = "parseFlag", required = false) parseFlag: kotlin.Boolean?,
        @Parameter(description = "When true, fetches images instead of generating them") @Valid @RequestParam(value = "fetchFlag", required = false) fetchFlag: kotlin.Boolean?,
        @Parameter(description = "When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open") @Valid @RequestParam(value = "callback", required = false) paramCallback: kotlin.String?
    ): ResponseEntity<OrsonAiVoiceCanvasResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Create Word",
        operationId = "createWord",
        description = """Create a word by the given params.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = WordzWordResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/game/word/create"
        value = [PATH_CREATE_WORD],
        produces = ["*/*"]
    )
    fun createWord(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The logged in user.", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "The text of the word.", required = true) @Valid @RequestParam(value = "word", required = true) word: kotlin.String,
        @NotNull @Parameter(description = "The definition of the word.", required = true) @Valid @RequestParam(value = "definition", required = true) definition: kotlin.String,
        @NotNull @Parameter(description = "If true set the word to active. Default to false.", required = true, schema = Schema(defaultValue = "false")) @Valid @RequestParam(value = "active", required = true, defaultValue = "false") active: kotlin.Boolean,
        @NotNull @Parameter(description = "If true then scoring will give tickets. Default to false.", required = true, schema = Schema(defaultValue = "false")) @Valid @RequestParam(value = "allocateTickets", required = true, defaultValue = "false") allocateTickets: kotlin.Boolean,
        @NotNull @Parameter(description = "The number of tickets to reward", required = true, schema = Schema(defaultValue = "0L")) @Valid @RequestParam(value = "ticketCount", required = true, defaultValue = "0L") ticketCount: kotlin.Long,
        @Parameter(description = "The asset id of the word.") @Valid @RequestParam(value = "assetId", required = false) assetId: kotlin.Long?,
        @Parameter(description = "The type of ticket to reward, null means default type") @Valid @RequestParam(value = "ticketType", required = false) ticketType: kotlin.String?,
        @Parameter(description = "The number of points to award for completing a mission") @Valid @RequestParam(value = "points", required = false) points: kotlin.Long?
    ): ResponseEntity<WordzWordResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Delete Trip",
        operationId = "delete",
        description = """Delete an existing trip""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation") ]
    )
    @RequestMapping(
        method = [RequestMethod.DELETE],
        // "/api/{version}/trip/{id}"
        value = [PATH_DELETE]
    )
    fun delete(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "the id of the trip to delete", required = true) @PathVariable("id") id: kotlin.Long
    ): ResponseEntity<Unit> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Delete Achievement",
        operationId = "deleteAchievement",
        description = """Deletes an achievement (for developer/retailer use). User must have permissions to the application the achievement was created for.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/achievement/delete"
        value = [PATH_DELETE_ACHIEVEMENT],
        produces = ["*/*"]
    )
    fun deleteAchievement(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The ID of the achievement", required = true) @Valid @RequestParam(value = "achievementId", required = true) achievementId: kotlin.Long,
        @Parameter(description = "the account id of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Delete Achievement Tier",
        operationId = "deleteAchievementTier",
        description = """Deletes an achievement tier (for developer/retailer use). User must have permissions to the application the achievement was created for.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/achievement/tier/delete"
        value = [PATH_DELETE_ACHIEVEMENT_TIER],
        produces = ["*/*"]
    )
    fun deleteAchievementTier(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the achievement id for deletion", required = true) @Valid @RequestParam(value = "achievementTierId", required = true) achievementTierId: kotlin.Long,
        @Parameter(description = "the account id of the user (deviceId or accountId required).") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Delete Application",
        operationId = "deleteApplication",
        description = """Set the deleted timestamp to current time. This effectively deletes the application since all queries should ignore any records with a deleted timestamp""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/application/delete"
        value = [PATH_DELETE_APPLICATION],
        produces = ["*/*"]
    )
    fun deleteApplication(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "The account used to perform the delete, must have rights to edit the application.") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "The key of the application to be deleted") @Valid @RequestParam(value = "appKey", required = false) appKey: kotlin.String?
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Delete AppConfig",
        operationId = "deleteApplicationConfig",
        description = """Mark the application configuration for deletion.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/appconfig/delete"
        value = [PATH_DELETE_APPLICATION_CONFIG],
        produces = ["*/*"]
    )
    fun deleteApplicationConfig(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The account ID of the user", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "The config ID of the application configuration to delete", required = true) @Valid @RequestParam(value = "configId", required = true) configId: kotlin.Long
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Delete Ad Placement",
        operationId = "deleteApplicationPlacement",
        description = """Deletes an ad placement for an application.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = PlacementResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/application/placement/delete"
        value = [PATH_DELETE_APPLICATION_PLACEMENT],
        produces = ["*/*"]
    )
    fun deleteApplicationPlacement(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The id of the placement to delete, the user must have rights to the application the ad placement is for", required = true) @Valid @RequestParam(value = "placementId", required = true) placementId: kotlin.Long,
        @Parameter(description = "The unique id of the device making the request (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "The account id of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?
    ): ResponseEntity<PlacementResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Delete Asset",
        operationId = "deleteAsset",
        description = """Delete an asset.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/asset/delete"
        value = [PATH_DELETE_ASSET],
        produces = ["*/*"]
    )
    fun deleteAsset(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the id of the asset to delete", required = true) @Valid @RequestParam(value = "assetId", required = true) assetId: kotlin.String,
        @Parameter(description = "the device id (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "the account id of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "latitude used to update the user's current location") @Valid @RequestParam(value = "latitude", required = false) latitude: kotlin.Double?,
        @Parameter(description = "longitude used to update the user's current location") @Valid @RequestParam(value = "longitude", required = false) longitude: kotlin.Double?
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Delete Audience",
        operationId = "deleteAudience",
        description = """Delete an audience. The audience and account must be valid and have the appropirate permissions to view the content.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/audience/delete"
        value = [PATH_DELETE_AUDIENCE],
        produces = ["*/*"]
    )
    fun deleteAudience(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The logged in user.", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "The id of the audience to delete.", required = true) @Valid @RequestParam(value = "audienceId", required = true) audienceId: kotlin.Long
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Delete Offline Report",
        operationId = "deleteBatch",
        description = """Deletes a batch report.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/report/batch/delete"
        value = [PATH_DELETE_BATCH],
        produces = ["*/*"]
    )
    fun deleteBatch(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the id of the account", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "the id of the batch to delete", required = true) @Valid @RequestParam(value = "batchId", required = true) batchId: kotlin.Long
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Delete Bid",
        operationId = "deleteBid",
        description = """Deleted a bid on a biddable object""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/bid/delete"
        value = [PATH_DELETE_BID],
        produces = ["*/*"]
    )
    fun deleteBid(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The bid id", required = true) @Valid @RequestParam(value = "bidId", required = true) bidId: kotlin.Long,
        @Parameter(description = "The device id (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "The account id of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Delete Billable",
        operationId = "deleteBillableEntity",
        description = """Mark the billable as deleted""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/billable/delete"
        value = [PATH_DELETE_BILLABLE_ENTITY],
        produces = ["*/*"]
    )
    fun deleteBillableEntity(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "The device id (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "The account used to perform the delete, must have rights to edit the billable entity.") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Delete Cargo Type",
        operationId = "deleteCargoType",
        description = """Delete a type of cargo""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation") ]
    )
    @RequestMapping(
        method = [RequestMethod.DELETE],
        // "/api/{version}/cargo/type/{cargoTypeId}"
        value = [PATH_DELETE_CARGO_TYPE]
    )
    fun deleteCargoType(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "the ID of the cargo type", required = true) @PathVariable("cargoTypeId") cargoTypeId: kotlin.Long
    ): ResponseEntity<Unit> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Delete Category",
        operationId = "deleteCategory",
        description = """Delete a category.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/category/delete"
        value = [PATH_DELETE_CATEGORY],
        produces = ["*/*"]
    )
    fun deleteCategory(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the ID of the account", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "the ID of the category", required = true) @Valid @RequestParam(value = "categoryId", required = true) categoryId: kotlin.Long
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Delete Contest",
        operationId = "deleteContest",
        description = """Deletes a contest.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/consumer/album/contest/remove"
        value = [PATH_DELETE_CONTEST],
        produces = ["*/*"]
    )
    fun deleteContest(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the album contest ID", required = true) @Valid @RequestParam(value = "albumContestId", required = true) albumContestId: kotlin.Long,
        @Parameter(description = "a unique ID given by the device (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "the account ID of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "latitude used to update the user's current location") @Valid @RequestParam(value = "latitude", required = false) latitude: kotlin.Double?,
        @Parameter(description = "longitude used to update the user's current location") @Valid @RequestParam(value = "longitude", required = false) longitude: kotlin.Double?
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Delete Creative",
        operationId = "deleteCreative",
        description = """Delete a creative""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/creative/delete"
        value = [PATH_DELETE_CREATIVE],
        produces = ["*/*"]
    )
    fun deleteCreative(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the id of the logged in user", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "the id of the creative to delete", required = true) @Valid @RequestParam(value = "creativeId", required = true) creativeId: kotlin.Long
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Delete Credential",
        operationId = "deleteCredential",
        description = """Delete a third party network on a Sirqul account.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/thirdparty/credential/delete"
        value = [PATH_DELETE_CREDENTIAL],
        produces = ["*/*"]
    )
    fun deleteCredential(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The account id of the user", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "The third party network identifier", required = true) @Valid @RequestParam(value = "networkUID", required = true) networkUID: kotlin.String,
        @NotNull @Parameter(description = "The third party user id", required = true) @Valid @RequestParam(value = "thirdPartyId", required = true) thirdPartyId: kotlin.String,
        @NotNull @Parameter(description = "the application key", required = true) @Valid @RequestParam(value = "appKey", required = true) appKey: kotlin.String
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Delete Data",
        operationId = "deleteData",
        description = """Delete a record for the specified object. Cannot be undone so use only when abolutely sure.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = ObjectStoreResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.DELETE],
        // "/api/{version}/object/data/{objectName}/{objectId}"
        value = [PATH_DELETE_DATA],
        produces = ["*/*"]
    )
    fun deleteData(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "The name of the object to search upon", required = true) @PathVariable("objectName") objectName: kotlin.String,
        @Parameter(description = "objectId The id of the record to return", required = true) @PathVariable("objectId") objectId: kotlin.String,
        @Parameter(description = "The account id of the logged in user") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?
    ): ResponseEntity<ObjectStoreResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Delete Employee",
        operationId = "deleteEmployee",
        description = """Set the deleted date field which marks the record as deleted.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/employee/delete"
        value = [PATH_DELETE_EMPLOYEE],
        produces = ["*/*"]
    )
    fun deleteEmployee(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the id of the logged in user", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "the id of the employee to delete", required = true) @Valid @RequestParam(value = "employeeAccountId", required = true) employeeAccountId: kotlin.Long
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Delete Event",
        operationId = "deleteEvent",
        description = """Delete an event that the user has permissions to.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/event/delete"
        value = [PATH_DELETE_EVENT],
        produces = ["*/*"]
    )
    fun deleteEvent(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the id of the logged in user", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "the id of the event to update", required = true) @Valid @RequestParam(value = "eventId", required = true) eventId: kotlin.Long
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Delete Favorite",
        operationId = "deleteFavorite",
        description = """Removes a favorited item from the user's favorites list.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/favorite/delete"
        value = [PATH_DELETE_FAVORITE],
        produces = ["*/*"]
    )
    fun deleteFavorite(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "The unique ID given by the device (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "The account ID of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "The ID of the favorite reference record (only optional if favoritableId & favoritableType is pass in instead)") @Valid @RequestParam(value = "favoriteId", required = false) favoriteId: kotlin.Long?,
        @Parameter(description = "The ID of the object to un-favorite {offerId, offerLocationId, retailerLocationId, categoryId} (this is required if favoriteId is NOT passed in)") @Valid @RequestParam(value = "favoritableId", required = false) favoritableId: kotlin.Long?,
        @Parameter(description = "The type of the object to un-favorite {OFFER, OFFER_LOCATION, RETAILER_LOCATION, CATEGORY} (this is required if favoriteId is NOT passed in)") @Valid @RequestParam(value = "favoritableType", required = false) favoritableType: kotlin.String?
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Delete Field",
        operationId = "deleteField",
        description = """Delete a field from an object.  This will remove the field, indexes,   and foreign keys associated with the field. 

The following field names   are reserved and cannot be removed from the object: ID, OBJECTID, CREATED,   UPDATED, DELETED""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = ObjectStoreResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/object/field/delete"
        value = [PATH_DELETE_FIELD],
        produces = ["*/*"]
    )
    fun deleteField(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The account id of the logged in user", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "The application key for updating an existing application", required = true) @Valid @RequestParam(value = "appKey", required = true) appKey: kotlin.String,
        @NotNull @Parameter(description = "The name of the object to remove the field from", required = true) @Valid @RequestParam(value = "objectName", required = true) objectName: kotlin.String,
        @NotNull @Parameter(description = "field name The name of the field to remove.", required = true) @Valid @RequestParam(value = "fieldName", required = true) fieldName: kotlin.String
    ): ResponseEntity<ObjectStoreResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Delete Filter",
        operationId = "deleteFilter",
        description = """Delete a filter.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/filter/delete"
        value = [PATH_DELETE_FILTER],
        produces = ["*/*"]
    )
    fun deleteFilter(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The account id of the user (must have permissions to the filter's assigned application)", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "The ID of the filter to delete", required = true) @Valid @RequestParam(value = "filterId", required = true) filterId: kotlin.Long
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Delete Flag",
        operationId = "deleteFlag",
        description = """Deletes a flag.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/flag/delete"
        value = [PATH_DELETE_FLAG],
        produces = ["*/*"]
    )
    fun deleteFlag(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "The unique device identifier that made the request (either deviceId or accountId must be used)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "The unique accountId that made the request (either deviceId or accountId must be used)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "This parameter is deprecated.") @Valid @RequestParam(value = "itemBeingFlaggedType", required = false) itemBeingFlaggedType: kotlin.String?,
        @Parameter(description = "This parameter is deprecated.") @Valid @RequestParam(value = "itemBeingFlaggedId", required = false) itemBeingFlaggedId: kotlin.Long?,
        @Parameter(description = "The flagable object type {ACCOUNT, ALBUM, ALBUM_CONTEST, ASSET, GAME_LEVEL, THEME_DESCRIPTOR, OFFER, NOTE}") @Valid @RequestParam(value = "flagableType", required = false) flagableType: kotlin.String?,
        @Parameter(description = "The flagable object id") @Valid @RequestParam(value = "flagableId", required = false) flagableId: kotlin.Long?
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Delete following",
        operationId = "deleteFollowing",
        description = """Delete following.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation") ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/vatom/me/rels/following/delete"
        value = [PATH_DELETE_FOLLOWING]
    )
    fun deleteFollowing(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "Sirqul Account Id", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "Vatom Rels Key", required = true) @Valid @RequestParam(value = "vatomRelsKey", required = true) vatomRelsKey: kotlin.String,
        @Parameter(description = "Return raw response") @Valid @RequestParam(value = "returnRawResponse", required = false) returnRawResponse: kotlin.Boolean?
    ): ResponseEntity<Unit> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Delete a Game",
        operationId = "deleteGame",
        description = """Delete a game.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/game/delete"
        value = [PATH_DELETE_GAME],
        produces = ["*/*"]
    )
    fun deleteGame(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The logged in user.", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "the updating game's id.", required = true) @Valid @RequestParam(value = "gameId", required = true) gameId: kotlin.Long
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Delete Game Level",
        operationId = "deleteGameLevel",
        description = """Delete a game level. The level and account must be valid and have the appropirate permissions to view the content.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/level/delete"
        value = [PATH_DELETE_GAME_LEVEL],
        produces = ["*/*"]
    )
    fun deleteGameLevel(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The logged in user.", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "The id of the level to return.", required = true) @Valid @RequestParam(value = "levelId", required = true) levelId: kotlin.Long
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Delete the Leader Board",
        operationId = "deleteLeaderboard",
        description = """Removes a leader board id.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/leaderboard/delete"
        value = [PATH_DELETE_LEADERBOARD],
        produces = ["*/*"]
    )
    fun deleteLeaderboard(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The leaderboard id to delete.", required = true) @Valid @RequestParam(value = "leaderboardId", required = true) leaderboardId: kotlin.Long,
        @Parameter(description = "The account id of the user making the request.") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Delete Listing",
        operationId = "deleteListing",
        description = """Delete a listing.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/listing/delete"
        value = [PATH_DELETE_LISTING],
        produces = ["*/*"]
    )
    fun deleteListing(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the id of the logged in user", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "the id of the listing to delete", required = true) @Valid @RequestParam(value = "listingId", required = true) listingId: kotlin.Long
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Delete Media",
        operationId = "deleteMedia",
        description = """Delete a media offering that the user has permissions to.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/media/delete"
        value = [PATH_DELETE_MEDIA],
        produces = ["*/*"]
    )
    fun deleteMedia(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the id of the logged in user", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "the ID of the media to delete", required = true) @Valid @RequestParam(value = "mediaId", required = true) mediaId: kotlin.Long
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Delete Mission",
        operationId = "deleteMission",
        description = """Delete a mission.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/mission/delete"
        value = [PATH_DELETE_MISSION],
        produces = ["*/*"]
    )
    fun deleteMission(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the id of the logged in user", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "the id of the mission to delete", required = true) @Valid @RequestParam(value = "missionId", required = true) missionId: kotlin.Long
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Delete Mission Invite",
        operationId = "deleteMissionInvite",
        description = """Update the mission invite status to quit.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/mission/invite/delete"
        value = [PATH_DELETE_MISSION_INVITE],
        produces = ["*/*"]
    )
    fun deleteMissionInvite(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "the device id (deviceId or accountId required).") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "the account id of the user (deviceId or accountId required).") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "The mission to find the invite for (missionId or missionInviteId requried).") @Valid @RequestParam(value = "missionId", required = false) missionId: kotlin.Long?,
        @Parameter(description = "The mission invite id. This checks on the user's billable for permission (missionId or missionInviteId requried).") @Valid @RequestParam(value = "missionInviteId", required = false) missionInviteId: kotlin.Long?,
        @Parameter(description = "Include the game level data with the mission.") @Valid @RequestParam(value = "includeGameData", required = false) includeGameData: kotlin.Boolean?
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Delete Network",
        operationId = "deleteNetwork",
        description = """Marks a custom third party network as deleted. Only the network owners and managers have access to this.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/thirdparty/network/delete"
        value = [PATH_DELETE_NETWORK],
        produces = ["*/*"]
    )
    fun deleteNetwork(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the id of the logged in user", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "The unique identifier for the third party network defined by Sirqul", required = true) @Valid @RequestParam(value = "networkUID", required = true) networkUID: kotlin.String
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Delete Note",
        operationId = "deleteNote",
        description = """Sets a comment (note) as deleted.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/note/delete"
        value = [PATH_DELETE_NOTE],
        produces = ["*/*"]
    )
    fun deleteNote(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The ID of the note to delete", required = true) @Valid @RequestParam(value = "noteId", required = true) noteId: kotlin.Long,
        @Parameter(description = "The unique device identifier that made the request (either deviceId or accountId must be used)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "The unique accountId that made the request (either deviceId or accountId must be used)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "The current location of the user") @Valid @RequestParam(value = "latitude", required = false) latitude: kotlin.Double?,
        @Parameter(description = "The current location of the user") @Valid @RequestParam(value = "longitude", required = false) longitude: kotlin.Double?,
        @Parameter(description = "The application key used to identify the application") @Valid @RequestParam(value = "appKey", required = false) appKey: kotlin.String?
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Delete Notification Template",
        operationId = "deleteNotificationTemplate",
        description = """Deletes a notification template. Developers will only be able to delete notification templates for their own applications.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = NotificationTemplateResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/notification/template/delete"
        value = [PATH_DELETE_NOTIFICATION_TEMPLATE],
        produces = ["*/*"]
    )
    fun deleteNotificationTemplate(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the account id of the user", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "the id of the notification template to delete", required = true) @Valid @RequestParam(value = "notificationTemplateId", required = true) notificationTemplateId: kotlin.Long
    ): ResponseEntity<NotificationTemplateResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Delete Object",
        operationId = "deleteObject",
        description = """Delete and Object in the store.  This will delete the table and clean up and foreign keys referencing it. Cannot be undone so use only when abolutely sure.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = ObjectStoreResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/object/delete"
        value = [PATH_DELETE_OBJECT],
        produces = ["*/*"]
    )
    fun deleteObject(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the id of the logged in user", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "the application key", required = true) @Valid @RequestParam(value = "appKey", required = true) appKey: kotlin.String,
        @NotNull @Parameter(description = "the name of the object to delete", required = true) @Valid @RequestParam(value = "objectName", required = true) objectName: kotlin.String
    ): ResponseEntity<ObjectStoreResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Delete Offer",
        operationId = "deleteOffer",
        description = """Set the deleted timestamp to current time. This effectively deletes the offer since all queries should ignore any records with a deleted time stamp.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/retailer/offer/delete"
        value = [PATH_DELETE_OFFER],
        produces = ["*/*"]
    )
    fun deleteOffer(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The ID of the offer to be deleted", required = true) @Valid @RequestParam(value = "offerId", required = true) offerId: kotlin.Long,
        @Parameter(description = "The device id (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "The account used to perform the delete, must have rights to edit the offer.") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Delete Offer Location",
        operationId = "deleteOfferLocation",
        description = """Set the deleted timestamp to current time. This effectively deletes the offer location since all queries should ignore any records with a deleted time stamp.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/retailer/offer/location/delete"
        value = [PATH_DELETE_OFFER_LOCATION],
        produces = ["*/*"]
    )
    fun deleteOfferLocation(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The ID of the offer location to be deleted", required = true) @Valid @RequestParam(value = "offerLocationId", required = true) offerLocationId: kotlin.Long,
        @Parameter(description = "The device id (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "The account used to perform the delete, must have rights to edit the offer location.") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Delete Wallet Offer",
        operationId = "deleteOfferTransaction",
        description = """Removes the transaction from the wallet by setting the deleted date to the current date/time.  Requires a valid account and transactionId.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/wallet/delete"
        value = [PATH_DELETE_OFFER_TRANSACTION],
        produces = ["*/*"]
    )
    fun deleteOfferTransaction(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The offer transaction id to remove", required = true) @Valid @RequestParam(value = "transactionId", required = true) transactionId: kotlin.Long,
        @Parameter(description = "The device id (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "The account id of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Delete Offer Status",
        operationId = "deleteOfferTransactionStatus",
        description = """Mark an offer status record as deleted""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/offer/status/delete"
        value = [PATH_DELETE_OFFER_TRANSACTION_STATUS],
        produces = ["*/*"]
    )
    fun deleteOfferTransactionStatus(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The id of the record to delete", required = true) @Valid @RequestParam(value = "statusId", required = true) statusId: kotlin.Long,
        @Parameter(description = "The device id (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "The account id of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "Used to update the user's current location") @Valid @RequestParam(value = "latitude", required = false) latitude: kotlin.Double?,
        @Parameter(description = "Used to update the user's current location") @Valid @RequestParam(value = "longitude", required = false) longitude: kotlin.Double?
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Delete Order",
        operationId = "deleteOrder",
        description = """Removes the transaction from the wallet by setting the deleted date to the current date/time.  Requires a valid account and transactionId.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/order/delete"
        value = [PATH_DELETE_ORDER],
        produces = ["*/*"]
    )
    fun deleteOrder(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "Order Id", required = true) @Valid @RequestParam(value = "orderId", required = true) orderId: kotlin.Long,
        @Parameter(description = "The device id (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "The account id of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Delete Pack",
        operationId = "deletePack",
        description = """Delete a pack.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/pack/delete"
        value = [PATH_DELETE_PACK],
        produces = ["*/*"]
    )
    fun deletePack(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the id of the logged in user", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "the id of the pack to delete", required = true) @Valid @RequestParam(value = "packId", required = true) packId: kotlin.Long
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Delete Persona",
        operationId = "deletePersona",
        description = """Mark the persona for deletion.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/persona/delete"
        value = [PATH_DELETE_PERSONA],
        produces = ["*/*"]
    )
    fun deletePersona(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the account id of the user", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "the id of the persona to delete", required = true) @Valid @RequestParam(value = "personaId", required = true) personaId: kotlin.Long
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Reset All Points Balance",
        operationId = "deletePointsBalance",
        description = """Reset All Points Balance.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation") ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/vatom/b/campaign/points/delete"
        value = [PATH_DELETE_POINTS_BALANCE]
    )
    fun deletePointsBalance(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "Sirqul Account Id", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "Sirqul Application Key", required = true) @Valid @RequestParam(value = "appKey", required = true) appKey: kotlin.String,
        @NotNull @Parameter(description = "Vatom Campaign Id", required = true) @Valid @RequestParam(value = "vatomCampaignId", required = true) vatomCampaignId: kotlin.String,
        @Parameter(description = "Return raw response") @Valid @RequestParam(value = "returnRawResponse", required = false) returnRawResponse: kotlin.Boolean?
    ): ResponseEntity<Unit> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Delete Postal Code",
        operationId = "deletePostalCode",
        description = """Delete a Postal Code""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/postalCode/delete"
        value = [PATH_DELETE_POSTAL_CODE],
        produces = ["*/*"]
    )
    fun deletePostalCode(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the id of the logged in user", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "the id of the postal code to delete", required = true) @Valid @RequestParam(value = "postalCodeId", required = true) postalCodeId: kotlin.Long
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Delete Program",
        operationId = "deleteProgram",
        description = """Delete an existing program""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation") ]
    )
    @RequestMapping(
        method = [RequestMethod.DELETE],
        // "/api/{version}/program/{id}"
        value = [PATH_DELETE_PROGRAM]
    )
    fun deleteProgram(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "the id of the program", required = true) @PathVariable("id") id: kotlin.Long
    ): ResponseEntity<Unit> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Delete Purchase",
        operationId = "deletePurchaseItem",
        description = """Marks the purchase item as deleted""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/purchase/delete"
        value = [PATH_DELETE_PURCHASE_ITEM],
        produces = ["*/*"]
    )
    fun deletePurchaseItem(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The purchase item id", required = true) @Valid @RequestParam(value = "purchaseItemId", required = true) purchaseItemId: kotlin.Long,
        @Parameter(description = "The device id (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "The account id of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Delete Question",
        operationId = "deleteQuestion",
        description = """Delete a question by the given questionId. The accountId given needs to be the owner or executive to delete.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/game/question/delete"
        value = [PATH_DELETE_QUESTION],
        produces = ["*/*"]
    )
    fun deleteQuestion(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the id of the question to delete", required = true) @Valid @RequestParam(value = "questionId", required = true) questionId: kotlin.Long,
        @NotNull @Parameter(description = "the id of the account that can execute this request", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Delete Rating",
        operationId = "deleteRating",
        description = """Sets a rating as deleted.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/rating/delete"
        value = [PATH_DELETE_RATING],
        produces = ["*/*"]
    )
    fun deleteRating(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The ID of the rating to delete", required = true) @Valid @RequestParam(value = "ratingId", required = true) ratingId: kotlin.Long,
        @Parameter(description = "The unique device identifier that made the request (either deviceId or accountId must be used)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "The unique accountId that made the request (either deviceId or accountId must be used)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Delete Region",
        operationId = "deleteRegion",
        description = """Delete a region.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = RegionResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/region/delete"
        value = [PATH_DELETE_REGION],
        produces = ["*/*"]
    )
    fun deleteRegion(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the id of the account logged in", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "the id of the region", required = true) @Valid @RequestParam(value = "regionId", required = true) regionId: kotlin.Long
    ): ResponseEntity<RegionResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Delete Reservation",
        operationId = "deleteReservation",
        description = """Deleted a reservation on a reservation object""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation") ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/reservation/delete"
        value = [PATH_DELETE_RESERVATION]
    )
    fun deleteReservation(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The reservation id", required = true) @Valid @RequestParam(value = "reservationId", required = true) reservationId: kotlin.Long,
        @Parameter(description = "The device id (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "The account id of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?
    ): ResponseEntity<Unit> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Delete Retailer",
        operationId = "deleteRetailer",
        description = """Set the deleted timestamp to current time.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/retailer/delete"
        value = [PATH_DELETE_RETAILER],
        produces = ["*/*"]
    )
    fun deleteRetailer(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "The device id (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "The account used to perform the delete, must have rights to edit the retailer.") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "The ID of the retailer to be deleted") @Valid @RequestParam(value = "retailerId", required = false) retailerId: kotlin.Long?
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Delete Retailer Location",
        operationId = "deleteRetailerLocation",
        description = """Set the deleted timestamp to current time. This effectively deletes the retailer location since all queries should ignore any records with a deleted time stamp.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/retailer/location/delete"
        value = [PATH_DELETE_RETAILER_LOCATION],
        produces = ["*/*"]
    )
    fun deleteRetailerLocation(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "the device id") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "the id of the logged in user") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "the id of the retailer location to delete") @Valid @RequestParam(value = "retailerLocationId", required = false) retailerLocationId: kotlin.Long?
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Delete Route",
        operationId = "deleteRoute",
        description = """Delete an existing route""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation") ]
    )
    @RequestMapping(
        method = [RequestMethod.DELETE],
        // "/api/{version}/route/{routeId}"
        value = [PATH_DELETE_ROUTE]
    )
    fun deleteRoute(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "the id of the route", required = true) @PathVariable("routeId") routeId: kotlin.Long
    ): ResponseEntity<Unit> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Delete Route Setting",
        operationId = "deleteRouteSettings",
        description = """Delete an existing route setting""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = kotlin.Any::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.DELETE],
        // "/api/{version}/route/setting/{routeSettingsId}"
        value = [PATH_DELETE_ROUTE_SETTINGS],
        produces = ["*/*"]
    )
    fun deleteRouteSettings(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "the id of the route setting to delete", required = true) @PathVariable("routeSettingsId") routeSettingsId: kotlin.Long
    ): ResponseEntity<kotlin.Any> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Delete Scheduled Notification",
        operationId = "deleteScheduledNotification",
        description = """This endpoint deletes a Scheduled Notification. Only the original owner of the Scheduled Notification or someone with write permissions can use this endpoint. Permissions can be granted to other users by using the UserPermissionsApi.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = ScheduledNotificationFullResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/notification/schedule/delete"
        value = [PATH_DELETE_SCHEDULED_NOTIFICATION],
        produces = ["*/*"]
    )
    fun deleteScheduledNotification(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the id of the logged in user", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "the id of the scheduled notification to delete", required = true) @Valid @RequestParam(value = "scheduledNotificationId", required = true) scheduledNotificationId: kotlin.Long,
        @Parameter(description = "If set to true, also deletes Scheduled Notifications under the same account with the same groupingId.") @Valid @RequestParam(value = "deleteByGroupingId", required = false) deleteByGroupingId: kotlin.Boolean?
    ): ResponseEntity<ScheduledNotificationFullResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Delete Secure Application",
        operationId = "deleteSecureApplication",
        description = """Delete a secure application record.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/secure/application/delete"
        value = [PATH_DELETE_SECURE_APPLICATION],
        produces = ["*/*"]
    )
    fun deleteSecureApplication(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The unique id of the user making the request", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "The application to secure", required = true) @Valid @RequestParam(value = "appKey", required = true) appKey: kotlin.String
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Delete Service Hub",
        operationId = "deleteServiceHub",
        description = """Delete an existing service hub""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation") ]
    )
    @RequestMapping(
        method = [RequestMethod.DELETE],
        // "/api/{version}/hub/{id}"
        value = [PATH_DELETE_SERVICE_HUB]
    )
    fun deleteServiceHub(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "the id of the service hub to delete", required = true) @PathVariable("id") id: kotlin.Long
    ): ResponseEntity<Unit> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Delete Shipment",
        operationId = "deleteShipment",
        description = """Delete an existing shipment""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation") ]
    )
    @RequestMapping(
        method = [RequestMethod.DELETE],
        // "/api/{version}/shipment/{id}"
        value = [PATH_DELETE_SHIPMENT]
    )
    fun deleteShipment(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "the id of the shipment to delete", required = true) @PathVariable("id") id: kotlin.Long
    ): ResponseEntity<Unit> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Delete Shipment Batch",
        operationId = "deleteShipmentBatch",
        description = """Search for shipment batches""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation") ]
    )
    @RequestMapping(
        method = [RequestMethod.DELETE],
        // "/api/{version}/shipment/batch/{batchId}"
        value = [PATH_DELETE_SHIPMENT_BATCH]
    )
    fun deleteShipmentBatch(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "the id of the shipment batch to delete", required = true) @PathVariable("batchId") batchId: kotlin.Long
    ): ResponseEntity<Unit> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Delete Vatom Space",
        operationId = "deleteSpace",
        description = """Delete a Vatom space.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation") ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/vatom/b/spaces/delete"
        value = [PATH_DELETE_SPACE]
    )
    fun deleteSpace(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "Sirqul Account Id", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "Sirqul Application Key", required = true) @Valid @RequestParam(value = "appKey", required = true) appKey: kotlin.String,
        @NotNull @Parameter(description = "Vatom Space Id", required = true) @Valid @RequestParam(value = "vatomSpaceId", required = true) vatomSpaceId: kotlin.String,
        @Parameter(description = "Return raw response") @Valid @RequestParam(value = "returnRawResponse", required = false) returnRawResponse: kotlin.Boolean?
    ): ResponseEntity<Unit> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Delete Subscription",
        operationId = "deleteSubscription",
        description = """Suspend the current subscription for the billable entity managed by the account.  The account must be the responsible manager to perform this action""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/subscription/delete"
        value = [PATH_DELETE_SUBSCRIPTION],
        produces = ["*/*"]
    )
    fun deleteSubscription(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The account used to perform the delete, must be the responsible manager", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Delete Task",
        operationId = "deleteTask",
        description = """Delete a Task""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/task/delete"
        value = [PATH_DELETE_TASK],
        produces = ["*/*"]
    )
    fun deleteTask(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The logged in user.", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "The id of the Task to delete.", required = true) @Valid @RequestParam(value = "taskId", required = true) taskId: kotlin.Long
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Delete Territory",
        operationId = "deleteTerritory",
        description = """Deletes a territory.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/territory/delete"
        value = [PATH_DELETE_TERRITORY],
        produces = ["*/*"]
    )
    fun deleteTerritory(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the id of the logged in user", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "the id of the territory to delete", required = true) @Valid @RequestParam(value = "territoryId", required = true) territoryId: kotlin.Long
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Delete Tournament",
        operationId = "deleteTournament",
        description = """Delete a tournament.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/tournament/delete"
        value = [PATH_DELETE_TOURNAMENT],
        produces = ["*/*"]
    )
    fun deleteTournament(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the id of the logged in user", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "the id of the mission to delete", required = true) @Valid @RequestParam(value = "missionId", required = true) missionId: kotlin.Long
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Delete Trigger",
        operationId = "deleteTrigger",
        description = """Mark a trigger as deleted.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/trigger/delete"
        value = [PATH_DELETE_TRIGGER],
        produces = ["*/*"]
    )
    fun deleteTrigger(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The logged in user.", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "The id of the trigger to delete.", required = true) @Valid @RequestParam(value = "triggerId", required = true) triggerId: kotlin.Long
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Delete Vatom Event",
        operationId = "deleteVatomEvent",
        description = """Delete a Vatom event.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation") ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/vatom/b/events/delete"
        value = [PATH_DELETE_VATOM_EVENT]
    )
    fun deleteVatomEvent(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "Sirqul Account Id", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "Sirqul Application Key", required = true) @Valid @RequestParam(value = "appKey", required = true) appKey: kotlin.String,
        @NotNull @Parameter(description = "Vatom Event Id", required = true) @Valid @RequestParam(value = "vatomEventId", required = true) vatomEventId: kotlin.String,
        @Parameter(description = "Return raw response") @Valid @RequestParam(value = "returnRawResponse", required = false) returnRawResponse: kotlin.Boolean?
    ): ResponseEntity<Unit> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Delete Vatom NFT",
        operationId = "deleteVatomNFT",
        description = """Delete Vatom NFT""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation") ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/vatom/vatoms/delete"
        value = [PATH_DELETE_VATOM_NFT]
    )
    fun deleteVatomNFT(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "Sirqul Account Id", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "Vatom NFT Id", required = true) @Valid @RequestParam(value = "vatomId", required = true) vatomId: kotlin.String,
        @Parameter(description = "Return raw response") @Valid @RequestParam(value = "returnRawResponse", required = false) returnRawResponse: kotlin.Boolean?
    ): ResponseEntity<Unit> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Delete Vehicle",
        operationId = "deleteVehicle",
        description = """Delete an existing vehicle""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation") ]
    )
    @RequestMapping(
        method = [RequestMethod.DELETE],
        // "/api/{version}/vehicle/{id}"
        value = [PATH_DELETE_VEHICLE]
    )
    fun deleteVehicle(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "The id of the vehicle to delete", required = true) @PathVariable("id") id: kotlin.Long
    ): ResponseEntity<Unit> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Delete Vehicle Type",
        operationId = "deleteVehicleType",
        description = """Delete a vehicle type""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation") ]
    )
    @RequestMapping(
        method = [RequestMethod.DELETE],
        // "/api/{version}/vehicle/type/{vehicleTypeId}"
        value = [PATH_DELETE_VEHICLE_TYPE]
    )
    fun deleteVehicleType(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "The id of the requested vehicle type", required = true) @PathVariable("vehicleTypeId") vehicleTypeId: kotlin.Long
    ): ResponseEntity<Unit> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Delete Word",
        operationId = "deleteWord",
        description = """Delete a word by the given id. The accountId given needs to be the owner or executive to delete.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.DELETE],
        // "/api/{version}/game/word/delete"
        value = [PATH_DELETE_WORD],
        produces = ["*/*"]
    )
    fun deleteWord(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The id of the word to delete.", required = true) @Valid @RequestParam(value = "wordId", required = true) wordId: kotlin.Long,
        @NotNull @Parameter(description = "The account vor validating permission", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Disapprove Route",
        operationId = "disapproveRoute",
        description = """Disapprove a route""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = Route::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/route/{routeId}/disapprove"
        value = [PATH_DISAPPROVE_ROUTE],
        produces = ["*/*"]
    )
    fun disapproveRoute(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "the id of the route to reject", required = true) @PathVariable("routeId") routeId: kotlin.Long
    ): ResponseEntity<Route> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Set Trip Preference Driver",
        operationId = "driveTrip",
        description = """Update trip preference to drive, also create a route and assign the trip to the route""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = Trip::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/trip/{id}/drive"
        value = [PATH_DRIVE_TRIP],
        produces = ["*/*"]
    )
    fun driveTrip(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "the id of the trip", required = true) @PathVariable("id") id: kotlin.Long,
        @NotNull @Parameter(description = "the frequency of the trip (e.g. weekly, until 2018-08-09)", required = true) @Valid @RequestParam(value = "recurrence", required = true) recurrence: kotlin.Boolean
    ): ResponseEntity<Trip> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Duplicate Category",
        operationId = "duplicateCategory",
        description = """Duplicate a category, including all its children.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = CategoryTreeResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/category/duplicate"
        value = [PATH_DUPLICATE_CATEGORY],
        produces = ["*/*"]
    )
    fun duplicateCategory(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The account id of the user (must have permissions to the target application)", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "The category ID to duplicate (includes all children)", required = true) @Valid @RequestParam(value = "categoryId", required = true) categoryId: kotlin.Long,
        @Parameter(description = "The application to assign the new category to, may be different then the application the source category is assigned to") @Valid @RequestParam(value = "appKey", required = false) appKey: kotlin.String?,
        @Parameter(description = "The parent category ID to add the target category to.") @Valid @RequestParam(value = "parentCategoryId", required = false) parentCategoryId: kotlin.Long?
    ): ResponseEntity<CategoryTreeResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Update Account",
        operationId = "editAccount",
        description = """Edit the user's profile information""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = ProfileInfoResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/account/profile/update"
        value = [PATH_EDIT_ACCOUNT],
        produces = ["*/*"]
    )
    fun editAccount(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "The device id (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "The account id of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "The account id used to edit another person's account") @Valid @RequestParam(value = "connectionAccountId", required = false) connectionAccountId: kotlin.Long?,
        @Parameter(description = "The account role to change to") @Valid @RequestParam(value = "role", required = false) role: kotlin.String?,
        @Parameter(description = "The asset id to set the user's profile image") @Valid @RequestParam(value = "assetId", required = false) assetId: kotlin.Long?,
        @Parameter(description = "The full name of the user. If this parameter is NOT empty, the  following parameters will be ignored: prefixName, firstName, middleName,  lastName, and suffixName ") @Valid @RequestParam(value = "name", required = false) name: kotlin.String?,
        @Parameter(description = "If the parameter 'name' is empty or not present, this field will be used to set the prefix of the user's name") @Valid @RequestParam(value = "prefixName", required = false) prefixName: kotlin.String?,
        @Parameter(description = "If the parameter 'name' is empty or not present, this field will be used to set the user's first name") @Valid @RequestParam(value = "firstName", required = false) firstName: kotlin.String?,
        @Parameter(description = "If the parameter 'name' is empty or not present, this field will be used to set the user's middle name") @Valid @RequestParam(value = "middleName", required = false) middleName: kotlin.String?,
        @Parameter(description = "If the parameter 'name' is empty or not present, this field will be used to set the user's last name") @Valid @RequestParam(value = "lastName", required = false) lastName: kotlin.String?,
        @Parameter(description = "If the parameter 'name' is empty or not present, this field will be used to set the suffix of the user's name") @Valid @RequestParam(value = "suffixName", required = false) suffixName: kotlin.String?,
        @Parameter(description = "This field will be used to set the user's job title") @Valid @RequestParam(value = "title", required = false) title: kotlin.String?,
        @Parameter(description = "The gender of the user AudienceGender") @Valid @RequestParam(value = "gender", required = false) gender: kotlin.String?,
        @Parameter(description = "This is deperecated, use the birthday parameter") @Valid @RequestParam(value = "age", required = false) age: kotlin.Int?,
        @Parameter(description = "The birthday date of the user in UTC milliseconds") @Valid @RequestParam(value = "birthday", required = false) birthday: kotlin.Long?,
        @Parameter(description = "The home phone number") @Valid @RequestParam(value = "homePhone", required = false) homePhone: kotlin.String?,
        @Parameter(description = "The cellular phone number") @Valid @RequestParam(value = "cellPhone", required = false) cellPhone: kotlin.String?,
        @Parameter(description = "The cellular service provider") @Valid @RequestParam(value = "cellPhoneCarrier", required = false) cellPhoneCarrier: kotlin.String?,
        @Parameter(description = "The business phone number") @Valid @RequestParam(value = "businessPhone", required = false) businessPhone: kotlin.String?,
        @Parameter(description = "The user's contact email address (NOT the username)") @Valid @RequestParam(value = "emailAddress", required = false) emailAddress: kotlin.String?,
        @Parameter(description = "The street address of the user's contact location") @Valid @RequestParam(value = "streetAddress", required = false) streetAddress: kotlin.String?,
        @Parameter(description = "Additional address information (such as a suite number, floor number, building name, or PO Box)") @Valid @RequestParam(value = "streetAddress2", required = false) streetAddress2: kotlin.String?,
        @Parameter(description = "The city of the user's contact location") @Valid @RequestParam(value = "city", required = false) city: kotlin.String?,
        @Parameter(description = "The state of the user's contact location") @Valid @RequestParam(value = "state", required = false) state: kotlin.String?,
        @Parameter(description = "The zipcode of the user's contact location") @Valid @RequestParam(value = "zipcode", required = false) zipcode: kotlin.String?,
        @Parameter(description = "The country of the user's contact location") @Valid @RequestParam(value = "country", required = false) country: kotlin.String?,
        @Parameter(description = "Allow anyone to view the user's personal profile") @Valid @RequestParam(value = "makeProfileInfoPublic", required = false) makeProfileInfoPublic: kotlin.Boolean?,
        @Parameter(description = "Allow anyone to view the user's game/app info") @Valid @RequestParam(value = "makeGameInfoPublic", required = false) makeGameInfoPublic: kotlin.Boolean?,
        @Parameter(description = "Allow anyone to view the user's friends list") @Valid @RequestParam(value = "makeFriendsInfoPublic", required = false) makeFriendsInfoPublic: kotlin.Boolean?,
        @Parameter(description = "The user's hometown") @Valid @RequestParam(value = "hometown", required = false) hometown: kotlin.String?,
        @Parameter(description = "The user's height") @Valid @RequestParam(value = "height", required = false) height: kotlin.String?,
        @Parameter(description = "The user's height in a numerical value that can be used for ordering/searching") @Valid @RequestParam(value = "heightIndex", required = false) heightIndex: kotlin.Int?,
        @Parameter(description = "The user's ethnicity") @Valid @RequestParam(value = "ethnicity", required = false) ethnicity: kotlin.String?,
        @Parameter(description = "The user's body type") @Valid @RequestParam(value = "bodyType", required = false) bodyType: kotlin.String?,
        @Parameter(description = "The user's marital status") @Valid @RequestParam(value = "maritalStatus", required = false) maritalStatus: kotlin.String?,
        @Parameter(description = "The user's children status") @Valid @RequestParam(value = "children", required = false) children: kotlin.String?,
        @Parameter(description = "The user's religion") @Valid @RequestParam(value = "religion", required = false) religion: kotlin.String?,
        @Parameter(description = "The user's education") @Valid @RequestParam(value = "education", required = false) education: kotlin.String?,
        @Parameter(description = "The user's education in a numerical value that can be used for ordering/searching") @Valid @RequestParam(value = "educationIndex", required = false) educationIndex: kotlin.Int?,
        @Parameter(description = "The user's smoke status") @Valid @RequestParam(value = "smoke", required = false) smoke: kotlin.String?,
        @Parameter(description = "The user's drink status") @Valid @RequestParam(value = "drink", required = false) drink: kotlin.String?,
        @Parameter(description = "The user's companionship status") @Valid @RequestParam(value = "companionship", required = false) companionship: kotlin.String?,
        @Parameter(description = "The user's companionship index") @Valid @RequestParam(value = "companionshipIndex", required = false) companionshipIndex: kotlin.Int?,
        @Parameter(description = "The preferred minimum age in the account location search") @Valid @RequestParam(value = "preferredMinAge", required = false) preferredMinAge: kotlin.Int?,
        @Parameter(description = "The preferred maximum age in the account location search") @Valid @RequestParam(value = "preferredMaxAge", required = false) preferredMaxAge: kotlin.Int?,
        @Parameter(description = "The preferred minimum height in the account location search") @Valid @RequestParam(value = "preferredMinHeight", required = false) preferredMinHeight: kotlin.Int?,
        @Parameter(description = "The preferred maximum height in the account location search") @Valid @RequestParam(value = "preferredMaxHeight", required = false) preferredMaxHeight: kotlin.Int?,
        @Parameter(description = "The preferred gender in the account location search") @Valid @RequestParam(value = "preferredGender", required = false) preferredGender: kotlin.String?,
        @Parameter(description = "The preferred education in the account location search") @Valid @RequestParam(value = "preferredEducation", required = false) preferredEducation: kotlin.String?,
        @Parameter(description = "The preferred education in a numerical value that can be used for ordering/searching") @Valid @RequestParam(value = "preferredEducationIndex", required = false) preferredEducationIndex: kotlin.Int?,
        @Parameter(description = "The preferred body type in the account location search") @Valid @RequestParam(value = "preferredBodyType", required = false) preferredBodyType: kotlin.String?,
        @Parameter(description = "The preferred ethnicity in the account location search") @Valid @RequestParam(value = "preferredEthnicity", required = false) preferredEthnicity: kotlin.String?,
        @Parameter(description = "The preferred education in the account location search") @Valid @RequestParam(value = "preferredLocation", required = false) preferredLocation: kotlin.String?,
        @Parameter(description = "The preferred location range in the account location search") @Valid @RequestParam(value = "preferredLocationRange", required = false) preferredLocationRange: kotlin.Double?,
        @Parameter(description = "Platforms") @Valid @RequestParam(value = "platforms", required = false) platforms: kotlin.String?,
        @Parameter(description = "Tags") @Valid @RequestParam(value = "tags", required = false) tags: kotlin.String?,
        @Parameter(description = "About Us") @Valid @RequestParam(value = "aboutUs", required = false) aboutUs: kotlin.String?,
        @Parameter(description = "Match Token") @Valid @RequestParam(value = "matchToken", required = false) matchToken: kotlin.String?,
        @Parameter(description = "Game Experience") @Valid @RequestParam(value = "gameExperience", required = false) gameExperience: kotlin.String?,
        @Parameter(description = "Deprecated use categoryIds") @Valid @RequestParam(value = "categories", required = false) categories: kotlin.String?,
        @Parameter(description = "A list of category ids that represent interests and associations") @Valid @RequestParam(value = "categoryIds", required = false) categoryIds: kotlin.String?,
        @Parameter(description = "A comma separated list of ProfileFilters for filtering the returned response data", schema = Schema(defaultValue = "PROFILE,PROFILE_CONTACT")) @Valid @RequestParam(value = "responseFilters", required = false, defaultValue = "PROFILE,PROFILE_CONTACT") responseFilters: kotlin.String,
        @Parameter(description = "The user's preference if they want to be shown by zipcode on a map") @Valid @RequestParam(value = "showAsZipcode", required = false) showAsZipcode: kotlin.Boolean?,
        @Parameter(description = "The user's preference if they want to be shown by their exact location on a map") @Valid @RequestParam(value = "showExactLocation", required = false) showExactLocation: kotlin.Boolean?,
        @Parameter(description = "The user's preference if they want to see others exact location on a map") @Valid @RequestParam(value = "showOthersExactLocation", required = false) showOthersExactLocation: kotlin.Boolean?,
        @Parameter(description = "Accepted Terms") @Valid @RequestParam(value = "acceptedTerms", required = false) acceptedTerms: kotlin.Boolean?,
        @Parameter(description = "Location Visibility") @Valid @RequestParam(value = "locationVisibility", required = false) locationVisibility: kotlin.String?,
        @Parameter(description = "App Blob") @Valid @RequestParam(value = "appBlob", required = false) appBlob: kotlin.String?,
        @Parameter(description = "App Enable Push") @Valid @RequestParam(value = "appEnablePush", required = false) appEnablePush: kotlin.Boolean?,
        @Parameter(description = "App Enable SMS") @Valid @RequestParam(value = "appEnableSMS", required = false) appEnableSMS: kotlin.Boolean?,
        @Parameter(description = "App Enable Email") @Valid @RequestParam(value = "appEnableEmail", required = false) appEnableEmail: kotlin.Boolean?,
        @Parameter(description = "Game Type") @Valid @RequestParam(value = "gameType", required = false) gameType: kotlin.String?,
        @Parameter(description = "The application key") @Valid @RequestParam(value = "appKey", required = false) appKey: kotlin.String?,
        @Parameter(description = "The current latitude of the user") @Valid @RequestParam(value = "latitude", required = false) latitude: kotlin.Double?,
        @Parameter(description = "The current longitude of the user") @Valid @RequestParam(value = "longitude", required = false) longitude: kotlin.Double?,
        @Parameter(description = "Return Profile") @Valid @RequestParam(value = "returnProfile", required = false) returnProfile: kotlin.Boolean?,
        @Parameter(description = "Audience Ids to add") @Valid @RequestParam(value = "audienceIdsToAdd", required = false) audienceIdsToAdd: kotlin.String?,
        @Parameter(description = "Audience Ids to remove") @Valid @RequestParam(value = "audienceIdsToRemove", required = false) audienceIdsToRemove: kotlin.String?,
        @Parameter(description = "The account id of the referrer") @Valid @RequestParam(value = "referralAccountId", required = false) referralAccountId: kotlin.Long?,
        @Parameter(description = "App nickname") @Valid @RequestParam(value = "appNickname", required = false) appNickname: kotlin.String?,
        @Parameter(description = "Personal Audience") @Valid @RequestParam(value = "personalAudienceId", required = false) personalAudienceId: kotlin.Long?,
        @Parameter(description = "The user's username to update with if they currently have a guest username") @Valid @RequestParam(value = "nonGuestUsername", required = false) nonGuestUsername: kotlin.String?
    ): ResponseEntity<ProfileInfoResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Update Username and Email",
        operationId = "editUsername",
        description = """Update account's own username and/or emailAddress""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/account/username/update"
        value = [PATH_EDIT_USERNAME],
        produces = ["*/*"]
    )
    fun editUsername(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "The device id") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "The account id of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "the user's contact email address (NOT the username) which is also used for email validation") @Valid @RequestParam(value = "emailAddress", required = false) emailAddress: kotlin.String?,
        @Parameter(description = "the user's username to update with if they currently have a guest username") @Valid @RequestParam(value = "username", required = false) username: kotlin.String?
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Detect emotions",
        operationId = "emotion",
        description = """Detects emotions in an audio or video recording.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = OrsonAiEmotionsResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/orson/ai/emotion"
        value = [PATH_EMOTION],
        produces = ["*/*"]
    )
    fun emotion(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "Sirqul Account Id", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @Parameter(description = "A third-party account id that is meaningful to your systems") @Valid @RequestParam(value = "thirdPartyAccountId", required = false) thirdPartyAccountId: kotlin.String?,
        @Parameter(description = "An uploaded recording to analyze (Currently limited to 10MB)") @Valid @RequestParam(value = "file", required = false) file: org.springframework.web.multipart.MultipartFile,
        @Parameter(description = "A recording file to download and analyze (Size limit: 1GB)") @Valid @RequestParam(value = "url", required = false) url: kotlin.String?,
        @Parameter(description = "When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open") @Valid @RequestParam(value = "callback", required = false) paramCallback: kotlin.String?
    ): ResponseEntity<OrsonAiEmotionsResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Invite to Event",
        operationId = "eventInvite",
        description = """Allows a user to invite people to attend an event. This will generate an invite token, which when used, will allow the invitee to add the offer to their wallet.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = InviteResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/invite/event"
        value = [PATH_EVENT_INVITE],
        produces = ["*/*"]
    )
    fun eventInvite(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the account ID of the user making the share", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "the application key", required = true) @Valid @RequestParam(value = "appKey", required = true) appKey: kotlin.String,
        @NotNull @Parameter(description = "The ID of the event listing", required = true) @Valid @RequestParam(value = "listingId", required = true) listingId: kotlin.Long,
        @Parameter(description = "the account ID of a Sirqul user they would like to share an event with") @Valid @RequestParam(value = "receiverAccountIds", required = false) receiverAccountIds: kotlin.String?,
        @Parameter(description = "The retailer location id of where the event will take place") @Valid @RequestParam(value = "retailerLocationId", required = false) retailerLocationId: kotlin.Long?
    ): ResponseEntity<InviteResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Execute Action on NFT",
        operationId = "executeActionOnNFT",
        description = """Execute Action on NFT.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation") ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/vatom/vatoms/execute-action"
        value = [PATH_EXECUTE_ACTION_ON_NFT]
    )
    fun executeActionOnNFT(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "Sirqul Account Id", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "Vatom NFT Id", required = true) @Valid @RequestParam(value = "vatomId", required = true) vatomId: kotlin.String,
        @NotNull @Parameter(description = "Vatom Parameters", required = true) @Valid @RequestParam(value = "vatomParameters", required = true) vatomParameters: kotlin.String,
        @Parameter(description = "Return raw response") @Valid @RequestParam(value = "returnRawResponse", required = false) returnRawResponse: kotlin.Boolean?
    ): ResponseEntity<Unit> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get Filtered Usage",
        operationId = "filteredUsage",
        description = """Query analytics to get data used for graphs and charts""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = ChartData::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/analytics/filteredUsage"
        value = [PATH_FILTERED_USAGE],
        produces = ["*/*"]
    )
    fun filteredUsage(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "The unique id of the device making the request (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "The account id of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "This parameter is deprecated.") @Valid @RequestParam(value = "applicationId", required = false) applicationId: kotlin.Long?,
        @Parameter(description = "The application key used to filter results by application") @Valid @RequestParam(value = "appKey", required = false) appKey: kotlin.String?,
        @Parameter(description = "Used to search for results after or equal to this date (UNIX time-stamp in milliseconds)") @Valid @RequestParam(value = "startDate", required = false) startDate: kotlin.Long?,
        @Parameter(description = "Used to search for results before or equal to this date (UNIX time-stamp in milliseconds)") @Valid @RequestParam(value = "endDate", required = false) endDate: kotlin.Long?,
        @Parameter(description = "The device type to filter results by (performs a LIKE search)") @Valid @RequestParam(value = "deviceType", required = false) deviceType: kotlin.String?,
        @Parameter(description = "The device to filter results by (performs a LIKE search)") @Valid @RequestParam(value = "device", required = false) device: kotlin.String?,
        @Parameter(description = "The device OS to filter results by (performs a LIKE search)") @Valid @RequestParam(value = "deviceOS", required = false) deviceOS: kotlin.String?,
        @Parameter(description = "The gender to filter results by {MALE, FEMALE}") @Valid @RequestParam(value = "gender", required = false) gender: kotlin.String?,
        @Parameter(description = "Comma separated list of age groups to filter by {AGE_0_13, AGE_14_17, AGE_18_22, AGE_23_30, AGE_31_54, AGE_55_PLUS}") @Valid @RequestParam(value = "ageGroup", required = false) ageGroup: kotlin.String?,
        @Parameter(description = "The country to filter results by (performs a wild-card search)") @Valid @RequestParam(value = "country", required = false) country: kotlin.String?,
        @Parameter(description = "The state to filter results by (performs a wild-card search)") @Valid @RequestParam(value = "state", required = false) state: kotlin.String?,
        @Parameter(description = "The city to filter results by (performs a wild-card search)") @Valid @RequestParam(value = "city", required = false) city: kotlin.String?,
        @Parameter(description = "The zip to filter results by (performs a wild-card search)") @Valid @RequestParam(value = "zip", required = false) zip: kotlin.String?,
        @Parameter(description = "The model to filter results by (performs a wild-card search)") @Valid @RequestParam(value = "model", required = false) model: kotlin.String?,
        @Parameter(description = "The tag to filter results by (performs a wild-card search)") @Valid @RequestParam(value = "tag", required = false) tag: kotlin.String?,
        @Parameter(description = "The account id to filter results for a particular user") @Valid @RequestParam(value = "userAccountId", required = false) userAccountId: kotlin.Long?,
        @Parameter(description = "The user display to filter results by (performs a wild-card search)") @Valid @RequestParam(value = "userAccountDisplay", required = false) userAccountDisplay: kotlin.String?,
        @Parameter(description = "The username to filter results by (performs a wild-card search)") @Valid @RequestParam(value = "userAccountUsername", required = false) userAccountUsername: kotlin.String?,
        @Parameter(description = "The ID for the custom table column") @Valid @RequestParam(value = "customId", required = false) customId: kotlin.Long?,
        @Parameter(description = "The type defined for the custom table column") @Valid @RequestParam(value = "customType", required = false) customType: kotlin.String?,
        @Parameter(description = "The value for the custom table column") @Valid @RequestParam(value = "customValue", required = false) customValue: kotlin.Double?,
        @Parameter(description = "The value for another custom table column") @Valid @RequestParam(value = "customValue2", required = false) customValue2: kotlin.Double?,
        @Parameter(description = "The value that supports Longs for custom table column") @Valid @RequestParam(value = "customLong", required = false) customLong: kotlin.Long?,
        @Parameter(description = "The value that supports Longs for custom table column") @Valid @RequestParam(value = "customLong2", required = false) customLong2: kotlin.Long?,
        @Parameter(description = "The message for the custom table column") @Valid @RequestParam(value = "customMessage", required = false) customMessage: kotlin.String?,
        @Parameter(description = "The message for the custom table column") @Valid @RequestParam(value = "customMessage2", required = false) customMessage2: kotlin.String?,
        @Parameter(description = "Determines how to group results. For example, passing in 'CREATED' will return results by date. Passing in 'ACCOUNT' will return results by user {TAG, CUSTOM_ID, TOKEN, MODEL, DEVICE_TYPE, DEVICE, DEVICE_OS, DEVICE_ID, IP_ADDRESS, STATE, CITY, ZIP, COUNTRY, ACCOUNT, APPLICATION_ID}", schema = Schema(allowableValues = ["TAG_COUNT", "TAG", "TOKEN", "MODEL", "DEVICE_TYPE", "DEVICE", "DEVICE_OS", "DEVICE_ID", "IP_ADDRESS", "STATE", "CITY", "ZIP", "COUNTRY", "CREATED", "UPDATED", "LAST_UPDATED", "CLIENT_TIME", "ACTIVE", "CUSTOM_ID", "CUSTOM_TYPE", "CUSTOM_VALUE", "CUSTOM_VALUE2", "CUSTOM_LONG", "CUSTOM_LONG2", "CUSTOM_MESSAGE", "CUSTOM_MESSAGE2", "ACCOUNT_ID", "ACCOUNT_USERNAME", "ACCOUNT_DISPLAY", "ACCOUNT_CREATED", "ACCOUNT_GENDER", "ACCOUNT_AGE_GROUP", "APPLICATION_ID", "APPLICATION_KEY", "APPLICATION_NAME"])) @Valid @RequestParam(value = "groupBy", required = false) groupBy: kotlin.String?,
        @Parameter(description = "Performs a unique query on the specified column. For example, passing in 'ACCOUNT' will return the number of unique users. {TAG, CUSTOM_ID, TOKEN, MODEL, DEVICE_TYPE, DEVICE, DEVICE_OS, DEVICE_ID, IP_ADDRESS, STATE, CITY, ZIP, COUNTRY, ACCOUNT, APPLICATION_ID}", schema = Schema(allowableValues = ["TAG_COUNT", "TAG", "TOKEN", "MODEL", "DEVICE_TYPE", "DEVICE", "DEVICE_OS", "DEVICE_ID", "IP_ADDRESS", "STATE", "CITY", "ZIP", "COUNTRY", "CREATED", "UPDATED", "LAST_UPDATED", "CLIENT_TIME", "ACTIVE", "CUSTOM_ID", "CUSTOM_TYPE", "CUSTOM_VALUE", "CUSTOM_VALUE2", "CUSTOM_LONG", "CUSTOM_LONG2", "CUSTOM_MESSAGE", "CUSTOM_MESSAGE2", "ACCOUNT_ID", "ACCOUNT_USERNAME", "ACCOUNT_DISPLAY", "ACCOUNT_CREATED", "ACCOUNT_GENDER", "ACCOUNT_AGE_GROUP", "APPLICATION_ID", "APPLICATION_KEY", "APPLICATION_NAME"])) @Valid @RequestParam(value = "distinctCount", required = false) distinctCount: kotlin.String?,
        @Parameter(description = "sum of the column values", schema = Schema(allowableValues = ["TAG_COUNT", "TAG", "TOKEN", "MODEL", "DEVICE_TYPE", "DEVICE", "DEVICE_OS", "DEVICE_ID", "IP_ADDRESS", "STATE", "CITY", "ZIP", "COUNTRY", "CREATED", "UPDATED", "LAST_UPDATED", "CLIENT_TIME", "ACTIVE", "CUSTOM_ID", "CUSTOM_TYPE", "CUSTOM_VALUE", "CUSTOM_VALUE2", "CUSTOM_LONG", "CUSTOM_LONG2", "CUSTOM_MESSAGE", "CUSTOM_MESSAGE2", "ACCOUNT_ID", "ACCOUNT_USERNAME", "ACCOUNT_DISPLAY", "ACCOUNT_CREATED", "ACCOUNT_GENDER", "ACCOUNT_AGE_GROUP", "APPLICATION_ID", "APPLICATION_KEY", "APPLICATION_NAME"])) @Valid @RequestParam(value = "sumColumn", required = false) sumColumn: kotlin.String?,
        @Parameter(description = "Determines whether the results will be sorted by day or by number of hits {CREATED, TAG_COUNT}", schema = Schema(allowableValues = ["TAG_COUNT", "TAG", "TOKEN", "MODEL", "DEVICE_TYPE", "DEVICE", "DEVICE_OS", "DEVICE_ID", "IP_ADDRESS", "STATE", "CITY", "ZIP", "COUNTRY", "CREATED", "UPDATED", "LAST_UPDATED", "CLIENT_TIME", "ACTIVE", "CUSTOM_ID", "CUSTOM_TYPE", "CUSTOM_VALUE", "CUSTOM_VALUE2", "CUSTOM_LONG", "CUSTOM_LONG2", "CUSTOM_MESSAGE", "CUSTOM_MESSAGE2", "ACCOUNT_ID", "ACCOUNT_USERNAME", "ACCOUNT_DISPLAY", "ACCOUNT_CREATED", "ACCOUNT_GENDER", "ACCOUNT_AGE_GROUP", "APPLICATION_ID", "APPLICATION_KEY", "APPLICATION_NAME"])) @Valid @RequestParam(value = "sortField", required = false) sortField: kotlin.String?,
        @Parameter(description = "Determines whether to return results in descending order") @Valid @RequestParam(value = "descending", required = false) descending: kotlin.Boolean?,
        @Parameter(description = "Determines whether to return data that has empty or unknown values") @Valid @RequestParam(value = "hideUnknown", required = false) hideUnknown: kotlin.Boolean?,
        @Parameter(description = "Determines whether to return a JOSN or XML representation of the graph results", schema = Schema(allowableValues = ["HTML", "XML", "JSON", "CSV"])) @Valid @RequestParam(value = "responseFormat", required = false) responseFormat: kotlin.String?,
        @Parameter(description = "This parameter is deprecated.") @Valid @RequestParam(value = "_l", required = false) l: kotlin.Int?,
        @Parameter(description = "Used to limit results to get a cleaner graph. The results that gets filtered out will be combined") @Valid @RequestParam(value = "limit", required = false) limit: kotlin.Int?,
        @Parameter(description = "the current latitude of the user") @Valid @RequestParam(value = "latitude", required = false) latitude: kotlin.Double?,
        @Parameter(description = "the current longitude of the user") @Valid @RequestParam(value = "longitude", required = false) longitude: kotlin.Double?
    ): ResponseEntity<ChartData> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Find Missions",
        operationId = "findMissions",
        description = """Get a set of ad filtered by the parameters provided.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = MissionResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/mission/find"
        value = [PATH_FIND_MISSIONS],
        produces = ["*/*"]
    )
    fun findMissions(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The application key, if provided return missions specific for the app. Will always return mission levels that are app agnostic.", required = true) @Valid @RequestParam(value = "appKey", required = true) appKey: kotlin.String,
        @Parameter(description = "The type of mission to get, possible values are: click_banner, click_leaderboard, click_skyscraper, click_full, click_video, or click_zip") @Valid @RequestParam(value = "suffix", required = false) suffix: kotlin.String?,
        @Parameter(description = "The type of ads to get, possible values are: BANNER, LEADERBOARD, SKYSCRAPER, FULL, VIDEO, ZIP, CONFIG. Use this instead of suffix.") @Valid @RequestParam(value = "type", required = false) type: kotlin.String?,
        @Parameter(description = "The logged in user.") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "The version of the application, will not return levels newer than the appVersion.") @Valid @RequestParam(value = "appVersion", required = false) appVersion: kotlin.String?,
        @Parameter(description = "The current location of the requesting device") @Valid @RequestParam(value = "latitude", required = false) latitude: kotlin.Double?,
        @Parameter(description = "The current location of the requesting device") @Valid @RequestParam(value = "longitude", required = false) longitude: kotlin.Double?,
        @Parameter(description = "Should use deviceId if possible. The name of the requesting device; possible values are: Android, iPhone, iPad, iPod, etc. use /audience/devices for list.") @Valid @RequestParam(value = "device", required = false) device: kotlin.String?,
        @Parameter(description = "The device ID of the requesting device, use /audience/devices for list") @Valid @RequestParam(value = "deviceIdentifier", required = false) deviceIdentifier: kotlin.Long?,
        @Parameter(description = "The requesting device version; examples are: 2.3, 5.1.4, 6.1.4. Supports X, X.X, or X.X.X formated string.") @Valid @RequestParam(value = "deviceVersion", required = false) deviceVersion: kotlin.String?,
        @Parameter(description = "The index into the record set to start with.") @Valid @RequestParam(value = "start", required = false) start: kotlin.Int?,
        @Parameter(description = "The total number of record to return.") @Valid @RequestParam(value = "limit", required = false) limit: kotlin.Int?,
        @Parameter(description = "Include the game level data with the mission.") @Valid @RequestParam(value = "includeGameData", required = false) includeGameData: kotlin.Boolean?,
        @Parameter(description = "If true then return the audience data in the response. Default is false.") @Valid @RequestParam(value = "includeAudiences", required = false) includeAudiences: kotlin.Boolean?,
        @Parameter(description = "If true/false only return missions whose game levels allocate (or don't allocate) tickets. Do not provide a value to return both.") @Valid @RequestParam(value = "allocatesTickets", required = false) allocatesTickets: kotlin.Boolean?,
        @Parameter(description = "return a random set of results, default is true. If false returns in natural order.") @Valid @RequestParam(value = "randomize", required = false) randomize: kotlin.Boolean?,
        @Parameter(description = "return only ads targeted to the specific app, no global ads.") @Valid @RequestParam(value = "targetedAdsOnly", required = false) targetedAdsOnly: kotlin.Boolean?,
        @Parameter(description = "return only ads from the specified campaigns.") @Valid @RequestParam(value = "missionIds", required = false) missionIds: kotlin.String?,
        @Parameter(description = "will return the items that have at least 1 or all of their audiences exist in the logged in users audiences, depending if the value is OR or AND") @Valid @RequestParam(value = "audienceOperator", required = false) audienceOperator: kotlin.String?
    ): ResponseEntity<MissionResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Set Trip Preference Flexible",
        operationId = "flexibleTrip",
        description = """Update trip preference to flexible.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = Trip::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/trip/{id}/flexible"
        value = [PATH_FLEXIBLE_TRIP],
        produces = ["*/*"]
    )
    fun flexibleTrip(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "the id of the trip", required = true) @PathVariable("id") id: kotlin.Long,
        @NotNull @Parameter(description = "the frequency of the trip (e.g. weekly, until 2018-08-09)", required = true) @Valid @RequestParam(value = "recurrence", required = true) recurrence: kotlin.Boolean
    ): ResponseEntity<Trip> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Accept Follow Request",
        operationId = "followAccept",
        description = """Accept someone's follow request.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/consumer/follow/accept"
        value = [PATH_FOLLOW_ACCEPT],
        produces = ["*/*"]
    )
    fun followAccept(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the account id of the user", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "the account ID of the user who initiated the follow", required = true) @Valid @RequestParam(value = "connectionAccountId", required = true) connectionAccountId: kotlin.Long,
        @NotNull @Parameter(description = "the application key for sending notifications", required = true) @Valid @RequestParam(value = "appKey", required = true) appKey: kotlin.String
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Reject Follow Request",
        operationId = "followReject",
        description = """Reject someone's follow request or remove them as a follower.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/consumer/follow/reject"
        value = [PATH_FOLLOW_REJECT],
        produces = ["*/*"]
    )
    fun followReject(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the account id of the user", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "the account ID of the user who initiated the follow", required = true) @Valid @RequestParam(value = "connectionAccountId", required = true) connectionAccountId: kotlin.Long,
        @NotNull @Parameter(description = "the application key for sending notifications", required = true) @Valid @RequestParam(value = "appKey", required = true) appKey: kotlin.String
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Remove Follower / Unfollow",
        operationId = "followRemove",
        description = """Unfollow someone you are following or remove them as a follower.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/consumer/follow/remove"
        value = [PATH_FOLLOW_REMOVE],
        produces = ["*/*"]
    )
    fun followRemove(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the account id of the user", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "the account ID of the user who you want to unfollow", required = true) @Valid @RequestParam(value = "connectionAccountId", required = true) connectionAccountId: kotlin.Long,
        @NotNull @Parameter(description = "the application key for sending notifications", required = true) @Valid @RequestParam(value = "appKey", required = true) appKey: kotlin.String
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Send Follow Request",
        operationId = "followRequest",
        description = """Send a request to follow someone.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/consumer/follow/request"
        value = [PATH_FOLLOW_REQUEST],
        produces = ["*/*"]
    )
    fun followRequest(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the account id of the user", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "the account ID of the user who you want to follow", required = true) @Valid @RequestParam(value = "connectionAccountId", required = true) connectionAccountId: kotlin.Long,
        @NotNull @Parameter(description = "the application key for sending notifications", required = true) @Valid @RequestParam(value = "appKey", required = true) appKey: kotlin.String,
        @Parameter(description = "determines if the other user needs to confirm the follow request", schema = Schema(defaultValue = "true")) @Valid @RequestParam(value = "approvalNeeded", required = false, defaultValue = "true") approvalNeeded: kotlin.Boolean
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Accept Friend",
        operationId = "friendAccept",
        description = """Accept a friend request and optionally sends a notification.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/consumer/friend/accept"
        value = [PATH_FRIEND_ACCEPT],
        produces = ["*/*"]
    )
    fun friendAccept(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the friend's account id", required = true) @Valid @RequestParam(value = "friendAccountId", required = true) friendAccountId: kotlin.Long,
        @NotNull @Parameter(description = "determines whether to send a notification to the afflicting party", required = true) @Valid @RequestParam(value = "notifyFriend", required = true) notifyFriend: kotlin.Boolean,
        @Parameter(description = "the device id (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "the account id of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "This parameter is deprecated.") @Valid @RequestParam(value = "gameType", required = false) gameType: kotlin.String?,
        @Parameter(description = "the application key") @Valid @RequestParam(value = "appKey", required = false) appKey: kotlin.String?,
        @Parameter(description = "optional message to send in a notification") @Valid @RequestParam(value = "notificationMessage", required = false) notificationMessage: kotlin.String?
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Decline Friend",
        operationId = "friendReject",
        description = """Request a friend request and optionally sends a notification.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/consumer/friend/reject"
        value = [PATH_FRIEND_REJECT],
        produces = ["*/*"]
    )
    fun friendReject(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the friend's account id", required = true) @Valid @RequestParam(value = "friendAccountId", required = true) friendAccountId: kotlin.Long,
        @Parameter(description = "the device id (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "the account id of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "This parameter is deprecated.") @Valid @RequestParam(value = "gameType", required = false) gameType: kotlin.String?,
        @Parameter(description = "the application key") @Valid @RequestParam(value = "appKey", required = false) appKey: kotlin.String?,
        @Parameter(description = "determines whether to send a notification to the afflicting party") @Valid @RequestParam(value = "notifyFriend", required = false) notifyFriend: kotlin.Boolean?,
        @Parameter(description = "optional message to send in a notification") @Valid @RequestParam(value = "notificationMessage", required = false) notificationMessage: kotlin.String?
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Delete Friend",
        operationId = "friendRemove",
        description = """Removes a friend from the user's friends list.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/consumer/friend/remove"
        value = [PATH_FRIEND_REMOVE],
        produces = ["*/*"]
    )
    fun friendRemove(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the account ID of the friend to remove", required = true) @Valid @RequestParam(value = "friendAccountId", required = true) friendAccountId: kotlin.Long,
        @Parameter(description = "the device id (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "the account id of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "optionally notifies the connection that they have been removed as a friend") @Valid @RequestParam(value = "notifyFriend", required = false) notifyFriend: kotlin.Boolean?,
        @Parameter(description = "optionally removes the connection from the user's groups") @Valid @RequestParam(value = "removeFromGroups", required = false) removeFromGroups: kotlin.Boolean?
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Request Friend",
        operationId = "friendRequest",
        description = """Sends a friend request notification to another user.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/consumer/friend/request"
        value = [PATH_FRIEND_REQUEST],
        produces = ["*/*"]
    )
    fun friendRequest(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the friend's account id", required = true) @Valid @RequestParam(value = "friendAccountId", required = true) friendAccountId: kotlin.Long,
        @Parameter(description = "the device id (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "the account id of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "This parameter is deprecated.") @Valid @RequestParam(value = "gameType", required = false) gameType: kotlin.String?,
        @Parameter(description = "the application key") @Valid @RequestParam(value = "appKey", required = false) appKey: kotlin.String?,
        @Parameter(description = "optional message to send in a notification") @Valid @RequestParam(value = "notificationMessage", required = false) notificationMessage: kotlin.String?
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Invite to Game Level",
        operationId = "gameInvite",
        description = """Allows a user to invite people to gain access to an album. This will generate an invite token, which when used, will give the invitee access to an album (whether it is private or not). The invitee will also become the user's friend when the invitation is accepted.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = InviteResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/invite/gameLevel"
        value = [PATH_GAME_INVITE],
        produces = ["*/*"]
    )
    fun gameInvite(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "a unique ID given by the device (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "the account ID of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "This parameter is deprecated.") @Valid @RequestParam(value = "appId", required = false) appId: kotlin.Long?,
        @Parameter(description = "the application key") @Valid @RequestParam(value = "appKey", required = false) appKey: kotlin.String?,
        @Parameter(description = "the game level that the user owns and is giving access to") @Valid @RequestParam(value = "gameLevelId", required = false) gameLevelId: kotlin.Long?,
        @Parameter(description = "the current latitude of the user") @Valid @RequestParam(value = "latitude", required = false) latitude: kotlin.Double?,
        @Parameter(description = "the current longitude of the user") @Valid @RequestParam(value = "longitude", required = false) longitude: kotlin.Double?
    ): ResponseEntity<InviteResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Search Vatom Geo Map",
        operationId = "geomapSearch",
        description = """Search Vatom Geo Map""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation") ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/vatom/vatoms/geo-map/search"
        value = [PATH_GEOMAP_SEARCH]
    )
    fun geomapSearch(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "Sirqul Account Id", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "Vatom Parameters", required = true) @Valid @RequestParam(value = "vatomParameters", required = true) vatomParameters: kotlin.String,
        @Parameter(description = "Return raw response") @Valid @RequestParam(value = "returnRawResponse", required = false) returnRawResponse: kotlin.Boolean?
    ): ResponseEntity<Unit> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get Account",
        operationId = "getAccount",
        description = """Gets a user's account profile. Application settings and account settings will also be returned for the owner of the account.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = ProfileResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/account/profile/get"
        value = [PATH_GET_ACCOUNT],
        produces = ["*/*"]
    )
    fun getAccount(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "Return Nulls", schema = Schema(defaultValue = "false")) @Valid @RequestParam(value = "returnNulls", required = false, defaultValue = "false") returnNulls: kotlin.Boolean,
        @Parameter(description = "The device id (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "The account id of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "Connection Account Email") @Valid @RequestParam(value = "connectionAccountEmail", required = false) connectionAccountEmail: kotlin.String?,
        @Parameter(description = "The account id used to view another person's account", schema = Schema(defaultValue = "0L")) @Valid @RequestParam(value = "connectionAccountId", required = false, defaultValue = "0L") connectionAccountId: kotlin.Long,
        @Parameter(description = "A comma separated list of ProfileFilters for filtering the returned response data", schema = Schema(defaultValue = "PROFILE")) @Valid @RequestParam(value = "responseFilters", required = false, defaultValue = "PROFILE") responseFilters: kotlin.String,
        @Parameter(description = "Game Type") @Valid @RequestParam(value = "gameType", required = false) gameType: kotlin.String?,
        @Parameter(description = "The application key") @Valid @RequestParam(value = "appKey", required = false) appKey: kotlin.String?,
        @Parameter(description = "Purchase Type", schema = Schema(defaultValue = "SIRQUL")) @Valid @RequestParam(value = "purchaseType", required = false, defaultValue = "SIRQUL") purchaseType: kotlin.String,
        @Parameter(description = "Determines whether to track if a person has viewed someone's profile", schema = Schema(defaultValue = "false")) @Valid @RequestParam(value = "updateViewedDate", required = false, defaultValue = "false") updateViewedDate: kotlin.Boolean,
        @Parameter(description = "Latitude used to update the user's current location") @Valid @RequestParam(value = "latitude", required = false) latitude: kotlin.Double?,
        @Parameter(description = "Longitude used to update the user's current location") @Valid @RequestParam(value = "longitude", required = false) longitude: kotlin.Double?
    ): ResponseEntity<ProfileResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get Achievement",
        operationId = "getAchievement",
        description = """Get an achievement (for developer/retailer use). User must have permissions to the application the achievement is created for.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = AchievementTierResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/achievement/get"
        value = [PATH_GET_ACHIEVEMENT],
        produces = ["*/*"]
    )
    fun getAchievement(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The ID of the achievement", required = true) @Valid @RequestParam(value = "achievementId", required = true) achievementId: kotlin.Long,
        @Parameter(description = "a unique id given by the device (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "the account id of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "achievementType") @Valid @RequestParam(value = "achievementType", required = false) achievementType: kotlin.String?
    ): ResponseEntity<AchievementTierResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Gets an achievement tier",
        operationId = "getAchievementTier",
        description = """Gets an achievement tier (for developer/retailer use). User must have permissions to the application the achievement is created for.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = AchievementTierResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/achievement/tier/get"
        value = [PATH_GET_ACHIEVEMENT_TIER],
        produces = ["*/*"]
    )
    fun getAchievementTier(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the account id of the user (deviceId or accountId required)", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "the achievement tier id that is being retrieved", required = true) @Valid @RequestParam(value = "achievementTierId", required = true) achievementTierId: kotlin.Long
    ): ResponseEntity<AchievementTierResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get Add Movie Result",
        operationId = "getAddMovieResult",
        description = """Get the result of an in progress Add Movie request from an earlier POST.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = OrsonAiAddMovieResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/orson/ai/addMovie/{requestId}"
        value = [PATH_GET_ADD_MOVIE_RESULT],
        produces = ["*/*"]
    )
    fun getAddMovieResult(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "Orson Request Id", required = true) @PathVariable("requestId") requestId: kotlin.String,
        @NotNull @Parameter(description = "Sirqul Account Id", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long
    ): ResponseEntity<OrsonAiAddMovieResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get Age Groups",
        operationId = "getAgeGroups",
        description = """Gets the list of available age groups that can be selected by consumers and retailers targeting offers.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(array = ArraySchema(schema = Schema(implementation = AgeGroupResponse::class)))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/audience/ageGroups"
        value = [PATH_GET_AGE_GROUPS],
        produces = ["*/*"]
    )
    fun getAgeGroups(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal
    ): ResponseEntity<List<AgeGroupResponse>> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = " Get Album",
        operationId = "getAlbumCollection",
        description = """Get an Album.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = AlbumFullResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/album/get"
        value = [PATH_GET_ALBUM_COLLECTION],
        produces = ["*/*"]
    )
    fun getAlbumCollection(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "This parameter is deprecated.", required = true) @Valid @RequestParam(value = "returnNulls", required = true) returnNulls: kotlin.Boolean,
        @NotNull @Parameter(description = "the album to look up", required = true) @Valid @RequestParam(value = "albumId", required = true) albumId: kotlin.Long,
        @Parameter(description = "a unique ID given by the device (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "the account ID of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "returns the last X likes. To search on and paginate the remaining likes - please use the \"/like/search\" endpoint.") @Valid @RequestParam(value = "likePreviewSize", required = false) likePreviewSize: kotlin.Int?,
        @Parameter(description = "returns the first X assets. To search on and paginate the remaining assets - please use the \"/assets/search\" endpoint.") @Valid @RequestParam(value = "assetPreviewSize", required = false) assetPreviewSize: kotlin.Int?,
        @Parameter(description = "returns the last X notes. To search on and paginate the remaining notes - please use the \"/note/search\" endpoint.") @Valid @RequestParam(value = "notePreviewSize", required = false) notePreviewSize: kotlin.Int?,
        @Parameter(description = "returns the first X users/connections. To search on and paginate the remaining connections - please use the \"/permissions/search\" endpoint.") @Valid @RequestParam(value = "connectionPreviewSize", required = false) connectionPreviewSize: kotlin.Int?,
        @Parameter(description = "returns the first X audiences. To search on and paginate the remaining audiences - please use the \"/audience/search\" endpoint.") @Valid @RequestParam(value = "audiencePreviewSize", required = false) audiencePreviewSize: kotlin.Int?
    ): ResponseEntity<AlbumFullResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get Contest",
        operationId = "getAlbumContest",
        description = """Gets the contest object including the likes and notes""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = AlbumContestResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/consumer/album/contest/get"
        value = [PATH_GET_ALBUM_CONTEST],
        produces = ["*/*"]
    )
    fun getAlbumContest(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the album contest ID", required = true) @Valid @RequestParam(value = "albumContestId", required = true) albumContestId: kotlin.Long,
        @Parameter(description = "a unique ID given by the device (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "the account ID of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "latitude used to update the user's current location") @Valid @RequestParam(value = "latitude", required = false) latitude: kotlin.Double?,
        @Parameter(description = "longitude used to update the user's current location") @Valid @RequestParam(value = "longitude", required = false) longitude: kotlin.Double?
    ): ResponseEntity<AlbumContestResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Search Contests",
        operationId = "getAlbumContests",
        description = """Searches on contests.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = AlbumContestListResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/consumer/album/contest/search"
        value = [PATH_GET_ALBUM_CONTESTS],
        produces = ["*/*"]
    )
    fun getAlbumContests(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "a comma separated list of Ownership", required = true) @Valid @RequestParam(value = "filter", required = true) filter: kotlin.String,
        @NotNull @Parameter(description = "the field to sort by. See AlbumContestApiMap", required = true) @Valid @RequestParam(value = "sortField", required = true) sortField: kotlin.String,
        @NotNull @Parameter(description = "determines whether the sorted list is in descending or ascending order", required = true) @Valid @RequestParam(value = "descending", required = true) descending: kotlin.Boolean,
        @NotNull @Parameter(description = "the start index for pagination", required = true) @Valid @RequestParam(value = "start", required = true) start: kotlin.Int,
        @NotNull @Parameter(description = "the limit for pagination (there is a hard limit of 30)", required = true) @Valid @RequestParam(value = "limit", required = true) limit: kotlin.Int,
        @Parameter(description = "a unique ID given by the device (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "the account ID of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "This parameter is deprecated.") @Valid @RequestParam(value = "gameType", required = false) gameType: kotlin.String?,
        @Parameter(description = "the application key") @Valid @RequestParam(value = "appKey", required = false) appKey: kotlin.String?,
        @Parameter(description = "the application type") @Valid @RequestParam(value = "appType", required = false) appType: kotlin.String?,
        @Parameter(description = "filter contests with this contest type") @Valid @RequestParam(value = "contestType", required = false) contestType: kotlin.String?,
        @Parameter(description = "search on contests that have been created by this account (that the user has permissions to)") @Valid @RequestParam(value = "ownerId", required = false) ownerId: kotlin.Long?,
        @Parameter(description = "This parameter is deprecated.") @Valid @RequestParam(value = "q", required = false) q: kotlin.String?,
        @Parameter(description = "keyword search string") @Valid @RequestParam(value = "keyword", required = false) keyword: kotlin.String?,
        @Parameter(description = "This parameter is deprecated.") @Valid @RequestParam(value = "_i", required = false) i: kotlin.Int?,
        @Parameter(description = "This parameter is deprecated.") @Valid @RequestParam(value = "_l", required = false) l: kotlin.Int?,
        @Parameter(description = "filter on items that have been created before this date") @Valid @RequestParam(value = "dateCreated", required = false) dateCreated: kotlin.Long?,
        @Parameter(description = "latitude used to update the user's current location") @Valid @RequestParam(value = "latitude", required = false) latitude: kotlin.Double?,
        @Parameter(description = "longitude used to update the user's current location") @Valid @RequestParam(value = "longitude", required = false) longitude: kotlin.Double?
    ): ResponseEntity<AlbumContestListResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get App Data",
        operationId = "getAppData",
        description = """Get the application data structure.  The basic structure is a   node tree, with the root node being a AppResponse.  The response contains   the user's profile, messages from the system, and a list of MissionResponse.    A mission can have any number of GameResponses but typically is a single   game type.  A game then has any number of PackResponses which help group   the game levels. Packs are then composed of any number of GameLevelResponses.   

Using the various parameters can return the applications default mission   (built-in packs to play), the list of community levels published, the user's   saved levels, or explicity levels desired.  You can choose to include the   profile or not, or just return parts of the profile.  You can also filter   out game levels that have been published with a higher version of the application.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = AppResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/app/get"
        value = [PATH_GET_APP_DATA],
        produces = ["*/*"]
    )
    fun getAppData(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "start the search results at a record.", required = true) @Valid @RequestParam(value = "start", required = true) start: kotlin.Int,
        @NotNull @Parameter(description = "limit the search results to some number.", required = true) @Valid @RequestParam(value = "limit", required = true) limit: kotlin.Int,
        @Parameter(description = "the device id (deviceId or accountId required).") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "the account id of the user (deviceId or accountId required).") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "the game to retrieve the data for, use your application key.") @Valid @RequestParam(value = "gameType", required = false) gameType: kotlin.String?,
        @Parameter(description = "if true then include the game data blob, otherwise don't include.") @Valid @RequestParam(value = "includeGameData", required = false) includeGameData: kotlin.Boolean?,
        @Parameter(description = "This parameter is deprecated.") @Valid @RequestParam(value = "q", required = false) q: kotlin.String?,
        @Parameter(description = "query string used to filter the search results when looking for community and saved levels.") @Valid @RequestParam(value = "keyword", required = false) keyword: kotlin.String?,
        @Parameter(description = "how to sort the results when looking for community and saved levels. possible values are: LEVEL_NAME, LEVEL_CREATED, LEVEL_UPDATED, LEVEL_LIKES, LEVEL_DISLIKES, LEVEL_NOTES, LEVEL_PLAYS.") @Valid @RequestParam(value = "sortField", required = false) sortField: kotlin.String?,
        @Parameter(description = "order the search results descending or ascending when looking for community and saved levels.") @Valid @RequestParam(value = "descending", required = false) descending: kotlin.Boolean?,
        @Parameter(description = "This parameter is deprecated.") @Valid @RequestParam(value = "_i", required = false) i: kotlin.Int?,
        @Parameter(description = "This parameter is deprecated.") @Valid @RequestParam(value = "_l", required = false) l: kotlin.Int?,
        @Parameter(description = "if true then include the game object count, otherwise don't include.") @Valid @RequestParam(value = "gameObjectCount", required = false) gameObjectCount: kotlin.Boolean?,
        @Parameter(description = "restrict the search to items with certain permissions, possible values are: MINE, FRIENDS, PUBLIC, ALL_PUBLIC, ALL, LIKED") @Valid @RequestParam(value = "filter", required = false) filter: kotlin.String?,
        @Parameter(description = "restrict the search to items created less then date") @Valid @RequestParam(value = "dateCreated", required = false) dateCreated: kotlin.Long?,
        @Parameter(description = "get levels owned by a particular account") @Valid @RequestParam(value = "ownerId", required = false) ownerId: kotlin.Long?,
        @Parameter(description = "get missions by specified id, comman seperated list of long ids") @Valid @RequestParam(value = "missionIds", required = false) missionIds: kotlin.String?,
        @Parameter(description = "get games by specified id, comman seperated list of long ids") @Valid @RequestParam(value = "gameIds", required = false) gameIds: kotlin.String?,
        @Parameter(description = "get packs by specified id, comman seperated list of long ids") @Valid @RequestParam(value = "packIds", required = false) packIds: kotlin.String?,
        @Parameter(description = "get game levels by specified id, comman seperated list of long ids") @Valid @RequestParam(value = "gameLevelIds", required = false) gameLevelIds: kotlin.String?,
        @Parameter(description = "the application version, used to versin the game level data") @Valid @RequestParam(value = "appVersion", required = false) appVersion: kotlin.String?,
        @Parameter(description = "default is false and will not include any packs that have levels above the specified appVersion. If true then will return all levels regardless of version.") @Valid @RequestParam(value = "includeHigherVersionPacks", required = false) includeHigherVersionPacks: kotlin.Boolean?,
        @Parameter(description = "default is false and will not include any levels above the specified appVersion. If true then will return all levels regardless of version.") @Valid @RequestParam(value = "includeHigherVersionLevels", required = false) includeHigherVersionLevels: kotlin.Boolean?,
        @Parameter(description = "use response groups to include large parts of the structure. possible values are: * MISSION_DEFAULT (default) - include the default mission (built-in packs), excludes all other mission groups * MISSION_DEFAULT_LEVELS_SAVED - include saved levels, excludes all other mission groups * MISSION_DEFAULT_LEVELS_COMMUNITY - include community levels, excludes all other mission groups * MISSION_INVITED (default) - include challenges sent to user * PROFILE (default) - include entire profile * PROFILE_DATA - only include profile date (exclude friends) * PROFILE_FRIENDS - include friends list ") @Valid @RequestParam(value = "responseGroups", required = false) responseGroups: kotlin.String?,
        @Parameter(description = "the will return the correct in app purchases for the device, possible values are: * SIRQUL (default) - purchasing from the sirqul store using tickets * IOS - purchasing from the itunes store for iPhone, iPod, iPod Touch * GOOGLE - purchasing from the google android store * AMAZON - purchasing from the amazon android store * MAC - purchasing from the itunes store for OSX * FREE - the item is free to purchase ") @Valid @RequestParam(value = "purchaseType", required = false) purchaseType: kotlin.String?
    ): ResponseEntity<AppResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get Application",
        operationId = "getApplication",
        description = """Get a specific application by appKey""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = ApplicationResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/application/get"
        value = [PATH_GET_APPLICATION],
        produces = ["*/*"]
    )
    fun getApplication(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "The key of the application") @Valid @RequestParam(value = "appKey", required = false) appKey: kotlin.String?,
        @Parameter(description = "Application Id") @Valid @RequestParam(value = "applicationId", required = false) applicationId: kotlin.Long?
    ): ResponseEntity<ApplicationResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get AppConfig",
        operationId = "getApplicationConfig",
        description = """Gets the appConfig data by the given configId. If appConfig cannot be found, it returns an invalid response.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = ApplicationConfigResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/appconfig/get"
        value = [PATH_GET_APPLICATION_CONFIG],
        produces = ["*/*"]
    )
    fun getApplicationConfig(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The account ID of the user", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "The config ID of the application configuration", required = true) @Valid @RequestParam(value = "configId", required = true) configId: kotlin.Long
    ): ResponseEntity<ApplicationConfigResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get AppConfig by Version",
        operationId = "getApplicationConfigByConfigVersion",
        description = """Gets the appConfig data by the given appKey and app configVersion number.If the appKey is is invalid or appConfig is not found, it returns an invalid response. """,
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = ApplicationConfigResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/appconfig/getbyversion"
        value = [PATH_GET_APPLICATION_CONFIG_BY_CONFIG_VERSION],
        produces = ["*/*"]
    )
    fun getApplicationConfigByConfigVersion(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The application key", required = true) @Valid @RequestParam(value = "appKey", required = true) appKey: kotlin.String,
        @NotNull @Parameter(description = "The version of the application configuration", required = true) @Valid @RequestParam(value = "configVersion", required = true) configVersion: kotlin.String,
        @Parameter(description = "Only returns the config that matches the given retailer") @Valid @RequestParam(value = "retailerId", required = false) retailerId: kotlin.Long?,
        @Parameter(description = "Only returns the config that matches the given retailer location") @Valid @RequestParam(value = "retailerLocationId", required = false) retailerLocationId: kotlin.Long?,
        @Parameter(description = "Only returns only returns the config that matches the given device udid") @Valid @RequestParam(value = "udid", required = false) udid: kotlin.String?,
        @Parameter(description = "Determines whether to return older config versions if the exact version is not found. If this happens, will try to return the latest version.", schema = Schema(defaultValue = "false")) @Valid @RequestParam(value = "allowOlderVersions", required = false, defaultValue = "false") allowOlderVersions: kotlin.Boolean
    ): ResponseEntity<ApplicationConfigResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get Ad Placement",
        operationId = "getApplicationPlacement",
        description = """Get details of an ad placement""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = PlacementResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/application/placement/get"
        value = [PATH_GET_APPLICATION_PLACEMENT],
        produces = ["*/*"]
    )
    fun getApplicationPlacement(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The id of the placement", required = true) @Valid @RequestParam(value = "placementId", required = true) placementId: kotlin.Long,
        @Parameter(description = "The unique id of the device making the request (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "The account id of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?
    ): ResponseEntity<PlacementResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get API versions",
        operationId = "getApplicationVersions",
        description = """Will return a comma separated list of numbers, newest first. For example: 3.0, 2.2, 2.1, 1.8""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/application/versions"
        value = [PATH_GET_APPLICATION_VERSIONS],
        produces = ["*/*"]
    )
    fun getApplicationVersions(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get Asset",
        operationId = "getAsset",
        description = """Gets the full asset response including attached likes and notes.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = AssetFullResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/asset/get"
        value = [PATH_GET_ASSET],
        produces = ["*/*"]
    )
    fun getAsset(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the asset ID", required = true) @Valid @RequestParam(value = "assetId", required = true) assetId: kotlin.Long,
        @Parameter(description = "a unique ID given by the device (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "the account ID of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "determines whether the notes on the asset are in descending order", schema = Schema(defaultValue = "false")) @Valid @RequestParam(value = "noteDescending", required = false, defaultValue = "false") noteDescending: kotlin.Boolean
    ): ResponseEntity<AssetFullResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get Audience",
        operationId = "getAudience",
        description = """Get an audience. The audience and account must be valid and have the appropriate permissions to view the content.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = AudienceResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/audience/get"
        value = [PATH_GET_AUDIENCE],
        produces = ["*/*"]
    )
    fun getAudience(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The logged in user.", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "The id of the audience to return.", required = true) @Valid @RequestParam(value = "audienceId", required = true) audienceId: kotlin.Long,
        @Parameter(description = "The application key (optional). If provided, results may be scoped to this application.") @Valid @RequestParam(value = "appKey", required = false) appKey: kotlin.String?,
        @Parameter(description = "(boolean) set to true to include the accountCount associated with current audience of the current app", schema = Schema(defaultValue = "false")) @Valid @RequestParam(value = "returnAccountCount", required = false, defaultValue = "false") returnAccountCount: kotlin.Boolean,
        @Parameter(description = "(boolean) set to true to include the albumCount associated with current audience of the current app", schema = Schema(defaultValue = "false")) @Valid @RequestParam(value = "returnAlbumCount", required = false, defaultValue = "false") returnAlbumCount: kotlin.Boolean,
        @Parameter(description = "(String) comma separated list, return an array with each item is the count of each album type. If not provided, \"all_types\" count is returned.") @Valid @RequestParam(value = "albumTypesForCount", required = false) albumTypesForCount: kotlin.String?
    ): ResponseEntity<AudienceResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Search Audiences",
        operationId = "getAudienceList",
        description = """Get the list audiences owned by the account""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(array = ArraySchema(schema = Schema(implementation = SearchResponse::class)))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/audience/search"
        value = [PATH_GET_AUDIENCE_LIST],
        produces = ["*/*"]
    )
    fun getAudienceList(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "The logged in user.") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "Comma separated list of album IDs to filter results with") @Valid @RequestParam(value = "albumIds", required = false) albumIds: kotlin.String?,
        @Parameter(description = "The keyword used to search") @Valid @RequestParam(value = "keyword", required = false) keyword: kotlin.String?,
        @Parameter(description = "Comma separated list of fields that the keywords will match against. Possible values include: SEARCH_TAGS, NAME, DESCRIPTION, OWNER_DISPLAY", schema = Schema(defaultValue = "SEARCH_TAGS,NAME,DESCRIPTION")) @Valid @RequestParam(value = "keywordFields", required = false, defaultValue = "SEARCH_TAGS,NAME,DESCRIPTION") keywordFields: kotlin.String,
        @Parameter(description = "The field to sort by, possible values include: {ID, CREATED, UPDATED, DELETED, SEARCH_TAGS, ACTIVE, NAME, DESCRIPTION, OWNER_ID, OWNER_DISPLAY, GENDER}", schema = Schema(allowableValues = ["ID", "CREATED", "UPDATED", "DELETED", "SEARCH_TAGS", "ACTIVE", "NAME", "DESCRIPTION", "SEND_SUGGESTION", "OWNER_ID", "OWNER_DISPLAY", "GENDER"], defaultValue = "NAME")) @Valid @RequestParam(value = "sortField", required = false, defaultValue = "NAME") sortField: kotlin.String,
        @Parameter(description = "The order to return the results. Default is false, which will return the results in ascending order.", schema = Schema(defaultValue = "false")) @Valid @RequestParam(value = "descending", required = false, defaultValue = "false") descending: kotlin.Boolean,
        @Parameter(description = "The index into the record set to start with.", schema = Schema(defaultValue = "0")) @Valid @RequestParam(value = "start", required = false, defaultValue = "0") start: kotlin.Int,
        @Parameter(description = "The total number of record to return (there is a hard limit of 100).", schema = Schema(defaultValue = "20")) @Valid @RequestParam(value = "limit", required = false, defaultValue = "20") limit: kotlin.Int,
        @Parameter(description = "Filter results based on whether or not the audience is set to send suggestions") @Valid @RequestParam(value = "sendSuggestion", required = false) sendSuggestion: kotlin.Boolean?,
        @Parameter(description = "Determines whether to return only active results. Default is false.") @Valid @RequestParam(value = "activeOnly", required = false) activeOnly: kotlin.Boolean?,
        @Parameter(description = "Groups results by the audience groupingId (this does not work in conjunction with the following parameters: albumIds, audienceType, appKey, returnGlobal)") @Valid @RequestParam(value = "groupByGroupingId", required = false) groupByGroupingId: kotlin.Boolean?,
        @Parameter(description = "Filter results by application key") @Valid @RequestParam(value = "appKey", required = false) appKey: kotlin.String?,
        @Parameter(description = "If filtering by appKey, determines whether or not audiences that do not have an application set will also be returned as well") @Valid @RequestParam(value = "returnGlobal", required = false) returnGlobal: kotlin.Boolean?,
        @Parameter(description = "If true, match keyword exactly") @Valid @RequestParam(value = "exactKeyword", required = false) exactKeyword: kotlin.Boolean?,
        @Parameter(description = "(Deprecated) Filter results by audience type") @Valid @RequestParam(value = "audienceType", required = false) audienceType: kotlin.String?,
        @Parameter(description = "comma separated string with the different audience types you want to filter for") @Valid @RequestParam(value = "audienceTypes", required = false) audienceTypes: kotlin.String?,
        @Parameter(description = "(boolean) set to true to include the accountCount associated with current audience of the current app", schema = Schema(defaultValue = "false")) @Valid @RequestParam(value = "returnAccountCount", required = false, defaultValue = "false") returnAccountCount: kotlin.Boolean,
        @Parameter(description = "(boolean) set to true to include the albumCount associated with current audience of the current app", schema = Schema(defaultValue = "false")) @Valid @RequestParam(value = "returnAlbumCount", required = false, defaultValue = "false") returnAlbumCount: kotlin.Boolean,
        @Parameter(description = "(String) comma separated list, return an array with each item is the count of each album type. If not provided, \"all_types\" count is returned.") @Valid @RequestParam(value = "albumTypesForCount", required = false) albumTypesForCount: kotlin.String?
    ): ResponseEntity<List<SearchResponse>> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get Batch Analysis Results",
        operationId = "getBatch",
        description = """Gets the completed Video Batch results, if done, or an error or status update if not.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = OrsonAiBatchResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/orson/ai/batch/{requestId}"
        value = [PATH_GET_BATCH],
        produces = ["*/*"]
    )
    fun getBatch(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "Orson Request Id", required = true) @PathVariable("requestId") requestId: kotlin.String,
        @NotNull @Parameter(description = "Sirqul Account Id", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long
    ): ResponseEntity<OrsonAiBatchResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get Bid",
        operationId = "getBid",
        description = """Get the bid details of a biddable object""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = BidResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/bid/get"
        value = [PATH_GET_BID],
        produces = ["*/*"]
    )
    fun getBid(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The bid id", required = true) @Valid @RequestParam(value = "bidId", required = true) bidId: kotlin.Long,
        @Parameter(description = "The device id (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "The account id of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?
    ): ResponseEntity<BidResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get Billable",
        operationId = "getBillableEntity",
        description = """Used to determine the associated BillableEntity of an account""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = BillableEntityResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/billable/get"
        value = [PATH_GET_BILLABLE_ENTITY],
        produces = ["*/*"]
    )
    fun getBillableEntity(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "The unique device identifier that made the request (either deviceId or accountId must be used)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "The unique accountId that made the request (either deviceId or accountId must be used)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "Determines whether to include the retailer dash board counts into the response", schema = Schema(defaultValue = "false")) @Valid @RequestParam(value = "includeCounts", required = false, defaultValue = "false") includeCounts: kotlin.Boolean,
        @Parameter(description = "Whether to enable payments or not", schema = Schema(defaultValue = "true")) @Valid @RequestParam(value = "includePayments", required = false, defaultValue = "true") includePayments: kotlin.Boolean
    ): ResponseEntity<BillableEntityResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get Vatom Business Behaviors",
        operationId = "getBusinessBehaviors",
        description = """Gets the behaviors of a business.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation") ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/vatom/b/behaviors"
        value = [PATH_GET_BUSINESS_BEHAVIORS]
    )
    fun getBusinessBehaviors(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "Sirqul Account Id", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "Sirqul Application Key", required = true) @Valid @RequestParam(value = "appKey", required = true) appKey: kotlin.String,
        @Parameter(description = "Return raw response") @Valid @RequestParam(value = "returnRawResponse", required = false) returnRawResponse: kotlin.Boolean?
    ): ResponseEntity<Unit> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get the coins for a Business",
        operationId = "getBusinessCoinsBalance",
        description = """Get the coins for a Businesss.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation") ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/vatom/b/coins/get"
        value = [PATH_GET_BUSINESS_COINS_BALANCE]
    )
    fun getBusinessCoinsBalance(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "Sirqul Account Id", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "Sirqul Application Key", required = true) @Valid @RequestParam(value = "appKey", required = true) appKey: kotlin.String,
        @Parameter(description = "Return raw response") @Valid @RequestParam(value = "returnRawResponse", required = false) returnRawResponse: kotlin.Boolean?
    ): ResponseEntity<Unit> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get the user business ids",
        operationId = "getBusinessIds",
        description = """Get the business ids the logged in user has access to.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation") ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/vatom/me/businesses"
        value = [PATH_GET_BUSINESS_IDS]
    )
    fun getBusinessIds(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "Sirqul Account Id", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @Parameter(description = "Return raw response") @Valid @RequestParam(value = "returnRawResponse", required = false) returnRawResponse: kotlin.Boolean?
    ): ResponseEntity<Unit> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get Vatom Business Info",
        operationId = "getBusinessInfo",
        description = """Gets the business info tied to this account.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation") ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/vatom/b/get"
        value = [PATH_GET_BUSINESS_INFO]
    )
    fun getBusinessInfo(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "Sirqul Account Id", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "Sirqul Application Key", required = true) @Valid @RequestParam(value = "appKey", required = true) appKey: kotlin.String,
        @Parameter(description = "Vatom Parameters") @Valid @RequestParam(value = "vatomParameters", required = false) vatomParameters: kotlin.String?,
        @Parameter(description = "Return raw response") @Valid @RequestParam(value = "returnRawResponse", required = false) returnRawResponse: kotlin.Boolean?
    ): ResponseEntity<Unit> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get Vatom Business Users",
        operationId = "getBusinessUsers",
        description = """Gets the users of a business.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation") ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/vatom/b/users"
        value = [PATH_GET_BUSINESS_USERS]
    )
    fun getBusinessUsers(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "Sirqul Account Id", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "Sirqul Application Key", required = true) @Valid @RequestParam(value = "appKey", required = true) appKey: kotlin.String,
        @Parameter(description = "Return raw response") @Valid @RequestParam(value = "returnRawResponse", required = false) returnRawResponse: kotlin.Boolean?
    ): ResponseEntity<Unit> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get Campaign Group Entities",
        operationId = "getCampaignGroupEntities",
        description = """Get campaign group entities.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation") ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/vatom/b/campaign-groups/entities"
        value = [PATH_GET_CAMPAIGN_GROUP_ENTITIES]
    )
    fun getCampaignGroupEntities(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "Sirqul Account Id", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "Sirqul Application Key", required = true) @Valid @RequestParam(value = "appKey", required = true) appKey: kotlin.String,
        @NotNull @Parameter(description = "Vatom Campaign Id", required = true) @Valid @RequestParam(value = "vatomCampaignId", required = true) vatomCampaignId: kotlin.String,
        @Parameter(description = "Return raw response") @Valid @RequestParam(value = "returnRawResponse", required = false) returnRawResponse: kotlin.Boolean?
    ): ResponseEntity<Unit> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get Campaign Group Rules",
        operationId = "getCampaignGroupRules",
        description = """Get campaign group rules.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation") ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/vatom/b/campaign-groups/rules"
        value = [PATH_GET_CAMPAIGN_GROUP_RULES]
    )
    fun getCampaignGroupRules(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "Sirqul Account Id", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "Sirqul Application Key", required = true) @Valid @RequestParam(value = "appKey", required = true) appKey: kotlin.String,
        @NotNull @Parameter(description = "Vatom Campaign Id", required = true) @Valid @RequestParam(value = "vatomCampaignId", required = true) vatomCampaignId: kotlin.String,
        @Parameter(description = "Return raw response") @Valid @RequestParam(value = "returnRawResponse", required = false) returnRawResponse: kotlin.Boolean?
    ): ResponseEntity<Unit> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get Campaign Group Stats",
        operationId = "getCampaignGroupStats",
        description = """Get campaign group stats.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation") ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/vatom/b/campaign-groups/stats"
        value = [PATH_GET_CAMPAIGN_GROUP_STATS]
    )
    fun getCampaignGroupStats(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "Sirqul Account Id", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "Sirqul Application Key", required = true) @Valid @RequestParam(value = "appKey", required = true) appKey: kotlin.String,
        @NotNull @Parameter(description = "Vatom Campaign Id", required = true) @Valid @RequestParam(value = "vatomCampaignId", required = true) vatomCampaignId: kotlin.String,
        @Parameter(description = "Return raw response") @Valid @RequestParam(value = "returnRawResponse", required = false) returnRawResponse: kotlin.Boolean?
    ): ResponseEntity<Unit> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get Campaign Info",
        operationId = "getCampaignInfo",
        description = """Gets the info on a campaign.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation") ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/vatom/b/campaign-groups/get"
        value = [PATH_GET_CAMPAIGN_INFO]
    )
    fun getCampaignInfo(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "Sirqul Account Id", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "Sirqul Application Key", required = true) @Valid @RequestParam(value = "appKey", required = true) appKey: kotlin.String,
        @NotNull @Parameter(description = "Vatom Campaign Id", required = true) @Valid @RequestParam(value = "vatomCampaignId", required = true) vatomCampaignId: kotlin.String,
        @Parameter(description = "Return raw response") @Valid @RequestParam(value = "returnRawResponse", required = false) returnRawResponse: kotlin.Boolean?
    ): ResponseEntity<Unit> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get Cargo Type",
        operationId = "getCargoType",
        description = """Get an existing cargo type""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = CargoType::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/cargo/type/{cargoTypeId}"
        value = [PATH_GET_CARGO_TYPE],
        produces = ["*/*"]
    )
    fun getCargoType(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "the cargo type ID", required = true) @PathVariable("cargoTypeId") cargoTypeId: kotlin.Long
    ): ResponseEntity<CargoType> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get Category",
        operationId = "getCategory",
        description = """Get the details of a specific category. Recursively include all child categories and their children.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = CategoryTreeResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/category/get"
        value = [PATH_GET_CATEGORY],
        produces = ["*/*"]
    )
    fun getCategory(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the ID of the category", required = true) @Valid @RequestParam(value = "categoryId", required = true) categoryId: kotlin.Long,
        @Parameter(description = "Determines whether to return extra info about the category's \"Participant\" reference", schema = Schema(defaultValue = "true")) @Valid @RequestParam(value = "returnExternal", required = false, defaultValue = "true") returnExternal: kotlin.Boolean
    ): ResponseEntity<CategoryTreeResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get Sent Friend Requests",
        operationId = "getConnectionSentFriendRequests",
        description = """Gets the connection sent friend requests.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = ConnectionListResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/consumer/connection/getRequested"
        value = [PATH_GET_CONNECTION_SENT_FRIEND_REQUESTS],
        produces = ["*/*"]
    )
    fun getConnectionSentFriendRequests(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "the ID of the device") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "the id of the account") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?
    ): ResponseEntity<ConnectionListResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Search Connections",
        operationId = "getConnections",
        description = """Gets the connections.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = ConnectionListResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/consumer/connection/get"
        value = [PATH_GET_CONNECTIONS],
        produces = ["*/*"]
    )
    fun getConnections(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "whether to return nulls or not", required = true) @Valid @RequestParam(value = "returnNulls", required = true) returnNulls: kotlin.Boolean,
        @NotNull @Parameter(description = "a comma separated list of ConnectionApiMap. (NOTE on FOLLOWER vs FOLLOWING: FOLLOWER will get me a list of followers, FOLLOWING will get me a list of people I am following)", required = true) @Valid @RequestParam(value = "filter", required = true) filter: kotlin.String,
        @NotNull @Parameter(description = "sorts the response list by ConnectionApiMap", required = true) @Valid @RequestParam(value = "sortField", required = true) sortField: kotlin.String,
        @NotNull @Parameter(description = "sorts the response list by descending order if true", required = true) @Valid @RequestParam(value = "descending", required = true) descending: kotlin.Boolean,
        @NotNull @Parameter(description = "start index of the pagination", required = true) @Valid @RequestParam(value = "start", required = true) start: kotlin.Int,
        @NotNull @Parameter(description = "limit of the pagination", required = true) @Valid @RequestParam(value = "limit", required = true) limit: kotlin.Int,
        @Parameter(description = "the device id (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "the account id (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "optional parameter to search on other account's connections") @Valid @RequestParam(value = "connectionAccountId", required = false) connectionAccountId: kotlin.Long?,
        @Parameter(description = "This parameter is deprecated.") @Valid @RequestParam(value = "q", required = false) q: kotlin.String?,
        @Parameter(description = "an optional keyword to search on, this parameter is ignored if empty") @Valid @RequestParam(value = "keyword", required = false) keyword: kotlin.String?,
        @Parameter(description = "This parameter is deprecated.") @Valid @RequestParam(value = "_i", required = false) i: kotlin.Int?,
        @Parameter(description = "This parameter is deprecated.") @Valid @RequestParam(value = "_l", required = false) l: kotlin.Int?,
        @Parameter(description = "the current latitude of the user") @Valid @RequestParam(value = "latitude", required = false) latitude: kotlin.Double?,
        @Parameter(description = "the current longitude of the user") @Valid @RequestParam(value = "longitude", required = false) longitude: kotlin.Double?
    ): ResponseEntity<ConnectionListResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get Creative",
        operationId = "getCreative",
        description = """Get a creative""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = CreativeResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/creative/get"
        value = [PATH_GET_CREATIVE],
        produces = ["*/*"]
    )
    fun getCreative(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the id of the logged in user", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "the ID of the creative to get", required = true) @Valid @RequestParam(value = "creativeId", required = true) creativeId: kotlin.Long
    ): ResponseEntity<CreativeResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Search Creatives",
        operationId = "getCreativesByApplication",
        description = """Get a list of levels for an application, just those the account has permissions to view.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(array = ArraySchema(schema = Schema(implementation = CreativeResponse::class)))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/creative/search"
        value = [PATH_GET_CREATIVES_BY_APPLICATION],
        produces = ["*/*"]
    )
    fun getCreativesByApplication(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The logged in user.", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "the application key", required = true) @Valid @RequestParam(value = "appKey", required = true) appKey: kotlin.String,
        @NotNull @Parameter(description = "Start the result set at some index.", required = true) @Valid @RequestParam(value = "start", required = true) start: kotlin.Int,
        @NotNull @Parameter(description = "Limit the result to some number.", required = true) @Valid @RequestParam(value = "limit", required = true) limit: kotlin.Int,
        @Parameter(description = "Creatives contained in the provided mission.") @Valid @RequestParam(value = "missionId", required = false) missionId: kotlin.Long?,
        @Parameter(description = "Match the keyword to the owner name or level name.") @Valid @RequestParam(value = "keyword", required = false) keyword: kotlin.String?
    ): ResponseEntity<List<CreativeResponse>> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get Credential",
        operationId = "getCredential",
        description = """Gets the account information given a third party token.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = ProfileResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/thirdparty/credential/get"
        value = [PATH_GET_CREDENTIAL],
        produces = ["*/*"]
    )
    fun getCredential(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the access provider to authenticate against", required = true) @Valid @RequestParam(value = "networkUID", required = true) networkUID: kotlin.String,
        @NotNull @Parameter(description = "the application key", required = true) @Valid @RequestParam(value = "appKey", required = true) appKey: kotlin.String,
        @Parameter(description = "the unique account id of a specific account that will be bound to the third-party credentials") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "the unique id of the device making the request") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "the session id for the request") @Valid @RequestParam(value = "sessionId", required = false) sessionId: kotlin.String?,
        @Parameter(description = "the third-party credentials id from the response of the credential/create step") @Valid @RequestParam(value = "thirdPartyCredentialId", required = false) thirdPartyCredentialId: kotlin.Long?,
        @Parameter(description = "the access token to authenticate with") @Valid @RequestParam(value = "thirdPartyToken", required = false) thirdPartyToken: kotlin.String?,
        @Parameter(description = "the secret code to authenticate with (used for MFA)") @Valid @RequestParam(value = "thirdPartySecret", required = false) thirdPartySecret: kotlin.String?,
        @Parameter(description = "flag to force creation of a new account when no accountId is passed and user chooses not to use listed accounts", schema = Schema(defaultValue = "false")) @Valid @RequestParam(value = "createNewAccount", required = false, defaultValue = "false") createNewAccount: kotlin.Boolean,
        @Parameter(description = "this determines how much of the profile should be returned, see ProfileFilters") @Valid @RequestParam(value = "responseFilters", required = false) responseFilters: kotlin.String?,
        @Parameter(description = "the latitude of the user") @Valid @RequestParam(value = "latitude", required = false) latitude: kotlin.Double?,
        @Parameter(description = "the longitude of the user") @Valid @RequestParam(value = "longitude", required = false) longitude: kotlin.Double?,
        @Parameter(description = "audience ids to add to the account") @Valid @RequestParam(value = "audienceIdsToAdd", required = false) audienceIdsToAdd: kotlin.String?,
        @Parameter(description = "audience ids to remove from the account") @Valid @RequestParam(value = "audienceIdsToRemove", required = false) audienceIdsToRemove: kotlin.String?,
        @Parameter(description = "account id of the referrer (inviter-invitee relationship)") @Valid @RequestParam(value = "referralAccountId", required = false) referralAccountId: kotlin.Long?
    ): ResponseEntity<ProfileResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get Crypto Balances",
        operationId = "getCryptoBalance",
        description = """Get the cypto balance details for a user""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = PaymentTypesResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/billing/crypto/get"
        value = [PATH_GET_CRYPTO_BALANCE],
        produces = ["*/*"]
    )
    fun getCryptoBalance(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The account used to perform the the request", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @Parameter(description = "The account to retreive balances for") @Valid @RequestParam(value = "ownerAccountId", required = false) ownerAccountId: kotlin.Long?,
        @Parameter(description = "The payment method to return details on. If this is not set, then the user's default payment method will be returned.") @Valid @RequestParam(value = "paymentMethodId", required = false) paymentMethodId: kotlin.Long?
    ): ResponseEntity<PaymentTypesResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get Data",
        operationId = "getData",
        description = """Get a specific record from a specified object.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = ObjectStoreResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/object/data/{objectName}/{objectId}"
        value = [PATH_GET_DATA],
        produces = ["*/*"]
    )
    fun getData(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "The name of the object to search upon", required = true) @PathVariable("objectName") objectName: kotlin.String,
        @Parameter(description = "objectId The id of the record to return", required = true) @PathVariable("objectId") objectId: kotlin.String,
        @Parameter(description = "The account id of the logged in user") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "") @Valid @RequestParam(value = "include", required = false) include: kotlin.String?
    ): ResponseEntity<ObjectStoreResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get dependent list of an account",
        operationId = "getDependents",
        description = """Get the dependent list of an account""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/cargo/dependent/{accountId}"
        value = [PATH_GET_DEPENDENTS],
        produces = ["*/*"]
    )
    fun getDependents(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "the id of the parent account to get a list of dependents", required = true) @PathVariable("accountId") accountId: kotlin.Long
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get Devices",
        operationId = "getDevices",
        description = """Gets the list of available devices that can be selected by consumers and retailers.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(array = ArraySchema(schema = Schema(implementation = AudienceDeviceResponse::class)))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/audience/devices"
        value = [PATH_GET_DEVICES],
        produces = ["*/*"]
    )
    fun getDevices(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "If true return inactive record as well. default is false.", required = true) @Valid @RequestParam(value = "includeInactive", required = true) includeInactive: kotlin.Boolean
    ): ResponseEntity<List<AudienceDeviceResponse>> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get Disbursement",
        operationId = "getDisbursement",
        description = """Get Disbursement details""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = DisbursementResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/disbursement/get"
        value = [PATH_GET_DISBURSEMENT],
        produces = ["*/*"]
    )
    fun getDisbursement(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The logged in user.", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "the id of the disbursement", required = true) @Valid @RequestParam(value = "disbursementId", required = true) disbursementId: kotlin.Long
    ): ResponseEntity<DisbursementResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get Emotion Results",
        operationId = "getEmotion",
        description = """Checks the Emotion analysis and returns in progress, results, or error.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = OrsonAiEmotionsResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/orson/ai/emotion/{requestId}"
        value = [PATH_GET_EMOTION],
        produces = ["*/*"]
    )
    fun getEmotion(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "Orson Request Id", required = true) @PathVariable("requestId") requestId: kotlin.String,
        @NotNull @Parameter(description = "Sirqul Account Id", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long
    ): ResponseEntity<OrsonAiEmotionsResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get Employee",
        operationId = "getEmployee",
        description = """Get the account record for the account id provided.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = EmployeeResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/employee/get"
        value = [PATH_GET_EMPLOYEE],
        produces = ["*/*"]
    )
    fun getEmployee(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the id of logged in user", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "the id of the employee account to get", required = true) @Valid @RequestParam(value = "employeeAccountId", required = true) employeeAccountId: kotlin.Long,
        @Parameter(description = "Determines whether to return the application settings for the employee for a particular application") @Valid @RequestParam(value = "settingsAppKey", required = false) settingsAppKey: kotlin.String?
    ): ResponseEntity<EmployeeResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Check episode status",
        operationId = "getEpisodeStatus",
        description = """Gets a summary of the episode's status, including any renders.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = OrsonEpisodeResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/orson/stories/episodes/{episodeId}/status"
        value = [PATH_GET_EPISODE_STATUS],
        produces = ["*/*"]
    )
    fun getEpisodeStatus(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "Episode ID", required = true) @PathVariable("episodeId") episodeId: kotlin.Long,
        @NotNull @Parameter(description = "Sirqul Account Id", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long
    ): ResponseEntity<OrsonEpisodeResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get Event",
        operationId = "getEvent",
        description = """Get an event.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = OfferResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/event/get"
        value = [PATH_GET_EVENT],
        produces = ["*/*"]
    )
    fun getEvent(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the id of the logged in user", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "The id of the event to return", required = true) @Valid @RequestParam(value = "eventId", required = true) eventId: kotlin.Long
    ): ResponseEntity<OfferResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get Vatom Event Guest List",
        operationId = "getEventGuestList",
        description = """Gets the guest list of an event.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation") ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/vatom/b/events/guests/get"
        value = [PATH_GET_EVENT_GUEST_LIST]
    )
    fun getEventGuestList(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "Sirqul Account Id", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "Sirqul Application Key", required = true) @Valid @RequestParam(value = "appKey", required = true) appKey: kotlin.String,
        @NotNull @Parameter(description = "Vatom Event Id", required = true) @Valid @RequestParam(value = "vatomEventId", required = true) vatomEventId: kotlin.String,
        @Parameter(description = "Return raw response") @Valid @RequestParam(value = "returnRawResponse", required = false) returnRawResponse: kotlin.Boolean?
    ): ResponseEntity<Unit> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get Experiences",
        operationId = "getExperiences",
        description = """Gets the list of available experiences that can be selected by consumers and retailers.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/audience/experiences"
        value = [PATH_GET_EXPERIENCES],
        produces = ["*/*"]
    )
    fun getExperiences(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get Favorite",
        operationId = "getFavorite",
        description = """Retrieves a single favorited item.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = WrappedResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/favorite/get"
        value = [PATH_GET_FAVORITE],
        produces = ["*/*"]
    )
    fun getFavorite(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The ID of the favorite reference record", required = true) @Valid @RequestParam(value = "favoriteId", required = true) favoriteId: kotlin.Long,
        @Parameter(description = "The unique ID given by the device (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "The account ID of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "The current latitude of the user") @Valid @RequestParam(value = "latitude", required = false) latitude: kotlin.Double?,
        @Parameter(description = "The current longitude of the user") @Valid @RequestParam(value = "longitude", required = false) longitude: kotlin.Double?
    ): ResponseEntity<WrappedResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get Filter",
        operationId = "getFilter",
        description = """Get the details of a specific filter. Recursively include all child filters and their children.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = FilterTreeResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/filter/get"
        value = [PATH_GET_FILTER],
        produces = ["*/*"]
    )
    fun getFilter(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the id of the filter to get", required = true) @Valid @RequestParam(value = "filterId", required = true) filterId: kotlin.Long
    ): ResponseEntity<FilterTreeResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get Flag",
        operationId = "getFlag",
        description = """Gets the details on whether the user has flagged a particular flagable object.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = FlagResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/flag/get"
        value = [PATH_GET_FLAG],
        produces = ["*/*"]
    )
    fun getFlag(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The flagable object type {ACCOUNT, ALBUM, ALBUM_CONTEST, ASSET, GAME_LEVEL, THEME_DESCRIPTOR, NOTE, OFFER}", required = true) @Valid @RequestParam(value = "flagableType", required = true) flagableType: kotlin.String,
        @NotNull @Parameter(description = "The flagable object id", required = true) @Valid @RequestParam(value = "flagableId", required = true) flagableId: kotlin.Long,
        @Parameter(description = "The unique device identifier that made the request (either deviceId or accountId must be used)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "The unique accountId that made the request (either deviceId or accountId must be used)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "The current location of the user") @Valid @RequestParam(value = "latitude", required = false) latitude: kotlin.Double?,
        @Parameter(description = "The current location of the user") @Valid @RequestParam(value = "longitude", required = false) longitude: kotlin.Double?
    ): ResponseEntity<FlagResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get Flag Threshold",
        operationId = "getFlagThreshold",
        description = """Get the flag threshold value on an object type for a particular application.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = CountResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/flag/threshold/get"
        value = [PATH_GET_FLAG_THRESHOLD],
        produces = ["*/*"]
    )
    fun getFlagThreshold(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The flagable object type {ACCOUNT, ALBUM, ALBUM_CONTEST, ASSET, GAME_LEVEL, THEME_DESCRIPTOR, OFFER, NOTE}", required = true) @Valid @RequestParam(value = "itemBeingFlaggedType", required = true) itemBeingFlaggedType: kotlin.String,
        @NotNull @Parameter(description = "The application key", required = true) @Valid @RequestParam(value = "appKey", required = true) appKey: kotlin.String
    ): ResponseEntity<CountResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get a Game by id",
        operationId = "getGame",
        description = """Get a Game by id.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = GameResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/game/get"
        value = [PATH_GET_GAME],
        produces = ["*/*"]
    )
    fun getGame(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The logged in user.", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "the updating game's id.", required = true) @Valid @RequestParam(value = "gameId", required = true) gameId: kotlin.Long,
        @Parameter(description = "If true include the game level data, otherwise don't. default is false.") @Valid @RequestParam(value = "includeGameData", required = false) includeGameData: kotlin.Boolean?
    ): ResponseEntity<GameResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get Game Level",
        operationId = "getGameLevel",
        description = """Get a game level. The level and account must be valid and have the appropirate permissions to view the content.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = GameLevelResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/level/get"
        value = [PATH_GET_GAME_LEVEL],
        produces = ["*/*"]
    )
    fun getGameLevel(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The logged in user.", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "The id of the level to return.", required = true) @Valid @RequestParam(value = "levelId", required = true) levelId: kotlin.Long,
        @Parameter(description = "If true include the game level data, otherwise don't. default is false.") @Valid @RequestParam(value = "includeGameData", required = false) includeGameData: kotlin.Boolean?
    ): ResponseEntity<GameLevelResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Search Game Levels",
        operationId = "getGameLevelsByApplication",
        description = """Get a list of levels for an application, just those the account has permissions to view.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = GameLevelListResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/level/search"
        value = [PATH_GET_GAME_LEVELS_BY_APPLICATION],
        produces = ["*/*"]
    )
    fun getGameLevelsByApplication(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The logged in user.", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "the application key", required = true) @Valid @RequestParam(value = "appKey", required = true) appKey: kotlin.String,
        @Parameter(description = "Match the keyword to the owner name or level name.") @Valid @RequestParam(value = "keyword", required = false) keyword: kotlin.String?,
        @Parameter(description = "what field to sort on") @Valid @RequestParam(value = "sortField", required = false) sortField: kotlin.String?,
        @Parameter(description = "whether to return levels in ascending or descending order") @Valid @RequestParam(value = "descending", required = false) descending: kotlin.Boolean?,
        @Parameter(description = "Start the result set at some index.") @Valid @RequestParam(value = "start", required = false) start: kotlin.Int?,
        @Parameter(description = "Limit the result to some number.") @Valid @RequestParam(value = "limit", required = false) limit: kotlin.Int?,
        @Parameter(description = "The maximum version of the level to return.") @Valid @RequestParam(value = "appVersion", required = false) appVersion: kotlin.String?,
        @Parameter(description = "If true include the game level data, otherwise don't. default is false.") @Valid @RequestParam(value = "includeGameData", required = false) includeGameData: kotlin.Boolean?,
        @Parameter(description = "") @Valid @RequestParam(value = "filters", required = false) filters: kotlin.String?
    ): ResponseEntity<GameLevelListResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Search Game Level by Billable Entity",
        operationId = "getGameLevelsByBillableEntity",
        description = """Searches on game levels that the logged in user has access to. A user would have access if the creator of the game level is managed under the same BillableEntity.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = GameLevelResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/level/searchByBillableEntity"
        value = [PATH_GET_GAME_LEVELS_BY_BILLABLE_ENTITY],
        produces = ["*/*"]
    )
    fun getGameLevelsByBillableEntity(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The account id of the user", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @Parameter(description = "the application key") @Valid @RequestParam(value = "appKey", required = false) appKey: kotlin.String?,
        @Parameter(description = "The keyword used to search") @Valid @RequestParam(value = "keyword", required = false) keyword: kotlin.String?,
        @Parameter(description = "The column to sort the search on", schema = Schema(allowableValues = ["LEVEL_ACTIVE", "LEVEL_NAME", "LEVEL_DESCRIPTION", "LEVEL_CREATED", "LEVEL_UPDATED", "LEVEL_LIKES", "LEVEL_DISLIKES", "LEVEL_NOTES", "LEVEL_PLAYS", "LEVEL_DOWNLOADS", "LEVEL_QUITS", "LEVEL_COMPLETES", "LEVEL_VERSION", "LEVEL_MISSION_TYPE", "LEVEL_OWNER_DISPLAY", "GAME_OWNER_DISPLAY", "GAME_TITLE", "GAME_DESCRIPTION", "GAME_LIKES", "GAME_DISLIKES", "APP_NAME", "APP_SCORING_TYPE"])) @Valid @RequestParam(value = "sortField", required = false) sortField: kotlin.String?,
        @Parameter(description = "The order to return the search results") @Valid @RequestParam(value = "descending", required = false) descending: kotlin.Boolean?,
        @Parameter(description = "Return only active results") @Valid @RequestParam(value = "activeOnly", required = false) activeOnly: kotlin.Boolean?,
        @Parameter(description = "The record to begin the return set on") @Valid @RequestParam(value = "start", required = false) start: kotlin.Long?,
        @Parameter(description = "The number of records to return") @Valid @RequestParam(value = "limit", required = false) limit: kotlin.Long?
    ): ResponseEntity<GameLevelResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get Connection Group",
        operationId = "getGroupDetails",
        description = """""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = ConnectionGroupResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/consumer/connection/group/details/get"
        value = [PATH_GET_GROUP_DETAILS],
        produces = ["*/*"]
    )
    fun getGroupDetails(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "whether to combine connections or not", required = true) @Valid @RequestParam(value = "combineConnections", required = true) combineConnections: kotlin.Boolean,
        @Parameter(description = "the device id (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "the account id of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "the group id") @Valid @RequestParam(value = "groupId", required = false) groupId: kotlin.Long?,
        @Parameter(description = "the current latitude of the user") @Valid @RequestParam(value = "latitude", required = false) latitude: kotlin.Double?,
        @Parameter(description = "the current longitude of the user") @Valid @RequestParam(value = "longitude", required = false) longitude: kotlin.Double?
    ): ResponseEntity<ConnectionGroupResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get GroupedAudiences",
        operationId = "getGroupedAudiences",
        description = """Get a group of audiences. The audience and account must be valid and have the appropriate permissions to view the content.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = AudienceResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/audience/grouped/get"
        value = [PATH_GET_GROUPED_AUDIENCES],
        produces = ["*/*"]
    )
    fun getGroupedAudiences(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The logged in user.", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "The audience grouping id to return.", required = true) @Valid @RequestParam(value = "audienceGroupingId", required = true) audienceGroupingId: kotlin.String
    ): ResponseEntity<AudienceResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Search Historical Rankings",
        operationId = "getHistoricalRankings",
        description = """Get historical leaderboard rankings by time-frame.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = RankFullResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/ranking/historical/search"
        value = [PATH_GET_HISTORICAL_RANKINGS],
        produces = ["*/*"]
    )
    fun getHistoricalRankings(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the application key for filtering results by application", required = true) @Valid @RequestParam(value = "appKey", required = true) appKey: kotlin.String,
        @NotNull @Parameter(description = "the rank type to return", required = true) @Valid @RequestParam(value = "rankType", required = true) rankType: kotlin.String,
        @NotNull @Parameter(description = "timestamp in milliseconds to filter results with", required = true) @Valid @RequestParam(value = "startDate", required = true) startDate: kotlin.Long,
        @NotNull @Parameter(description = "timestamp in milliseconds to filter results with", required = true) @Valid @RequestParam(value = "endDate", required = true) endDate: kotlin.Long,
        @Parameter(description = "a unique id given by the device (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "the account id of the user") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "determines how to order and rank the results. Possible values include: TOTAL, MONTHLY, WEEKLY, DAILY, TOP, LOWEST", schema = Schema(defaultValue = "TOTAL")) @Valid @RequestParam(value = "sortField", required = false, defaultValue = "TOTAL") sortField: kotlin.String,
        @Parameter(description = "determines whether to return results in ascending or descending order", schema = Schema(defaultValue = "true")) @Valid @RequestParam(value = "descending", required = false, defaultValue = "true") descending: kotlin.Boolean,
        @Parameter(description = "the start index for pagination", schema = Schema(defaultValue = "0")) @Valid @RequestParam(value = "start", required = false, defaultValue = "0") start: kotlin.Int,
        @Parameter(description = "the limit for pagination", schema = Schema(defaultValue = "100")) @Valid @RequestParam(value = "limit", required = false, defaultValue = "100") limit: kotlin.Int
    ): ResponseEntity<RankFullResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get Vatom User's Inventory",
        operationId = "getInventory",
        description = """Gets the logged in user's Vatom Inventory.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation") ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/vatom/me/inventory"
        value = [PATH_GET_INVENTORY]
    )
    fun getInventory(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "Sirqul Account Id", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "Vatom Parameters", required = true) @Valid @RequestParam(value = "vatomParameters", required = true) vatomParameters: kotlin.String,
        @Parameter(description = "Return raw response") @Valid @RequestParam(value = "returnRawResponse", required = false) returnRawResponse: kotlin.Boolean?
    ): ResponseEntity<Unit> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get Invite",
        operationId = "getInvite",
        description = """This is used to determine whether an invite token is valid. If the token is valid, this will also return information about who invited the user, and what they are invited to.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/invite/get"
        value = [PATH_GET_INVITE],
        produces = ["*/*"]
    )
    fun getInvite(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "Account ID of the user if they are logged in") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "the invite token") @Valid @RequestParam(value = "token", required = false) token: kotlin.String?,
        @Parameter(description = "album id to match the invite against (if applicable)") @Valid @RequestParam(value = "albumId", required = false) albumId: kotlin.Long?,
        @Parameter(description = "mission id to match the invite against (if applicable)") @Valid @RequestParam(value = "missionId", required = false) missionId: kotlin.Long?,
        @Parameter(description = "album contest id to match the invite against (if applicable)") @Valid @RequestParam(value = "albumContestId", required = false) albumContestId: kotlin.Long?,
        @Parameter(description = "offer id to match the invite against (if applicable)") @Valid @RequestParam(value = "offerId", required = false) offerId: kotlin.Long?,
        @Parameter(description = "offer location id to match the invite against (if applicable)") @Valid @RequestParam(value = "offerLocationId", required = false) offerLocationId: kotlin.Long?,
        @Parameter(description = "retailer location id to match the invite against (if applicable)") @Valid @RequestParam(value = "retailerLocationId", required = false) retailerLocationId: kotlin.Long?,
        @Parameter(description = "the application key") @Valid @RequestParam(value = "appKey", required = false) appKey: kotlin.String?
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Read a leaderboard by id and retrieve the matching ranking list",
        operationId = "getLeaderboard",
        description = """Read a leaderboard by id and retrieve the matching ranking list""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = LeaderboardResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/leaderboard/get"
        value = [PATH_GET_LEADERBOARD],
        produces = ["*/*"]
    )
    fun getLeaderboard(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The leaderboard id.", required = true) @Valid @RequestParam(value = "leaderboardId", required = true) leaderboardId: kotlin.Long,
        @Parameter(description = "A valid account.") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "set to true if need to return the leaderboard's full ranking list") @Valid @RequestParam(value = "includeFullRankingList", required = false) includeFullRankingList: kotlin.Boolean?
    ): ResponseEntity<LeaderboardResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get Listing",
        operationId = "getListing",
        description = """Get a listing by id.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = ListingFullResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/listing/get"
        value = [PATH_GET_LISTING],
        produces = ["*/*"]
    )
    fun getListing(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the id of the listing to get", required = true) @Valid @RequestParam(value = "listingId", required = true) listingId: kotlin.Long
    ): ResponseEntity<ListingFullResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get Location by IP",
        operationId = "getLocationByIp",
        description = """Get location information based on an IP address.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = CoordsResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/location/ip"
        value = [PATH_GET_LOCATION_BY_IP],
        produces = ["*/*"]
    )
    fun getLocationByIp(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "the ip address of the client device") @Valid @RequestParam(value = "ip", required = false) ip: kotlin.String?
    ): ResponseEntity<CoordsResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get Location by Trilateration",
        operationId = "getLocationByTrilateration",
        description = """Send in device data and calculate a position based on signal strengths.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = GeoPointResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/account/location/trilaterate"
        value = [PATH_GET_LOCATION_BY_TRILATERATION],
        produces = ["*/*"]
    )
    fun getLocationByTrilateration(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "The account making the request, if provided the last know location will be updated") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "The known GPS latitude to compare to the calculated version") @Valid @RequestParam(value = "latitude", required = false) latitude: kotlin.Double?,
        @Parameter(description = "The known GPS longitude to compare to the calculated version") @Valid @RequestParam(value = "longitude", required = false) longitude: kotlin.Double?,
        @Parameter(description = "The json formated sample data:  ```json {    \"count\": 2,   \"timespan\": 10,    \"samples\": [     {       \"deviceId\": \"device1\",       \"rssi\": [-63, -75]     },      {       \"deviceId\": \"device2\",       \"rssi\": [-83, -79]     }   ] } ``` ") @Valid @RequestParam(value = "data", required = false) `data`: kotlin.String?,
        @Parameter(description = "Optional response filters (not used currently)") @Valid @RequestParam(value = "responseFilters", required = false) responseFilters: kotlin.String?
    ): ResponseEntity<GeoPointResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Search Regions or Postal Codes",
        operationId = "getLocations",
        description = """Searches geographic locations by proximity via address or keyword.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = LocationSearchResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/location/search"
        value = [PATH_GET_LOCATIONS],
        produces = ["*/*"]
    )
    fun getLocations(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "the device id") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "the account id") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "This parameter is deprecated.") @Valid @RequestParam(value = "currentlatitude", required = false) currentlatitude: kotlin.Double?,
        @Parameter(description = "This parameter is deprecated.") @Valid @RequestParam(value = "currentlongitude", required = false) currentlongitude: kotlin.Double?,
        @Parameter(description = "the current latitude of the user") @Valid @RequestParam(value = "currentLatitude", required = false) currentLatitude: kotlin.Double?,
        @Parameter(description = "the current longitude of the user") @Valid @RequestParam(value = "currentLongitude", required = false) currentLongitude: kotlin.Double?,
        @Parameter(description = "the query results by keyword or address") @Valid @RequestParam(value = "query", required = false) query: kotlin.String?,
        @Parameter(description = "This parameter is deprecated.") @Valid @RequestParam(value = "zipcode", required = false) zipcode: kotlin.String?,
        @Parameter(description = "the zip code to filter results") @Valid @RequestParam(value = "zipCode", required = false) zipCode: kotlin.String?,
        @Parameter(description = "This parameter is deprecated.") @Valid @RequestParam(value = "selectedMaplatitude", required = false) selectedMaplatitude: kotlin.Double?,
        @Parameter(description = "This parameter is deprecated.") @Valid @RequestParam(value = "selectedMaplongitude", required = false) selectedMaplongitude: kotlin.Double?,
        @Parameter(description = "the latitude of where the search should originate from") @Valid @RequestParam(value = "selectedMapLatitude", required = false) selectedMapLatitude: kotlin.Double?,
        @Parameter(description = "the longitude of where the search should originate from") @Valid @RequestParam(value = "selectedMapLongitude", required = false) selectedMapLongitude: kotlin.Double?,
        @Parameter(description = "the search range of the search in miles", schema = Schema(defaultValue = "5.0")) @Valid @RequestParam(value = "searchRange", required = false, defaultValue = "5.0") searchRange: kotlin.Double,
        @Parameter(description = "determines whether to allow searches via address", schema = Schema(defaultValue = "false")) @Valid @RequestParam(value = "useGeocode", required = false, defaultValue = "false") useGeocode: kotlin.Boolean,
        @Parameter(description = "This parameter is deprecated.") @Valid @RequestParam(value = "_i", required = false) i: kotlin.Int?,
        @Parameter(description = "the start index for pagination", schema = Schema(defaultValue = "0")) @Valid @RequestParam(value = "start", required = false, defaultValue = "0") start: kotlin.Int,
        @Parameter(description = "This parameter is deprecated.") @Valid @RequestParam(value = "_l", required = false) l: kotlin.Int?,
        @Parameter(description = "the limit for pagination", schema = Schema(defaultValue = "20")) @Valid @RequestParam(value = "limit", required = false, defaultValue = "20") limit: kotlin.Int
    ): ResponseEntity<LocationSearchResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Media Get",
        operationId = "getMedia",
        description = """Get a media offering.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = MediaOfferResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/media/get"
        value = [PATH_GET_MEDIA],
        produces = ["*/*"]
    )
    fun getMedia(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the id of the logged in user", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "the id of the media to get", required = true) @Valid @RequestParam(value = "mediaId", required = true) mediaId: kotlin.Long
    ): ResponseEntity<MediaOfferResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get Mission",
        operationId = "getMission",
        description = """Get a mission.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = MissionResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/mission/get"
        value = [PATH_GET_MISSION],
        produces = ["*/*"]
    )
    fun getMission(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The logged in user.", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "The id of the mission to return.", required = true) @Valid @RequestParam(value = "missionId", required = true) missionId: kotlin.Long,
        @Parameter(description = "Return creatives associated with the mission when true") @Valid @RequestParam(value = "returnCreative", required = false) returnCreative: kotlin.Boolean?
    ): ResponseEntity<MissionResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get Mission Invite",
        operationId = "getMissionInvite",
        description = """Get the mission invite. An account can only be invited to a mission one time.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = MissionResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/mission/invite/get"
        value = [PATH_GET_MISSION_INVITE],
        produces = ["*/*"]
    )
    fun getMissionInvite(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "the device id (deviceId or accountId required).") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "the account id of the user (deviceId or accountId required).") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "The mission to find the invite for (missionId or missionInviteId requried).") @Valid @RequestParam(value = "missionId", required = false) missionId: kotlin.Long?,
        @Parameter(description = "The mission invite id. This checks on the user's billable for permission (missionId or missionInviteId requried).") @Valid @RequestParam(value = "missionInviteId", required = false) missionInviteId: kotlin.Long?,
        @Parameter(description = "Include the game level data with the mission.") @Valid @RequestParam(value = "includeGameData", required = false) includeGameData: kotlin.Boolean?,
        @Parameter(description = "include the scores with the mission") @Valid @RequestParam(value = "includeScores", required = false) includeScores: kotlin.String?
    ): ResponseEntity<MissionResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get following",
        operationId = "getMyFollowing",
        description = """Get following.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation") ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/vatom/me/rels/following"
        value = [PATH_GET_MY_FOLLOWING]
    )
    fun getMyFollowing(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "Sirqul Account Id", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @Parameter(description = "Return raw response") @Valid @RequestParam(value = "returnRawResponse", required = false) returnRawResponse: kotlin.Boolean?
    ): ResponseEntity<Unit> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get Network",
        operationId = "getNetwork",
        description = """Get the details of a third party network. Only the network owners and managers have access to this.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = ThirdPartyNetworkResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/thirdparty/network/get"
        value = [PATH_GET_NETWORK],
        produces = ["*/*"]
    )
    fun getNetwork(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The account id making the request", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "The unique identifier for the third party network defined by Sirqul", required = true) @Valid @RequestParam(value = "networkUID", required = true) networkUID: kotlin.String
    ): ResponseEntity<ThirdPartyNetworkResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get Note",
        operationId = "getNote",
        description = """Get for a note based on its Id.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/note/get"
        value = [PATH_GET_NOTE],
        produces = ["*/*"]
    )
    fun getNote(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the id of the note to get", required = true) @Valid @RequestParam(value = "noteId", required = true) noteId: kotlin.Long,
        @Parameter(description = "The unique device identifier that made the request (either deviceId or accountId must be used)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "The unique accountId that made the request (either deviceId or accountId must be used)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "Determines whether to return the NoteFullResponse for the item") @Valid @RequestParam(value = "returnFullResponse", required = false) returnFullResponse: kotlin.Boolean?
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get Notification Template",
        operationId = "getNotificationTemplate",
        description = """Get the details of a notification template. Developers will only be able to see notification templates for their own applications.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = NotificationTemplateResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/notification/template/get"
        value = [PATH_GET_NOTIFICATION_TEMPLATE],
        produces = ["*/*"]
    )
    fun getNotificationTemplate(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the id of the account", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "the id of the notification template to get", required = true) @Valid @RequestParam(value = "notificationTemplateId", required = true) notificationTemplateId: kotlin.Long
    ): ResponseEntity<NotificationTemplateResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get Notifications",
        operationId = "getNotifications",
        description = """Get a list of notifications for a user. If the "markAsRead" parameter is set to true, the returned notifications will be marked as "read" after the response has been sent. By default, read messages will not be returned, so to see read messages, set "returnReadMessages" to true.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = NotificationMessageListResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/notification/search"
        value = [PATH_GET_NOTIFICATIONS],
        produces = ["*/*"]
    )
    fun getNotifications(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "the unique id of the device making the request (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "the account id of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "the account id used to view another person's notifications") @Valid @RequestParam(value = "connectionAccountId", required = false) connectionAccountId: kotlin.Long?,
        @Parameter(description = "the application key to filter messages by application") @Valid @RequestParam(value = "appKey", required = false) appKey: kotlin.String?,
        @Parameter(description = "comma separated list of EVENTS. Filters search results to only include these events. Don't include this parameter or pass in an empty string to return all event types.") @Valid @RequestParam(value = "eventType", required = false) eventType: kotlin.String?,
        @Parameter(description = "comma separated list of content ids to search notifications on") @Valid @RequestParam(value = "contentIds", required = false) contentIds: kotlin.String?,
        @Parameter(description = "comma separated list of content types to search notifications on") @Valid @RequestParam(value = "contentTypes", required = false) contentTypes: kotlin.String?,
        @Parameter(description = "comma separated list of parent ids to search notifications on") @Valid @RequestParam(value = "parentIds", required = false) parentIds: kotlin.String?,
        @Parameter(description = "comma separated list of parent types to search notifications on") @Valid @RequestParam(value = "parentTypes", required = false) parentTypes: kotlin.String?,
        @Parameter(description = "Action category used to filter notifications") @Valid @RequestParam(value = "actionCategory", required = false) actionCategory: kotlin.String?,
        @Parameter(description = "comma separated list of conduits to search notifications on") @Valid @RequestParam(value = "conduits", required = false) conduits: kotlin.String?,
        @Parameter(description = "search notifications via keyword") @Valid @RequestParam(value = "keyword", required = false) keyword: kotlin.String?,
        @Parameter(description = "if set to true, will return notifications that have been marked as read") @Valid @RequestParam(value = "returnReadMessages", required = false) returnReadMessages: kotlin.Boolean?,
        @Parameter(description = "if set to true, the returned notifications will be marked as \\\"read\\\" after the response has been sent") @Valid @RequestParam(value = "markAsRead", required = false) markAsRead: kotlin.Boolean?,
        @Parameter(description = "filter notifications from this date") @Valid @RequestParam(value = "fromDate", required = false) fromDate: kotlin.Long?,
        @Parameter(description = "latitude used to update the user's current location") @Valid @RequestParam(value = "latitude", required = false) latitude: kotlin.Double?,
        @Parameter(description = "longitude used to update the user's current location") @Valid @RequestParam(value = "longitude", required = false) longitude: kotlin.Double?,
        @Parameter(description = "whether to include notifications sent by the requester in the response") @Valid @RequestParam(value = "returnSent", required = false) returnSent: kotlin.Boolean?,
        @Parameter(description = "whether to ignore flagged notifications") @Valid @RequestParam(value = "ignoreFlagged", required = false) ignoreFlagged: kotlin.Boolean?,
        @Parameter(description = "start of the pagination") @Valid @RequestParam(value = "start", required = false) start: kotlin.Int?,
        @Parameter(description = "limit of the pagination") @Valid @RequestParam(value = "limit", required = false) limit: kotlin.Int?
    ): ResponseEntity<NotificationMessageListResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get Object",
        operationId = "getObject",
        description = """Get the definition of an Object. Returns all field names, types, and current size. The types supported are: STRING, DATE, NUMBER, BOOLEAN, IDENTITY.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = ObjectStoreResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/object/get"
        value = [PATH_GET_OBJECT],
        produces = ["*/*"]
    )
    fun getObject(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The account id of the logged in user", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "The application key for updating an existing application", required = true) @Valid @RequestParam(value = "appKey", required = true) appKey: kotlin.String,
        @NotNull @Parameter(description = "The name of the object to get the definition for", required = true) @Valid @RequestParam(value = "objectName", required = true) objectName: kotlin.String
    ): ResponseEntity<ObjectStoreResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get Offer",
        operationId = "getOffer",
        description = """Gets the details of an offer that the user has access to.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = RetailerOfferResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/retailer/offer/get"
        value = [PATH_GET_OFFER],
        produces = ["*/*"]
    )
    fun getOffer(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The id of the offer", required = true) @Valid @RequestParam(value = "offerId", required = true) offerId: kotlin.Long,
        @NotNull @Parameter(description = "", required = true) @Valid @RequestParam(value = "includeOfferLocations", required = true) includeOfferLocations: kotlin.Boolean,
        @Parameter(description = "The device id (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "The account id (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?
    ): ResponseEntity<RetailerOfferResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get Offer",
        operationId = "getOfferDetails",
        description = """Gets offer or offer location details as a consumer.  Will check if it is a favorite if the deviceId/accountId is provided.  If the offerId is provided it will look up the main offer and ignore the the offerLocationId. If no offerId is provided then an offerLocationId must be specified.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = OfferResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/offer/get"
        value = [PATH_GET_OFFER_DETAILS],
        produces = ["*/*"]
    )
    fun getOfferDetails(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "The device id for returning account information (i.e. favorites)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "The account id for returning account information (i.e. favorites)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "The offer id (either offeLocationId or offerId must be provided)") @Valid @RequestParam(value = "offerId", required = false) offerId: kotlin.Long?,
        @Parameter(description = "The offer location id (either offeLocationId or offerId must be provided)") @Valid @RequestParam(value = "offerLocationId", required = false) offerLocationId: kotlin.Long?,
        @Parameter(description = "The distance of the offer from the user's current location (this is returned when the offer is searched)") @Valid @RequestParam(value = "distance", required = false) distance: kotlin.Double?,
        @Parameter(description = "The latitude to calculate distance from the offer") @Valid @RequestParam(value = "latitude", required = false) latitude: kotlin.Double?,
        @Parameter(description = "The longitude to calculate distance from the offer") @Valid @RequestParam(value = "longitude", required = false) longitude: kotlin.Double?,
        @Parameter(description = "Determines whether to return offer locations for the offer", schema = Schema(defaultValue = "false")) @Valid @RequestParam(value = "includeOfferLocations", required = false, defaultValue = "false") includeOfferLocations: kotlin.Boolean,
        @Parameter(description = "Determines whether to return the retailer location info for each offer location response (includeOfferLocations must also be true for this to work)", schema = Schema(defaultValue = "false")) @Valid @RequestParam(value = "includeRetailerLocations", required = false, defaultValue = "false") includeRetailerLocations: kotlin.Boolean,
        @Parameter(description = "Determines whether to include child offers in the response", schema = Schema(defaultValue = "false")) @Valid @RequestParam(value = "includeChildOffers", required = false, defaultValue = "false") includeChildOffers: kotlin.Boolean
    ): ResponseEntity<OfferResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get Offers (Counts)",
        operationId = "getOfferListCounts",
        description = """Gets the offer list counts.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = ListCountResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/offer/lists/count"
        value = [PATH_GET_OFFER_LIST_COUNTS],
        produces = ["*/*"]
    )
    fun getOfferListCounts(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The latitude of where the search will center at", required = true) @Valid @RequestParam(value = "latitude", required = true) latitude: kotlin.Double,
        @NotNull @Parameter(description = "The longitude of where the search will center at", required = true) @Valid @RequestParam(value = "longitude", required = true) longitude: kotlin.Double,
        @Parameter(description = "The range of the search", schema = Schema(defaultValue = "5")) @Valid @RequestParam(value = "searchRange", required = false, defaultValue = "5") searchRange: java.math.BigDecimal,
        @Parameter(description = "The units to use for distance calculations (e.g. MILES, KILOMETERS)", schema = Schema(allowableValues = ["MILES", "KILOMETERS"], defaultValue = "MILES")) @Valid @RequestParam(value = "distanceUnit", required = false, defaultValue = "MILES") distanceUnit: kotlin.String
    ): ResponseEntity<ListCountResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get Offer Location",
        operationId = "getOfferLocation",
        description = """Gets the offer location by offer location id or udid (of a device)""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = OfferShortResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/offer/location/get"
        value = [PATH_GET_OFFER_LOCATION],
        produces = ["*/*"]
    )
    fun getOfferLocation(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "the id of the offer location to get") @Valid @RequestParam(value = "offerLocationId", required = false) offerLocationId: kotlin.Long?,
        @Parameter(description = "the UDID of the device") @Valid @RequestParam(value = "udid", required = false) udid: kotlin.String?
    ): ResponseEntity<OfferShortResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Search Offer Locations",
        operationId = "getOfferLocationsForRetailers",
        description = """Searches on offer locations, which are records that represent an offer that has been assigned to a retailer location. If an offer does not have any locations assigned, then it will NOT be returned.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(array = ArraySchema(schema = Schema(implementation = OfferShortResponse::class)))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/retailer/offer/location/search"
        value = [PATH_GET_OFFER_LOCATIONS_FOR_RETAILERS],
        produces = ["*/*"]
    )
    fun getOfferLocationsForRetailers(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The column to sort the results on. Default is \"TITLE\", which will sort the results by the offer title. Possible input values: {CREATED, UPDATED, ACTIVE, ACTIVATED, EXPIRES, TITLE, SUBTITLE, DETAILS, OFFER_TYPE, RETAILER_ID,RETAILER_LOCATION_ID, BILLABLE_ENTITY_NAME, RESPONSIBLE_DISPLAY}", required = true, schema = Schema(allowableValues = ["ID", "CREATED", "UPDATED", "DELETED", "SEARCH_TAGS", "ACTIVE", "OFFER_ID", "ACTIVATED", "EXPIRES", "TITLE", "SUBTITLE", "DETAILS", "OFFER_TYPE", "SPECIAL_OFFER_TYPE", "OFFER_VISIBILITY", "RETAILER_ID", "RETAILER_LOCATION_ID", "BILLABLE_ENTITY_ID", "BILLABLE_ENTITY_NAME", "RESPONSIBLE_DISPLAY"])) @Valid @RequestParam(value = "sortField", required = true) sortField: kotlin.String,
        @NotNull @Parameter(description = "The order to return the results. Default is false, which will return the results in ascending order.", required = true) @Valid @RequestParam(value = "descending", required = true) descending: kotlin.Boolean,
        @NotNull @Parameter(description = "The index into the record set to start with. Default is 0.", required = true) @Valid @RequestParam(value = "start", required = true) start: kotlin.Int,
        @NotNull @Parameter(description = "The total number of records to return. Default is 20.", required = true) @Valid @RequestParam(value = "limit", required = true) limit: kotlin.Int,
        @NotNull @Parameter(description = "Determines whether to return only active results. Default is false.", required = true) @Valid @RequestParam(value = "activeOnly", required = true) activeOnly: kotlin.Boolean,
        @NotNull @Parameter(description = "", required = true) @Valid @RequestParam(value = "includeRetailerLocation", required = true) includeRetailerLocation: kotlin.Boolean,
        @Parameter(description = "The device id (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "The account id of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "The keyword used to search") @Valid @RequestParam(value = "keyword", required = false) keyword: kotlin.String?,
        @Parameter(description = "Filter results for a specific retailer") @Valid @RequestParam(value = "retailerId", required = false) retailerId: kotlin.Long?,
        @Parameter(description = "Filter results for a specific retailer location") @Valid @RequestParam(value = "retailerLocationId", required = false) retailerLocationId: kotlin.Long?,
        @Parameter(description = "Filter results to only return COUPON, VOUCHER, PRODUCT, MEDIA, or EVENT offers", schema = Schema(allowableValues = ["VOUCHER", "COUPON", "PRODUCT", "MEDIA", "EVENT", "DEVICE"])) @Valid @RequestParam(value = "offerType", required = false) offerType: kotlin.String?,
        @Parameter(description = "Filter results to only return REGULAR_OFFER, ACT_NOW, GET_THERE_NOW offer specials", schema = Schema(allowableValues = ["ALL", "RESERVABLE", "REGULAR_OFFER", "ACT_NOW", "GET_THERE_NOW", "SQOOT", "TICKETS", "YIPIT"])) @Valid @RequestParam(value = "specialOfferType", required = false) specialOfferType: kotlin.String?,
        @Parameter(description = "") @Valid @RequestParam(value = "barcodeType", required = false) barcodeType: kotlin.String?,
        @Parameter(description = "") @Valid @RequestParam(value = "barcodeEntry", required = false) barcodeEntry: kotlin.String?,
        @Parameter(description = "") @Valid @RequestParam(value = "isbn", required = false) isbn: kotlin.String?,
        @Parameter(description = "") @Valid @RequestParam(value = "asin", required = false) asin: kotlin.String?,
        @Parameter(description = "Edysen device status, running, warning, or down", schema = Schema(allowableValues = ["RUNNING", "WARNING", "DOWN"])) @Valid @RequestParam(value = "deviceStatus", required = false) deviceStatus: kotlin.String?,
        @Parameter(description = "") @Valid @RequestParam(value = "needsNotificationSent", required = false) needsNotificationSent: kotlin.Boolean?,
        @Parameter(description = "") @Valid @RequestParam(value = "lastNotificationSent", required = false) lastNotificationSent: kotlin.Long?
    ): ResponseEntity<List<OfferShortResponse>> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get Wallet Offer",
        operationId = "getOfferTransaction",
        description = """""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = OfferTransactionResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/wallet/get"
        value = [PATH_GET_OFFER_TRANSACTION],
        produces = ["*/*"]
    )
    fun getOfferTransaction(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The offer transaction id to get details of", required = true) @Valid @RequestParam(value = "transactionId", required = true) transactionId: kotlin.Long,
        @Parameter(description = "The device id (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "The account id of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "If true then include mission data, false to not include", schema = Schema(defaultValue = "false")) @Valid @RequestParam(value = "includeMission", required = false, defaultValue = "false") includeMission: kotlin.Boolean,
        @Parameter(description = "The latitude location of the user") @Valid @RequestParam(value = "latitude", required = false) latitude: kotlin.Double?,
        @Parameter(description = "The latitude location of the user") @Valid @RequestParam(value = "longitude", required = false) longitude: kotlin.Double?,
        @Parameter(description = "Determines whether to return a detailed version of the response", schema = Schema(defaultValue = "true")) @Valid @RequestParam(value = "returnFullResponse", required = false, defaultValue = "true") returnFullResponse: kotlin.Boolean
    ): ResponseEntity<OfferTransactionResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get Offer Status",
        operationId = "getOfferTransactionStatus",
        description = """Get an offer status record""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = OfferTransactionStatusResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/offer/status/get"
        value = [PATH_GET_OFFER_TRANSACTION_STATUS],
        produces = ["*/*"]
    )
    fun getOfferTransactionStatus(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The id of the record to get ", required = true) @Valid @RequestParam(value = "statusId", required = true) statusId: kotlin.Long,
        @Parameter(description = "The device id (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "The account id of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "Used to update the user's current location") @Valid @RequestParam(value = "latitude", required = false) latitude: kotlin.Double?,
        @Parameter(description = "Used to update the user's current location") @Valid @RequestParam(value = "longitude", required = false) longitude: kotlin.Double?
    ): ResponseEntity<OfferTransactionStatusResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Search Offers",
        operationId = "getOffersForRetailers",
        description = """Searches on offers that the account has access to.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(array = ArraySchema(schema = Schema(implementation = OfferResponse::class)))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/retailer/offer/search"
        value = [PATH_GET_OFFERS_FOR_RETAILERS],
        produces = ["*/*"]
    )
    fun getOffersForRetailers(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "", required = true, schema = Schema(allowableValues = ["PUBLIC", "LISTABLE", "REWARDABLE", "TRIGGERABLE", "PRIVATE"])) @Valid @RequestParam(value = "offerVisibility", required = true) offerVisibility: kotlin.String,
        @NotNull @Parameter(description = "The column to sort the search on. Possible values include: ID, CREATED, UPDATED, ACTIVE, ACTIVATED, EXPIRES, TITLE, SUBTITLE, DETAILS, OFFER_TYPE, SPECIAL_OFFER_TYPE, OFFER_VISIBILITY, ESTIMATED_VALUE, VOUCHER_PRICE, RETAILER_ID, RETAILER_NAME, RETAILER_LOCATION_ID, RETAILER_LOCATION_NAME, BILLABLE_ENTITY_ID, BILLABLE_ENTITY_NAME, RESPONSIBLE_DISPLAY", required = true, schema = Schema(allowableValues = ["ID", "CREATED", "UPDATED", "DELETED", "SEARCH_TAGS", "ACTIVE", "ACTIVATED", "EXPIRES", "REDEEMABLE_START", "REDEEMABLE_END", "TITLE", "SUBTITLE", "DETAILS", "OFFER_TYPE", "SPECIAL_OFFER_TYPE", "OFFER_VISIBILITY", "ESTIMATED_VALUE", "VOUCHER_PRICE", "VOUCHER_DISCOUNT_PRICE", "FULL_PRICE", "DICOUNT_PRICE", "TICKETS_REWARD", "AVAILABILITY_DATE", "RELEASE_DATE", "RETAILER_ID", "RETAILER_NAME", "RETAILER_LOCATION_ID", "RETAILER_LOCATION_NAME", "BILLABLE_ENTITY_ID", "BILLABLE_ENTITY_NAME", "RESPONSIBLE_DISPLAY"])) @Valid @RequestParam(value = "sortField", required = true) sortField: kotlin.String,
        @NotNull @Parameter(description = "The order to return the search results", required = true) @Valid @RequestParam(value = "descending", required = true) descending: kotlin.Boolean,
        @NotNull @Parameter(description = "The record to begin the return set on", required = true) @Valid @RequestParam(value = "start", required = true) start: kotlin.Int,
        @NotNull @Parameter(description = "The number of records to return", required = true) @Valid @RequestParam(value = "limit", required = true) limit: kotlin.Int,
        @NotNull @Parameter(description = "Return only results that are currently being promoted (is activated and not expired)", required = true) @Valid @RequestParam(value = "availableOnly", required = true) availableOnly: kotlin.Boolean,
        @NotNull @Parameter(description = "Return only active results", required = true) @Valid @RequestParam(value = "activeOnly", required = true) activeOnly: kotlin.Boolean,
        @NotNull @Parameter(description = "", required = true) @Valid @RequestParam(value = "includeCategories", required = true) includeCategories: kotlin.Boolean,
        @NotNull @Parameter(description = "", required = true) @Valid @RequestParam(value = "includeFilters", required = true) includeFilters: kotlin.Boolean,
        @NotNull @Parameter(description = "", required = true) @Valid @RequestParam(value = "includeOfferLocations", required = true) includeOfferLocations: kotlin.Boolean,
        @Parameter(description = "The device id (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "The account id of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "") @Valid @RequestParam(value = "categoryIds", required = false) categoryIds: kotlin.String?,
        @Parameter(description = "") @Valid @RequestParam(value = "filterIds", required = false) filterIds: kotlin.String?,
        @Parameter(description = "This parameter is deprecated.") @Valid @RequestParam(value = "q", required = false) q: kotlin.String?,
        @Parameter(description = "The keyword used to search") @Valid @RequestParam(value = "keyword", required = false) keyword: kotlin.String?,
        @Parameter(description = "the id of the retailer") @Valid @RequestParam(value = "retailerId", required = false) retailerId: kotlin.Long?,
        @Parameter(description = "the id of the retailer location") @Valid @RequestParam(value = "retailerLocationId", required = false) retailerLocationId: kotlin.Long?,
        @Parameter(description = "This parameter is deprecated.", schema = Schema(allowableValues = ["VOUCHER", "COUPON", "PRODUCT", "MEDIA", "EVENT", "DEVICE"])) @Valid @RequestParam(value = "couponType", required = false) couponType: kotlin.String?,
        @Parameter(description = "This parameter is deprecated. Use offer types. Filter results to only return COUPON, VOUCHER, PRODUCT, MEDIA, or EVENT offers", schema = Schema(allowableValues = ["VOUCHER", "COUPON", "PRODUCT", "MEDIA", "EVENT", "DEVICE"])) @Valid @RequestParam(value = "offerType", required = false) offerType: kotlin.String?,
        @Parameter(description = "Comma separated list of offer types {COUPON, VOUCHER, PRODUCT, MEDIA, EVENT, DEVICE}") @Valid @RequestParam(value = "offerTypes", required = false) offerTypes: kotlin.String?,
        @Parameter(description = "Filter results to only return REGULAR_OFFER, ACT_NOW, GET_THERE_NOW offer specials", schema = Schema(allowableValues = ["ALL", "RESERVABLE", "REGULAR_OFFER", "ACT_NOW", "GET_THERE_NOW", "SQOOT", "TICKETS", "YIPIT"])) @Valid @RequestParam(value = "specialOfferType", required = false) specialOfferType: kotlin.String?,
        @Parameter(description = "This parameter is deprecated.") @Valid @RequestParam(value = "_i", required = false) i: kotlin.Int?,
        @Parameter(description = "This parameter is deprecated.") @Valid @RequestParam(value = "_l", required = false) l: kotlin.Int?,
        @Parameter(description = "") @Valid @RequestParam(value = "barcodeType", required = false) barcodeType: kotlin.String?,
        @Parameter(description = "") @Valid @RequestParam(value = "barcodeEntry", required = false) barcodeEntry: kotlin.String?,
        @Parameter(description = "") @Valid @RequestParam(value = "isbn", required = false) isbn: kotlin.String?,
        @Parameter(description = "") @Valid @RequestParam(value = "asin", required = false) asin: kotlin.String?,
        @Parameter(description = "Edysen device status", schema = Schema(allowableValues = ["RUNNING", "WARNING", "DOWN"])) @Valid @RequestParam(value = "deviceStatus", required = false) deviceStatus: kotlin.String?,
        @Parameter(description = "") @Valid @RequestParam(value = "needsNotificationSent", required = false) needsNotificationSent: kotlin.Boolean?,
        @Parameter(description = "") @Valid @RequestParam(value = "lastNotificationSent", required = false) lastNotificationSent: kotlin.Long?
    ): ResponseEntity<List<OfferResponse>> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get Optimization Result",
        operationId = "getOptimizationResult",
        description = """Get the results of the import batch.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = ShipmentOrder::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/optimize/result/{batchID}"
        value = [PATH_GET_OPTIMIZATION_RESULT],
        produces = ["*/*"]
    )
    fun getOptimizationResult(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "The batchID for getting the import status of.", required = true) @PathVariable("batchID") batchID: kotlin.String,
        @NotNull @Parameter(description = "The start index for pagination", required = true) @Valid @RequestParam(value = "start", required = true) start: kotlin.Int,
        @NotNull @Parameter(description = "The limit for pagination", required = true) @Valid @RequestParam(value = "limit", required = true) limit: kotlin.Int
    ): ResponseEntity<Map<String, ShipmentOrder>> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get Order",
        operationId = "getOrder",
        description = """Get an order record""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = OrderResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/order/get"
        value = [PATH_GET_ORDER],
        produces = ["*/*"]
    )
    fun getOrder(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "The device id (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "The account id of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "The order id to get details of, either orderId or externalOrderId must be provided") @Valid @RequestParam(value = "orderId", required = false) orderId: kotlin.Long?,
        @Parameter(description = "The external order id to get details of, either orderId or externalOrderId must be provided") @Valid @RequestParam(value = "externalOrderId", required = false) externalOrderId: kotlin.String?
    ): ResponseEntity<OrderResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get Pack",
        operationId = "getPack",
        description = """Get a pack.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = PackResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/pack/get"
        value = [PATH_GET_PACK],
        produces = ["*/*"]
    )
    fun getPack(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The logged in user.", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "The id of the pack to return.", required = true) @Valid @RequestParam(value = "packId", required = true) packId: kotlin.Long,
        @NotNull @Parameter(description = "If true include the game level data, otherwise don't. default is false.", required = true) @Valid @RequestParam(value = "includeGameData", required = true) includeGameData: kotlin.Boolean
    ): ResponseEntity<PackResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get Payment Method",
        operationId = "getPaymentMethod",
        description = """Get the details of the user's payment method or their current default method of payment""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = PaymentTypesResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/billing/get"
        value = [PATH_GET_PAYMENT_METHOD],
        produces = ["*/*"]
    )
    fun getPaymentMethod(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The account used to perform the the request", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @Parameter(description = "The payment method to return details on. If this is not set, then the user's default payment method will be returned.") @Valid @RequestParam(value = "paymentMethodId", required = false) paymentMethodId: kotlin.Long?,
        @Parameter(description = "Determines whether to get the user's current balance for the requested payment method option (not all payment method options support this)") @Valid @RequestParam(value = "getCurrentBalance", required = false) getCurrentBalance: kotlin.Boolean?
    ): ResponseEntity<PaymentTypesResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get Persona",
        operationId = "getPersonaList",
        description = """Get the persona by the given persona ID. If the persona cannot be found, a invalid response is returned.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = PreviewPersonaResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/persona/get"
        value = [PATH_GET_PERSONA_LIST],
        produces = ["*/*"]
    )
    fun getPersonaList(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the account ID of the user", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "the persona ID of the persona", required = true) @Valid @RequestParam(value = "personaId", required = true) personaId: kotlin.Long
    ): ResponseEntity<PreviewPersonaResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get Points Balance",
        operationId = "getPointsBalance",
        description = """Gets the points balance of a Vatom user.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation") ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/vatom/u/campaign/points/get"
        value = [PATH_GET_POINTS_BALANCE]
    )
    fun getPointsBalance(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "Sirqul Account Id", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "Vatom User Id", required = true) @Valid @RequestParam(value = "vatomUserId", required = true) vatomUserId: kotlin.String,
        @NotNull @Parameter(description = "Vatom Campaign Id", required = true) @Valid @RequestParam(value = "vatomCampaignId", required = true) vatomCampaignId: kotlin.String,
        @Parameter(description = "Return raw response") @Valid @RequestParam(value = "returnRawResponse", required = false) returnRawResponse: kotlin.Boolean?
    ): ResponseEntity<Unit> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get Points Balance as Business",
        operationId = "getPointsBalanceAsBusiness",
        description = """Gets the points balance of a Vatom user.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation") ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/vatom/b/campaign/u/points/get"
        value = [PATH_GET_POINTS_BALANCE_AS_BUSINESS]
    )
    fun getPointsBalanceAsBusiness(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "Sirqul Account Id", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "Sirqul Application Key", required = true) @Valid @RequestParam(value = "appKey", required = true) appKey: kotlin.String,
        @NotNull @Parameter(description = "Vatom User Id", required = true) @Valid @RequestParam(value = "vatomUserId", required = true) vatomUserId: kotlin.String,
        @NotNull @Parameter(description = "Vatom Campaign Id", required = true) @Valid @RequestParam(value = "vatomCampaignId", required = true) vatomCampaignId: kotlin.String,
        @Parameter(description = "Return raw response") @Valid @RequestParam(value = "returnRawResponse", required = false) returnRawResponse: kotlin.Boolean?
    ): ResponseEntity<Unit> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get Postal Code",
        operationId = "getPostalCode",
        description = """Get a Postal Code""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = PostalCodeResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/postalCode/get"
        value = [PATH_GET_POSTAL_CODE],
        produces = ["*/*"]
    )
    fun getPostalCode(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the id of the postal code to get", required = true) @Valid @RequestParam(value = "postalCodeId", required = true) postalCodeId: kotlin.Long
    ): ResponseEntity<PostalCodeResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Search Postal Codes",
        operationId = "getPostalCodes",
        description = """Get the list of regions. If latitude or longitude is null, will return all postal codes in the system with paginated response.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(array = ArraySchema(schema = Schema(implementation = PostalCodeResponse::class)))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/postalCode/search"
        value = [PATH_GET_POSTAL_CODES],
        produces = ["*/*"]
    )
    fun getPostalCodes(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the field to sort the results on", required = true) @Valid @RequestParam(value = "sortField", required = true) sortField: kotlin.String,
        @NotNull @Parameter(description = "whether to order results in ascending or descending order", required = true) @Valid @RequestParam(value = "descending", required = true) descending: kotlin.Boolean,
        @Parameter(description = "the latitude of the postal code to search on") @Valid @RequestParam(value = "latitude", required = false) latitude: kotlin.Double?,
        @Parameter(description = "the longitude of the postal code to search on") @Valid @RequestParam(value = "longitude", required = false) longitude: kotlin.Double?,
        @Parameter(description = "the keyword of the postal code to search on") @Valid @RequestParam(value = "keyword", required = false) keyword: kotlin.String?,
        @Parameter(description = "how far (in miles) to search on for the postal code") @Valid @RequestParam(value = "miles", required = false) miles: kotlin.Double?,
        @Parameter(description = "the start of the index and/or pagination") @Valid @RequestParam(value = "start", required = false) start: kotlin.Int?,
        @Parameter(description = "the limit of the index and/or pagination") @Valid @RequestParam(value = "limit", required = false) limit: kotlin.Int?
    ): ResponseEntity<List<PostalCodeResponse>> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get Predicted Locations",
        operationId = "getPredictedLocations",
        description = """Get the predicted location for a customer based on previous behavior.  If a customer resides in a place for a period of time this is marked as a preferred location.  We look back over the previous few days and the previous days of the week from the day specified.  If for instance the day was a Wednesday then this would check the days before, including: Tuesday, Monday, Sunday, etc. It will also check some number of previous Wednesdays in the past few weeks.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = PredictedLocationResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/tracking/predicted/get"
        value = [PATH_GET_PREDICTED_LOCATIONS],
        produces = ["*/*"]
    )
    fun getPredictedLocations(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The account id of the customer", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @Parameter(description = "latitude to return a more likely result set based on the user's current location") @Valid @RequestParam(value = "latitude", required = false) latitude: kotlin.Double?,
        @Parameter(description = "longitude to return a more likely result set based on the user's current location") @Valid @RequestParam(value = "longitude", required = false) longitude: kotlin.Double?,
        @Parameter(description = "Used to specify which day to get predicted locations for. So if you want to look at where they might be tomorrow, pass in tomorrow's date (timestamp in milliseconds). If no value is passed in, the current date will be used.") @Valid @RequestParam(value = "dateCheck", required = false) dateCheck: kotlin.Long?,
        @Parameter(description = "Comma separated list of hours that will filter the results on the hours specified. For example, if you want to see predicted locations for the mornings and evening you can pass in \"8,9,10,11,17,18,19,20\".") @Valid @RequestParam(value = "hourCheck", required = false) hourCheck: kotlin.String?,
        @Parameter(description = "The minimum number matches in 1 hour to be considered a likely location.", schema = Schema(defaultValue = "1L")) @Valid @RequestParam(value = "threshold", required = false, defaultValue = "1L") threshold: kotlin.Long,
        @Parameter(description = "Determines which unit of measurement gets returned for distances: {MILES, KILOMETERS}", schema = Schema(allowableValues = ["MILES", "KILOMETERS"], defaultValue = "MILES")) @Valid @RequestParam(value = "distanceUnit", required = false, defaultValue = "MILES") distanceUnit: kotlin.String,
        @Parameter(description = "Filter results so only locations within the specified radius will be returned. The distance can either be in miles or kilometers as specified in the distanceUnit parameter. A value of \"0\" (zero) will ignore the radius restriction.", schema = Schema(defaultValue = "0.0")) @Valid @RequestParam(value = "searchRange", required = false, defaultValue = "0.0") searchRange: kotlin.Double,
        @Parameter(description = "The ordering algorithm for sorting the returned results: {MATCHES, DISTANCE, WEIGHTED}", schema = Schema(allowableValues = ["MATCHES", "DISTANCE", "WEIGHTED"], defaultValue = "MATCHES")) @Valid @RequestParam(value = "sortOrder", required = false, defaultValue = "MATCHES") sortOrder: kotlin.String
    ): ResponseEntity<PredictedLocationResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get Tracking Path",
        operationId = "getPredictedPath",
        description = """Get the path (lat/long coordinates) between 2 steps previously logged for a customer.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(array = ArraySchema(schema = Schema(implementation = StepResponse::class)))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/tracking/path/get"
        value = [PATH_GET_PREDICTED_PATH],
        produces = ["*/*"]
    )
    fun getPredictedPath(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The account id of the customer", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "The stepId to begin from", required = true) @Valid @RequestParam(value = "startStepId", required = true) startStepId: kotlin.Long,
        @NotNull @Parameter(description = "The stepId to end with", required = true) @Valid @RequestParam(value = "endStepId", required = true) endStepId: kotlin.Long
    ): ResponseEntity<List<StepResponse>> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Search Preferred Locations",
        operationId = "getPreferredLocations",
        description = """Search on preferred locations for a user, which is created when a customer resides in a place for a period of time.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(array = ArraySchema(schema = Schema(implementation = PreferredLocationResponse::class)))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/tracking/preferred/search"
        value = [PATH_GET_PREFERRED_LOCATIONS],
        produces = ["*/*"]
    )
    fun getPreferredLocations(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The account id of the customer", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @Parameter(description = "latitude to return a more likely result set based on the user's current location") @Valid @RequestParam(value = "latitude", required = false) latitude: kotlin.Double?,
        @Parameter(description = "longitude to return a more likely result set based on the user's current location") @Valid @RequestParam(value = "longitude", required = false) longitude: kotlin.Double?,
        @Parameter(description = "Used to specify which day to get preferred locations for. So if you want to look at where they might be tomorrow, pass in tomorrow's date (timestamp in milliseconds). If no value is passed in, results from all time will be returned.") @Valid @RequestParam(value = "dateCheck", required = false) dateCheck: kotlin.Long?,
        @Parameter(description = "Comma separated list of hours that will filter the results on the hours specified. For example, if you want to see preferred locations for the mornings and evening you can pass in \"8,9,10,11,17,18,19,20\".") @Valid @RequestParam(value = "hourCheck", required = false) hourCheck: kotlin.String?,
        @Parameter(description = "Specifies how the results will be ordered. Supported values include: CREATED - the time of when the preferred location data was processed. PREFERRED_DATE - the time of when the user sent in the tracking data. HOUR - the hour of when the user sent in the tracking data. DURATION - the duration of the preferred location", schema = Schema(defaultValue = "PREFERRED_DATE")) @Valid @RequestParam(value = "sortField", required = false, defaultValue = "PREFERRED_DATE") sortField: kotlin.String,
        @Parameter(description = "Determines whether the sorted list is in descending or ascending order", schema = Schema(defaultValue = "true")) @Valid @RequestParam(value = "descending", required = false, defaultValue = "true") descending: kotlin.Boolean,
        @Parameter(description = "The start index for pagination", schema = Schema(defaultValue = "0")) @Valid @RequestParam(value = "start", required = false, defaultValue = "0") start: kotlin.Int,
        @Parameter(description = "The limit for pagination", schema = Schema(defaultValue = "20")) @Valid @RequestParam(value = "limit", required = false, defaultValue = "20") limit: kotlin.Int,
        @Parameter(description = "Filter results so only locations within the specified radius will be returned. The distance can either be in miles or kilometers as specified in the distanceUnit parameter. A value of \"0\" (zero) will ignore the radius restriction.", schema = Schema(defaultValue = "0.0")) @Valid @RequestParam(value = "searchRange", required = false, defaultValue = "0.0") searchRange: kotlin.Double,
        @Parameter(description = "Determines which unit of measurement gets returned for distances: {MILES, KILOMETERS}", schema = Schema(allowableValues = ["MILES", "KILOMETERS"], defaultValue = "MILES")) @Valid @RequestParam(value = "distanceUnit", required = false, defaultValue = "MILES") distanceUnit: kotlin.String
    ): ResponseEntity<List<PreferredLocationResponse>> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get Profile Assets",
        operationId = "getProfileAssets",
        description = """Get a list of assets a person has ever uploaded. Filters the list based on parameters.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = AssetListResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/account/profile/assets"
        value = [PATH_GET_PROFILE_ASSETS],
        produces = ["*/*"]
    )
    fun getProfileAssets(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "Determines whether to return null fields in the response", schema = Schema(defaultValue = "false")) @Valid @RequestParam(value = "returnNulls", required = false, defaultValue = "false") returnNulls: kotlin.Boolean,
        @Parameter(description = "The device id (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "The account id of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "The account id of the person the user wants to view") @Valid @RequestParam(value = "ownerId", required = false) ownerId: kotlin.Long?,
        @Parameter(description = "Comma separated list of MediaType") @Valid @RequestParam(value = "mediaTypes", required = false) mediaTypes: kotlin.String?,
        @Parameter(description = "Comma separated list of mime types") @Valid @RequestParam(value = "mimeTypes", required = false) mimeTypes: kotlin.String?,
        @Parameter(description = "Determines what the returning list will be sorted by (see AssetApiMap)", schema = Schema(defaultValue = "CREATED")) @Valid @RequestParam(value = "sortField", required = false, defaultValue = "CREATED") sortField: kotlin.String,
        @Parameter(description = "Determines whether to return the resulting list in descending or ascending order", schema = Schema(defaultValue = "true")) @Valid @RequestParam(value = "descending", required = false, defaultValue = "true") descending: kotlin.Boolean,
        @Parameter(description = "Latitude used to update the user's current location") @Valid @RequestParam(value = "latitude", required = false) latitude: kotlin.Double?,
        @Parameter(description = "Longitude used to update the user's current location") @Valid @RequestParam(value = "longitude", required = false) longitude: kotlin.Double?,
        @Parameter(description = "_i") @Valid @RequestParam(value = "_i", required = false) i: kotlin.Int?,
        @Parameter(description = "Start of the pagination", schema = Schema(defaultValue = "0")) @Valid @RequestParam(value = "start", required = false, defaultValue = "0") start: kotlin.Int,
        @Parameter(description = "_l") @Valid @RequestParam(value = "_l", required = false) l: kotlin.Int?,
        @Parameter(description = "Limit of the pagination", schema = Schema(defaultValue = "0")) @Valid @RequestParam(value = "limit", required = false, defaultValue = "0") limit: kotlin.Int
    ): ResponseEntity<AssetListResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get Program",
        operationId = "getProgram",
        description = """Get an existing program""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = Program::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/program/{id}"
        value = [PATH_GET_PROGRAM],
        produces = ["*/*"]
    )
    fun getProgram(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "the id of the program", required = true) @PathVariable("id") id: kotlin.Long
    ): ResponseEntity<Program> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get Purchase",
        operationId = "getPurchaseItem",
        description = """Get detailed information about a purchase item""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = PurchaseItemFullResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/purchase/get"
        value = [PATH_GET_PURCHASE_ITEM],
        produces = ["*/*"]
    )
    fun getPurchaseItem(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The purchase item id", required = true) @Valid @RequestParam(value = "purchaseItemId", required = true) purchaseItemId: kotlin.Long,
        @Parameter(description = "The device id (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "The account id of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?
    ): ResponseEntity<PurchaseItemFullResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get Question",
        operationId = "getQuestion",
        description = """Get a question by the given id.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = QuestionResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/game/question/get"
        value = [PATH_GET_QUESTION],
        produces = ["*/*"]
    )
    fun getQuestion(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the id of the question to get", required = true) @Valid @RequestParam(value = "questionId", required = true) questionId: kotlin.Long,
        @NotNull @Parameter(description = "the id of the account that can make this request", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long
    ): ResponseEntity<QuestionResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get Level Questions",
        operationId = "getQuestionsInLevel",
        description = """Get questions within a level.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = QuestionResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/level/questions/get"
        value = [PATH_GET_QUESTIONS_IN_LEVEL],
        produces = ["*/*"]
    )
    fun getQuestionsInLevel(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the id of the level to get questions from", required = true) @Valid @RequestParam(value = "levelId", required = true) levelId: kotlin.Long,
        @NotNull @Parameter(description = "the id of the logged in user", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long
    ): ResponseEntity<QuestionResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Search Rankings",
        operationId = "getRankings",
        description = """Get leader board rankings. This is an all in one endpoint that can return multiple ranking types and also the current user rank.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = RankFullResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/ranking/search"
        value = [PATH_GET_RANKINGS],
        produces = ["*/*"]
    )
    fun getRankings(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "a unique id given by the device (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "the account id of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "This parameter is deprecated.") @Valid @RequestParam(value = "gameType", required = false) gameType: kotlin.String?,
        @Parameter(description = "the application key for filtering results by application (required for non-EXECUTIVE users)") @Valid @RequestParam(value = "appKey", required = false) appKey: kotlin.String?,
        @Parameter(description = "This parameter is deprecated.") @Valid @RequestParam(value = "q", required = false) q: kotlin.String?,
        @Parameter(description = "keyword to search for") @Valid @RequestParam(value = "keyword", required = false) keyword: kotlin.String?,
        @Parameter(description = "a comma separated list of rank types to return. Possible default rank types: POINTS, DOWNLOADS, INVITATIONS", schema = Schema(defaultValue = "POINTS,DOWNLOADS,INVITATIONS")) @Valid @RequestParam(value = "rankType", required = false, defaultValue = "POINTS,DOWNLOADS,INVITATIONS") rankType: kotlin.String,
        @Parameter(description = "the type of search to perform. Possible values include: GLOBAL - searches scores globally (all users in the system are included in the ranking) LOCAL - filters results by select users and on users that have logged into the same device CUSTOM - allows for custom filtering using the params: withinAccountIds, albumId, audienceId", schema = Schema(defaultValue = "GLOBAL")) @Valid @RequestParam(value = "leaderboardMode", required = false, defaultValue = "GLOBAL") leaderboardMode: kotlin.String,
        @Parameter(description = "comma separated list of account ids. If performing a LOCAL or CUSTOM search, the query will include these accounts.") @Valid @RequestParam(value = "withinAccountIds", required = false) withinAccountIds: kotlin.String?,
        @Parameter(description = "determines whether to return the user's current rank in the response. This can be turned off for sequential paginated requests.", schema = Schema(defaultValue = "true")) @Valid @RequestParam(value = "returnUserRank", required = false, defaultValue = "true") returnUserRank: kotlin.Boolean,
        @Parameter(description = "album id to use when performing CUSTOM filters") @Valid @RequestParam(value = "albumId", required = false) albumId: kotlin.Long?,
        @Parameter(description = "audience id to use when performing CUSTOM filters") @Valid @RequestParam(value = "audienceId", required = false) audienceId: kotlin.Long?,
        @Parameter(description = "determines how to order and rank the results. Possible values include: TOTAL - order results by total score MONTHLY - order results by monthly score WEEKLY - order results by weekly score DAILY - order results by daily score TOP - order results by top score LOWEST - order results by lowest score", schema = Schema(defaultValue = "TOTAL")) @Valid @RequestParam(value = "sortField", required = false, defaultValue = "TOTAL") sortField: kotlin.String,
        @Parameter(description = "determines whether to return results in ascending or descending order", schema = Schema(defaultValue = "true")) @Valid @RequestParam(value = "descending", required = false, defaultValue = "true") descending: kotlin.Boolean,
        @Parameter(description = "This parameter is deprecated.") @Valid @RequestParam(value = "_i", required = false) i: kotlin.Int?,
        @Parameter(description = "the start index for pagination", schema = Schema(defaultValue = "0")) @Valid @RequestParam(value = "start", required = false, defaultValue = "0") start: kotlin.Int,
        @Parameter(description = "This parameter is deprecated.") @Valid @RequestParam(value = "_l", required = false) l: kotlin.Int?,
        @Parameter(description = "the limit for pagination", schema = Schema(defaultValue = "100")) @Valid @RequestParam(value = "limit", required = false, defaultValue = "100") limit: kotlin.Int
    ): ResponseEntity<RankFullResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Search Accounts",
        operationId = "getReferralList",
        description = """Gets a user's account profile and their referral List.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation") ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/account/referral/list"
        value = [PATH_GET_REFERRAL_LIST]
    )
    fun getReferralList(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "The account id of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "The application key") @Valid @RequestParam(value = "appKey", required = false) appKey: kotlin.String?,
        @Parameter(description = "one of these option - GET_CHILDREN will get all accounts that had signed up using the current account invite link - GET_ANCESTOR will get all accounts that referred the current account and it's parents, recursively - GET_ALL will get all of the above") @Valid @RequestParam(value = "retrieveType", required = false) retrieveType: kotlin.String?,
        @Parameter(description = "level limit for children and ancestors of current account, starts from current account") @Valid @RequestParam(value = "levelLimit", required = false) levelLimit: java.math.BigDecimal?,
        @Parameter(description = "level limit for ancestors, will override levelLimit if this is set") @Valid @RequestParam(value = "ancestorLevelLimit", required = false) ancestorLevelLimit: java.math.BigDecimal?,
        @Parameter(description = "level limit for children, will override levelLimit if this is set") @Valid @RequestParam(value = "childrenLevelLimit", required = false) childrenLevelLimit: java.math.BigDecimal?,
        @Parameter(description = "pagination start for children list") @Valid @RequestParam(value = "ancestorListStart", required = false) ancestorListStart: java.math.BigDecimal?,
        @Parameter(description = "pagination limit for children list") @Valid @RequestParam(value = "ancestorListLimit", required = false) ancestorListLimit: java.math.BigDecimal?,
        @Parameter(description = "pagination start for children list") @Valid @RequestParam(value = "childrenListStart", required = false) childrenListStart: java.math.BigDecimal?,
        @Parameter(description = "pagination limit for children list") @Valid @RequestParam(value = "childrenListLimit", required = false) childrenListLimit: java.math.BigDecimal?,
        @Parameter(description = "if true, on each item in ancestor and children list, return the childrenTotalNumber and ancestorTotalNumber for that item", schema = Schema(defaultValue = "true")) @Valid @RequestParam(value = "childrenChildren", required = false, defaultValue = "true") childrenChildren: kotlin.Boolean
    ): ResponseEntity<Unit> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get Region",
        operationId = "getRegion",
        description = """Get a region.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = RegionResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/region/get"
        value = [PATH_GET_REGION],
        produces = ["*/*"]
    )
    fun getRegion(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the id of the region to get", required = true) @Valid @RequestParam(value = "regionId", required = true) regionId: kotlin.Long,
        @Parameter(description = "the id of the logged in user") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?
    ): ResponseEntity<RegionResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Check episode status",
        operationId = "getRenderStatus",
        description = """Gets a summary of the episode's status, including any renders.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = OrsonRenderResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/orson/stories/renders/{renderId}/status"
        value = [PATH_GET_RENDER_STATUS],
        produces = ["*/*"]
    )
    fun getRenderStatus(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "Render ID", required = true) @PathVariable("renderId") renderId: kotlin.String,
        @NotNull @Parameter(description = "Sirqul Account Id", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long
    ): ResponseEntity<OrsonRenderResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get Offline Report",
        operationId = "getReportBatch",
        description = """Checks status of batch report.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = ReportBatchResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/report/batch/get"
        value = [PATH_GET_REPORT_BATCH],
        produces = ["*/*"]
    )
    fun getReportBatch(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the id of the logged in user", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "returned by /report/batch/create", required = true) @Valid @RequestParam(value = "batchId", required = true) batchId: kotlin.Long,
        @NotNull @Parameter(description = "whether to return all batch results or not", required = true) @Valid @RequestParam(value = "allResults", required = true) allResults: kotlin.Boolean
    ): ResponseEntity<ReportBatchResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get Retailer",
        operationId = "getRetailer",
        description = """Gets a retailer. Only the owner and the employees of a retailer have access to view its information.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = RetailerFullResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/retailer/get"
        value = [PATH_GET_RETAILER],
        produces = ["*/*"]
    )
    fun getRetailer(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the ID of the retailer", required = true) @Valid @RequestParam(value = "retailerId", required = true) retailerId: kotlin.Long,
        @Parameter(description = "the device id (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "the account id of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "Determines whether to include counts in the response (default true)") @Valid @RequestParam(value = "includeCounts", required = false) includeCounts: kotlin.Boolean?
    ): ResponseEntity<RetailerFullResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get Retailer Location",
        operationId = "getRetailerLocation",
        description = """Gets a retailer location. Only the owner and the employees of the retailer have access to view its information.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = RetailerLocationResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/retailer/location/get"
        value = [PATH_GET_RETAILER_LOCATION],
        produces = ["*/*"]
    )
    fun getRetailerLocation(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The ID of the retailer location", required = true) @Valid @RequestParam(value = "retailerLocationId", required = true) retailerLocationId: kotlin.Long,
        @Parameter(description = "The device id (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "The account id of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "the unique token of the retailer location") @Valid @RequestParam(value = "retailerLocationToken", required = false) retailerLocationToken: kotlin.String?
    ): ResponseEntity<RetailerLocationResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get Retailer Location (Consumer)",
        operationId = "getRetailerLocationConsumer",
        description = """Gets the details of a retailer location as a consumer.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = RetailerLocationResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/location/get"
        value = [PATH_GET_RETAILER_LOCATION_CONSUMER],
        produces = ["*/*"]
    )
    fun getRetailerLocationConsumer(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The retailer location id", required = true) @Valid @RequestParam(value = "retailerLocationId", required = true) retailerLocationId: kotlin.Long,
        @Parameter(description = "The device id for returning account information (i.e. favorites)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "The account id for returning account information (i.e. favorites)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?
    ): ResponseEntity<RetailerLocationResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Search Retailers",
        operationId = "getRetailers",
        description = """earches on retailers that the account has access to.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(array = ArraySchema(schema = Schema(implementation = RetailerResponse::class)))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/retailer/search"
        value = [PATH_GET_RETAILERS],
        produces = ["*/*"]
    )
    fun getRetailers(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "", required = true, schema = Schema(allowableValues = ["PUBLIC", "PRIVATE", "FRIENDS"])) @Valid @RequestParam(value = "visibility", required = true) visibility: kotlin.String,
        @NotNull @Parameter(description = "The column to sort the search on", required = true, schema = Schema(allowableValues = ["ID", "CREATED", "UPDATED", "DELETED", "SEARCH_TAGS", "ACTIVE", "BILLABLE_ENTITY_ID", "BILLABLE_ENTITY_NAME", "RESPONSIBLE_DISPLAY", "ADDRESS_STREET", "ADDRESS_CITY", "ADDRESS_STATE", "ADDRESS_POSTAL_CODE", "ADDRESS_COUNTRY", "FILTERS", "CATEGORIES", "VISIBILITY", "NAME"])) @Valid @RequestParam(value = "sortField", required = true) sortField: kotlin.String,
        @NotNull @Parameter(description = "The order to return the search results", required = true) @Valid @RequestParam(value = "descending", required = true) descending: kotlin.Boolean,
        @NotNull @Parameter(description = "The record to begin the return set on", required = true) @Valid @RequestParam(value = "start", required = true) start: kotlin.Int,
        @NotNull @Parameter(description = "The number of records to return", required = true) @Valid @RequestParam(value = "limit", required = true) limit: kotlin.Int,
        @NotNull @Parameter(description = "Return only active results", required = true) @Valid @RequestParam(value = "activeOnly", required = true) activeOnly: kotlin.Boolean,
        @Parameter(description = "The device id (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "The account id of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "This parameter is deprecated.") @Valid @RequestParam(value = "q", required = false) q: kotlin.String?,
        @Parameter(description = "The keyword used to search") @Valid @RequestParam(value = "keyword", required = false) keyword: kotlin.String?,
        @Parameter(description = "the categories that the retailer is associated with") @Valid @RequestParam(value = "categoryIds", required = false) categoryIds: kotlin.String?,
        @Parameter(description = "the filters that the retailer is associated with") @Valid @RequestParam(value = "filterIds", required = false) filterIds: kotlin.String?,
        @Parameter(description = "This parameter is deprecated.") @Valid @RequestParam(value = "_i", required = false) i: kotlin.Int?,
        @Parameter(description = "This parameter is deprecated.") @Valid @RequestParam(value = "_l", required = false) l: kotlin.Int?
    ): ResponseEntity<List<RetailerResponse>> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get Retailer",
        operationId = "getRetaokiler",
        description = """Gets a retailer. Only the owner and the employees of a retailer have access to view its information.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/retailer"
        value = [PATH_GET_RETAOKILER],
        produces = ["*/*"]
    )
    fun getRetaokiler(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the id of the retailer", required = true) @Valid @RequestParam(value = "retailerId", required = true) retailerId: kotlin.Long,
        @NotNull @Parameter(description = "whether to return results that are active only or all", required = true, schema = Schema(defaultValue = "true")) @Valid @RequestParam(value = "activeOnly", required = true, defaultValue = "true") activeOnly: kotlin.Boolean,
        @Parameter(description = "the keyword to search on to get retailer") @Valid @RequestParam(value = "keyword", required = false) keyword: kotlin.String?,
        @Parameter(description = "the field to sort on", schema = Schema(defaultValue = "id")) @Valid @RequestParam(value = "sortField", required = false, defaultValue = "id") sortField: kotlin.String,
        @Parameter(description = "the start of the index and/or pagination", schema = Schema(defaultValue = "0L")) @Valid @RequestParam(value = "start", required = false, defaultValue = "0L") start: kotlin.Long,
        @Parameter(description = "the limit of the index and/or pagination", schema = Schema(defaultValue = "20L")) @Valid @RequestParam(value = "limit", required = false, defaultValue = "20L") limit: kotlin.Long
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get Route",
        operationId = "getRoute",
        description = """Get an existing route""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = Route::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/route/{routeId}"
        value = [PATH_GET_ROUTE],
        produces = ["*/*"]
    )
    fun getRoute(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "the id of the route to get", required = true) @PathVariable("routeId") routeId: kotlin.Long,
        @NotNull @Parameter(description = "return inherited properties from parent or not", required = true) @Valid @RequestParam(value = "showInheritedProperties", required = true) showInheritedProperties: kotlin.Boolean
    ): ResponseEntity<Route> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get Route Directions",
        operationId = "getRouteDirections",
        description = """Get the directions of a route""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(array = ArraySchema(schema = Schema(implementation = Direction::class)))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/route/{routeId}/directions"
        value = [PATH_GET_ROUTE_DIRECTIONS],
        produces = ["*/*"]
    )
    fun getRouteDirections(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "the id of the route to get directions for", required = true) @PathVariable("routeId") routeId: kotlin.Long
    ): ResponseEntity<List<Direction>> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get Route Setting",
        operationId = "getRouteSettings",
        description = """Get an existing route settings""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = RouteSettings::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/route/setting/{routeSettingsId}"
        value = [PATH_GET_ROUTE_SETTINGS],
        produces = ["*/*"]
    )
    fun getRouteSettings(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "the id of the route settings to get", required = true) @PathVariable("routeSettingsId") routeSettingsId: kotlin.Long
    ): ResponseEntity<RouteSettings> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get Route Shipments",
        operationId = "getRouteShipments",
        description = """Get the shipments on the requested route""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(array = ArraySchema(schema = Schema(implementation = Shipment::class)))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/route/{routeId}/shipments"
        value = [PATH_GET_ROUTE_SHIPMENTS],
        produces = ["*/*"]
    )
    fun getRouteShipments(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "the id of the route to get shipments for", required = true) @PathVariable("routeId") routeId: kotlin.Long
    ): ResponseEntity<List<Shipment>> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get Route Stop",
        operationId = "getRouteStop",
        description = """Get the specific stop on a route""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = Stop::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/route/{routeId}/stop/{stopId}"
        value = [PATH_GET_ROUTE_STOP],
        produces = ["*/*"]
    )
    fun getRouteStop(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "the id of the route to get stops for", required = true) @PathVariable("routeId") routeId: kotlin.Long,
        @Parameter(description = "the id of the specific stop on the route", required = true) @PathVariable("stopId") stopId: kotlin.Long
    ): ResponseEntity<Stop> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get Route Stops",
        operationId = "getRouteStops",
        description = """The stops of the route requested""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(array = ArraySchema(schema = Schema(implementation = Stop::class)))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/route/{routeId}/stops"
        value = [PATH_GET_ROUTE_STOPS],
        produces = ["*/*"]
    )
    fun getRouteStops(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "the id of the route", required = true) @PathVariable("routeId") routeId: kotlin.Long,
        @NotNull @Parameter(description = "only get stops that have been confirmed or not", required = true) @Valid @RequestParam(value = "confirmedOnly", required = true) confirmedOnly: kotlin.Boolean
    ): ResponseEntity<List<Stop>> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get Speach to Text Result",
        operationId = "getSTT",
        description = """The results of the video transcription and optional translation.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = OrsonAiSTTResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/orson/ai/stt/{requestId}"
        value = [PATH_GET_STT],
        produces = ["*/*"]
    )
    fun getSTT(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "Orson Request Id", required = true) @PathVariable("requestId") requestId: kotlin.String,
        @NotNull @Parameter(description = "Sirqul Account Id", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long
    ): ResponseEntity<OrsonAiSTTResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get Scheduled Notification",
        operationId = "getScheduledNotification",
        description = """Get a ScheduledNotification""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = ScheduledNotificationFullResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/notification/schedule/get"
        value = [PATH_GET_SCHEDULED_NOTIFICATION],
        produces = ["*/*"]
    )
    fun getScheduledNotification(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the id of the account logged in", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "the id of the scheduled notification to get", required = true) @Valid @RequestParam(value = "scheduledNotificationId", required = true) scheduledNotificationId: kotlin.Long
    ): ResponseEntity<ScheduledNotificationFullResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get Score",
        operationId = "getScore",
        description = """Get the high score for an item.  Pass in the full path IDs for the score.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = ScoreResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/score/get"
        value = [PATH_GET_SCORE],
        produces = ["*/*"]
    )
    fun getScore(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The logged in user.", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "The game application key to get the level for.", required = true) @Valid @RequestParam(value = "appKey", required = true) appKey: kotlin.String,
        @Parameter(description = "The missionId to score for, null if not playing mission.") @Valid @RequestParam(value = "missionId", required = false) missionId: kotlin.Long?,
        @Parameter(description = "The gameId to score for, null if not playing mission.") @Valid @RequestParam(value = "gameId", required = false) gameId: kotlin.Long?,
        @Parameter(description = "The packId to score for, null if playing community levels.") @Valid @RequestParam(value = "packId", required = false) packId: kotlin.Long?,
        @Parameter(description = "The gameLevelId to score for.") @Valid @RequestParam(value = "gameLevelId", required = false) gameLevelId: kotlin.Long?,
        @Parameter(description = "The gameObjectId to score for, null if level based scoring.") @Valid @RequestParam(value = "gameObjectId", required = false) gameObjectId: kotlin.Long?,
        @Parameter(description = "The object type to filter scores by (TicketObjectType)") @Valid @RequestParam(value = "scoreObjectType", required = false) scoreObjectType: kotlin.String?,
        @Parameter(description = "The status of the score to filter (ScoreStatus)") @Valid @RequestParam(value = "scoreStatus", required = false) scoreStatus: kotlin.String?
    ): ResponseEntity<ScoreResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get Service Hub",
        operationId = "getServiceHub",
        description = """Get an existing service hub""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = kotlin.Any::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/hub/{id}"
        value = [PATH_GET_SERVICE_HUB],
        produces = ["*/*"]
    )
    fun getServiceHub(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "the id of the service hub to get", required = true) @PathVariable("id") id: kotlin.Long
    ): ResponseEntity<kotlin.Any> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get Account Settings",
        operationId = "getSettings",
        description = """Get the account settings for a user""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = UserSettingsResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/account/settings/get"
        value = [PATH_GET_SETTINGS],
        produces = ["*/*"]
    )
    fun getSettings(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "The device id (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "The account id of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "The current latitude of the user") @Valid @RequestParam(value = "latitude", required = false) latitude: kotlin.Double?,
        @Parameter(description = "The current longitude of the user") @Valid @RequestParam(value = "longitude", required = false) longitude: kotlin.Double?
    ): ResponseEntity<UserSettingsResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get Shipment",
        operationId = "getShipment",
        description = """Get an existing shipment""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = Shipment::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/shipment/{id}"
        value = [PATH_GET_SHIPMENT],
        produces = ["*/*"]
    )
    fun getShipment(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "the id of the shipment to get", required = true) @PathVariable("id") id: kotlin.Long
    ): ResponseEntity<Shipment> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get Shipment Batch",
        operationId = "getShipmentBatch",
        description = """Get an existing shipment batch""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = ShipmentBatch::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/shipment/batch/{batchId}"
        value = [PATH_GET_SHIPMENT_BATCH],
        produces = ["*/*"]
    )
    fun getShipmentBatch(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "the id of the shipment batch to get", required = true) @PathVariable("batchId") batchId: kotlin.Long
    ): ResponseEntity<ShipmentBatch> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get Shipment Batch Status",
        operationId = "getShipmentBatchStatus",
        description = """Get the import status list of the import shipment batch""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(array = ArraySchema(schema = Schema(implementation = ShipmentImportStatus::class)))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/shipment/batch/{batchId}/status"
        value = [PATH_GET_SHIPMENT_BATCH_STATUS],
        produces = ["*/*"]
    )
    fun getShipmentBatchStatus(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "The id of the requested shipment batch", required = true) @PathVariable("batchId") batchId: kotlin.Long,
        @NotNull @Parameter(description = "the id of the logged in user", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "The field to sort by", required = true) @Valid @RequestParam(value = "sortField", required = true) sortField: kotlin.String,
        @NotNull @Parameter(description = "Determines whether the sorted list is in descending or ascending order", required = true) @Valid @RequestParam(value = "descending", required = true) descending: kotlin.Boolean,
        @NotNull @Parameter(description = "The start index for pagination", required = true) @Valid @RequestParam(value = "start", required = true) start: kotlin.Int,
        @NotNull @Parameter(description = "The limit for pagination", required = true) @Valid @RequestParam(value = "limit", required = true) limit: kotlin.Int,
        @Parameter(description = "Valid import status only or not") @Valid @RequestParam(value = "valid", required = false) valid: kotlin.Boolean?,
        @Parameter(description = "Started import status only") @Valid @RequestParam(value = "started", required = false) started: kotlin.Boolean?,
        @Parameter(description = "Completed import status only") @Valid @RequestParam(value = "completed", required = false) completed: kotlin.Boolean?,
        @Parameter(description = "Has shipment associate to the status") @Valid @RequestParam(value = "hasShipment", required = false) hasShipment: kotlin.Boolean?,
        @Parameter(description = "Has route associate to the status") @Valid @RequestParam(value = "hasRoute", required = false) hasRoute: kotlin.Boolean?,
        @Parameter(description = "The keyword to search for") @Valid @RequestParam(value = "keyword", required = false) keyword: kotlin.String?
    ): ResponseEntity<List<ShipmentImportStatus>> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get Shipments At Stop",
        operationId = "getShipmentsAtStop",
        description = """Get the list of shipments on the requested route at a stop""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(array = ArraySchema(schema = Schema(implementation = Shipment::class)))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/route/{routeId}/stop/{stopId}/shipments"
        value = [PATH_GET_SHIPMENTS_AT_STOP],
        produces = ["*/*"]
    )
    fun getShipmentsAtStop(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "the id of the route", required = true) @PathVariable("routeId") routeId: kotlin.Long,
        @Parameter(description = "the id of the stop to get shipments on", required = true) @PathVariable("stopId") stopId: kotlin.Long
    ): ResponseEntity<List<Shipment>> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get Vatom Space",
        operationId = "getSpace",
        description = """Gets the details of a space.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation") ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/vatom/b/spaces/get"
        value = [PATH_GET_SPACE]
    )
    fun getSpace(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "Sirqul Account Id", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "Sirqul Application Key", required = true) @Valid @RequestParam(value = "appKey", required = true) appKey: kotlin.String,
        @NotNull @Parameter(description = "Vatom Space Id", required = true) @Valid @RequestParam(value = "vatomSpaceId", required = true) vatomSpaceId: kotlin.String,
        @Parameter(description = "Return raw response") @Valid @RequestParam(value = "returnRawResponse", required = false) returnRawResponse: kotlin.Boolean?
    ): ResponseEntity<Unit> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Detail Status",
        operationId = "getStatusCSV",
        description = """""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/csvimport/batch/status/details"
        value = [PATH_GET_STATUS_CSV],
        produces = ["*/*"]
    )
    fun getStatusCSV(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the id of the logged in user", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "the id of the batch", required = true) @Valid @RequestParam(value = "batchId", required = true) batchId: kotlin.Long,
        @NotNull @Parameter(description = "The group of categories to return: SUMMARY, DETAILS, ERRORS, OR ALL", required = true, schema = Schema(allowableValues = ["SUMMARY", "DETAILS", "ERRORS", "ALL"])) @Valid @RequestParam(value = "responseGroup", required = true) responseGroup: kotlin.String,
        @NotNull @Parameter(description = "the start of the pagination", required = true) @Valid @RequestParam(value = "start", required = true) start: kotlin.Long,
        @NotNull @Parameter(description = "the limit of the pagination", required = true) @Valid @RequestParam(value = "limit", required = true) limit: kotlin.Long
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get Stop",
        operationId = "getStop",
        description = """Get an existing stop""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = Stop::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/stop/{id}"
        value = [PATH_GET_STOP],
        produces = ["*/*"]
    )
    fun getStop(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "the id of the stop to get", required = true) @PathVariable("id") id: kotlin.Long
    ): ResponseEntity<Stop> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get Subscription",
        operationId = "getSubscription",
        description = """Use the accountId to determine the associated BillableEntity.  Then get the subscription.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SubscriptionResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/subscription/get"
        value = [PATH_GET_SUBSCRIPTION],
        produces = ["*/*"]
    )
    fun getSubscription(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The account used to perform the lookup", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long
    ): ResponseEntity<SubscriptionResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get Subscription Plan",
        operationId = "getSubscriptionPlan",
        description = """Get the matched subscription plan""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SubscriptionPlanResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/subscription/plan/get"
        value = [PATH_GET_SUBSCRIPTION_PLAN],
        produces = ["*/*"]
    )
    fun getSubscriptionPlan(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The ID of the plan to get", required = true) @Valid @RequestParam(value = "planId", required = true) planId: kotlin.Long
    ): ResponseEntity<SubscriptionPlanResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "List Subscription Plans",
        operationId = "getSubscriptionPlans",
        description = """Get the matched subscription plan""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(array = ArraySchema(schema = Schema(implementation = SubscriptionPlanResponse::class)))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/subscription/plan/list"
        value = [PATH_GET_SUBSCRIPTION_PLANS],
        produces = ["*/*"]
    )
    fun getSubscriptionPlans(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "Include visible only (true), hidden only (false), or all (null)") @Valid @RequestParam(value = "visible", required = false) visible: kotlin.Boolean?,
        @Parameter(description = "The role the plan is targeted for, values are: DEVELOPER, RETAILER, ADVERTISER") @Valid @RequestParam(value = "role", required = false) role: kotlin.String?
    ): ResponseEntity<List<SubscriptionPlanResponse>> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get Subscription Usage",
        operationId = "getSubscriptionUsage",
        description = """Use the accountId to determine the associated BillableEntity.  Then get the application usage.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = ApplicationUsageResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/subscription/usage/get"
        value = [PATH_GET_SUBSCRIPTION_USAGE],
        produces = ["*/*"]
    )
    fun getSubscriptionUsage(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The account used to perform the lookup", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @Parameter(description = "Get for just 1 application instead of the BillableEntity") @Valid @RequestParam(value = "applicationId", required = false) applicationId: kotlin.Long?,
        @Parameter(description = "The start time frame") @Valid @RequestParam(value = "start", required = false) start: kotlin.Long?,
        @Parameter(description = "The end time frame") @Valid @RequestParam(value = "end", required = false) end: kotlin.Long?
    ): ResponseEntity<ApplicationUsageResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get Text to Speach Result",
        operationId = "getTTS",
        description = """Check the status of an in progress Text-to-Speech call or download the result.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = OrsonAiTTSResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/orson/ai/tts/{requestId}"
        value = [PATH_GET_TTS],
        produces = ["*/*"]
    )
    fun getTTS(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "Orson Request Id", required = true) @PathVariable("requestId") requestId: kotlin.String,
        @NotNull @Parameter(description = "Sirqul Account Id", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long
    ): ResponseEntity<OrsonAiTTSResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get Task",
        operationId = "getTask",
        description = """Get a Task""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = TaskResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/task/get"
        value = [PATH_GET_TASK],
        produces = ["*/*"]
    )
    fun getTask(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The logged in user.", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "The id of the Task to return.", required = true) @Valid @RequestParam(value = "taskId", required = true) taskId: kotlin.Long
    ): ResponseEntity<TaskResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get TechTune Results",
        operationId = "getTechTune",
        description = """Get a result or continue waiting for a pending request for TechTune analysis.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = OrsonAiTechTuneResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/orson/ai/techTune/{requestId}"
        value = [PATH_GET_TECH_TUNE],
        produces = ["*/*"]
    )
    fun getTechTune(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "Orson Request Id", required = true) @PathVariable("requestId") requestId: kotlin.String,
        @NotNull @Parameter(description = "Sirqul Account Id", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long
    ): ResponseEntity<OrsonAiTechTuneResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get Territory",
        operationId = "getTerritory",
        description = """Get a territory.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = TerritoryResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/territory/get"
        value = [PATH_GET_TERRITORY],
        produces = ["*/*"]
    )
    fun getTerritory(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the id of the territory to get", required = true) @Valid @RequestParam(value = "territoryId", required = true) territoryId: kotlin.Long
    ): ResponseEntity<TerritoryResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get Theme",
        operationId = "getThemeDescriptor",
        description = """Gets a theme.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = PurchaseItemListResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/consumer/theme/get"
        value = [PATH_GET_THEME_DESCRIPTOR],
        produces = ["*/*"]
    )
    fun getThemeDescriptor(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the theme id", required = true) @Valid @RequestParam(value = "themeDescriptorId", required = true) themeDescriptorId: kotlin.Long,
        @Parameter(description = "a unique ID given by the device (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "the account ID of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "the application key") @Valid @RequestParam(value = "gameType", required = false) gameType: kotlin.String?,
        @Parameter(description = "latitude used to update the user's current location") @Valid @RequestParam(value = "latitude", required = false) latitude: kotlin.Double?,
        @Parameter(description = "longitude used to update the user's current location") @Valid @RequestParam(value = "longitude", required = false) longitude: kotlin.Double?
    ): ResponseEntity<PurchaseItemListResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Search Themes",
        operationId = "getThemeDescriptors",
        description = """Searches for themes.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = PurchaseItemListResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/consumer/theme/search"
        value = [PATH_GET_THEME_DESCRIPTORS],
        produces = ["*/*"]
    )
    fun getThemeDescriptors(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "a comma separated list of Ownership", required = true) @Valid @RequestParam(value = "filter", required = true) filter: kotlin.String,
        @NotNull @Parameter(description = "the field to sort by. See ThemeDescriptorApiMap", required = true) @Valid @RequestParam(value = "sortField", required = true) sortField: kotlin.String,
        @NotNull @Parameter(description = "determines whether the sorted list is in descending or ascending order", required = true) @Valid @RequestParam(value = "descending", required = true) descending: kotlin.Boolean,
        @NotNull @Parameter(description = "the start parameter for pagination", required = true) @Valid @RequestParam(value = "start", required = true) start: kotlin.Int,
        @NotNull @Parameter(description = "the limit parameter for pagination", required = true) @Valid @RequestParam(value = "limit", required = true) limit: kotlin.Int,
        @Parameter(description = "a unique id given by the device (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "the account id of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "the unique title of an application given from the admin tool") @Valid @RequestParam(value = "gameType", required = false) gameType: kotlin.String?,
        @Parameter(description = "contest type") @Valid @RequestParam(value = "contestType", required = false) contestType: kotlin.String?,
        @Parameter(description = "search on contests that an account has access to") @Valid @RequestParam(value = "ownerId", required = false) ownerId: kotlin.Long?,
        @Parameter(description = "This parameter is deprecated.") @Valid @RequestParam(value = "q", required = false) q: kotlin.String?,
        @Parameter(description = "a keyword to search on") @Valid @RequestParam(value = "keyword", required = false) keyword: kotlin.String?,
        @Parameter(description = "This parameter is deprecated.") @Valid @RequestParam(value = "_i", required = false) i: kotlin.Int?,
        @Parameter(description = "This parameter is deprecated.") @Valid @RequestParam(value = "_l", required = false) l: kotlin.Int?,
        @Parameter(description = "filter on items that have been created before this date") @Valid @RequestParam(value = "dateCreated", required = false) dateCreated: kotlin.Long?,
        @Parameter(description = "application version of the theme to filter by") @Valid @RequestParam(value = "appVersion", required = false) appVersion: kotlin.String?,
        @Parameter(description = "latitude used to update the user's current location") @Valid @RequestParam(value = "latitude", required = false) latitude: kotlin.Double?,
        @Parameter(description = "longitude used to update the user's current location") @Valid @RequestParam(value = "longitude", required = false) longitude: kotlin.Double?
    ): ResponseEntity<PurchaseItemListResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get Ticket Count",
        operationId = "getTicketCount",
        description = """Gets the ticket count.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = CountResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/ticket/count"
        value = [PATH_GET_TICKET_COUNT],
        produces = ["*/*"]
    )
    fun getTicketCount(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "the id of the device that owns the tickets") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "the id of the account that owns the tickets") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "this is deprecated.") @Valid @RequestParam(value = "gameType", required = false) gameType: kotlin.String?,
        @Parameter(description = "the applicationkey") @Valid @RequestParam(value = "appKey", required = false) appKey: kotlin.String?,
        @Parameter(description = "the type of ticket") @Valid @RequestParam(value = "ticketType", required = false) ticketType: kotlin.String?
    ): ResponseEntity<CountResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get Ticket List",
        operationId = "getTicketList",
        description = """Gets the list of tickets.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = TicketListResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/ticket/getList"
        value = [PATH_GET_TICKET_LIST],
        produces = ["*/*"]
    )
    fun getTicketList(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "the id of the device that owns the tickets") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "the id of the account that owns the tickets") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "comma separated list of TicketObjectType") @Valid @RequestParam(value = "ticketObjectType", required = false) ticketObjectType: kotlin.String?,
        @Parameter(description = "comma separated list of TicketActionType") @Valid @RequestParam(value = "actionType", required = false) actionType: kotlin.String?,
        @Parameter(description = "the ids of the tickets to get") @Valid @RequestParam(value = "ticketIds", required = false) ticketIds: kotlin.String?,
        @Parameter(description = "the ids of the objects to get") @Valid @RequestParam(value = "objectIds", required = false) objectIds: kotlin.String?,
        @Parameter(description = "") @Valid @RequestParam(value = "receiptTokens", required = false) receiptTokens: kotlin.String?,
        @Parameter(description = "") @Valid @RequestParam(value = "gameType", required = false) gameType: kotlin.String?,
        @Parameter(description = "the application key") @Valid @RequestParam(value = "appKey", required = false) appKey: kotlin.String?
    ): ResponseEntity<TicketListResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get Facebook Token",
        operationId = "getToken",
        description = """Gets a user's Facebook token.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = TokenResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/facebook/getfbtoken"
        value = [PATH_GET_TOKEN],
        produces = ["*/*"]
    )
    fun getToken(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "a unique id given by the device (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "the account id of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "used to update the user's current location") @Valid @RequestParam(value = "latitude", required = false) latitude: kotlin.Double?,
        @Parameter(description = "used to update the user's current location") @Valid @RequestParam(value = "longitude", required = false) longitude: kotlin.Double?
    ): ResponseEntity<TokenResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get Topics",
        operationId = "getTopics",
        description = """Get the result of an in progress Topics Analysis from an earlier POST.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = OrsonAiTopicsResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/orson/ai/topics/{requestId}"
        value = [PATH_GET_TOPICS],
        produces = ["*/*"]
    )
    fun getTopics(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "Orson Request Id", required = true) @PathVariable("requestId") requestId: kotlin.String,
        @NotNull @Parameter(description = "Sirqul Account Id", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long
    ): ResponseEntity<OrsonAiTopicsResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get Tournament",
        operationId = "getTournament",
        description = """Get a tournament.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = TournamentResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/tournament/get"
        value = [PATH_GET_TOURNAMENT],
        produces = ["*/*"]
    )
    fun getTournament(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The id of the logged in user", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @Parameter(description = "The id of the mission to return (either missionId or joinCode is required)") @Valid @RequestParam(value = "missionId", required = false) missionId: kotlin.Long?,
        @Parameter(description = "Optional identifier for getting the tournament (either missionId or joinCode is required)") @Valid @RequestParam(value = "joinCode", required = false) joinCode: kotlin.String?,
        @Parameter(description = "Determines which type of scores are returned. Possible values include: ALL, MINE", schema = Schema(allowableValues = ["ALL", "MINE"])) @Valid @RequestParam(value = "includeScores", required = false) includeScores: kotlin.String?,
        @Parameter(description = "Determines the max number of game objects that will get returned for each game level response", schema = Schema(defaultValue = "50")) @Valid @RequestParam(value = "objectPreviewSize", required = false, defaultValue = "50") objectPreviewSize: kotlin.Int
    ): ResponseEntity<TournamentResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Search Tracking",
        operationId = "getTrackingLegs",
        description = """Retrieve tracking data to be able to show where a user has been.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(array = ArraySchema(schema = Schema(implementation = LegResponse::class)))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/tracking/search"
        value = [PATH_GET_TRACKING_LEGS],
        produces = ["*/*"]
    )
    fun getTrackingLegs(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "the device id (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "the account id of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "the account id of the person the user wants to tracking data for") @Valid @RequestParam(value = "ownerId", required = false) ownerId: kotlin.Long?,
        @Parameter(description = "the id of the tracking device") @Valid @RequestParam(value = "trackingDeviceId", required = false) trackingDeviceId: kotlin.String?,
        @Parameter(description = "the start date in (UTC milliseconds) to filter the tracking results. If no startDate is passed in, the last 30 days will be returned.") @Valid @RequestParam(value = "startDate", required = false) startDate: kotlin.Long?,
        @Parameter(description = "the end date in (UTC milliseconds) to filter the tracking results") @Valid @RequestParam(value = "endDate", required = false) endDate: kotlin.Long?,
        @Parameter(description = "filter results by tag") @Valid @RequestParam(value = "tags", required = false) tags: kotlin.String?,
        @Parameter(description = "gets the last known location of the user", schema = Schema(defaultValue = "false")) @Valid @RequestParam(value = "getLastPoint", required = false, defaultValue = "false") getLastPoint: kotlin.Boolean
    ): ResponseEntity<List<LegResponse>> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get Trigger",
        operationId = "getTrigger",
        description = """Get a trigger""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = TriggerResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/trigger/get"
        value = [PATH_GET_TRIGGER],
        produces = ["*/*"]
    )
    fun getTrigger(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The logged in user.", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "The id of the Trigger to return.", required = true) @Valid @RequestParam(value = "triggerId", required = true) triggerId: kotlin.Long
    ): ResponseEntity<TriggerResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get Trip",
        operationId = "getTrip",
        description = """Get an existing trip""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = Trip::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/trip/{id}"
        value = [PATH_GET_TRIP],
        produces = ["*/*"]
    )
    fun getTrip(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "the id of the trip to get", required = true) @PathVariable("id") id: kotlin.Long
    ): ResponseEntity<Trip> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get Trip Matches",
        operationId = "getTripMatches",
        description = """Get matching trips of specific trip""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(array = ArraySchema(schema = Schema(implementation = Trip::class)))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/trip/{id}/match"
        value = [PATH_GET_TRIP_MATCHES],
        produces = ["*/*"]
    )
    fun getTripMatches(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "The id The id of the trip to search for matches for", required = true) @PathVariable("id") id: kotlin.Long,
        @NotNull @Parameter(description = "The field to sort by", required = true) @Valid @RequestParam(value = "sortField", required = true) sortField: kotlin.String,
        @NotNull @Parameter(description = "Determines whether the sorted list is in descending or ascending order", required = true) @Valid @RequestParam(value = "descending", required = true) descending: kotlin.Boolean,
        @NotNull @Parameter(description = "The start index for pagination", required = true) @Valid @RequestParam(value = "start", required = true) start: kotlin.Int,
        @NotNull @Parameter(description = "The limit for pagination", required = true) @Valid @RequestParam(value = "limit", required = true) limit: kotlin.Int,
        @NotNull @Parameter(description = "Return only active results", required = true) @Valid @RequestParam(value = "activeOnly", required = true) activeOnly: kotlin.Boolean,
        @Parameter(description = "Only return matchings that already have route assigned") @Valid @RequestParam(value = "matchedHasRoute", required = false) matchedHasRoute: kotlin.Boolean?,
        @Parameter(description = "Only return matchings that already have driver assigned") @Valid @RequestParam(value = "matchedHasDriver", required = false) matchedHasDriver: kotlin.Boolean?
    ): ResponseEntity<List<Trip>> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Search Application Users",
        operationId = "getUniqueUsersByApp",
        description = """Get a list of users per application""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = AccountListResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/application/users"
        value = [PATH_GET_UNIQUE_USERS_BY_APP],
        produces = ["*/*"]
    )
    fun getUniqueUsersByApp(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The application key", required = true) @Valid @RequestParam(value = "appKey", required = true) appKey: kotlin.String,
        @Parameter(description = "Q") @Valid @RequestParam(value = "q", required = false) q: kotlin.String?,
        @Parameter(description = "The keyword used to search") @Valid @RequestParam(value = "keyword", required = false) keyword: kotlin.String?,
        @Parameter(description = "Return accounts that have been active after this date (UNIX time-stamp in milliseconds)") @Valid @RequestParam(value = "since", required = false) since: kotlin.Long?,
        @Parameter(description = "the start of the index") @Valid @RequestParam(value = "_i", required = false) i: kotlin.Int?,
        @Parameter(description = "The start of the pagination", schema = Schema(defaultValue = "0")) @Valid @RequestParam(value = "start", required = false, defaultValue = "0") start: kotlin.Int,
        @Parameter(description = "the limit of the index") @Valid @RequestParam(value = "_l", required = false) l: kotlin.Int?,
        @Parameter(description = "The limit of the pagination", schema = Schema(defaultValue = "20")) @Valid @RequestParam(value = "limit", required = false, defaultValue = "20") limit: kotlin.Int
    ): ResponseEntity<AccountListResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get Achievement Progress",
        operationId = "getUserAchievements",
        description = """Gets a list of user achievements.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(array = ArraySchema(schema = Schema(implementation = AchievementProgressResponse::class)))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/achievement/progress/get"
        value = [PATH_GET_USER_ACHIEVEMENTS],
        produces = ["*/*"]
    )
    fun getUserAchievements(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "determines whether to return null fields in the response", required = true, schema = Schema(defaultValue = "true")) @Valid @RequestParam(value = "returnNulls", required = true, defaultValue = "true") returnNulls: kotlin.Boolean,
        @NotNull @Parameter(description = "the application key for filtering results by application", required = true) @Valid @RequestParam(value = "appKey", required = true) appKey: kotlin.String,
        @NotNull @Parameter(description = "determines whether to return achievements that the user has not discovered yet", required = true, schema = Schema(defaultValue = "true")) @Valid @RequestParam(value = "includeUndiscovered", required = true, defaultValue = "true") includeUndiscovered: kotlin.Boolean,
        @Parameter(description = "a unique id given by the device (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "the account id of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "the email of the account to view achievements") @Valid @RequestParam(value = "connectionAccountEmail", required = false) connectionAccountEmail: kotlin.String?,
        @Parameter(description = "the id of the account to view achievements") @Valid @RequestParam(value = "connectionAccountId", required = false) connectionAccountId: kotlin.Long?,
        @Parameter(description = "filter results by achievement rankType") @Valid @RequestParam(value = "rankType", required = false) rankType: kotlin.String?,
        @Parameter(description = "filter results by achievement type") @Valid @RequestParam(value = "achievementType", required = false) achievementType: kotlin.String?,
        @Parameter(description = "the current latitude of the user") @Valid @RequestParam(value = "latitude", required = false) latitude: kotlin.Double?,
        @Parameter(description = "the current longitude of the user") @Valid @RequestParam(value = "longitude", required = false) longitude: kotlin.Double?
    ): ResponseEntity<List<AchievementProgressResponse>> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get the coins for a user (as a Business)",
        operationId = "getUserCoinsAsBusiness",
        description = """Get the coins for a user (as a Business).""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation") ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/vatom/b/users/coins/get"
        value = [PATH_GET_USER_COINS_AS_BUSINESS]
    )
    fun getUserCoinsAsBusiness(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "Sirqul Account Id", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "Vatom User Id", required = true) @Valid @RequestParam(value = "vatomUserId", required = true) vatomUserId: kotlin.String,
        @NotNull @Parameter(description = "Sirqul Application Key", required = true) @Valid @RequestParam(value = "appKey", required = true) appKey: kotlin.String,
        @Parameter(description = "Return raw response") @Valid @RequestParam(value = "returnRawResponse", required = false) returnRawResponse: kotlin.Boolean?
    ): ResponseEntity<Unit> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Gets the coins balance for a Vatom User",
        operationId = "getUserCoinsBalance",
        description = """Gets the coins balance for a Vatom User.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation") ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/vatom/u/coins/get"
        value = [PATH_GET_USER_COINS_BALANCE]
    )
    fun getUserCoinsBalance(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "Sirqul Account Id", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "Vatom User Id", required = true) @Valid @RequestParam(value = "vatomUserId", required = true) vatomUserId: kotlin.String,
        @Parameter(description = "Vatom Parameters") @Valid @RequestParam(value = "vatomParameters", required = false) vatomParameters: kotlin.String?,
        @Parameter(description = "Return raw response") @Valid @RequestParam(value = "returnRawResponse", required = false) returnRawResponse: kotlin.Boolean?
    ): ResponseEntity<Unit> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get user followers",
        operationId = "getUserFollowers",
        description = """Get user followers.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation") ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/vatom/users/rels/followers"
        value = [PATH_GET_USER_FOLLOWERS]
    )
    fun getUserFollowers(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "Sirqul Account Id", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "Vatom User Id", required = true) @Valid @RequestParam(value = "vatomUserId", required = true) vatomUserId: kotlin.String,
        @Parameter(description = "Return raw response") @Valid @RequestParam(value = "returnRawResponse", required = false) returnRawResponse: kotlin.Boolean?
    ): ResponseEntity<Unit> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get user following",
        operationId = "getUserFollowing",
        description = """Get user following.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation") ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/vatom/users/rels/following"
        value = [PATH_GET_USER_FOLLOWING]
    )
    fun getUserFollowing(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "Sirqul Account Id", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "Vatom User Id", required = true) @Valid @RequestParam(value = "vatomUserId", required = true) vatomUserId: kotlin.String,
        @Parameter(description = "Return raw response") @Valid @RequestParam(value = "returnRawResponse", required = false) returnRawResponse: kotlin.Boolean?
    ): ResponseEntity<Unit> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get User Info",
        operationId = "getUserInfo",
        description = """Get a User's Info.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation") ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/vatom/user/get"
        value = [PATH_GET_USER_INFO]
    )
    fun getUserInfo(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "Sirqul Account Id", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "Vatom User Id", required = true) @Valid @RequestParam(value = "vatomUserId", required = true) vatomUserId: kotlin.String,
        @Parameter(description = "Return raw response") @Valid @RequestParam(value = "returnRawResponse", required = false) returnRawResponse: kotlin.Boolean?
    ): ResponseEntity<Unit> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get Vatom User Profile",
        operationId = "getUserProfile",
        description = """Gets the logged in user's profile in Vatom.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation") ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/vatom/me/get"
        value = [PATH_GET_USER_PROFILE]
    )
    fun getUserProfile(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "Sirqul Account Id", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @Parameter(description = "Return raw response") @Valid @RequestParam(value = "returnRawResponse", required = false) returnRawResponse: kotlin.Boolean?
    ): ResponseEntity<Unit> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get Personal Rankings",
        operationId = "getUserRank",
        description = """Returns the user's ranks for one or more rank types and modes.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = kotlin.Any::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/ranking/personal/ranks"
        value = [PATH_GET_USER_RANK],
        produces = ["*/*"]
    )
    fun getUserRank(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "a unique id given by the device (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "the account id of the user") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "the application key for filtering results by application (required)") @Valid @RequestParam(value = "appKey", required = false) appKey: kotlin.String?,
        @Parameter(description = "pass in all rankTypes and children rankTypes") @Valid @RequestParam(value = "rankType", required = false) rankType: kotlin.String?,
        @Parameter(description = "determines whether to return the user's current rank in the response, for each rankType", schema = Schema(defaultValue = "false")) @Valid @RequestParam(value = "returnUserRank", required = false, defaultValue = "false") returnUserRank: kotlin.Boolean,
        @Parameter(description = "the type of search to perform. Possible values include: GLOBAL, LOCAL, SEARCH, CUSTOM", schema = Schema(defaultValue = "GLOBAL")) @Valid @RequestParam(value = "leaderboardMode", required = false, defaultValue = "GLOBAL") leaderboardMode: kotlin.String,
        @Parameter(description = "determines how to order and rank the results. Possible values include: TOTAL, MONTHLY, WEEKLY, DAILY, TOP, LOWEST", schema = Schema(defaultValue = "TOTAL")) @Valid @RequestParam(value = "sortField", required = false, defaultValue = "TOTAL") sortField: kotlin.String,
        @Parameter(description = "keyword to search for (on rankType)") @Valid @RequestParam(value = "keyword", required = false) keyword: kotlin.String?,
        @Parameter(description = "determines whether to return results in descending order", schema = Schema(defaultValue = "true")) @Valid @RequestParam(value = "descending", required = false, defaultValue = "true") descending: kotlin.Boolean,
        @Parameter(description = "the start index for pagination", schema = Schema(defaultValue = "0")) @Valid @RequestParam(value = "start", required = false, defaultValue = "0") start: kotlin.Int,
        @Parameter(description = "the limit for pagination", schema = Schema(defaultValue = "100")) @Valid @RequestParam(value = "limit", required = false, defaultValue = "100") limit: kotlin.Int
    ): ResponseEntity<kotlin.Any> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get Vatom Event",
        operationId = "getVatomEvent",
        description = """Gets the details of a event.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation") ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/vatom/b/events/get"
        value = [PATH_GET_VATOM_EVENT]
    )
    fun getVatomEvent(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "Sirqul Account Id", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "Sirqul Application Key", required = true) @Valid @RequestParam(value = "appKey", required = true) appKey: kotlin.String,
        @NotNull @Parameter(description = "Vatom Event Id", required = true) @Valid @RequestParam(value = "vatomEventId", required = true) vatomEventId: kotlin.String,
        @Parameter(description = "Return raw response") @Valid @RequestParam(value = "returnRawResponse", required = false) returnRawResponse: kotlin.Boolean?
    ): ResponseEntity<Unit> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get Vatom NFT Details",
        operationId = "getVatomNFT",
        description = """Get Vatom NFT Details""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation") ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/vatom/vatoms/get"
        value = [PATH_GET_VATOM_NFT]
    )
    fun getVatomNFT(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "Sirqul Account Id", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "Vatom NFT Id", required = true) @Valid @RequestParam(value = "vatomId", required = true) vatomId: kotlin.String,
        @Parameter(description = "Return raw response") @Valid @RequestParam(value = "returnRawResponse", required = false) returnRawResponse: kotlin.Boolean?
    ): ResponseEntity<Unit> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get Vehicle",
        operationId = "getVehicle",
        description = """Get an existing vehicle""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = Vehicle::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/vehicle/{id}"
        value = [PATH_GET_VEHICLE],
        produces = ["*/*"]
    )
    fun getVehicle(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "The id of the vehicle requested", required = true) @PathVariable("id") id: kotlin.Long
    ): ResponseEntity<Vehicle> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get Vehicle Type",
        operationId = "getVehicleType",
        description = """Get a vehicle type""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = VehicleType::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/vehicle/type/{vehicleTypeId}"
        value = [PATH_GET_VEHICLE_TYPE],
        produces = ["*/*"]
    )
    fun getVehicleType(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "The id of the requested vehicle type", required = true) @PathVariable("vehicleTypeId") vehicleTypeId: kotlin.Long
    ): ResponseEntity<VehicleType> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get VoiceCanvas images",
        operationId = "getVoiceCanvas",
        description = """Get a result or continue waiting for a pending request for VoiceCanvas Images.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = OrsonAiVoiceCanvasResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/orson/ai/voiceCanvas/{requestId}"
        value = [PATH_GET_VOICE_CANVAS],
        produces = ["*/*"]
    )
    fun getVoiceCanvas(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "Orson Request Id", required = true) @PathVariable("requestId") requestId: kotlin.String,
        @NotNull @Parameter(description = "Sirqul Account Id", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long
    ): ResponseEntity<OrsonAiVoiceCanvasResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get Word",
        operationId = "getWord",
        description = """Get a word by the given id.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = WordzWordResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/game/word/get"
        value = [PATH_GET_WORD],
        produces = ["*/*"]
    )
    fun getWord(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The id of the word to get.", required = true) @Valid @RequestParam(value = "wordId", required = true) wordId: kotlin.Long,
        @NotNull @Parameter(description = "The logged in user.", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long
    ): ResponseEntity<WordzWordResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Search Words",
        operationId = "getWords",
        description = """Search for words by the given params.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(array = ArraySchema(schema = Schema(implementation = WordzWordResponse::class)))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/game/word/search"
        value = [PATH_GET_WORDS],
        produces = ["*/*"]
    )
    fun getWords(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The logged in user.", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "The column to sort the search on", required = true, schema = Schema(defaultValue = "id")) @Valid @RequestParam(value = "sortField", required = true, defaultValue = "id") sortField: kotlin.String,
        @NotNull @Parameter(description = "The order to return the search results", required = true, schema = Schema(defaultValue = "false")) @Valid @RequestParam(value = "descending", required = true, defaultValue = "false") descending: kotlin.Boolean,
        @NotNull @Parameter(description = "Return only active results if set to true.", required = true, schema = Schema(defaultValue = "false")) @Valid @RequestParam(value = "activeOnly", required = true, defaultValue = "false") activeOnly: kotlin.Boolean,
        @NotNull @Parameter(description = "The record to begin the return set on.", required = true, schema = Schema(defaultValue = "0")) @Valid @RequestParam(value = "start", required = true, defaultValue = "0") start: kotlin.Int,
        @NotNull @Parameter(description = "The number of records to return.", required = true, schema = Schema(defaultValue = "20")) @Valid @RequestParam(value = "limit", required = true, defaultValue = "20") limit: kotlin.Int,
        @Parameter(description = "The keyword for searching words with matching definition or word text.") @Valid @RequestParam(value = "keyword", required = false) keyword: kotlin.String?
    ): ResponseEntity<List<WordzWordResponse>> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get Level Words",
        operationId = "getWordsInLevel",
        description = """Get words within a level.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = WordzWordResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/level/words/get"
        value = [PATH_GET_WORDS_IN_LEVEL],
        produces = ["*/*"]
    )
    fun getWordsInLevel(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the id of the level to get words for", required = true) @Valid @RequestParam(value = "levelId", required = true) levelId: kotlin.Long,
        @NotNull @Parameter(description = "the id of the logged in user", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long
    ): ResponseEntity<WordzWordResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Gift Tickets",
        operationId = "giftPurchase",
        description = """Gift tickets to another user.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/purchase/gift"
        value = [PATH_GIFT_PURCHASE],
        produces = ["*/*"]
    )
    fun giftPurchase(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the id of the account receiving the tickets", required = true) @Valid @RequestParam(value = "receiverAccountId", required = true) receiverAccountId: kotlin.Long,
        @NotNull @Parameter(description = "the id of the tickets", required = true) @Valid @RequestParam(value = "ticketId", required = true) ticketId: kotlin.Long,
        @Parameter(description = "the id of the device") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "the id of the gift owner") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "the id of the asset") @Valid @RequestParam(value = "assetId", required = false) assetId: kotlin.Long?,
        @Parameter(description = "a message that can be written to go along with the gift") @Valid @RequestParam(value = "customMessage", required = false) customMessage: kotlin.String?,
        @Parameter(description = "the type of game associated with the tickets") @Valid @RequestParam(value = "gameType", required = false) gameType: kotlin.String?,
        @Parameter(description = "the application key") @Valid @RequestParam(value = "appKey", required = false) appKey: kotlin.String?
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Post to Facebook",
        operationId = "graphInterface",
        description = """Make Facebook posts on behalf of the user.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/facebook/graph"
        value = [PATH_GRAPH_INTERFACE],
        produces = ["*/*"]
    )
    fun graphInterface(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the type of Sirqul event {DOWNLOADED_APP, CHALLENGE, LEVEL_COMPLETED, LEVEL_CREATED}", required = true) @Valid @RequestParam(value = "event", required = true) event: kotlin.String,
        @Parameter(description = "a unique id given by the device (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "the account id of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "for posting about information related to an object. Possible types: {ALBUM, ALBUM_CONTEST, GAME_LEVEL, THEME_DESCRIPTOR}") @Valid @RequestParam(value = "permissionableType", required = false) permissionableType: kotlin.String?,
        @Parameter(description = "the object id") @Valid @RequestParam(value = "permissionableId", required = false) permissionableId: kotlin.Long?,
        @Parameter(description = "used to include an asset on a Facebook post") @Valid @RequestParam(value = "assetId", required = false) assetId: kotlin.Long?,
        @Parameter(description = "This parameter is deprecated.") @Valid @RequestParam(value = "gameType", required = false) gameType: kotlin.String?,
        @Parameter(description = "the application key") @Valid @RequestParam(value = "appKey", required = false) appKey: kotlin.String?,
        @Parameter(description = "used to update the user's current location") @Valid @RequestParam(value = "latitude", required = false) latitude: kotlin.Double?,
        @Parameter(description = "used to update the user's current location") @Valid @RequestParam(value = "longitude", required = false) longitude: kotlin.Double?
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Search Connection Groups",
        operationId = "groupSearch",
        description = """Gets a user's private groups and default groups.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(array = ArraySchema(schema = Schema(implementation = ConnectionInfoResponse::class)))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/connection/group/search"
        value = [PATH_GROUP_SEARCH],
        produces = ["*/*"]
    )
    fun groupSearch(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the field to sort by", required = true, schema = Schema(allowableValues = ["CREATED", "UPDATED", "ACTIVE", "NAME", "DESCRIPTION", "CAN_VIEW_PROFILE_INFO", "CAN_VIEW_GAME_INFO", "CAN_VIEW_FRIEND_INFO", "INVITE_CODE", "OWNER_DISPLAY", "OWNER_USERNAME"])) @Valid @RequestParam(value = "sortField", required = true) sortField: kotlin.String,
        @NotNull @Parameter(description = "whether to return results in descending or ascending order", required = true) @Valid @RequestParam(value = "descending", required = true) descending: kotlin.Boolean,
        @NotNull @Parameter(description = "to search on active only or not", required = true) @Valid @RequestParam(value = "activeOnly", required = true) activeOnly: kotlin.Boolean,
        @NotNull @Parameter(description = "The start of the pagination", required = true) @Valid @RequestParam(value = "start", required = true) start: kotlin.Int,
        @NotNull @Parameter(description = "the limit of the pagination", required = true) @Valid @RequestParam(value = "limit", required = true) limit: kotlin.Int,
        @Parameter(description = "the device id (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "the account id of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "the current latitude of the user") @Valid @RequestParam(value = "latitude", required = false) latitude: kotlin.Double?,
        @Parameter(description = "the current longitude of the user") @Valid @RequestParam(value = "longitude", required = false) longitude: kotlin.Double?,
        @Parameter(description = "keyword search string") @Valid @RequestParam(value = "keyword", required = false) keyword: kotlin.String?
    ): ResponseEntity<List<ConnectionInfoResponse>> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Generate images with OpenAI",
        operationId = "imageGeneration",
        description = """Generate images with OpenAI.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = WrappedProxyItemResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/openai/v1/images/generations"
        value = [PATH_IMAGE_GENERATION],
        produces = ["*/*"]
    )
    fun imageGeneration(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "Sirqul Account Id", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "Post Body Parameters", required = true) @Valid @RequestParam(value = "postBody", required = true) postBody: kotlin.String,
        @Parameter(description = "Return raw response") @Valid @RequestParam(value = "returnRawResponse", required = false) returnRawResponse: kotlin.Boolean?
    ): ResponseEntity<WrappedProxyItemResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Import Mission",
        operationId = "importMission",
        description = """Create a mission using a source item such as an offer location.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/mission/import"
        value = [PATH_IMPORT_MISSION],
        produces = ["*/*"]
    )
    fun importMission(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The logged in user.", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "The current location of the requesting device", required = true) @Valid @RequestParam(value = "latitude", required = true) latitude: kotlin.Double,
        @NotNull @Parameter(description = "The current location of the requesting device", required = true) @Valid @RequestParam(value = "longitude", required = true) longitude: kotlin.Double,
        @NotNull @Parameter(description = "the application key", required = true) @Valid @RequestParam(value = "appKey", required = true) appKey: kotlin.String,
        @Parameter(description = "the keyword of the mission") @Valid @RequestParam(value = "keyword", required = false) keyword: kotlin.String?,
        @Parameter(description = "The starting index in the result set to return. Default is 0.") @Valid @RequestParam(value = "start", required = false) start: kotlin.Int?,
        @Parameter(description = "The total number of records to return. Default is 20.") @Valid @RequestParam(value = "limit", required = false) limit: kotlin.Int?,
        @Parameter(description = "the size of the ad", schema = Schema(allowableValues = ["CONFIG", "BANNER", "LEADERBOARD", "SKYSCRAPER", "VIDEO", "ZIP", "INTERSTITIAL", "CUSTOM1", "CUSTOM2", "CUSTOM3", "CUSTOM4", "CUSTOM5", "CUSTOM6", "CUSTOM7", "CUSTOM8", "CUSTOM9", "CUSTOM10"])) @Valid @RequestParam(value = "adSize", required = false) adSize: kotlin.String?
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Distance Search Retailer Locations (Indexed)",
        operationId = "indexedRetailerLocationDistanceSearch",
        description = """Retailer location indexed search by distance. This searches on any retailer location with location data and returns the results sorted by distance.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(array = ArraySchema(schema = Schema(implementation = RetailerLocationResponse::class)))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/retailer/location/idistancesearch"
        value = [PATH_INDEXED_RETAILER_LOCATION_DISTANCE_SEARCH],
        produces = ["*/*"]
    )
    fun indexedRetailerLocationDistanceSearch(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The latitude to center the search on", required = true) @Valid @RequestParam(value = "latitude", required = true) latitude: kotlin.Double,
        @NotNull @Parameter(description = "The longitude to center the search on", required = true) @Valid @RequestParam(value = "longitude", required = true) longitude: kotlin.Double,
        @NotNull @Parameter(description = "The search range in the distanceUnit specified; default is MILES.", required = true) @Valid @RequestParam(value = "searchRange", required = true) searchRange: kotlin.Double,
        @NotNull @Parameter(description = "The start index for pagination", required = true) @Valid @RequestParam(value = "start", required = true) start: kotlin.Int,
        @NotNull @Parameter(description = "The limit for pagination", required = true) @Valid @RequestParam(value = "limit", required = true) limit: kotlin.Int,
        @Parameter(description = "The account id of the user") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "Used to return results using this address as the center") @Valid @RequestParam(value = "address", required = false) address: kotlin.String?,
        @Parameter(description = "boolean to indicate whether to include retailer locations that have no offers") @Valid @RequestParam(value = "hasOffers", required = false) hasOffers: kotlin.Boolean?,
        @Parameter(description = "Comma separate list of category ids") @Valid @RequestParam(value = "categories", required = false) categories: kotlin.String?,
        @Parameter(description = "Comma separated list of filter ids") @Valid @RequestParam(value = "filters", required = false) filters: kotlin.String?,
        @Parameter(description = "Comma separated list of audience ids") @Valid @RequestParam(value = "audiences", required = false) audiences: kotlin.String?,
        @Parameter(description = "Comma separated list of retailer ids") @Valid @RequestParam(value = "retailerIds", required = false) retailerIds: kotlin.String?,
        @Parameter(description = "Comma separated list of retailer location ids") @Valid @RequestParam(value = "retailerLocationIds", required = false) retailerLocationIds: kotlin.String?,
        @Parameter(description = "Does a full-text search on tags") @Valid @RequestParam(value = "tags", required = false) tags: kotlin.String?,
        @Parameter(description = "Location type filter") @Valid @RequestParam(value = "locationType", required = false) locationType: kotlin.String?,
        @Parameter(description = "The field to sort the result set on. Possible values include: DISTANCE, RETAILER_NAME, RETAILER_LOCATION_NAME") @Valid @RequestParam(value = "sortField", required = false) sortField: kotlin.String?,
        @Parameter(description = "Determines whether the sorted list is in descending or ascending order") @Valid @RequestParam(value = "descending", required = false) descending: kotlin.Boolean?,
        @Parameter(description = "This parameter is deprecated.") @Valid @RequestParam(value = "q", required = false) q: kotlin.String?,
        @Parameter(description = "Search by keyword") @Valid @RequestParam(value = "keyword", required = false) keyword: kotlin.String?,
        @Parameter(description = "Determines the operator used when there are multiple words in the 'keyword' parameter") @Valid @RequestParam(value = "keywordOperator", required = false) keywordOperator: kotlin.String?,
        @Parameter(description = "Search expression to further refine results") @Valid @RequestParam(value = "searchExpression", required = false) searchExpression: kotlin.String?,
        @Parameter(description = "Unit of distance", schema = Schema(allowableValues = ["MILES", "KILOMETERS"])) @Valid @RequestParam(value = "distanceUnit", required = false) distanceUnit: kotlin.String?,
        @Parameter(description = "(deprecated) return favorited flag") @Valid @RequestParam(value = "returnFavorited", required = false) returnFavorited: kotlin.Boolean?,
        @Parameter(description = "Return retailer info") @Valid @RequestParam(value = "returnRetailer", required = false) returnRetailer: kotlin.Boolean?,
        @Parameter(description = "Return assets") @Valid @RequestParam(value = "returnAssets", required = false) returnAssets: kotlin.Boolean?,
        @Parameter(description = "Return offers") @Valid @RequestParam(value = "returnOffers", required = false) returnOffers: kotlin.Boolean?,
        @Parameter(description = "Return categories") @Valid @RequestParam(value = "returnCategories", required = false) returnCategories: kotlin.Boolean?,
        @Parameter(description = "Return filters") @Valid @RequestParam(value = "returnFilters", required = false) returnFilters: kotlin.Boolean?,
        @Parameter(description = "Return audiences") @Valid @RequestParam(value = "returnAudiences", required = false) returnAudiences: kotlin.Boolean?,
        @Parameter(description = "Return QR code info") @Valid @RequestParam(value = "returnQrCode", required = false) returnQrCode: kotlin.Boolean?,
        @Parameter(description = "Return external category data") @Valid @RequestParam(value = "returnExternalCategoryData", required = false) returnExternalCategoryData: kotlin.Boolean?,
        @Parameter(description = "Include favorites in response") @Valid @RequestParam(value = "includeFavorite", required = false) includeFavorite: kotlin.Boolean?,
        @Parameter(description = "Include liked flag in response") @Valid @RequestParam(value = "includeLiked", required = false) includeLiked: kotlin.Boolean?,
        @Parameter(description = "Include rating info in response") @Valid @RequestParam(value = "includeRating", required = false) includeRating: kotlin.Boolean?
    ): ResponseEntity<List<RetailerLocationResponse>> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Keyword Search Retailer Locations (Indexed)",
        operationId = "indexedRetailerLocationSearch",
        description = """Retailer location (faster) indexed search. This searches all retailer locations.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(array = ArraySchema(schema = Schema(implementation = RetailerLocationResponse::class)))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/retailer/location/isearch"
        value = [PATH_INDEXED_RETAILER_LOCATION_SEARCH],
        produces = ["*/*"]
    )
    fun indexedRetailerLocationSearch(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "The account id of the user") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "The start index for pagination") @Valid @RequestParam(value = "start", required = false) start: kotlin.Int?,
        @Parameter(description = "The limit for pagination") @Valid @RequestParam(value = "limit", required = false) limit: kotlin.Int?,
        @Parameter(description = "boolean to indicate whether to include retailer locations that have no offers") @Valid @RequestParam(value = "hasOffers", required = false) hasOffers: kotlin.Boolean?,
        @Parameter(description = "Comma separate list of category ids") @Valid @RequestParam(value = "categories", required = false) categories: kotlin.String?,
        @Parameter(description = "Comma separated list of filter ids") @Valid @RequestParam(value = "filters", required = false) filters: kotlin.String?,
        @Parameter(description = "Comma separated list of audience ids") @Valid @RequestParam(value = "audiences", required = false) audiences: kotlin.String?,
        @Parameter(description = "Comma separated list of retailer ids") @Valid @RequestParam(value = "retailerIds", required = false) retailerIds: kotlin.String?,
        @Parameter(description = "Comma separated list of retailer location ids") @Valid @RequestParam(value = "retailerLocationIds", required = false) retailerLocationIds: kotlin.String?,
        @Parameter(description = "Does a full-text search on tags") @Valid @RequestParam(value = "tags", required = false) tags: kotlin.String?,
        @Parameter(description = "Location type filter") @Valid @RequestParam(value = "locationType", required = false) locationType: kotlin.String?,
        @Parameter(description = "The field to sort the result set on. Possible values include: RETAILER_NAME, RETAILER_LOCATION_NAME") @Valid @RequestParam(value = "sortField", required = false) sortField: kotlin.String?,
        @Parameter(description = "Determines whether the sorted list is in descending or ascending order") @Valid @RequestParam(value = "descending", required = false) descending: kotlin.Boolean?,
        @Parameter(description = "This parameter is deprecated.") @Valid @RequestParam(value = "q", required = false) q: kotlin.String?,
        @Parameter(description = "Search by keyword") @Valid @RequestParam(value = "keyword", required = false) keyword: kotlin.String?,
        @Parameter(description = "Determines the operator used when there are multiple words in the 'keyword' parameter") @Valid @RequestParam(value = "keywordOperator", required = false) keywordOperator: kotlin.String?,
        @Parameter(description = "Search expression to further refine results") @Valid @RequestParam(value = "searchExpression", required = false) searchExpression: kotlin.String?,
        @Parameter(description = "Return retailer info") @Valid @RequestParam(value = "returnRetailer", required = false) returnRetailer: kotlin.Boolean?,
        @Parameter(description = "Return assets") @Valid @RequestParam(value = "returnAssets", required = false) returnAssets: kotlin.Boolean?,
        @Parameter(description = "Return offers") @Valid @RequestParam(value = "returnOffers", required = false) returnOffers: kotlin.Boolean?,
        @Parameter(description = "Return categories") @Valid @RequestParam(value = "returnCategories", required = false) returnCategories: kotlin.Boolean?,
        @Parameter(description = "Return filters") @Valid @RequestParam(value = "returnFilters", required = false) returnFilters: kotlin.Boolean?,
        @Parameter(description = "Return audiences") @Valid @RequestParam(value = "returnAudiences", required = false) returnAudiences: kotlin.Boolean?,
        @Parameter(description = "Return QR code info") @Valid @RequestParam(value = "returnQrCode", required = false) returnQrCode: kotlin.Boolean?,
        @Parameter(description = "Return external category data") @Valid @RequestParam(value = "returnExternalCategoryData", required = false) returnExternalCategoryData: kotlin.Boolean?,
        @Parameter(description = "Include favorites in response") @Valid @RequestParam(value = "includeFavorite", required = false) includeFavorite: kotlin.Boolean?,
        @Parameter(description = "Include liked flag in response") @Valid @RequestParam(value = "includeLiked", required = false) includeLiked: kotlin.Boolean?,
        @Parameter(description = "Include rating info in response") @Valid @RequestParam(value = "includeRating", required = false) includeRating: kotlin.Boolean?
    ): ResponseEntity<List<RetailerLocationResponse>> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Leave Album",
        operationId = "leaveAlbum",
        description = """ Allows a user to leave an album (they are no longer considered a participant). The album creator cannot leave their own albums.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/album/user/leave"
        value = [PATH_LEAVE_ALBUM],
        produces = ["*/*"]
    )
    fun leaveAlbum(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the album ID", required = true) @Valid @RequestParam(value = "albumId", required = true) albumId: kotlin.Long,
        @Parameter(description = "a unique ID given by the device (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "the account ID of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Leave",
        operationId = "leaveFromPermissionable",
        description = """Used when the user wants to leave from someone else's permissionable object""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/consumer/permissions/leave"
        value = [PATH_LEAVE_FROM_PERMISSIONABLE],
        produces = ["*/*"]
    )
    fun leaveFromPermissionable(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the permissionable type PermissionableType", required = true) @Valid @RequestParam(value = "permissionableType", required = true) permissionableType: kotlin.String,
        @NotNull @Parameter(description = "the id of the permissionable object", required = true) @Valid @RequestParam(value = "permissionableId", required = true) permissionableId: kotlin.Long,
        @Parameter(description = "the device id (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "the account id of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "the current latitude of the user") @Valid @RequestParam(value = "latitude", required = false) latitude: kotlin.Double?,
        @Parameter(description = "the current longitude of the user") @Valid @RequestParam(value = "longitude", required = false) longitude: kotlin.Double?
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "List Achievement Tags",
        operationId = "listAchievementTags",
        description = """List achievement tags by application""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/achievement/tag/list"
        value = [PATH_LIST_ACHIEVEMENT_TAGS],
        produces = ["*/*"]
    )
    fun listAchievementTags(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "filter results by application key") @Valid @RequestParam(value = "appKey", required = false) appKey: kotlin.String?
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "List Achievements",
        operationId = "listAchievements",
        description = """List achievements by billable.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(array = ArraySchema(schema = Schema(implementation = AchievementShortResponse::class)))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/achievement/list"
        value = [PATH_LIST_ACHIEVEMENTS],
        produces = ["*/*"]
    )
    fun listAchievements(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the field to sort by. See AchievementApiMap", required = true, schema = Schema(allowableValues = ["CREATED", "UPDATED", "DELETED", "SEARCH_TAGS", "ACTIVE", "TITLE", "DESCRIPTION", "RANK_TYPE", "APPLICATION_ID", "APPLICATION_NAME", "BILLABLE_ID"])) @Valid @RequestParam(value = "sortField", required = true) sortField: kotlin.String,
        @NotNull @Parameter(description = "determines whether the sorted list is in descending or ascending order", required = true) @Valid @RequestParam(value = "descending", required = true) descending: kotlin.Boolean,
        @NotNull @Parameter(description = "the start index for pagination", required = true) @Valid @RequestParam(value = "start", required = true) start: kotlin.Int,
        @NotNull @Parameter(description = "the limit for pagination (has a hard limit of 1000)", required = true) @Valid @RequestParam(value = "limit", required = true) limit: kotlin.Int,
        @NotNull @Parameter(description = "Filter results to only return active achievements", required = true) @Valid @RequestParam(value = "activeOnly", required = true) activeOnly: kotlin.Boolean,
        @Parameter(description = "a unique id given by the device (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "the account id of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "the application key") @Valid @RequestParam(value = "appKey", required = false) appKey: kotlin.String?,
        @Parameter(description = "the keyword used to filter results with (this returns results that have the keyword in the title or description of the achievement)") @Valid @RequestParam(value = "keyword", required = false) keyword: kotlin.String?,
        @Parameter(description = "filter results by the achievementType (these are exact case sensitive matches)") @Valid @RequestParam(value = "achievementType", required = false) achievementType: kotlin.String?,
        @Parameter(description = "filter results by the rankType (these are exact case sensitive matches)") @Valid @RequestParam(value = "rankType", required = false) rankType: kotlin.String?
    ): ResponseEntity<List<AchievementShortResponse>> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "List Applications",
        operationId = "listApplications",
        description = """List active applications matching the criteria (as a consumer)""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(array = ArraySchema(schema = Schema(implementation = ApplicationShortResponse::class)))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/application/list"
        value = [PATH_LIST_APPLICATIONS],
        produces = ["*/*"]
    )
    fun listApplications(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "The account id of the application owner/manager") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "Q") @Valid @RequestParam(value = "q", required = false) q: kotlin.String?,
        @Parameter(description = "The keyword used to search for title, about, and description fields") @Valid @RequestParam(value = "keyword", required = false) keyword: kotlin.String?,
        @Parameter(description = "Deprecated, use deviceIds and deviceVersions") @Valid @RequestParam(value = "platforms", required = false) platforms: kotlin.String?,
        @Parameter(description = "The list of targeted device ids, comma separated; possible values are retreived via /api/{version/audience/devices com.sirqul.geoapps.common.service.AudienceApi#getDevices getDevices (pass in deviceId values)") @Valid @RequestParam(value = "deviceIds", required = false) deviceIds: kotlin.String?,
        @Parameter(description = "The list of targeted device version ranges that are aligned  with the provided devices list (see devices param for possible values),  comma separated; examples are: 2.3-X, 0-5.1.4, 4.3.1-6.1.4 where X  is no maximum and 0 is no minimum. ") @Valid @RequestParam(value = "deviceVersions", required = false) deviceVersions: kotlin.String?,
        @Parameter(description = "The list of category ids to filter the list by") @Valid @RequestParam(value = "categoryIds", required = false) categoryIds: kotlin.String?,
        @Parameter(description = "The column to sort the search on, possible values include: UPDATED (default), CREATED, TITLE", schema = Schema(allowableValues = ["CREATED", "UPDATED", "DELETED", "SEARCH_TAGS", "ACTIVE", "HAS_ADVERTISEMENTS", "PUBLIC_NOTIFICATIONS", "PLACEMENTS", "BILLABLE_ENTITY_ID", "BILLABLE_ENTITY_NAME", "RESPONSIBLE_DISPLAY", "TITLE", "NAME", "ABOUT", "DESCRIPTION", "APPLICATION_ID", "APP_TYPE", "GAME_TYPE", "BUNDLE_ID", "SCORING_TYPE", "LANDING_PAGE_URL", "EULA_VERSION", "BUILD_VERSION", "API_VERSION"], defaultValue = "UPDATED")) @Valid @RequestParam(value = "sortField", required = false, defaultValue = "UPDATED") sortField: kotlin.String,
        @Parameter(description = "Filter results on whether the application supports ads or not. Ignore this parameter to return all results.") @Valid @RequestParam(value = "hasAds", required = false) hasAds: kotlin.Boolean?,
        @Parameter(description = "Filter results on whether the application is available for public trigger notifications") @Valid @RequestParam(value = "publicNotifications", required = false) publicNotifications: kotlin.Boolean?,
        @Parameter(description = "Determines whether to only return applications that the user has access to") @Valid @RequestParam(value = "filterBillable", required = false) filterBillable: kotlin.Boolean?,
        @Parameter(description = "Determines whether to only return applications that the user is a content admin of") @Valid @RequestParam(value = "filterContentAdmin", required = false) filterContentAdmin: kotlin.Boolean?,
        @Parameter(description = "The order to return the search results", schema = Schema(defaultValue = "true")) @Valid @RequestParam(value = "descending", required = false, defaultValue = "true") descending: kotlin.Boolean,
        @Parameter(description = "the start of the index") @Valid @RequestParam(value = "_i", required = false) i: kotlin.Int?,
        @Parameter(description = "The start of the pagination", schema = Schema(defaultValue = "0")) @Valid @RequestParam(value = "start", required = false, defaultValue = "0") start: kotlin.Int,
        @Parameter(description = "The limit of the index") @Valid @RequestParam(value = "_l", required = false) l: kotlin.Int?,
        @Parameter(description = "The limit of the pagination", schema = Schema(defaultValue = "20")) @Valid @RequestParam(value = "limit", required = false, defaultValue = "20") limit: kotlin.Int,
        @Parameter(description = "The list of application ids, comma separated. If provided will ignore all other params.") @Valid @RequestParam(value = "applicationIds", required = false) applicationIds: kotlin.String?,
        @Parameter(description = "Only include applications with a object store (default is false)", schema = Schema(defaultValue = "false")) @Valid @RequestParam(value = "hasObjectStore", required = false, defaultValue = "false") hasObjectStore: kotlin.Boolean,
        @Parameter(description = "Return only active results", schema = Schema(defaultValue = "true")) @Valid @RequestParam(value = "activeOnly", required = false, defaultValue = "true") activeOnly: kotlin.Boolean
    ): ResponseEntity<List<ApplicationShortResponse>> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "List Suggestions by Audience",
        operationId = "listByAccount",
        description = """List either Missions or Offers that the user matches the assigned audience.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = OfferListResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/audience/suggestion/list"
        value = [PATH_LIST_BY_ACCOUNT],
        produces = ["*/*"]
    )
    fun listByAccount(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The account to match offers for.", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "the limit of the index", required = true) @Valid @RequestParam(value = "limit", required = true) limit: kotlin.Int,
        @NotNull @Parameter(description = "the type of suggestion", required = true) @Valid @RequestParam(value = "suggestionType", required = true) suggestionType: kotlin.String
    ): ResponseEntity<OfferListResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "List Offers by Audience",
        operationId = "listByAudience",
        description = """Get a list of offer locations based on audience information provided.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = OfferListResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/audience/suggestion/offersByAudience"
        value = [PATH_LIST_BY_AUDIENCE],
        produces = ["*/*"]
    )
    fun listByAudience(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "this is the limit of the index", required = true) @Valid @RequestParam(value = "limit", required = true) limit: kotlin.Int,
        @Parameter(description = "this is the gender to list offers by") @Valid @RequestParam(value = "gender", required = false) gender: kotlin.String?,
        @Parameter(description = "this is the age to list offers by") @Valid @RequestParam(value = "age", required = false) age: kotlin.Int?,
        @Parameter(description = "this is the category IDs to list offers by") @Valid @RequestParam(value = "categoryIds", required = false) categoryIds: kotlin.String?,
        @Parameter(description = "this is the latitude to list offers by") @Valid @RequestParam(value = "latitude", required = false) latitude: kotlin.Double?,
        @Parameter(description = "this is the longitude to list offers by") @Valid @RequestParam(value = "longitude", required = false) longitude: kotlin.Double?
    ): ResponseEntity<OfferListResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "List Vatom Communities",
        operationId = "listCommunities",
        description = """Gets the communities tied to a business.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation") ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/vatom/b/communities/search"
        value = [PATH_LIST_COMMUNITIES]
    )
    fun listCommunities(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "Sirqul Account Id", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "Sirqul Application Key", required = true) @Valid @RequestParam(value = "appKey", required = true) appKey: kotlin.String,
        @Parameter(description = "Vatom Parameters") @Valid @RequestParam(value = "vatomParameters", required = false) vatomParameters: kotlin.String?,
        @Parameter(description = "Return raw response") @Valid @RequestParam(value = "returnRawResponse", required = false) returnRawResponse: kotlin.Boolean?
    ): ResponseEntity<Unit> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "List Vatom Events",
        operationId = "listEvents",
        description = """Gets the events tied to a business.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation") ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/vatom/b/events/search"
        value = [PATH_LIST_EVENTS]
    )
    fun listEvents(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "Sirqul Account Id", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "Sirqul Application Key", required = true) @Valid @RequestParam(value = "appKey", required = true) appKey: kotlin.String,
        @Parameter(description = "Vatom Parameters") @Valid @RequestParam(value = "vatomParameters", required = false) vatomParameters: kotlin.String?,
        @Parameter(description = "Return raw response") @Valid @RequestParam(value = "returnRawResponse", required = false) returnRawResponse: kotlin.Boolean?
    ): ResponseEntity<Unit> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "List Sent Suggestions ",
        operationId = "listLastestByAccount",
        description = """Return list of recent trigger suggestions that have been sent to the user.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = OfferListResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/audience/suggestion/latest"
        value = [PATH_LIST_LASTEST_BY_ACCOUNT],
        produces = ["*/*"]
    )
    fun listLastestByAccount(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The account to match offers for.", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "The timeframe in seconds of the latest suggestions", required = true) @Valid @RequestParam(value = "timeframe", required = true) timeframe: kotlin.Int,
        @NotNull @Parameter(description = "The type of trigger suggestions to return", required = true) @Valid @RequestParam(value = "suggestionType", required = true) suggestionType: kotlin.String
    ): ResponseEntity<OfferListResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "List Vatom Spaces",
        operationId = "listSpaces",
        description = """Gets the spaces tied to a business.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation") ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/vatom/b/spaces/search"
        value = [PATH_LIST_SPACES]
    )
    fun listSpaces(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "Sirqul Account Id", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "Sirqul Application Key", required = true) @Valid @RequestParam(value = "appKey", required = true) appKey: kotlin.String,
        @Parameter(description = "Vatom Parameters") @Valid @RequestParam(value = "vatomParameters", required = false) vatomParameters: kotlin.String?,
        @Parameter(description = "Return raw response") @Valid @RequestParam(value = "returnRawResponse", required = false) returnRawResponse: kotlin.Boolean?
    ): ResponseEntity<Unit> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Search Status",
        operationId = "listStatusCSV",
        description = """Retrieves batches for a user.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = CsvImportResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/csvimport/batch/list"
        value = [PATH_LIST_STATUS_CSV],
        produces = ["*/*"]
    )
    fun listStatusCSV(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the id of the account", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "the start of the pagination", required = true) @Valid @RequestParam(value = "start", required = true) start: kotlin.Int,
        @NotNull @Parameter(description = "the limit of the pagination", required = true) @Valid @RequestParam(value = "limit", required = true) limit: kotlin.Int
    ): ResponseEntity<CsvImportResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "List Coin Transactions for a Vatom User",
        operationId = "listUserCoinTransactions",
        description = """Gets the logged in user's Vatom coin transactions.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation") ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/vatom/u/coins/txns/search"
        value = [PATH_LIST_USER_COIN_TRANSACTIONS]
    )
    fun listUserCoinTransactions(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "Sirqul Account Id", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "Vatom User Id", required = true) @Valid @RequestParam(value = "vatomUserId", required = true) vatomUserId: kotlin.String,
        @Parameter(description = "Vatom Parameters") @Valid @RequestParam(value = "vatomParameters", required = false) vatomParameters: kotlin.String?,
        @Parameter(description = "Return raw response") @Valid @RequestParam(value = "returnRawResponse", required = false) returnRawResponse: kotlin.Boolean?
    ): ResponseEntity<Unit> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "List coin transactions for a user (as a Business)",
        operationId = "listUserCoinTransactionsAsBusiness",
        description = """List coin transactions for a user (as a Business).""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation") ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/vatom/b/users/coins/txns/search"
        value = [PATH_LIST_USER_COIN_TRANSACTIONS_AS_BUSINESS]
    )
    fun listUserCoinTransactionsAsBusiness(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "Sirqul Account Id", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "Vatom User Id", required = true) @Valid @RequestParam(value = "vatomUserId", required = true) vatomUserId: kotlin.String,
        @NotNull @Parameter(description = "Sirqul Application Key", required = true) @Valid @RequestParam(value = "appKey", required = true) appKey: kotlin.String,
        @Parameter(description = "Vatom Parameters") @Valid @RequestParam(value = "vatomParameters", required = false) vatomParameters: kotlin.String?,
        @Parameter(description = "Return raw response") @Valid @RequestParam(value = "returnRawResponse", required = false) returnRawResponse: kotlin.Boolean?
    ): ResponseEntity<Unit> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Login as Account",
        operationId = "loginDelegate",
        description = """A login service that supports logging in as someone else (accounts that the user manages). Intended for internal use for now.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = ProfileResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/account/login/delegate"
        value = [PATH_LOGIN_DELEGATE],
        produces = ["*/*"]
    )
    fun loginDelegate(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "", required = true) @Valid @RequestParam(value = "accessToken", required = true) accessToken: kotlin.String,
        @NotNull @Parameter(description = "", required = true) @Valid @RequestParam(value = "appKey", required = true) appKey: kotlin.String,
        @Parameter(description = "") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "") @Valid @RequestParam(value = "accessTokenSecret", required = false) accessTokenSecret: kotlin.String?,
        @Parameter(description = "") @Valid @RequestParam(value = "delegatedAccountId", required = false) delegatedAccountId: kotlin.Long?,
        @Parameter(description = "") @Valid @RequestParam(value = "delegatedUsername", required = false) delegatedUsername: kotlin.String?,
        @Parameter(description = "The access provider to authenticate against (default: USERNAME). Supported values: FACEBOOK, TWITTER, USERNAME, PHONE", schema = Schema(defaultValue = "USERNAME")) @Valid @RequestParam(value = "networkUID", required = false, defaultValue = "USERNAME") networkUID: kotlin.String,
        @Parameter(description = "Checks user's birthday to see if they meet an age requirement. If the user is under age, an error message is returned.", schema = Schema(defaultValue = "0")) @Valid @RequestParam(value = "ageRestriction", required = false, defaultValue = "0") ageRestriction: kotlin.Int,
        @Parameter(description = "This determines how much of the profile should be returned, see ProfileFilters", schema = Schema(defaultValue = "PROFILE")) @Valid @RequestParam(value = "responseFilters", required = false, defaultValue = "PROFILE") responseFilters: kotlin.String,
        @Parameter(description = "") @Valid @RequestParam(value = "latitude", required = false) latitude: kotlin.Double?,
        @Parameter(description = "") @Valid @RequestParam(value = "longitude", required = false) longitude: kotlin.Double?
    ): ResponseEntity<ProfileResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Login Account",
        operationId = "loginGeneral",
        description = """General login service that supports various authentication methods. Currently supports Facebook, Twitter, Sirqul Username, and Sirqul Phone by default. Can also support custom networks created using the {@link ThirdPartyApi}""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = ProfileResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/account/login"
        value = [PATH_LOGIN_GENERAL],
        produces = ["*/*"]
    )
    fun loginGeneral(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The access token to authenticate with (ex: username or fb token)", required = true) @Valid @RequestParam(value = "accessToken", required = true) accessToken: kotlin.String,
        @NotNull @Parameter(description = "The access provider to authenticate against. This can be custom  networks created using the ThirdPartyApi as well. Supported values by default  include: FACEBOOK, TWITTER, USERNAME, PHONE ", required = true, schema = Schema(defaultValue = "USERNAME")) @Valid @RequestParam(value = "networkUID", required = true, defaultValue = "USERNAME") networkUID: kotlin.String,
        @NotNull @Parameter(description = "The application key", required = true) @Valid @RequestParam(value = "appKey", required = true) appKey: kotlin.String,
        @Parameter(description = "The unique id of the device making the request") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "The type of device id (this is defined by the client), ie. MAC_ADDRESS, APPLE_UDID, etc") @Valid @RequestParam(value = "deviceIdType", required = false) deviceIdType: kotlin.String?,
        @Parameter(description = "The secret to authenticate with (ex: password)") @Valid @RequestParam(value = "accessTokenSecret", required = false) accessTokenSecret: kotlin.String?,
        @Parameter(description = "Checks user's birthday to see if they meet an age requirement. If the user is under age, an error message is returned.", schema = Schema(defaultValue = "0")) @Valid @RequestParam(value = "ageRestriction", required = false, defaultValue = "0") ageRestriction: kotlin.Int,
        @Parameter(description = "This determines how much of the profile should be returned, see ProfileFilters", schema = Schema(defaultValue = "PROFILE")) @Valid @RequestParam(value = "responseFilters", required = false, defaultValue = "PROFILE") responseFilters: kotlin.String,
        @Parameter(description = "Used to update the user's current location") @Valid @RequestParam(value = "latitude", required = false) latitude: kotlin.Double?,
        @Parameter(description = "Used to update the user's current location") @Valid @RequestParam(value = "longitude", required = false) longitude: kotlin.Double?,
        @Parameter(description = "Option to check for email if username doesn't match, also support multiple accounts", schema = Schema(defaultValue = "false")) @Valid @RequestParam(value = "emailMatch", required = false, defaultValue = "false") emailMatch: kotlin.Boolean,
        @Parameter(description = "Chosen account Id sent from the app - pass in the 2nd request to choose an account from multiple accounts matching the email - use one of the account id from the previous request", schema = Schema(defaultValue = "0L")) @Valid @RequestParam(value = "chosenAccountId", required = false, defaultValue = "0L") chosenAccountId: kotlin.Long,
        @Parameter(description = "Third-party credential Id, pass in the 2nd request to choose an account from multiple accounts matching the email - use the id from the previous call ThirdPartyCredential object", schema = Schema(defaultValue = "0L")) @Valid @RequestParam(value = "thirdPartyCredentialId", required = false, defaultValue = "0L") thirdPartyCredentialId: kotlin.Long
    ): ResponseEntity<ProfileResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Login Clear",
        operationId = "loginSecure",
        description = """Login via Clear.me. Creates a new account if logging in for the first time.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = ProfileResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/secure/login"
        value = [PATH_LOGIN_SECURE],
        produces = ["*/*"]
    )
    fun loginSecure(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The application making the request, defines what type and position is required to make a secure login the request.", required = true) @Valid @RequestParam(value = "appKey", required = true) appKey: kotlin.String,
        @NotNull @Parameter(description = "The data file used to perform authentication", required = true) @Valid @RequestParam(value = "biometricFile", required = true) biometricFile: org.springframework.web.multipart.MultipartFile,
        @Parameter(description = "The unique id of the device making the request") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "The data file used to perform authentication") @Valid @RequestParam(value = "biometricFile2", required = false) biometricFile2: org.springframework.web.multipart.MultipartFile,
        @Parameter(description = "Checks user's birthday to see if they meet an age requirement. If the user is under age, an error message is returned.", schema = Schema(defaultValue = "0")) @Valid @RequestParam(value = "ageRestriction", required = false, defaultValue = "0") ageRestriction: kotlin.Int,
        @Parameter(description = "Determines whether to return a ProfileResponse on success, or a PaymentTypesResponse", schema = Schema(defaultValue = "false")) @Valid @RequestParam(value = "returnProfile", required = false, defaultValue = "false") returnProfile: kotlin.Boolean,
        @Parameter(description = "If returnProfile is set to true, this determines how much of the profile should be returned, see ProfileFilters", schema = Schema(defaultValue = "PROFILE")) @Valid @RequestParam(value = "responseFilters", required = false, defaultValue = "PROFILE") responseFilters: kotlin.String,
        @Parameter(description = "Used to update the user's current location") @Valid @RequestParam(value = "latitude", required = false) latitude: kotlin.Double?,
        @Parameter(description = "Used to update the user's current location") @Valid @RequestParam(value = "longitude", required = false) longitude: kotlin.Double?
    ): ResponseEntity<ProfileResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Login Twitter",
        operationId = "loginTwitter",
        description = """Returns the user profile information given an access token and the secret access token. This call verifies the tokens with twitter and creates a Sirqul account for the user if its their first time logging in.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = ProfileResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/twitter/login"
        value = [PATH_LOGIN_TWITTER],
        produces = ["*/*"]
    )
    fun loginTwitter(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The access token", required = true) @Valid @RequestParam(value = "accessToken", required = true) accessToken: kotlin.String,
        @NotNull @Parameter(description = "The secret access token", required = true) @Valid @RequestParam(value = "accessTokenSecret", required = true) accessTokenSecret: kotlin.String,
        @NotNull @Parameter(description = "The application key", required = true) @Valid @RequestParam(value = "appKey", required = true) appKey: kotlin.String,
        @NotNull @Parameter(description = "a comma separated list of ProfileFilters for filtering the returned response data", required = true) @Valid @RequestParam(value = "responseFilters", required = true) responseFilters: kotlin.String,
        @Parameter(description = "The device id") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "The current latitude of the user") @Valid @RequestParam(value = "latitude", required = false) latitude: kotlin.Double?,
        @Parameter(description = "The current longitude of the user") @Valid @RequestParam(value = "longitude", required = false) longitude: kotlin.Double?
    ): ResponseEntity<ProfileResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Login Account (Username)",
        operationId = "loginUsername",
        description = """Login to system with an account""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = ProfileResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/account/get"
        value = [PATH_LOGIN_USERNAME],
        produces = ["*/*"]
    )
    fun loginUsername(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the user's email address they used to sign-up", required = true) @Valid @RequestParam(value = "username", required = true) username: kotlin.String,
        @NotNull @Parameter(description = "the password", required = true) @Valid @RequestParam(value = "password", required = true) password: kotlin.String,
        @Parameter(description = "the device id") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "the current latitude of the user") @Valid @RequestParam(value = "latitude", required = false) latitude: kotlin.Double?,
        @Parameter(description = "the current longitude of the user") @Valid @RequestParam(value = "longitude", required = false) longitude: kotlin.Double?,
        @Parameter(description = "the app") @Valid @RequestParam(value = "app", required = false) app: kotlin.String?,
        @Parameter(description = "This parameter is deprecated. This is deprecated, use appKey.") @Valid @RequestParam(value = "gameType", required = false) gameType: kotlin.String?,
        @Parameter(description = "the application key") @Valid @RequestParam(value = "appKey", required = false) appKey: kotlin.String?,
        @Parameter(description = "the profile to return") @Valid @RequestParam(value = "returnProfile", required = false) returnProfile: kotlin.Boolean?,
        @Parameter(description = "a comma separated list of ProfileFilters for filtering the returned response data") @Valid @RequestParam(value = "responseFilters", required = false) responseFilters: kotlin.String?
    ): ResponseEntity<ProfileResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Logout Account",
        operationId = "logout",
        description = """Cleans up the users data for logging out.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/account/logout"
        value = [PATH_LOGOUT],
        produces = ["*/*"]
    )
    fun logout(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "The device id (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "Device Id Type") @Valid @RequestParam(value = "deviceIdType", required = false) deviceIdType: kotlin.String?,
        @Parameter(description = "The account id of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "The current latitude of the user") @Valid @RequestParam(value = "latitude", required = false) latitude: kotlin.Double?,
        @Parameter(description = "The current longitude of the user") @Valid @RequestParam(value = "longitude", required = false) longitude: kotlin.Double?
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Merge Account",
        operationId = "mergeAccount",
        description = """Merges the analytics, achievements, leaderboards of two accounts.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/account/merge"
        value = [PATH_MERGE_ACCOUNT],
        produces = ["*/*"]
    )
    fun mergeAccount(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The id of the account to being merged", required = true) @Valid @RequestParam(value = "mergeAccountId", required = true) mergeAccountId: kotlin.Long,
        @NotNull @Parameter(description = "The application key", required = true) @Valid @RequestParam(value = "appKey", required = true) appKey: kotlin.String,
        @Parameter(description = "The device id (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "The account id of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Invite to Mission",
        operationId = "missionInvite",
        description = """Allows a user to invite people to gain access to a mission. This will generate an invite token, which when used, will give the invitee access to a mission (whether it is private or not). The invitee will also become the user's friend when the invitation is accepted.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = InviteResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/invite/mission"
        value = [PATH_MISSION_INVITE],
        produces = ["*/*"]
    )
    fun missionInvite(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "a unique ID given by the device (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "the account ID of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "This parameter is deprecated.") @Valid @RequestParam(value = "appId", required = false) appId: kotlin.Long?,
        @Parameter(description = "the application key") @Valid @RequestParam(value = "appKey", required = false) appKey: kotlin.String?,
        @Parameter(description = "the mission to share") @Valid @RequestParam(value = "missionId", required = false) missionId: kotlin.Long?,
        @Parameter(description = "the current latitude of the user") @Valid @RequestParam(value = "latitude", required = false) latitude: kotlin.Double?,
        @Parameter(description = "the current longitude of the user") @Valid @RequestParam(value = "longitude", required = false) longitude: kotlin.Double?
    ): ResponseEntity<InviteResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Invite to Offer",
        operationId = "offerInvite",
        description = """Allows a user to invite people to favorite an offer. This will generate an invite token, which when used, will give the invitee the offer in their favorite's list.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = InviteResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/invite/offer"
        value = [PATH_OFFER_INVITE],
        produces = ["*/*"]
    )
    fun offerInvite(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the account ID of the user making the share", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "the application key", required = true) @Valid @RequestParam(value = "appKey", required = true) appKey: kotlin.String,
        @NotNull @Parameter(description = "the ID of the offer used to invite to favorite", required = true) @Valid @RequestParam(value = "offerId", required = true) offerId: kotlin.Long
    ): ResponseEntity<InviteResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Invite to Offer Location",
        operationId = "offerLocationInvite",
        description = """Allows a user to invite people to favorite an offer location. This will generate an invite token, which when used, will give the invitee the offer location in their favorite's list.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = InviteResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/invite/offerLocation"
        value = [PATH_OFFER_LOCATION_INVITE],
        produces = ["*/*"]
    )
    fun offerLocationInvite(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the account ID of the user making the share", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "the application key", required = true) @Valid @RequestParam(value = "appKey", required = true) appKey: kotlin.String,
        @NotNull @Parameter(description = "the id of the offer location to share", required = true) @Valid @RequestParam(value = "offerLocationId", required = true) offerLocationId: kotlin.Long
    ): ResponseEntity<InviteResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Optimize Route",
        operationId = "optimizeRoute",
        description = """Optimize a route. The optimization method based on how the server is configured.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation") ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/route/{routeId}/optimize"
        value = [PATH_OPTIMIZE_ROUTE]
    )
    fun optimizeRoute(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "the id of the route to optimize", required = true) @PathVariable("routeId") routeId: kotlin.Long
    ): ResponseEntity<Unit> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Override User Rank",
        operationId = "overrideUserRank",
        description = """Allows an admin of an application to override a user's scores for a leaderboard.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/ranking/override"
        value = [PATH_OVERRIDE_USER_RANK],
        produces = ["*/*"]
    )
    fun overrideUserRank(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the logged in user's account id (must have permissions to manage data for the application)", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "the end user's account id to override", required = true) @Valid @RequestParam(value = "ownerAccountId", required = true) ownerAccountId: kotlin.Long,
        @NotNull @Parameter(description = "the application key the leaderboard is for", required = true) @Valid @RequestParam(value = "appKey", required = true) appKey: kotlin.String,
        @NotNull @Parameter(description = "the rankType of the leaderboard", required = true) @Valid @RequestParam(value = "rankType", required = true) rankType: kotlin.String,
        @Parameter(description = "the total score to update") @Valid @RequestParam(value = "totalScore", required = false) totalScore: kotlin.Long?,
        @Parameter(description = "the total count to update") @Valid @RequestParam(value = "totalCount", required = false) totalCount: kotlin.Long?,
        @Parameter(description = "the total time to update") @Valid @RequestParam(value = "totalTime", required = false) totalTime: kotlin.Long?,
        @Parameter(description = "the daily score to update") @Valid @RequestParam(value = "dailyScore", required = false) dailyScore: kotlin.Long?,
        @Parameter(description = "the daily count to update") @Valid @RequestParam(value = "dailyCount", required = false) dailyCount: kotlin.Long?,
        @Parameter(description = "the daily time to update") @Valid @RequestParam(value = "dailyTime", required = false) dailyTime: kotlin.Long?,
        @Parameter(description = "the weekly score to update") @Valid @RequestParam(value = "weeklyScore", required = false) weeklyScore: kotlin.Long?,
        @Parameter(description = "the weekly count to update") @Valid @RequestParam(value = "weeklyCount", required = false) weeklyCount: kotlin.Long?,
        @Parameter(description = "the weekly time to update") @Valid @RequestParam(value = "weeklyTime", required = false) weeklyTime: kotlin.Long?,
        @Parameter(description = "the monthly score to update") @Valid @RequestParam(value = "monthlyScore", required = false) monthlyScore: kotlin.Long?,
        @Parameter(description = "the monthly count to update") @Valid @RequestParam(value = "monthlyCount", required = false) monthlyCount: kotlin.Long?,
        @Parameter(description = "the monthly time to update") @Valid @RequestParam(value = "monthlyTime", required = false) monthlyTime: kotlin.Long?,
        @Parameter(description = "the top score to update") @Valid @RequestParam(value = "topScore", required = false) topScore: kotlin.Long?,
        @Parameter(description = "the lowest score to update") @Valid @RequestParam(value = "lowestScore", required = false) lowestScore: kotlin.Long?,
        @Parameter(description = "the streak count to update") @Valid @RequestParam(value = "streakCount", required = false) streakCount: kotlin.Long?,
        @Parameter(description = "the best streak count to update") @Valid @RequestParam(value = "streakBestCount", required = false) streakBestCount: kotlin.Long?,
        @Parameter(description = "the start date to update") @Valid @RequestParam(value = "startDate", required = false) startDate: kotlin.Long?,
        @Parameter(description = "the end date to update") @Valid @RequestParam(value = "endDate", required = false) endDate: kotlin.Long?
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Update Password",
        operationId = "passwordChange",
        description = """Update the account password.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/account/passwordchange"
        value = [PATH_PASSWORD_CHANGE],
        produces = ["*/*"]
    )
    fun passwordChange(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The account to update", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "The current password, used to validate access", required = true) @Valid @RequestParam(value = "oldPassword", required = true) oldPassword: kotlin.String,
        @NotNull @Parameter(description = "The new password to set, cannot be empty", required = true) @Valid @RequestParam(value = "newPassword", required = true) newPassword: kotlin.String,
        @NotNull @Parameter(description = "The new password to confirm, must match newPassword", required = true) @Valid @RequestParam(value = "confirmPassword", required = true) confirmPassword: kotlin.String
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Reset Password",
        operationId = "passwordReset",
        description = """Reset the account password. The token must be valid and not expired. Use the RequestPasswordReset end point to request a token.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/account/passwordreset"
        value = [PATH_PASSWORD_RESET],
        produces = ["*/*"]
    )
    fun passwordReset(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The token associated with the account to update, good for 24 hours", required = true) @Valid @RequestParam(value = "token", required = true) token: kotlin.String,
        @NotNull @Parameter(description = "The new password to set, cannot be empty", required = true) @Valid @RequestParam(value = "password", required = true) password: kotlin.String,
        @NotNull @Parameter(description = "The new password to confirm, must match newPassword", required = true) @Valid @RequestParam(value = "confirm", required = true) confirm: kotlin.String
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Perform Action on NFT",
        operationId = "performActionOnNFT",
        description = """Perform Action on NFT.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation") ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/vatom/me/vatoms/actions"
        value = [PATH_PERFORM_ACTION_ON_NFT]
    )
    fun performActionOnNFT(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "Sirqul Account Id", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "Vatom NFT Id", required = true) @Valid @RequestParam(value = "vatomId", required = true) vatomId: kotlin.String,
        @NotNull @Parameter(description = "Vatom Action", required = true) @Valid @RequestParam(value = "vatomAction", required = true) vatomAction: kotlin.String,
        @NotNull @Parameter(description = "Vatom Parameters", required = true) @Valid @RequestParam(value = "vatomParameters", required = true) vatomParameters: kotlin.String,
        @Parameter(description = "Return raw response") @Valid @RequestParam(value = "returnRawResponse", required = false) returnRawResponse: kotlin.Boolean?
    ): ResponseEntity<Unit> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Create App Data",
        operationId = "postAppData",
        description = """Publish the application data structure.  Can be used to save levels   and scores.  It then returns the application data structure.

The basic   structure is a node tree, with the root node being a AppResponse.  The response   contains the user's profile, messages from the system, and a list of MissionResponse.    A mission can have any number of GameResponses but typically is a single   game type.  A game then has any number of PackResponses which help group   the game levels. Packs are then composed of any number of GameLevelResponses.    

Using the various parameters can return the applications default mission   (built-in packs to play), the list of community levels published, the user's   saved levels, or explicity levels desired.  You can choose to include the   profile or not, or just return parts of the profile.  You can also filter   out game levels that have been published with a higher version of the application""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = AppResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/app/post"
        value = [PATH_POST_APP_DATA],
        produces = ["*/*"]
    )
    fun postAppData(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the game to retrieve the data for, use your application key.", required = true) @Valid @RequestParam(value = "gameType", required = true) gameType: kotlin.String,
        @NotNull @Parameter(description = "start the search results at a record.", required = true) @Valid @RequestParam(value = "start", required = true) start: kotlin.Int,
        @NotNull @Parameter(description = "limit the search results to some number.", required = true) @Valid @RequestParam(value = "limit", required = true) limit: kotlin.Int,
        @NotNull @Parameter(description = "The analytic data AnalyticListResponse", required = true) @Valid @RequestParam(value = "data", required = true) `data`: kotlin.String,
        @Parameter(description = "the device id (deviceId or accountId required).") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "the account id of the user (deviceId or accountId required).") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "if true then include the game data blob, otherwise don't include.") @Valid @RequestParam(value = "includeGameData", required = false) includeGameData: kotlin.Boolean?,
        @Parameter(description = "This parameter is deprecated.") @Valid @RequestParam(value = "q", required = false) q: kotlin.String?,
        @Parameter(description = "query string used to filter the search results when looking for community and saved levels.") @Valid @RequestParam(value = "keyword", required = false) keyword: kotlin.String?,
        @Parameter(description = "how to sort the results when looking for community and saved levels. possible values are: LEVEL_NAME, LEVEL_CREATED, LEVEL_UPDATED, LEVEL_LIKES, LEVEL_DISLIKES, LEVEL_NOTES, LEVEL_PLAYS.") @Valid @RequestParam(value = "sortField", required = false) sortField: kotlin.String?,
        @Parameter(description = "order the search results descending or ascending when looking for community and saved levels.") @Valid @RequestParam(value = "descending", required = false) descending: kotlin.Boolean?,
        @Parameter(description = "This parameter is deprecated.") @Valid @RequestParam(value = "_i", required = false) i: kotlin.Int?,
        @Parameter(description = "This parameter is deprecated.") @Valid @RequestParam(value = "_l", required = false) l: kotlin.Int?,
        @Parameter(description = "if true then include the game object count, otherwise don't include.") @Valid @RequestParam(value = "gameObjectCount", required = false) gameObjectCount: kotlin.Boolean?,
        @Parameter(description = "restrict the search to items with certain permissions, possible values are: MINE, FRIENDS, PUBLIC, ALL_PUBLIC, ALL, LIKED") @Valid @RequestParam(value = "filter", required = false) filter: kotlin.String?,
        @Parameter(description = "restrict the search to items created less then date") @Valid @RequestParam(value = "dateCreated", required = false) dateCreated: kotlin.Long?,
        @Parameter(description = "get levels owned by a particular account") @Valid @RequestParam(value = "ownerId", required = false) ownerId: kotlin.Long?,
        @Parameter(description = "get missions by specified id, comman seperated list of long ids") @Valid @RequestParam(value = "missionIds", required = false) missionIds: kotlin.String?,
        @Parameter(description = "get games by specified id, comman seperated list of long ids") @Valid @RequestParam(value = "gameIds", required = false) gameIds: kotlin.String?,
        @Parameter(description = "get packs by specified id, comman seperated list of long ids") @Valid @RequestParam(value = "packIds", required = false) packIds: kotlin.String?,
        @Parameter(description = "get game levels by specified id, comman seperated list of long ids") @Valid @RequestParam(value = "gameLevelIds", required = false) gameLevelIds: kotlin.String?,
        @Parameter(description = "the application version, used to versin the game level data") @Valid @RequestParam(value = "appVersion", required = false) appVersion: kotlin.String?,
        @Parameter(description = "default is false and will not include any packs that have levels above the specified appVersion. If true then will return all levels regardless of version.") @Valid @RequestParam(value = "includeHigherVersionPacks", required = false) includeHigherVersionPacks: kotlin.Boolean?,
        @Parameter(description = "default is false and will not include any levels above the specified appVersion. If true then will return all levels regardless of version.") @Valid @RequestParam(value = "includeHigherVersionLevels", required = false) includeHigherVersionLevels: kotlin.Boolean?,
        @Parameter(description = "use response groups to include large parts of the structure. possible values are: * MISSION_DEFAULT (default) - include the default mission (built-in packs), excludes all other mission groups * MISSION_DEFAULT_LEVELS_SAVED - include saved levels, excludes all other mission groups * MISSION_DEFAULT_LEVELS_COMMUNITY - include community levels, excludes all other mission groups * MISSION_INVITED (default) - include challenges sent to user * PROFILE (default) - include entire profile * PROFILE_DATA - only include profile date (exclude friends) * PROFILE_FRIENDS - include friends list ") @Valid @RequestParam(value = "responseGroups", required = false) responseGroups: kotlin.String?,
        @Parameter(description = "the will return the correct in app purchases for the device, possible values are: * SIRQUL (default) - purchasing from the sirqul store using tickets * IOS - purchasing from the itunes store for iPhone, iPod, iPod Touch * GOOGLE - purchasing from the google android store * AMAZON - purchasing from the amazon android store * MAC - purchasing from the itunes store for OSX * FREE - the item is free to purchase ") @Valid @RequestParam(value = "purchaseType", required = false) purchaseType: kotlin.String?
    ): ResponseEntity<AppResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Update Program",
        operationId = "postProgram",
        description = """Update an existing program""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = Program::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/program/{id}"
        value = [PATH_POST_PROGRAM],
        produces = ["*/*"]
    )
    fun postProgram(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "the id of the program", required = true) @PathVariable("id") id: kotlin.Long,
        @Parameter(description = "") @Valid @RequestBody(required = false) body: Program?
    ): ResponseEntity<Program> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Update Service Hub",
        operationId = "postServiceHub",
        description = """Update an existing service hub""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = ServiceHub::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/hub/{id}"
        value = [PATH_POST_SERVICE_HUB],
        produces = ["*/*"]
    )
    fun postServiceHub(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "the id of the service hub", required = true) @PathVariable("id") id: kotlin.Long,
        @Parameter(description = "") @Valid @RequestBody(required = false) body: ServiceHub?
    ): ResponseEntity<ServiceHub> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Preview Wallet Offers",
        operationId = "previewOfferTransaction",
        description = """Preview the final cost of a transaction without charging the user""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(array = ArraySchema(schema = Schema(implementation = OfferTransactionResponse::class)))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/wallet/preview"
        value = [PATH_PREVIEW_OFFER_TRANSACTION],
        produces = ["*/*"]
    )
    fun previewOfferTransaction(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "The device id (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "The account id of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "The id of the offer being added (offerId or offeLocationId required)") @Valid @RequestParam(value = "offerId", required = false) offerId: kotlin.Long?,
        @Parameter(description = "The id of the offer location being added (offerId or offeLocationId required)") @Valid @RequestParam(value = "offerLocationId", required = false) offerLocationId: kotlin.Long?,
        @Parameter(description = "A JSON list of offers to purchase.") @Valid @RequestParam(value = "offerCart", required = false) offerCart: kotlin.String?,
        @Parameter(description = "The promoCode") @Valid @RequestParam(value = "promoCode", required = false) promoCode: kotlin.String?,
        @Parameter(description = "Determines the method of purchasing offer. CASH = use card on file, POINTS = use points, TICKETS = use tickets", schema = Schema(defaultValue = "CASH")) @Valid @RequestParam(value = "currencyType", required = false, defaultValue = "CASH") currencyType: kotlin.String,
        @Parameter(description = "Sets the currencyType to POINTS") @Valid @RequestParam(value = "usePoints", required = false) usePoints: kotlin.Boolean?,
        @Parameter(description = "External custom client defined data") @Valid @RequestParam(value = "metaData", required = false) metaData: kotlin.String?,
        @Parameter(description = "The application requesting the purchase, required when currencyType is TICKETS") @Valid @RequestParam(value = "appKey", required = false) appKey: kotlin.String?
    ): ResponseEntity<List<OfferTransactionResponse>> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Preview Order",
        operationId = "previewOrder",
        description = """Previews a purchase to see the total cost before making it.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = OrderResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/order/preview"
        value = [PATH_PREVIEW_ORDER],
        produces = ["*/*"]
    )
    fun previewOrder(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The application requesting the purchase", required = true) @Valid @RequestParam(value = "appKey", required = true) appKey: kotlin.String,
        @NotNull @Parameter(description = "A JSON list of items to purchase", required = true) @Valid @RequestParam(value = "cart", required = true) cart: kotlin.String,
        @Parameter(description = "The device id (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "The account id of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "A description of the purchase") @Valid @RequestParam(value = "description", required = false) description: kotlin.String?,
        @Parameter(description = "Determines the method of purchasing offer. ```json {   \"VOID\": \"used for when there is no payment involved (ie. for updating the status of a purchase order)\",   \"CASH\": \"use card on file\",   \"POINTS\": \"use account balance\",   \"TICKETS\": \"use tickets\",   \"REFUND\": \"not allowed for a create, requires a paymentTransactionId\",   \"CREDIT\": \"add to the account balance\",   \"RELOAD\": \"charge a credit card then add to the account balance\" } ``` ", schema = Schema(allowableValues = ["VOID", "CASH", "POINTS", "TICKETS", "REFUND", "CREDIT", "RELOAD"], defaultValue = "CASH")) @Valid @RequestParam(value = "currencyType", required = false, defaultValue = "CASH") currencyType: kotlin.String,
        @Parameter(description = "Use a specific payment method (CASH), if not provided use default") @Valid @RequestParam(value = "paymentMethodId", required = false) paymentMethodId: kotlin.Long?,
        @Parameter(description = "Store identifier from external system") @Valid @RequestParam(value = "externalOrderId", required = false) externalOrderId: kotlin.String?,
        @Parameter(description = "Store identifier from external system") @Valid @RequestParam(value = "externalPaymentId", required = false) externalPaymentId: kotlin.String?,
        @Parameter(description = "Remote Reference type") @Valid @RequestParam(value = "remoteRefType", required = false) remoteRefType: kotlin.String?,
        @Parameter(description = "External Date") @Valid @RequestParam(value = "externalDate", required = false) externalDate: kotlin.Long?,
        @Parameter(description = "The Promo Code") @Valid @RequestParam(value = "promoCode", required = false) promoCode: kotlin.String?
    ): ResponseEntity<OrderResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Process All Participant Feeds",
        operationId = "processAllParticipants",
        description = """Processes all supported participant feeds.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/participant/process/all"
        value = [PATH_PROCESS_ALL_PARTICIPANTS],
        produces = ["*/*"]
    )
    fun processAllParticipants(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The account id of the user", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @Parameter(description = "The application key used to identify the application") @Valid @RequestParam(value = "appKey", required = false) appKey: kotlin.String?,
        @Parameter(description = "Whether to use short name as the participant ID") @Valid @RequestParam(value = "useShortNameAsID", required = false) useShortNameAsID: kotlin.Boolean?
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Process Participants Feed",
        operationId = "processParticipants",
        description = """Processes a participant feed or uploaded file for a specific league.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/participant/process"
        value = [PATH_PROCESS_PARTICIPANTS],
        produces = ["*/*"]
    )
    fun processParticipants(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The account id of the user", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "The league identifier to process", required = true) @Valid @RequestParam(value = "league", required = true) league: kotlin.String,
        @Parameter(description = "The application key used to identify the application") @Valid @RequestParam(value = "appKey", required = false) appKey: kotlin.String?,
        @Parameter(description = "Whether to use short name as the participant ID") @Valid @RequestParam(value = "useShortNameAsID", required = false) useShortNameAsID: kotlin.Boolean?,
        @Parameter(description = "Multipart file containing participant feed contents") @Valid @RequestParam(value = "file", required = false) file: org.springframework.web.multipart.MultipartFile
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Process Trip Matches",
        operationId = "processTripMatches",
        description = """Process trip matching, assign trips with no route to matched trips with route.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(array = ArraySchema(schema = Schema(implementation = Trip::class)))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/trip/match/process"
        value = [PATH_PROCESS_TRIP_MATCHES],
        produces = ["*/*"]
    )
    fun processTripMatches(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "The lower bound date to process matchings") @Valid @RequestParam(value = "startDate", required = false) startDate: kotlin.Long?,
        @Parameter(description = "The upper bound date to process matchings") @Valid @RequestParam(value = "endDate", required = false) endDate: kotlin.Long?,
        @Parameter(description = "the id of the trip to process") @Valid @RequestParam(value = "tripId", required = false) tripId: kotlin.Long?
    ): ResponseEntity<List<Trip>> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Purchase Clear",
        operationId = "purchaseSecure",
        description = """Purchase via Clear.me. Creates a new account if purchasing for the first time.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = ProfileResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/secure/purchase"
        value = [PATH_PURCHASE_SECURE],
        produces = ["application/json"],
        consumes = ["application/json"]
    )
    fun purchaseSecure(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "The payment request object", required = true) @Valid @RequestBody body: PaymentRequest
    ): ResponseEntity<ProfileResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Update Program",
        operationId = "putProgram",
        description = """Update an existing program""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = Program::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.PUT],
        // "/api/{version}/program/{id}"
        value = [PATH_PUT_PROGRAM],
        produces = ["*/*"]
    )
    fun putProgram(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "the id of the program", required = true) @PathVariable("id") id: kotlin.Long,
        @Parameter(description = "") @Valid @RequestBody(required = false) body: Program?
    ): ResponseEntity<Program> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Update Service Hub",
        operationId = "putServiceHub",
        description = """Update an existing service hub""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = ServiceHub::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.PUT],
        // "/api/{version}/hub/{id}"
        value = [PATH_PUT_SERVICE_HUB],
        produces = ["*/*"]
    )
    fun putServiceHub(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "the id of the service hub", required = true) @PathVariable("id") id: kotlin.Long,
        @Parameter(description = "") @Valid @RequestBody(required = false) body: ServiceHub?
    ): ResponseEntity<ServiceHub> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Create Queue",
        operationId = "queueCreate",
        description = """Create a basic AMQP queue. If the username and password and virtual host is not sepcified, the queue will be created on the virtual host assigned to the application.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = QueueResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/queue/create"
        value = [PATH_QUEUE_CREATE],
        produces = ["*/*"]
    )
    fun queueCreate(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The application key unique to each application.", required = true) @Valid @RequestParam(value = "appKey", required = true) appKey: kotlin.String,
        @NotNull @Parameter(description = "The name of the queue to create", required = true) @Valid @RequestParam(value = "name", required = true) name: kotlin.String,
        @Parameter(description = "The client deviceID") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "The logged in user ID") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "The number of workers to generate ", schema = Schema(defaultValue = "1")) @Valid @RequestParam(value = "workers", required = false, defaultValue = "1") workers: kotlin.Int,
        @Parameter(description = "If provided the analytic processing will publsih to this queue instead of the default one for the provided list of tags") @Valid @RequestParam(value = "analyticTags", required = false) analyticTags: kotlin.String?,
        @Parameter(description = "The hostname of the server the queue is hosted on") @Valid @RequestParam(value = "hostname", required = false) hostname: kotlin.String?,
        @Parameter(description = "The port of the server the queue is hosted on") @Valid @RequestParam(value = "port", required = false) port: kotlin.Int?,
        @Parameter(description = "The username to access the server that the queue is on") @Valid @RequestParam(value = "username", required = false) username: kotlin.String?,
        @Parameter(description = "The password to access the queue to connect to") @Valid @RequestParam(value = "password", required = false) password: kotlin.String?,
        @Parameter(description = "The virtual host defined on the server to queue") @Valid @RequestParam(value = "virtualHost", required = false) virtualHost: kotlin.String?,
        @Parameter(description = "Use SSL") @Valid @RequestParam(value = "useSSL", required = false) useSSL: kotlin.Boolean?
    ): ResponseEntity<QueueResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Delete Queue",
        operationId = "queueDelete",
        description = """Delete the stored queue record and close any active connections to the AMQP servers.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/queue/delete"
        value = [PATH_QUEUE_DELETE],
        produces = ["*/*"]
    )
    fun queueDelete(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The id of the queue to find", required = true) @Valid @RequestParam(value = "queueId", required = true) queueId: kotlin.Long,
        @Parameter(description = "The client device ID") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "The logged in user ID") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get Queue",
        operationId = "queueGet",
        description = """Get the stored queue record. Must supply the queueId, or the name and hostname and virtualHost, or the name and appKey to find the record.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = QueueResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/queue/get"
        value = [PATH_QUEUE_GET],
        produces = ["*/*"]
    )
    fun queueGet(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "The client device ID") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "The logged in user ID") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "The id of the queue to find") @Valid @RequestParam(value = "queueId", required = false) queueId: kotlin.Long?,
        @Parameter(description = "The application key the queue was assigned to") @Valid @RequestParam(value = "appKey", required = false) appKey: kotlin.String?,
        @Parameter(description = "The name of the queue to find") @Valid @RequestParam(value = "name", required = false) name: kotlin.String?,
        @Parameter(description = "The hostname of the queue to find") @Valid @RequestParam(value = "hostname", required = false) hostname: kotlin.String?,
        @Parameter(description = "The virtual host of the queue to find") @Valid @RequestParam(value = "virtualHost", required = false) virtualHost: kotlin.String?
    ): ResponseEntity<QueueResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Publish Queue",
        operationId = "queuePublish",
        description = """Publish a message to a stored queue. Must supply the queueId, or the name and hostname and virtualHost, or the name and appKey to find the record.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/queue/publish"
        value = [PATH_QUEUE_PUBLISH],
        produces = ["*/*"]
    )
    fun queuePublish(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The payload to send to the queue", required = true) @Valid @RequestParam(value = "message", required = true) message: kotlin.String,
        @Parameter(description = "The id of the queue to publish to") @Valid @RequestParam(value = "queueId", required = false) queueId: kotlin.Long?,
        @Parameter(description = "The application key the queue was assigned to") @Valid @RequestParam(value = "appKey", required = false) appKey: kotlin.String?,
        @Parameter(description = "The name of the queue to publish to or the analytic tag to handle if the analytic param is true") @Valid @RequestParam(value = "name", required = false) name: kotlin.String?,
        @Parameter(description = "The hostname of the server the queue is hosted on") @Valid @RequestParam(value = "hostname", required = false) hostname: kotlin.String?,
        @Parameter(description = "The virtual host defined on the server to queue") @Valid @RequestParam(value = "virtualHost", required = false) virtualHost: kotlin.String?
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Search Queue",
        operationId = "queueSearch",
        description = """Get the queues setup for the BillableEntity's applications.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = QueueResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/queue/search"
        value = [PATH_QUEUE_SEARCH],
        produces = ["*/*"]
    )
    fun queueSearch(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "The id of the queue to find") @Valid @RequestParam(value = "queueId", required = false) queueId: kotlin.Long?,
        @Parameter(description = "The client device ID") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "The logged in user ID") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "The name of the queue to find") @Valid @RequestParam(value = "name", required = false) name: kotlin.String?,
        @Parameter(description = "Start of the index", schema = Schema(defaultValue = "0")) @Valid @RequestParam(value = "start", required = false, defaultValue = "0") start: kotlin.Int,
        @Parameter(description = "Limit of the index", schema = Schema(defaultValue = "10")) @Valid @RequestParam(value = "limit", required = false, defaultValue = "10") limit: kotlin.Int
    ): ResponseEntity<QueueResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Update Queue",
        operationId = "queueUpdate",
        description = """Update the basic AMQP queue.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = QueueResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/queue/update"
        value = [PATH_QUEUE_UPDATE],
        produces = ["*/*"]
    )
    fun queueUpdate(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The id of the queue to update", required = true) @Valid @RequestParam(value = "queueId", required = true) queueId: kotlin.Long,
        @Parameter(description = "The client deviceID") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "The logged in user ID") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "The application key unique to each application.") @Valid @RequestParam(value = "appKey", required = false) appKey: kotlin.String?,
        @Parameter(description = "The number of workers to generate") @Valid @RequestParam(value = "workers", required = false) workers: kotlin.Int?,
        @Parameter(description = "If provided the analytic processing will publsih to this queue instead of the default one for the provided list of tags") @Valid @RequestParam(value = "analyticTags", required = false) analyticTags: kotlin.String?,
        @Parameter(description = "The hostname of the server the queue is hosted on") @Valid @RequestParam(value = "hostname", required = false) hostname: kotlin.String?,
        @Parameter(description = "The port of the server the queue is hosted on") @Valid @RequestParam(value = "port", required = false) port: kotlin.Int?,
        @Parameter(description = "The username to access the server that the queue is on") @Valid @RequestParam(value = "username", required = false) username: kotlin.String?,
        @Parameter(description = "The password to access the queue to connect to") @Valid @RequestParam(value = "password", required = false) password: kotlin.String?,
        @Parameter(description = "The virtual host defined on the server to queue") @Valid @RequestParam(value = "virtualHost", required = false) virtualHost: kotlin.String?,
        @Parameter(description = "the SSL to use") @Valid @RequestParam(value = "useSSL", required = false) useSSL: kotlin.Boolean?
    ): ResponseEntity<QueueResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Redeem NFT",
        operationId = "redeemNFT",
        description = """Redeem an NFT.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation") ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/vatom/b/redemptions"
        value = [PATH_REDEEM_NFT]
    )
    fun redeemNFT(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "Sirqul Account Id", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "Sirqul Application Key", required = true) @Valid @RequestParam(value = "appKey", required = true) appKey: kotlin.String,
        @NotNull @Parameter(description = "Vatom Parameters", required = true) @Valid @RequestParam(value = "vatomParameters", required = true) vatomParameters: kotlin.String,
        @Parameter(description = "Return raw response") @Valid @RequestParam(value = "returnRawResponse", required = false) returnRawResponse: kotlin.Boolean?
    ): ResponseEntity<Unit> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Update Offer Transaction",
        operationId = "redeemOfferTransaction",
        description = """Redeems an offer.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/retailer/offer/transaction/update"
        value = [PATH_REDEEM_OFFER_TRANSACTION],
        produces = ["*/*"]
    )
    fun redeemOfferTransaction(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the OfferTransaction ID of the transaction being redeemed", required = true) @Valid @RequestParam(value = "offerTransactionId", required = true) offerTransactionId: kotlin.Long,
        @NotNull @Parameter(description = "the status to set the offer transaction to - 1 sets it to redeemable and 2 sets it to redeemed", required = true) @Valid @RequestParam(value = "status", required = true) status: kotlin.Int,
        @Parameter(description = "the device id (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "the account id of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "the OfferLocation ID where the offer is being redeemed") @Valid @RequestParam(value = "offerLocationId", required = false) offerLocationId: kotlin.Long?
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Redeem the coins for a user (as a Business)",
        operationId = "redeemUserCoinsAsBusiness",
        description = """Redeem the coins for a user (as a Business).""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation") ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/vatom/b/users/coins/redeem"
        value = [PATH_REDEEM_USER_COINS_AS_BUSINESS]
    )
    fun redeemUserCoinsAsBusiness(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "Sirqul Account Id", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "Vatom User Id", required = true) @Valid @RequestParam(value = "vatomUserId", required = true) vatomUserId: kotlin.String,
        @NotNull @Parameter(description = "Sirqul Application Key", required = true) @Valid @RequestParam(value = "appKey", required = true) appKey: kotlin.String,
        @NotNull @Parameter(description = "Vatom Parameters", required = true) @Valid @RequestParam(value = "vatomParameters", required = true) vatomParameters: kotlin.String,
        @Parameter(description = "Return raw response") @Valid @RequestParam(value = "returnRawResponse", required = false) returnRawResponse: kotlin.Boolean?
    ): ResponseEntity<Unit> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Regenerate App Data",
        operationId = "regenAppData",
        description = """Regenerate the app data cache for apps""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/app/regen"
        value = [PATH_REGEN_APP_DATA],
        produces = ["*/*"]
    )
    fun regenAppData(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "the account id of the user") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "process a specific application, if null process all apps with caches") @Valid @RequestParam(value = "appKey", required = false) appKey: kotlin.String?,
        @Parameter(description = "create a specific version, if null use current version. Be careful if processing all") @Valid @RequestParam(value = "buildVersion", required = false) buildVersion: kotlin.String?,
        @Parameter(description = "create a specific version, if null use current version. Be careful if processing all") @Valid @RequestParam(value = "apiVersion", required = false) apiVersion: kotlin.String?
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Create Like",
        operationId = "registerLike",
        description = """Allows a user to like or dislike accounts, albums, album contests, assets, game levels, notes, and theme descriptors. Multiple likes\dislikes on the same object will replace the previous one.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = LikableResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/like"
        value = [PATH_REGISTER_LIKE],
        produces = ["*/*"]
    )
    fun registerLike(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The type of likable object {ALBUM, ALBUM_CONTEST, ASSET, GAME_LEVEL, NOTE, THEME_DESCRIPTOR}", required = true) @Valid @RequestParam(value = "likableType", required = true) likableType: kotlin.String,
        @NotNull @Parameter(description = "The id of the likable object", required = true) @Valid @RequestParam(value = "likableId", required = true) likableId: kotlin.Long,
        @Parameter(description = "The unique device identifier that made the request (either deviceId or accountId must be used)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "The unique accountId that made the request (either deviceId or accountId must be used)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "This is used for sending out group notifications. For example, when someone likes an asset which is also a part of an album, everyone in the album will receive a notification. This is achieved by passing in the permissionable type (in this case \"album\"), and the permissionable id (the album id). Possible types: {ALBUM, ALBUM_CONTEST, GAME_LEVEL, THEME_DESCRIPTOR}") @Valid @RequestParam(value = "permissionableType", required = false) permissionableType: kotlin.String?,
        @Parameter(description = "The id of the permissionable object (for sending group notifications)") @Valid @RequestParam(value = "permissionableId", required = false) permissionableId: kotlin.Long?,
        @Parameter(description = "determines whether the user likes or dislikes the object") @Valid @RequestParam(value = "like", required = false) like: kotlin.Boolean?,
        @Parameter(description = "This parameter is deprecated. This is deprecated, use \"appKey\" instead.") @Valid @RequestParam(value = "app", required = false) app: kotlin.String?,
        @Parameter(description = "This parameter is deprecated. This is deprecated, use \"appKey\" instead.") @Valid @RequestParam(value = "gameType", required = false) gameType: kotlin.String?,
        @Parameter(description = "the application key") @Valid @RequestParam(value = "appKey", required = false) appKey: kotlin.String?,
        @Parameter(description = "The current location of the user") @Valid @RequestParam(value = "latitude", required = false) latitude: kotlin.Double?,
        @Parameter(description = "The current location of the user") @Valid @RequestParam(value = "longitude", required = false) longitude: kotlin.Double?
    ): ResponseEntity<LikableResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Register Notification Token",
        operationId = "registerNotificationToken",
        description = """Register a token to send application dependent notifications like Google Cloud Messaging, or Apple Push Notifications.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/notification/token"
        value = [PATH_REGISTER_NOTIFICATION_TOKEN],
        produces = ["*/*"]
    )
    fun registerNotificationToken(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "A token that is generated by the device to sign requests for the notification service providers", required = true) @Valid @RequestParam(value = "token", required = true) token: kotlin.String,
        @NotNull @Parameter(description = "The type of push notification. Possible values include: APNS, GCM", required = true, schema = Schema(allowableValues = ["APNS", "GCM", "BAIDU", "XGPUSH", "JPUSH"])) @Valid @RequestParam(value = "pushType", required = true) pushType: kotlin.String,
        @Parameter(description = "The unique id of the device making the request (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "The account id of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "Determines if the token is a DEVELOPMENT or PRODUCTION token") @Valid @RequestParam(value = "environment", required = false) environment: kotlin.String?,
        @Parameter(description = "The application key") @Valid @RequestParam(value = "appKey", required = false) appKey: kotlin.String?,
        @Parameter(description = "This parameter is deprecated (use appKey instead)") @Valid @RequestParam(value = "gameType", required = false) gameType: kotlin.String?,
        @Parameter(description = "Sets whether the token is active or not (non-active tokens are not used)") @Valid @RequestParam(value = "active", required = false) active: kotlin.Boolean?,
        @Parameter(description = "Latitude used to update the user's current location") @Valid @RequestParam(value = "latitude", required = false) latitude: kotlin.Double?,
        @Parameter(description = "Longitude used to update the user's current location") @Valid @RequestParam(value = "longitude", required = false) longitude: kotlin.Double?
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Delete Album",
        operationId = "removeAlbum",
        description = """Deletes an Album""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/album/delete"
        value = [PATH_REMOVE_ALBUM],
        produces = ["*/*"]
    )
    fun removeAlbum(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the album ID to delete", required = true) @Valid @RequestParam(value = "albumId", required = true) albumId: kotlin.Long,
        @Parameter(description = "a unique ID given by the device (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "the account ID of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Remove Album Users",
        operationId = "removeAlbumUsers",
        description = """Remove participants of an album.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/album/user/delete"
        value = [PATH_REMOVE_ALBUM_USERS],
        produces = ["*/*"]
    )
    fun removeAlbumUsers(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the album ID", required = true) @Valid @RequestParam(value = "albumId", required = true) albumId: kotlin.Long,
        @NotNull @Parameter(description = "remove friend group", required = true) @Valid @RequestParam(value = "removeFriendGroup", required = true) removeFriendGroup: kotlin.Boolean,
        @Parameter(description = "a unique ID given by the device (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "the account ID of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "comma separated list of connection IDs") @Valid @RequestParam(value = "connections", required = false) connections: kotlin.String?,
        @Parameter(description = "comma separated list of connection group IDs") @Valid @RequestParam(value = "connectionGroups", required = false) connectionGroups: kotlin.String?
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Remove Asset from Collection",
        operationId = "removeAsset",
        description = """Remove assets from collections""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/asset/remove"
        value = [PATH_REMOVE_ASSET],
        produces = ["*/*"]
    )
    fun removeAsset(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the id of the asset to remove", required = true) @Valid @RequestParam(value = "assetId", required = true) assetId: kotlin.String,
        @Parameter(description = "the device id (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "the account id of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "the album id to remove the asset from") @Valid @RequestParam(value = "albumId", required = false) albumId: kotlin.Long?,
        @Parameter(description = "the collection id to remove the asset from") @Valid @RequestParam(value = "collectionId", required = false) collectionId: kotlin.Long?,
        @Parameter(description = "remove from the user's profile album") @Valid @RequestParam(value = "removeFromDefaultAlbums", required = false) removeFromDefaultAlbums: kotlin.Boolean?,
        @Parameter(description = "latitude used to update the user's current location") @Valid @RequestParam(value = "latitude", required = false) latitude: kotlin.Double?,
        @Parameter(description = "longitude used to update the user's current location") @Valid @RequestParam(value = "longitude", required = false) longitude: kotlin.Double?
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Delete Connection",
        operationId = "removeConnectionFromGroup",
        description = """Removes the connection from group.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/consumer/connection/group/removeConnection"
        value = [PATH_REMOVE_CONNECTION_FROM_GROUP],
        produces = ["*/*"]
    )
    fun removeConnectionFromGroup(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "whether to return nulls or not", required = true) @Valid @RequestParam(value = "returnNulls", required = true) returnNulls: kotlin.Boolean,
        @NotNull @Parameter(description = "the group id", required = true) @Valid @RequestParam(value = "groupId", required = true) groupId: kotlin.Long,
        @Parameter(description = "the device id (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "the account id of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "the connection id") @Valid @RequestParam(value = "connectionId", required = false) connectionId: kotlin.Long?,
        @Parameter(description = "the connection account id") @Valid @RequestParam(value = "connectionAccountId", required = false) connectionAccountId: kotlin.Long?,
        @Parameter(description = "the pending id") @Valid @RequestParam(value = "pendingId", required = false) pendingId: kotlin.Long?,
        @Parameter(description = "the current latitude of the user") @Valid @RequestParam(value = "latitude", required = false) latitude: kotlin.Double?,
        @Parameter(description = "the current longitude of the user") @Valid @RequestParam(value = "longitude", required = false) longitude: kotlin.Double?
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Remove Connections",
        operationId = "removeConnectionsFromGroup",
        description = """Remove a list of connections from a group.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/connection/group/removeConnections"
        value = [PATH_REMOVE_CONNECTIONS_FROM_GROUP],
        produces = ["*/*"]
    )
    fun removeConnectionsFromGroup(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "connection group id", required = true) @Valid @RequestParam(value = "connectionGroupId", required = true) connectionGroupId: kotlin.Long,
        @Parameter(description = "the device id (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "the account id of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "comma separated list of connection ids") @Valid @RequestParam(value = "connectionIds", required = false) connectionIds: kotlin.String?,
        @Parameter(description = "comma separated list of connection account ids") @Valid @RequestParam(value = "connectionAccountIds", required = false) connectionAccountIds: kotlin.String?,
        @Parameter(description = "the current latitude of the user") @Valid @RequestParam(value = "latitude", required = false) latitude: kotlin.Double?,
        @Parameter(description = "the current longitude of the user") @Valid @RequestParam(value = "longitude", required = false) longitude: kotlin.Double?
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Delete Dependent",
        operationId = "removeDependent",
        description = """Delete the Dependent""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation") ]
    )
    @RequestMapping(
        method = [RequestMethod.DELETE],
        // "/api/{version}/cargo/dependent/{accountId}"
        value = [PATH_REMOVE_DEPENDENT]
    )
    fun removeDependent(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "the id of the parent account tied to the dependent", required = true) @PathVariable("accountId") accountId: kotlin.Long,
        @Parameter(description = "the id of the dependent to delete", required = true) @PathVariable("dependentId") dependentId: kotlin.Long
    ): ResponseEntity<Unit> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Delete Connection Group",
        operationId = "removeGroup",
        description = """Remove a user's group.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/consumer/connection/group/remove"
        value = [PATH_REMOVE_GROUP],
        produces = ["*/*"]
    )
    fun removeGroup(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "whether to return nulls or not", required = true) @Valid @RequestParam(value = "returnNulls", required = true) returnNulls: kotlin.Boolean,
        @NotNull @Parameter(description = "the group id", required = true) @Valid @RequestParam(value = "groupId", required = true) groupId: kotlin.Long,
        @Parameter(description = "the device id (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "the account id of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "the current latitude of the user") @Valid @RequestParam(value = "latitude", required = false) latitude: kotlin.Double?,
        @Parameter(description = "the current longitude of the user") @Valid @RequestParam(value = "longitude", required = false) longitude: kotlin.Double?
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Delete Like",
        operationId = "removeLike",
        description = """Removes a like. This will make the user "neutral".""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = LikableResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/like/delete"
        value = [PATH_REMOVE_LIKE],
        produces = ["*/*"]
    )
    fun removeLike(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The type of the likable object {ALBUM, ALBUM_CONTEST, ASSET, GAME_LEVEL, NOTE, THEME_DESCRIPTOR}", required = true) @Valid @RequestParam(value = "likableType", required = true) likableType: kotlin.String,
        @NotNull @Parameter(description = "The id of the likable object", required = true) @Valid @RequestParam(value = "likableId", required = true) likableId: kotlin.Long,
        @Parameter(description = "The unique device identifier that made the request (either deviceId or accountId must be used)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "The unique accountId that made the request (either deviceId or accountId must be used)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "The current location of the user") @Valid @RequestParam(value = "latitude", required = false) latitude: kotlin.Double?,
        @Parameter(description = "The current location of the user") @Valid @RequestParam(value = "longitude", required = false) longitude: kotlin.Double?
    ): ResponseEntity<LikableResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Remove Preview",
        operationId = "removePreview",
        description = """Remove this ad for preview for this account.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/creative/removepreview"
        value = [PATH_REMOVE_PREVIEW],
        produces = ["*/*"]
    )
    fun removePreview(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the ID of the logged in user", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "the ID of the creative to remove preview", required = true) @Valid @RequestParam(value = "creativeId", required = true) creativeId: kotlin.Long
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Delete Stop",
        operationId = "removeStop",
        description = """Delete a stop on a route""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation") ]
    )
    @RequestMapping(
        method = [RequestMethod.DELETE],
        // "/api/{version}/route/{routeId}/stop/{stopId}"
        value = [PATH_REMOVE_STOP]
    )
    fun removeStop(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "the id of the route", required = true) @PathVariable("routeId") routeId: kotlin.Long,
        @Parameter(description = "the id of the specific stop to delete on the route", required = true) @PathVariable("stopId") stopId: kotlin.Long
    ): ResponseEntity<Unit> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Remove Connection Groups",
        operationId = "removeSubGroups",
        description = """Remove sub groups from a group""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/consumer/connection/group/removeSubGroup"
        value = [PATH_REMOVE_SUB_GROUPS],
        produces = ["*/*"]
    )
    fun removeSubGroups(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "whether to return nulls or not", required = true) @Valid @RequestParam(value = "returnNulls", required = true) returnNulls: kotlin.Boolean,
        @NotNull @Parameter(description = "the parent group id", required = true) @Valid @RequestParam(value = "groupId", required = true) groupId: kotlin.Long,
        @NotNull @Parameter(description = "comma separated list of group IDs to remove from the parent group", required = true) @Valid @RequestParam(value = "subGroupIds", required = true) subGroupIds: kotlin.String,
        @Parameter(description = "the device id (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "the account id of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "the current latitude of the user") @Valid @RequestParam(value = "latitude", required = false) latitude: kotlin.Double?,
        @Parameter(description = "the current longitude of the user") @Valid @RequestParam(value = "longitude", required = false) longitude: kotlin.Double?
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Delete Theme",
        operationId = "removeThemeDescriptor",
        description = """Removes a theme.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/consumer/theme/remove"
        value = [PATH_REMOVE_THEME_DESCRIPTOR],
        produces = ["*/*"]
    )
    fun removeThemeDescriptor(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the theme id to remove", required = true) @Valid @RequestParam(value = "themeDescriptorId", required = true) themeDescriptorId: kotlin.Long,
        @Parameter(description = "a unique id given by the device (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "the account id of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "the unique title of an application given from the admin tool") @Valid @RequestParam(value = "gameType", required = false) gameType: kotlin.String?,
        @Parameter(description = "latitude used to update the user's current location") @Valid @RequestParam(value = "latitude", required = false) latitude: kotlin.Double?,
        @Parameter(description = "longitude used to update the user's current location") @Valid @RequestParam(value = "longitude", required = false) longitude: kotlin.Double?
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Remove User",
        operationId = "removeUsersFromPermissionable",
        description = """Used to remove someone (assuming they have permission) from a permissionable object""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/consumer/permissions/remove"
        value = [PATH_REMOVE_USERS_FROM_PERMISSIONABLE],
        produces = ["*/*"]
    )
    fun removeUsersFromPermissionable(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the permissionable type of the object", required = true, schema = Schema(allowableValues = ["ACCOUNT", "GAMELEVEL", "ALBUM_CONTEST", "THEME_DESCRIPTOR", "SCHEDULED_NOTIFICATION", "TASK", "TRIGGER"])) @Valid @RequestParam(value = "permissionableType", required = true) permissionableType: kotlin.String,
        @NotNull @Parameter(description = "the id of the permissionable object", required = true) @Valid @RequestParam(value = "permissionableId", required = true) permissionableId: kotlin.Long,
        @Parameter(description = "the device id (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "the account id of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "a comma separated list of connection ids (NOT the account ids)") @Valid @RequestParam(value = "connectionIds", required = false) connectionIds: kotlin.String?,
        @Parameter(description = "a comma separated list of account ids") @Valid @RequestParam(value = "connectionAccountIds", required = false) connectionAccountIds: kotlin.String?,
        @Parameter(description = "a comma separated list of connection group ids (these are groups made by the user)") @Valid @RequestParam(value = "connectionGroupIds", required = false) connectionGroupIds: kotlin.String?,
        @Parameter(description = "flag to determine whether to remove the built-in \"friends\" group", schema = Schema(defaultValue = "false")) @Valid @RequestParam(value = "removeFriendGroup", required = false, defaultValue = "false") removeFriendGroup: kotlin.Boolean,
        @Parameter(description = "the current latitude of the user") @Valid @RequestParam(value = "latitude", required = false) latitude: kotlin.Double?,
        @Parameter(description = "the current longitude of the user") @Valid @RequestParam(value = "longitude", required = false) longitude: kotlin.Double?,
        @Parameter(description = "comma separated list of audience ids. This will remove all users from these audiences from the permissionable object. Notifications will not be sent to users if this feature is used.") @Valid @RequestParam(value = "audienceIds", required = false) audienceIds: kotlin.String?
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Reorder Route Stops",
        operationId = "reorderRouteStopsPatch",
        description = """Reordering the stops on the route with and update route distance, time, direction, and polyline""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(array = ArraySchema(schema = Schema(implementation = Stop::class)))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.PATCH],
        // "/api/{version}/route/{routeId}/stops/reorder"
        value = [PATH_REORDER_ROUTE_STOPS_PATCH],
        produces = ["*/*"]
    )
    fun reorderRouteStopsPatch(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "the id of the route", required = true) @PathVariable("routeId") routeId: kotlin.Long,
        @Parameter(description = "") @Valid @RequestBody(required = false) body: kotlin.collections.List<Stop>?
    ): ResponseEntity<List<Stop>> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Reorder Route Stops",
        operationId = "reorderRouteStopsPost",
        description = """Reordering the stops on the route with and update route distance, time, direction, and polyline""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(array = ArraySchema(schema = Schema(implementation = Stop::class)))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/route/{routeId}/stops/reorder"
        value = [PATH_REORDER_ROUTE_STOPS_POST],
        produces = ["*/*"]
    )
    fun reorderRouteStopsPost(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "the id of the route", required = true) @PathVariable("routeId") routeId: kotlin.Long,
        @Parameter(description = "") @Valid @RequestBody(required = false) body: kotlin.collections.List<Stop>?
    ): ResponseEntity<List<Stop>> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Request Optimization",
        operationId = "requestOptimization",
        description = """Request and upload of shipment orders and create ShipmentImportBatch for optimization.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = ImportStatuses::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/optimize/request"
        value = [PATH_REQUEST_OPTIMIZATION],
        produces = ["*/*"]
    )
    fun requestOptimization(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "") @Valid @RequestBody(required = false) body: Orders?
    ): ResponseEntity<ImportStatuses> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Request Password Reset",
        operationId = "requestPasswordReset",
        description = """Request that an account password be reset. The account is looked up by email address and then a link is sent via email to that account with a reset token. The token is valid for 24 hours.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/account/requestpasswordreset"
        value = [PATH_REQUEST_PASSWORD_RESET],
        produces = ["*/*"]
    )
    fun requestPasswordReset(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The email/username of the account", required = true) @Valid @RequestParam(value = "email", required = true) email: kotlin.String,
        @Parameter(description = "this is the sender email", schema = Schema(defaultValue = "Sirqul")) @Valid @RequestParam(value = "from", required = false, defaultValue = "Sirqul") from: kotlin.String,
        @Parameter(description = "this is the domain (like dev.sirqul.com) used to generate the password reset link") @Valid @RequestParam(value = "domain", required = false) domain: kotlin.String?,
        @Parameter(description = "this is the the subUrl (like resetpassword) used to generate a password reset link") @Valid @RequestParam(value = "subUrl", required = false) subUrl: kotlin.String?,
        @Parameter(description = "this is used to generate a password reset link", schema = Schema(defaultValue = "http://dev.sirqul.com/resetpassword")) @Valid @RequestParam(value = "referer", required = false, defaultValue = "http://dev.sirqul.com/resetpassword") referer: kotlin.String
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Send Validation Request",
        operationId = "requestValidateAccount",
        description = """Send an email to validate a user's account.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/account/requestValidateAccount"
        value = [PATH_REQUEST_VALIDATE_ACCOUNT],
        produces = ["*/*"]
    )
    fun requestValidateAccount(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The account id of the user", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Update Availability",
        operationId = "reservableAvailability",
        description = """""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(array = ArraySchema(schema = Schema(implementation = AvailabilityResponse::class)))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/reservable/availability/update"
        value = [PATH_RESERVABLE_AVAILABILITY],
        produces = ["*/*"]
    )
    fun reservableAvailability(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the id of the reservation", required = true) @Valid @RequestParam(value = "reservableId", required = true) reservableId: kotlin.Long,
        @NotNull @Parameter(description = "the type of reservation", required = true, schema = Schema(allowableValues = ["LOCATABLE", "RESERVABLE", "PERMISSIONABLE", "NOTABLE", "ASSETABLE", "LIKABLE", "FLAGABLE", "FAVORITABLE", "RATABLE", "ALBUM", "COLLECTION", "APPLICATION", "APPLICATION_SETTING", "APPLICATION_CERT", "APPLICATION_PLACEMENT", "ACCOUNT", "ACCOUNT_SETTING", "GAME_LEVEL", "PACK", "MISSION", "TOURNAMENT", "ASSET", "ALBUM_CONTEST", "THEME_DESCRIPTOR", "OFFER", "OFFER_LOCATION", "EVENT", "RETAILER", "RETAILER_LOCATION", "NOTE", "CREATIVE", "FAVORITE", "LIKE", "RATING", "ANALYTIC", "THIRD_PARTY_CREDENTIAL", "THIRD_PARTY_NETWORK", "REGION"])) @Valid @RequestParam(value = "reservableType", required = true) reservableType: kotlin.String,
        @Parameter(description = "the device id of the reservation") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "the id of the logged in user") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "Availability") @Valid @RequestParam(value = "availability", required = false) availability: kotlin.String?,
        @Parameter(description = "Availability Summary") @Valid @RequestParam(value = "availabilitySummary", required = false) availabilitySummary: kotlin.String?
    ): ResponseEntity<List<AvailabilityResponse>> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Rest Secure Application",
        operationId = "resetSecure",
        description = """Reset a secure application client.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/secure/application/reset"
        value = [PATH_RESET_SECURE],
        produces = ["*/*"]
    )
    fun resetSecure(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The unique id of the user making the request", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "The application to secure", required = true) @Valid @RequestParam(value = "appKey", required = true) appKey: kotlin.String
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Invite to Retailer Location",
        operationId = "retailerLocationInvite",
        description = """Allows a user to invite people to favorite a retailer location. This will generate an invite token, which when used, will give the invitee the retailer location in their favorite's list.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = InviteResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/invite/retailerLocation"
        value = [PATH_RETAILER_LOCATION_INVITE],
        produces = ["*/*"]
    )
    fun retailerLocationInvite(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the account ID of the user making the share", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "the application key", required = true) @Valid @RequestParam(value = "appKey", required = true) appKey: kotlin.String,
        @NotNull @Parameter(description = "The retailer location id of where the event will take place", required = true) @Valid @RequestParam(value = "retailerLocationId", required = true) retailerLocationId: kotlin.Long,
        @Parameter(description = "Optional album id to link with the invite") @Valid @RequestParam(value = "albumId", required = false) albumId: kotlin.Long?
    ): ResponseEntity<InviteResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Login Retailer",
        operationId = "retailerLoginCheck",
        description = """Retailer login check.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = AccountLoginResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/retailer/login"
        value = [PATH_RETAILER_LOGIN_CHECK],
        produces = ["*/*"]
    )
    fun retailerLoginCheck(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the user's email address they used to sign-up", required = true) @Valid @RequestParam(value = "username", required = true) username: kotlin.String,
        @NotNull @Parameter(description = "the password", required = true) @Valid @RequestParam(value = "password", required = true) password: kotlin.String,
        @Parameter(description = "the device id (optional)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "the current latitude of the user") @Valid @RequestParam(value = "latitude", required = false) latitude: kotlin.Double?,
        @Parameter(description = "the current longitude of the user") @Valid @RequestParam(value = "longitude", required = false) longitude: kotlin.Double?,
        @Parameter(description = "the application key") @Valid @RequestParam(value = "appKey", required = false) appKey: kotlin.String?
    ): ResponseEntity<AccountLoginResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Set Trip Preference Rider",
        operationId = "ride",
        description = """Update trip preference to ride.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = Trip::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/trip/{id}/ride"
        value = [PATH_RIDE],
        produces = ["*/*"]
    )
    fun ride(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "the id of the trip", required = true) @PathVariable("id") id: kotlin.Long,
        @NotNull @Parameter(description = "the frequency of the trip (e.g. weekly, until 2018-08-09)", required = true) @Valid @RequestParam(value = "recurrence", required = true) recurrence: kotlin.Boolean
    ): ResponseEntity<Trip> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Run Report",
        operationId = "runReport",
        description = """ This endpoint allows you to run a set of predefined reports that can be used to understand your users' behavior as well as trends within your application.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = ReportResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/report/run"
        value = [PATH_RUN_REPORT],
        produces = ["*/*"]
    )
    fun runReport(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "If true then descending order, false is ascending", required = true) @Valid @RequestParam(value = "desc", required = true) desc: kotlin.Boolean,
        @Parameter(description = "The account id of the user for passing account related params") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "The named identifier of the query") @Valid @RequestParam(value = "query", required = false) query: kotlin.String?,
        @Parameter(description = "Parameter values used in the query in JSON format, example: ```json {   \"string\":\"value\",    \"number\":3.345,   \"date\":\"2014-05-01 00:00:00\" } ``` ") @Valid @RequestParam(value = "parameters", required = false) parameters: kotlin.String?,
        @Parameter(description = "The order to use, must be a column name (see response results for list of column names)") @Valid @RequestParam(value = "order", required = false) order: kotlin.String?,
        @Parameter(description = "The start of the pagination") @Valid @RequestParam(value = "start", required = false) start: kotlin.Long?,
        @Parameter(description = "The limit of the pagination") @Valid @RequestParam(value = "limit", required = false) limit: kotlin.Long?,
        @Parameter(description = "Determines what response format to return. Options are: JSON or CSV", schema = Schema(allowableValues = ["HTML", "XML", "JSON", "CSV"])) @Valid @RequestParam(value = "responseFormat", required = false) responseFormat: kotlin.String?
    ): ResponseEntity<ReportResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Run Workflow",
        operationId = "runWorkflow",
        description = """Runs a published executable workflow""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/workflow/run"
        value = [PATH_RUN_WORKFLOW],
        produces = ["*/*"]
    )
    fun runWorkflow(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the account ID of the user", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "the workflow to run", required = true) @Valid @RequestParam(value = "workflowId", required = true) workflowId: kotlin.Long,
        @Parameter(description = "this runs a particular sku on the workflow") @Valid @RequestParam(value = "skuId", required = false) skuId: kotlin.Long?,
        @Parameter(description = "this runs a particular sku version on the workflow") @Valid @RequestParam(value = "versionCode", required = false) versionCode: kotlin.Int?,
        @Parameter(description = "Override parameters in JSON format. Example: ```json {   \"arguments_81\": { \"filter\": \"PUBLIC\" },   \"arguments_87\": { \"tag\": \"custom_tag\" } } ``` ") @Valid @RequestParam(value = "parameters", required = false) parameters: kotlin.String?
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Save Ticket",
        operationId = "saveTicket",
        description = """Allow user to acquire a purchase item and generate a ticket record. Used to redeem tickets or add tickets to the system.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = ProfileResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/ticket/save"
        value = [PATH_SAVE_TICKET],
        produces = ["*/*"]
    )
    fun saveTicket(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the action being performed, values: COMPLETED, // ADD TICKETS FOR COMPLETING A MISSION, CHALLENGE, GAME, PACK, LEVEL, LEVEL OBJECT REDEEMED, // REMOVE TICKETS FOR BUYING PACKS, HINTS, AND PEN TOOLS OPTIONS, ETC USERS_PLAYED, // ADD TICKETS FOR LEVELS PLAYED BY OTHER USERS TOURNAMENT_OWNER, // ADD TICKETS FOR TOURNAMENTS BY OTHER USERS PURCHASED, // ADD TICKET VIA IN APP PURCHASING SUMATION, // SUMATION OF TICKETS EARNED FROM CHILDREN GIFTED, // TRANSFERING OF PURCHASE ITEMS TO OTHER PEOPLE REFUNDED // FOR REFUNDING TICKETS BACK TO THE USER", required = true) @Valid @RequestParam(value = "actionType", required = true) actionType: kotlin.String,
        @NotNull @Parameter(description = "the type of object being purchased, values: GAME_OBJECT, GAME_LEVEL, PACK, GAME, MISSION, PROFILE, APPLICATION, TICKETS, ASSET, CUSTOM", required = true) @Valid @RequestParam(value = "ticketObjectType", required = true) ticketObjectType: kotlin.String,
        @Parameter(description = "whether to return nulls or not") @Valid @RequestParam(value = "returnNulls", required = false) returnNulls: kotlin.Boolean?,
        @Parameter(description = "the device id that owns the tickets") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "the account id that owns the tickets") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "This parameter is deprecated. deprecated, use the appKey") @Valid @RequestParam(value = "gameType", required = false) gameType: kotlin.String?,
        @Parameter(description = "the application key") @Valid @RequestParam(value = "appKey", required = false) appKey: kotlin.String?,
        @Parameter(description = "the ID of the item being purchased") @Valid @RequestParam(value = "objectId", required = false) objectId: kotlin.Long?,
        @Parameter(description = "a unique string identifier defined by the application owner or Executive") @Valid @RequestParam(value = "purchaseCode", required = false) purchaseCode: kotlin.String?,
        @Parameter(description = "a unique transaction identifier from the purchase provider (i.e. the transaction ID from iTunes, Google Play, etc)") @Valid @RequestParam(value = "receiptToken", required = false) receiptToken: kotlin.String?,
        @Parameter(description = "the receipt/transaction data for validating a purchase via iTunes/Gooogle/etc. This should be in string format.") @Valid @RequestParam(value = "receiptData", required = false) receiptData: kotlin.String?,
        @Parameter(description = "the count of tickets") @Valid @RequestParam(value = "count", required = false) count: kotlin.Long?,
        @Parameter(description = "the ticket type") @Valid @RequestParam(value = "ticketType", required = false) ticketType: kotlin.String?,
        @Parameter(description = "the provider for making the purchase {ITUNES, ITUNES_SANDBOX, GOOGLE}") @Valid @RequestParam(value = "purchaseProvider", required = false) purchaseProvider: kotlin.String?,
        @Parameter(description = "a comma separated list of purchase types { SIRQUL, // purchasing from the sirqul store using tickets IOS, // purchasing from the itunes store for iPhone, iPod, iPod Touch GOOGLE, // purchasing from the google android store AMAZON, // purchasing from the amazon android store MAC, // purchasing from the itunes store for OSX WP8, // purhasing from the windows phone 8 store FREE }") @Valid @RequestParam(value = "purchaseType", required = false) purchaseType: kotlin.String?,
        @Parameter(description = "returns a ProfileResponse if true, otherwise will return an AppResponse") @Valid @RequestParam(value = "returnProfileResponse", required = false) returnProfileResponse: kotlin.Boolean?,
        @Parameter(description = "if returnProfileResponse is false, will return an AppResponse with profile data if true") @Valid @RequestParam(value = "includeProfileResponse", required = false) includeProfileResponse: kotlin.Boolean?,
        @Parameter(description = "the application version") @Valid @RequestParam(value = "appVersion", required = false) appVersion: kotlin.String?
    ): ResponseEntity<ProfileResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Save Ticket with Reciept",
        operationId = "saveTicketViaFileUpload",
        description = """Similar to the Save Ticket endpoint but allows the receiptData to be in binary format. This must be a multi-part post""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = ProfileResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/ticket/save/fileUpload"
        value = [PATH_SAVE_TICKET_VIA_FILE_UPLOAD],
        produces = ["*/*"]
    )
    fun saveTicketViaFileUpload(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the action being performed { COMPLETED, // ADD TICKETS FOR COMPLETING A MISSION, CHALLENGE, GAME, PACK, LEVEL, LEVEL OBJECT REDEEMED, // REMOVE TICKETS FOR BUYING PACKS, HINTS, AND PEN TOOLS OPTIONS, ETC USERS_PLAYED, // ADD TICKETS FOR LEVELS PLAYED BY OTHER USERS TOURNAMENT_OWNER, // ADD TICKETS FOR TOURNAMENTS BY OTHER USERS PURCHASED, // ADD TICKET VIA IN APP PURCHASING SUMATION, // SUMATION OF TICKETS EARNED FROM CHILDREN GIFTED, // TRANSFERING OF PURCHASE ITEMS TO OTHER PEOPLE REFUNDED // FOR REFUNDING TICKETS BACK TO THE USER }", required = true) @Valid @RequestParam(value = "actionType", required = true) actionType: kotlin.String,
        @NotNull @Parameter(description = "the type of object being purchased {GAME_OBJECT, GAME_LEVEL, PACK, GAME, MISSION, PROFILE, APPLICATION, TICKETS, ASSET, CUSTOM}", required = true) @Valid @RequestParam(value = "ticketObjectType", required = true) ticketObjectType: kotlin.String,
        @NotNull @Parameter(description = "the receipt/transaction data for validating a purchase via iTunes/Gooogle/etc. This should be in binary format.", required = true) @Valid @RequestParam(value = "receiptData", required = true) receiptData: org.springframework.web.multipart.MultipartFile,
        @Parameter(description = "whether to return nulls or not") @Valid @RequestParam(value = "returnNulls", required = false) returnNulls: kotlin.Boolean?,
        @Parameter(description = "the device id") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "the account id") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "This parameter is deprecated. deprecated, use the appKey") @Valid @RequestParam(value = "gameType", required = false) gameType: kotlin.String?,
        @Parameter(description = "the application key") @Valid @RequestParam(value = "appKey", required = false) appKey: kotlin.String?,
        @Parameter(description = "the ID of the item being purchased") @Valid @RequestParam(value = "objectId", required = false) objectId: kotlin.Long?,
        @Parameter(description = "a unique string identifier defined by the application owner or Executive") @Valid @RequestParam(value = "purchaseCode", required = false) purchaseCode: kotlin.String?,
        @Parameter(description = "a unique transaction identifier from the purchase provider (i.e. the transaction ID from iTunes, Google Play, etc)") @Valid @RequestParam(value = "receiptToken", required = false) receiptToken: kotlin.String?,
        @Parameter(description = "the count of tickets") @Valid @RequestParam(value = "count", required = false) count: kotlin.Long?,
        @Parameter(description = "the ticket type") @Valid @RequestParam(value = "ticketType", required = false) ticketType: kotlin.String?,
        @Parameter(description = "the provider for making the purchase {ITUNES, ITUNES_SANDBOX, GOOGLE}") @Valid @RequestParam(value = "purchaseProvider", required = false) purchaseProvider: kotlin.String?,
        @Parameter(description = "a comma separated list of purchase types { SIRQUL, // purchasing from the sirqul store using tickets IOS, // purchasing from the itunes store for iPhone, iPod, iPod Touch GOOGLE, // purchasing from the google android store AMAZON, // purchasing from the amazon android store MAC, // purchasing from the itunes store for OSX WP8, // purhasing from the windows phone 8 store FREE }") @Valid @RequestParam(value = "purchaseType", required = false) purchaseType: kotlin.String?,
        @Parameter(description = "returns a ProfileResponse if true, otherwise will return an AppResponse") @Valid @RequestParam(value = "returnProfileResponse", required = false) returnProfileResponse: kotlin.Boolean?,
        @Parameter(description = "if returnProfileResponse is false, will return an AppResponse with profile data if true") @Valid @RequestParam(value = "includeProfileResponse", required = false) includeProfileResponse: kotlin.Boolean?,
        @Parameter(description = "the application version") @Valid @RequestParam(value = "appVersion", required = false) appVersion: kotlin.String?
    ): ResponseEntity<ProfileResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Create Tracking Leg",
        operationId = "saveTrackingLeg",
        description = """Send tracking points to be able to generate pathing data""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/tracking/leg/create"
        value = [PATH_SAVE_TRACKING_LEG],
        produces = ["*/*"]
    )
    fun saveTrackingLeg(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the latitude of the first point", required = true) @Valid @RequestParam(value = "startLat", required = true) startLat: kotlin.Double,
        @NotNull @Parameter(description = "the longitude of the first point", required = true) @Valid @RequestParam(value = "startLng", required = true) startLng: kotlin.Double,
        @NotNull @Parameter(description = "the start date (in UTC milliseconds) of the first point", required = true) @Valid @RequestParam(value = "startDate", required = true) startDate: kotlin.Long,
        @NotNull @Parameter(description = "the latitude of the last point", required = true) @Valid @RequestParam(value = "endLat", required = true) endLat: kotlin.Double,
        @NotNull @Parameter(description = "the longitude of the last point", required = true) @Valid @RequestParam(value = "endLng", required = true) endLng: kotlin.Double,
        @NotNull @Parameter(description = "the end date (in UTC milliseconds) of the last point", required = true) @Valid @RequestParam(value = "endDate", required = true) endDate: kotlin.Long,
        @Parameter(description = "the device id (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "the account id of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "the total distance") @Valid @RequestParam(value = "distance", required = false) distance: kotlin.Double?,
        @Parameter(description = "the total duration") @Valid @RequestParam(value = "duration", required = false) duration: kotlin.Long?,
        @Parameter(description = "JSON array of tracking vectors used for smoother pathing data. If null then the leg data will be used to generate a single step, if an empty array then no steps will be generated. ```json [{   \"distance\": \"0.03\",   \"duration\": \"5000\",   \"startLat\": \"47.614603\",   \"startLng\": \"-122.350518\",   \"startDate\": \"1361924010000\",   \"endLat\": \"47.614941\",   \"endLng\": \"-122.350062\",   \"endDate\": \"1361924015000\" }] ``` ") @Valid @RequestParam(value = "steps", required = false) steps: kotlin.String?,
        @Parameter(description = "name the leg for searching") @Valid @RequestParam(value = "tags", required = false) tags: kotlin.String?
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Create Tracking Step",
        operationId = "saveTrackingStep",
        description = """Send tracking points to be able to generate pathing data""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/tracking/step/create"
        value = [PATH_SAVE_TRACKING_STEP],
        produces = ["*/*"]
    )
    fun saveTrackingStep(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the leg to add the step to", required = true) @Valid @RequestParam(value = "legId", required = true) legId: kotlin.Long,
        @NotNull @Parameter(description = "the latitude of the first point", required = true) @Valid @RequestParam(value = "startLat", required = true) startLat: kotlin.Double,
        @NotNull @Parameter(description = "the longitude of the first point", required = true) @Valid @RequestParam(value = "startLng", required = true) startLng: kotlin.Double,
        @NotNull @Parameter(description = "the start date (in UTC milliseconds) of the first point", required = true) @Valid @RequestParam(value = "startDate", required = true) startDate: kotlin.Long,
        @NotNull @Parameter(description = "the latitude of the last point", required = true) @Valid @RequestParam(value = "endLat", required = true) endLat: kotlin.Double,
        @NotNull @Parameter(description = "the longitude of the last point", required = true) @Valid @RequestParam(value = "endLng", required = true) endLng: kotlin.Double,
        @NotNull @Parameter(description = "the end date (in UTC milliseconds) of the last point", required = true) @Valid @RequestParam(value = "endDate", required = true) endDate: kotlin.Long,
        @Parameter(description = "the device id (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "the account id of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "the total distance") @Valid @RequestParam(value = "distance", required = false) distance: kotlin.Double?,
        @Parameter(description = "the total duration") @Valid @RequestParam(value = "duration", required = false) duration: kotlin.Long?
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Generate Schedule Notifications",
        operationId = "scheduleNotificationListings",
        description = """Use a report to identify events that are starting soon and then create a scheduled notification to push a message to matching users.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/notification/schedule/generate"
        value = [PATH_SCHEDULE_NOTIFICATION_LISTINGS],
        produces = ["*/*"]
    )
    fun scheduleNotificationListings(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The logged in user.", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "The application to target", required = true) @Valid @RequestParam(value = "appKey", required = true) appKey: kotlin.String,
        @NotNull @Parameter(description = "The name of the report used to identify events. The report must return columns named: id, name, date, params, and type otherwise it will fail", required = true) @Valid @RequestParam(value = "reportName", required = true) reportName: kotlin.String,
        @NotNull @Parameter(description = "The message to be sent to the recipients. If you set %name% the report row name value will be swapped in. If you set %time% or %date% the report row start date/time value will be swapped in", required = true) @Valid @RequestParam(value = "message", required = true) message: kotlin.String,
        @NotNull @Parameter(description = "Time in munites before the event starts to notify recipients", required = true) @Valid @RequestParam(value = "offset", required = true) offset: kotlin.Int,
        @NotNull @Parameter(description = "The report id used to generate the recipient list", required = true) @Valid @RequestParam(value = "recipientReportId", required = true) recipientReportId: kotlin.Long,
        @Parameter(description = "The parameters of the report used to identify events in a json structure, example: ```json {   \"string\": \"value\",   \"number\": 3.345,   \"date\": \"2014-05-01 00:00:00\" } ``` ") @Valid @RequestParam(value = "reportParams", required = false) reportParams: kotlin.String?,
        @Parameter(description = "The type of scheduled notification; supported values are: MOBILE_NOTIFICATION") @Valid @RequestParam(value = "type", required = false) type: kotlin.String?
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Search Trips",
        operationId = "search",
        description = """Search for trips""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(array = ArraySchema(schema = Schema(implementation = Trip::class)))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/trip"
        value = [PATH_SEARCH],
        produces = ["*/*"]
    )
    fun search(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The owner of the trips", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "The field to sort by", required = true) @Valid @RequestParam(value = "sortField", required = true) sortField: kotlin.String,
        @NotNull @Parameter(description = "Determines whether the sorted list is in descending or ascending order", required = true) @Valid @RequestParam(value = "descending", required = true) descending: kotlin.Boolean,
        @NotNull @Parameter(description = "The start index for pagination", required = true) @Valid @RequestParam(value = "start", required = true) start: kotlin.Int,
        @NotNull @Parameter(description = "The limit for pagination", required = true) @Valid @RequestParam(value = "limit", required = true) limit: kotlin.Int,
        @NotNull @Parameter(description = "Return only active results", required = true) @Valid @RequestParam(value = "activeOnly", required = true) activeOnly: kotlin.Boolean,
        @Parameter(description = "The lower bound limit of time") @Valid @RequestParam(value = "startDate", required = false) startDate: kotlin.Long?,
        @Parameter(description = "The upper bound limit of time") @Valid @RequestParam(value = "endDate", required = false) endDate: kotlin.Long?,
        @Parameter(description = "whether to search on trips that have notifications or not") @Valid @RequestParam(value = "hasNotifications", required = false) hasNotifications: kotlin.Boolean?
    ): ResponseEntity<List<Trip>> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Search Accounts",
        operationId = "searchAccounts",
        description = """Search for account profiles.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(array = ArraySchema(schema = Schema(implementation = ProfileResponse::class)))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/account/profile/search"
        value = [PATH_SEARCH_ACCOUNTS],
        produces = ["*/*"]
    )
    fun searchAccounts(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The id of the account requesting", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "The application key", required = true) @Valid @RequestParam(value = "appKey", required = true) appKey: kotlin.String,
        @Parameter(description = "The keyword for for querying the account") @Valid @RequestParam(value = "keyword", required = false) keyword: kotlin.String?,
        @Parameter(description = "the latitude") @Valid @RequestParam(value = "latitude", required = false) latitude: kotlin.Double?,
        @Parameter(description = "the longitude") @Valid @RequestParam(value = "longitude", required = false) longitude: kotlin.Double?,
        @Parameter(description = "the radius", schema = Schema(defaultValue = "5.0")) @Valid @RequestParam(value = "radius", required = false, defaultValue = "5.0") radius: kotlin.Double,
        @Parameter(description = "the user's gender", schema = Schema(allowableValues = ["MALE", "FEMALE", "ANY"])) @Valid @RequestParam(value = "gender", required = false) gender: kotlin.String?,
        @Parameter(description = "the user's Game Experience", schema = Schema(allowableValues = ["ANY", "NEW", "BEGINNER", "INTERMEDIATE", "EXPERT"])) @Valid @RequestParam(value = "gameExperience", required = false) gameExperience: kotlin.String?,
        @Parameter(description = "the user's age") @Valid @RequestParam(value = "age", required = false) age: kotlin.Int?,
        @Parameter(description = "the user's Category Ids") @Valid @RequestParam(value = "categoryIds", required = false) categoryIds: kotlin.String?,
        @Parameter(description = "Return Nulls", schema = Schema(defaultValue = "true")) @Valid @RequestParam(value = "returnNulls", required = false, defaultValue = "true") returnNulls: kotlin.Boolean,
        @Parameter(description = "A comma separated list of ProfileFilters for filtering the returned response data", schema = Schema(defaultValue = "PROFILE")) @Valid @RequestParam(value = "responseFilters", required = false, defaultValue = "PROFILE") responseFilters: kotlin.String,
        @Parameter(description = "A comma separated list of PurchaseType", schema = Schema(defaultValue = "SIRQUL")) @Valid @RequestParam(value = "purchaseType", required = false, defaultValue = "SIRQUL") purchaseType: kotlin.String,
        @Parameter(description = "The field to sort by", schema = Schema(defaultValue = "id")) @Valid @RequestParam(value = "sortField", required = false, defaultValue = "id") sortField: kotlin.String,
        @Parameter(description = "The order to return the results. Default is false, which will return the results in ascending order.", schema = Schema(defaultValue = "false")) @Valid @RequestParam(value = "descending", required = false, defaultValue = "false") descending: kotlin.Boolean,
        @Parameter(description = "The index into the record set to start with.", schema = Schema(defaultValue = "0")) @Valid @RequestParam(value = "start", required = false, defaultValue = "0") start: kotlin.Int,
        @Parameter(description = "The total number of record to return.", schema = Schema(defaultValue = "20")) @Valid @RequestParam(value = "limit", required = false, defaultValue = "20") limit: kotlin.Int,
        @Parameter(description = "Determines whether to return only active results. Default is false.", schema = Schema(defaultValue = "false")) @Valid @RequestParam(value = "activeOnly", required = false, defaultValue = "false") activeOnly: kotlin.Boolean
    ): ResponseEntity<List<ProfileResponse>> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "List Tracking",
        operationId = "searchAccountsWithTrackingLegs",
        description = """Search for all accounts that have tracking legs data by the given constraints.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(array = ArraySchema(schema = Schema(implementation = AccountMiniResponse::class)))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/tracking/list"
        value = [PATH_SEARCH_ACCOUNTS_WITH_TRACKING_LEGS],
        produces = ["*/*"]
    )
    fun searchAccountsWithTrackingLegs(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The account id of the user", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @Parameter(description = "Used for LIKE search of first or last name on the acocunt") @Valid @RequestParam(value = "keyword", required = false) keyword: kotlin.String?,
        @Parameter(description = "Range to begin in UTC milliseconds") @Valid @RequestParam(value = "startDate", required = false) startDate: kotlin.Long?,
        @Parameter(description = "Range to end in UTC milliseconds") @Valid @RequestParam(value = "endDate", required = false) endDate: kotlin.Long?,
        @Parameter(description = "Exact match on tag field of Legs's searchTag") @Valid @RequestParam(value = "tags", required = false) tags: kotlin.String?,
        @Parameter(description = "") @Valid @RequestParam(value = "audienceIds", required = false) audienceIds: kotlin.String?,
        @Parameter(description = "Origin latitude to perform searching constraints with given range") @Valid @RequestParam(value = "latitude", required = false) latitude: kotlin.Double?,
        @Parameter(description = "Origin longitude to perform searching constraints with given range") @Valid @RequestParam(value = "longitude", required = false) longitude: kotlin.Double?,
        @Parameter(description = "The radius, in miles, to perform the search for", schema = Schema(defaultValue = "5.0")) @Valid @RequestParam(value = "range", required = false, defaultValue = "5.0") range: kotlin.Double,
        @Parameter(description = "The column to sort the search on. Possible values include: {LEG_START_DATE, ACCOUNT_DISPLAY}", schema = Schema(defaultValue = "LEG_START_DATE")) @Valid @RequestParam(value = "sortField", required = false, defaultValue = "LEG_START_DATE") sortField: kotlin.String,
        @Parameter(description = "The order to return the results. Default is false, which will return the results in ascending order.", schema = Schema(defaultValue = "true")) @Valid @RequestParam(value = "descending", required = false, defaultValue = "true") descending: kotlin.Boolean,
        @Parameter(description = "The index into the record set to start with. Default is 0.", schema = Schema(defaultValue = "0")) @Valid @RequestParam(value = "start", required = false, defaultValue = "0") start: kotlin.Int,
        @Parameter(description = "The total number of records to return. Default is 20.", schema = Schema(defaultValue = "20")) @Valid @RequestParam(value = "limit", required = false, defaultValue = "20") limit: kotlin.Int,
        @Parameter(description = "Determines whether to return only active results. Default is false.", schema = Schema(defaultValue = "false")) @Valid @RequestParam(value = "activeOnly", required = false, defaultValue = "false") activeOnly: kotlin.Boolean
    ): ResponseEntity<List<AccountMiniResponse>> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Search Achievements",
        operationId = "searchAchievements",
        description = """Searches achievements by application for consumers.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(array = ArraySchema(schema = Schema(implementation = AchievementShortResponse::class)))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/achievement/search"
        value = [PATH_SEARCH_ACHIEVEMENTS],
        produces = ["*/*"]
    )
    fun searchAchievements(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the application key", required = true) @Valid @RequestParam(value = "appKey", required = true) appKey: kotlin.String,
        @NotNull @Parameter(description = "the field to sort by. See AchievementApiMap", required = true, schema = Schema(allowableValues = ["CREATED", "UPDATED", "DELETED", "SEARCH_TAGS", "ACTIVE", "TITLE", "DESCRIPTION", "RANK_TYPE", "APPLICATION_ID", "APPLICATION_NAME", "BILLABLE_ID"], defaultValue = "TITLE")) @Valid @RequestParam(value = "sortField", required = true, defaultValue = "TITLE") sortField: kotlin.String,
        @NotNull @Parameter(description = "determines whether the sorted list is in descending or ascending order", required = true, schema = Schema(defaultValue = "false")) @Valid @RequestParam(value = "descending", required = true, defaultValue = "false") descending: kotlin.Boolean,
        @NotNull @Parameter(description = "return tiers, only applicable for version >3.18", required = true, schema = Schema(defaultValue = "false")) @Valid @RequestParam(value = "includeTiers", required = true, defaultValue = "false") includeTiers: kotlin.Boolean,
        @NotNull @Parameter(description = "return inactive tiers, only applicable when includeTiers is true, only applicable for version >3.18", required = true, schema = Schema(defaultValue = "false")) @Valid @RequestParam(value = "includeInactiveTiers", required = true, defaultValue = "false") includeInactiveTiers: kotlin.Boolean,
        @NotNull @Parameter(description = "the start index for pagination", required = true, schema = Schema(defaultValue = "0")) @Valid @RequestParam(value = "start", required = true, defaultValue = "0") start: kotlin.Int,
        @NotNull @Parameter(description = "the limit for pagination (has a hard limit of 1000)", required = true, schema = Schema(defaultValue = "100")) @Valid @RequestParam(value = "limit", required = true, defaultValue = "100") limit: kotlin.Int,
        @Parameter(description = "a unique id given by the device (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "the account id of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "the keyword used to filter results with (this returns results that have the keyword in the title or description of the achievement)") @Valid @RequestParam(value = "keyword", required = false) keyword: kotlin.String?,
        @Parameter(description = "filter results by the achievementType (these are exact case sensitive matches)") @Valid @RequestParam(value = "achievementType", required = false) achievementType: kotlin.String?,
        @Parameter(description = "filter results by the rankType (these are exact case sensitive matches)") @Valid @RequestParam(value = "rankType", required = false) rankType: kotlin.String?
    ): ResponseEntity<List<AchievementShortResponse>> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Search Albums",
        operationId = "searchAlbums",
        description = """Searches on Albums.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(array = ArraySchema(schema = Schema(implementation = AlbumFullResponse::class)))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/album/search"
        value = [PATH_SEARCH_ALBUMS],
        produces = ["*/*"]
    )
    fun searchAlbums(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "a comma separated list of filters: * MINE - Return albums that the user has created. * SHARED - Return albums that have been shared to the user via addAlbumUsers, or addUsersToPermissionable . * FOLLOWER - Return albums that have been created by the user's followers (the content needs to have been APPROVED or FEATURED). * FOLLOWING - Return albums that have been created by people who the user is following (the content needs to have been APPROVED or FEATURED). * PUBLIC - Return all PUBLIC albums that have been APPROVED or FEATURED. * ALL_PUBLIC - Return all PUBLIC albums regardless of whether they are approved or not (ignores the approval status). * LIKED - Return all albums that the user has liked. * FEATURED - Return all albums that have been featured. * PENDING - Return all pending albums. ", required = true) @Valid @RequestParam(value = "filter", required = true) filter: kotlin.String,
        @NotNull @Parameter(description = "id of custom albumType", required = true) @Valid @RequestParam(value = "albumTypeId", required = true) albumTypeId: kotlin.Long,
        @NotNull @Parameter(description = "filter albums with this album sub type", required = true) @Valid @RequestParam(value = "subType", required = true) subType: kotlin.String,
        @NotNull @Parameter(description = "determines whether to return inactive albums", required = true) @Valid @RequestParam(value = "includeInactive", required = true) includeInactive: kotlin.Boolean,
        @NotNull @Parameter(description = "the field to sort by. See AlbumApiMap", required = true) @Valid @RequestParam(value = "sortField", required = true) sortField: kotlin.String,
        @NotNull @Parameter(description = "determines whether the sorted list is in descending or ascending order", required = true) @Valid @RequestParam(value = "descending", required = true) descending: kotlin.Boolean,
        @NotNull @Parameter(description = "the start index for pagination", required = true) @Valid @RequestParam(value = "start", required = true) start: kotlin.Int,
        @NotNull @Parameter(description = "the limit for pagination (There is a hard limit of 100)", required = true) @Valid @RequestParam(value = "limit", required = true) limit: kotlin.Int,
        @NotNull @Parameter(description = "the maximum range the album can be from the center (used when sortField=ALBUM_DISTANCE)", required = true) @Valid @RequestParam(value = "range", required = true) range: kotlin.Double,
        @NotNull @Parameter(description = "returns whether or not the current logged in user has liked the album", required = true) @Valid @RequestParam(value = "includeLiked", required = true) includeLiked: kotlin.Boolean,
        @NotNull @Parameter(description = "returns whether or not the current logged in user has favorited the album", required = true) @Valid @RequestParam(value = "includeFavorited", required = true) includeFavorited: kotlin.Boolean,
        @NotNull @Parameter(description = "returns permission details on whether they have read/write/delete permissions etc (client app probably doesn't need this)", required = true) @Valid @RequestParam(value = "includePermissions", required = true) includePermissions: kotlin.Boolean,
        @NotNull @Parameter(description = "returns the last X likes", required = true) @Valid @RequestParam(value = "likePreviewSize", required = true) likePreviewSize: kotlin.Int,
        @NotNull @Parameter(description = "returns the first X assets", required = true) @Valid @RequestParam(value = "assetPreviewSize", required = true) assetPreviewSize: kotlin.Int,
        @NotNull @Parameter(description = "returns the last X notes", required = true) @Valid @RequestParam(value = "notePreviewSize", required = true) notePreviewSize: kotlin.Int,
        @NotNull @Parameter(description = "returns the first X users/connections", required = true) @Valid @RequestParam(value = "connectionPreviewSize", required = true) connectionPreviewSize: kotlin.Int,
        @NotNull @Parameter(description = "returns the first X audiences. To search on and paginate the remaining audiences, please use the \"/audience/search\" endpoint.", required = true) @Valid @RequestParam(value = "audiencePreviewSize", required = true) audiencePreviewSize: kotlin.Int,
        @Parameter(description = "a unique ID given by the device (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "the account ID of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "the account ID of the user that the results will be based on. This is used to return albums that this account has liked/favorited.") @Valid @RequestParam(value = "connectionAccountId", required = false) connectionAccountId: kotlin.Long?,
        @Parameter(description = "search on albums that have been created by this account (that the user has permissions to)") @Valid @RequestParam(value = "ownerId", required = false) ownerId: kotlin.Long?,
        @Parameter(description = "search on album within a comma separated list of album IDs (this does not work with sortField=ALBUM_DISTANCE, or when stackSearch=true)") @Valid @RequestParam(value = "albumIds", required = false) albumIds: kotlin.String?,
        @Parameter(description = "Only for CLOUDINDEX mode, exclude albums with ids matching this list") @Valid @RequestParam(value = "excludeAlbumIds", required = false) excludeAlbumIds: kotlin.String?,
        @Parameter(description = "search on albums that are in a particular media offering") @Valid @RequestParam(value = "mediaId", required = false) mediaId: kotlin.Long?,
        @Parameter(description = "keyword search string") @Valid @RequestParam(value = "keyword", required = false) keyword: kotlin.String?,
        @Parameter(description = "filter albums with this album type") @Valid @RequestParam(value = "albumType", required = false) albumType: kotlin.String?,
        @Parameter(description = "When using multiple album types this sets a per-album-type limit (used with cloud index mode)") @Valid @RequestParam(value = "limitPerAlbumType", required = false) limitPerAlbumType: kotlin.Int?,
        @Parameter(description = "return items that have been created before this date (time-stamp in milliseconds)") @Valid @RequestParam(value = "dateCreated", required = false) dateCreated: kotlin.Long?,
        @Parameter(description = "return items that have been updated since this date (time-stamp in milliseconds)") @Valid @RequestParam(value = "updatedSince", required = false) updatedSince: kotlin.Long?,
        @Parameter(description = "return items that have been updated before this date (time-stamp in milliseconds)") @Valid @RequestParam(value = "updatedBefore", required = false) updatedBefore: kotlin.Long?,
        @Parameter(description = "return items that have been created since this date (time-stamp in milliseconds)") @Valid @RequestParam(value = "createdSince", required = false) createdSince: kotlin.Long?,
        @Parameter(description = "return items that have been created before this date (time-stamp in milliseconds)") @Valid @RequestParam(value = "createdBefore", required = false) createdBefore: kotlin.Long?,
        @Parameter(description = "return items that have been started since this date (time-stamp in milliseconds)") @Valid @RequestParam(value = "startedSince", required = false) startedSince: kotlin.Long?,
        @Parameter(description = "return items that have been started before this date (time-stamp in milliseconds)") @Valid @RequestParam(value = "startedBefore", required = false) startedBefore: kotlin.Long?,
        @Parameter(description = "return items that have been ended since this date (time-stamp in milliseconds)") @Valid @RequestParam(value = "endedSince", required = false) endedSince: kotlin.Long?,
        @Parameter(description = "return items that have been ended before this date (time-stamp in milliseconds)") @Valid @RequestParam(value = "endedBefore", required = false) endedBefore: kotlin.Long?,
        @Parameter(description = "the latitude of where the search is centered on (used when sortField=ALBUM_DISTANCE)") @Valid @RequestParam(value = "latitude", required = false) latitude: kotlin.Double?,
        @Parameter(description = "the longitude of where the search is centered on (used when sortField=ALBUM_DISTANCE)") @Valid @RequestParam(value = "longitude", required = false) longitude: kotlin.Double?,
        @Parameter(description = "the application key to filter results by application. This is required for consumer searches. Leaving this empty will return albums for the applications that the logged in user owns or has access to.") @Valid @RequestParam(value = "appKey", required = false) appKey: kotlin.String?,
        @Parameter(description = "return results with categories matching this list") @Valid @RequestParam(value = "categoryIds", required = false) categoryIds: kotlin.String?,
        @Parameter(description = "return results with filters matching this list") @Valid @RequestParam(value = "categoryFilterIds", required = false) categoryFilterIds: kotlin.String?,
        @Parameter(description = "return results with audiences matching this list") @Valid @RequestParam(value = "audienceIds", required = false) audienceIds: kotlin.String?,
        @Parameter(description = "exclude audiences with ids matching this list") @Valid @RequestParam(value = "excludeAudienceIds", required = false) excludeAudienceIds: kotlin.String?,
        @Parameter(description = "returns the user's completable object for the album if it exists") @Valid @RequestParam(value = "includeCompletable", required = false) includeCompletable: kotlin.Boolean?,
        @Parameter(description = "returns the user's rating for the album if it exists") @Valid @RequestParam(value = "includeRating", required = false) includeRating: kotlin.Boolean?,
        @Parameter(description = "The search index mode to use (RDS, LUCENE, or CLOUDINDEX). If not provided will use server default.") @Valid @RequestParam(value = "searchMode", required = false) searchMode: kotlin.String?,
        @Parameter(description = "groups similar albums together that have the same albumTypeId, within a time window defined in stackWindowSize") @Valid @RequestParam(value = "stackSearch", required = false) stackSearch: kotlin.Boolean?,
        @Parameter(description = "size of each window for each stack") @Valid @RequestParam(value = "stackWindowSize", required = false) stackWindowSize: kotlin.Int?,
        @Parameter(description = "The minimum number of stacks returned in a response. For example,  first call, minStackPerPage = 20, the API will return at least 20 results") @Valid @RequestParam(value = "minStackPerPage", required = false) minStackPerPage: kotlin.Int?,
        @Parameter(description = "this is used to tell the system where it left off on the previous previous page, since we can't use start/limit for stackSearch") @Valid @RequestParam(value = "stackPaginationIdentifier", required = false) stackPaginationIdentifier: kotlin.String?,
        @Parameter(description = "set this to true when making the call to view the albums in the stack") @Valid @RequestParam(value = "stackDetails", required = false) stackDetails: kotlin.Boolean?,
        @Parameter(description = "Return any results that have a minimum of the specified flag count (even ones that have met the flag threshold)") @Valid @RequestParam(value = "flagCountMinimum", required = false) flagCountMinimum: kotlin.Long?,
        @Parameter(description = "return items that have flagCount >= flagThreshold (controls removal of flagged content)", schema = Schema(defaultValue = "true")) @Valid @RequestParam(value = "removeFlaggedContent", required = false, defaultValue = "true") removeFlaggedContent: kotlin.Boolean,
        @Parameter(description = "setting to true will return only verified albums only, setting to false will return non-verified albums only (leave empty to return both)") @Valid @RequestParam(value = "verifiedFilter", required = false) verifiedFilter: kotlin.Boolean?,
        @Parameter(description = "filter results by the linkedObjectType") @Valid @RequestParam(value = "linkedObjectType", required = false) linkedObjectType: kotlin.String?,
        @Parameter(description = "filter results by the linkedObjectId") @Valid @RequestParam(value = "linkedObjectId", required = false) linkedObjectId: kotlin.Long?,
        @Parameter(description = "determines whether to use the order assigned via the /album/order/_* api (which is tied to an audience)") @Valid @RequestParam(value = "orderAudienceId", required = false) orderAudienceId: kotlin.Long?,
        @Parameter(description = "if true, ignore the application's default app filter when searching") @Valid @RequestParam(value = "ignoreDefaultAppFilter", required = false) ignoreDefaultAppFilter: kotlin.Boolean?,
        @Parameter(description = "Advanced search expression to be used by the server") @Valid @RequestParam(value = "searchExpression", required = false) searchExpression: kotlin.String?,
        @Parameter(description = "If true and results are empty, attempt to generate albums via templates") @Valid @RequestParam(value = "generateAlbums", required = false) generateAlbums: kotlin.Boolean?
    ): ResponseEntity<List<AlbumFullResponse>> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Search AppConfigs",
        operationId = "searchApplicationConfig",
        description = """Gets all versions of application configurations in a particular app by the given appKey.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(array = ArraySchema(schema = Schema(implementation = ApplicationConfigResponse::class)))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/appconfig/search"
        value = [PATH_SEARCH_APPLICATION_CONFIG],
        produces = ["*/*"]
    )
    fun searchApplicationConfig(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The account ID of the user", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @Parameter(description = "The application key to filter results by application Leaving this empty will return all application configurations for all applications (executive user only)") @Valid @RequestParam(value = "appKey", required = false) appKey: kotlin.String?,
        @Parameter(description = "Only returns the configs that matches the given retailer") @Valid @RequestParam(value = "retailerId", required = false) retailerId: kotlin.Long?,
        @Parameter(description = "Only returns the configs that matches the given retailer location") @Valid @RequestParam(value = "retailerLocationId", required = false) retailerLocationId: kotlin.Long?,
        @Parameter(description = "Only returns only returns the configs that matches the given device udid") @Valid @RequestParam(value = "udid", required = false) udid: kotlin.String?,
        @Parameter(description = "Config Version") @Valid @RequestParam(value = "configVersion", required = false) configVersion: kotlin.String?,
        @Parameter(description = "Orders the results by: CREATED, UPDATED, ACTIVE, APPLICATION_ID,  APPLICATION_KEY, APPLICATION_NAME, RETAILER_NAME, RETAILER_ID, RETAILER_LOCATION_NAME,  RETAILER_LOCATION_ID, OFFER_TITLE, OFFER_ID, OFFER_LOCATION_ID, CONFIG_VERSION_MINOR,  CONFIG_VERSION_MAJOR, CONFIG_VERSION_INDEX ", schema = Schema(defaultValue = "CONFIG_VERSION_INDEX")) @Valid @RequestParam(value = "sortField", required = false, defaultValue = "CONFIG_VERSION_INDEX") sortField: kotlin.String,
        @Parameter(description = "Determines whether the results are in descending or ascending order", schema = Schema(defaultValue = "true")) @Valid @RequestParam(value = "descending", required = false, defaultValue = "true") descending: kotlin.Boolean,
        @Parameter(description = "The start index for pagination", schema = Schema(defaultValue = "0")) @Valid @RequestParam(value = "start", required = false, defaultValue = "0") start: kotlin.Int,
        @Parameter(description = "The limit for pagination (There is a hard limit of 100)", schema = Schema(defaultValue = "20")) @Valid @RequestParam(value = "limit", required = false, defaultValue = "20") limit: kotlin.Int
    ): ResponseEntity<List<ApplicationConfigResponse>> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Search for Ad Placements",
        operationId = "searchApplicationPlacement",
        description = """Searches placements for an application.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(array = ArraySchema(schema = Schema(implementation = PlacementResponse::class)))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/application/placement/search"
        value = [PATH_SEARCH_APPLICATION_PLACEMENT],
        produces = ["*/*"]
    )
    fun searchApplicationPlacement(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The key of the application", required = true) @Valid @RequestParam(value = "appKey", required = true) appKey: kotlin.String,
        @Parameter(description = "The unique id of the device making the request (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "The account id of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "The start of the pagination", schema = Schema(defaultValue = "0")) @Valid @RequestParam(value = "start", required = false, defaultValue = "0") start: kotlin.Int,
        @Parameter(description = "The limit of the pagination", schema = Schema(defaultValue = "100")) @Valid @RequestParam(value = "limit", required = false, defaultValue = "100") limit: kotlin.Int
    ): ResponseEntity<List<PlacementResponse>> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Search for Application Settings",
        operationId = "searchApplicationSettings",
        description = """Returns a list of applications that the user has logged into before, and returns specific settings for that application and user""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = ApplicationSettingsResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/application/settings/search"
        value = [PATH_SEARCH_APPLICATION_SETTINGS],
        produces = ["*/*"]
    )
    fun searchApplicationSettings(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "The device id (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "The account id of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "The account id used to view another person's account") @Valid @RequestParam(value = "connectionAccountId", required = false) connectionAccountId: kotlin.Long?,
        @Parameter(description = "The string to search applications on") @Valid @RequestParam(value = "keyword", required = false) keyword: kotlin.String?,
        @Parameter(description = "The column to sort the search on. Possible values include: CREATED, UPDATED, APPLICATION_TITLE", schema = Schema(defaultValue = "APPLICATION_TITLE")) @Valid @RequestParam(value = "sortField", required = false, defaultValue = "APPLICATION_TITLE") sortField: kotlin.String,
        @Parameter(description = "The order to return the search results", schema = Schema(defaultValue = "false")) @Valid @RequestParam(value = "descending", required = false, defaultValue = "false") descending: kotlin.Boolean,
        @Parameter(description = "The start index for pagination", schema = Schema(defaultValue = "0")) @Valid @RequestParam(value = "start", required = false, defaultValue = "0") start: kotlin.Int,
        @Parameter(description = "The limit per result set for pagination", schema = Schema(defaultValue = "20")) @Valid @RequestParam(value = "limit", required = false, defaultValue = "20") limit: kotlin.Int
    ): ResponseEntity<ApplicationSettingsResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Search Applications",
        operationId = "searchApplications",
        description = """Search for applications matching the criteria that the logged in user has access to""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(array = ArraySchema(schema = Schema(implementation = ApplicationResponse::class)))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/application/search"
        value = [PATH_SEARCH_APPLICATIONS],
        produces = ["*/*"]
    )
    fun searchApplications(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "The unique id of the device making the request (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "The account id of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "The location of the device") @Valid @RequestParam(value = "latitude", required = false) latitude: kotlin.Double?,
        @Parameter(description = "The location of the device") @Valid @RequestParam(value = "longitude", required = false) longitude: kotlin.Double?,
        @Parameter(description = "Q") @Valid @RequestParam(value = "q", required = false) q: kotlin.String?,
        @Parameter(description = "The keyword used to search") @Valid @RequestParam(value = "keyword", required = false) keyword: kotlin.String?,
        @Parameter(description = "The columns to applied the keyword search to", schema = Schema(defaultValue = "NAME,ABOUT,BILLABLE_ENTITY_NAME")) @Valid @RequestParam(value = "qSearchFields", required = false, defaultValue = "NAME,ABOUT,BILLABLE_ENTITY_NAME") qSearchFields: kotlin.String,
        @Parameter(description = "The column to sort the search on", schema = Schema(allowableValues = ["CREATED", "UPDATED", "DELETED", "SEARCH_TAGS", "ACTIVE", "HAS_ADVERTISEMENTS", "PUBLIC_NOTIFICATIONS", "PLACEMENTS", "BILLABLE_ENTITY_ID", "BILLABLE_ENTITY_NAME", "RESPONSIBLE_DISPLAY", "TITLE", "NAME", "ABOUT", "DESCRIPTION", "APPLICATION_ID", "APP_TYPE", "GAME_TYPE", "BUNDLE_ID", "SCORING_TYPE", "LANDING_PAGE_URL", "EULA_VERSION", "BUILD_VERSION", "API_VERSION"], defaultValue = "APPLICATION_ID")) @Valid @RequestParam(value = "sortField", required = false, defaultValue = "APPLICATION_ID") sortField: kotlin.String,
        @Parameter(description = "The order to return the search results", schema = Schema(defaultValue = "false")) @Valid @RequestParam(value = "descending", required = false, defaultValue = "false") descending: kotlin.Boolean,
        @Parameter(description = "the start of the index") @Valid @RequestParam(value = "_i", required = false) i: kotlin.Int?,
        @Parameter(description = "The start of the pagination", schema = Schema(defaultValue = "0")) @Valid @RequestParam(value = "start", required = false, defaultValue = "0") start: kotlin.Int,
        @Parameter(description = "the limit of the index") @Valid @RequestParam(value = "_l", required = false) l: kotlin.Int?,
        @Parameter(description = "The limit of the pagination", schema = Schema(defaultValue = "100")) @Valid @RequestParam(value = "limit", required = false, defaultValue = "100") limit: kotlin.Int,
        @Parameter(description = "Filter results on whether the application supports ads or not. Ignore this parameter to return all results.") @Valid @RequestParam(value = "hasAds", required = false) hasAds: kotlin.Boolean?,
        @Parameter(description = "Filter results on whether the application is available for public trigger notifications") @Valid @RequestParam(value = "publicNotifications", required = false) publicNotifications: kotlin.Boolean?,
        @Parameter(description = "Return only active results", schema = Schema(defaultValue = "false")) @Valid @RequestParam(value = "activeOnly", required = false, defaultValue = "false") activeOnly: kotlin.Boolean
    ): ResponseEntity<List<ApplicationResponse>> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Search Assets",
        operationId = "searchAssets",
        description = """Searches for assets""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(array = ArraySchema(schema = Schema(implementation = AssetResponse::class)))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/asset/search"
        value = [PATH_SEARCH_ASSETS],
        produces = ["*/*"]
    )
    fun searchAssets(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "a unique ID given by the device (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "the account ID of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "comma separated list of album ids to search on") @Valid @RequestParam(value = "albumIds", required = false) albumIds: kotlin.String?,
        @Parameter(description = "comma separated list of asset ids to search on") @Valid @RequestParam(value = "assetIds", required = false) assetIds: kotlin.String?,
        @Parameter(description = "the application key to filter results by application.") @Valid @RequestParam(value = "appKey", required = false) appKey: kotlin.String?,
        @Parameter(description = "filter results by media type. Possible values include: APPLICATION, IMAGE, AUDIO, VIDEO, MULTIPART, TEXT") @Valid @RequestParam(value = "mediaType", required = false) mediaType: kotlin.String?,
        @Parameter(description = "filter results by mime type") @Valid @RequestParam(value = "mimeType", required = false) mimeType: kotlin.String?,
        @Parameter(description = "keyword search string") @Valid @RequestParam(value = "keyword", required = false) keyword: kotlin.String?,
        @Parameter(description = "filter results by version code") @Valid @RequestParam(value = "versionCode", required = false) versionCode: kotlin.Int?,
        @Parameter(description = "filter results by version name") @Valid @RequestParam(value = "versionName", required = false) versionName: kotlin.String?,
        @Parameter(description = "return items that have been updated since this date (time-stamp in milliseconds)") @Valid @RequestParam(value = "updatedSince", required = false) updatedSince: kotlin.Long?,
        @Parameter(description = "return items that have been updated before this date (time-stamp in milliseconds)") @Valid @RequestParam(value = "updatedBefore", required = false) updatedBefore: kotlin.Long?,
        @Parameter(description = "the field to sort by. See AssetApiMap") @Valid @RequestParam(value = "sortField", required = false) sortField: kotlin.String?,
        @Parameter(description = "determines whether the sorted list is in descending or ascending order") @Valid @RequestParam(value = "descending", required = false) descending: kotlin.Boolean?,
        @Parameter(description = "determines whether to search on the media library album") @Valid @RequestParam(value = "searchMediaLibrary", required = false) searchMediaLibrary: kotlin.Boolean?,
        @Parameter(description = "filter results by billable entity") @Valid @RequestParam(value = "filterByBillable", required = false) filterByBillable: kotlin.Boolean?,
        @Parameter(description = "if only searching for active assets") @Valid @RequestParam(value = "activeOnly", required = false) activeOnly: kotlin.Boolean?,
        @Parameter(description = "determines whether to include the application response as part of the asset response") @Valid @RequestParam(value = "returnApp", required = false) returnApp: kotlin.Boolean?,
        @Parameter(description = "the start index for pagination") @Valid @RequestParam(value = "start", required = false) start: kotlin.Int?,
        @Parameter(description = "the limit for pagination (there is a hard limit of 200)") @Valid @RequestParam(value = "limit", required = false) limit: kotlin.Int?,
        @Parameter(description = "search mode for index (SearchIndexMode)") @Valid @RequestParam(value = "searchMode", required = false) searchMode: kotlin.String?,
        @Parameter(description = "filter by asset type") @Valid @RequestParam(value = "assetType", required = false) assetType: kotlin.String?,
        @Parameter(description = "filter by approval status") @Valid @RequestParam(value = "approvalStatus", required = false) approvalStatus: kotlin.String?,
        @Parameter(description = "filter results by an assigned account id") @Valid @RequestParam(value = "assignedAccountId", required = false) assignedAccountId: kotlin.Long?
    ): ResponseEntity<List<AssetResponse>> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Search Availability",
        operationId = "searchAvailability",
        description = """""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(array = ArraySchema(schema = Schema(implementation = AvailabilityResponse::class)))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/reservable/availability/search"
        value = [PATH_SEARCH_AVAILABILITY],
        produces = ["*/*"]
    )
    fun searchAvailability(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the id of the reservation", required = true) @Valid @RequestParam(value = "reservableId", required = true) reservableId: kotlin.Long,
        @NotNull @Parameter(description = "the reservable type", required = true, schema = Schema(allowableValues = ["LOCATABLE", "RESERVABLE", "PERMISSIONABLE", "NOTABLE", "ASSETABLE", "LIKABLE", "FLAGABLE", "FAVORITABLE", "RATABLE", "ALBUM", "COLLECTION", "APPLICATION", "APPLICATION_SETTING", "APPLICATION_CERT", "APPLICATION_PLACEMENT", "ACCOUNT", "ACCOUNT_SETTING", "GAME_LEVEL", "PACK", "MISSION", "TOURNAMENT", "ASSET", "ALBUM_CONTEST", "THEME_DESCRIPTOR", "OFFER", "OFFER_LOCATION", "EVENT", "RETAILER", "RETAILER_LOCATION", "NOTE", "CREATIVE", "FAVORITE", "LIKE", "RATING", "ANALYTIC", "THIRD_PARTY_CREDENTIAL", "THIRD_PARTY_NETWORK", "REGION"])) @Valid @RequestParam(value = "reservableType", required = true) reservableType: kotlin.String,
        @Parameter(description = "the device ID that the reservation is on") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "the id of the logged in user") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "the start date of the reservation") @Valid @RequestParam(value = "startDate", required = false) startDate: kotlin.Long?,
        @Parameter(description = "the end date of the reservation") @Valid @RequestParam(value = "endDate", required = false) endDate: kotlin.Long?,
        @Parameter(description = "the start of the index and/or pagination", schema = Schema(defaultValue = "0")) @Valid @RequestParam(value = "start", required = false, defaultValue = "0") start: kotlin.Int,
        @Parameter(description = "the limit of the index and/or pagination", schema = Schema(defaultValue = "100")) @Valid @RequestParam(value = "limit", required = false, defaultValue = "100") limit: kotlin.Int
    ): ResponseEntity<List<AvailabilityResponse>> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Search Offline Reports",
        operationId = "searchBatch",
        description = """Retrieves batches for a user..""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(array = ArraySchema(schema = Schema(implementation = ReportBatchResponse::class)))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/report/batch/search"
        value = [PATH_SEARCH_BATCH],
        produces = ["*/*"]
    )
    fun searchBatch(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the id of the account logged in", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "the start of the index and/or pagination", required = true) @Valid @RequestParam(value = "start", required = true) start: kotlin.Int,
        @NotNull @Parameter(description = "the limit of the index and/or pagination", required = true) @Valid @RequestParam(value = "limit", required = true) limit: kotlin.Int,
        @Parameter(description = "the names of the report batch to search on") @Valid @RequestParam(value = "names", required = false) names: kotlin.String?,
        @Parameter(description = "the application key") @Valid @RequestParam(value = "appKey", required = false) appKey: kotlin.String?,
        @Parameter(description = "the report batch status", schema = Schema(allowableValues = ["NEW", "ERROR", "COMPLETE", "PARSE_ERROR", "PROCESSING", "DUPLICATE", "SAVEONLY"])) @Valid @RequestParam(value = "status", required = false) status: kotlin.String?,
        @Parameter(description = "the global app to search on") @Valid @RequestParam(value = "globalAppSearch", required = false) globalAppSearch: kotlin.Boolean?,
        @Parameter(description = "the start date of the report batch to search on") @Valid @RequestParam(value = "startDate", required = false) startDate: kotlin.Long?,
        @Parameter(description = "the end date of the report batch to search on") @Valid @RequestParam(value = "endDate", required = false) endDate: kotlin.Long?
    ): ResponseEntity<List<ReportBatchResponse>> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Search on the user's blocked notification settings",
        operationId = "searchBlockedNotifications",
        description = """Search on the user's blocked notification settings""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = BlockedNotificationResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/notification/blocked/search"
        value = [PATH_SEARCH_BLOCKED_NOTIFICATIONS],
        produces = ["*/*"]
    )
    fun searchBlockedNotifications(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The application key", required = true) @Valid @RequestParam(value = "appKey", required = true) appKey: kotlin.String,
        @Parameter(description = "the account id of the user") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "search tags to filter results") @Valid @RequestParam(value = "searchTags", required = false) searchTags: kotlin.String?,
        @Parameter(description = "events to filter by (comma separated)") @Valid @RequestParam(value = "events", required = false) events: kotlin.String?,
        @Parameter(description = "conduits to filter by (comma separated)") @Valid @RequestParam(value = "conduits", required = false) conduits: kotlin.String?,
        @Parameter(description = "custom types to filter by (comma separated)") @Valid @RequestParam(value = "customTypes", required = false) customTypes: kotlin.String?,
        @Parameter(description = "content types to filter by (comma separated)") @Valid @RequestParam(value = "contentTypes", required = false) contentTypes: kotlin.String?,
        @Parameter(description = "content ids to filter by (comma separated)") @Valid @RequestParam(value = "contentIds", required = false) contentIds: kotlin.String?,
        @Parameter(description = "sort field for results") @Valid @RequestParam(value = "sortField", required = false) sortField: kotlin.String?,
        @Parameter(description = "whether to sort descending") @Valid @RequestParam(value = "descending", required = false) descending: kotlin.Boolean?,
        @Parameter(description = "start of the pagination") @Valid @RequestParam(value = "start", required = false) start: kotlin.Int?,
        @Parameter(description = "limit of the pagination") @Valid @RequestParam(value = "limit", required = false) limit: kotlin.Int?
    ): ResponseEntity<BlockedNotificationResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Search for Vatom Businesses",
        operationId = "searchBusinesses",
        description = """Searches for Vatom businesses.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation") ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/vatom/b/search"
        value = [PATH_SEARCH_BUSINESSES]
    )
    fun searchBusinesses(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "Sirqul Account Id", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @Parameter(description = "Vatom Parameters") @Valid @RequestParam(value = "vatomParameters", required = false) vatomParameters: kotlin.String?,
        @Parameter(description = "Return raw response") @Valid @RequestParam(value = "returnRawResponse", required = false) returnRawResponse: kotlin.Boolean?
    ): ResponseEntity<Unit> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Search Campaign Groups",
        operationId = "searchCampaignGroups",
        description = """Search campaign groups.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation") ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/vatom/b/campaign-groups/search"
        value = [PATH_SEARCH_CAMPAIGN_GROUPS]
    )
    fun searchCampaignGroups(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "Sirqul Account Id", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "Sirqul Application Key", required = true) @Valid @RequestParam(value = "appKey", required = true) appKey: kotlin.String,
        @Parameter(description = "Return raw response") @Valid @RequestParam(value = "returnRawResponse", required = false) returnRawResponse: kotlin.Boolean?
    ): ResponseEntity<Unit> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Search Cargo Type",
        operationId = "searchCargoTypes",
        description = """Search for types of cargo""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(array = ArraySchema(schema = Schema(implementation = CargoType::class)))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/cargo/type"
        value = [PATH_SEARCH_CARGO_TYPES],
        produces = ["*/*"]
    )
    fun searchCargoTypes(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the sort field to use for the cargo type", required = true) @Valid @RequestParam(value = "sortField", required = true) sortField: kotlin.String,
        @NotNull @Parameter(description = "if the cargo type should be should be in descending order", required = true) @Valid @RequestParam(value = "descending", required = true) descending: kotlin.Boolean,
        @NotNull @Parameter(description = "the start of the search", required = true) @Valid @RequestParam(value = "start", required = true) start: kotlin.Int,
        @NotNull @Parameter(description = "the limit of the search", required = true) @Valid @RequestParam(value = "limit", required = true) limit: kotlin.Int,
        @NotNull @Parameter(description = "if search should be on active only", required = true) @Valid @RequestParam(value = "activeOnly", required = true) activeOnly: kotlin.Boolean,
        @Parameter(description = "the id of the retailer location") @Valid @RequestParam(value = "retailerId", required = false) retailerId: kotlin.Long?,
        @Parameter(description = "the ID of the hub") @Valid @RequestParam(value = "hubId", required = false) hubId: kotlin.Long?
    ): ResponseEntity<List<CargoType>> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Search Carriers",
        operationId = "searchCarriers",
        description = """Search on supported mobile telephone carriers that can be used to send SMS notifications via email.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(array = ArraySchema(schema = Schema(implementation = CellCarrierResponse::class)))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/carrier/search"
        value = [PATH_SEARCH_CARRIERS],
        produces = ["*/*"]
    )
    fun searchCarriers(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "The keyword to search on") @Valid @RequestParam(value = "keyword", required = false) keyword: kotlin.String?,
        @Parameter(description = "Determines whether the sorted list is in descending or ascending order", schema = Schema(defaultValue = "false")) @Valid @RequestParam(value = "descending", required = false, defaultValue = "false") descending: kotlin.Boolean,
        @Parameter(description = "The start index for pagination", schema = Schema(defaultValue = "0")) @Valid @RequestParam(value = "start", required = false, defaultValue = "0") start: kotlin.Int,
        @Parameter(description = "The limit for pagination", schema = Schema(defaultValue = "20")) @Valid @RequestParam(value = "limit", required = false, defaultValue = "20") limit: kotlin.Int,
        @Parameter(description = "Determines whether to return inactive results", schema = Schema(defaultValue = "true")) @Valid @RequestParam(value = "activeOnly", required = false, defaultValue = "true") activeOnly: kotlin.Boolean
    ): ResponseEntity<List<CellCarrierResponse>> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Search Categories",
        operationId = "searchCategories",
        description = """Search for categories.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(array = ArraySchema(schema = Schema(implementation = CategoryResponse::class)))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/category/search"
        value = [PATH_SEARCH_CATEGORIES],
        produces = ["*/*"]
    )
    fun searchCategories(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "The account id of the user") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "The string to search on") @Valid @RequestParam(value = "keyword", required = false) keyword: kotlin.String?,
        @Parameter(description = "the appKey of the application to retrieve categories for, if not specified then search on the global application.") @Valid @RequestParam(value = "appKey", required = false) appKey: kotlin.String?,
        @Parameter(description = "@Deprecated, use parentCategoryIds instead") @Valid @RequestParam(value = "categoryId", required = false) categoryId: kotlin.String?,
        @Parameter(description = "Restrict the search by specific categories") @Valid @RequestParam(value = "categoryIds", required = false) categoryIds: kotlin.String?,
        @Parameter(description = "Restrict the search by specific parent categories so that only its sub children are searched.") @Valid @RequestParam(value = "parentCategoryIds", required = false) parentCategoryIds: kotlin.String?,
        @Parameter(description = "Restrict the search to only those categories with no parent category assigned.") @Valid @RequestParam(value = "rootOnly", required = false) rootOnly: kotlin.Boolean?,
        @Parameter(description = "The column to sort the search on. Possible values include: ID, CREATED, UPDATED, ACTIVE, NAME, DISPLAY", schema = Schema(allowableValues = ["ID", "CREATED", "UPDATED", "DELETED", "SEARCH_TAGS", "ACTIVE", "NAME", "DISPLAY"], defaultValue = "DISPLAY")) @Valid @RequestParam(value = "sortField", required = false, defaultValue = "DISPLAY") sortField: kotlin.String,
        @Parameter(description = "The group of categories to return: ALL, GLOBAL or MINE. ALL returns both global and application specific matches, GLOBAL only returns global matches, and MINE only returns the application specific matches. If not provided search on the application provided.", schema = Schema(allowableValues = ["ALL", "GLOBAL", "MINE"])) @Valid @RequestParam(value = "responseGroup", required = false) responseGroup: kotlin.String?,
        @Parameter(description = "The order to return the search results", schema = Schema(defaultValue = "false")) @Valid @RequestParam(value = "descending", required = false, defaultValue = "false") descending: kotlin.Boolean,
        @Parameter(description = "The record to begin the return set on", schema = Schema(defaultValue = "0")) @Valid @RequestParam(value = "start", required = false, defaultValue = "0") start: kotlin.Int,
        @Parameter(description = "The number of records to return", schema = Schema(defaultValue = "20")) @Valid @RequestParam(value = "limit", required = false, defaultValue = "20") limit: kotlin.Int,
        @Parameter(description = "Determines whether to return only active categories", schema = Schema(defaultValue = "true")) @Valid @RequestParam(value = "activeOnly", required = false, defaultValue = "true") activeOnly: kotlin.Boolean,
        @Parameter(description = "Determines whether to return extra info about the category's \"Participant\" reference", schema = Schema(defaultValue = "true")) @Valid @RequestParam(value = "returnExternal", required = false, defaultValue = "true") returnExternal: kotlin.Boolean,
        @Parameter(description = "If true search categories using the exact keyword, if false then do a partial match (like) search. Default is false.", schema = Schema(defaultValue = "false")) @Valid @RequestParam(value = "exactMatch", required = false, defaultValue = "false") exactMatch: kotlin.Boolean,
        @Parameter(description = "Filters results by the Category's type") @Valid @RequestParam(value = "type", required = false) type: kotlin.String?,
        @Parameter(description = "Filters results by externalType") @Valid @RequestParam(value = "externalType", required = false) externalType: kotlin.String?,
        @Parameter(description = "Determines whether the \"externalType\" param is excluded from the search results") @Valid @RequestParam(value = "excludeExternalType", required = false) excludeExternalType: kotlin.Boolean?,
        @Parameter(description = "Filters results to only return Categories that have been referenced by a minimum number of Offers") @Valid @RequestParam(value = "minOfferCount", required = false) minOfferCount: kotlin.Int?,
        @Parameter(description = "When searching by a specific parent category (to return sub children), this determines the number of child layers to search in. The minimum is 1, the maximum is 4.", schema = Schema(defaultValue = "4")) @Valid @RequestParam(value = "searchDepth", required = false, defaultValue = "4") searchDepth: kotlin.Int,
        @Parameter(description = "The search index mode to use (e.g. OPENSEARCH or RDS)") @Valid @RequestParam(value = "searchMode", required = false) searchMode: kotlin.String?
    ): ResponseEntity<List<CategoryResponse>> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Search Possible Connections",
        operationId = "searchConnections",
        description = """Search for accounts that the user may not have a connection with.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = ConnectionListResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/connection/search"
        value = [PATH_SEARCH_CONNECTIONS],
        produces = ["*/*"]
    )
    fun searchConnections(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "return all json attributes if true. defualt is true.", required = true) @Valid @RequestParam(value = "returnNulls", required = true) returnNulls: kotlin.Boolean,
        @NotNull @Parameter(description = "start index of the pagination", required = true) @Valid @RequestParam(value = "start", required = true) start: kotlin.Int,
        @NotNull @Parameter(description = "limit of the pagination", required = true) @Valid @RequestParam(value = "limit", required = true) limit: kotlin.Int,
        @Parameter(description = "the device id (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "the account id (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "This parameter is deprecated.") @Valid @RequestParam(value = "q", required = false) q: kotlin.String?,
        @Parameter(description = "keyword to search on, optional and this parameter is ignored if empt") @Valid @RequestParam(value = "keyword", required = false) keyword: kotlin.String?,
        @Parameter(description = "the current latitude of the user") @Valid @RequestParam(value = "latitude", required = false) latitude: kotlin.Double?,
        @Parameter(description = "the current longitude of the user") @Valid @RequestParam(value = "longitude", required = false) longitude: kotlin.Double?,
        @Parameter(description = "This parameter is deprecated.") @Valid @RequestParam(value = "gameType", required = false) gameType: kotlin.String?,
        @Parameter(description = "the public application key, if provided only looks for users of that application") @Valid @RequestParam(value = "appKey", required = false) appKey: kotlin.String?,
        @Parameter(description = "This parameter is deprecated.") @Valid @RequestParam(value = "_i", required = false) i: kotlin.Int?,
        @Parameter(description = "This parameter is deprecated.") @Valid @RequestParam(value = "_l", required = false) l: kotlin.Int?,
        @Parameter(description = "the field to sort on") @Valid @RequestParam(value = "sortField", required = false) sortField: kotlin.String?,
        @Parameter(description = "whether the search has location or not") @Valid @RequestParam(value = "hasLocation", required = false) hasLocation: kotlin.Boolean?
    ): ResponseEntity<ConnectionListResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Search Credentials",
        operationId = "searchCredentials",
        description = """Search on a user's linked third party networks.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(array = ArraySchema(schema = Schema(implementation = ThirdPartyCredentialResponse::class)))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/thirdparty/credential/search"
        value = [PATH_SEARCH_CREDENTIALS],
        produces = ["*/*"]
    )
    fun searchCredentials(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The account id of the user", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @Parameter(description = "The keyword used to search on the third party name and network string") @Valid @RequestParam(value = "keyword", required = false) keyword: kotlin.String?,
        @Parameter(description = "The network UID to filter results with") @Valid @RequestParam(value = "networkUID", required = false) networkUID: kotlin.String?,
        @Parameter(description = "The order to return the search results") @Valid @RequestParam(value = "descending", required = false) descending: kotlin.Boolean?,
        @Parameter(description = "The start of the pagination", schema = Schema(defaultValue = "0")) @Valid @RequestParam(value = "start", required = false, defaultValue = "0") start: kotlin.Int,
        @Parameter(description = "The limit of the pagination", schema = Schema(defaultValue = "20")) @Valid @RequestParam(value = "limit", required = false, defaultValue = "20") limit: kotlin.Int
    ): ResponseEntity<List<ThirdPartyCredentialResponse>> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Search Data",
        operationId = "searchData",
        description = """Search for records given the specified criteria.  The criteria is a defined set of json values used to build a query""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = ObjectStoreResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/object/data/{objectName}"
        value = [PATH_SEARCH_DATA],
        produces = ["*/*"]
    )
    fun searchData(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "The name of the object to search upon", required = true) @PathVariable("objectName") objectName: kotlin.String,
        @NotNull @Parameter(description = "If true just return the record count of the search. False (default) will return the actual records", required = true) @Valid @RequestParam(value = "count", required = true) count: kotlin.Boolean,
        @NotNull @Parameter(description = "The start of the pagination", required = true) @Valid @RequestParam(value = "start", required = true) start: kotlin.Long,
        @NotNull @Parameter(description = "The limit of the pagination", required = true) @Valid @RequestParam(value = "limit", required = true) limit: kotlin.Long,
        @Parameter(description = "The account id of the logged in user") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "The search criteria") @Valid @RequestParam(value = "criteria", required = false) criteria: kotlin.String?,
        @Parameter(description = "The order of results; comma seperated list of field names. Illegal field names will be ignored. Direction by defualt is ascending. Prepend a minus to the field name to make that field descending.") @Valid @RequestParam(value = "order", required = false) order: kotlin.String?,
        @Parameter(description = "") @Valid @RequestParam(value = "include", required = false) include: kotlin.String?
    ): ResponseEntity<ObjectStoreResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Search Disbursements",
        operationId = "searchDisbursements",
        description = """Search Disbursements""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(array = ArraySchema(schema = Schema(implementation = DisbursementResponse::class)))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/disbursement/search"
        value = [PATH_SEARCH_DISBURSEMENTS],
        produces = ["*/*"]
    )
    fun searchDisbursements(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the id of the logged in user", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @Parameter(description = "filter results by the id of the account receiving the disbursement") @Valid @RequestParam(value = "receiverAccountId", required = false) receiverAccountId: kotlin.Long?,
        @Parameter(description = "comma separated list of status values to search for, possilbe values include: NEW, APPROVED, VALIDATING, ERROR, AUTHORIZED, CAPTURED, SETTLED") @Valid @RequestParam(value = "statuses", required = false) statuses: kotlin.String?,
        @Parameter(description = "comma separated list of payment providers to search for, possbile values include: AUTHORIZE_NET, AMAZON_FPS, BILL_COM") @Valid @RequestParam(value = "providers", required = false) providers: kotlin.String?,
        @Parameter(description = "the date for searching disbursements before it has been processed") @Valid @RequestParam(value = "beforeDate", required = false) beforeDate: kotlin.Long?,
        @Parameter(description = "the date for searching disbursements before it has been processed") @Valid @RequestParam(value = "afterDate", required = false) afterDate: kotlin.Long?,
        @Parameter(description = "the start index for pagination", schema = Schema(defaultValue = "0")) @Valid @RequestParam(value = "start", required = false, defaultValue = "0") start: kotlin.Int,
        @Parameter(description = "the limit per result set for pagination", schema = Schema(defaultValue = "20")) @Valid @RequestParam(value = "limit", required = false, defaultValue = "20") limit: kotlin.Int,
        @Parameter(description = "search on disbursements that are active only", schema = Schema(defaultValue = "false")) @Valid @RequestParam(value = "activeOnly", required = false, defaultValue = "false") activeOnly: kotlin.Boolean,
        @Parameter(description = "search results by this external ID (that can be used to reference the disbursement)") @Valid @RequestParam(value = "externalId", required = false) externalId: kotlin.String?
    ): ResponseEntity<List<DisbursementResponse>> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Search Employees",
        operationId = "searchEmployees",
        description = """Use the accountId to determine the associated BillableEntity. From there get a list of all accounts associated as managers/employees.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(array = ArraySchema(schema = Schema(implementation = EmployeeResponse::class)))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/employee/search"
        value = [PATH_SEARCH_EMPLOYEES],
        produces = ["*/*"]
    )
    fun searchEmployees(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The account id of the logged in user", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @Parameter(description = "The role to limit the search to: RETAILER or RETAILER_LIMITED. Leave empty to search on both roles.") @Valid @RequestParam(value = "role", required = false) role: kotlin.String?,
        @Parameter(description = "Filters employees by retailer") @Valid @RequestParam(value = "retailerId", required = false) retailerId: kotlin.Long?,
        @Parameter(description = "Filter employees by retailer locations") @Valid @RequestParam(value = "retailerLocationId", required = false) retailerLocationId: kotlin.Long?,
        @Parameter(description = "Deprecated parameter") @Valid @RequestParam(value = "q", required = false) q: kotlin.String?,
        @Parameter(description = "an optional keyword to search on; ignored if empty") @Valid @RequestParam(value = "keyword", required = false) keyword: kotlin.String?,
        @Parameter(description = "The field to sort by. Possible values include: DISPLAY, CREATED, UPDATED, ACTIVE, DELETED, LAST_LOGGED_IN, CONTACT_EMAIL, RETAILER_LOCATION_NAME, RETAILER_NAME", schema = Schema(allowableValues = ["ID", "DISPLAY", "CREATED", "UPDATED", "ACTIVE", "DELETED", "LAST_LOGGED_IN", "CONTACT_EMAIL", "ACCOUNT_TYPE", "RETAILER_LOCATION_NAME", "RETAILER_NAME"])) @Valid @RequestParam(value = "sortField", required = false) sortField: kotlin.String?,
        @Parameter(description = "Determines whether the sorted list is in descending or ascending order", schema = Schema(defaultValue = "false")) @Valid @RequestParam(value = "descending", required = false, defaultValue = "false") descending: kotlin.Boolean,
        @Parameter(description = "Deprecated parameter") @Valid @RequestParam(value = "_i", required = false) i: kotlin.Int?,
        @Parameter(description = "Start the result set at some index", schema = Schema(defaultValue = "0")) @Valid @RequestParam(value = "start", required = false, defaultValue = "0") start: kotlin.Int,
        @Parameter(description = "Deprecated parameter") @Valid @RequestParam(value = "_l", required = false) l: kotlin.Int?,
        @Parameter(description = "Limit the result to some number", schema = Schema(defaultValue = "20")) @Valid @RequestParam(value = "limit", required = false, defaultValue = "20") limit: kotlin.Int,
        @Parameter(description = "Filter results to only return active employees", schema = Schema(defaultValue = "true")) @Valid @RequestParam(value = "activeOnly", required = false, defaultValue = "true") activeOnly: kotlin.Boolean,
        @Parameter(description = "Filter results to only employees that you manage") @Valid @RequestParam(value = "managedOnly", required = false) managedOnly: kotlin.Boolean?,
        @Parameter(description = "Determines whether to return the application settings for the employee for a particular application") @Valid @RequestParam(value = "settingsAppKey", required = false) settingsAppKey: kotlin.String?,
        @Parameter(description = "Comma separated list of category ids to filter results") @Valid @RequestParam(value = "categoryIds", required = false) categoryIds: kotlin.String?,
        @Parameter(description = "Legacy/reporting query parameter used for formatting employee responses") @Valid @RequestParam(value = "query", required = false) query: kotlin.String?
    ): ResponseEntity<List<EmployeeResponse>> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Search Event Attendance",
        operationId = "searchEventTransactions",
        description = """Searches on event type transactions. This can be used to see who is attending an event.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(array = ArraySchema(schema = Schema(implementation = EventAttendanceResponse::class)))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/event/attendance/search"
        value = [PATH_SEARCH_EVENT_TRANSACTIONS],
        produces = ["*/*"]
    )
    fun searchEventTransactions(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "The device id (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "The account id of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "The application key") @Valid @RequestParam(value = "appKey", required = false) appKey: kotlin.String?,
        @Parameter(description = "The keyword to search for") @Valid @RequestParam(value = "keyword", required = false) keyword: kotlin.String?,
        @Parameter(description = "Filter results for this retailer") @Valid @RequestParam(value = "retailerId", required = false) retailerId: kotlin.Long?,
        @Parameter(description = "Filter results for this retailer location") @Valid @RequestParam(value = "retailerLocationId", required = false) retailerLocationId: kotlin.Long?,
        @Parameter(description = "Exclude results from this retailer location") @Valid @RequestParam(value = "excludeRetailerLocationId", required = false) excludeRetailerLocationId: kotlin.Long?,
        @Parameter(description = "Filter results for this event listing") @Valid @RequestParam(value = "listingId", required = false) listingId: kotlin.Long?,
        @Parameter(description = "Filter results for this offer") @Valid @RequestParam(value = "offerId", required = false) offerId: kotlin.Long?,
        @Parameter(description = "Filter results for this offer location") @Valid @RequestParam(value = "offerLocationId", required = false) offerLocationId: kotlin.Long?,
        @Parameter(description = "Filter results by accounts") @Valid @RequestParam(value = "customerAccountIds", required = false) customerAccountIds: kotlin.String?,
        @Parameter(description = "Comma separated list of category ids to determine whether the attendee is affiliated with the category") @Valid @RequestParam(value = "affiliatedCategoryIds", required = false) affiliatedCategoryIds: kotlin.String?,
        @Parameter(description = "Filter on attendance starting on or after this date (milliseconds since epoch)") @Valid @RequestParam(value = "startDate", required = false) startDate: kotlin.Long?,
        @Parameter(description = "Filter on attendance starting on or before this date (milliseconds since epoch)") @Valid @RequestParam(value = "endDate", required = false) endDate: kotlin.Long?,
        @Parameter(description = "Comma separated list of transaction statuses to filter on") @Valid @RequestParam(value = "statuses", required = false) statuses: kotlin.String?,
        @Parameter(description = "Determines what to sort the results by {CREATED, UPDATED, SEARCH_TAGS, ACTIVE, ACTIVATED, EXPIRES, TITLE, SUBTITLE, OFFER_TYPE, SPECIAL_OFFER_TYPE, OFFER_VISIBILITY, CUSTOMER_ID, CUSTOMER_DISPLAY, RETAILER_ID, RETAILER_NAME, RETAILER_LOCATION_ID, RETAILER_LOCATION_NAME, BILLABLE_ENTITY_ID, BILLABLE_ENTITY_NAME, RESPONSIBLE_DISPLAY}", schema = Schema(allowableValues = ["ID", "CREATED", "UPDATED", "DELETED", "SEARCH_TAGS", "ACTIVE", "ACTIVATED", "EXPIRES", "TITLE", "SUBTITLE", "DETAILS", "OFFER_TYPE", "SPECIAL_OFFER_TYPE", "OFFER_VISIBILITY", "REDEEMABLE_START", "REDEEMABLE_END", "CUSTOMER_ID", "CUSTOMER_DISPLAY", "RETAILER_ID", "RETAILER_NAME", "RETAILER_LOCATION_ID", "RETAILER_LOCATION_NAME", "BILLABLE_ENTITY_ID", "BILLABLE_ENTITY_NAME", "RESPONSIBLE_DISPLAY"])) @Valid @RequestParam(value = "sortField", required = false) sortField: kotlin.String?,
        @Parameter(description = "Determines whether the results are in descending order") @Valid @RequestParam(value = "descending", required = false) descending: kotlin.Boolean?,
        @Parameter(description = "The start index for pagination") @Valid @RequestParam(value = "start", required = false) start: kotlin.Int?,
        @Parameter(description = "The limit for pagination") @Valid @RequestParam(value = "limit", required = false) limit: kotlin.Int?
    ): ResponseEntity<List<EventAttendanceResponse>> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Search Events",
        operationId = "searchEvents",
        description = """Searches on events that the account has access to.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(array = ArraySchema(schema = Schema(implementation = OfferShortResponse::class)))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/event/search"
        value = [PATH_SEARCH_EVENTS],
        produces = ["*/*"]
    )
    fun searchEvents(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The logged in user.", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @Parameter(description = "The keyword used to search") @Valid @RequestParam(value = "keyword", required = false) keyword: kotlin.String?,
        @Parameter(description = "Return only active results") @Valid @RequestParam(value = "activeOnly", required = false) activeOnly: kotlin.Boolean?,
        @Parameter(description = "the IDs of the categories that this event is associated with") @Valid @RequestParam(value = "categoryIds", required = false) categoryIds: kotlin.String?,
        @Parameter(description = "the IDs of the filters that this event is associated with") @Valid @RequestParam(value = "filterIds", required = false) filterIds: kotlin.String?,
        @Parameter(description = "Offer audience ids to filter on") @Valid @RequestParam(value = "offerAudienceIds", required = false) offerAudienceIds: kotlin.String?,
        @Parameter(description = "Transaction audience ids to filter on") @Valid @RequestParam(value = "transactionAudienceIds", required = false) transactionAudienceIds: kotlin.String?,
        @Parameter(description = "The column to sort the search on. Possible values include: ID, CREATED, UPDATED, ACTIVE, ACTIVATED, EXPIRES, TITLE, SUBTITLE, DETAILS, OFFER_TYPE, SPECIAL_OFFER_TYPE, OFFER_VISIBILITY, ESTIMATED_VALUE, VOUCHER_PRICE, RETAILER_ID, RETAILER_NAME, RETAILER_LOCATION_ID, RETAILER_LOCATION_NAME, BILLABLE_ENTITY_ID, BILLABLE_ENTITY_NAME, RESPONSIBLE_DISPLAY", schema = Schema(allowableValues = ["ID", "CREATED", "UPDATED", "DELETED", "SEARCH_TAGS", "ACTIVE", "ACTIVATED", "EXPIRES", "REDEEMABLE_START", "REDEEMABLE_END", "TITLE", "SUBTITLE", "DETAILS", "OFFER_TYPE", "SPECIAL_OFFER_TYPE", "OFFER_VISIBILITY", "ESTIMATED_VALUE", "VOUCHER_PRICE", "VOUCHER_DISCOUNT_PRICE", "FULL_PRICE", "DICOUNT_PRICE", "TICKETS_REWARD", "AVAILABILITY_DATE", "RELEASE_DATE", "RETAILER_ID", "RETAILER_NAME", "RETAILER_LOCATION_ID", "RETAILER_LOCATION_NAME", "BILLABLE_ENTITY_ID", "BILLABLE_ENTITY_NAME", "RESPONSIBLE_DISPLAY"])) @Valid @RequestParam(value = "sortField", required = false) sortField: kotlin.String?,
        @Parameter(description = "The order to return the search results") @Valid @RequestParam(value = "descending", required = false) descending: kotlin.Boolean?,
        @Parameter(description = "Filter the events to return only those that start on or after the date") @Valid @RequestParam(value = "startDate", required = false) startDate: kotlin.Long?,
        @Parameter(description = "Filter the events to return only those that start on or before the date") @Valid @RequestParam(value = "endDate", required = false) endDate: kotlin.Long?,
        @Parameter(description = "The record to begin the return set on") @Valid @RequestParam(value = "start", required = false) start: kotlin.Int?,
        @Parameter(description = "The number of records to return") @Valid @RequestParam(value = "limit", required = false) limit: kotlin.Int?
    ): ResponseEntity<List<OfferShortResponse>> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Search Favorites",
        operationId = "searchFavorites",
        description = """Searches on the user's favorites.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SearchResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/favorite/search"
        value = [PATH_SEARCH_FAVORITES],
        produces = ["*/*"]
    )
    fun searchFavorites(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The type of the object to favorite {OFFER, OFFER_LOCATION, RETAILER_LOCATION, CATEGORY}", required = true) @Valid @RequestParam(value = "favoritableType", required = true) favoritableType: kotlin.String,
        @NotNull @Parameter(description = "Determines what to sort the results by {CREATED, UPDATED, DISPLAY}", required = true, schema = Schema(allowableValues = ["ID", "CREATED", "UPDATED", "DELETED", "SEARCH_TAGS", "ACTIVE", "DISPLAY"])) @Valid @RequestParam(value = "sortField", required = true) sortField: kotlin.String,
        @NotNull @Parameter(description = "Determines whether the results are in descending order", required = true) @Valid @RequestParam(value = "descending", required = true) descending: kotlin.Boolean,
        @NotNull @Parameter(description = "The start index for pagination", required = true) @Valid @RequestParam(value = "start", required = true) start: kotlin.Int,
        @NotNull @Parameter(description = "The limit for pagination (there is a hard limit of 1000)", required = true) @Valid @RequestParam(value = "limit", required = true) limit: kotlin.Int,
        @NotNull @Parameter(description = "Determines whether to only return active favorites", required = true) @Valid @RequestParam(value = "activeOnly", required = true) activeOnly: kotlin.Boolean,
        @NotNull @Parameter(description = "Determines whether to return a detailed version of the response list", required = true) @Valid @RequestParam(value = "returnFullResponse", required = true) returnFullResponse: kotlin.Boolean,
        @Parameter(description = "The unique ID given by the device (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "The account ID of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "The ID of an account the user would like to view favorites for") @Valid @RequestParam(value = "connectionAccountId", required = false) connectionAccountId: kotlin.Long?,
        @Parameter(description = "") @Valid @RequestParam(value = "secondaryType", required = false) secondaryType: kotlin.String?,
        @Parameter(description = "The keyword to search for") @Valid @RequestParam(value = "keyword", required = false) keyword: kotlin.String?,
        @Parameter(description = "The current latitude of the user") @Valid @RequestParam(value = "latitude", required = false) latitude: kotlin.Double?,
        @Parameter(description = "The current longitude of the user") @Valid @RequestParam(value = "longitude", required = false) longitude: kotlin.Double?
    ): ResponseEntity<SearchResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Search Filters",
        operationId = "searchFilters",
        description = """Search for filters.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(array = ArraySchema(schema = Schema(implementation = FilterResponse::class)))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/filter/search"
        value = [PATH_SEARCH_FILTERS],
        produces = ["*/*"]
    )
    fun searchFilters(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "The account id of the user") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "The string to search on") @Valid @RequestParam(value = "keyword", required = false) keyword: kotlin.String?,
        @Parameter(description = "the appKey of the application to retrieve filters for") @Valid @RequestParam(value = "appKey", required = false) appKey: kotlin.String?,
        @Parameter(description = "The group of filters to return: ALL, GLOBAL or MINE. ALL returns both global and application specific matches, GLOBAL only returns global matches, and MINE only returns the application specific matches. If not provided search on the application provided.", schema = Schema(allowableValues = ["ALL", "GLOBAL", "MINE"])) @Valid @RequestParam(value = "responseGroup", required = false) responseGroup: kotlin.String?,
        @Parameter(description = "Restrict the search to only those filters with no parent filter assigned.") @Valid @RequestParam(value = "rootOnly", required = false) rootOnly: kotlin.Boolean?,
        @Parameter(description = "The column to sort the search on. Possible values include: ID, CREATED, UPDATED, ACTIVE, NAME, DISPLAY", schema = Schema(allowableValues = ["ID", "CREATED", "UPDATED", "DELETED", "SEARCH_TAGS", "ACTIVE", "NAME", "DISPLAY"], defaultValue = "DISPLAY")) @Valid @RequestParam(value = "sortField", required = false, defaultValue = "DISPLAY") sortField: kotlin.String,
        @Parameter(description = "The order to return the search results", schema = Schema(defaultValue = "false")) @Valid @RequestParam(value = "descending", required = false, defaultValue = "false") descending: kotlin.Boolean,
        @Parameter(description = "The record to begin the return set on", schema = Schema(defaultValue = "0")) @Valid @RequestParam(value = "start", required = false, defaultValue = "0") start: kotlin.Int,
        @Parameter(description = "The number of records to return", schema = Schema(defaultValue = "20")) @Valid @RequestParam(value = "limit", required = false, defaultValue = "20") limit: kotlin.Int,
        @Parameter(description = "Determines whether to return only active categories", schema = Schema(defaultValue = "true")) @Valid @RequestParam(value = "activeOnly", required = false, defaultValue = "true") activeOnly: kotlin.Boolean
    ): ResponseEntity<List<FilterResponse>> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Search a Game",
        operationId = "searchGames",
        description = """Get a list of games for an application, just those the account has permissions to view.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = GameResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/game/search"
        value = [PATH_SEARCH_GAMES],
        produces = ["*/*"]
    )
    fun searchGames(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The logged in user.", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "the application key", required = true) @Valid @RequestParam(value = "appKey", required = true) appKey: kotlin.String,
        @NotNull @Parameter(description = "Start the result set at some index.", required = true) @Valid @RequestParam(value = "start", required = true) start: kotlin.Int,
        @NotNull @Parameter(description = "Limit the result to some number.", required = true) @Valid @RequestParam(value = "limit", required = true) limit: kotlin.Int,
        @Parameter(description = "Match the keyword to the owner name or level name.") @Valid @RequestParam(value = "keyword", required = false) keyword: kotlin.String?,
        @Parameter(description = "The maximum version of the level to return.") @Valid @RequestParam(value = "appVersion", required = false) appVersion: kotlin.String?,
        @Parameter(description = "more details in response") @Valid @RequestParam(value = "includeGameData", required = false) includeGameData: kotlin.Boolean?,
        @Parameter(description = "more details in response") @Valid @RequestParam(value = "includeInactive", required = false) includeInactive: kotlin.Boolean?
    ): ResponseEntity<GameResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Search User Identities",
        operationId = "searchIdentities",
        description = """Search User Identities.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation") ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/vatom/me/identities/search"
        value = [PATH_SEARCH_IDENTITIES]
    )
    fun searchIdentities(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "Sirqul Account Id", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @Parameter(description = "Return raw response") @Valid @RequestParam(value = "returnRawResponse", required = false) returnRawResponse: kotlin.Boolean?
    ): ResponseEntity<Unit> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Search Vatom User's Inventory",
        operationId = "searchInventory",
        description = """Searches the logged in user's Vatom Inventory.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation") ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/vatom/user-inventory/search"
        value = [PATH_SEARCH_INVENTORY]
    )
    fun searchInventory(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "Sirqul Account Id", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @Parameter(description = "Vatom Parameters") @Valid @RequestParam(value = "vatomParameters", required = false) vatomParameters: kotlin.String?,
        @Parameter(description = "Return raw response") @Valid @RequestParam(value = "returnRawResponse", required = false) returnRawResponse: kotlin.Boolean?
    ): ResponseEntity<Unit> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Search leaderboard and retrieve the matching ranking list",
        operationId = "searchLeaderboards",
        description = """Search leaderboard and retrieve the matching ranking list""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = LeaderboardResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/leaderboard/search"
        value = [PATH_SEARCH_LEADERBOARDS],
        produces = ["*/*"]
    )
    fun searchLeaderboards(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "The account id of the user requesting the search.") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "The application key.") @Valid @RequestParam(value = "appKey", required = false) appKey: kotlin.String?,
        @Parameter(description = "only include global leaderboards (this overrides the appKey filter)") @Valid @RequestParam(value = "globalOnly", required = false) globalOnly: kotlin.Boolean?,
        @Parameter(description = "keyword to search by title") @Valid @RequestParam(value = "keyword", required = false) keyword: kotlin.String?,
        @Parameter(description = "comma separated list of leaderboard ids to filter results with") @Valid @RequestParam(value = "leaderboardIds", required = false) leaderboardIds: kotlin.String?,
        @Parameter(description = "comma separated list of rankType to filter results with") @Valid @RequestParam(value = "rankTypes", required = false) rankTypes: kotlin.String?,
        @Parameter(description = "sortField of the result, from LeaderboardApiMap (TITLE, DESCRIPTION, CREATED, UPDATED, RANK_TYPE, RANK_MODE)") @Valid @RequestParam(value = "sortField", required = false) sortField: kotlin.String?,
        @Parameter(description = "Determines whether the sorted list is in descending or ascending order") @Valid @RequestParam(value = "descending", required = false) descending: kotlin.Boolean?,
        @Parameter(description = "include inactive in the result") @Valid @RequestParam(value = "includeInactive", required = false) includeInactive: kotlin.Boolean?,
        @Parameter(description = "determines whether to include the application response for each leaderboard") @Valid @RequestParam(value = "includeAppResponse", required = false) includeAppResponse: kotlin.Boolean?,
        @Parameter(description = "Start the result set at some index.") @Valid @RequestParam(value = "start", required = false) start: kotlin.Int?,
        @Parameter(description = "Limit the result to some number.") @Valid @RequestParam(value = "limit", required = false) limit: kotlin.Int?
    ): ResponseEntity<LeaderboardResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Search Likes",
        operationId = "searchLikes",
        description = """Search for likes on a likable object.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SearchResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/like/search"
        value = [PATH_SEARCH_LIKES],
        produces = ["*/*"]
    )
    fun searchLikes(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The type of the likable object {ALBUM, ALBUM_CONTEST, ASSET, GAME_LEVEL, NOTE, THEME_DESCRIPTOR}", required = true) @Valid @RequestParam(value = "likableType", required = true) likableType: kotlin.String,
        @NotNull @Parameter(description = "The id of the likable object", required = true) @Valid @RequestParam(value = "likableId", required = true) likableId: kotlin.Long,
        @Parameter(description = "The unique device identifier that made the request (either deviceId or accountId must be used)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "The unique accountId that made the request (either deviceId or accountId must be used)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "Comma separated list of account IDs for filtering on users") @Valid @RequestParam(value = "connectionAccountIds", required = false) connectionAccountIds: kotlin.String?,
        @Parameter(description = "The field to sort by. Possible values include: ID", schema = Schema(defaultValue = "ID")) @Valid @RequestParam(value = "sortField", required = false, defaultValue = "ID") sortField: kotlin.String,
        @Parameter(description = "Determines whether the sorted list is in descending or ascending order", schema = Schema(defaultValue = "true")) @Valid @RequestParam(value = "descending", required = false, defaultValue = "true") descending: kotlin.Boolean,
        @Parameter(description = "return items that have been updated since this date (time-stamp in milliseconds)") @Valid @RequestParam(value = "updatedSince", required = false) updatedSince: kotlin.Long?,
        @Parameter(description = "return items that have been updated before this date (time-stamp in milliseconds)") @Valid @RequestParam(value = "updatedBefore", required = false) updatedBefore: kotlin.Long?,
        @Parameter(description = "the start index for pagination", schema = Schema(defaultValue = "0")) @Valid @RequestParam(value = "start", required = false, defaultValue = "0") start: kotlin.Int,
        @Parameter(description = "the limit for pagination", schema = Schema(defaultValue = "20")) @Valid @RequestParam(value = "limit", required = false, defaultValue = "20") limit: kotlin.Int
    ): ResponseEntity<SearchResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Search Listings",
        operationId = "searchListing",
        description = """Search for event listings from the start time to end time""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(array = ArraySchema(schema = Schema(implementation = ListingResponse::class)))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/listing/search"
        value = [PATH_SEARCH_LISTING],
        produces = ["*/*"]
    )
    fun searchListing(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "the account id of the user") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "search the event name and description for this keyword") @Valid @RequestParam(value = "keyword", required = false) keyword: kotlin.String?,
        @Parameter(description = "the record to begin the return set on", schema = Schema(defaultValue = "0")) @Valid @RequestParam(value = "start", required = false, defaultValue = "0") start: kotlin.Int,
        @Parameter(description = "the number of records to return", schema = Schema(defaultValue = "20")) @Valid @RequestParam(value = "limit", required = false, defaultValue = "20") limit: kotlin.Int,
        @Parameter(description = "whether to search on active listings only", schema = Schema(defaultValue = "false")) @Valid @RequestParam(value = "activeOnly", required = false, defaultValue = "false") activeOnly: kotlin.Boolean,
        @Parameter(description = "the current latitude of the user") @Valid @RequestParam(value = "latitude", required = false) latitude: kotlin.Double?,
        @Parameter(description = "the current longitude of the user") @Valid @RequestParam(value = "longitude", required = false) longitude: kotlin.Double?,
        @Parameter(description = "the start date to search from") @Valid @RequestParam(value = "startDate", required = false) startDate: kotlin.Long?,
        @Parameter(description = "the end date to search to") @Valid @RequestParam(value = "endDate", required = false) endDate: kotlin.Long?,
        @Parameter(description = "only return items of these categories") @Valid @RequestParam(value = "categoryIds", required = false) categoryIds: kotlin.String?,
        @Parameter(description = "") @Valid @RequestParam(value = "filterIds", required = false) filterIds: kotlin.String?,
        @Parameter(description = "determines whether to use configured listing order ids", schema = Schema(defaultValue = "true")) @Valid @RequestParam(value = "useListingOrderIds", required = false, defaultValue = "true") useListingOrderIds: kotlin.Boolean,
        @Parameter(description = "external identifier used by a third party") @Valid @RequestParam(value = "externalId", required = false) externalId: kotlin.String?,
        @Parameter(description = "secondary external identifier used by a third party") @Valid @RequestParam(value = "externalId2", required = false) externalId2: kotlin.String?,
        @Parameter(description = "external group identifier used by a third party") @Valid @RequestParam(value = "externalGroupId", required = false) externalGroupId: kotlin.String?
    ): ResponseEntity<List<ListingResponse>> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Search Location Rating Indexes",
        operationId = "searchLocationRatingIndexes",
        description = """Search for retailer locations by averages near you.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(array = ArraySchema(schema = Schema(implementation = RatingIndexResponse::class)))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/location/rating/index/search"
        value = [PATH_SEARCH_LOCATION_RATING_INDEXES],
        produces = ["*/*"]
    )
    fun searchLocationRatingIndexes(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "Comma separated list of category ids to filter the results by") @Valid @RequestParam(value = "categoryIds", required = false) categoryIds: kotlin.String?,
        @Parameter(description = "The keyword used to search") @Valid @RequestParam(value = "keyword", required = false) keyword: kotlin.String?,
        @Parameter(description = "The type of location to filter the results by") @Valid @RequestParam(value = "locationType", required = false) locationType: kotlin.String?,
        @Parameter(description = "The column to sort the search on {ID, CREATED, UPDATED, ACTIVE, RATABLE_TYPE, RATABLE_ID, RATABLE_DISPLAY, CATEGORY_ID, CATEGORY_NAME, CATEGORY_SHORT_NAME, CATEGORY_DISPLAY, COUNT, SUMMATION, AVERAGE, VALUE}", schema = Schema(allowableValues = ["ID", "CREATED", "UPDATED", "DELETED", "SEARCH_TAGS", "ACTIVE", "RATABLE_TYPE", "RATABLE_ID", "RATABLE_DISPLAY", "CATEGORY_ID", "CATEGORY_NAME", "CATEGORY_SHORT_NAME", "CATEGORY_DISPLAY", "COUNT", "SUMMATION", "AVERAGE", "VALUE"])) @Valid @RequestParam(value = "sortField", required = false) sortField: kotlin.String?,
        @Parameter(description = "The order to return the search results") @Valid @RequestParam(value = "descending", required = false) descending: kotlin.Boolean?,
        @Parameter(description = "The record to begin the return set on") @Valid @RequestParam(value = "start", required = false) start: kotlin.Int?,
        @Parameter(description = "The number of records to return") @Valid @RequestParam(value = "limit", required = false) limit: kotlin.Int?,
        @Parameter(description = "The search radius in kilometers to filter results") @Valid @RequestParam(value = "searchRange", required = false) searchRange: kotlin.Double?,
        @Parameter(description = "The current location of the user") @Valid @RequestParam(value = "latitude", required = false) latitude: kotlin.Double?,
        @Parameter(description = "The current location of the user") @Valid @RequestParam(value = "longitude", required = false) longitude: kotlin.Double?,
        @Parameter(description = "Determines whether to return the overall rating record instead") @Valid @RequestParam(value = "returnOverallRating", required = false) returnOverallRating: kotlin.Boolean?,
        @Parameter(description = "", schema = Schema(allowableValues = ["MILES", "KILOMETERS"])) @Valid @RequestParam(value = "distanceUnit", required = false) distanceUnit: kotlin.String?,
        @Parameter(description = "whether to return the retailer or not") @Valid @RequestParam(value = "returnRetailer", required = false) returnRetailer: kotlin.Boolean?,
        @Parameter(description = "whether to return the assets or not") @Valid @RequestParam(value = "returnAssets", required = false) returnAssets: kotlin.Boolean?,
        @Parameter(description = "whether to return the offers or not") @Valid @RequestParam(value = "returnOffers", required = false) returnOffers: kotlin.Boolean?,
        @Parameter(description = "whether to return the categories or not") @Valid @RequestParam(value = "returnCategories", required = false) returnCategories: kotlin.Boolean?,
        @Parameter(description = "whether to return the filters or not") @Valid @RequestParam(value = "returnFilters", required = false) returnFilters: kotlin.Boolean?
    ): ResponseEntity<List<RatingIndexResponse>> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Search Media",
        operationId = "searchMedia",
        description = """Searches on events that the account has access to.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(array = ArraySchema(schema = Schema(implementation = MediaOfferResponse::class)))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/media/search"
        value = [PATH_SEARCH_MEDIA],
        produces = ["*/*"]
    )
    fun searchMedia(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The logged in user.", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "Return only active results", required = true) @Valid @RequestParam(value = "activeOnly", required = true) activeOnly: kotlin.Boolean,
        @NotNull @Parameter(description = "The column to sort the search on. Possible values include: ID, CREATED, UPDATED, ACTIVE, ACTIVATED, EXPIRES, TITLE, SUBTITLE, DETAILS, OFFER_TYPE, SPECIAL_OFFER_TYPE, OFFER_VISIBILITY, ESTIMATED_VALUE, VOUCHER_PRICE, RETAILER_ID, RETAILER_NAME, RETAILER_LOCATION_ID, RETAILER_LOCATION_NAME, BILLABLE_ENTITY_ID, BILLABLE_ENTITY_NAME, RESPONSIBLE_DISPLAY, AVAILABILITY_DATE, RELEASE_DATE", required = true, schema = Schema(allowableValues = ["ID", "CREATED", "UPDATED", "DELETED", "SEARCH_TAGS", "ACTIVE", "ACTIVATED", "EXPIRES", "REDEEMABLE_START", "REDEEMABLE_END", "TITLE", "SUBTITLE", "DETAILS", "OFFER_TYPE", "SPECIAL_OFFER_TYPE", "OFFER_VISIBILITY", "ESTIMATED_VALUE", "VOUCHER_PRICE", "VOUCHER_DISCOUNT_PRICE", "FULL_PRICE", "DICOUNT_PRICE", "TICKETS_REWARD", "AVAILABILITY_DATE", "RELEASE_DATE", "RETAILER_ID", "RETAILER_NAME", "RETAILER_LOCATION_ID", "RETAILER_LOCATION_NAME", "BILLABLE_ENTITY_ID", "BILLABLE_ENTITY_NAME", "RESPONSIBLE_DISPLAY"])) @Valid @RequestParam(value = "sortField", required = true) sortField: kotlin.String,
        @NotNull @Parameter(description = "The order to return the search results", required = true) @Valid @RequestParam(value = "descending", required = true) descending: kotlin.Boolean,
        @Parameter(description = "The keyword used to search") @Valid @RequestParam(value = "keyword", required = false) keyword: kotlin.String?,
        @Parameter(description = "") @Valid @RequestParam(value = "categoryIds", required = false) categoryIds: kotlin.String?,
        @Parameter(description = "") @Valid @RequestParam(value = "filterIds", required = false) filterIds: kotlin.String?,
        @Parameter(description = "The record to begin the return set on") @Valid @RequestParam(value = "start", required = false) start: kotlin.Int?,
        @Parameter(description = "The number of records to return") @Valid @RequestParam(value = "limit", required = false) limit: kotlin.Int?
    ): ResponseEntity<List<MediaOfferResponse>> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Search Mission Formats",
        operationId = "searchMissionFormats",
        description = """Searches on pre-defined mission formats""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(array = ArraySchema(schema = Schema(implementation = MissionFormatResponse::class)))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/mission/format/search"
        value = [PATH_SEARCH_MISSION_FORMATS],
        produces = ["*/*"]
    )
    fun searchMissionFormats(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The starting index in the result set to return. Default is 0.", required = true) @Valid @RequestParam(value = "start", required = true) start: kotlin.Int,
        @NotNull @Parameter(description = "The total number of records to return. Default is 20.", required = true) @Valid @RequestParam(value = "limit", required = true) limit: kotlin.Int,
        @NotNull @Parameter(description = "Determines whether to return only active results. Default is false.", required = true) @Valid @RequestParam(value = "activeOnly", required = true) activeOnly: kotlin.Boolean
    ): ResponseEntity<List<MissionFormatResponse>> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Search Mission Invites",
        operationId = "searchMissionInvites",
        description = """Get a list of mission invites that the account has.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(array = ArraySchema(schema = Schema(implementation = MissionResponse::class)))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/mission/invite/search"
        value = [PATH_SEARCH_MISSION_INVITES],
        produces = ["*/*"]
    )
    fun searchMissionInvites(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "the device id (deviceId or accountId required).") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "the account id of the user (deviceId or accountId required).") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "the app to retrieve the data for, use your application key.") @Valid @RequestParam(value = "appKey", required = false) appKey: kotlin.String?,
        @Parameter(description = "the application version, used to version the game level data") @Valid @RequestParam(value = "appVersion", required = false) appVersion: kotlin.String?,
        @Parameter(description = "the mission id to filter on") @Valid @RequestParam(value = "missionId", required = false) missionId: kotlin.Long?,
        @Parameter(description = "The invite status to filter for, comma separated list {AVAILABLE, PENDING, UPDATED, ACCEPTED, ACTIVE, QUIT, COMPLETED, PENDING_REVIEW, REJECTED}") @Valid @RequestParam(value = "status", required = false) status: kotlin.String?,
        @Parameter(description = "Only return invites that have been updated since this date/time (long)") @Valid @RequestParam(value = "lastUpdated", required = false) lastUpdated: kotlin.Long?,
        @Parameter(description = "The index into the record set to start with.") @Valid @RequestParam(value = "start", required = false) start: kotlin.Int?,
        @Parameter(description = "The total number of record to return.") @Valid @RequestParam(value = "limit", required = false) limit: kotlin.Int?,
        @Parameter(description = "the keyword to search on") @Valid @RequestParam(value = "keyword", required = false) keyword: kotlin.String?,
        @Parameter(description = "") @Valid @RequestParam(value = "missionTypes", required = false) missionTypes: kotlin.String?,
        @Parameter(description = "filter results by the account's billable") @Valid @RequestParam(value = "filterByBillable", required = false) filterByBillable: kotlin.Boolean?,
        @Parameter(description = "Include the game level data with the mission.") @Valid @RequestParam(value = "includeGameData", required = false) includeGameData: kotlin.Boolean?
    ): ResponseEntity<List<MissionResponse>> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Search Missions",
        operationId = "searchMissions",
        description = """Get the list missions available to the account.  """,
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(array = ArraySchema(schema = Schema(implementation = MissionResponse::class)))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/mission/search"
        value = [PATH_SEARCH_MISSIONS],
        produces = ["*/*"]
    )
    fun searchMissions(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The logged in user.", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @Parameter(description = "Filter by keyword") @Valid @RequestParam(value = "keyword", required = false) keyword: kotlin.String?,
        @Parameter(description = "Custom string client apps can use for searching/filtering missions") @Valid @RequestParam(value = "subType", required = false) subType: kotlin.String?,
        @Parameter(description = "The index into the record set to start with. Default is 0.") @Valid @RequestParam(value = "start", required = false) start: kotlin.Int?,
        @Parameter(description = "The total number of record to return. Default is 20, maximum is 100.") @Valid @RequestParam(value = "limit", required = false) limit: kotlin.Int?,
        @Parameter(description = "If true then return the game level data in the response. Default is false.") @Valid @RequestParam(value = "includeGameData", required = false) includeGameData: kotlin.Boolean?,
        @Parameter(description = "If true then return the audience data in the response. Default is false.") @Valid @RequestParam(value = "includeAudiences", required = false) includeAudiences: kotlin.Boolean?,
        @Parameter(description = "If true then include inactive missions. Default is false.") @Valid @RequestParam(value = "includeInactive", required = false) includeInactive: kotlin.Boolean?,
        @Parameter(description = "A list of game types to include; click_leaderboard, click_banner, click_skyscraper, click_full, click_video, click_zip, create, vote, question, invite, share, json, xml") @Valid @RequestParam(value = "suffix", required = false) suffix: kotlin.String?,
        @Parameter(description = "The field to sort the search on (for example TITLE)") @Valid @RequestParam(value = "sortField", required = false) sortField: kotlin.String?,
        @Parameter(description = "Whether to sort in descending order (default true)") @Valid @RequestParam(value = "descending", required = false) descending: kotlin.Boolean?
    ): ResponseEntity<List<MissionResponse>> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Search Missions by Billable Entity",
        operationId = "searchMissionsByBillableEntity",
        description = """Use the accountId to determine the associated BillableEntity.  From there get a list of all accounts associated as managers.  Get the list missions owned by all associated managers.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(array = ArraySchema(schema = Schema(implementation = MissionResponse::class)))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/mission/searchByBillableEntity"
        value = [PATH_SEARCH_MISSIONS_BY_BILLABLE_ENTITY],
        produces = ["*/*"]
    )
    fun searchMissionsByBillableEntity(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The logged in user.", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @Parameter(description = "Filter by keyword") @Valid @RequestParam(value = "keyword", required = false) keyword: kotlin.String?,
        @Parameter(description = "The index into the record set to start with. Default is 0.") @Valid @RequestParam(value = "start", required = false) start: kotlin.Int?,
        @Parameter(description = "The total number of record to return. Default id 20.") @Valid @RequestParam(value = "limit", required = false) limit: kotlin.Int?,
        @Parameter(description = "If true then return the game level data in the response. Default is false.") @Valid @RequestParam(value = "includeGameData", required = false) includeGameData: kotlin.Boolean?,
        @Parameter(description = "If true then return the audience data in the response. Default is false.") @Valid @RequestParam(value = "includeAudiences", required = false) includeAudiences: kotlin.Boolean?,
        @Parameter(description = "If true then include inactive missions. Default is false.") @Valid @RequestParam(value = "includeInactive", required = false) includeInactive: kotlin.Boolean?,
        @Parameter(description = "A list of game types to include; click_leaderboard, click_banner, click_skyscraper, click_full, click_video, click_zip, create, vote, question, invite, share, json, xml") @Valid @RequestParam(value = "suffix", required = false) suffix: kotlin.String?,
        @Parameter(description = "The field to sort the search on (for example TITLE)") @Valid @RequestParam(value = "sortField", required = false) sortField: kotlin.String?,
        @Parameter(description = "Whether to sort in descending order (default true)") @Valid @RequestParam(value = "descending", required = false) descending: kotlin.Boolean?
    ): ResponseEntity<List<MissionResponse>> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Search Networks",
        operationId = "searchNetworks",
        description = """Search on supported third party networks and custom networks from external users.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(array = ArraySchema(schema = Schema(implementation = ThirdPartyNetworkShortResponse::class)))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/thirdparty/network/search"
        value = [PATH_SEARCH_NETWORKS],
        produces = ["*/*"]
    )
    fun searchNetworks(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The account id making the request", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "The column to sort the search on, possible values include: UPDATED (default), CREATED, NAME", required = true, schema = Schema(allowableValues = ["ID", "CREATED", "UPDATED", "DELETED", "SEARCH_TAGS", "ACTIVE", "BILLABLE_ENTITY_ID", "BILLABLE_ENTITY_NAME", "RESPONSIBLE_DISPLAY", "NAME", "DESCRIPTION"])) @Valid @RequestParam(value = "sortField", required = true) sortField: kotlin.String,
        @NotNull @Parameter(description = "The order to return the search results", required = true) @Valid @RequestParam(value = "descending", required = true) descending: kotlin.Boolean,
        @NotNull @Parameter(description = "The start of the pagination", required = true) @Valid @RequestParam(value = "start", required = true) start: kotlin.Int,
        @NotNull @Parameter(description = "The limit of the pagination", required = true) @Valid @RequestParam(value = "limit", required = true) limit: kotlin.Int,
        @NotNull @Parameter(description = "Return only active results", required = true) @Valid @RequestParam(value = "activeOnly", required = true) activeOnly: kotlin.Boolean,
        @Parameter(description = "The keyword used to search on the network name and description fields") @Valid @RequestParam(value = "keyword", required = false) keyword: kotlin.String?,
        @Parameter(description = "Determines whether to only return applications that the user has access to") @Valid @RequestParam(value = "filterBillable", required = false) filterBillable: kotlin.Boolean?
    ): ResponseEntity<List<ThirdPartyNetworkShortResponse>> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Search Notes",
        operationId = "searchNotes",
        description = """Search for notes on a notable object.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(array = ArraySchema(schema = Schema(implementation = NoteResponse::class)))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/note/search"
        value = [PATH_SEARCH_NOTES],
        produces = ["*/*"]
    )
    fun searchNotes(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "The device id (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "The account id of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "The notable object type {ALBUM, ALBUM_CONTEST, ASSET, GAME_LEVEL, OFFER, OFFER_LOCATION, RETAILER, RETAILER_LOCATION, THEME_DESCRIPTOR}") @Valid @RequestParam(value = "notableType", required = false) notableType: kotlin.String?,
        @Parameter(description = "The id of the notable object") @Valid @RequestParam(value = "notableId", required = false) notableId: kotlin.Long?,
        @Parameter(description = "Comma separated list of noteType strings to filter results with") @Valid @RequestParam(value = "noteTypes", required = false) noteTypes: kotlin.String?,
        @Parameter(description = "The application key used to identify the application") @Valid @RequestParam(value = "appKey", required = false) appKey: kotlin.String?,
        @Parameter(description = "The keyword used to search") @Valid @RequestParam(value = "keyword", required = false) keyword: kotlin.String?,
        @Parameter(description = "return items that has flagCount >= flagCountMinimum if this is set, return all items, even ones with flagCount >= flagThreshold") @Valid @RequestParam(value = "flagCountMinimum", required = false) flagCountMinimum: kotlin.Long?,
        @Parameter(description = "return items that has flagCount >= flagThreshold, which are hidden by default") @Valid @RequestParam(value = "flagsExceedThreshold", required = false) flagsExceedThreshold: kotlin.Boolean?,
        @Parameter(description = "include inactive in the result") @Valid @RequestParam(value = "includeInactive", required = false) includeInactive: kotlin.Boolean?,
        @Parameter(description = "The column to sort the search on", schema = Schema(allowableValues = ["ID", "CREATED", "UPDATED", "DELETED", "SEARCH_TAGS", "ACTIVE", "OWNER_DISPLAY", "NOTABLE_TYPE", "NOTE_TAG", "NOTE_COUNT", "LIKES", "DISLIKES"])) @Valid @RequestParam(value = "sortField", required = false) sortField: kotlin.String?,
        @Parameter(description = "The order to return the search results") @Valid @RequestParam(value = "descending", required = false) descending: kotlin.Boolean?,
        @Parameter(description = "Determines whether to return the NoteFullResponse for each search item") @Valid @RequestParam(value = "returnFullResponse", required = false) returnFullResponse: kotlin.Boolean?,
        @Parameter(description = "return items that have been updated since this date (time-stamp in milliseconds)") @Valid @RequestParam(value = "updatedSince", required = false) updatedSince: kotlin.Long?,
        @Parameter(description = "return items that have been updated before this date (time-stamp in milliseconds)") @Valid @RequestParam(value = "updatedBefore", required = false) updatedBefore: kotlin.Long?,
        @Parameter(description = "The record to begin the return set on") @Valid @RequestParam(value = "start", required = false) start: kotlin.Int?,
        @Parameter(description = "The number of records to return") @Valid @RequestParam(value = "limit", required = false) limit: kotlin.Int?
    ): ResponseEntity<List<NoteResponse>> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Search Notification Templates",
        operationId = "searchNotificationTemplate",
        description = """Search for notification templates on owned applications.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = NotificationTemplateResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/notification/template/search"
        value = [PATH_SEARCH_NOTIFICATION_TEMPLATE],
        produces = ["*/*"]
    )
    fun searchNotificationTemplate(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The account ID of the user.", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "Specifies how results are ordered.ID - order results by the notificationTemplateId CREATED - order results by the created date UPDATED - order results by the updated date TITLE - order results by title EVENT - order results by event CONDUIT - order results by conduit APP_NAME - order results by the application name ('global' templates will not have an application and will be returned last if 'descending' is set to false.", required = true) @Valid @RequestParam(value = "sortField", required = true) sortField: kotlin.String,
        @NotNull @Parameter(description = "Specified whether the results are returned in descending or ascending order.", required = true) @Valid @RequestParam(value = "descending", required = true) descending: kotlin.Boolean,
        @NotNull @Parameter(description = "The start of the pagination.", required = true) @Valid @RequestParam(value = "start", required = true) start: kotlin.Int,
        @NotNull @Parameter(description = "The limit of the pagination.", required = true) @Valid @RequestParam(value = "limit", required = true) limit: kotlin.Int,
        @Parameter(description = "Filter results by application.") @Valid @RequestParam(value = "appKey", required = false) appKey: kotlin.String?,
        @Parameter(description = "Filter results by event.") @Valid @RequestParam(value = "event", required = false) event: kotlin.String?,
        @Parameter(description = "Filter results by notification type: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION.") @Valid @RequestParam(value = "conduit", required = false) conduit: kotlin.String?,
        @Parameter(description = "Returns only templates that have been reserved for system use on all applications (only for admin accounts).") @Valid @RequestParam(value = "globalOnly", required = false) globalOnly: kotlin.Boolean?,
        @Parameter(description = "Returns only templates that use reserved events.") @Valid @RequestParam(value = "reservedOnly", required = false) reservedOnly: kotlin.Boolean?,
        @Parameter(description = "Filter results by keyword on the title, tags.") @Valid @RequestParam(value = "keyword", required = false) keyword: kotlin.String?
    ): ResponseEntity<NotificationTemplateResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Search Objects",
        operationId = "searchObject",
        description = """Search for Objects and return the list of names found.  Use this in conjunction with the object get service to present the current data model defined.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = ObjectStoreResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/object/search"
        value = [PATH_SEARCH_OBJECT],
        produces = ["*/*"]
    )
    fun searchObject(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The account id of the logged in user", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "The application key for updating an existing application", required = true) @Valid @RequestParam(value = "appKey", required = true) appKey: kotlin.String,
        @NotNull @Parameter(description = "The start of the pagination", required = true) @Valid @RequestParam(value = "start", required = true) start: kotlin.Long,
        @NotNull @Parameter(description = "The limit of the pagination", required = true) @Valid @RequestParam(value = "limit", required = true) limit: kotlin.Long,
        @Parameter(description = "The name of the object(s) to search for, can be a partial match") @Valid @RequestParam(value = "keyword", required = false) keyword: kotlin.String?
    ): ResponseEntity<ObjectStoreResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Search Tournament Objects",
        operationId = "searchObjects",
        description = """Search on game objects of tournaments""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/tournament/object/search"
        value = [PATH_SEARCH_OBJECTS],
        produces = ["*/*"]
    )
    fun searchObjects(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the account ID", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "the game level id to filter results by", required = true) @Valid @RequestParam(value = "gameLevelId", required = true) gameLevelId: kotlin.Long,
        @Parameter(description = "the field to sort by", schema = Schema(allowableValues = ["ID", "PLAYER_SCORE_COUNT"], defaultValue = "PLAYER_SCORE_COUNT")) @Valid @RequestParam(value = "sortField", required = false, defaultValue = "PLAYER_SCORE_COUNT") sortField: kotlin.String,
        @Parameter(description = "determines whether the sorted list is in descending or ascending order", schema = Schema(defaultValue = "true")) @Valid @RequestParam(value = "descending", required = false, defaultValue = "true") descending: kotlin.Boolean,
        @Parameter(description = "the start index for pagination", schema = Schema(defaultValue = "0")) @Valid @RequestParam(value = "start", required = false, defaultValue = "0") start: kotlin.Int,
        @Parameter(description = "the limit for pagination", schema = Schema(defaultValue = "20")) @Valid @RequestParam(value = "limit", required = false, defaultValue = "20") limit: kotlin.Int
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Search Offer Status",
        operationId = "searchOfferTransactionStatuses",
        description = """Search for the available offer statuses""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(array = ArraySchema(schema = Schema(implementation = OfferTransactionStatusResponse::class)))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/offer/status/search"
        value = [PATH_SEARCH_OFFER_TRANSACTION_STATUSES],
        produces = ["*/*"]
    )
    fun searchOfferTransactionStatuses(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "The device id (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "The account id of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "Used to update the user's current location") @Valid @RequestParam(value = "latitude", required = false) latitude: kotlin.Double?,
        @Parameter(description = "Used to update the user's current location") @Valid @RequestParam(value = "longitude", required = false) longitude: kotlin.Double?,
        @Parameter(description = "Search the name and description fields") @Valid @RequestParam(value = "keyword", required = false) keyword: kotlin.String?,
        @Parameter(description = "The actors role, possible values are: CUSTOMER, RETAILER, or ANY") @Valid @RequestParam(value = "role", required = false) role: kotlin.String?,
        @Parameter(description = "The application making the request") @Valid @RequestParam(value = "appKey", required = false) appKey: kotlin.String?,
        @Parameter(description = "The field to sort on, possible values are: ID, CREATED, UPDATED, DELETED, SEARCH_TAGS, ACTIVE, NAME, DESCRIPTION, CODE, ROLE", schema = Schema(allowableValues = ["ID", "CREATED", "UPDATED", "DELETED", "SEARCH_TAGS", "ACTIVE", "NAME", "DESCRIPTION", "CODE", "ROLE"], defaultValue = "CODE")) @Valid @RequestParam(value = "sortField", required = false, defaultValue = "CODE") sortField: kotlin.String,
        @Parameter(description = "Determines whether the results are in descending order", schema = Schema(defaultValue = "true")) @Valid @RequestParam(value = "descending", required = false, defaultValue = "true") descending: kotlin.Boolean,
        @Parameter(description = "The start index for pagination", schema = Schema(defaultValue = "0")) @Valid @RequestParam(value = "start", required = false, defaultValue = "0") start: kotlin.Int,
        @Parameter(description = "The limit for pagination", schema = Schema(defaultValue = "20")) @Valid @RequestParam(value = "limit", required = false, defaultValue = "20") limit: kotlin.Int,
        @Parameter(description = "If true include inactive items", schema = Schema(defaultValue = "false")) @Valid @RequestParam(value = "includeInactive", required = false, defaultValue = "false") includeInactive: kotlin.Boolean
    ): ResponseEntity<List<OfferTransactionStatusResponse>> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Search Wallet Offers",
        operationId = "searchOfferTransactions",
        description = """Search on active offers currently in the user's wallet, or past offers the user has already redeemed.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(array = ArraySchema(schema = Schema(implementation = OfferTransactionResponse::class)))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/wallet/search"
        value = [PATH_SEARCH_OFFER_TRANSACTIONS],
        produces = ["*/*"]
    )
    fun searchOfferTransactions(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "The device id (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "The account id of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "The keyword to search for") @Valid @RequestParam(value = "keyword", required = false) keyword: kotlin.String?,
        @Parameter(description = "Filter results for this retailer") @Valid @RequestParam(value = "retailerId", required = false) retailerId: kotlin.Long?,
        @Parameter(description = "Filter results for a list of retailers") @Valid @RequestParam(value = "retailerIds", required = false) retailerIds: kotlin.String?,
        @Parameter(description = "Filter results for this retailer location") @Valid @RequestParam(value = "retailerLocationId", required = false) retailerLocationId: kotlin.Long?,
        @Parameter(description = "Filter results for a list of retailer locations") @Valid @RequestParam(value = "retailerLocationIds", required = false) retailerLocationIds: kotlin.String?,
        @Parameter(description = "Filter results to exclude retailer locations") @Valid @RequestParam(value = "excludeRetailerLocationIds", required = false) excludeRetailerLocationIds: kotlin.String?,
        @Parameter(description = "Filter results for this offer") @Valid @RequestParam(value = "offerId", required = false) offerId: kotlin.Long?,
        @Parameter(description = "Filter results for a list of offer") @Valid @RequestParam(value = "offerIds", required = false) offerIds: kotlin.String?,
        @Parameter(description = "Filter results for this offer location") @Valid @RequestParam(value = "offerLocationId", required = false) offerLocationId: kotlin.Long?,
        @Parameter(description = "Filter results for a list of offer locations") @Valid @RequestParam(value = "offerLocationIds", required = false) offerLocationIds: kotlin.String?,
        @Parameter(description = "Filter results to return a specific offer type", schema = Schema(allowableValues = ["VOUCHER", "COUPON", "PRODUCT", "MEDIA", "EVENT", "DEVICE"])) @Valid @RequestParam(value = "offerType", required = false) offerType: kotlin.String?,
        @Parameter(description = "Filter results to return specific offer types") @Valid @RequestParam(value = "offerTypes", required = false) offerTypes: kotlin.String?,
        @Parameter(description = "Filter results to return a specific special offer type") @Valid @RequestParam(value = "specialOfferType", required = false) specialOfferType: kotlin.String?,
        @Parameter(description = "Filter results to return specific special offer types") @Valid @RequestParam(value = "specialOfferTypes", required = false) specialOfferTypes: kotlin.String?,
        @Parameter(description = "Category Ids") @Valid @RequestParam(value = "categoryIds", required = false) categoryIds: kotlin.String?,
        @Parameter(description = "Filter Ids") @Valid @RequestParam(value = "filterIds", required = false) filterIds: kotlin.String?,
        @Parameter(description = "Offer Audience Ids") @Valid @RequestParam(value = "offerAudienceIds", required = false) offerAudienceIds: kotlin.String?,
        @Parameter(description = "Determines what to sort the results by", schema = Schema(allowableValues = ["ID", "CREATED", "UPDATED", "DELETED", "SEARCH_TAGS", "ACTIVE", "ACTIVATED", "EXPIRES", "TITLE", "SUBTITLE", "DETAILS", "OFFER_TYPE", "SPECIAL_OFFER_TYPE", "OFFER_VISIBILITY", "REDEEMABLE_START", "REDEEMABLE_END", "CUSTOMER_ID", "CUSTOMER_DISPLAY", "RETAILER_ID", "RETAILER_NAME", "RETAILER_LOCATION_ID", "RETAILER_LOCATION_NAME", "BILLABLE_ENTITY_ID", "BILLABLE_ENTITY_NAME", "RESPONSIBLE_DISPLAY"], defaultValue = "CREATED")) @Valid @RequestParam(value = "sortField", required = false, defaultValue = "CREATED") sortField: kotlin.String,
        @Parameter(description = "Determines whether the results are in descending order", schema = Schema(defaultValue = "true")) @Valid @RequestParam(value = "descending", required = false, defaultValue = "true") descending: kotlin.Boolean,
        @Parameter(description = "The start index for pagination", schema = Schema(defaultValue = "0")) @Valid @RequestParam(value = "start", required = false, defaultValue = "0") start: kotlin.Int,
        @Parameter(description = "The limit for pagination", schema = Schema(defaultValue = "20")) @Valid @RequestParam(value = "limit", required = false, defaultValue = "20") limit: kotlin.Int,
        @Parameter(description = "The latitude location of the user") @Valid @RequestParam(value = "latitude", required = false) latitude: kotlin.Double?,
        @Parameter(description = "The latitude location of the user") @Valid @RequestParam(value = "longitude", required = false) longitude: kotlin.Double?,
        @Parameter(description = "Filter results by the offer redeemable date") @Valid @RequestParam(value = "redeemableStartDate", required = false) redeemableStartDate: kotlin.Long?,
        @Parameter(description = "Filter results by the offer redeemable date") @Valid @RequestParam(value = "redeemableEndDate", required = false) redeemableEndDate: kotlin.Long?,
        @Parameter(description = "Apply params to offer's parent", schema = Schema(defaultValue = "false")) @Valid @RequestParam(value = "filterByParentOffer", required = false, defaultValue = "false") filterByParentOffer: kotlin.Boolean,
        @Parameter(description = "Filter results by the offer start date") @Valid @RequestParam(value = "startedSince", required = false) startedSince: kotlin.Long?,
        @Parameter(description = "Filter results by the offer start date") @Valid @RequestParam(value = "startedBefore", required = false) startedBefore: kotlin.Long?,
        @Parameter(description = "Filter results by the offer end date") @Valid @RequestParam(value = "endedSince", required = false) endedSince: kotlin.Long?,
        @Parameter(description = "Filter results by the offer end date") @Valid @RequestParam(value = "endedBefore", required = false) endedBefore: kotlin.Long?,
        @Parameter(description = "If true return redeemed transactions (status 2), otherwise return active transactions (status 0 or 1)", schema = Schema(defaultValue = "false")) @Valid @RequestParam(value = "redeemed", required = false, defaultValue = "false") redeemed: kotlin.Boolean,
        @Parameter(description = "Custom status value to change to (0 or 1 for redeem, 5 or 6 for membership)") @Valid @RequestParam(value = "statuses", required = false) statuses: kotlin.String?,
        @Parameter(description = "Returns only reservation transactions if true", schema = Schema(defaultValue = "false")) @Valid @RequestParam(value = "reservationsOnly", required = false, defaultValue = "false") reservationsOnly: kotlin.Boolean,
        @Parameter(description = "Active Only", schema = Schema(defaultValue = "false")) @Valid @RequestParam(value = "activeOnly", required = false, defaultValue = "false") activeOnly: kotlin.Boolean,
        @Parameter(description = "Determines whether to return a detailed version of the response", schema = Schema(defaultValue = "false")) @Valid @RequestParam(value = "returnFullResponse", required = false, defaultValue = "false") returnFullResponse: kotlin.Boolean,
        @Parameter(description = "Filter results by the recurring billing start date") @Valid @RequestParam(value = "recurringStartedSince", required = false) recurringStartedSince: kotlin.Long?,
        @Parameter(description = "Filter results by the recurring billing start date") @Valid @RequestParam(value = "recurringStartedBefore", required = false) recurringStartedBefore: kotlin.Long?,
        @Parameter(description = "Filter results by the recurring billing expiration date") @Valid @RequestParam(value = "recurringExpirationSince", required = false) recurringExpirationSince: kotlin.Long?,
        @Parameter(description = "Filter results by the recurring billing expiration date") @Valid @RequestParam(value = "recurringExpirationBefore", required = false) recurringExpirationBefore: kotlin.Long?
    ): ResponseEntity<List<OfferTransactionResponse>> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Search Offer Transactions",
        operationId = "searchOfferTransactionsForRetailers",
        description = """Searches on offer transactions for offers that the account has access to.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(array = ArraySchema(schema = Schema(implementation = OfferTransactionResponse::class)))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/retailer/offer/transaction/search"
        value = [PATH_SEARCH_OFFER_TRANSACTIONS_FOR_RETAILERS],
        produces = ["*/*"]
    )
    fun searchOfferTransactionsForRetailers(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "Determines what to sort the results by {CREATED, UPDATED, SEARCH_TAGS, ACTIVE, ACTIVATED, EXPIRES, TITLE, SUBTITLE, OFFER_TYPE, SPECIAL_OFFER_TYPE, OFFER_VISIBILITY, CUSTOMER_ID, CUSTOMER_DISPLAY, RETAILER_ID, RETAILER_NAME, RETAILER_LOCATION_ID, RETAILER_LOCATION_NAME, BILLABLE_ENTITY_ID, BILLABLE_ENTITY_NAME, RESPONSIBLE_DISPLAY}", required = true, schema = Schema(allowableValues = ["ID", "CREATED", "UPDATED", "DELETED", "SEARCH_TAGS", "ACTIVE", "ACTIVATED", "EXPIRES", "TITLE", "SUBTITLE", "DETAILS", "OFFER_TYPE", "SPECIAL_OFFER_TYPE", "OFFER_VISIBILITY", "REDEEMABLE_START", "REDEEMABLE_END", "CUSTOMER_ID", "CUSTOMER_DISPLAY", "RETAILER_ID", "RETAILER_NAME", "RETAILER_LOCATION_ID", "RETAILER_LOCATION_NAME", "BILLABLE_ENTITY_ID", "BILLABLE_ENTITY_NAME", "RESPONSIBLE_DISPLAY"])) @Valid @RequestParam(value = "sortField", required = true) sortField: kotlin.String,
        @NotNull @Parameter(description = "Determines whether the results are in descending order", required = true) @Valid @RequestParam(value = "descending", required = true) descending: kotlin.Boolean,
        @NotNull @Parameter(description = "The start index for pagination", required = true) @Valid @RequestParam(value = "start", required = true) start: kotlin.Int,
        @NotNull @Parameter(description = "The limit for pagination", required = true) @Valid @RequestParam(value = "limit", required = true) limit: kotlin.Int,
        @NotNull @Parameter(description = "Determines whether to only return active offer transactions", required = true) @Valid @RequestParam(value = "activeOnly", required = true) activeOnly: kotlin.Boolean,
        @Parameter(description = "The device id (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "The account id of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "This parameter is deprecated.") @Valid @RequestParam(value = "q", required = false) q: kotlin.String?,
        @Parameter(description = "The keyword to search for") @Valid @RequestParam(value = "keyword", required = false) keyword: kotlin.String?,
        @Parameter(description = "Filter results for this retailer") @Valid @RequestParam(value = "retailerId", required = false) retailerId: kotlin.Long?,
        @Parameter(description = "Filter results for this retailer location") @Valid @RequestParam(value = "retailerLocationId", required = false) retailerLocationId: kotlin.Long?,
        @Parameter(description = "Filter results for this offer") @Valid @RequestParam(value = "offerId", required = false) offerId: kotlin.Long?,
        @Parameter(description = "Filter results for this offer location") @Valid @RequestParam(value = "offerLocationId", required = false) offerLocationId: kotlin.Long?,
        @Parameter(description = "if true return redeemed transactions (status 2), if false return active transactions (status 0 or 1)") @Valid @RequestParam(value = "redeemed", required = false) redeemed: kotlin.Boolean?,
        @Parameter(description = "returns only reservation transactions if true") @Valid @RequestParam(value = "reservationsOnly", required = false) reservationsOnly: kotlin.Boolean?,
        @Parameter(description = "This parameter is deprecated.", schema = Schema(allowableValues = ["VOUCHER", "COUPON", "PRODUCT", "MEDIA", "EVENT", "DEVICE"])) @Valid @RequestParam(value = "couponType", required = false) couponType: kotlin.String?,
        @Parameter(description = "Filter results to only return COUPON, VOUCHER, PRODUCT, MEDIA, or EVENT offers", schema = Schema(allowableValues = ["VOUCHER", "COUPON", "PRODUCT", "MEDIA", "EVENT", "DEVICE"])) @Valid @RequestParam(value = "offerType", required = false) offerType: kotlin.String?,
        @Parameter(description = "Filter results to only return REGULAR_OFFER, ACT_NOW, GET_THERE_NOW offer specials", schema = Schema(allowableValues = ["ALL", "RESERVABLE", "REGULAR_OFFER", "ACT_NOW", "GET_THERE_NOW", "SQOOT", "TICKETS", "YIPIT"])) @Valid @RequestParam(value = "specialOfferType", required = false) specialOfferType: kotlin.String?,
        @Parameter(description = "Filter results by accounts") @Valid @RequestParam(value = "customerAccountIds", required = false) customerAccountIds: kotlin.String?,
        @Parameter(description = "") @Valid @RequestParam(value = "categoryIds", required = false) categoryIds: kotlin.String?,
        @Parameter(description = "") @Valid @RequestParam(value = "redeemableStartDate", required = false) redeemableStartDate: kotlin.Long?,
        @Parameter(description = "") @Valid @RequestParam(value = "redeemableEndDate", required = false) redeemableEndDate: kotlin.Long?,
        @Parameter(description = "This parameter is deprecated.") @Valid @RequestParam(value = "_i", required = false) i: kotlin.Int?,
        @Parameter(description = "This parameter is deprecated.") @Valid @RequestParam(value = "_l", required = false) l: kotlin.Int?
    ): ResponseEntity<List<OfferTransactionResponse>> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Search Offers",
        operationId = "searchOffersForConsumer",
        description = """Searches for offers as a consumer.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = OfferListResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/offer/lists"
        value = [PATH_SEARCH_OFFERS_FOR_CONSUMER],
        produces = ["*/*"]
    )
    fun searchOffersForConsumer(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The latitude of where the search will center at", required = true) @Valid @RequestParam(value = "latitude", required = true) latitude: kotlin.Double,
        @NotNull @Parameter(description = "The longitude of where the search will center at", required = true) @Valid @RequestParam(value = "longitude", required = true) longitude: kotlin.Double,
        @NotNull @Parameter(description = "The method to use to gather recommendations: WALLET base relevance on items in users wallets CLICKS base relevance on items users have clicked on BLENDED blend using all methods available", required = true, schema = Schema(allowableValues = ["WALLET", "CLICKS", "BLENDED"])) @Valid @RequestParam(value = "recommendationType", required = true) recommendationType: kotlin.String,
        @NotNull @Parameter(description = "This parameter is deprecated. The location id", required = true) @Valid @RequestParam(value = "locationId", required = true) locationId: kotlin.Long,
        @NotNull @Parameter(description = "The start index for pagination", required = true) @Valid @RequestParam(value = "start", required = true) start: kotlin.Int,
        @NotNull @Parameter(description = "The limit for pagination", required = true) @Valid @RequestParam(value = "limit", required = true) limit: kotlin.Int,
        @NotNull @Parameter(description = "", required = true) @Valid @RequestParam(value = "maxRecommendations", required = true) maxRecommendations: kotlin.Int,
        @NotNull @Parameter(description = "", required = true, schema = Schema(allowableValues = ["MILES", "KILOMETERS"])) @Valid @RequestParam(value = "distanceUnit", required = true) distanceUnit: kotlin.String,
        @Parameter(description = "The application key used to identify the application") @Valid @RequestParam(value = "appKey", required = false) appKey: kotlin.String?,
        @Parameter(description = "The device id for returning account information (i.e. offer transactions made by the user)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "The account id for returning account information (i.e. offer transactions made by the user)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "The range of the search", schema = Schema(defaultValue = "5.0")) @Valid @RequestParam(value = "searchRange", required = false, defaultValue = "5.0") searchRange: kotlin.Double,
        @Parameter(description = "Does a full-text search on tags") @Valid @RequestParam(value = "tags", required = false) tags: kotlin.String?,
        @Parameter(description = "supported postal codes") @Valid @RequestParam(value = "supportedPostalCodes", required = false) supportedPostalCodes: kotlin.String?,
        @Parameter(description = "The keyword to filter results by") @Valid @RequestParam(value = "keyword", required = false) keyword: kotlin.String?,
        @Parameter(description = "Comma separate list of category ids") @Valid @RequestParam(value = "categories", required = false) categories: kotlin.String?,
        @Parameter(description = "Comma separated list of filter ids") @Valid @RequestParam(value = "filters", required = false) filters: kotlin.String?,
        @Parameter(description = "Comma separated list of offer types {COUPON, VOUCHER, PRODUCT, MEDIA, EVENT, DEVICE}", schema = Schema(defaultValue = "COUPON, VOUCHER")) @Valid @RequestParam(value = "offerTypes", required = false, defaultValue = "COUPON, VOUCHER") offerTypes: kotlin.String,
        @Parameter(description = "The special offer type {ALL, RESERVABLE, REGULAR_OFFER, ACT_NOW, GET_THERE_NOW}") @Valid @RequestParam(value = "type", required = false) type: kotlin.String?,
        @Parameter(description = "The field to sort the result set on:DISTANCE Sort the offers nearest to farthest BUSINESS_NAME Sort the offers alphabetically by location name SHUFFLE Sort the nearest offers randomly USERPREFS accountId must accompany this parameter. Gives the first X recommendations where X equals the parameter maxRecommendations") @Valid @RequestParam(value = "sortField", required = false) sortField: kotlin.String?,
        @Parameter(description = "Return recommendations based on these offers IDs") @Valid @RequestParam(value = "recommendOfferIds", required = false) recommendOfferIds: kotlin.String?,
        @Parameter(description = "Only return offer locations for the specific retailer locations.") @Valid @RequestParam(value = "retailerLocationIds", required = false) retailerLocationIds: kotlin.String?,
        @Parameter(description = "Only return offer locations for the specific offer.") @Valid @RequestParam(value = "offerId", required = false) offerId: kotlin.Long?,
        @Parameter(description = "If true include the mission response as part of the offer. Default is false.") @Valid @RequestParam(value = "includeMission", required = false) includeMission: kotlin.Boolean?,
        @Parameter(description = "If true include the category list response as part of the offer. Default is false.") @Valid @RequestParam(value = "includeCategories", required = false) includeCategories: kotlin.Boolean?,
        @Parameter(description = "If true include the filter list response as part of the offer. Default is false.") @Valid @RequestParam(value = "includeFilters", required = false) includeFilters: kotlin.Boolean?,
        @Parameter(description = "If true then ignore the expired dates. Default is false.") @Valid @RequestParam(value = "includeExpired", required = false) includeExpired: kotlin.Boolean?,
        @Parameter(description = "If true then ignore the favorite. Default is false.") @Valid @RequestParam(value = "includeFavorite", required = false) includeFavorite: kotlin.Boolean?,
        @Parameter(description = "This parameter is deprecated. see groupBy. If true then it only returns the offer location for an offer closest to the given lat/lon") @Valid @RequestParam(value = "closestOfferOnly", required = false) closestOfferOnly: kotlin.Boolean?,
        @Parameter(description = "") @Valid @RequestParam(value = "searchExpression", required = false) searchExpression: kotlin.String?,
        @Parameter(description = "groups the results by a certain field. For example, if you want to return the closest offer location of an offer, then pass in groupBy=OFFER_ID and sortField=DISTANCE (to sort by distance).", schema = Schema(allowableValues = ["ID", "CREATED", "UPDATED", "DELETED", "SEARCH_TAGS", "ACTIVE", "OFFER_ID", "ACTIVATED", "EXPIRES", "TITLE", "SUBTITLE", "DETAILS", "OFFER_TYPE", "SPECIAL_OFFER_TYPE", "OFFER_VISIBILITY", "RETAILER_ID", "RETAILER_LOCATION_ID", "BILLABLE_ENTITY_ID", "BILLABLE_ENTITY_NAME", "RESPONSIBLE_DISPLAY"])) @Valid @RequestParam(value = "groupBy", required = false) groupBy: kotlin.String?
    ): ResponseEntity<OfferListResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Search Orders",
        operationId = "searchOrders",
        description = """Search on active orders by customer""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(array = ArraySchema(schema = Schema(implementation = OrderResponse::class)))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/order/search"
        value = [PATH_SEARCH_ORDERS],
        produces = ["*/*"]
    )
    fun searchOrders(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The application requesting the purchase", required = true) @Valid @RequestParam(value = "appKey", required = true) appKey: kotlin.String,
        @Parameter(description = "The device id (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "The account id of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "The start index for pagination", schema = Schema(defaultValue = "0")) @Valid @RequestParam(value = "start", required = false, defaultValue = "0") start: kotlin.Int,
        @Parameter(description = "The limit for pagination", schema = Schema(defaultValue = "20")) @Valid @RequestParam(value = "limit", required = false, defaultValue = "20") limit: kotlin.Int,
        @Parameter(description = "Determines whether to return the resulting list in descending or ascending order", schema = Schema(defaultValue = "true")) @Valid @RequestParam(value = "descending", required = false, defaultValue = "true") descending: kotlin.Boolean,
        @Parameter(description = "Only return active orders", schema = Schema(defaultValue = "false")) @Valid @RequestParam(value = "activeOnly", required = false, defaultValue = "false") activeOnly: kotlin.Boolean,
        @Parameter(description = "Determines whether to ignore the customer filter (requires an Admin/Exec account)", schema = Schema(defaultValue = "false")) @Valid @RequestParam(value = "ignoreCustomerFilter", required = false, defaultValue = "false") ignoreCustomerFilter: kotlin.Boolean,
        @Parameter(description = "Filter results by orderItemTypes") @Valid @RequestParam(value = "orderItemTypes", required = false) orderItemTypes: kotlin.String?,
        @Parameter(description = "Filter results by orderItemIds") @Valid @RequestParam(value = "orderItemIds", required = false) orderItemIds: kotlin.String?,
        @Parameter(description = "Filter results by orderCustomTypes") @Valid @RequestParam(value = "orderCustomTypes", required = false) orderCustomTypes: kotlin.String?,
        @Parameter(description = "Filter results by orderCustomIds") @Valid @RequestParam(value = "orderCustomIds", required = false) orderCustomIds: kotlin.String?,
        @Parameter(description = "Determines what to sort the results by", schema = Schema(defaultValue = "ID")) @Valid @RequestParam(value = "sortField", required = false, defaultValue = "ID") sortField: kotlin.String,
        @Parameter(description = "Filter results by offer type") @Valid @RequestParam(value = "offerTypes", required = false) offerTypes: kotlin.String?,
        @Parameter(description = "Filter results by special offer type") @Valid @RequestParam(value = "specialOfferTypes", required = false) specialOfferTypes: kotlin.String?,
        @Parameter(description = "Filter results by category Ids") @Valid @RequestParam(value = "categoryIds", required = false) categoryIds: kotlin.String?,
        @Parameter(description = "Filter results by filter Ids") @Valid @RequestParam(value = "filterIds", required = false) filterIds: kotlin.String?,
        @Parameter(description = "Filter results by offer audience Ids") @Valid @RequestParam(value = "offerAudienceIds", required = false) offerAudienceIds: kotlin.String?,
        @Parameter(description = "Filter results by transaction audience Ids") @Valid @RequestParam(value = "transactionAudienceIds", required = false) transactionAudienceIds: kotlin.String?,
        @Parameter(description = "Filter results by offer Ids") @Valid @RequestParam(value = "offerIds", required = false) offerIds: kotlin.String?,
        @Parameter(description = "Filter results by offer location Ids") @Valid @RequestParam(value = "offerLocationIds", required = false) offerLocationIds: kotlin.String?,
        @Parameter(description = "Filter results by retailer Ids") @Valid @RequestParam(value = "retailerIds", required = false) retailerIds: kotlin.String?,
        @Parameter(description = "Filter results by retailer location Ids") @Valid @RequestParam(value = "retailerLocationIds", required = false) retailerLocationIds: kotlin.String?,
        @Parameter(description = "Filter results by offer transaction status (0: non-redeemable, 1: redeemable, 2: redeemed, 3: user deleted, 4: unclaimed/rewarded, 5: membership active, 6: membership cancelled)") @Valid @RequestParam(value = "statuses", required = false) statuses: kotlin.String?,
        @Parameter(description = "The keyword to search for") @Valid @RequestParam(value = "keyword", required = false) keyword: kotlin.String?,
        @Parameter(description = "Filter results by the offer redeemable date") @Valid @RequestParam(value = "redeemableStartDate", required = false) redeemableStartDate: kotlin.Long?,
        @Parameter(description = "Filter results by the offer redeemable date") @Valid @RequestParam(value = "redeemableEndDate", required = false) redeemableEndDate: kotlin.Long?,
        @Parameter(description = "Filter results by the offer start date") @Valid @RequestParam(value = "startedSince", required = false) startedSince: kotlin.Long?,
        @Parameter(description = "Filter results by the offer start date") @Valid @RequestParam(value = "startedBefore", required = false) startedBefore: kotlin.Long?,
        @Parameter(description = "Filter results by the offer end date") @Valid @RequestParam(value = "endedSince", required = false) endedSince: kotlin.Long?,
        @Parameter(description = "Filter results by the offer end date") @Valid @RequestParam(value = "endedBefore", required = false) endedBefore: kotlin.Long?
    ): ResponseEntity<List<OrderResponse>> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Search Packs",
        operationId = "searchPacks",
        description = """Search on packs.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(array = ArraySchema(schema = Schema(implementation = PackResponse::class)))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/pack/search"
        value = [PATH_SEARCH_PACKS],
        produces = ["*/*"]
    )
    fun searchPacks(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The logged in user.", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "The field to sort by. Possible values include: TITLE, DESCRIPTION, CREATED, UPDATED", required = true, schema = Schema(allowableValues = ["TITLE", "DESCRIPTION", "CREATED", "UPDATED"])) @Valid @RequestParam(value = "sortField", required = true) sortField: kotlin.String,
        @NotNull @Parameter(description = "Determines whether the sorted list is in descending or ascending order", required = true) @Valid @RequestParam(value = "descending", required = true) descending: kotlin.Boolean,
        @Parameter(description = "Keyword search on the pack name") @Valid @RequestParam(value = "keyword", required = false) keyword: kotlin.String?,
        @Parameter(description = "Filters results on pack type", schema = Schema(allowableValues = ["TUTORIAL", "BUILTIN", "DOWNLOAD", "THRESHOLD", "THEME", "TOURNAMENT"])) @Valid @RequestParam(value = "packType", required = false) packType: kotlin.String?,
        @Parameter(description = "Start the result set at some index.") @Valid @RequestParam(value = "start", required = false) start: kotlin.Int?,
        @Parameter(description = "Limit the result to some number.") @Valid @RequestParam(value = "limit", required = false) limit: kotlin.Int?,
        @Parameter(description = "Determines whether to include game data in the results") @Valid @RequestParam(value = "includeGameData", required = false) includeGameData: kotlin.Boolean?,
        @Parameter(description = "Determines whether to include inactive results") @Valid @RequestParam(value = "includeInactive", required = false) includeInactive: kotlin.Boolean?,
        @Parameter(description = "The application to filter results on") @Valid @RequestParam(value = "appKey", required = false) appKey: kotlin.String?
    ): ResponseEntity<List<PackResponse>> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Search Payment Methods",
        operationId = "searchPaymentMethod",
        description = """Search the payment methods of an account""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = PaymentTypesResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/billing/search"
        value = [PATH_SEARCH_PAYMENT_METHOD],
        produces = ["*/*"]
    )
    fun searchPaymentMethod(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "Account Id to search on", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @Parameter(description = "Provider to search on", schema = Schema(defaultValue = "AUTHORIZE_NET")) @Valid @RequestParam(value = "provider", required = false, defaultValue = "AUTHORIZE_NET") provider: kotlin.String,
        @Parameter(description = "the type to search on") @Valid @RequestParam(value = "type", required = false) type: kotlin.String?,
        @Parameter(description = "the keyword to search on") @Valid @RequestParam(value = "keyword", required = false) keyword: kotlin.String?,
        @Parameter(description = "the sort field to use for the search", schema = Schema(defaultValue = "UPDATED")) @Valid @RequestParam(value = "sortField", required = false, defaultValue = "UPDATED") sortField: kotlin.String,
        @Parameter(description = "if the results should be in descending order", schema = Schema(defaultValue = "true")) @Valid @RequestParam(value = "descending", required = false, defaultValue = "true") descending: kotlin.Boolean,
        @Parameter(description = "the start of the search", schema = Schema(defaultValue = "0")) @Valid @RequestParam(value = "start", required = false, defaultValue = "0") start: kotlin.Int,
        @Parameter(description = "the limit of the search", schema = Schema(defaultValue = "5")) @Valid @RequestParam(value = "limit", required = false, defaultValue = "5") limit: kotlin.Int
    ): ResponseEntity<PaymentTypesResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Search Permissionables",
        operationId = "searchPermissionables",
        description = """Search on UserPermissions""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(array = ArraySchema(schema = Schema(implementation = UserPermissionsResponse::class)))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/permissions/search"
        value = [PATH_SEARCH_PERMISSIONABLES],
        produces = ["*/*"]
    )
    fun searchPermissionables(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "A unique ID given by the device (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "The account ID of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "Filter results for a specific user account") @Valid @RequestParam(value = "connectionAccountId", required = false) connectionAccountId: kotlin.Long?,
        @Parameter(description = "Comma separated list of account IDs to filter results with") @Valid @RequestParam(value = "connectionAccountIds", required = false) connectionAccountIds: kotlin.String?,
        @Parameter(description = "Filter user permissions by the permissionable object type", schema = Schema(allowableValues = ["ACCOUNT", "GAMELEVEL", "ALBUM_CONTEST", "THEME_DESCRIPTOR", "SCHEDULED_NOTIFICATION", "TASK", "TRIGGER"])) @Valid @RequestParam(value = "permissionableType", required = false) permissionableType: kotlin.String?,
        @Parameter(description = "The id of the permissionable object to filter by") @Valid @RequestParam(value = "permissionableId", required = false) permissionableId: kotlin.Long?,
        @Parameter(description = "Keyword to search within permissionable records") @Valid @RequestParam(value = "keyword", required = false) keyword: kotlin.String?,
        @Parameter(description = "Field to sort results on") @Valid @RequestParam(value = "sortField", required = false) sortField: kotlin.String?,
        @Parameter(description = "Sort descending when true") @Valid @RequestParam(value = "descending", required = false) descending: kotlin.Boolean?,
        @Parameter(description = "Return user permissions that are pending") @Valid @RequestParam(value = "pending", required = false) pending: kotlin.Boolean?,
        @Parameter(description = "Return user permissions that are admins") @Valid @RequestParam(value = "admin", required = false) admin: kotlin.Boolean?,
        @Parameter(description = "the start index for pagination", schema = Schema(defaultValue = "0")) @Valid @RequestParam(value = "start", required = false, defaultValue = "0") start: kotlin.Int,
        @Parameter(description = "the limit for pagination", schema = Schema(defaultValue = "20")) @Valid @RequestParam(value = "limit", required = false, defaultValue = "20") limit: kotlin.Int
    ): ResponseEntity<List<UserPermissionsResponse>> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Search Permissionables by Distnace",
        operationId = "searchPermissionablesFollowingDistance",
        description = """Search on UserPermissions by distance""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(array = ArraySchema(schema = Schema(implementation = UserPermissionsResponse::class)))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/permissions/distancesearch"
        value = [PATH_SEARCH_PERMISSIONABLES_FOLLOWING_DISTANCE],
        produces = ["*/*"]
    )
    fun searchPermissionablesFollowingDistance(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The latitude of the current account", required = true) @Valid @RequestParam(value = "latitude", required = true) latitude: kotlin.Double,
        @NotNull @Parameter(description = "The longitude of the current account", required = true) @Valid @RequestParam(value = "longitude", required = true) longitude: kotlin.Double,
        @Parameter(description = "A unique ID given by the device (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "The account ID of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "Filter results for a specific user account") @Valid @RequestParam(value = "connectionAccountId", required = false) connectionAccountId: kotlin.Long?,
        @Parameter(description = "Comma separated list of account IDs to filter results with") @Valid @RequestParam(value = "connectionAccountIds", required = false) connectionAccountIds: kotlin.String?,
        @Parameter(description = "Filter user permissions by the permissionable object type", schema = Schema(allowableValues = ["ACCOUNT", "GAMELEVEL", "ALBUM_CONTEST", "THEME_DESCRIPTOR", "SCHEDULED_NOTIFICATION", "TASK", "TRIGGER"])) @Valid @RequestParam(value = "permissionableType", required = false) permissionableType: kotlin.String?,
        @Parameter(description = "The id of the permissionable object to filter by") @Valid @RequestParam(value = "permissionableId", required = false) permissionableId: kotlin.Long?,
        @Parameter(description = "The search range in miles", schema = Schema(defaultValue = "5.0")) @Valid @RequestParam(value = "searchRange", required = false, defaultValue = "5.0") searchRange: kotlin.Double,
        @Parameter(description = "Keyword to search within permissionable records") @Valid @RequestParam(value = "keyword", required = false) keyword: kotlin.String?,
        @Parameter(description = "Return user permissions that are pending") @Valid @RequestParam(value = "pending", required = false) pending: kotlin.Boolean?,
        @Parameter(description = "Return user permissions that are admins") @Valid @RequestParam(value = "admin", required = false) admin: kotlin.Boolean?,
        @Parameter(description = "The start index for pagination", schema = Schema(defaultValue = "0")) @Valid @RequestParam(value = "start", required = false, defaultValue = "0") start: kotlin.Int,
        @Parameter(description = "The limit for pagination", schema = Schema(defaultValue = "20")) @Valid @RequestParam(value = "limit", required = false, defaultValue = "20") limit: kotlin.Int
    ): ResponseEntity<List<UserPermissionsResponse>> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Search Personas",
        operationId = "searchPersona",
        description = """Search for persona that the account owns by the given account ID.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = PreviewPersonaResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/persona/search"
        value = [PATH_SEARCH_PERSONA],
        produces = ["*/*"]
    )
    fun searchPersona(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the account ID of the user", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "the start index for pagination", required = true) @Valid @RequestParam(value = "start", required = true) start: kotlin.Int,
        @NotNull @Parameter(description = "the limit for pagination (There is a hard limit of 100)", required = true) @Valid @RequestParam(value = "limit", required = true) limit: kotlin.Int
    ): ResponseEntity<PreviewPersonaResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Search Programs",
        operationId = "searchPrograms",
        description = """Search for programs""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(array = ArraySchema(schema = Schema(implementation = Program::class)))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/program"
        value = [PATH_SEARCH_PROGRAMS],
        produces = ["*/*"]
    )
    fun searchPrograms(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The field to sort by", required = true) @Valid @RequestParam(value = "sortField", required = true) sortField: kotlin.String,
        @NotNull @Parameter(description = "Determines whether the sorted list is in descending or ascending order", required = true) @Valid @RequestParam(value = "descending", required = true) descending: kotlin.Boolean,
        @NotNull @Parameter(description = "The start index for pagination", required = true) @Valid @RequestParam(value = "start", required = true) start: kotlin.Int,
        @NotNull @Parameter(description = "The limit for pagination", required = true) @Valid @RequestParam(value = "limit", required = true) limit: kotlin.Int,
        @NotNull @Parameter(description = "Return only active results", required = true) @Valid @RequestParam(value = "activeOnly", required = true) activeOnly: kotlin.Boolean,
        @Parameter(description = "The keyword to filter results by") @Valid @RequestParam(value = "keyword", required = false) keyword: kotlin.String?
    ): ResponseEntity<List<Program>> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Search Purchases",
        operationId = "searchPurchaseItems",
        description = """Search for purchasable items from the system""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(array = ArraySchema(schema = Schema(implementation = PurchaseItemResponse::class)))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/purchase/search"
        value = [PATH_SEARCH_PURCHASE_ITEMS],
        produces = ["*/*"]
    )
    fun searchPurchaseItems(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "The device id (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "The account id of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "The application key to filter results by application") @Valid @RequestParam(value = "appKey", required = false) appKey: kotlin.String?,
        @Parameter(description = "Determines whether to filter results by the user's billable entity", schema = Schema(defaultValue = "false")) @Valid @RequestParam(value = "filterByBillable", required = false, defaultValue = "false") filterByBillable: kotlin.Boolean,
        @Parameter(description = "A comma separated list of purchase providers to filter by. Possible values include: <ul> <li>SIRQUL - purchases from the Sirqul store using tickets</li> <li>IOS - purchases from the iTunes store for iPhone, iPod, iPod Touch</li> <li>GOOGLE - purchases from the Google Play store</li> <li>AMAZON - purchases from the Amazon Android store</li> <li>MAC - purchases from the iTunes store for OSX</li> <li>WP8 - purchases from the Windows Phone 8 store</li> <li>FREE - purchases that are free (can be used for development/testing purposes)</li> </ul>") @Valid @RequestParam(value = "purchaseType", required = false) purchaseType: kotlin.String?,
        @Parameter(description = "A comma separated list of service actions to filter results by. Possible values include: <ul> <li>DAY_PREMIUM - purchases that subscribes a user for a day of membership</li> <li>WEEK_PREMIUM - purchases that subscribes a user for a week of membership</li> <li>MONTH_PREMIUM - purchases that subscribes a user for a month of membership</li> <li>ADD_TICKET - purchases that allow users to add more tickets</li> <li>ADD_GIFT - purchases that allow users to recieve gifts</li> </ul>") @Valid @RequestParam(value = "serviceAction", required = false) serviceAction: kotlin.String?,
        @Parameter(description = "The keyword used to search") @Valid @RequestParam(value = "keyword", required = false) keyword: kotlin.String?,
        @Parameter(description = "The column to sort the search on. Possible values include: ID, CREATED, UPDATED, ACTIVE, ACTIVATED, EXPIRES, TITLE, SUBTITLE, DETAILS, OFFER_TYPE, SPECIAL_OFFER_TYPE, OFFER_VISIBILITY, ESTIMATED_VALUE, VOUCHER_PRICE, RETAILER_ID, RETAILER_NAME, RETAILER_LOCATION_ID, RETAILER_LOCATION_NAME, BILLABLE_ENTITY_ID, BILLABLE_ENTITY_NAME, RESPONSIBLE_DISPLAY", schema = Schema(allowableValues = ["ID", "CREATED", "UPDATED", "DELETED", "SEARCH_TAGS", "ACTIVE", "NAME", "DESCRIPTION", "TICKETS", "PRICE", "PURCHASE_TYPE", "PURCHASE_CODE", "PURCHASE_LIMIT", "SERIVCE_ACTION", "GIFTABLE", "ASSETABLE", "APPLICATION_ID", "APPLICATION_NAME"], defaultValue = "NAME")) @Valid @RequestParam(value = "sortField", required = false, defaultValue = "NAME") sortField: kotlin.String,
        @Parameter(description = "The order to return the search results", schema = Schema(defaultValue = "false")) @Valid @RequestParam(value = "descending", required = false, defaultValue = "false") descending: kotlin.Boolean,
        @Parameter(description = "The record to begin the return set on", schema = Schema(defaultValue = "0")) @Valid @RequestParam(value = "start", required = false, defaultValue = "0") start: kotlin.Int,
        @Parameter(description = "The number of records to return", schema = Schema(defaultValue = "20")) @Valid @RequestParam(value = "limit", required = false, defaultValue = "20") limit: kotlin.Int,
        @Parameter(description = "Return only active results", schema = Schema(defaultValue = "false")) @Valid @RequestParam(value = "activeOnly", required = false, defaultValue = "false") activeOnly: kotlin.Boolean
    ): ResponseEntity<List<PurchaseItemResponse>> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Search Questions",
        operationId = "searchQuestions",
        description = """Search for questions by the given params.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(array = ArraySchema(schema = Schema(implementation = QuestionResponse::class)))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/game/question/search"
        value = [PATH_SEARCH_QUESTIONS],
        produces = ["*/*"]
    )
    fun searchQuestions(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The logged in user.", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "The column to sort the search on", required = true) @Valid @RequestParam(value = "sortField", required = true) sortField: kotlin.String,
        @NotNull @Parameter(description = "The order to return the search results", required = true) @Valid @RequestParam(value = "descending", required = true) descending: kotlin.Boolean,
        @NotNull @Parameter(description = "Return only active results if set to true.", required = true) @Valid @RequestParam(value = "activeOnly", required = true) activeOnly: kotlin.Boolean,
        @NotNull @Parameter(description = "The record to begin the return set on.", required = true) @Valid @RequestParam(value = "start", required = true) start: kotlin.Int,
        @NotNull @Parameter(description = "The number of records to return.", required = true) @Valid @RequestParam(value = "limit", required = true) limit: kotlin.Int,
        @Parameter(description = "The keyword for searching questions with matching tags or question text.") @Valid @RequestParam(value = "keyword", required = false) keyword: kotlin.String?
    ): ResponseEntity<List<QuestionResponse>> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Search Rating Indexes",
        operationId = "searchRatingIndexes",
        description = """Search for ratable items by averages.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(array = ArraySchema(schema = Schema(implementation = RatingIndexResponse::class)))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/rating/index/search"
        value = [PATH_SEARCH_RATING_INDEXES],
        produces = ["*/*"]
    )
    fun searchRatingIndexes(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "Filter results by a ratable type {RETAILER_LOCATION}", required = true, schema = Schema(allowableValues = ["LOCATABLE", "RESERVABLE", "PERMISSIONABLE", "NOTABLE", "ASSETABLE", "LIKABLE", "FLAGABLE", "FAVORITABLE", "RATABLE", "ALBUM", "COLLECTION", "APPLICATION", "APPLICATION_SETTING", "APPLICATION_CERT", "APPLICATION_PLACEMENT", "ACCOUNT", "ACCOUNT_SETTING", "GAME_LEVEL", "PACK", "MISSION", "TOURNAMENT", "ASSET", "ALBUM_CONTEST", "THEME_DESCRIPTOR", "OFFER", "OFFER_LOCATION", "EVENT", "RETAILER", "RETAILER_LOCATION", "NOTE", "CREATIVE", "FAVORITE", "LIKE", "RATING", "ANALYTIC", "THIRD_PARTY_CREDENTIAL", "THIRD_PARTY_NETWORK", "REGION"])) @Valid @RequestParam(value = "ratableType", required = true) ratableType: kotlin.String,
        @Parameter(description = "Comma separated list of ratable ids to filter the resuts by") @Valid @RequestParam(value = "ratableIds", required = false) ratableIds: kotlin.String?,
        @Parameter(description = "Comma separated list of category ids to filter the results by") @Valid @RequestParam(value = "categoryIds", required = false) categoryIds: kotlin.String?,
        @Parameter(description = "") @Valid @RequestParam(value = "secondaryType", required = false) secondaryType: kotlin.String?,
        @Parameter(description = "The keyword used to search") @Valid @RequestParam(value = "keyword", required = false) keyword: kotlin.String?,
        @Parameter(description = "The column to sort the search on {ID, CREATED, UPDATED, ACTIVE, RATABLE_TYPE, RATABLE_ID, RATABLE_DISPLAY, CATEGORY_ID, CATEGORY_NAME, CATEGORY_SHORT_NAME, CATEGORY_DISPLAY, COUNT, SUMMATION, AVERAGE, VALUE}", schema = Schema(allowableValues = ["ID", "CREATED", "UPDATED", "DELETED", "SEARCH_TAGS", "ACTIVE", "RATABLE_TYPE", "RATABLE_ID", "RATABLE_DISPLAY", "CATEGORY_ID", "CATEGORY_NAME", "CATEGORY_SHORT_NAME", "CATEGORY_DISPLAY", "COUNT", "SUMMATION", "AVERAGE", "VALUE"])) @Valid @RequestParam(value = "sortField", required = false) sortField: kotlin.String?,
        @Parameter(description = "The order to return the search results") @Valid @RequestParam(value = "descending", required = false) descending: kotlin.Boolean?,
        @Parameter(description = "The record to begin the return set on") @Valid @RequestParam(value = "start", required = false) start: kotlin.Int?,
        @Parameter(description = "The number of records to return") @Valid @RequestParam(value = "limit", required = false) limit: kotlin.Int?,
        @Parameter(description = "") @Valid @RequestParam(value = "latitude", required = false) latitude: kotlin.Double?,
        @Parameter(description = "") @Valid @RequestParam(value = "longitude", required = false) longitude: kotlin.Double?,
        @Parameter(description = "Determines whether to return the ratable object in the response") @Valid @RequestParam(value = "returnRatable", required = false) returnRatable: kotlin.Boolean?,
        @Parameter(description = "Determines whether to return the overall rating record instead") @Valid @RequestParam(value = "returnOverallRating", required = false) returnOverallRating: kotlin.Boolean?
    ): ResponseEntity<List<RatingIndexResponse>> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Search Ratings",
        operationId = "searchRatings",
        description = """Search for ratings on a ratable object.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(array = ArraySchema(schema = Schema(implementation = RatingResponse::class)))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/rating/search"
        value = [PATH_SEARCH_RATINGS],
        produces = ["*/*"]
    )
    fun searchRatings(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "The device id (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "The account id of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "Filter results for a particular account") @Valid @RequestParam(value = "filterAccountId", required = false) filterAccountId: kotlin.Long?,
        @Parameter(description = "The ratable object type {RETAILER_LOCATION}") @Valid @RequestParam(value = "ratableType", required = false) ratableType: kotlin.String?,
        @Parameter(description = "The id of the ratable object") @Valid @RequestParam(value = "ratableId", required = false) ratableId: kotlin.Long?,
        @Parameter(description = "Comma separated list of category ids to filter the results by") @Valid @RequestParam(value = "categoryIds", required = false) categoryIds: kotlin.String?,
        @Parameter(description = "The keyword used to search") @Valid @RequestParam(value = "keyword", required = false) keyword: kotlin.String?,
        @Parameter(description = "The column to sort the search on {ID, CREATED, UPDATED, ACTIVE, OWNER_DISPLAY, RATABLE_TYPE, RATABLE_ID, RATABLE_DISPLAY, CATEGORY_ID, CATEGORY_NAME, CATEGORY_SHORT_NAME, CATEGORY_DISPLAY, VALUE}", schema = Schema(allowableValues = ["ID", "CREATED", "UPDATED", "DELETED", "SEARCH_TAGS", "ACTIVE", "OWNER_DISPLAY", "RATABLE_TYPE", "RATABLE_ID", "RATABLE_DISPLAY", "CATEGORY_ID", "CATEGORY_NAME", "CATEGORY_SHORT_NAME", "CATEGORY_DISPLAY", "VALUE"])) @Valid @RequestParam(value = "sortField", required = false) sortField: kotlin.String?,
        @Parameter(description = "The order to return the search results") @Valid @RequestParam(value = "descending", required = false) descending: kotlin.Boolean?,
        @Parameter(description = "The record to begin the return set on") @Valid @RequestParam(value = "start", required = false) start: kotlin.Int?,
        @Parameter(description = "The number of records to return") @Valid @RequestParam(value = "limit", required = false) limit: kotlin.Int?
    ): ResponseEntity<List<RatingResponse>> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Search for Recipients",
        operationId = "searchRecipients",
        description = """Search for application users to send notifications.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(array = ArraySchema(schema = Schema(implementation = NotificationRecipientResponse::class)))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/notification/recipient/search"
        value = [PATH_SEARCH_RECIPIENTS],
        produces = ["*/*"]
    )
    fun searchRecipients(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The field to sort by. Possible values include: {ACCOUNT_DISPLAY, CREATED, UPDATED, ACTIVE, DELETED, LAST_LOGGED_IN, CONTACT_EMAIL, RETAILER_LOCATION_NAME, RETAILER_NAME, APPLICATION_NAME}", required = true, schema = Schema(allowableValues = ["ID", "HAS_SMS", "HAS_EMAIL", "HAS_APNS", "HAS_GCM", "APPLICATION_ID", "APPLICATION_NAME", "ACCOUNT_ID", "ACCOUNT_USERNAME", "ACCOUNT_DISPLAY", "ACCOUNT_TYPE"])) @Valid @RequestParam(value = "sortField", required = true) sortField: kotlin.String,
        @Parameter(description = "the unique id of the device making the request (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "the account id of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "filters results by application. If this is empty, will return all recipients for all applications that the user has access to.") @Valid @RequestParam(value = "appKey", required = false) appKey: kotlin.String?,
        @Parameter(description = "the type of notification to send: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION.") @Valid @RequestParam(value = "conduit", required = false) conduit: kotlin.String?,
        @Parameter(description = "search by keyword on user's display name and email") @Valid @RequestParam(value = "keyword", required = false) keyword: kotlin.String?,
        @Parameter(description = "This parameter is deprecated. filter results by audience") @Valid @RequestParam(value = "audienceId", required = false) audienceId: kotlin.Long?,
        @Parameter(description = "filter results by audiences (comma separated list of audience ids)") @Valid @RequestParam(value = "audienceIds", required = false) audienceIds: kotlin.String?,
        @Parameter(description = "filter results by connection groups (comma separated list of connection group ids)") @Valid @RequestParam(value = "connectionGroupIds", required = false) connectionGroupIds: kotlin.String?,
        @Parameter(description = "filter results by accounts (comma separated list of account ids)") @Valid @RequestParam(value = "recipientAccountIds", required = false) recipientAccountIds: kotlin.String?,
        @Parameter(description = "Determines whether the sorted list is in descending or ascending order") @Valid @RequestParam(value = "descending", required = false) descending: kotlin.Boolean?,
        @Parameter(description = "start of the pagination") @Valid @RequestParam(value = "start", required = false) start: kotlin.Int?,
        @Parameter(description = "limit of the pagination (hard limit of 1000)") @Valid @RequestParam(value = "limit", required = false) limit: kotlin.Int?
    ): ResponseEntity<List<NotificationRecipientResponse>> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Search for Recipients (Counts/Grouped)",
        operationId = "searchRecipientsCount",
        description = """Search for application users to send notifications (count/grouped variant).""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = NotificationRecipientResponseListResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/notification/recipient/search/count"
        value = [PATH_SEARCH_RECIPIENTS_COUNT],
        produces = ["*/*"]
    )
    fun searchRecipientsCount(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "the unique id of the device making the request (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "the account id of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "filters results by application. If this is empty, will return all recipients for all applications that the user has access to.") @Valid @RequestParam(value = "appKey", required = false) appKey: kotlin.String?,
        @Parameter(description = "the type of notification to send: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION.") @Valid @RequestParam(value = "conduit", required = false) conduit: kotlin.String?,
        @Parameter(description = "search by keyword on user's display name and email") @Valid @RequestParam(value = "keyword", required = false) keyword: kotlin.String?,
        @Parameter(description = "This parameter is deprecated. filter results by audience") @Valid @RequestParam(value = "audienceId", required = false) audienceId: kotlin.Long?,
        @Parameter(description = "filter results by audiences (comma separated list of audience ids)") @Valid @RequestParam(value = "audienceIds", required = false) audienceIds: kotlin.String?,
        @Parameter(description = "filter results by connection groups (comma separated list of connection group ids)") @Valid @RequestParam(value = "connectionGroupIds", required = false) connectionGroupIds: kotlin.String?,
        @Parameter(description = "The field to sort by (see API docs for allowed values).") @Valid @RequestParam(value = "sortField", required = false) sortField: kotlin.String?,
        @Parameter(description = "Determines whether the sorted list is in descending or ascending order") @Valid @RequestParam(value = "descending", required = false) descending: kotlin.Boolean?,
        @Parameter(description = "start of the pagination") @Valid @RequestParam(value = "start", required = false) start: kotlin.Int?,
        @Parameter(description = "limit of the pagination") @Valid @RequestParam(value = "limit", required = false) limit: kotlin.Int?
    ): ResponseEntity<NotificationRecipientResponseListResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Search Regions",
        operationId = "searchRegions",
        description = """Get the list of regions.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(array = ArraySchema(schema = Schema(implementation = RegionResponse::class)))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/region/search"
        value = [PATH_SEARCH_REGIONS],
        produces = ["*/*"]
    )
    fun searchRegions(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "the owner account id of the region to be created") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "This parameter is deprecated. deprecated - use \"keyword\"") @Valid @RequestParam(value = "query", required = false) query: kotlin.String?,
        @Parameter(description = "the keyword to filter results on") @Valid @RequestParam(value = "keyword", required = false) keyword: kotlin.String?,
        @Parameter(description = "the latitude of the user") @Valid @RequestParam(value = "latitude", required = false) latitude: kotlin.Double?,
        @Parameter(description = "the longitude of the user") @Valid @RequestParam(value = "longitude", required = false) longitude: kotlin.Double?,
        @Parameter(description = "the search radius") @Valid @RequestParam(value = "range", required = false) range: kotlin.Double?,
        @Parameter(description = "", schema = Schema(allowableValues = ["NATIONAL", "STATE", "COUNTY", "METRO_AREA", "CITY", "NEIGHBORHOOD", "TERRITORY", "CUSTOM", "ZONE"])) @Valid @RequestParam(value = "regionClass", required = false) regionClass: kotlin.String?,
        @Parameter(description = "", schema = Schema(allowableValues = ["PUBLIC", "PRIVATE", "FRIENDS"])) @Valid @RequestParam(value = "visibility", required = false) visibility: kotlin.String?,
        @Parameter(description = "the SearchIndexMode: RDS, LUCENE, or CLOUDINDEX. If not provided, will use the default defined in the Sirqul server", schema = Schema(allowableValues = ["RDS", "LUCENE", "CLOUDINDEX"])) @Valid @RequestParam(value = "searchMode", required = false) searchMode: kotlin.String?,
        @Parameter(description = "the field to order results by: ID, UPDATED, NAME, or DISTANCE. If not provided, will use the default which is by ID for text and DISTANCE when lat/long is provided.", schema = Schema(allowableValues = ["ID", "UPDATED", "NAME", "DISTANCE"])) @Valid @RequestParam(value = "sortField", required = false) sortField: kotlin.String?,
        @Parameter(description = "determines if the results get ordered in descending order") @Valid @RequestParam(value = "descending", required = false) descending: kotlin.Boolean?,
        @Parameter(description = "include the parent region or not") @Valid @RequestParam(value = "includeParent", required = false) includeParent: kotlin.Boolean?,
        @Parameter(description = "include the chidren regions or not") @Valid @RequestParam(value = "includeChildren", required = false) includeChildren: kotlin.Boolean?,
        @Parameter(description = "include the postal codes associated with the region or not") @Valid @RequestParam(value = "includePostalCodes", required = false) includePostalCodes: kotlin.Boolean?,
        @Parameter(description = "search on the categories associated with the region") @Valid @RequestParam(value = "categoryIds", required = false) categoryIds: kotlin.String?,
        @Parameter(description = "search on the filters associated with the region") @Valid @RequestParam(value = "filterIds", required = false) filterIds: kotlin.String?,
        @Parameter(description = "filter by a specific version code") @Valid @RequestParam(value = "versionCode", required = false) versionCode: kotlin.Int?,
        @Parameter(description = "filter to show only active results") @Valid @RequestParam(value = "activeOnly", required = false) activeOnly: kotlin.Boolean?,
        @Parameter(description = "If showDeleted is true and activeOnly is false, will return regions that have been deleted") @Valid @RequestParam(value = "showDeleted", required = false) showDeleted: kotlin.Boolean?,
        @Parameter(description = "only returns records that have last updated since this date \\(UTC timestamp in milliseconds\\)") @Valid @RequestParam(value = "lastUpdatedSince", required = false) lastUpdatedSince: kotlin.Long?,
        @Parameter(description = "the start index for pagination") @Valid @RequestParam(value = "start", required = false) start: kotlin.Int?,
        @Parameter(description = "the limit for pagination") @Valid @RequestParam(value = "limit", required = false) limit: kotlin.Int?
    ): ResponseEntity<List<RegionResponse>> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Search Reservations",
        operationId = "searchReservations",
        description = """""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(array = ArraySchema(schema = Schema(implementation = ReservationResponse::class)))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/reservation/search"
        value = [PATH_SEARCH_RESERVATIONS],
        produces = ["*/*"]
    )
    fun searchReservations(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "Device Id") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "Appilcation Key") @Valid @RequestParam(value = "appKey", required = false) appKey: kotlin.String?,
        @Parameter(description = "the id of the logged in user") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "filter reservations by account ID") @Valid @RequestParam(value = "filterAccountId", required = false) filterAccountId: kotlin.Long?,
        @Parameter(description = "the reservation ID") @Valid @RequestParam(value = "reservableId", required = false) reservableId: kotlin.Long?,
        @Parameter(description = "the type of reservation", schema = Schema(allowableValues = ["LOCATABLE", "RESERVABLE", "PERMISSIONABLE", "NOTABLE", "ASSETABLE", "LIKABLE", "FLAGABLE", "FAVORITABLE", "RATABLE", "ALBUM", "COLLECTION", "APPLICATION", "APPLICATION_SETTING", "APPLICATION_CERT", "APPLICATION_PLACEMENT", "ACCOUNT", "ACCOUNT_SETTING", "GAME_LEVEL", "PACK", "MISSION", "TOURNAMENT", "ASSET", "ALBUM_CONTEST", "THEME_DESCRIPTOR", "OFFER", "OFFER_LOCATION", "EVENT", "RETAILER", "RETAILER_LOCATION", "NOTE", "CREATIVE", "FAVORITE", "LIKE", "RATING", "ANALYTIC", "THIRD_PARTY_CREDENTIAL", "THIRD_PARTY_NETWORK", "REGION"])) @Valid @RequestParam(value = "reservableType", required = false) reservableType: kotlin.String?,
        @Parameter(description = "the keyword to search the reservation on") @Valid @RequestParam(value = "keyword", required = false) keyword: kotlin.String?,
        @Parameter(description = "the start date of the reservation search") @Valid @RequestParam(value = "startDate", required = false) startDate: kotlin.Long?,
        @Parameter(description = "the end date of the reservation search") @Valid @RequestParam(value = "endDate", required = false) endDate: kotlin.Long?,
        @Parameter(description = "the start of the index and/or pagination", schema = Schema(defaultValue = "0")) @Valid @RequestParam(value = "start", required = false, defaultValue = "0") start: kotlin.Int,
        @Parameter(description = "the limit of the index and/or pagination", schema = Schema(defaultValue = "100")) @Valid @RequestParam(value = "limit", required = false, defaultValue = "100") limit: kotlin.Int
    ): ResponseEntity<List<ReservationResponse>> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Search Retailer Locations (Owned)",
        operationId = "searchRetailerLocations",
        description = """Searches on retailer locations that the account has access to.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(array = ArraySchema(schema = Schema(implementation = RetailerLocationResponse::class)))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/retailer/location/search"
        value = [PATH_SEARCH_RETAILER_LOCATIONS],
        produces = ["*/*"]
    )
    fun searchRetailerLocations(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "The device id (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "The account id of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "This parameter is deprecated.") @Valid @RequestParam(value = "q", required = false) q: kotlin.String?,
        @Parameter(description = "The keyword used to search") @Valid @RequestParam(value = "keyword", required = false) keyword: kotlin.String?,
        @Parameter(description = "Comma separated list of retailer IDs which when passed in will filter the results to only return these retailers.") @Valid @RequestParam(value = "retailerIds", required = false) retailerIds: kotlin.String?,
        @Parameter(description = "Comma separated list of retailer location IDs") @Valid @RequestParam(value = "retailerLocationIds", required = false) retailerLocationIds: kotlin.String?,
        @Parameter(description = "Location type filter") @Valid @RequestParam(value = "locationType", required = false) locationType: kotlin.String?,
        @Parameter(description = "The column to sort the search on", schema = Schema(allowableValues = ["ID", "CREATED", "UPDATED", "DELETED", "SEARCH_TAGS", "ACTIVE", "RETAILER_ID", "BILLABLE_ENTITY_ID", "BILLABLE_ENTITY_NAME", "RESPONSIBLE_DISPLAY", "ADDRESS_STREET", "ADDRESS_CITY", "ADDRESS_STATE", "ADDRESS_POSTAL_CODE", "ADDRESS_COUNTRY", "NAME", "CODE"])) @Valid @RequestParam(value = "sortField", required = false) sortField: kotlin.String?,
        @Parameter(description = "The order to return the search results") @Valid @RequestParam(value = "descending", required = false) descending: kotlin.Boolean?,
        @Parameter(description = "This parameter is deprecated.") @Valid @RequestParam(value = "_i", required = false) i: kotlin.Int?,
        @Parameter(description = "The record to begin the return set on") @Valid @RequestParam(value = "start", required = false) start: kotlin.Int?,
        @Parameter(description = "This parameter is deprecated.") @Valid @RequestParam(value = "_l", required = false) l: kotlin.Int?,
        @Parameter(description = "The number of records to return") @Valid @RequestParam(value = "limit", required = false) limit: kotlin.Int?,
        @Parameter(description = "Whether to include public locations in the results") @Valid @RequestParam(value = "showPublicLocations", required = false) showPublicLocations: kotlin.Boolean?,
        @Parameter(description = "Return only active results") @Valid @RequestParam(value = "activeOnly", required = false) activeOnly: kotlin.Boolean?,
        @Parameter(description = "Return retailer info") @Valid @RequestParam(value = "returnRetailer", required = false) returnRetailer: kotlin.Boolean?,
        @Parameter(description = "Return assets") @Valid @RequestParam(value = "returnAssets", required = false) returnAssets: kotlin.Boolean?,
        @Parameter(description = "Return offers") @Valid @RequestParam(value = "returnOffers", required = false) returnOffers: kotlin.Boolean?,
        @Parameter(description = "Return categories") @Valid @RequestParam(value = "returnCategories", required = false) returnCategories: kotlin.Boolean?,
        @Parameter(description = "Return filters") @Valid @RequestParam(value = "returnFilters", required = false) returnFilters: kotlin.Boolean?,
        @Parameter(description = "Return audiences") @Valid @RequestParam(value = "returnAudiences", required = false) returnAudiences: kotlin.Boolean?,
        @Parameter(description = "Return QR code info") @Valid @RequestParam(value = "returnQrCode", required = false) returnQrCode: kotlin.Boolean?,
        @Parameter(description = "Include favorites in response") @Valid @RequestParam(value = "includeFavorite", required = false) includeFavorite: kotlin.Boolean?,
        @Parameter(description = "Include liked flag in response") @Valid @RequestParam(value = "includeLiked", required = false) includeLiked: kotlin.Boolean?,
        @Parameter(description = "Include rating info in response") @Valid @RequestParam(value = "includeRating", required = false) includeRating: kotlin.Boolean?
    ): ResponseEntity<List<RetailerLocationResponse>> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Search Tournament Rounds",
        operationId = "searchRounds",
        description = """Search for the user's tournament games.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/tournament/round/search"
        value = [PATH_SEARCH_ROUNDS],
        produces = ["*/*"]
    )
    fun searchRounds(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the account ID", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "the application key", required = true) @Valid @RequestParam(value = "appKey", required = true) appKey: kotlin.String,
        @Parameter(description = "comma separated list of statuses to filter results by", schema = Schema(defaultValue = "ACCEPTED,ACTIVE")) @Valid @RequestParam(value = "status", required = false, defaultValue = "ACCEPTED,ACTIVE") status: kotlin.String,
        @Parameter(description = "The style of tournament to search for, options are: TOURNAMENT, POOLPLAY", schema = Schema(allowableValues = ["TOURNAMENT", "POOLPLAY"])) @Valid @RequestParam(value = "missionType", required = false) missionType: kotlin.String?,
        @Parameter(description = "search for games that are flagged current only", schema = Schema(defaultValue = "true")) @Valid @RequestParam(value = "currentOnly", required = false, defaultValue = "true") currentOnly: kotlin.Boolean,
        @Parameter(description = "Filter tournament rounds by the mission visibility flag", schema = Schema(defaultValue = "PUBLIC")) @Valid @RequestParam(value = "visibilities", required = false, defaultValue = "PUBLIC") visibilities: kotlin.String,
        @Parameter(description = "the start index for pagination", schema = Schema(defaultValue = "0")) @Valid @RequestParam(value = "start", required = false, defaultValue = "0") start: kotlin.Int,
        @Parameter(description = "the limit for pagination", schema = Schema(defaultValue = "20")) @Valid @RequestParam(value = "limit", required = false, defaultValue = "20") limit: kotlin.Int
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Search Route Settings",
        operationId = "searchRouteSettings",
        description = """Search for route settings""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(array = ArraySchema(schema = Schema(implementation = RouteSettings::class)))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/route/setting"
        value = [PATH_SEARCH_ROUTE_SETTINGS],
        produces = ["*/*"]
    )
    fun searchRouteSettings(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The field to sort by", required = true) @Valid @RequestParam(value = "sortField", required = true) sortField: kotlin.String,
        @NotNull @Parameter(description = "Determines whether the sorted list is in descending or ascending order", required = true) @Valid @RequestParam(value = "descending", required = true) descending: kotlin.Boolean,
        @NotNull @Parameter(description = "The start index for pagination", required = true) @Valid @RequestParam(value = "start", required = true) start: kotlin.Int,
        @NotNull @Parameter(description = "The limit for pagination", required = true) @Valid @RequestParam(value = "limit", required = true) limit: kotlin.Int,
        @NotNull @Parameter(description = "Return only active results", required = true) @Valid @RequestParam(value = "activeOnly", required = true) activeOnly: kotlin.Boolean,
        @Parameter(description = "The service hub that the route belongs under") @Valid @RequestParam(value = "hubId", required = false) hubId: kotlin.Long?,
        @Parameter(description = "The program that the route belongs under") @Valid @RequestParam(value = "programId", required = false) programId: kotlin.Long?,
        @Parameter(description = "The keyword to search for the route") @Valid @RequestParam(value = "keyword", required = false) keyword: kotlin.String?
    ): ResponseEntity<List<RouteSettings>> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Search Routes",
        operationId = "searchRoutes",
        description = """Search for routes.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(array = ArraySchema(schema = Schema(implementation = Route::class)))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/route"
        value = [PATH_SEARCH_ROUTES],
        produces = ["*/*"]
    )
    fun searchRoutes(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The field to sort by", required = true) @Valid @RequestParam(value = "sortField", required = true) sortField: kotlin.String,
        @NotNull @Parameter(description = "Determines whether the sorted list is in descending or ascending order", required = true) @Valid @RequestParam(value = "descending", required = true) descending: kotlin.Boolean,
        @NotNull @Parameter(description = "The start index for pagination", required = true) @Valid @RequestParam(value = "start", required = true) start: kotlin.Int,
        @NotNull @Parameter(description = "The limit for pagination", required = true) @Valid @RequestParam(value = "limit", required = true) limit: kotlin.Int,
        @NotNull @Parameter(description = "Return only active results", required = true) @Valid @RequestParam(value = "activeOnly", required = true) activeOnly: kotlin.Boolean,
        @NotNull @Parameter(description = "Include empty routes or not", required = true) @Valid @RequestParam(value = "includesEmpty", required = true) includesEmpty: kotlin.Boolean,
        @NotNull @Parameter(description = "Only return root instance routes", required = true) @Valid @RequestParam(value = "rootOnly", required = true) rootOnly: kotlin.Boolean,
        @NotNull @Parameter(description = "Display root route properties", required = true) @Valid @RequestParam(value = "showInheritedProperties", required = true) showInheritedProperties: kotlin.Boolean,
        @Parameter(description = "Filter results by service hub") @Valid @RequestParam(value = "hubId", required = false) hubId: kotlin.Long?,
        @Parameter(description = "Filter results by program") @Valid @RequestParam(value = "programId", required = false) programId: kotlin.Long?,
        @Parameter(description = "The start date to filter the results by") @Valid @RequestParam(value = "scheduledStart", required = false) scheduledStart: kotlin.Long?,
        @Parameter(description = "The end date to filter the results by") @Valid @RequestParam(value = "scheduledEnd", required = false) scheduledEnd: kotlin.Long?,
        @Parameter(description = "The lower bound of updated date") @Valid @RequestParam(value = "updatedStart", required = false) updatedStart: kotlin.Long?,
        @Parameter(description = "The upper bound of updated date") @Valid @RequestParam(value = "updatedEnd", required = false) updatedEnd: kotlin.Long?,
        @Parameter(description = "The route is featured or not") @Valid @RequestParam(value = "featured", required = false) featured: kotlin.Boolean?,
        @Parameter(description = "Has at least this many seat available") @Valid @RequestParam(value = "seatCount", required = false) seatCount: kotlin.Int?,
        @Parameter(description = "Has been approved or not") @Valid @RequestParam(value = "approved", required = false) approved: kotlin.Boolean?,
        @Parameter(description = "Has started or not") @Valid @RequestParam(value = "started", required = false) started: kotlin.Boolean?,
        @Parameter(description = "Has completed or not") @Valid @RequestParam(value = "completed", required = false) completed: kotlin.Boolean?,
        @Parameter(description = "Is valid or not") @Valid @RequestParam(value = "valid", required = false) valid: kotlin.Boolean?,
        @Parameter(description = "If it is a recurring route based on the parent route") @Valid @RequestParam(value = "parentId", required = false) parentId: kotlin.Long?
    ): ResponseEntity<List<Route>> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Search Schedule",
        operationId = "searchSchedule",
        description = """""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(array = ArraySchema(schema = Schema(implementation = TimeSlotResponse::class)))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/reservable/schedule/search"
        value = [PATH_SEARCH_SCHEDULE],
        produces = ["*/*"]
    )
    fun searchSchedule(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the id of the reservation", required = true) @Valid @RequestParam(value = "reservableId", required = true) reservableId: kotlin.Long,
        @NotNull @Parameter(description = "the reservation type", required = true, schema = Schema(allowableValues = ["LOCATABLE", "RESERVABLE", "PERMISSIONABLE", "NOTABLE", "ASSETABLE", "LIKABLE", "FLAGABLE", "FAVORITABLE", "RATABLE", "ALBUM", "COLLECTION", "APPLICATION", "APPLICATION_SETTING", "APPLICATION_CERT", "APPLICATION_PLACEMENT", "ACCOUNT", "ACCOUNT_SETTING", "GAME_LEVEL", "PACK", "MISSION", "TOURNAMENT", "ASSET", "ALBUM_CONTEST", "THEME_DESCRIPTOR", "OFFER", "OFFER_LOCATION", "EVENT", "RETAILER", "RETAILER_LOCATION", "NOTE", "CREATIVE", "FAVORITE", "LIKE", "RATING", "ANALYTIC", "THIRD_PARTY_CREDENTIAL", "THIRD_PARTY_NETWORK", "REGION"])) @Valid @RequestParam(value = "reservableType", required = true) reservableType: kotlin.String,
        @NotNull @Parameter(description = "the start date of the reservation", required = true) @Valid @RequestParam(value = "startDate", required = true) startDate: kotlin.Long,
        @NotNull @Parameter(description = "the end date of the reservation", required = true) @Valid @RequestParam(value = "endDate", required = true) endDate: kotlin.Long,
        @Parameter(description = "the id of the device that the reservation is on") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "the id of the logged in user") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "the length of time in minutes to search on for reservation", schema = Schema(defaultValue = "30")) @Valid @RequestParam(value = "timeBucketMins", required = false, defaultValue = "30") timeBucketMins: kotlin.Int
    ): ResponseEntity<List<TimeSlotResponse>> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Search Scheduled Notifications",
        operationId = "searchScheduledNotifications",
        description = """This endpoint searches on Scheduled Notifications. If a scheduled notification was created with the visibility parameter set to PUBLIC, then anyone can search on it if the filter parameter includes the PUBLIC value. PRIVATE visibility means that it can only be searched on by the owner or if it has been shared to the user using the UserPermissionsApi.

In addition, if a PUBLIC Scheduled Notification was created for an application that requires content approval (using the publicContentApproval parameter), then an administrator of the application needs to approve it before it can be search on by other users. Before this happens, it is in a PENDING state, and only the original creator or the owner of the application can search and see it. Also, only the owner of the application can use the UserPermissionsApi to approve or reject it. Scheduled notifications that have been rejected are only visible to the original creators.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = ScheduledNotificationFullResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/notification/schedule/search"
        value = [PATH_SEARCH_SCHEDULED_NOTIFICATIONS],
        produces = ["*/*"]
    )
    fun searchScheduledNotifications(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The logged in user.", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @Parameter(description = "Filter results by a grouping identifier defined by the client") @Valid @RequestParam(value = "groupingId", required = false) groupingId: kotlin.String?,
        @Parameter(description = "Filter results by audience") @Valid @RequestParam(value = "audienceId", required = false) audienceId: kotlin.Long?,
        @Parameter(description = "a comma separated list of filters: MINE - Return scheduled notifications that the user has created. SHARED - Return scheduled notifications that have been shared to the user via addUsersToPermissionable. FOLLOWER - Return scheduled notifications that have been created by the users followers (the content needs to have been APPROVED or FEATURED). FOLLOWING - Return scheduled notifications that have been created by people who the user is following (the content needs to have been APPROVED or FEATURED). PUBLIC - Return all PUBLIC scheduled notifications that have been APPROVED or FEATURED. ALL_PUBLIC - Return all PUBLIC scheduled notifications regardless of whether they are approved or not (ignores the approval status). LIKED - Return all scheduled notifications that the user has liked. FEATURED - Return all scheduled notifications that have been featured. PENDING - Return all pending scheduled notifications.") @Valid @RequestParam(value = "filter", required = false) filter: kotlin.String?,
        @Parameter(description = "Filter results by notification types (comma separated list). Values include: HTTP, EMAIL, SMS, MOBILE_NOTIFICATION") @Valid @RequestParam(value = "types", required = false) types: kotlin.String?,
        @Parameter(description = "search using content IDs") @Valid @RequestParam(value = "contentIds", required = false) contentIds: kotlin.String?,
        @Parameter(description = "search using content types") @Valid @RequestParam(value = "contentTypes", required = false) contentTypes: kotlin.String?,
        @Parameter(description = "search using parent IDs") @Valid @RequestParam(value = "parentIds", required = false) parentIds: kotlin.String?,
        @Parameter(description = "search using parent types") @Valid @RequestParam(value = "parentTypes", required = false) parentTypes: kotlin.String?,
        @Parameter(description = "Filter results by status (comma separated list). Possible values include: NEW - scheduled to run ERROR - encountered an error during processing COMPLETE - processing has completed and it is no longer scheduled to run PROCESSING - currently processing/sending") @Valid @RequestParam(value = "statuses", required = false) statuses: kotlin.String?,
        @Parameter(description = "") @Valid @RequestParam(value = "templateTypes", required = false) templateTypes: kotlin.String?,
        @Parameter(description = "Filter the list by a specific application") @Valid @RequestParam(value = "appKey", required = false) appKey: kotlin.String?,
        @Parameter(description = "Keyword search on the scheduled notification names.") @Valid @RequestParam(value = "keyword", required = false) keyword: kotlin.String?,
        @Parameter(description = "The field to sort by. Possible values include: ID - order by the scheduledNotificationId CREATED - order by the timestamp it was created UPDATED - order by the timestamp it was last updated ACTIVE - order by whether it is active or inactive NAME - order by the scheduled notification name SCHEDULED_DATE - order by the next scheduled date START_DATE - order by the start date END_DATE - order by the end date") @Valid @RequestParam(value = "sortField", required = false) sortField: kotlin.String?,
        @Parameter(description = "Determines whether the sorted list is in descending or ascending order") @Valid @RequestParam(value = "descending", required = false) descending: kotlin.Boolean?,
        @Parameter(description = "Start the result set at some index.") @Valid @RequestParam(value = "start", required = false) start: kotlin.Int?,
        @Parameter(description = "Limit the result to some number.") @Valid @RequestParam(value = "limit", required = false) limit: kotlin.Int?,
        @Parameter(description = "Determines whether to return only active results") @Valid @RequestParam(value = "activeOnly", required = false) activeOnly: kotlin.Boolean?,
        @Parameter(description = "Determines whether to group results with the same groupingId together.") @Valid @RequestParam(value = "groupByGroupingId", required = false) groupByGroupingId: kotlin.Boolean?,
        @Parameter(description = "If true, include audience account counts in the response") @Valid @RequestParam(value = "returnAudienceAccountCount", required = false) returnAudienceAccountCount: kotlin.Boolean?
    ): ResponseEntity<ScheduledNotificationFullResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Search Score",
        operationId = "searchScores",
        description = """Search the scores for an item.  Pass in the full path IDs for the scores.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(array = ArraySchema(schema = Schema(implementation = ScoreResponse::class)))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/score/search"
        value = [PATH_SEARCH_SCORES],
        produces = ["*/*"]
    )
    fun searchScores(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The logged in user.", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "The game application key to get the level for.", required = true) @Valid @RequestParam(value = "appKey", required = true) appKey: kotlin.String,
        @Parameter(description = "The missionId to score for, null if not playing mission.") @Valid @RequestParam(value = "missionId", required = false) missionId: kotlin.Long?,
        @Parameter(description = "The gameId to score for, null if not playing mission.") @Valid @RequestParam(value = "gameId", required = false) gameId: kotlin.Long?,
        @Parameter(description = "The packId to score for, null if playing community levels.") @Valid @RequestParam(value = "packId", required = false) packId: kotlin.Long?,
        @Parameter(description = "The gameLevelId to score for.") @Valid @RequestParam(value = "gameLevelId", required = false) gameLevelId: kotlin.Long?,
        @Parameter(description = "The gameObjectId to score for, null if level based scoring.") @Valid @RequestParam(value = "gameObjectId", required = false) gameObjectId: kotlin.Long?
    ): ResponseEntity<List<ScoreResponse>> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Search Service Hubs",
        operationId = "searchServiceHubs",
        description = """Search for service hubs.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(array = ArraySchema(schema = Schema(implementation = ServiceHub::class)))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/hub"
        value = [PATH_SEARCH_SERVICE_HUBS],
        produces = ["*/*"]
    )
    fun searchServiceHubs(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The field to sort by", required = true) @Valid @RequestParam(value = "sortField", required = true) sortField: kotlin.String,
        @NotNull @Parameter(description = "Determines whether the sorted list is in descending or ascending order", required = true) @Valid @RequestParam(value = "descending", required = true) descending: kotlin.Boolean,
        @NotNull @Parameter(description = "The start index for pagination", required = true) @Valid @RequestParam(value = "start", required = true) start: kotlin.Int,
        @NotNull @Parameter(description = "The limit for pagination", required = true) @Valid @RequestParam(value = "limit", required = true) limit: kotlin.Int,
        @NotNull @Parameter(description = "Return only active results", required = true) @Valid @RequestParam(value = "activeOnly", required = true) activeOnly: kotlin.Boolean,
        @Parameter(description = "The keyword to search for") @Valid @RequestParam(value = "keyword", required = false) keyword: kotlin.String?,
        @Parameter(description = "The retailer belongs to") @Valid @RequestParam(value = "retailerId", required = false) retailerId: kotlin.Long?
    ): ResponseEntity<List<ServiceHub>> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Search Shipment Batch",
        operationId = "searchShipmentBatch",
        description = """Search for shipment batches""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(array = ArraySchema(schema = Schema(implementation = ShipmentBatch::class)))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/shipment/batch"
        value = [PATH_SEARCH_SHIPMENT_BATCH],
        produces = ["*/*"]
    )
    fun searchShipmentBatch(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The associated service hub", required = true) @Valid @RequestParam(value = "hubId", required = true) hubId: kotlin.Long,
        @NotNull @Parameter(description = "The field to sort by", required = true) @Valid @RequestParam(value = "sortField", required = true) sortField: kotlin.String,
        @NotNull @Parameter(description = "Determines whether the sorted list is in descending or ascending order", required = true) @Valid @RequestParam(value = "descending", required = true) descending: kotlin.Boolean,
        @NotNull @Parameter(description = "The start index for pagination", required = true) @Valid @RequestParam(value = "start", required = true) start: kotlin.Int,
        @NotNull @Parameter(description = "The limit for pagination", required = true) @Valid @RequestParam(value = "limit", required = true) limit: kotlin.Int
    ): ResponseEntity<List<ShipmentBatch>> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Search Shipments",
        operationId = "searchShipments",
        description = """Search for shipments""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(array = ArraySchema(schema = Schema(implementation = Shipment::class)))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/shipment"
        value = [PATH_SEARCH_SHIPMENTS],
        produces = ["*/*"]
    )
    fun searchShipments(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The field to sort by", required = true) @Valid @RequestParam(value = "sortField", required = true) sortField: kotlin.String,
        @NotNull @Parameter(description = "Determines whether the sorted list is in descending or ascending order", required = true) @Valid @RequestParam(value = "descending", required = true) descending: kotlin.Boolean,
        @NotNull @Parameter(description = "The start index for pagination", required = true) @Valid @RequestParam(value = "start", required = true) start: kotlin.Int,
        @NotNull @Parameter(description = "The limit for pagination", required = true) @Valid @RequestParam(value = "limit", required = true) limit: kotlin.Int,
        @NotNull @Parameter(description = "Return only active results", required = true) @Valid @RequestParam(value = "activeOnly", required = true) activeOnly: kotlin.Boolean,
        @Parameter(description = "The owner of the shipment") @Valid @RequestParam(value = "ownerId", required = false) ownerId: kotlin.Long?,
        @Parameter(description = "The rider associate to this shipment") @Valid @RequestParam(value = "riderId", required = false) riderId: kotlin.Long?,
        @Parameter(description = "The route associate to this shipment") @Valid @RequestParam(value = "routeId", required = false) routeId: kotlin.Long?
    ): ResponseEntity<List<Shipment>> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Search Tasks",
        operationId = "searchTasks",
        description = """Search on Tasks""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(array = ArraySchema(schema = Schema(implementation = TaskResponse::class)))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/task/search"
        value = [PATH_SEARCH_TASKS],
        produces = ["*/*"]
    )
    fun searchTasks(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The logged in user.", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @Parameter(description = "Filter results by a grouping identifier defined by the client") @Valid @RequestParam(value = "groupingId", required = false) groupingId: kotlin.String?,
        @Parameter(description = "A comma separated list of filters:  * MINE - Return tasks that the user has created * SHARED - Return tasks that have been shared to the user * FOLLOWER - Return tasks that have been created by the user''s followers (the content needs to have been APPROVED or FEATURED) * FOLLOWING - Return tasks that have been created by people who the user is following (the content needs to have been APPROVED or FEATURED) * PUBLIC - Return all PUBLIC tasks that have been APPROVED or FEATURED * ALL_PUBLIC - Return all PUBLIC tasks regardless of whether they are approved or not (ignores the approval status) * LIKED - Return all tasks that the user has liked * FEATURED - Return all tasks that have been featured * PENDING - Return all pending tasks ", schema = Schema(defaultValue = "MINE")) @Valid @RequestParam(value = "filter", required = false, defaultValue = "MINE") filter: kotlin.String,
        @Parameter(description = "Filter results by status (comma separated list). Values include: NEW, ERROR, COMPLETE, PROCESSING, TEMPLATE", schema = Schema(defaultValue = "NEW,ERROR,COMPLETE,PROCESSING")) @Valid @RequestParam(value = "statuses", required = false, defaultValue = "NEW,ERROR,COMPLETE,PROCESSING") statuses: kotlin.String,
        @Parameter(description = "Template Types") @Valid @RequestParam(value = "templateTypes", required = false) templateTypes: kotlin.String?,
        @Parameter(description = "Filter the list by a specific application") @Valid @RequestParam(value = "appKey", required = false) appKey: kotlin.String?,
        @Parameter(description = "Keyword search on the task names.") @Valid @RequestParam(value = "keyword", required = false) keyword: kotlin.String?,
        @Parameter(description = "The field to sort by. Possible values include: ID, CREATED, UPDATED, ACTIVE, NAME, SCHEDULED_DATE, START_DATE, END_DATE", schema = Schema(defaultValue = "CREATED")) @Valid @RequestParam(value = "sortField", required = false, defaultValue = "CREATED") sortField: kotlin.String,
        @Parameter(description = "Determines whether the sorted list is in descending or ascending order", schema = Schema(defaultValue = "true")) @Valid @RequestParam(value = "descending", required = false, defaultValue = "true") descending: kotlin.Boolean,
        @Parameter(description = "Start the result set at some index.", schema = Schema(defaultValue = "0")) @Valid @RequestParam(value = "start", required = false, defaultValue = "0") start: kotlin.Int,
        @Parameter(description = "Limit the result to some number.", schema = Schema(defaultValue = "20")) @Valid @RequestParam(value = "limit", required = false, defaultValue = "20") limit: kotlin.Int,
        @Parameter(description = "Determines whether to return only active results", schema = Schema(defaultValue = "true")) @Valid @RequestParam(value = "activeOnly", required = false, defaultValue = "true") activeOnly: kotlin.Boolean
    ): ResponseEntity<List<TaskResponse>> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Search Territories",
        operationId = "searchTerritories",
        description = """Searches on territories.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(array = ArraySchema(schema = Schema(implementation = TerritoryResponse::class)))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/territory/search"
        value = [PATH_SEARCH_TERRITORIES],
        produces = ["*/*"]
    )
    fun searchTerritories(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the field to sort by. Supported values include: ID, CREATED, UPDATED, NAME", required = true, schema = Schema(allowableValues = ["ID", "UPDATED", "CREATED", "NAME"])) @Valid @RequestParam(value = "sortField", required = true) sortField: kotlin.String,
        @NotNull @Parameter(description = "determines whether the sorted list is in descending or ascending order", required = true) @Valid @RequestParam(value = "descending", required = true) descending: kotlin.Boolean,
        @Parameter(description = "Return results that match this keyword.") @Valid @RequestParam(value = "keyword", required = false) keyword: kotlin.String?,
        @Parameter(description = "The start index for pagination") @Valid @RequestParam(value = "start", required = false) start: kotlin.Int?,
        @Parameter(description = "The limit for pagination") @Valid @RequestParam(value = "limit", required = false) limit: kotlin.Int?
    ): ResponseEntity<List<TerritoryResponse>> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Search Tournaments",
        operationId = "searchTournaments",
        description = """Search for tournaments""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = MissionShortResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/tournament/search"
        value = [PATH_SEARCH_TOURNAMENTS],
        produces = ["*/*"]
    )
    fun searchTournaments(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The logged in user.", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "The application key", required = true) @Valid @RequestParam(value = "appKey", required = true) appKey: kotlin.String,
        @Parameter(description = "the keyword to search tournament on") @Valid @RequestParam(value = "keyword", required = false) keyword: kotlin.String?,
        @Parameter(description = "filter results by subType") @Valid @RequestParam(value = "subType", required = false) subType: kotlin.String?,
        @Parameter(description = "whether to include inactives in the search or not", schema = Schema(defaultValue = "false")) @Valid @RequestParam(value = "includeInactive", required = false, defaultValue = "false") includeInactive: kotlin.Boolean,
        @Parameter(description = "comma separated list of mission types to filter results, possbile values include: TOURNAMENT, POOLPLAY, MULTISTAGE", schema = Schema(defaultValue = "MULTISTAGE,TOURNAMENT,POOLPLAY")) @Valid @RequestParam(value = "missionTypes", required = false, defaultValue = "MULTISTAGE,TOURNAMENT,POOLPLAY") missionTypes: kotlin.String,
        @Parameter(description = "filter tournaments by the tournament's current state", schema = Schema(allowableValues = ["ALL", "UPCOMING", "PAST", "PRESENT", "ACTIVE"], defaultValue = "UPCOMING")) @Valid @RequestParam(value = "filter", required = false, defaultValue = "UPCOMING") filter: kotlin.String,
        @Parameter(description = "which field to sort on", schema = Schema(allowableValues = ["ACTIVE", "TITLE", "DESCRIPTION", "CREATED", "UPDATED", "MISSION_TYPE", "OWNER_DISPLAY", "START_DATE", "END_DATE", "STARTING_LIMIT", "AVAILABLE_LIMIT", "INVITE_COUNT", "ACCEPTED_COUNT"], defaultValue = "START_DATE")) @Valid @RequestParam(value = "sortField", required = false, defaultValue = "START_DATE") sortField: kotlin.String,
        @Parameter(description = "Determines whether to return results in descending order. The default value will be true if the filter is \"PAST\", otherwise the default value will be false.") @Valid @RequestParam(value = "descending", required = false) descending: kotlin.Boolean?,
        @Parameter(description = "Comma separated list of visibility flags for search for, possible values include: PUBLIC, LISTABLE, REWARDABLE, TRIGGERABLE, PRIVATE", schema = Schema(defaultValue = "PUBLIC")) @Valid @RequestParam(value = "visibility", required = false, defaultValue = "PUBLIC") visibility: kotlin.String,
        @Parameter(description = "Start the result set at some index.", schema = Schema(defaultValue = "0")) @Valid @RequestParam(value = "start", required = false, defaultValue = "0") start: kotlin.Int,
        @Parameter(description = "Limit the result to some number", schema = Schema(defaultValue = "20")) @Valid @RequestParam(value = "limit", required = false, defaultValue = "20") limit: kotlin.Int
    ): ResponseEntity<MissionShortResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Search Tracking (Billable)",
        operationId = "searchTrackingLegs",
        description = """Retrieve tracking data for billable/account scoped queries.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(array = ArraySchema(schema = Schema(implementation = LegResponse::class)))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/tracking/searchByBillable"
        value = [PATH_SEARCH_TRACKING_LEGS],
        produces = ["*/*"]
    )
    fun searchTrackingLegs(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The account id to search tracking for", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "The application key", required = true) @Valid @RequestParam(value = "appKey", required = true) appKey: kotlin.String,
        @Parameter(description = "The id of the tracking device") @Valid @RequestParam(value = "trackingDeviceId", required = false) trackingDeviceId: kotlin.String?,
        @Parameter(description = "The start date in (UTC milliseconds) to filter the tracking results") @Valid @RequestParam(value = "startDate", required = false) startDate: kotlin.Long?,
        @Parameter(description = "The end date in (UTC milliseconds) to filter the tracking results") @Valid @RequestParam(value = "endDate", required = false) endDate: kotlin.Long?,
        @Parameter(description = "Filter results by tag") @Valid @RequestParam(value = "tags", required = false) tags: kotlin.String?,
        @Parameter(description = "The start index for pagination", schema = Schema(defaultValue = "0")) @Valid @RequestParam(value = "start", required = false, defaultValue = "0") start: kotlin.Int,
        @Parameter(description = "The limit for pagination", schema = Schema(defaultValue = "100")) @Valid @RequestParam(value = "limit", required = false, defaultValue = "100") limit: kotlin.Int
    ): ResponseEntity<List<LegResponse>> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Search Triggers",
        operationId = "searchTriggers",
        description = """Search for triggers""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(array = ArraySchema(schema = Schema(implementation = TriggerResponse::class)))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/trigger/search"
        value = [PATH_SEARCH_TRIGGERS],
        produces = ["*/*"]
    )
    fun searchTriggers(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The logged in user.", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @Parameter(description = "Filter results by a grouping identifier defined by the client") @Valid @RequestParam(value = "groupingId", required = false) groupingId: kotlin.String?,
        @Parameter(description = "A comma separated list of filters. * MINE - Return triggers that the user has created * SHARED - Return triggers that have been shared to the user * FOLLOWER - Return triggers that have been created by the user''s followers (the content needs to have been APPROVED or FEATURED) * FOLLOWING - Return triggers that have been created by people who the user is following (the content needs to have been APPROVED or FEATURED) * PUBLIC - Return all PUBLIC triggers that have been APPROVED or FEATURED * ALL_PUBLIC - Return all PUBLIC triggers regardless of whether they are approved or not (ignores the approval status) * LIKED - Return all triggers that the user has liked * FEATURED - Return all triggers that have been featured * PENDING - Return all pending triggers ", schema = Schema(defaultValue = "MINE")) @Valid @RequestParam(value = "filter", required = false, defaultValue = "MINE") filter: kotlin.String,
        @Parameter(description = "Filter results by status (comma separated list). Values include: NEW, ERROR, COMPLETE, PROCESSING, TEMPLATE", schema = Schema(defaultValue = "NEW,ERROR,COMPLETE,PROCESSING")) @Valid @RequestParam(value = "statuses", required = false, defaultValue = "NEW,ERROR,COMPLETE,PROCESSING") statuses: kotlin.String,
        @Parameter(description = "Template Types") @Valid @RequestParam(value = "templateTypes", required = false) templateTypes: kotlin.String?,
        @Parameter(description = "Filter the list by a specific application") @Valid @RequestParam(value = "appKey", required = false) appKey: kotlin.String?,
        @Parameter(description = "Keyword search on the trigger names.") @Valid @RequestParam(value = "keyword", required = false) keyword: kotlin.String?,
        @Parameter(description = "The field to sort by. Possible values include: ID, CREATED, UPDATED, ACTIVE, NAME, SCHEDULED_DATE, START_DATE, END_DATE", schema = Schema(defaultValue = "CREATED")) @Valid @RequestParam(value = "sortField", required = false, defaultValue = "CREATED") sortField: kotlin.String,
        @Parameter(description = "Determines whether the sorted list is in descending or ascending order", schema = Schema(defaultValue = "true")) @Valid @RequestParam(value = "descending", required = false, defaultValue = "true") descending: kotlin.Boolean,
        @Parameter(description = "Start the result set at some index.", schema = Schema(defaultValue = "0")) @Valid @RequestParam(value = "start", required = false, defaultValue = "0") start: kotlin.Int,
        @Parameter(description = "Limit the result to some number.", schema = Schema(defaultValue = "20")) @Valid @RequestParam(value = "limit", required = false, defaultValue = "20") limit: kotlin.Int,
        @Parameter(description = "Determines whether to return only active results", schema = Schema(defaultValue = "true")) @Valid @RequestParam(value = "activeOnly", required = false, defaultValue = "true") activeOnly: kotlin.Boolean
    ): ResponseEntity<List<TriggerResponse>> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Search Trips",
        operationId = "searchTrips",
        description = """Search for trips with matching information.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(array = ArraySchema(schema = Schema(implementation = Trip::class)))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/trip/match"
        value = [PATH_SEARCH_TRIPS],
        produces = ["*/*"]
    )
    fun searchTrips(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The owner of the trips", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "The field to sort by", required = true) @Valid @RequestParam(value = "sortField", required = true) sortField: kotlin.String,
        @NotNull @Parameter(description = "Determines whether the sorted list is in descending or ascending order", required = true) @Valid @RequestParam(value = "descending", required = true) descending: kotlin.Boolean,
        @NotNull @Parameter(description = "The start index for pagination", required = true) @Valid @RequestParam(value = "start", required = true) start: kotlin.Int,
        @NotNull @Parameter(description = "The limit for pagination", required = true) @Valid @RequestParam(value = "limit", required = true) limit: kotlin.Int,
        @NotNull @Parameter(description = "Return only active results", required = true) @Valid @RequestParam(value = "activeOnly", required = true) activeOnly: kotlin.Boolean,
        @Parameter(description = "The lower bound limit of time") @Valid @RequestParam(value = "startDate", required = false) startDate: kotlin.Long?,
        @Parameter(description = "The upper bound limit of time") @Valid @RequestParam(value = "endDate", required = false) endDate: kotlin.Long?,
        @Parameter(description = "Only return matchings that already have route assigned") @Valid @RequestParam(value = "matchedHasRoute", required = false) matchedHasRoute: kotlin.Boolean?,
        @Parameter(description = "Only return matchings that already have driver assigned") @Valid @RequestParam(value = "matchedHasDriver", required = false) matchedHasDriver: kotlin.Boolean?
    ): ResponseEntity<List<Trip>> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Search Vehicle",
        operationId = "searchVehicle",
        description = """Search for vehicles""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(array = ArraySchema(schema = Schema(implementation = Vehicle::class)))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/vehicle"
        value = [PATH_SEARCH_VEHICLE],
        produces = ["*/*"]
    )
    fun searchVehicle(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "Filter by service hub", required = true) @Valid @RequestParam(value = "hubId", required = true) hubId: kotlin.Long,
        @NotNull @Parameter(description = "The field to sort by", required = true, schema = Schema(defaultValue = "id")) @Valid @RequestParam(value = "sortField", required = true, defaultValue = "id") sortField: kotlin.String,
        @NotNull @Parameter(description = "Determines whether the sorted list is in descending or ascending order", required = true, schema = Schema(defaultValue = "false")) @Valid @RequestParam(value = "descending", required = true, defaultValue = "false") descending: kotlin.Boolean,
        @NotNull @Parameter(description = "The start index for pagination", required = true, schema = Schema(defaultValue = "0")) @Valid @RequestParam(value = "start", required = true, defaultValue = "0") start: kotlin.Int,
        @NotNull @Parameter(description = "The limit for pagination", required = true, schema = Schema(defaultValue = "20")) @Valid @RequestParam(value = "limit", required = true, defaultValue = "20") limit: kotlin.Int,
        @NotNull @Parameter(description = "Return only active results", required = true, schema = Schema(defaultValue = "true")) @Valid @RequestParam(value = "activeOnly", required = true, defaultValue = "true") activeOnly: kotlin.Boolean,
        @Parameter(description = "The keyword to search for") @Valid @RequestParam(value = "keyword", required = false) keyword: kotlin.String?
    ): ResponseEntity<List<Vehicle>> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Search Vehicle Type",
        operationId = "searchVehicleTypes",
        description = """Search for types of vehicles""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(array = ArraySchema(schema = Schema(implementation = VehicleType::class)))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/vehicle/type"
        value = [PATH_SEARCH_VEHICLE_TYPES],
        produces = ["*/*"]
    )
    fun searchVehicleTypes(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The field to sort by", required = true, schema = Schema(defaultValue = "id")) @Valid @RequestParam(value = "sortField", required = true, defaultValue = "id") sortField: kotlin.String,
        @NotNull @Parameter(description = "Determines whether the sorted list is in descending or ascending order", required = true, schema = Schema(defaultValue = "false")) @Valid @RequestParam(value = "descending", required = true, defaultValue = "false") descending: kotlin.Boolean,
        @NotNull @Parameter(description = "The start index for pagination", required = true, schema = Schema(defaultValue = "0")) @Valid @RequestParam(value = "start", required = true, defaultValue = "0") start: kotlin.Int,
        @NotNull @Parameter(description = "The limit for pagination", required = true, schema = Schema(defaultValue = "20")) @Valid @RequestParam(value = "limit", required = true, defaultValue = "20") limit: kotlin.Int,
        @NotNull @Parameter(description = "Return only active results", required = true, schema = Schema(defaultValue = "true")) @Valid @RequestParam(value = "activeOnly", required = true, defaultValue = "true") activeOnly: kotlin.Boolean,
        @Parameter(description = "Filter by retailer") @Valid @RequestParam(value = "retailerId", required = false) retailerId: kotlin.Long?,
        @Parameter(description = "Filter by service hub") @Valid @RequestParam(value = "hubId", required = false) hubId: kotlin.Long?
    ): ResponseEntity<List<VehicleType>> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Search Weather",
        operationId = "searchWeather",
        description = """Search the weather forcast for the next 5 days""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = WeatherResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/weather/search"
        value = [PATH_SEARCH_WEATHER],
        produces = ["*/*"]
    )
    fun searchWeather(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "Region Id") @Valid @RequestParam(value = "regionId", required = false) regionId: kotlin.Long?,
        @Parameter(description = "Latitude") @Valid @RequestParam(value = "latitude", required = false) latitude: kotlin.Double?,
        @Parameter(description = "Longitude") @Valid @RequestParam(value = "longitude", required = false) longitude: kotlin.Double?,
        @Parameter(description = "Timezone Offset", schema = Schema(defaultValue = "-6L")) @Valid @RequestParam(value = "timezoneOffset", required = false, defaultValue = "-6L") timezoneOffset: kotlin.Long
    ): ResponseEntity<WeatherResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Login Account (Encrypted Username)",
        operationId = "secureLogin",
        description = """ogin with encrypted user-name and password.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = ProfileResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/account/login/validate"
        value = [PATH_SECURE_LOGIN],
        produces = ["*/*"]
    )
    fun secureLogin(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The user's encrypted email address they used to sign-up", required = true) @Valid @RequestParam(value = "username", required = true) username: kotlin.String,
        @NotNull @Parameter(description = "The encrypted password", required = true) @Valid @RequestParam(value = "password", required = true) password: kotlin.String,
        @NotNull @Parameter(description = "The application key", required = true) @Valid @RequestParam(value = "gameType", required = true) gameType: kotlin.String,
        @Parameter(description = "The device id") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "Charset Name", schema = Schema(defaultValue = "UTF-8")) @Valid @RequestParam(value = "charsetName", required = false, defaultValue = "UTF-8") charsetName: kotlin.String,
        @Parameter(description = "The current latitude of the user") @Valid @RequestParam(value = "latitude", required = false) latitude: kotlin.Double?,
        @Parameter(description = "The current longitude of the user") @Valid @RequestParam(value = "longitude", required = false) longitude: kotlin.Double?,
        @Parameter(description = "Return Profile", schema = Schema(defaultValue = "false")) @Valid @RequestParam(value = "returnProfile", required = false, defaultValue = "false") returnProfile: kotlin.Boolean,
        @Parameter(description = "A comma separated list of ProfileFilters for filtering the returned response data", schema = Schema(defaultValue = "PROFILE")) @Valid @RequestParam(value = "responseFilters", required = false, defaultValue = "PROFILE") responseFilters: kotlin.String
    ): ResponseEntity<ProfileResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Create Account (Encrypted Username)",
        operationId = "secureSignup",
        description = """Create a new account by role (with encrypted user-name and password)""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = ProfileInfoResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/account/create/validate"
        value = [PATH_SECURE_SIGNUP],
        produces = ["*/*"]
    )
    fun secureSignup(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The device id", required = true) @Valid @RequestParam(value = "deviceId", required = true) deviceId: kotlin.String,
        @NotNull @Parameter(description = "The encrypted email of the user, this is what will be used when they login", required = true) @Valid @RequestParam(value = "username", required = true) username: kotlin.String,
        @NotNull @Parameter(description = "The encrypted password of the user", required = true) @Valid @RequestParam(value = "password", required = true) password: kotlin.String,
        @Parameter(description = "The full name of the user. If this parameter is not empty, the  following parameters will be ignored: prefixName, firstName, middleName,  lastName, and suffixName ") @Valid @RequestParam(value = "name", required = false) name: kotlin.String?,
        @Parameter(description = "the inviteToken that the referrer use for this account to sign up") @Valid @RequestParam(value = "inviteToken", required = false) inviteToken: kotlin.String?,
        @Parameter(description = "If the parameter 'name' is empty or not present, this field will be used to set the prefix of the user's name") @Valid @RequestParam(value = "prefixName", required = false) prefixName: kotlin.String?,
        @Parameter(description = "If the parameter 'name' is empty or not present, this field will be used to set the user's first name") @Valid @RequestParam(value = "firstName", required = false) firstName: kotlin.String?,
        @Parameter(description = "If the parameter 'name' is empty or not present, this field will be used to set the user's middle name") @Valid @RequestParam(value = "middleName", required = false) middleName: kotlin.String?,
        @Parameter(description = "If the parameter 'name' is empty or not present, this field will be used to set the user's last name") @Valid @RequestParam(value = "lastName", required = false) lastName: kotlin.String?,
        @Parameter(description = "If the parameter 'name' is empty or not present, this field will be used to set the suffix of the user's name") @Valid @RequestParam(value = "suffixName", required = false) suffixName: kotlin.String?,
        @Parameter(description = "Title") @Valid @RequestParam(value = "title", required = false) title: kotlin.String?,
        @Parameter(description = "Device Id Type") @Valid @RequestParam(value = "deviceIdType", required = false) deviceIdType: kotlin.String?,
        @Parameter(description = "The user's contact email address (NOT the username) which is also used for email validation") @Valid @RequestParam(value = "emailAddress", required = false) emailAddress: kotlin.String?,
        @Parameter(description = "The asset id to set the user's profile image") @Valid @RequestParam(value = "assetId", required = false) assetId: kotlin.Long?,
        @Parameter(description = "the user's address") @Valid @RequestParam(value = "address", required = false) address: kotlin.String?,
        @Parameter(description = "The street zipcode of the user's contact location") @Valid @RequestParam(value = "zipcode", required = false) zipcode: kotlin.String?,
        @Parameter(description = "The gender of the user AudienceGender") @Valid @RequestParam(value = "gender", required = false) gender: kotlin.String?,
        @Parameter(description = "The birthday date of the user in milliseconds") @Valid @RequestParam(value = "birthday", required = false) birthday: kotlin.Long?,
        @Parameter(description = "the user's home phone number") @Valid @RequestParam(value = "homePhone", required = false) homePhone: kotlin.String?,
        @Parameter(description = "the user's cell phone number") @Valid @RequestParam(value = "cellPhone", required = false) cellPhone: kotlin.String?,
        @Parameter(description = "the user's Cell Phone Carrier") @Valid @RequestParam(value = "cellPhoneCarrier", required = false) cellPhoneCarrier: kotlin.String?,
        @Parameter(description = "the user's Business Phone Number") @Valid @RequestParam(value = "businessPhone", required = false) businessPhone: kotlin.String?,
        @Parameter(description = "The type of account being created {RETAILER, MEMBER, DEVELOPER, GUEST", schema = Schema(defaultValue = "MEMBER")) @Valid @RequestParam(value = "role", required = false, defaultValue = "MEMBER") role: kotlin.String,
        @Parameter(description = "Comma separated list of development platforms: MAC, WINDOWS, IOS, ANDROID, WINDOWSPHONE, KINDLE, UNITY3D, COCOS2D, HTML5, FACEBOOK") @Valid @RequestParam(value = "platforms", required = false) platforms: kotlin.String?,
        @Parameter(description = "Search tags") @Valid @RequestParam(value = "tags", required = false) tags: kotlin.String?,
        @Parameter(description = "About Us information") @Valid @RequestParam(value = "aboutUs", required = false) aboutUs: kotlin.String?,
        @Parameter(description = "Game experience level of the user {ANY, NEW, BEGINNER, INTERMEDIATE, EXPERT") @Valid @RequestParam(value = "gameExperience", required = false) gameExperience: kotlin.String?,
        @Parameter(description = "A list of category ids that represent interests and associations") @Valid @RequestParam(value = "categoryIds", required = false) categoryIds: kotlin.String?,
        @Parameter(description = "The user's hometown") @Valid @RequestParam(value = "hometown", required = false) hometown: kotlin.String?,
        @Parameter(description = "The user's height") @Valid @RequestParam(value = "height", required = false) height: kotlin.String?,
        @Parameter(description = "The user's height in a numerical value that can be used for ordering/searching") @Valid @RequestParam(value = "heightIndex", required = false) heightIndex: kotlin.Int?,
        @Parameter(description = "The user's ethnicity") @Valid @RequestParam(value = "ethnicity", required = false) ethnicity: kotlin.String?,
        @Parameter(description = "The user's body type") @Valid @RequestParam(value = "bodyType", required = false) bodyType: kotlin.String?,
        @Parameter(description = "The user's maritial status") @Valid @RequestParam(value = "maritalStatus", required = false) maritalStatus: kotlin.String?,
        @Parameter(description = "The user's children status") @Valid @RequestParam(value = "children", required = false) children: kotlin.String?,
        @Parameter(description = "The user's religion") @Valid @RequestParam(value = "religion", required = false) religion: kotlin.String?,
        @Parameter(description = "The user's education") @Valid @RequestParam(value = "education", required = false) education: kotlin.String?,
        @Parameter(description = "The user's education in a numerical value that can be used for ordering/searching") @Valid @RequestParam(value = "educationIndex", required = false) educationIndex: kotlin.Int?,
        @Parameter(description = "The user's smoke status") @Valid @RequestParam(value = "smoke", required = false) smoke: kotlin.String?,
        @Parameter(description = "The user's drink status") @Valid @RequestParam(value = "drink", required = false) drink: kotlin.String?,
        @Parameter(description = "The user's companionship status") @Valid @RequestParam(value = "companionship", required = false) companionship: kotlin.String?,
        @Parameter(description = "The user's companionship index") @Valid @RequestParam(value = "companionshipIndex", required = false) companionshipIndex: kotlin.Int?,
        @Parameter(description = "The preferred minimum age in the account location search") @Valid @RequestParam(value = "preferredMinAge", required = false) preferredMinAge: kotlin.Int?,
        @Parameter(description = "The preferred maximum age in the account location search") @Valid @RequestParam(value = "preferredMaxAge", required = false) preferredMaxAge: kotlin.Int?,
        @Parameter(description = "The preferred minimum height in the account location search") @Valid @RequestParam(value = "preferredMinHeight", required = false) preferredMinHeight: kotlin.Int?,
        @Parameter(description = "The preferred maximum height in the account location search") @Valid @RequestParam(value = "preferredMaxHeight", required = false) preferredMaxHeight: kotlin.Int?,
        @Parameter(description = "The preferred gender in the account location search") @Valid @RequestParam(value = "preferredGender", required = false) preferredGender: kotlin.String?,
        @Parameter(description = "The preferred education in the account location search") @Valid @RequestParam(value = "preferredEducation", required = false) preferredEducation: kotlin.String?,
        @Parameter(description = "The preferred education in a numerical value that can be used for ordering/searching") @Valid @RequestParam(value = "preferredEducationIndex", required = false) preferredEducationIndex: kotlin.Int?,
        @Parameter(description = "The preferred body type in the account location search") @Valid @RequestParam(value = "preferredBodyType", required = false) preferredBodyType: kotlin.String?,
        @Parameter(description = "The preferred ethnicity in the account location search") @Valid @RequestParam(value = "preferredEthnicity", required = false) preferredEthnicity: kotlin.String?,
        @Parameter(description = "The preferred education in the account location search") @Valid @RequestParam(value = "preferredLocation", required = false) preferredLocation: kotlin.String?,
        @Parameter(description = "The preferred location range in the account location search") @Valid @RequestParam(value = "preferredLocationRange", required = false) preferredLocationRange: kotlin.Double?,
        @Parameter(description = "The current latitude of the user") @Valid @RequestParam(value = "latitude", required = false) latitude: kotlin.Double?,
        @Parameter(description = "The current longitude of the user") @Valid @RequestParam(value = "longitude", required = false) longitude: kotlin.Double?,
        @Parameter(description = "Accepted Terms", schema = Schema(defaultValue = "true")) @Valid @RequestParam(value = "acceptedTerms", required = false, defaultValue = "true") acceptedTerms: kotlin.Boolean,
        @Parameter(description = "Charset Name", schema = Schema(defaultValue = "UTF-8")) @Valid @RequestParam(value = "charsetName", required = false, defaultValue = "UTF-8") charsetName: kotlin.String,
        @Parameter(description = "Game Type") @Valid @RequestParam(value = "gameType", required = false) gameType: kotlin.String?,
        @Parameter(description = "The application key") @Valid @RequestParam(value = "appKey", required = false) appKey: kotlin.String?,
        @Parameter(description = "App Version") @Valid @RequestParam(value = "appVersion", required = false) appVersion: kotlin.String?,
        @Parameter(description = "Response Type") @Valid @RequestParam(value = "responseType", required = false) responseType: kotlin.String?
    ): ResponseEntity<ProfileInfoResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Send Batch Notifications",
        operationId = "sendBatchNotifications",
        description = """Send notifications to all users of an application. Only someone with permissions to the application can do this.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/notification/batch"
        value = [PATH_SEND_BATCH_NOTIFICATIONS],
        produces = ["*/*"]
    )
    fun sendBatchNotifications(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The account id of the application owner/manager", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "The application key for updating an existing application", required = true) @Valid @RequestParam(value = "appKey", required = true) appKey: kotlin.String,
        @NotNull @Parameter(description = "Message string that will be displayed in on the notification", required = true) @Valid @RequestParam(value = "customMessage", required = true) customMessage: kotlin.String,
        @Parameter(description = "The type of notification to send: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION.") @Valid @RequestParam(value = "conduit", required = false) conduit: kotlin.String?,
        @Parameter(description = "Default notification pay-load field (usage is dependent on the app and the type of event)") @Valid @RequestParam(value = "contentId", required = false) contentId: kotlin.Long?,
        @Parameter(description = "Default notification pay-load field (usage is dependent on the app and the type of event)") @Valid @RequestParam(value = "contentName", required = false) contentName: kotlin.String?,
        @Parameter(description = "Default notification pay-load field (usage is dependent on the app and the type of event)") @Valid @RequestParam(value = "contentType", required = false) contentType: kotlin.String?,
        @Parameter(description = "Default notification pay-load field (usage is dependent on the app and the type of event)") @Valid @RequestParam(value = "parentId", required = false) parentId: kotlin.Long?,
        @Parameter(description = "Default notification pay-load field (usage is dependent on the app and the type of event)") @Valid @RequestParam(value = "parentType", required = false) parentType: kotlin.String?
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Send Suggestions",
        operationId = "sendByAccount",
        description = """Use the accountId to determine the associated BillableEntity. From there get a list of all triggers associated with the BillableEntity.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/audience/suggestion/send"
        value = [PATH_SEND_BY_ACCOUNT],
        produces = ["*/*"]
    )
    fun sendByAccount(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The account to match offers for.", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "the latitude", required = true) @Valid @RequestParam(value = "latitude", required = true) latitude: kotlin.Double,
        @NotNull @Parameter(description = "the longitude", required = true) @Valid @RequestParam(value = "longitude", required = true) longitude: kotlin.Double
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Send Custom Notifications",
        operationId = "sendCustomNotifications",
        description = """Send your own custom notification to a user. NOTE: the EventType of these notifications will be CUSTOM. Notifications sent to yourself will currently be ignored.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/notification/custom"
        value = [PATH_SEND_CUSTOM_NOTIFICATIONS],
        produces = ["*/*"]
    )
    fun sendCustomNotifications(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "the unique id of the device making the request (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "the account id of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "comma separated list of account IDs that will receive the notification") @Valid @RequestParam(value = "receiverAccountIds", required = false) receiverAccountIds: kotlin.String?,
        @Parameter(description = "determines whether to send to all of the user's friends, this flag must be true or receiverAccountIds must not be empty") @Valid @RequestParam(value = "includeFriendGroup", required = false) includeFriendGroup: kotlin.Boolean?,
        @Parameter(description = "the application key") @Valid @RequestParam(value = "appKey", required = false) appKey: kotlin.String?,
        @Parameter(description = "This parameter is deprecated.") @Valid @RequestParam(value = "gameType", required = false) gameType: kotlin.String?,
        @Parameter(description = "the type of notification to send: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION.") @Valid @RequestParam(value = "conduit", required = false) conduit: kotlin.String?,
        @Parameter(description = "default notification pay-load field (usage is dependent on the app and the type of event)") @Valid @RequestParam(value = "contentId", required = false) contentId: kotlin.Long?,
        @Parameter(description = "default notification pay-load field (usage is dependent on the app and the type of event)") @Valid @RequestParam(value = "contentName", required = false) contentName: kotlin.String?,
        @Parameter(description = "default notification pay-load field (usage is dependent on the app and the type of event)") @Valid @RequestParam(value = "contentType", required = false) contentType: kotlin.String?,
        @Parameter(description = "default notification pay-load field (usage is dependent on the app and the type of event)") @Valid @RequestParam(value = "parentId", required = false) parentId: kotlin.Long?,
        @Parameter(description = "default notification pay-load field (usage is dependent on the app and the type of event)") @Valid @RequestParam(value = "parentType", required = false) parentType: kotlin.String?,
        @Parameter(description = "") @Valid @RequestParam(value = "actionCategory", required = false) actionCategory: kotlin.String?,
        @Parameter(description = "the subject line of an email #@param customPayload custom json definition of notification pay-load (usage is dependent on the app and the type of event)") @Valid @RequestParam(value = "subject", required = false) subject: kotlin.String?,
        @Parameter(description = "message string that will be displayed in on the notification") @Valid @RequestParam(value = "customMessage", required = false) customMessage: kotlin.String?,
        @Parameter(description = "only sends APNS to people who are friends of the user (still saves the notification message for feed polling)") @Valid @RequestParam(value = "friendOnlyAPNS", required = false) friendOnlyAPNS: kotlin.Boolean?,
        @Parameter(description = "latitude used to update the user's current location") @Valid @RequestParam(value = "latitude", required = false) latitude: kotlin.Double?,
        @Parameter(description = "longitude used to update the user's current location") @Valid @RequestParam(value = "longitude", required = false) longitude: kotlin.Double?
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Send MFA Challenge",
        operationId = "sendMFAChallenge",
        description = """Sends an MFA challenge (SMS or Email) for networks with MFA enabled.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/thirdparty/credential/mfa/send"
        value = [PATH_SEND_MFA_CHALLENGE],
        produces = ["*/*"]
    )
    fun sendMFAChallenge(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the third party network provider that has MFA enabled", required = true) @Valid @RequestParam(value = "networkUID", required = true) networkUID: kotlin.String,
        @NotNull @Parameter(description = "the application key", required = true) @Valid @RequestParam(value = "appKey", required = true) appKey: kotlin.String,
        @Parameter(description = "the access token to authenticate with") @Valid @RequestParam(value = "thirdPartyToken", required = false) thirdPartyToken: kotlin.String?,
        @Parameter(description = "optional id of the existing third party credential") @Valid @RequestParam(value = "thirdPartyCredentialId", required = false) thirdPartyCredentialId: kotlin.Long?,
        @Parameter(description = "the unique id of the device making the request") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Send NFT",
        operationId = "sendNFT",
        description = """Send an NFT.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation") ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/vatom/b/campaigns/send"
        value = [PATH_SEND_NFT]
    )
    fun sendNFT(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "Sirqul Account Id", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "Sirqul Application Key", required = true) @Valid @RequestParam(value = "appKey", required = true) appKey: kotlin.String,
        @NotNull @Parameter(description = "Vatom Campaign Id", required = true) @Valid @RequestParam(value = "vatomCampaignId", required = true) vatomCampaignId: kotlin.String,
        @NotNull @Parameter(description = "Vatom Parameters", required = true) @Valid @RequestParam(value = "vatomParameters", required = true) vatomParameters: kotlin.String,
        @Parameter(description = "Return raw response") @Valid @RequestParam(value = "returnRawResponse", required = false) returnRawResponse: kotlin.Boolean?
    ): ResponseEntity<Unit> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Set Driver",
        operationId = "setDriver",
        description = """Update the driver of the route.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation") ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/route/{id}/driver/{driverId}"
        value = [PATH_SET_DRIVER]
    )
    fun setDriver(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "the id of the route", required = true) @PathVariable("id") id: kotlin.Long,
        @Parameter(description = "the id of the driver", required = true) @PathVariable("driverId") driverId: kotlin.Long
    ): ResponseEntity<Unit> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Save Match Token",
        operationId = "setMatchToken",
        description = """Save user's match token to be used for profile match making""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/consumer/profile/matchToken"
        value = [PATH_SET_MATCH_TOKEN],
        produces = ["*/*"]
    )
    fun setMatchToken(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "The device id (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "The account id of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "A string of numbers") @Valid @RequestParam(value = "matchToken", required = false) matchToken: kotlin.String?,
        @Parameter(description = "Game Type (deprecated)", schema = Schema(defaultValue = "BOOPY")) @Valid @RequestParam(value = "gameType", required = false, defaultValue = "BOOPY") gameType: kotlin.String,
        @Parameter(description = "The application key") @Valid @RequestParam(value = "appKey", required = false) appKey: kotlin.String?,
        @Parameter(description = "The current latitude of the user") @Valid @RequestParam(value = "latitude", required = false) latitude: kotlin.Double?,
        @Parameter(description = "The current longitude of the user") @Valid @RequestParam(value = "longitude", required = false) longitude: kotlin.Double?
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Set Points Balance as Business",
        operationId = "setPointsBalanceAsBusiness",
        description = """Sets the points balance of a Vatom user.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation") ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/vatom/b/campaign/u/points/update"
        value = [PATH_SET_POINTS_BALANCE_AS_BUSINESS]
    )
    fun setPointsBalanceAsBusiness(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "Sirqul Account Id", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "Sirqul Application Key", required = true) @Valid @RequestParam(value = "appKey", required = true) appKey: kotlin.String,
        @NotNull @Parameter(description = "Vatom User Id", required = true) @Valid @RequestParam(value = "vatomUserId", required = true) vatomUserId: kotlin.String,
        @NotNull @Parameter(description = "Vatom Campaign Id", required = true) @Valid @RequestParam(value = "vatomCampaignId", required = true) vatomCampaignId: kotlin.String,
        @NotNull @Parameter(description = "Vatom Parameters", required = true) @Valid @RequestParam(value = "vatomParameters", required = true) vatomParameters: kotlin.String,
        @Parameter(description = "Return raw response") @Valid @RequestParam(value = "returnRawResponse", required = false) returnRawResponse: kotlin.Boolean?
    ): ResponseEntity<Unit> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Routing Simulation",
        operationId = "simulation",
        description = """Simulates routing requests.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/simulation/routing"
        value = [PATH_SIMULATION],
        produces = ["*/*"]
    )
    fun simulation(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "JSON string in the following format: ```json {   \"startDate\": 1474268400000,   \"endDate\": 1474268700000,   \"checkoutStops\": [     {       \"latitude\": 25.060453943481615,       \"longitude\": 121.57487118216957     }   ],   \"requests\": [     {       \"vehicles\": [         {           \"id\": \"customer1\",           \"name\": \"Customer 1\",           \"depot\": {             \"latitude\": 25.060453943481615,             \"longitude\": 121.57487118216957           },           \"startWindow\": 1474268464537         }       ],       \"items\": [         {           \"id\": 152712,           \"name\": \"Appliance Product\",           \"pickup\": {             \"latitude\": 25.060306635544144,             \"longitude\": 121.5750770690688           }         },         {           \"id\": 152711,           \"name\": \"TV product\",           \"pickup\": {             \"latitude\": 25.060126352576326,             \"longitude\": 121.57505023621624           }         }       ]     }   ],   \"featuredItems\": [],   \"floorPlan\": {     \"metersPerX\": 0.81493109028875,     \"metersPerY\": 1.8525267552262,     \"width\": 75,     \"height\": 50,     \"exclusions\": [       { \"x\": 14, \"y\": 49 }     ],     \"southwest\": {       \"x\": 0,       \"y\": 0,       \"latitude\": 25.05961539530497,       \"longitude\": 121.57487591737885     }   } } ``` ", required = true) @Valid @RequestParam(value = "data", required = true) `data`: kotlin.String,
        @NotNull @Parameter(description = "determines whether to run the simulation and return the results in the same request", required = true) @Valid @RequestParam(value = "realTime", required = true) realTime: kotlin.Boolean
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Buy Offer by SMS",
        operationId = "smsBuyOffer",
        description = """Recieve an SMS payload from Twillio to purchase an offer.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = TwiMLResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/sms/buyoffer/{appKey}"
        value = [PATH_SMS_BUY_OFFER],
        produces = ["application/xml"]
    )
    fun smsBuyOffer(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "the application key", required = true) @PathVariable("appKey") appKey: kotlin.String,
        @NotNull @Parameter(description = "the message of the text", required = true) @Valid @RequestParam(value = "Body", required = true) body: kotlin.String,
        @NotNull @Parameter(description = "the sender of the sms", required = true) @Valid @RequestParam(value = "From", required = true) from: kotlin.String,
        @NotNull @Parameter(description = "the type of currency", required = true) @Valid @RequestParam(value = "currencyType", required = true) currencyType: kotlin.String
    ): ResponseEntity<TwiMLResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Starts a StoryStitch video render",
        operationId = "startVideoRender",
        description = """Starts a StoryStitch video render to produce your final video, returning the status details.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = OrsonRenderResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/orson/stories/renders"
        value = [PATH_START_VIDEO_RENDER],
        produces = ["*/*"]
    )
    fun startVideoRender(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "Sirqul Account Id", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "Request Data String", required = true) @Valid @RequestParam(value = "data", required = true) `data`: kotlin.String
    ): ResponseEntity<OrsonRenderResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Batch Status",
        operationId = "statusCSV",
        description = """Checks status of batch upload.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = CsvImportResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/csvimport/batch/status"
        value = [PATH_STATUS_CSV],
        produces = ["*/*"]
    )
    fun statusCSV(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the id of the account", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "the id of the batch to get its status", required = true) @Valid @RequestParam(value = "batchId", required = true) batchId: kotlin.Long
    ): ResponseEntity<CsvImportResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Speach to Text",
        operationId = "stt",
        description = """Accepts a movie URL or uploaded file and transcribes it. You also have the option to translate it into one of our additional supported languages.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = OrsonAiSTTResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/orson/ai/stt"
        value = [PATH_STT],
        produces = ["*/*"]
    )
    fun stt(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "Sirqul Account Id", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @Parameter(description = "A third-party account id that is meaningful to your systems") @Valid @RequestParam(value = "thirdPartyAccountId", required = false) thirdPartyAccountId: kotlin.String?,
        @Parameter(description = "Source Language") @Valid @RequestParam(value = "sourceLanguage", required = false) sourceLanguage: kotlin.String?,
        @Parameter(description = "Target Language") @Valid @RequestParam(value = "targetLanguage", required = false) targetLanguage: kotlin.String?,
        @Parameter(description = "An uploaded recording to analyze (Currently limited to 10MB)") @Valid @RequestParam(value = "file", required = false) file: org.springframework.web.multipart.MultipartFile,
        @Parameter(description = "A recording file to download and analyze (Size limit: 1GB)") @Valid @RequestParam(value = "url", required = false) url: kotlin.String?,
        @Parameter(description = "When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open") @Valid @RequestParam(value = "callback", required = false) paramCallback: kotlin.String?
    ): ResponseEntity<OrsonAiSTTResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Submit Tournament Score",
        operationId = "submitTournamentScore",
        description = """Submit an array of scores for a tournament match. """,
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/tournament/score"
        value = [PATH_SUBMIT_TOURNAMENT_SCORE],
        produces = ["*/*"]
    )
    fun submitTournamentScore(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The logged in user account ID.", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "The application key.", required = true) @Valid @RequestParam(value = "appKey", required = true) appKey: kotlin.String,
        @NotNull @Parameter(description = "The missionId to score for", required = true) @Valid @RequestParam(value = "missionId", required = true) missionId: kotlin.Long,
        @NotNull @Parameter(description = "The gameId to score for", required = true) @Valid @RequestParam(value = "gameId", required = true) gameId: kotlin.Long,
        @NotNull @Parameter(description = "The packId to score for", required = true) @Valid @RequestParam(value = "packId", required = true) packId: kotlin.Long,
        @NotNull @Parameter(description = "a JSON Array of scores to submit for a tournament match ```json [   {     \"accountId\": 2,     \"points\": 3   },   {     \"accountId\": 1777662,     \"points\": 7   } ] ``` ", required = true) @Valid @RequestParam(value = "scores", required = true) scores: kotlin.String,
        @Parameter(description = "The gameLevelId to score for") @Valid @RequestParam(value = "gameLevelId", required = false) gameLevelId: kotlin.Long?
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Submit a vote for a multi-stage album tournament.",
        operationId = "submitTournamentVote",
        description = """Submit a vote for a multi-stage album tournament.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/tournament/vote"
        value = [PATH_SUBMIT_TOURNAMENT_VOTE],
        produces = ["*/*"]
    )
    fun submitTournamentVote(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The logged in user.", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "The application to target", required = true) @Valid @RequestParam(value = "appKey", required = true) appKey: kotlin.String,
        @NotNull @Parameter(description = "The tournament's primary id", required = true) @Valid @RequestParam(value = "missionId", required = true) missionId: kotlin.Long,
        @NotNull @Parameter(description = "The tournament game object the user wants to vote on", required = true) @Valid @RequestParam(value = "gameObjectId", required = true) gameObjectId: kotlin.Long,
        @Parameter(description = "The unique id of the device making the request (optional)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "When true, check if the device already voted to prevent duplicate votes from the same device", schema = Schema(defaultValue = "false")) @Valid @RequestParam(value = "checkIfDeviceAlreadyVoted", required = false, defaultValue = "false") checkIfDeviceAlreadyVoted: kotlin.Boolean
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Substitute Tournament Player",
        operationId = "substituteTournamentPlayer",
        description = """Service to replace the user's opponent in the current level - pack - mission with an AI account.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/tournament/substitute"
        value = [PATH_SUBSTITUTE_TOURNAMENT_PLAYER],
        produces = ["*/*"]
    )
    fun substituteTournamentPlayer(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the id of the logged in user", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "the id of the mission", required = true) @Valid @RequestParam(value = "missionId", required = true) missionId: kotlin.Long,
        @NotNull @Parameter(description = "the id of the pack", required = true) @Valid @RequestParam(value = "packId", required = true) packId: kotlin.Long,
        @NotNull @Parameter(description = "the id of the game level", required = true) @Valid @RequestParam(value = "gameLevelId", required = true) gameLevelId: kotlin.Long
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Summarize Topics",
        operationId = "summarizeTopics",
        description = """Takes in a string of text sentences (also known as a document) and returns a list of associated topics and their proximity score.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = OrsonAiTopicsResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/orson/ai/topics"
        value = [PATH_SUMMARIZE_TOPICS],
        produces = ["*/*"]
    )
    fun summarizeTopics(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "Sirqul Account Id", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @Parameter(description = "A third-party account id that is meaningful to your systems") @Valid @RequestParam(value = "thirdPartyAccountId", required = false) thirdPartyAccountId: kotlin.String?,
        @Parameter(description = "The text to get topics for.") @Valid @RequestParam(value = "doc", required = false) doc: kotlin.String?,
        @Parameter(description = "An uploaded recording to analyze (Currently limited to 10MB)") @Valid @RequestParam(value = "file", required = false) file: org.springframework.web.multipart.MultipartFile,
        @Parameter(description = "A recording file to download and analyze (Size limit: 1GB)") @Valid @RequestParam(value = "url", required = false) url: kotlin.String?,
        @Parameter(description = "The number of results to return") @Valid @RequestParam(value = "limit", required = false) limit: kotlin.Int?,
        @Parameter(description = "The starting offset into the total result set to start from") @Valid @RequestParam(value = "offset", required = false) offset: kotlin.Int?,
        @Parameter(description = "When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open") @Valid @RequestParam(value = "callback", required = false) paramCallback: kotlin.String?
    ): ResponseEntity<OrsonAiTopicsResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Summary Listing",
        operationId = "summaryListing",
        description = """Search for a list of summary listings from the start time up to 8 days out.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(array = ArraySchema(schema = Schema(implementation = ListingGroupResponse::class)))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/listing/summary"
        value = [PATH_SUMMARY_LISTING],
        produces = ["*/*"]
    )
    fun summaryListing(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "the account id of the user") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "the start date to search from") @Valid @RequestParam(value = "startDate", required = false) startDate: kotlin.Long?,
        @Parameter(description = "the list of categories to search on") @Valid @RequestParam(value = "categoryIds", required = false) categoryIds: kotlin.String?,
        @Parameter(description = "how far out to search, in days", schema = Schema(defaultValue = "15")) @Valid @RequestParam(value = "daysToInclude", required = false, defaultValue = "15") daysToInclude: kotlin.Int,
        @Parameter(description = "determines whether to use configured listing order ids", schema = Schema(defaultValue = "true")) @Valid @RequestParam(value = "useListingOrderIds", required = false, defaultValue = "true") useListingOrderIds: kotlin.Boolean
    ): ResponseEntity<List<ListingGroupResponse>> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Detect Technical Issues",
        operationId = "techTune",
        description = """Analyses a movie file to detect technical issues, such as too few people in frame.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = OrsonAiTechTuneResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/orson/ai/techTune"
        value = [PATH_TECH_TUNE],
        produces = ["*/*"]
    )
    fun techTune(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "Sirqul Account Id", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "Number of expected faces", required = true) @Valid @RequestParam(value = "numFacesExpected", required = true) numFacesExpected: kotlin.Int,
        @Parameter(description = "A third-party account id that is meaningful to your systems") @Valid @RequestParam(value = "thirdPartyAccountId", required = false) thirdPartyAccountId: kotlin.String?,
        @Parameter(description = "An uploaded recording to analyze (Currently limited to 10MB)") @Valid @RequestParam(value = "file", required = false) file: org.springframework.web.multipart.MultipartFile,
        @Parameter(description = "A recording file to download and analyze (Size limit: 1GB)") @Valid @RequestParam(value = "url", required = false) url: kotlin.String?,
        @Parameter(description = "When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open") @Valid @RequestParam(value = "callback", required = false) paramCallback: kotlin.String?
    ): ResponseEntity<OrsonAiTechTuneResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get Ticket Offers",
        operationId = "ticketOffers",
        description = """Get a list offers for tickets owned by sirqul.  Purchasing these will add the number of tickets to the account specified by the offer.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = TicketOfferResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/ticket/ticketoffers"
        value = [PATH_TICKET_OFFERS],
        produces = ["*/*"]
    )
    fun ticketOffers(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal
    ): ResponseEntity<TicketOfferResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Get Offers (Top)",
        operationId = "topOfferTransactions",
        description = """Gets the top active offers.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = OfferListResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/offer/top"
        value = [PATH_TOP_OFFER_TRANSACTIONS],
        produces = ["*/*"]
    )
    fun topOfferTransactions(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "The index into the record set to start with. Default is 0.", schema = Schema(defaultValue = "0")) @Valid @RequestParam(value = "start", required = false, defaultValue = "0") start: kotlin.Int,
        @Parameter(description = "The total number of record to return. Default id 20.", schema = Schema(defaultValue = "20")) @Valid @RequestParam(value = "limit", required = false, defaultValue = "20") limit: kotlin.Int
    ): ResponseEntity<OfferListResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Transfer coins from Vatom Users",
        operationId = "transferUserCoins",
        description = """Transfer coins from Vatom Users.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation") ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/vatom/u/coins/transfer"
        value = [PATH_TRANSFER_USER_COINS]
    )
    fun transferUserCoins(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "Sirqul Account Id", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "Vatom User Id", required = true) @Valid @RequestParam(value = "vatomUserId", required = true) vatomUserId: kotlin.String,
        @NotNull @Parameter(description = "Vatom Parameters", required = true) @Valid @RequestParam(value = "vatomParameters", required = true) vatomParameters: kotlin.String,
        @Parameter(description = "Return raw response") @Valid @RequestParam(value = "returnRawResponse", required = false) returnRawResponse: kotlin.Boolean?
    ): ResponseEntity<Unit> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Text to Speach",
        operationId = "tts",
        description = """Creates an audio file for the given text, with the option of language and voice selection.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = OrsonAiTTSResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/orson/ai/tts"
        value = [PATH_TTS],
        produces = ["*/*"]
    )
    fun tts(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "Sirqul Account Id", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "Text", required = true) @Valid @RequestParam(value = "text", required = true) text: kotlin.String,
        @Parameter(description = "A third-party account id that is meaningful to your systems") @Valid @RequestParam(value = "thirdPartyAccountId", required = false) thirdPartyAccountId: kotlin.String?,
        @Parameter(description = "The language to use for the speaker and incoming text") @Valid @RequestParam(value = "language", required = false) language: kotlin.String?,
        @Parameter(description = "A language-specific voice to use, or picks the language default if not provided") @Valid @RequestParam(value = "voice", required = false) voice: kotlin.String?,
        @Parameter(description = "When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open") @Valid @RequestParam(value = "callback", required = false) paramCallback: kotlin.String?
    ): ResponseEntity<OrsonAiTTSResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Unassign Employee",
        operationId = "unassignEmployee",
        description = """Unassign An existing account to be an employee""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = EmployeeResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/employee/unassign"
        value = [PATH_UNASSIGN_EMPLOYEE],
        produces = ["*/*"]
    )
    fun unassignEmployee(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The account id of the logged in user", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "The account id of the user to be unassigned", required = true) @Valid @RequestParam(value = "employeeAccountId", required = true) employeeAccountId: kotlin.Long
    ): ResponseEntity<EmployeeResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Update Achievement",
        operationId = "updateAchievement",
        description = """Updates an achievement (for developer/retailer use). User must have permissions to the application the achievement is created for.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = AchievementResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/achievement/update"
        value = [PATH_UPDATE_ACHIEVEMENT],
        produces = ["*/*"]
    )
    fun updateAchievement(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "a unique id given by the device (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "the account id of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "the achievement ID for updating an existing achievement") @Valid @RequestParam(value = "achievementId", required = false) achievementId: kotlin.Long?,
        @Parameter(description = "the analytics tag that will trigger when a user's achievement count gets updated") @Valid @RequestParam(value = "analyticsTag", required = false) analyticsTag: kotlin.String?,
        @Parameter(description = "the title of the achievement (255 character limit)") @Valid @RequestParam(value = "title", required = false) title: kotlin.String?,
        @Parameter(description = "the description of the achievement") @Valid @RequestParam(value = "description", required = false) description: kotlin.String?,
        @Parameter(description = "the rank type for updating leader boards") @Valid @RequestParam(value = "rankType", required = false) rankType: kotlin.String?,
        @Parameter(description = "determines how much the rank count is incremented") @Valid @RequestParam(value = "rankIncrement", required = false) rankIncrement: kotlin.Int?,
        @Parameter(description = "restrict scores to be above or equal to this minimum value") @Valid @RequestParam(value = "minIncrement", required = false) minIncrement: kotlin.Int?,
        @Parameter(description = "enable to ignore usage of minIncrement") @Valid @RequestParam(value = "nullMinIncrement", required = false) nullMinIncrement: kotlin.Boolean?,
        @Parameter(description = "restrict scores to be below or equal to this maximum value") @Valid @RequestParam(value = "maxIncrement", required = false) maxIncrement: kotlin.Int?,
        @Parameter(description = "enable to ignore usage of maxIncrement") @Valid @RequestParam(value = "nullMaxIncrement", required = false) nullMaxIncrement: kotlin.Boolean?,
        @Parameter(description = "determines whether the customId on analytics are used to validate a user's achievement progress.") @Valid @RequestParam(value = "validate", required = false) validate: kotlin.Boolean?,
        @Parameter(description = "if it's active or inactive") @Valid @RequestParam(value = "active", required = false) active: kotlin.Boolean?,
        @Parameter(description = "if provided will define what triggers to run after a tier is completed") @Valid @RequestParam(value = "triggerDefinition", required = false) triggerDefinition: kotlin.String?
    ): ResponseEntity<AchievementResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Update Achievement Tier",
        operationId = "updateAchievementTier",
        description = """Updates a tier of an achievement (for developer/retailer use). User must have permissions to the application the achievement is created for.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = AchievementTierResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/achievement/tier/update"
        value = [PATH_UPDATE_ACHIEVEMENT_TIER],
        produces = ["*/*"]
    )
    fun updateAchievementTier(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the achievement tier id for updating", required = true) @Valid @RequestParam(value = "achievementTierId", required = true) achievementTierId: kotlin.Long,
        @Parameter(description = "a unique id given by the device (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "the account id of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "achievement tier icon image file") @Valid @RequestParam(value = "icon", required = false) icon: org.springframework.web.multipart.MultipartFile,
        @Parameter(description = "the icon assetId, if icon is provided, icon will overrule") @Valid @RequestParam(value = "iconAssetId", required = false) iconAssetId: kotlin.Long?,
        @Parameter(description = "the title of the achievement tier") @Valid @RequestParam(value = "title", required = false) title: kotlin.String?,
        @Parameter(description = "the description of the achievement tier") @Valid @RequestParam(value = "description", required = false) description: kotlin.String?,
        @Parameter(description = "the count requirement for completing the achievement tier") @Valid @RequestParam(value = "goalCount", required = false) goalCount: kotlin.Long?,
        @Parameter(description = "The ID of the mission to associate with the achievement") @Valid @RequestParam(value = "missionId", required = false) missionId: kotlin.Long?,
        @Parameter(description = "The ID of the game to associate with the achievement") @Valid @RequestParam(value = "gameId", required = false) gameId: kotlin.Long?,
        @Parameter(description = "The ID of the pack to associate with the achievement") @Valid @RequestParam(value = "packId", required = false) packId: kotlin.Long?,
        @Parameter(description = "The ID of the game level to associate with the achievement") @Valid @RequestParam(value = "gameLevelId", required = false) gameLevelId: kotlin.Long?,
        @Parameter(description = "The ID of the game object to associate with the achievement") @Valid @RequestParam(value = "gameObjectId", required = false) gameObjectId: kotlin.Long?,
        @Parameter(description = "score all instances") @Valid @RequestParam(value = "scoreAllInstances", required = false) scoreAllInstances: kotlin.Boolean?
    ): ResponseEntity<AchievementTierResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Update Account Active Status",
        operationId = "updateActveStatus",
        description = """Activate or deactivate an account (requires appropriate permissions).""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/account/active/update"
        value = [PATH_UPDATE_ACTVE_STATUS],
        produces = ["*/*"]
    )
    fun updateActveStatus(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the account id of the user (deviceId or accountId required)", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "The account id of the user you want to modify (if this is not set, then the accountId parameter will be used instead)", required = true) @Valid @RequestParam(value = "connectionAccountId", required = true) connectionAccountId: kotlin.Long,
        @NotNull @Parameter(description = "true will activate the user and false will deactivate", required = true) @Valid @RequestParam(value = "active", required = true) active: kotlin.Boolean,
        @Parameter(description = "the device id (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "the application key that the user belongs to") @Valid @RequestParam(value = "appKey", required = false) appKey: kotlin.String?
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Update Album",
        operationId = "updateAlbumCollection",
        description = """Update an Album.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = AlbumResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/album/update"
        value = [PATH_UPDATE_ALBUM_COLLECTION],
        produces = ["*/*"]
    )
    fun updateAlbumCollection(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the ID of the album to update", required = true) @Valid @RequestParam(value = "albumId", required = true) albumId: kotlin.Long,
        @Parameter(description = "a unique ID given by the device (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "the account ID of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "Comma separated list of asset IDs to add to the album's asset list (use \"assetId\" for setting the cover of the album)") @Valid @RequestParam(value = "assetsToAdd", required = false) assetsToAdd: kotlin.String?,
        @Parameter(description = "Comma separated list of asset IDs to remove from the album's asset list") @Valid @RequestParam(value = "assetsToRemove", required = false) assetsToRemove: kotlin.String?,
        @Parameter(description = "the cover asset ID") @Valid @RequestParam(value = "assetId", required = false) assetId: kotlin.Long?,
        @Parameter(description = "a MultipartFile containing the cover image of the album (this will only be used if \"assetId\" is empty)") @Valid @RequestParam(value = "media", required = false) media: org.springframework.web.multipart.MultipartFile,
        @Parameter(description = "this can be used if the \"media\" is a link (this will only be used if \"assetId\" and media are empty)") @Valid @RequestParam(value = "mediaURL", required = false) mediaURL: kotlin.String?,
        @Parameter(description = "determines whether the album is active or inactive") @Valid @RequestParam(value = "active", required = false) active: kotlin.Boolean?,
        @Parameter(description = "the title of the album") @Valid @RequestParam(value = "title", required = false) title: kotlin.String?,
        @Parameter(description = "the start date") @Valid @RequestParam(value = "startDate", required = false) startDate: kotlin.Long?,
        @Parameter(description = "the end date") @Valid @RequestParam(value = "endDate", required = false) endDate: kotlin.Long?,
        @Parameter(description = "the tags") @Valid @RequestParam(value = "tags", required = false) tags: kotlin.String?,
        @Parameter(description = "the description of the album") @Valid @RequestParam(value = "description", required = false) description: kotlin.String?,
        @Parameter(description = "a custom field used for aggregation and searching") @Valid @RequestParam(value = "albumType", required = false) albumType: kotlin.String?,
        @Parameter(description = "a custom indexed number used for aggregation and searching") @Valid @RequestParam(value = "albumTypeId", required = false) albumTypeId: kotlin.Long?,
        @Parameter(description = "a custom string field used for aggregation and searching") @Valid @RequestParam(value = "subType", required = false) subType: kotlin.String?,
        @Parameter(description = "determines whether the album's participants have read permissions") @Valid @RequestParam(value = "publicRead", required = false) publicRead: kotlin.Boolean?,
        @Parameter(description = "determines whether the album's participants have write permissions") @Valid @RequestParam(value = "publicWrite", required = false) publicWrite: kotlin.Boolean?,
        @Parameter(description = "determines whether the album's participants have delete permissions") @Valid @RequestParam(value = "publicDelete", required = false) publicDelete: kotlin.Boolean?,
        @Parameter(description = "determines whether the album's participants have add permissions") @Valid @RequestParam(value = "publicAdd", required = false) publicAdd: kotlin.Boolean?,
        @Parameter(description = "latitude used to update the album's location") @Valid @RequestParam(value = "latitude", required = false) latitude: kotlin.Double?,
        @Parameter(description = "longitude used to update the album's location") @Valid @RequestParam(value = "longitude", required = false) longitude: kotlin.Double?,
        @Parameter(description = "the location description") @Valid @RequestParam(value = "locationDescription", required = false) locationDescription: kotlin.String?,
        @Parameter(description = "the determines the album's participants (PUBLIC - includes everyone in the system as a potential participant, PRIVATE - only considers people who have been invited as participants)", schema = Schema(allowableValues = ["PUBLIC", "PRIVATE", "FRIENDS"])) @Valid @RequestParam(value = "visibility", required = false) visibility: kotlin.String?,
        @Parameter(description = "the cell phone number") @Valid @RequestParam(value = "cellPhone", required = false) cellPhone: kotlin.String?,
        @Parameter(description = "The street address of the location") @Valid @RequestParam(value = "streetAddress", required = false) streetAddress: kotlin.String?,
        @Parameter(description = "Additional address information (such as a suite number, floor number, building name, or PO Box)") @Valid @RequestParam(value = "streetAddress2", required = false) streetAddress2: kotlin.String?,
        @Parameter(description = "The city of the location") @Valid @RequestParam(value = "city", required = false) city: kotlin.String?,
        @Parameter(description = "The state of of the location") @Valid @RequestParam(value = "state", required = false) state: kotlin.String?,
        @Parameter(description = "The postal code of the location") @Valid @RequestParam(value = "postalCode", required = false) postalCode: kotlin.String?,
        @Parameter(description = "The full address of the location which should include the street address, city, state, and postal code") @Valid @RequestParam(value = "fullAddress", required = false) fullAddress: kotlin.String?,
        @Parameter(description = "determines whether the album is posted anonymously") @Valid @RequestParam(value = "anonymous", required = false) anonymous: kotlin.Boolean?,
        @Parameter(description = "External custom client defined data") @Valid @RequestParam(value = "metaData", required = false) metaData: kotlin.String?,
        @Parameter(description = "comma separated category ids string associated with the Album") @Valid @RequestParam(value = "categoryIds", required = false) categoryIds: kotlin.String?,
        @Parameter(description = "comma separated filter ids string associated with the Album") @Valid @RequestParam(value = "categoryFilterIds", required = false) categoryFilterIds: kotlin.String?,
        @Parameter(description = "comma separated audience ids string associated with the album") @Valid @RequestParam(value = "audienceIds", required = false) audienceIds: kotlin.String?,
        @Parameter(description = "comma separated audience ids to add to the album") @Valid @RequestParam(value = "audienceIdsToAdd", required = false) audienceIdsToAdd: kotlin.String?,
        @Parameter(description = "comma separated audience ids to remove from the album (overrides audienceIds and audienceIdsToAdd)") @Valid @RequestParam(value = "audienceIdsToRemove", required = false) audienceIdsToRemove: kotlin.String?,
        @Parameter(description = "determines whether to include all app users as members (only admins of the app can do this)") @Valid @RequestParam(value = "includeAllAppUsersAsMembers", required = false) includeAllAppUsersAsMembers: kotlin.Boolean?,
        @Parameter(description = "determines whether to include all users of the audiences as members (only admins of the app can do this)") @Valid @RequestParam(value = "includeAudiencesAsMembers", required = false) includeAudiencesAsMembers: kotlin.Boolean?,
        @Parameter(description = "determines whether to use ands or ors when using the audience list to add users") @Valid @RequestParam(value = "audienceOperator", required = false) audienceOperator: kotlin.String?,
        @Parameter(description = "sets a linked object so that it can be returned as part of the album response") @Valid @RequestParam(value = "linkedObjectType", required = false) linkedObjectType: kotlin.String?,
        @Parameter(description = "sets a linked object id so that it can be returned as part of the album response") @Valid @RequestParam(value = "linkedObjectId", required = false) linkedObjectId: kotlin.Long?,
        @Parameter(description = "determines whether the album should be indexed immediately") @Valid @RequestParam(value = "indexNow", required = false) indexNow: kotlin.Boolean?
    ): ResponseEntity<AlbumResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Update Application",
        operationId = "updateApplication",
        description = """Update an application record""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = ApplicationResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/application/update"
        value = [PATH_UPDATE_APPLICATION],
        produces = ["*/*"]
    )
    fun updateApplication(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The application key for updating an existing application", required = true) @Valid @RequestParam(value = "appKey", required = true) appKey: kotlin.String,
        @NotNull @Parameter(description = "The name of the application", required = true) @Valid @RequestParam(value = "appName", required = true) appName: kotlin.String,
        @Parameter(description = "The unique id of the device making the request (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "The account id of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "The description of the application") @Valid @RequestParam(value = "about", required = false) about: kotlin.String?,
        @Parameter(description = "The application bundle identifier (format - com.company.appName)") @Valid @RequestParam(value = "bundleId", required = false) bundleId: kotlin.String?,
        @Parameter(description = "The application icon asset id") @Valid @RequestParam(value = "appIconAssetId", required = false) appIconAssetId: kotlin.Long?,
        @Parameter(description = "The application logo asset id") @Valid @RequestParam(value = "appLogoAssetId", required = false) appLogoAssetId: kotlin.Long?,
        @Parameter(description = "The Facebook application id") @Valid @RequestParam(value = "facebookAppId", required = false) facebookAppId: kotlin.String?,
        @Parameter(description = "The Facebook application secret") @Valid @RequestParam(value = "facebookAppSecret", required = false) facebookAppSecret: kotlin.String?,
        @Parameter(description = "This is the either the 'server key' or 'browser key' generated from google to enable Google Cloud Messaging") @Valid @RequestParam(value = "googleApiKey", required = false) googleApiKey: kotlin.String?,
        @Parameter(description = "Determines whether to update the EULA date") @Valid @RequestParam(value = "updateEULADate", required = false) updateEULADate: kotlin.Boolean?,
        @Parameter(description = "The EULA version") @Valid @RequestParam(value = "eulaVersion", required = false) eulaVersion: kotlin.String?,
        @Parameter(description = "The landing page URL") @Valid @RequestParam(value = "landingPageUrl", required = false) landingPageUrl: kotlin.String?,
        @Parameter(description = "Determines whether to show the application in the activity feed") @Valid @RequestParam(value = "showInActivities", required = false) showInActivities: kotlin.Boolean?,
        @Parameter(description = "The description of the application in the activity feed") @Valid @RequestParam(value = "activityDescription", required = false) activityDescription: kotlin.String?,
        @Parameter(description = "The text to display on the invite page") @Valid @RequestParam(value = "inviteWelcomeText", required = false) inviteWelcomeText: kotlin.String?,
        @Parameter(description = "The url to the application invite page") @Valid @RequestParam(value = "invitePageUrl", required = false) invitePageUrl: kotlin.String?,
        @Parameter(description = "The protocal the app uses to load the app via a browser") @Valid @RequestParam(value = "urlScheme", required = false) urlScheme: kotlin.String?,
        @Parameter(description = "A json object with a list of supported platforms.  ```json {   \"platforms\": [     {       \"deviceId\": 1,       \"minimum\": 230,       \"maximum\": 421,       \"downloadUrl\": \"http://app.store.com/download\",       \"description\": \"description and version info\"     }   ] } ``` ") @Valid @RequestParam(value = "platforms", required = false) platforms: kotlin.String?,
        @Parameter(description = "Json formatted downloadUrls.  ```json {   \"ios\": \"the-url-to-app-store\",    \"android\": \"the-url-to-google-play\" } ```  ") @Valid @RequestParam(value = "downloadUrls", required = false) downloadUrls: kotlin.String?,
        @Parameter(description = "List of categories to apply") @Valid @RequestParam(value = "categoryIds", required = false) categoryIds: kotlin.String?,
        @Parameter(description = "The type of scoring this application will use {GAME_LEVEL, GAME_OBJECT", schema = Schema(allowableValues = ["GAME_LEVEL", "GAME_OBJECT"], defaultValue = "GAME_LEVEL")) @Valid @RequestParam(value = "scoringType", required = false, defaultValue = "GAME_LEVEL") scoringType: kotlin.String,
        @Parameter(description = "The cost of hints", schema = Schema(defaultValue = "11")) @Valid @RequestParam(value = "hintCost", required = false, defaultValue = "11") hintCost: kotlin.Int,
        @Parameter(description = "The maximum score that will be possible", schema = Schema(defaultValue = "125")) @Valid @RequestParam(value = "maxScore", required = false, defaultValue = "125") maxScore: kotlin.Int,
        @Parameter(description = "The point-to-ticket conversion ratio", schema = Schema(defaultValue = "0.037f")) @Valid @RequestParam(value = "ticketsPerPoint", required = false, defaultValue = "0.037f") ticketsPerPoint: kotlin.Float,
        @Parameter(description = "Determines whether the application uses services to save custom game objects", schema = Schema(defaultValue = "true")) @Valid @RequestParam(value = "hasGameData", required = false, defaultValue = "true") hasGameData: kotlin.Boolean,
        @Parameter(description = "Public Notifications") @Valid @RequestParam(value = "publicNotifications", required = false) publicNotifications: kotlin.Boolean?,
        @Parameter(description = "Use Matching Algorithm") @Valid @RequestParam(value = "useMatchingAlgorithm", required = false) useMatchingAlgorithm: kotlin.Boolean?,
        @Parameter(description = "Determines whether earned tickets are applied across all applications", schema = Schema(defaultValue = "false")) @Valid @RequestParam(value = "globalTickets", required = false, defaultValue = "false") globalTickets: kotlin.Boolean,
        @Parameter(description = "The current build version of the application", schema = Schema(defaultValue = "1f")) @Valid @RequestParam(value = "buildVersion", required = false, defaultValue = "1f") buildVersion: kotlin.Float,
        @Parameter(description = "The current API version the application uses") @Valid @RequestParam(value = "apiVersion", required = false) apiVersion: kotlin.Float?,
        @Parameter(description = "The name of the placement") @Valid @RequestParam(value = "placementName", required = false) placementName: kotlin.String?,
        @Parameter(description = "The description of the placement") @Valid @RequestParam(value = "placementDescription", required = false) placementDescription: kotlin.String?,
        @Parameter(description = "The ad placement size {BANNER, LEADERBOARD, SKYSCRAPER, INTERSTITIAL, CUSTOM (this is required if a placements is to be created)", schema = Schema(allowableValues = ["CONFIG", "BANNER", "LEADERBOARD", "SKYSCRAPER", "VIDEO", "ZIP", "INTERSTITIAL", "CUSTOM1", "CUSTOM2", "CUSTOM3", "CUSTOM4", "CUSTOM5", "CUSTOM6", "CUSTOM7", "CUSTOM8", "CUSTOM9", "CUSTOM10"])) @Valid @RequestParam(value = "placementSize", required = false) placementSize: kotlin.String?,
        @Parameter(description = "The height of a custom ad size") @Valid @RequestParam(value = "placementHeight", required = false) placementHeight: kotlin.Int?,
        @Parameter(description = "The width of a custom ad size") @Valid @RequestParam(value = "placementWidth", required = false) placementWidth: kotlin.Int?,
        @Parameter(description = "The refresh interval in seconds") @Valid @RequestParam(value = "placementRefreshInterval", required = false) placementRefreshInterval: kotlin.Int?,
        @Parameter(description = "Generate a custom object store to use", schema = Schema(defaultValue = "true")) @Valid @RequestParam(value = "createObjectStore", required = false, defaultValue = "true") createObjectStore: kotlin.Boolean,
        @Parameter(description = "Determine whether or not public content requires admin approval before it becomes public", schema = Schema(defaultValue = "false")) @Valid @RequestParam(value = "publicContentApproval", required = false, defaultValue = "false") publicContentApproval: kotlin.Boolean,
        @Parameter(description = "Determines whether the application uses production or sandbox services", schema = Schema(defaultValue = "false")) @Valid @RequestParam(value = "productionMode", required = false, defaultValue = "false") productionMode: kotlin.Boolean,
        @Parameter(description = "Minimum Session Length") @Valid @RequestParam(value = "minimumSessionLength", required = false) minimumSessionLength: kotlin.Int?,
        @Parameter(description = "Session Gap Length") @Valid @RequestParam(value = "sessionGapLength", required = false) sessionGapLength: kotlin.Int?,
        @Parameter(description = "Local Ads Enabled", schema = Schema(defaultValue = "false")) @Valid @RequestParam(value = "localAdsEnabled", required = false, defaultValue = "false") localAdsEnabled: kotlin.Boolean,
        @Parameter(description = "Sqoot Api Key") @Valid @RequestParam(value = "sqootApiKey", required = false) sqootApiKey: kotlin.String?,
        @Parameter(description = "Determines how to process trilateration data. Possible values include: DEFAULT, FINGERPRINT", schema = Schema(allowableValues = ["DEFAULT", "FINGERPRINT", "FINGERPRINT_V2"], defaultValue = "FINGERPRINT")) @Valid @RequestParam(value = "trilatProcessingType", required = false, defaultValue = "FINGERPRINT") trilatProcessingType: kotlin.String,
        @Parameter(description = "Determines what the maximum sample size during trilateration") @Valid @RequestParam(value = "maxSampleSize", required = false) maxSampleSize: kotlin.Int?,
        @Parameter(description = "Determines what the minimum acceptable RSSI value") @Valid @RequestParam(value = "minRSSI", required = false) minRSSI: kotlin.Double?,
        @Parameter(description = "List modules allowed to be served by the server, possible values include: COMMON, MEDIA, OFFER, GAME, SOCIAL, CONSUMER_WEBSITE, ALL", schema = Schema(defaultValue = "ALL")) @Valid @RequestParam(value = "modules", required = false, defaultValue = "ALL") modules: kotlin.String,
        @Parameter(description = "How many servers the license will support", schema = Schema(defaultValue = "1")) @Valid @RequestParam(value = "authorizedCount", required = false, defaultValue = "1") authorizedCount: kotlin.Int,
        @Parameter(description = "The list of ip addresses of servers the license will support, leave null for any server") @Valid @RequestParam(value = "authorizedServers", required = false) authorizedServers: kotlin.String?,
        @Parameter(description = "Sets the default timezone for the app (used for leaderboards and other time specific content)") @Valid @RequestParam(value = "defaultTimezone", required = false) defaultTimezone: kotlin.String?,
        @Parameter(description = "SMTP Pass") @Valid @RequestParam(value = "smtpPass", required = false) smtpPass: kotlin.String?,
        @Parameter(description = "The application meta data. Defined by the client") @Valid @RequestParam(value = "metaData", required = false) metaData: kotlin.String?,
        @Parameter(description = "The ad placement meta data. Defined by the client") @Valid @RequestParam(value = "placementMetaData", required = false) placementMetaData: kotlin.String?,
        @Parameter(description = "Create floor tables for Ips", schema = Schema(defaultValue = "false")) @Valid @RequestParam(value = "ipsFloor", required = false, defaultValue = "false") ipsFloor: kotlin.Boolean,
        @Parameter(description = "Enables setting the APNS badge value in the payload", schema = Schema(defaultValue = "true")) @Valid @RequestParam(value = "enableAPNSBadge", required = false, defaultValue = "true") enableAPNSBadge: kotlin.Boolean,
        @Parameter(description = "Enables using the application in session reports", schema = Schema(defaultValue = "true")) @Valid @RequestParam(value = "includeInReport", required = false, defaultValue = "true") includeInReport: kotlin.Boolean,
        @Parameter(description = "Sets the default filter to use (if none is passed in) for certain search APIs including Album Search.") @Valid @RequestParam(value = "defaultAppFilterId", required = false) defaultAppFilterId: kotlin.Long?,
        @Parameter(description = "Enables whether the default welcome email will be sent for new app users") @Valid @RequestParam(value = "enableWelcomeEmail", required = false) enableWelcomeEmail: kotlin.Boolean?,
        @Parameter(description = "The Apple Application ID") @Valid @RequestParam(value = "appleAppId", required = false) appleAppId: kotlin.String?,
        @Parameter(description = "The Apple Team ID") @Valid @RequestParam(value = "appleTeamId", required = false) appleTeamId: kotlin.String?,
        @Parameter(description = "The Apple Auth Key ID") @Valid @RequestParam(value = "appleAuthKeyId", required = false) appleAuthKeyId: kotlin.String?,
        @Parameter(description = "The Apple Auth Signin Key (p8) File") @Valid @RequestParam(value = "appleAuthKey", required = false) appleAuthKey: org.springframework.web.multipart.MultipartFile,
        @Parameter(description = "The Apple Issuer ID") @Valid @RequestParam(value = "appleIssuerId", required = false) appleIssuerId: kotlin.String?,
        @Parameter(description = "The Apple App Store Key ID") @Valid @RequestParam(value = "appStoreKeyId", required = false) appStoreKeyId: kotlin.String?,
        @Parameter(description = "The Apple App Store Key (p8) File") @Valid @RequestParam(value = "appStoreKey", required = false) appStoreKey: org.springframework.web.multipart.MultipartFile,
        @Parameter(description = "This is the private key file for your Google service account.") @Valid @RequestParam(value = "googlePrivateKeyFile", required = false) googlePrivateKeyFile: org.springframework.web.multipart.MultipartFile,
        @Parameter(description = "Authorize Net Api Key") @Valid @RequestParam(value = "authorizeNetApiKey", required = false) authorizeNetApiKey: kotlin.String?,
        @Parameter(description = "Authorize Net Transaction Key") @Valid @RequestParam(value = "authorizeNetTransactionKey", required = false) authorizeNetTransactionKey: kotlin.String?,
        @Parameter(description = "Email Sender") @Valid @RequestParam(value = "emailSender", required = false) emailSender: kotlin.String?,
        @Parameter(description = "SMTP User") @Valid @RequestParam(value = "smtpUser", required = false) smtpUser: kotlin.String?,
        @Parameter(description = "SMTP Host") @Valid @RequestParam(value = "smtpHost", required = false) smtpHost: kotlin.String?,
        @Parameter(description = "Vatom Business Id") @Valid @RequestParam(value = "vatomBusinessId", required = false) vatomBusinessId: kotlin.String?,
        @Parameter(description = "Vatom REST Client Id") @Valid @RequestParam(value = "vatomRestClientId", required = false) vatomRestClientId: kotlin.String?,
        @Parameter(description = "Vatom Secret Key") @Valid @RequestParam(value = "vatomRestSecretKey", required = false) vatomRestSecretKey: kotlin.String?,
        @Parameter(description = "Twilio Account SID") @Valid @RequestParam(value = "twilioAccountSID", required = false) twilioAccountSID: kotlin.String?,
        @Parameter(description = "Twilio Auth Token") @Valid @RequestParam(value = "twilioAuthToken", required = false) twilioAuthToken: kotlin.String?,
        @Parameter(description = "Twilio Sender Phone Number") @Valid @RequestParam(value = "twilioSenderPhoneNumber", required = false) twilioSenderPhoneNumber: kotlin.String?,
        @Parameter(description = "OpenAI Secret API Key") @Valid @RequestParam(value = "openAISecretKey", required = false) openAISecretKey: kotlin.String?
    ): ResponseEntity<ApplicationResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Change Appliation Status",
        operationId = "updateApplicationActive",
        description = """Set the application's active flag to true/false. This effectively activates or deactivates the application.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/application/active"
        value = [PATH_UPDATE_APPLICATION_ACTIVE],
        produces = ["*/*"]
    )
    fun updateApplicationActive(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The account used to perform the delete, must have rights to edit the application.", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "The key of the application to be deleted", required = true) @Valid @RequestParam(value = "appKey", required = true) appKey: kotlin.String,
        @NotNull @Parameter(description = "If true then set to active, false otherwise", required = true) @Valid @RequestParam(value = "active", required = true) active: kotlin.Boolean
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Update AppConfig",
        operationId = "updateApplicationConfig",
        description = """pdates an existing application configuration. If the configVersion provided already exists for the given app the application configuration won't be updated.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = ApplicationConfigResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/appconfig/update"
        value = [PATH_UPDATE_APPLICATION_CONFIG],
        produces = ["*/*"]
    )
    fun updateApplicationConfig(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The account ID of the user", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "The config ID of the application configuration to update", required = true) @Valid @RequestParam(value = "configId", required = true) configId: kotlin.Long,
        @Parameter(description = "The application key that the updated applicationConfig will be associated to") @Valid @RequestParam(value = "appKey", required = false) appKey: kotlin.String?,
        @Parameter(description = "The application configuration, has to be unique within the application") @Valid @RequestParam(value = "configVersion", required = false) configVersion: kotlin.String?,
        @Parameter(description = "The json assetId that stores the configuration detail.") @Valid @RequestParam(value = "assetId", required = false) assetId: kotlin.Long?,
        @Parameter(description = "The retailer id for retailer specific configurations") @Valid @RequestParam(value = "retailerId", required = false) retailerId: kotlin.Long?,
        @Parameter(description = "The retailer location id for retailer location specific configurations") @Valid @RequestParam(value = "retailerLocationId", required = false) retailerLocationId: kotlin.Long?,
        @Parameter(description = "The device udid for device specific configurations") @Valid @RequestParam(value = "udid", required = false) udid: kotlin.String?
    ): ResponseEntity<ApplicationConfigResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Update Ad Placement",
        operationId = "updateApplicationPlacement",
        description = """Updates an ad placement for an application.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = PlacementResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/application/placement/update"
        value = [PATH_UPDATE_APPLICATION_PLACEMENT],
        produces = ["*/*"]
    )
    fun updateApplicationPlacement(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The id of the placement to update, the user must have rights to the application the ad placement is for", required = true) @Valid @RequestParam(value = "placementId", required = true) placementId: kotlin.Long,
        @Parameter(description = "The unique id of the device making the request (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "The account id of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "The name of the placement") @Valid @RequestParam(value = "name", required = false) name: kotlin.String?,
        @Parameter(description = "The description of the placement") @Valid @RequestParam(value = "description", required = false) description: kotlin.String?,
        @Parameter(description = "The ad placement size {BANNER, LEADERBOARD, SKYSCRAPER, INTERSTITIAL, CUSTOM", schema = Schema(allowableValues = ["CONFIG", "BANNER", "LEADERBOARD", "SKYSCRAPER", "VIDEO", "ZIP", "INTERSTITIAL", "CUSTOM1", "CUSTOM2", "CUSTOM3", "CUSTOM4", "CUSTOM5", "CUSTOM6", "CUSTOM7", "CUSTOM8", "CUSTOM9", "CUSTOM10"])) @Valid @RequestParam(value = "size", required = false) size: kotlin.String?,
        @Parameter(description = "The height of a custom ad size") @Valid @RequestParam(value = "height", required = false) height: kotlin.Int?,
        @Parameter(description = "The width of a custom ad size") @Valid @RequestParam(value = "width", required = false) width: kotlin.Int?,
        @Parameter(description = "The refresh interval in seconds") @Valid @RequestParam(value = "refreshInterval", required = false) refreshInterval: kotlin.Int?,
        @Parameter(description = "Default Image Id") @Valid @RequestParam(value = "defaultImageId", required = false) defaultImageId: kotlin.Long?,
        @Parameter(description = "Active") @Valid @RequestParam(value = "active", required = false) active: kotlin.Boolean?
    ): ResponseEntity<PlacementResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Update Asset",
        operationId = "updateAsset",
        description = """Updates an asset's meta data. If an album reference is passed in, the participants with write permissions are allowed to edit the asset. Otherwise, only the asset up-loader has permission to edit the data.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/asset/update"
        value = [PATH_UPDATE_ASSET],
        produces = ["*/*"]
    )
    fun updateAsset(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the ID of the asset to update", required = true) @Valid @RequestParam(value = "assetId", required = true) assetId: kotlin.Long,
        @Parameter(description = "a unique ID given by the device (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "the account ID of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "the ID of the album to check user permissions") @Valid @RequestParam(value = "albumId", required = false) albumId: kotlin.Long?,
        @Parameter(description = "the ID of the attached asset") @Valid @RequestParam(value = "attachedAssetId", required = false) attachedAssetId: kotlin.Long?,
        @Parameter(description = "the version code") @Valid @RequestParam(value = "versionCode", required = false) versionCode: kotlin.Int?,
        @Parameter(description = "the version name") @Valid @RequestParam(value = "versionName", required = false) versionName: kotlin.String?,
        @Parameter(description = "External custom client defined data") @Valid @RequestParam(value = "metaData", required = false) metaData: kotlin.String?,
        @Parameter(description = "the caption") @Valid @RequestParam(value = "caption", required = false) caption: kotlin.String?,
        @Parameter(description = "the asset type") @Valid @RequestParam(value = "assetType", required = false) assetType: kotlin.String?,
        @Parameter(description = "approval status for the asset") @Valid @RequestParam(value = "approvalStatus", required = false) approvalStatus: kotlin.String?,
        @Parameter(description = "account id assigned to the asset") @Valid @RequestParam(value = "assignedAccountId", required = false) assignedAccountId: kotlin.Long?,
        @Parameter(description = "a MultipartFile containing the mimetype, etc") @Valid @RequestParam(value = "media", required = false) media: org.springframework.web.multipart.MultipartFile,
        @Parameter(description = "this can be used if the \"media\" is a link (optional)") @Valid @RequestParam(value = "mediaUrl", required = false) mediaUrl: kotlin.String?,
        @Parameter(description = "the media content as a string (optional)") @Valid @RequestParam(value = "mediaString", required = false) mediaString: kotlin.String?,
        @Parameter(description = "file name for mediaString (optional)") @Valid @RequestParam(value = "mediaStringFileName", required = false) mediaStringFileName: kotlin.String?,
        @Parameter(description = "content type for mediaString (optional)") @Valid @RequestParam(value = "mediaStringContentType", required = false) mediaStringContentType: kotlin.String?,
        @Parameter(description = "the media height (optional)") @Valid @RequestParam(value = "mediaHeight", required = false) mediaHeight: kotlin.Int?,
        @Parameter(description = "the media width (optional)") @Valid @RequestParam(value = "mediaWidth", required = false) mediaWidth: kotlin.Int?,
        @Parameter(description = "a MultipartFile containing an asset that the \"media\" file references (optional). Example: to upload a video the \"media\" file should contain a screen capture and the \"attachedMedia\" should be the actual video.") @Valid @RequestParam(value = "attachedMedia", required = false) attachedMedia: org.springframework.web.multipart.MultipartFile,
        @Parameter(description = "this can be used if the \"attachedMedia\" is a link (i.e. a Youtube video, etc) (optional)") @Valid @RequestParam(value = "attachedMediaUrl", required = false) attachedMediaUrl: kotlin.String?,
        @Parameter(description = "attached media content as a string (optional)") @Valid @RequestParam(value = "attachedMediaString", required = false) attachedMediaString: kotlin.String?,
        @Parameter(description = "file name for attachedMediaString (optional)") @Valid @RequestParam(value = "attachedMediaStringFileName", required = false) attachedMediaStringFileName: kotlin.String?,
        @Parameter(description = "content type for attachedMediaString (optional)") @Valid @RequestParam(value = "attachedMediaStringContentType", required = false) attachedMediaStringContentType: kotlin.String?,
        @Parameter(description = "the attached media height (optional)") @Valid @RequestParam(value = "attachedMediaHeight", required = false) attachedMediaHeight: kotlin.Int?,
        @Parameter(description = "the attached media width (optional)") @Valid @RequestParam(value = "attachedMediaWidth", required = false) attachedMediaWidth: kotlin.Int?,
        @Parameter(description = "the location description") @Valid @RequestParam(value = "locationDescription", required = false) locationDescription: kotlin.String?,
        @Parameter(description = "search tags") @Valid @RequestParam(value = "searchTags", required = false) searchTags: kotlin.String?,
        @Parameter(description = "the application key") @Valid @RequestParam(value = "appKey", required = false) appKey: kotlin.String?,
        @Parameter(description = "latitude used to update the asset's location") @Valid @RequestParam(value = "latitude", required = false) latitude: kotlin.Double?,
        @Parameter(description = "longitude used to update the asset's location") @Valid @RequestParam(value = "longitude", required = false) longitude: kotlin.Double?
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Update Audience",
        operationId = "updateAudience",
        description = """Update a user defined audience.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = AudienceResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/audience/update"
        value = [PATH_UPDATE_AUDIENCE],
        produces = ["*/*"]
    )
    fun updateAudience(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The logged in user.", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "The id of the audience to update.", required = true) @Valid @RequestParam(value = "audienceId", required = true) audienceId: kotlin.Long,
        @Parameter(description = "The name of the audience") @Valid @RequestParam(value = "name", required = false) name: kotlin.String?,
        @Parameter(description = "The description of the audience") @Valid @RequestParam(value = "description", required = false) description: kotlin.String?,
        @Parameter(description = "The search tags") @Valid @RequestParam(value = "searchTags", required = false) searchTags: kotlin.String?,
        @Parameter(description = "The gender; possible values are: MALE, FEMALE, ANY") @Valid @RequestParam(value = "gender", required = false) gender: kotlin.String?,
        @Parameter(description = "The list of age groups, comma separated; possible values are AGE_0_13, AGE_14_17, AGE_18_22, AGE_23_30, AGE_31_54, AGE_55_PLUS, AGE_ANY (to reset to none)") @Valid @RequestParam(value = "ageGroups", required = false) ageGroups: kotlin.String?,
        @Parameter(description = "The list of category ids, comma separated; possible values are retrieved via /api/{version}/category/search (pass in id values)") @Valid @RequestParam(value = "categoryIds", required = false) categoryIds: kotlin.String?,
        @Parameter(description = "The list of application ids, comma separated; possible values are retrieved via /api/{version}/application/list (pass in id values)") @Valid @RequestParam(value = "applicationIds", required = false) applicationIds: kotlin.String?,
        @Parameter(description = "The experience level of the player; possible values are: ANY, NEW, BEGINNER, INTERMEDIATE, EXPERT") @Valid @RequestParam(value = "gameExperienceLevel", required = false) gameExperienceLevel: kotlin.String?,
        @Parameter(description = "(Deprecated) Use deviceIds. The list of targeted device names, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in name values)") @Valid @RequestParam(value = "devices", required = false) devices: kotlin.String?,
        @Parameter(description = "The list of targeted device ids, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in id values)") @Valid @RequestParam(value = "deviceIds", required = false) deviceIds: kotlin.String?,
        @Parameter(description = "The list of targeted device version ranges that are aligned with the provided devices list, comma separated (examples: 2.3-X, 0-5.1.4, 4.3.1-6.1.4)") @Valid @RequestParam(value = "deviceVersions", required = false) deviceVersions: kotlin.String?,
        @Parameter(description = "The list of locations to build the center around; comma separated list of latitude/longitude pairs (example: lat1,long1,lat2,long2)") @Valid @RequestParam(value = "locations", required = false) locations: kotlin.String?,
        @Parameter(description = "The list of radius of influence for the audience, in miles; comma separated list. Either provide 1 to be applied to all location pairs or a matching list to each lat/long pair.") @Valid @RequestParam(value = "radius", required = false) radius: kotlin.String?,
        @Parameter(description = "if audience is active") @Valid @RequestParam(value = "active", required = false) active: kotlin.Boolean?,
        @Parameter(description = "If true, then notify matching users when they are inside the radius") @Valid @RequestParam(value = "sendSuggestion", required = false) sendSuggestion: kotlin.Boolean?,
        @Parameter(description = "Seconds from the start time of an event") @Valid @RequestParam(value = "startTimeOffset", required = false) startTimeOffset: kotlin.Int?,
        @Parameter(description = "Seconds from the end time of an event") @Valid @RequestParam(value = "endTimeOffset", required = false) endTimeOffset: kotlin.Int?,
        @Parameter(description = "the associate description") @Valid @RequestParam(value = "associateDescription", required = false) associateDescription: kotlin.String?,
        @Parameter(description = "The type of the object to center the audience geofence") @Valid @RequestParam(value = "associateType", required = false) associateType: kotlin.String?,
        @Parameter(description = "The ID of the object to center the audience geofence") @Valid @RequestParam(value = "associateId", required = false) associateId: kotlin.Long?,
        @Parameter(description = "Optional grouping id for the audience") @Valid @RequestParam(value = "groupingId", required = false) groupingId: kotlin.String?,
        @Parameter(description = "External custom client defined data") @Valid @RequestParam(value = "metaData", required = false) metaData: kotlin.String?,
        @Parameter(description = "Visibility of the audience") @Valid @RequestParam(value = "visibility", required = false) visibility: kotlin.String?,
        @Parameter(description = "Type of audience") @Valid @RequestParam(value = "audienceType", required = false) audienceType: kotlin.String?,
        @Parameter(description = "Use order for cohort") @Valid @RequestParam(value = "useOrder", required = false) useOrder: kotlin.Boolean?,
        @Parameter(description = "Cohort data for \"cohort\" audience type") @Valid @RequestParam(value = "cohortRegionsData", required = false) cohortRegionsData: kotlin.String?,
        @Parameter(description = "Filter results by application key") @Valid @RequestParam(value = "appKey", required = false) appKey: kotlin.String?,
        @Parameter(description = "Trilateration types") @Valid @RequestParam(value = "trilaterationTypes", required = false) trilaterationTypes: kotlin.String?,
        @Parameter(description = "If true, makes sure the audience name is unique") @Valid @RequestParam(value = "uniqueName", required = false) uniqueName: kotlin.Boolean?
    ): ResponseEntity<AudienceResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Update Bid",
        operationId = "updateBid",
        description = """Updates a bid on a biddable object""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = BidResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/bid/update"
        value = [PATH_UPDATE_BID],
        produces = ["*/*"]
    )
    fun updateBid(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The bid id", required = true) @Valid @RequestParam(value = "bidId", required = true) bidId: kotlin.Long,
        @Parameter(description = "The device id (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "The account id of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "The bid amount for views. For ads, this is the amount that will be taken for each impression.") @Valid @RequestParam(value = "amountPerView", required = false) amountPerView: kotlin.Double?,
        @Parameter(description = "The bid amount for actions. For ads, this is the amount that will be taken for each click.") @Valid @RequestParam(value = "amountPerAction", required = false) amountPerAction: kotlin.Double?,
        @Parameter(description = "The allocated budget amount that will be used") @Valid @RequestParam(value = "budgetAmount", required = false) budgetAmount: kotlin.Double?,
        @Parameter(description = "The schedule for when the allocated budget amount is reset") @Valid @RequestParam(value = "budgetSchedule", required = false) budgetSchedule: kotlin.String?
    ): ResponseEntity<BidResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Update Billable",
        operationId = "updateBillableEntity",
        description = """Updates the billable record for an account""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = BillableEntityResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/billable/update"
        value = [PATH_UPDATE_BILLABLE_ENTITY],
        produces = ["*/*"]
    )
    fun updateBillableEntity(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "The unique device identifier that made the request (either deviceId or accountId must be used)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "The unique accountId that made the request (either deviceId or accountId must be used). The account must have rights to edit the billable entity.") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "The name of the entity responsible for billing ") @Valid @RequestParam(value = "name", required = false) name: kotlin.String?,
        @Parameter(description = "The street address of the billable entity") @Valid @RequestParam(value = "streetAddress", required = false) streetAddress: kotlin.String?,
        @Parameter(description = "Additional address information (such as a suite number, floor number, building name, or PO Box) ") @Valid @RequestParam(value = "streetAddress2", required = false) streetAddress2: kotlin.String?,
        @Parameter(description = "The city of the billable entity") @Valid @RequestParam(value = "city", required = false) city: kotlin.String?,
        @Parameter(description = "The state of the billable entity") @Valid @RequestParam(value = "state", required = false) state: kotlin.String?,
        @Parameter(description = "The postal code of the billable entity") @Valid @RequestParam(value = "postalCode", required = false) postalCode: kotlin.String?,
        @Parameter(description = "The business phone of the billable entity") @Valid @RequestParam(value = "businessPhone", required = false) businessPhone: kotlin.String?,
        @Parameter(description = "The business phone extension of the billable entity") @Valid @RequestParam(value = "businessPhoneExt", required = false) businessPhoneExt: kotlin.String?,
        @Parameter(description = "Authorize Net Api Key of the billable entity") @Valid @RequestParam(value = "authorizeNetApiKey", required = false) authorizeNetApiKey: kotlin.String?,
        @Parameter(description = "Authorize Net Transaction Key of the billable entity") @Valid @RequestParam(value = "authorizeNetTransactionKey", required = false) authorizeNetTransactionKey: kotlin.String?
    ): ResponseEntity<BillableEntityResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Fund coins for a Business",
        operationId = "updateBusinessCoins",
        description = """Fund/update coins for a Businesss.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation") ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/vatom/b/coins/update"
        value = [PATH_UPDATE_BUSINESS_COINS]
    )
    fun updateBusinessCoins(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "Sirqul Account Id", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "Sirqul Application Key", required = true) @Valid @RequestParam(value = "appKey", required = true) appKey: kotlin.String,
        @NotNull @Parameter(description = "Vatom Parameters", required = true) @Valid @RequestParam(value = "vatomParameters", required = true) vatomParameters: kotlin.String,
        @Parameter(description = "Return raw response") @Valid @RequestParam(value = "returnRawResponse", required = false) returnRawResponse: kotlin.Boolean?
    ): ResponseEntity<Unit> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Update Cargo Type",
        operationId = "updateCargoType",
        description = """Update an existing cargo type""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = CargoType::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.PUT],
        // "/api/{version}/cargo/type/{cargoTypeId}"
        value = [PATH_UPDATE_CARGO_TYPE],
        produces = ["*/*"]
    )
    fun updateCargoType(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "the ID of the cargo type", required = true) @PathVariable("cargoTypeId") cargoTypeId: kotlin.Long,
        @Parameter(description = "") @Valid @RequestBody(required = false) body: CargoType?
    ): ResponseEntity<CargoType> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Update Category",
        operationId = "updateCategory",
        description = """Update a category.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = CategoryTreeResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/category/update"
        value = [PATH_UPDATE_CATEGORY],
        produces = ["*/*"]
    )
    fun updateCategory(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The account id of the user", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "The ID of the category to edit", required = true) @Valid @RequestParam(value = "categoryId", required = true) categoryId: kotlin.Long,
        @Parameter(description = "The ID of the parent category, if not provided then the parent category will be null") @Valid @RequestParam(value = "parentCategoryId", required = false) parentCategoryId: kotlin.Long?,
        @Parameter(description = "The name of the category") @Valid @RequestParam(value = "name", required = false) name: kotlin.String?,
        @Parameter(description = "The description of the category") @Valid @RequestParam(value = "description", required = false) description: kotlin.String?,
        @Parameter(description = "The type of the category") @Valid @RequestParam(value = "type", required = false) type: kotlin.String?,
        @Parameter(description = "The ID of the image asset previously uploaded using the media service") @Valid @RequestParam(value = "assetId", required = false) assetId: kotlin.Long?,
        @Parameter(description = "A string identifier used by client applications to store external information") @Valid @RequestParam(value = "externalId", required = false) externalId: kotlin.String?,
        @Parameter(description = "A string type used by client applications to store external information") @Valid @RequestParam(value = "externalType", required = false) externalType: kotlin.String?,
        @Parameter(description = "external category slug") @Valid @RequestParam(value = "externalCategorySlug", required = false) externalCategorySlug: kotlin.String?,
        @Parameter(description = "sqoot slug") @Valid @RequestParam(value = "sqootSlug", required = false) sqootSlug: kotlin.String?,
        @Parameter(description = "Sets whether the category is active or inactive (hidden from consumers)") @Valid @RequestParam(value = "active", required = false) active: kotlin.Boolean?,
        @Parameter(description = "external custom client defined data") @Valid @RequestParam(value = "metaData", required = false) metaData: kotlin.String?,
        @Parameter(description = "user defined strings for searching") @Valid @RequestParam(value = "searchTags", required = false) searchTags: kotlin.String?
    ): ResponseEntity<CategoryTreeResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Update Creative",
        operationId = "updateCreative",
        description = """Update a creative""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = CreativeResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/creative/update"
        value = [PATH_UPDATE_CREATIVE],
        produces = ["*/*"]
    )
    fun updateCreative(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The logged in user.", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "the creative Id to upate.", required = true) @Valid @RequestParam(value = "creativeId", required = true) creativeId: kotlin.Long,
        @Parameter(description = "The name of the level.") @Valid @RequestParam(value = "name", required = false) name: kotlin.String?,
        @Parameter(description = "The description of the level.") @Valid @RequestParam(value = "description", required = false) description: kotlin.String?,
        @Parameter(description = "The asset Id of the level image.") @Valid @RequestParam(value = "assetImageId", required = false) assetImageId: kotlin.Long?,
        @Parameter(description = "This parameter is deprecated. deprecated use data field") @Valid @RequestParam(value = "action", required = false) action: kotlin.String?,
        @Parameter(description = "The creative data, json based format depending on type") @Valid @RequestParam(value = "data", required = false) `data`: kotlin.String?,
        @Parameter(description = "This parameter is deprecated. deprecated use type field") @Valid @RequestParam(value = "suffix", required = false) suffix: kotlin.String?,
        @Parameter(description = "The type of creative.") @Valid @RequestParam(value = "type", required = false) type: kotlin.String?,
        @Parameter(description = "Set the amount of money available to spend, once 0 deactivate level. Set to a negative value for unlimited.") @Valid @RequestParam(value = "balance", required = false) balance: kotlin.Double?,
        @Parameter(description = "If true set the game level as active. Default is false.") @Valid @RequestParam(value = "active", required = false) active: kotlin.Boolean?,
        @Parameter(description = "if creative related so some other content provided the id") @Valid @RequestParam(value = "referenceId", required = false) referenceId: kotlin.Long?,
        @Parameter(description = "The version of the application, will not return creatives newer than the appVersion. Only used when requesting application configuration creatives.") @Valid @RequestParam(value = "appVersion", required = false) appVersion: kotlin.String?,
        @Parameter(description = "Assign the creative to a campaign for timing and audience matching.") @Valid @RequestParam(value = "missionId", required = false) missionId: kotlin.Long?
    ): ResponseEntity<CreativeResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Update Credential",
        operationId = "updateCredential",
        description = """Updates a third-party login for an account.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = ProfileResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/thirdparty/credential/update"
        value = [PATH_UPDATE_CREDENTIAL],
        produces = ["*/*"]
    )
    fun updateCredential(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the access provider to authenticate against", required = true) @Valid @RequestParam(value = "networkUID", required = true) networkUID: kotlin.String,
        @NotNull @Parameter(description = "the third party user account id", required = true) @Valid @RequestParam(value = "thirdPartyId", required = true) thirdPartyId: kotlin.String,
        @NotNull @Parameter(description = "the application key", required = true) @Valid @RequestParam(value = "appKey", required = true) appKey: kotlin.String,
        @Parameter(description = "the unique id of the device making the request") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "the third party user name") @Valid @RequestParam(value = "thirdPartyName", required = false) thirdPartyName: kotlin.String?,
        @Parameter(description = "the access token to authenticate with (ex: username or fb token)") @Valid @RequestParam(value = "thirdPartyToken", required = false) thirdPartyToken: kotlin.String?,
        @Parameter(description = "this determines how much of the profile should be returned, see ProfileFilters") @Valid @RequestParam(value = "responseFilters", required = false) responseFilters: kotlin.String?,
        @Parameter(description = "External custom client defined data") @Valid @RequestParam(value = "metaData", required = false) metaData: kotlin.String?,
        @Parameter(description = "optional refresh token for the third party") @Valid @RequestParam(value = "thirdPartyRefreshToken", required = false) thirdPartyRefreshToken: kotlin.String?
    ): ResponseEntity<ProfileResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Update Data",
        operationId = "updateData",
        description = """Update a record for the specified object.  If the object does not exist the request will be rejected, use the data create service for the first entry. If any of the fields included does not exist for the object then they are added to the object.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = ObjectStoreResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.PUT],
        // "/api/{version}/object/data/{objectName}/{objectId}"
        value = [PATH_UPDATE_DATA],
        produces = ["*/*"]
    )
    fun updateData(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "The name of the object to search upon", required = true) @PathVariable("objectName") objectName: kotlin.String,
        @Parameter(description = "objectId The id of the record to return", required = true) @PathVariable("objectId") objectId: kotlin.String,
        @Parameter(description = "The account id of the logged in user") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "") @Valid @RequestBody(required = false) body: kotlin.String?
    ): ResponseEntity<ObjectStoreResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Update Disbursement",
        operationId = "updateDisbursement",
        description = """Update Disbursement""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = DisbursementResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/disbursement/update"
        value = [PATH_UPDATE_DISBURSEMENT],
        produces = ["*/*"]
    )
    fun updateDisbursement(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the id of the logged in user", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "the id of the disbursement being updated", required = true) @Valid @RequestParam(value = "disbursementId", required = true) disbursementId: kotlin.Long,
        @Parameter(description = "the disbursement dollar amount being updated") @Valid @RequestParam(value = "amount", required = false) amount: java.math.BigDecimal?,
        @Parameter(description = "the payments and/or billing provider (e.g. Authorize.net, Bill.com, etc.)", schema = Schema(allowableValues = ["AUTHORIZE_NET", "AMAZON_FPS", "BILL_COM"])) @Valid @RequestParam(value = "provider", required = false) provider: kotlin.String?,
        @Parameter(description = "the date that the disbursement is scheduled to go out to the payment provider") @Valid @RequestParam(value = "scheduledDate", required = false) scheduledDate: kotlin.Long?,
        @Parameter(description = "the title given to the disbursement") @Valid @RequestParam(value = "title", required = false) title: kotlin.String?,
        @Parameter(description = "a comment that can be made on a disbursement") @Valid @RequestParam(value = "comment", required = false) comment: kotlin.String?,
        @Parameter(description = "an external ID that can be used to reference the disbursement") @Valid @RequestParam(value = "externalId", required = false) externalId: kotlin.String?,
        @Parameter(description = "determines whether to try sending the disbursement again in the case of a previous failure") @Valid @RequestParam(value = "retry", required = false) retry: kotlin.Boolean?,
        @Parameter(description = "for specifying parameters to make an http callback request for validating that the disbursement is valid") @Valid @RequestParam(value = "introspectionParams", required = false) introspectionParams: kotlin.String?
    ): ResponseEntity<DisbursementResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Update Employee",
        operationId = "updateEmployee",
        description = """Update the account record with the provided information.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = EmployeeResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/employee/update"
        value = [PATH_UPDATE_EMPLOYEE],
        produces = ["*/*"]
    )
    fun updateEmployee(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The account id of the logged in user", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "the id of the employee account", required = true) @Valid @RequestParam(value = "employeeAccountId", required = true) employeeAccountId: kotlin.Long,
        @Parameter(description = "The account id of the manager to assign under") @Valid @RequestParam(value = "managerAccountId", required = false) managerAccountId: kotlin.Long?,
        @Parameter(description = "a name field") @Valid @RequestParam(value = "name", required = false) name: kotlin.String?,
        @Parameter(description = "The name prefix; Mr, Mrs, etc") @Valid @RequestParam(value = "prefixName", required = false) prefixName: kotlin.String?,
        @Parameter(description = "The first name") @Valid @RequestParam(value = "firstName", required = false) firstName: kotlin.String?,
        @Parameter(description = "The middle name") @Valid @RequestParam(value = "middleName", required = false) middleName: kotlin.String?,
        @Parameter(description = "The last name") @Valid @RequestParam(value = "lastName", required = false) lastName: kotlin.String?,
        @Parameter(description = "The name suffix; Jr, Sr, III, etc") @Valid @RequestParam(value = "suffixName", required = false) suffixName: kotlin.String?,
        @Parameter(description = "The title of the user") @Valid @RequestParam(value = "title", required = false) title: kotlin.String?,
        @Parameter(description = "the asset id to set the user's profile image") @Valid @RequestParam(value = "assetId", required = false) assetId: kotlin.Long?,
        @Parameter(description = "The gender {MALE, FEMALE, ANY}", schema = Schema(allowableValues = ["MALE", "FEMALE", "ANY"])) @Valid @RequestParam(value = "gender", required = false) gender: kotlin.String?,
        @Parameter(description = "The home phone number") @Valid @RequestParam(value = "homePhone", required = false) homePhone: kotlin.String?,
        @Parameter(description = "The cellular phone number") @Valid @RequestParam(value = "cellPhone", required = false) cellPhone: kotlin.String?,
        @Parameter(description = "The cellular service provider. This is required for sending SMS. Leave this empty if the provider is not on the list of supported carriers. Supported Carriers: {ATT, QWEST, T_MOBILE, VERIZON, SPRINT, VIRIGIN_MOBILE, NEXTEL, ALLTEL, METRO_PCS, POWERTEL, BOOST_MOBILE, SUNCOM, TRACFONE, US_CELLULAR}") @Valid @RequestParam(value = "cellPhoneCarrier", required = false) cellPhoneCarrier: kotlin.String?,
        @Parameter(description = "The business phone number") @Valid @RequestParam(value = "businessPhone", required = false) businessPhone: kotlin.String?,
        @Parameter(description = "The user's contact email address (NOT the username)") @Valid @RequestParam(value = "emailAddress", required = false) emailAddress: kotlin.String?,
        @Parameter(description = "The street address of the user's contact location") @Valid @RequestParam(value = "streetAddress", required = false) streetAddress: kotlin.String?,
        @Parameter(description = "Additional address information (such as a suite number, floor number, building name, or PO Box)") @Valid @RequestParam(value = "streetAddress2", required = false) streetAddress2: kotlin.String?,
        @Parameter(description = "The city of the user's contact location") @Valid @RequestParam(value = "city", required = false) city: kotlin.String?,
        @Parameter(description = "The state of the user's contact location") @Valid @RequestParam(value = "state", required = false) state: kotlin.String?,
        @Parameter(description = "The zipcode of the user's contact location") @Valid @RequestParam(value = "zipcode", required = false) zipcode: kotlin.String?,
        @Parameter(description = "The country of the user's contact location") @Valid @RequestParam(value = "country", required = false) country: kotlin.String?,
        @Parameter(description = "The role; RETAILER or RETAILER_LIMITED, defaulted to RETAILER_LIMITED") @Valid @RequestParam(value = "role", required = false) role: kotlin.String?,
        @Parameter(description = "Sets whether the employee is active or inactive") @Valid @RequestParam(value = "active", required = false) active: kotlin.Boolean?,
        @Parameter(description = "Sets the password for the employee") @Valid @RequestParam(value = "password", required = false) password: kotlin.String?,
        @Parameter(description = "Sets which retailer locations the employee is assigned to") @Valid @RequestParam(value = "retailerLocationIds", required = false) retailerLocationIds: kotlin.String?,
        @Parameter(description = "Determines whether to return the application settings for the employee for a particular application") @Valid @RequestParam(value = "settingsAppKey", required = false) settingsAppKey: kotlin.String?,
        @Parameter(description = "external custom client defined data (per Application)") @Valid @RequestParam(value = "appBlob", required = false) appBlob: kotlin.String?,
        @Parameter(description = "The device id to assign to the user (used for IPS beacon tracking)") @Valid @RequestParam(value = "assignedDeviceId", required = false) assignedDeviceId: kotlin.String?
    ): ResponseEntity<EmployeeResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Update Event",
        operationId = "updateEvent",
        description = """Update a private event to share with associates.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = OfferResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/event/update"
        value = [PATH_UPDATE_EVENT],
        produces = ["*/*"]
    )
    fun updateEvent(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The logged in user.", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "The id of the event to update", required = true) @Valid @RequestParam(value = "eventId", required = true) eventId: kotlin.Long,
        @Parameter(description = "The retailer location to have the event at") @Valid @RequestParam(value = "retailerLocationIds", required = false) retailerLocationIds: kotlin.String?,
        @Parameter(description = "The event title") @Valid @RequestParam(value = "title", required = false) title: kotlin.String?,
        @Parameter(description = "The event sub title") @Valid @RequestParam(value = "subTitle", required = false) subTitle: kotlin.String?,
        @Parameter(description = "The event details") @Valid @RequestParam(value = "details", required = false) details: kotlin.String?,
        @Parameter(description = "The categories the associate the event with") @Valid @RequestParam(value = "categoryIds", required = false) categoryIds: kotlin.String?,
        @Parameter(description = "The filters the associate the event with") @Valid @RequestParam(value = "filterIds", required = false) filterIds: kotlin.String?,
        @Parameter(description = "Is this event active") @Valid @RequestParam(value = "active", required = false) active: kotlin.Boolean?,
        @Parameter(description = "The image to show for the event") @Valid @RequestParam(value = "imageAssetId", required = false) imageAssetId: kotlin.Long?,
        @Parameter(description = "The event start date/time") @Valid @RequestParam(value = "redeemableStart", required = false) redeemableStart: kotlin.Long?,
        @Parameter(description = "The event end date/time") @Valid @RequestParam(value = "redeemableEnd", required = false) redeemableEnd: kotlin.Long?
    ): ResponseEntity<OfferResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Update Vatom Event Guest List",
        operationId = "updateEventGuestList",
        description = """Update the guest list of an event.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation") ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/vatom/b/events/guests/update"
        value = [PATH_UPDATE_EVENT_GUEST_LIST]
    )
    fun updateEventGuestList(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "Sirqul Account Id", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "Sirqul Application Key", required = true) @Valid @RequestParam(value = "appKey", required = true) appKey: kotlin.String,
        @NotNull @Parameter(description = "Vatom Event Id", required = true) @Valid @RequestParam(value = "vatomEventId", required = true) vatomEventId: kotlin.String,
        @NotNull @Parameter(description = "Vatom Parameters", required = true) @Valid @RequestParam(value = "vatomParameters", required = true) vatomParameters: kotlin.String,
        @Parameter(description = "Return raw response") @Valid @RequestParam(value = "returnRawResponse", required = false) returnRawResponse: kotlin.Boolean?
    ): ResponseEntity<Unit> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Update Filter",
        operationId = "updateFilter",
        description = """Update a filter.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = FilterTreeResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/filter/update"
        value = [PATH_UPDATE_FILTER],
        produces = ["*/*"]
    )
    fun updateFilter(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The account id of the user", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "The ID of the filter to edit", required = true) @Valid @RequestParam(value = "filterId", required = true) filterId: kotlin.Long,
        @Parameter(description = "The ID of the parent filter, if not provided then the parent filter will be null") @Valid @RequestParam(value = "parentFilterId", required = false) parentFilterId: kotlin.Long?,
        @Parameter(description = "The name of the filter") @Valid @RequestParam(value = "name", required = false) name: kotlin.String?,
        @Parameter(description = "The description of the filter") @Valid @RequestParam(value = "description", required = false) description: kotlin.String?,
        @Parameter(description = "A string identifier used by client applications to store external information") @Valid @RequestParam(value = "externalId", required = false) externalId: kotlin.String?,
        @Parameter(description = "A string type used by client applications to store external information") @Valid @RequestParam(value = "externalType", required = false) externalType: kotlin.String?,
        @Parameter(description = "Sets whether the filter is active or inactive (hidden from consumers)") @Valid @RequestParam(value = "active", required = false) active: kotlin.Boolean?,
        @Parameter(description = "external custom client defined data") @Valid @RequestParam(value = "metaData", required = false) metaData: kotlin.String?
    ): ResponseEntity<FilterTreeResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Update Flag Threshold",
        operationId = "updateFlagThreshold",
        description = """Update the flag threshold on an object type for a particular application.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = CountResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/flag/threshold/update"
        value = [PATH_UPDATE_FLAG_THRESHOLD],
        produces = ["*/*"]
    )
    fun updateFlagThreshold(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The flagable object type {ACCOUNT, ALBUM, ALBUM_CONTEST, ASSET, GAME_LEVEL, THEME_DESCRIPTOR, OFFER, NOTE}", required = true) @Valid @RequestParam(value = "itemBeingFlaggedType", required = true) itemBeingFlaggedType: kotlin.String,
        @NotNull @Parameter(description = "The threshold value", required = true) @Valid @RequestParam(value = "threshold", required = true) threshold: kotlin.Long,
        @NotNull @Parameter(description = "The application key", required = true) @Valid @RequestParam(value = "appKey", required = true) appKey: kotlin.String,
        @Parameter(description = "The unique device identifier that made the request (either deviceId or accountId must be used)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "The unique accountId that made the request (either deviceId or accountId must be used)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?
    ): ResponseEntity<CountResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Update a Game",
        operationId = "updateGame",
        description = """Update a Game""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = GameResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/game/update"
        value = [PATH_UPDATE_GAME],
        produces = ["*/*"]
    )
    fun updateGame(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "The logged in user.") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "the updating game's id") @Valid @RequestParam(value = "gameId", required = false) gameId: kotlin.Long?,
        @Parameter(description = "The game application key to save the level for.") @Valid @RequestParam(value = "appKey", required = false) appKey: kotlin.String?,
        @Parameter(description = "Title of the Game.") @Valid @RequestParam(value = "title", required = false) title: kotlin.String?,
        @Parameter(description = "Description of the Game.") @Valid @RequestParam(value = "description", required = false) description: kotlin.String?,
        @Parameter(description = "metaData of the Game.") @Valid @RequestParam(value = "metaData", required = false) metaData: kotlin.String?,
        @Parameter(description = "comma separated String of pack Ids that will associate with the game.") @Valid @RequestParam(value = "packIds", required = false) packIds: kotlin.String?,
        @Parameter(description = "show more details in response.") @Valid @RequestParam(value = "includeGameData", required = false) includeGameData: kotlin.Boolean?
    ): ResponseEntity<GameResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Update Game Level",
        operationId = "updateGameLevel",
        description = """Update a game level. Currently does NOT support game objects.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = GameLevelResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/level/update"
        value = [PATH_UPDATE_GAME_LEVEL],
        produces = ["*/*"]
    )
    fun updateGameLevel(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The logged in user.", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "If update then include the level Id.", required = true) @Valid @RequestParam(value = "levelId", required = true) levelId: kotlin.Long,
        @Parameter(description = "The game application key to save the level for.") @Valid @RequestParam(value = "appKey", required = false) appKey: kotlin.String?,
        @Parameter(description = "The name of the level.") @Valid @RequestParam(value = "name", required = false) name: kotlin.String?,
        @Parameter(description = "The description of the level.") @Valid @RequestParam(value = "description", required = false) description: kotlin.String?,
        @Parameter(description = "The difficulty, possible values are: VERY_EASY, EASY, MEDIUM, HARD, VERY_HARD.") @Valid @RequestParam(value = "difficulty", required = false) difficulty: kotlin.String?,
        @Parameter(description = "The version number of the applicatuion required to correctly load/play the level.") @Valid @RequestParam(value = "appVersion", required = false) appVersion: kotlin.String?,
        @Parameter(description = "The asset Id of the level image.") @Valid @RequestParam(value = "assetImageId", required = false) assetImageId: kotlin.Long?,
        @Parameter(description = "The asset Id of the level icon.") @Valid @RequestParam(value = "assetIconId", required = false) assetIconId: kotlin.Long?,
        @Parameter(description = "The game level data: xml, json, or other texted based format.") @Valid @RequestParam(value = "gameData", required = false) gameData: kotlin.String?,
        @Parameter(description = "The game level data format type.") @Valid @RequestParam(value = "gameDataSuffix", required = false) gameDataSuffix: kotlin.String?,
        @Parameter(description = "Is the level visible to others, possible values are: PUBLIC, PRIVATE.") @Valid @RequestParam(value = "visibility", required = false) visibility: kotlin.String?,
        @Parameter(description = "Make the level be readable by all friends.") @Valid @RequestParam(value = "friendGroup", required = false) friendGroup: kotlin.Boolean?,
        @Parameter(description = "Make the level be readable by connections in this list.") @Valid @RequestParam(value = "connectionIds", required = false) connectionIds: kotlin.String?,
        @Parameter(description = "Make the level be readable by connection groups in this list.") @Valid @RequestParam(value = "connectionGroupIds", required = false) connectionGroupIds: kotlin.String?,
        @Parameter(description = "Set the amount of money available to spend, once 0 deactivate level. Set to a negative value for unlimited.") @Valid @RequestParam(value = "balance", required = false) balance: kotlin.Double?,
        @Parameter(description = "If true set the game level as active.") @Valid @RequestParam(value = "active", required = false) active: kotlin.Boolean?,
        @Parameter(description = "If true then scoring will give tickets.") @Valid @RequestParam(value = "allocateTickets", required = false) allocateTickets: kotlin.Boolean?,
        @Parameter(description = "The number of tickets to reward") @Valid @RequestParam(value = "ticketCount", required = false) ticketCount: kotlin.Long?,
        @Parameter(description = "The type of ticket to reward, null means default type") @Valid @RequestParam(value = "ticketType", required = false) ticketType: kotlin.String?,
        @Parameter(description = "The number of points to award for completing a level") @Valid @RequestParam(value = "points", required = false) points: kotlin.Long?,
        @Parameter(description = "Title of the tutorial.") @Valid @RequestParam(value = "tutorialTitle", required = false) tutorialTitle: kotlin.String?,
        @Parameter(description = "Message of the tutorial.") @Valid @RequestParam(value = "tutorialMessage", required = false) tutorialMessage: kotlin.String?,
        @Parameter(description = "Alignment of the tutorial image, possible values are: NONE, IMAGE_ABOVE, IMAGE_BELOW, IMAGE_LEFT, IMAGE_RIGHT, IMAGE_ONLY, TEXT_ONLY") @Valid @RequestParam(value = "tutorialAlignment", required = false) tutorialAlignment: kotlin.String?,
        @Parameter(description = "Asset id of the tutorial image.") @Valid @RequestParam(value = "tutorialImageAssetId", required = false) tutorialImageAssetId: kotlin.Long?,
        @Parameter(description = "") @Valid @RequestParam(value = "offerId", required = false) offerId: kotlin.Long?,
        @Parameter(description = "external custom client defined data") @Valid @RequestParam(value = "metaData", required = false) metaData: kotlin.String?
    ): ResponseEntity<GameLevelResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Update a leaderboard based on the rankingType, rankMode(leaderboardMode), sortField and limitation",
        operationId = "updateLeaderboard",
        description = """Update a leaderboard based on the rankingType, rankMode(leaderboardMode), sortField and limitation""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = LeaderboardResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/leaderboard/update"
        value = [PATH_UPDATE_LEADERBOARD],
        produces = ["*/*"]
    )
    fun updateLeaderboard(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The leaderboard id to update.", required = true) @Valid @RequestParam(value = "leaderboardId", required = true) leaderboardId: kotlin.Long,
        @Parameter(description = "The account id of the user updating the leaderboard.") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "The application key") @Valid @RequestParam(value = "appKey", required = false) appKey: kotlin.String?,
        @Parameter(description = "a unique label for identifying the ranking. This can be any alphanumeric string with a maximum length of 64 characters.") @Valid @RequestParam(value = "rankType", required = false) rankType: kotlin.String?,
        @Parameter(description = "the type of search to perform. Possible values include: GLOBAL, LOCAL, SEARCH, CUSTOM") @Valid @RequestParam(value = "leaderboardMode", required = false) leaderboardMode: kotlin.String?,
        @Parameter(description = "determines how to order and rank the results. Possible values include: TOTAL, WEEKLY, DAILY, TOP, LOWEST") @Valid @RequestParam(value = "sortField", required = false) sortField: kotlin.String?,
        @Parameter(description = "a MultipartFile containing the icon image of the leaderboard (this will only be used if \"iconAssetId\" is empty)") @Valid @RequestParam(value = "iconMedia", required = false) iconMedia: org.springframework.web.multipart.MultipartFile,
        @Parameter(description = "The asset ID to set the leaderboard icon") @Valid @RequestParam(value = "iconAssetId", required = false) iconAssetId: kotlin.Long?,
        @Parameter(description = "a MultipartFile containing the icon banner of the leaderboard (this will only be used if \"bannerAssetId\" is empty)") @Valid @RequestParam(value = "bannerMedia", required = false) bannerMedia: org.springframework.web.multipart.MultipartFile,
        @Parameter(description = "The asset ID to set the leaderboard banner") @Valid @RequestParam(value = "bannerAssetId", required = false) bannerAssetId: kotlin.Long?,
        @Parameter(description = "limit number of rankings for each leaderboard") @Valid @RequestParam(value = "limitation", required = false) limitation: kotlin.Int?,
        @Parameter(description = "Whether the leaderboard is active") @Valid @RequestParam(value = "active", required = false) active: kotlin.Boolean?,
        @Parameter(description = "leaderboard's title") @Valid @RequestParam(value = "title", required = false) title: kotlin.String?,
        @Parameter(description = "leaderboard's description") @Valid @RequestParam(value = "description", required = false) description: kotlin.String?,
        @Parameter(description = "custom meta data for the leaderboard") @Valid @RequestParam(value = "metaData", required = false) metaData: kotlin.String?
    ): ResponseEntity<LeaderboardResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Update Listing",
        operationId = "updateListing",
        description = """Updates a listing.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = ListingFullResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/listing/update"
        value = [PATH_UPDATE_LISTING],
        produces = ["*/*"]
    )
    fun updateListing(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the user's account ID", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "the listing to update", required = true) @Valid @RequestParam(value = "listingId", required = true) listingId: kotlin.Long,
        @Parameter(description = "comma separated list of filter IDs") @Valid @RequestParam(value = "filterIds", required = false) filterIds: kotlin.String?,
        @Parameter(description = "the name of the listing") @Valid @RequestParam(value = "name", required = false) name: kotlin.String?,
        @Parameter(description = "the description of the listing") @Valid @RequestParam(value = "description", required = false) description: kotlin.String?,
        @Parameter(description = "the start date of the listing") @Valid @RequestParam(value = "start", required = false) start: kotlin.Long?,
        @Parameter(description = "the end date of the listing") @Valid @RequestParam(value = "end", required = false) end: kotlin.Long?,
        @Parameter(description = "the name of the location the listing will be held at") @Valid @RequestParam(value = "locationName", required = false) locationName: kotlin.String?,
        @Parameter(description = "the description of the location the listing will be held at") @Valid @RequestParam(value = "locationDescription", required = false) locationDescription: kotlin.String?,
        @Parameter(description = "determines whether the listing is public or private") @Valid @RequestParam(value = "isPrivate", required = false) isPrivate: kotlin.Boolean?,
        @Parameter(description = "external identifier used by a third party") @Valid @RequestParam(value = "externalId", required = false) externalId: kotlin.String?,
        @Parameter(description = "secondary external identifier used by a third party") @Valid @RequestParam(value = "externalId2", required = false) externalId2: kotlin.String?,
        @Parameter(description = "external group identifier used by a third party") @Valid @RequestParam(value = "externalGroupId", required = false) externalGroupId: kotlin.String?,
        @Parameter(description = "Sets the active flag") @Valid @RequestParam(value = "active", required = false) active: kotlin.Boolean?,
        @Parameter(description = "external custom client defined data") @Valid @RequestParam(value = "metaData", required = false) metaData: kotlin.String?
    ): ResponseEntity<ListingFullResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Update Location",
        operationId = "updateLocation",
        description = """Update the account location""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/account/location/update"
        value = [PATH_UPDATE_LOCATION],
        produces = ["*/*"]
    )
    fun updateLocation(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "The device id (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "The account id of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "The current latitude of the user") @Valid @RequestParam(value = "latitude", required = false) latitude: kotlin.Double?,
        @Parameter(description = "The current longitude of the user") @Valid @RequestParam(value = "longitude", required = false) longitude: kotlin.Double?,
        @Parameter(description = "The time of the update") @Valid @RequestParam(value = "clientTime", required = false) clientTime: kotlin.Long?
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Update an existing location",
        operationId = "updateLocationV2",
        description = """Update an existing location""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/location/{id}"
        value = [PATH_UPDATE_LOCATION_V2],
        produces = ["*/*"]
    )
    fun updateLocationV2(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "the id of the location to update", required = true) @PathVariable("id") id: kotlin.Long,
        @Parameter(description = "") @Valid @RequestBody(required = false) body: Location?
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Update Trip Locations",
        operationId = "updateLocations",
        description = """""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = Trip::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/trip/{id}/locations"
        value = [PATH_UPDATE_LOCATIONS],
        produces = ["*/*"]
    )
    fun updateLocations(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "the id of the trip to update locations for", required = true) @PathVariable("id") id: kotlin.Long,
        @Parameter(description = "") @Valid @RequestBody(required = false) body: Trip?
    ): ResponseEntity<Trip> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Update Media",
        operationId = "updateMedia",
        description = """Update a media offering.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = MediaOfferResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/media/update"
        value = [PATH_UPDATE_MEDIA],
        produces = ["*/*"]
    )
    fun updateMedia(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The account used to perform the update, must have rights to edit the offer (deviceId or accountId required)", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "", required = true) @Valid @RequestParam(value = "mediaId", required = true) mediaId: kotlin.Long,
        @Parameter(description = "Comma separated list of retailer location ids. This will assign the offer to these retailer locations.") @Valid @RequestParam(value = "retailerLocationIds", required = false) retailerLocationIds: kotlin.String?,
        @Parameter(description = "A list of json data that has offer location specific values.") @Valid @RequestParam(value = "offerLocations", required = false) offerLocations: kotlin.String?,
        @Parameter(description = "The title (255 char limit)") @Valid @RequestParam(value = "title", required = false) title: kotlin.String?,
        @Parameter(description = "The sub title (255 char limit)") @Valid @RequestParam(value = "subTitle", required = false) subTitle: kotlin.String?,
        @Parameter(description = "The details") @Valid @RequestParam(value = "details", required = false) details: kotlin.String?,
        @Parameter(description = "A string for custom details (255 char limit)") @Valid @RequestParam(value = "subDetails", required = false) subDetails: kotlin.String?,
        @Parameter(description = "The fine print") @Valid @RequestParam(value = "finePrint", required = false) finePrint: kotlin.String?,
        @Parameter(description = "The bar code type {NONE, UPC, CODE_128, QR, CUSTOM_MEDIA}", schema = Schema(allowableValues = ["NONE", "UPC", "CODE_128", "QR", "CUSTOM_MEDIA"])) @Valid @RequestParam(value = "barcodeType", required = false) barcodeType: kotlin.String?,
        @Parameter(description = "The bar code entry string") @Valid @RequestParam(value = "barcodeEntry", required = false) barcodeEntry: kotlin.String?,
        @Parameter(description = "An external identifier. What the identifier will be used for and how it is formatted is up to the frontend developer.") @Valid @RequestParam(value = "externalRedeemOptions", required = false) externalRedeemOptions: kotlin.String?,
        @Parameter(description = "The clickUrl of the offer") @Valid @RequestParam(value = "externalUrl", required = false) externalUrl: kotlin.String?,
        @Parameter(description = "The type of ticket to reward, null means default type") @Valid @RequestParam(value = "ticketsRewardType", required = false) ticketsRewardType: kotlin.String?,
        @Parameter(description = "Determines how many tickets are awarded") @Valid @RequestParam(value = "ticketsReward", required = false) ticketsReward: kotlin.Long?,
        @Parameter(description = "The date of when the offer will be visible to consumers") @Valid @RequestParam(value = "activated", required = false) activated: kotlin.Long?,
        @Parameter(description = "The date of when the offer expires") @Valid @RequestParam(value = "expires", required = false) expires: kotlin.Long?,
        @Parameter(description = "Overrides the expiration date so that the offer does not expire") @Valid @RequestParam(value = "noExpiration", required = false) noExpiration: kotlin.Boolean?,
        @Parameter(description = "The limit of how many times the offer can be used by consumers") @Valid @RequestParam(value = "availableLimit", required = false) availableLimit: kotlin.Int?,
        @Parameter(description = "The limit of how many times a user can used the same offer") @Valid @RequestParam(value = "availableLimitPerUser", required = false) availableLimitPerUser: kotlin.Int?,
        @Parameter(description = "The limit of how many times the offer can be added to consumer wallets") @Valid @RequestParam(value = "addedLimit", required = false) addedLimit: kotlin.Int?,
        @Parameter(description = "") @Valid @RequestParam(value = "viewLimit", required = false) viewLimit: kotlin.Int?,
        @Parameter(description = "The maximum number of times the offer can be printed") @Valid @RequestParam(value = "maxPrints", required = false) maxPrints: kotlin.Int?,
        @Parameter(description = "the type of ticket needed to buy the offer") @Valid @RequestParam(value = "ticketPriceType", required = false) ticketPriceType: kotlin.String?,
        @Parameter(description = "The cost of the offer in tickets") @Valid @RequestParam(value = "ticketPrice", required = false) ticketPrice: kotlin.Long?,
        @Parameter(description = "The retail/full price cost of the offer in real currency") @Valid @RequestParam(value = "fullPrice", required = false) fullPrice: kotlin.Double?,
        @Parameter(description = "The cost of the offer at a discounted price (what the consumer pays)") @Valid @RequestParam(value = "discountPrice", required = false) discountPrice: kotlin.Double?,
        @Parameter(description = "The show remaining") @Valid @RequestParam(value = "showRemaining", required = false) showRemaining: kotlin.Boolean?,
        @Parameter(description = "The show redeemed") @Valid @RequestParam(value = "showRedeemed", required = false) showRedeemed: kotlin.Boolean?,
        @Parameter(description = "The replaced") @Valid @RequestParam(value = "replaced", required = false) replaced: kotlin.Boolean?,
        @Parameter(description = "The featured") @Valid @RequestParam(value = "featured", required = false) featured: kotlin.Boolean?,
        @Parameter(description = "The special offer type {ALL, REGULAR_OFFER, ACT_NOW, GET_THERE_NOW}", schema = Schema(allowableValues = ["ALL", "RESERVABLE", "REGULAR_OFFER", "ACT_NOW", "GET_THERE_NOW", "SQOOT", "TICKETS", "YIPIT"])) @Valid @RequestParam(value = "specialOfferType", required = false) specialOfferType: kotlin.String?,
        @Parameter(description = "The offer visibility {PUBLIC, REWARDABLE, TRIGGERABLE}", schema = Schema(allowableValues = ["PUBLIC", "LISTABLE", "REWARDABLE", "TRIGGERABLE", "PRIVATE"])) @Valid @RequestParam(value = "offerVisibility", required = false) offerVisibility: kotlin.String?,
        @Parameter(description = "Comma separated list of category ids") @Valid @RequestParam(value = "categoryIds", required = false) categoryIds: kotlin.String?,
        @Parameter(description = "Comma separated list of filter ids") @Valid @RequestParam(value = "filterIds", required = false) filterIds: kotlin.String?,
        @Parameter(description = "Sets the active flag") @Valid @RequestParam(value = "active", required = false) active: kotlin.Boolean?,
        @Parameter(description = "The id of the barcode asset") @Valid @RequestParam(value = "barcodeAssetId", required = false) barcodeAssetId: kotlin.Long?,
        @Parameter(description = "The id of the an offer asset") @Valid @RequestParam(value = "imageAssetId", required = false) imageAssetId: kotlin.Long?,
        @Parameter(description = "The id of the an offer asset") @Valid @RequestParam(value = "imageAssetId1", required = false) imageAssetId1: kotlin.Long?,
        @Parameter(description = "The id of the an offer asset") @Valid @RequestParam(value = "imageAssetId2", required = false) imageAssetId2: kotlin.Long?,
        @Parameter(description = "The id of the an offer asset") @Valid @RequestParam(value = "imageAssetId3", required = false) imageAssetId3: kotlin.Long?,
        @Parameter(description = "The id of the an offer asset") @Valid @RequestParam(value = "imageAssetId4", required = false) imageAssetId4: kotlin.Long?,
        @Parameter(description = "The id of the an offer asset") @Valid @RequestParam(value = "imageAssetId5", required = false) imageAssetId5: kotlin.Long?,
        @Parameter(description = "The maker of the item.") @Valid @RequestParam(value = "publisher", required = false) publisher: kotlin.String?,
        @Parameter(description = "The redeemable start date/time of the offer.") @Valid @RequestParam(value = "redeemableStart", required = false) redeemableStart: kotlin.Long?,
        @Parameter(description = "The redeemable start date/time of the offer.") @Valid @RequestParam(value = "redeemableEnd", required = false) redeemableEnd: kotlin.Long?,
        @Parameter(description = "The condition. OfferType PRODUCT only.", schema = Schema(allowableValues = ["NEW", "USED", "REFURBISHED", "OTHER"])) @Valid @RequestParam(value = "conditionType", required = false) conditionType: kotlin.String?,
        @Parameter(description = "The ISBN id. OfferType PRODUCT only.") @Valid @RequestParam(value = "isbn", required = false) isbn: kotlin.String?,
        @Parameter(description = "The ASIN id. OfferType PRODUCT only.") @Valid @RequestParam(value = "asin", required = false) asin: kotlin.String?,
        @Parameter(description = "The list of catelog numbers, comma seperated. OfferType PRODUCT only.") @Valid @RequestParam(value = "catalogNumbers", required = false) catalogNumbers: kotlin.String?,
        @Parameter(description = "The date available. OfferType PRODUCT only.") @Valid @RequestParam(value = "availabilityDate", required = false) availabilityDate: kotlin.Long?,
        @Parameter(description = "The parental control rating. OfferType PRODUCT only.") @Valid @RequestParam(value = "parentalRating", required = false) parentalRating: kotlin.String?,
        @Parameter(description = "", schema = Schema(allowableValues = ["APK", "APPLICATION", "IMAGE", "AUDIO", "VIDEO", "MULTIPART", "BAR_CODE", "TEXT", "OTHER"])) @Valid @RequestParam(value = "mediaType", required = false) mediaType: kotlin.String?,
        @Parameter(description = "The total playing time of the media item. OfferType MEDIA only.") @Valid @RequestParam(value = "duration", required = false) duration: kotlin.Int?,
        @Parameter(description = "The created/author of the media item. OfferType MEDIA only.") @Valid @RequestParam(value = "author", required = false) author: kotlin.String?,
        @Parameter(description = "The date/time of when the media item was originally released. OfferType MEDIA only.") @Valid @RequestParam(value = "releaseDate", required = false) releaseDate: kotlin.Long?,
        @Parameter(description = "") @Valid @RequestParam(value = "collectionIds", required = false) collectionIds: kotlin.String?,
        @Parameter(description = "") @Valid @RequestParam(value = "availability", required = false) availability: kotlin.String?,
        @Parameter(description = "") @Valid @RequestParam(value = "availabilitySummary", required = false) availabilitySummary: kotlin.String?
    ): ResponseEntity<MediaOfferResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Update Mission",
        operationId = "updateMission",
        description = """Update a mission.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = MissionResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/mission/update"
        value = [PATH_UPDATE_MISSION],
        produces = ["*/*"]
    )
    fun updateMission(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The logged in user.", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "The id of the mission to update.", required = true) @Valid @RequestParam(value = "missionId", required = true) missionId: kotlin.Long,
        @Parameter(description = "The title of the mission") @Valid @RequestParam(value = "title", required = false) title: kotlin.String?,
        @Parameter(description = "The description of the mission") @Valid @RequestParam(value = "description", required = false) description: kotlin.String?,
        @Parameter(description = "Custom string client apps can use for searching/filtering missions") @Valid @RequestParam(value = "subType", required = false) subType: kotlin.String?,
        @Parameter(description = "external custom client defined data") @Valid @RequestParam(value = "metaData", required = false) metaData: kotlin.String?,
        @Parameter(description = "The date/time to start the mission, send 0 to unset") @Valid @RequestParam(value = "startDate", required = false) startDate: kotlin.Long?,
        @Parameter(description = "The date/time to end the mission, send 0 to unset") @Valid @RequestParam(value = "endDate", required = false) endDate: kotlin.Long?,
        @Parameter(description = "Activate/deactivate the mission") @Valid @RequestParam(value = "active", required = false) active: kotlin.Boolean?,
        @Parameter(description = "the game level ids to include in the mission, comma separated") @Valid @RequestParam(value = "gameLevelIds", required = false) gameLevelIds: kotlin.String?,
        @Parameter(description = "") @Valid @RequestParam(value = "creativeIds", required = false) creativeIds: kotlin.String?,
        @Parameter(description = "") @Valid @RequestParam(value = "audienceIds", required = false) audienceIds: kotlin.String?,
        @Parameter(description = "The offerId to give as a reward") @Valid @RequestParam(value = "offerId", required = false) offerId: kotlin.Long?,
        @Parameter(description = "Replace the amount of money available to spend, once 0 deactivate mission. Set to a negative value for unlimited.") @Valid @RequestParam(value = "balance", required = false) balance: kotlin.Double?,
        @Parameter(description = "Flag to mark the mission as eligible for advanced reporting") @Valid @RequestParam(value = "advancedReporting", required = false) advancedReporting: kotlin.Boolean?,
        @Parameter(description = "Flag to indicate owner should receive tickets for completed missions") @Valid @RequestParam(value = "allocateTickets", required = false) allocateTickets: kotlin.Boolean?,
        @Parameter(description = "The number of tickets to reward") @Valid @RequestParam(value = "ticketCount", required = false) ticketCount: kotlin.Long?,
        @Parameter(description = "The type of ticket to reward, null means default type") @Valid @RequestParam(value = "ticketType", required = false) ticketType: kotlin.String?,
        @Parameter(description = "The number of points to award for completing a mission") @Valid @RequestParam(value = "points", required = false) points: kotlin.Long?,
        @Parameter(description = "Comma separated list of application ids") @Valid @RequestParam(value = "applicationIds", required = false) applicationIds: kotlin.String?,
        @Parameter(description = "Deprecated parameter for device names") @Valid @RequestParam(value = "devices", required = false) devices: kotlin.String?,
        @Parameter(description = "Comma separated list of device ids") @Valid @RequestParam(value = "deviceIds", required = false) deviceIds: kotlin.String?,
        @Parameter(description = "Comma separated list of device version ranges") @Valid @RequestParam(value = "deviceVersions", required = false) deviceVersions: kotlin.String?,
        @Parameter(description = "List of lat/long pairs for mission locations") @Valid @RequestParam(value = "locations", required = false) locations: kotlin.String?,
        @Parameter(description = "Comma separated list of radii for locations") @Valid @RequestParam(value = "radius", required = false) radius: kotlin.String?
    ): ResponseEntity<MissionResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Update Mission Invite",
        operationId = "updateMissionInvite",
        description = """Update the mission invite status. An account can only be invited to a mission one time. For missions that require user submission and reviewing the permissionableType and permissionableId need to be provided.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = MissionResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/mission/invite/update"
        value = [PATH_UPDATE_MISSION_INVITE],
        produces = ["*/*"]
    )
    fun updateMissionInvite(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "the device id (deviceId or accountId required).") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "the account id of the user (deviceId or accountId required).") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "the application key") @Valid @RequestParam(value = "appKey", required = false) appKey: kotlin.String?,
        @Parameter(description = "The mission to find the invite for (missionId or missionInviteId requried).") @Valid @RequestParam(value = "missionId", required = false) missionId: kotlin.Long?,
        @Parameter(description = "The mission invite id. This checks on the user's billable for permission (missionId or missionInviteId requried).") @Valid @RequestParam(value = "missionInviteId", required = false) missionInviteId: kotlin.Long?,
        @Parameter(description = "the pack id to find the invite for") @Valid @RequestParam(value = "packId", required = false) packId: kotlin.Long?,
        @Parameter(description = "the game level id to find the invite for") @Valid @RequestParam(value = "gameLevelId", required = false) gameLevelId: kotlin.Long?,
        @Parameter(description = "The invite status to filter for, comma separated list {AVAILABLE, PENDING, UPDATED, ACCEPTED, ACTIVE, QUIT, COMPLETED, PENDING_REVIEW, REJECTED}") @Valid @RequestParam(value = "status", required = false) status: kotlin.String?,
        @Parameter(description = "This is the content type for missions that require user submission. Note that user submitted content must require a status of PENDING_REVIEW to be accpeted. {ACCOUNT, GAMELEVEL, COLLECTION, ALBUM_CONTEST, THEME_DESCRIPTOR, ALBUM}") @Valid @RequestParam(value = "permissionableType", required = false) permissionableType: kotlin.String?,
        @Parameter(description = "The id of the content being submitted.") @Valid @RequestParam(value = "permissionableId", required = false) permissionableId: kotlin.Long?,
        @Parameter(description = "Include the game level data with the mission.") @Valid @RequestParam(value = "includeGameData", required = false) includeGameData: kotlin.Boolean?
    ): ResponseEntity<MissionResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Update Network",
        operationId = "updateNetwork",
        description = """Updates a custom third party network. Only the network owners and managers have access to this.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = ThirdPartyNetworkResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/thirdparty/network/update"
        value = [PATH_UPDATE_NETWORK],
        produces = ["*/*"]
    )
    fun updateNetwork(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The account id making the request", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "The unique identifier for the third party network defined by Sirqul", required = true) @Valid @RequestParam(value = "networkUID", required = true) networkUID: kotlin.String,
        @Parameter(description = "The name of the network") @Valid @RequestParam(value = "name", required = false) name: kotlin.String?,
        @Parameter(description = "The description of the network") @Valid @RequestParam(value = "description", required = false) description: kotlin.String?,
        @Parameter(description = "Whether the network uses introspection calls") @Valid @RequestParam(value = "enableIntrospection", required = false) enableIntrospection: kotlin.Boolean?,
        @Parameter(description = "HTTP method to use for introspection calls (e.g., GET, POST)") @Valid @RequestParam(value = "introspectionMethod", required = false) introspectionMethod: kotlin.String?,
        @Parameter(description = "The HTTP URL of the introspection call") @Valid @RequestParam(value = "introspectionURL", required = false) introspectionURL: kotlin.String?,
        @Parameter(description = "The parameters of the introspection call") @Valid @RequestParam(value = "introspectionParams", required = false) introspectionParams: kotlin.String?,
        @Parameter(description = "Required response params") @Valid @RequestParam(value = "requiredRootField", required = false) requiredRootField: kotlin.String?,
        @Parameter(description = "Whether this network uses MFA") @Valid @RequestParam(value = "enableMFA", required = false) enableMFA: kotlin.Boolean?,
        @Parameter(description = "Size of the MFA token") @Valid @RequestParam(value = "sizeMFA", required = false) sizeMFA: kotlin.Int?,
        @Parameter(description = "Shelf life (seconds) of the MFA token") @Valid @RequestParam(value = "shelfLifeMFA", required = false) shelfLifeMFA: kotlin.Int?,
        @Parameter(description = "OAuth token endpoint URL") @Valid @RequestParam(value = "oauthTokenURL", required = false) oauthTokenURL: kotlin.String?,
        @Parameter(description = "OAuth private key file (multipart)") @Valid @RequestParam(value = "oauthPrivateKey", required = false) oauthPrivateKey: org.springframework.web.multipart.MultipartFile,
        @Parameter(description = "OAuth public key file (multipart)") @Valid @RequestParam(value = "oauthPublicKey", required = false) oauthPublicKey: org.springframework.web.multipart.MultipartFile,
        @Parameter(description = "OAuth client id") @Valid @RequestParam(value = "oauthClientId", required = false) oauthClientId: kotlin.String?,
        @Parameter(description = "OAuth secret key") @Valid @RequestParam(value = "oauthSecretKey", required = false) oauthSecretKey: kotlin.String?,
        @Parameter(description = "") @Valid @RequestBody(required = false) body: kotlin.String?
    ): ResponseEntity<ThirdPartyNetworkResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Update Note",
        operationId = "updateNote",
        description = """Update an existing comment (note). Only the creator of the note have permission to update.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = NoteResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/note/update"
        value = [PATH_UPDATE_NOTE],
        produces = ["*/*"]
    )
    fun updateNote(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The id of the note, used when editing a comment", required = true) @Valid @RequestParam(value = "noteId", required = true) noteId: kotlin.Long,
        @Parameter(description = "The unique device identifier that made the request (either deviceId or accountId must be used)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "The unique accountId that made the request (either deviceId or accountId must be used)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "The message the user wishes to leave a comment on") @Valid @RequestParam(value = "comment", required = false) comment: kotlin.String?,
        @Parameter(description = "The custom string defined by the client (used for differentiating on various note types)") @Valid @RequestParam(value = "noteType", required = false) noteType: kotlin.String?,
        @Parameter(description = "A comma separated list of asset IDs to add with the note") @Valid @RequestParam(value = "assetIds", required = false) assetIds: kotlin.String?,
        @Parameter(description = "search tags") @Valid @RequestParam(value = "tags", required = false) tags: kotlin.String?,
        @Parameter(description = "This is used for sending out group notifications. For example, when someone adds a note to an asset which is also a part of an album, everyone in the album will receive a notification. This is achieved by passing in the permissionable type (in this case \"album\"), and the permissionable id (the album id). Possible types: {ALBUM, ALBUM_CONTEST, GAME_LEVEL, THEME_DESCRIPTOR}") @Valid @RequestParam(value = "permissionableType", required = false) permissionableType: kotlin.String?,
        @Parameter(description = "The id of the permissionable object (for sending group notifications)") @Valid @RequestParam(value = "permissionableId", required = false) permissionableId: kotlin.Long?,
        @Parameter(description = "The application key used to identify the application") @Valid @RequestParam(value = "appKey", required = false) appKey: kotlin.String?,
        @Parameter(description = "The description of the location") @Valid @RequestParam(value = "locationDescription", required = false) locationDescription: kotlin.String?,
        @Parameter(description = "The current location of the user") @Valid @RequestParam(value = "latitude", required = false) latitude: kotlin.Double?,
        @Parameter(description = "The current location of the user") @Valid @RequestParam(value = "longitude", required = false) longitude: kotlin.Double?,
        @Parameter(description = "meta data to update with the note") @Valid @RequestParam(value = "metaData", required = false) metaData: kotlin.String?,
        @Parameter(description = "whether to return the full response or not") @Valid @RequestParam(value = "returnFullResponse", required = false) returnFullResponse: kotlin.Boolean?,
        @Parameter(description = "Sets the active flag for the note") @Valid @RequestParam(value = "active", required = false) active: kotlin.Boolean?,
        @Parameter(description = "main flag for updating asset in note, must set to true if you want to update the note's asset") @Valid @RequestParam(value = "updateAsset", required = false) updateAsset: kotlin.Boolean?,
        @Parameter(description = "Return null fields for asset response when updating an asset") @Valid @RequestParam(value = "assetReturnNulls", required = false) assetReturnNulls: kotlin.Boolean?,
        @Parameter(description = "the album the asset will be added to (optional)") @Valid @RequestParam(value = "assetAlbumId", required = false) assetAlbumId: kotlin.Long?,
        @Parameter(description = "the collection ID that the asset is associated with") @Valid @RequestParam(value = "assetCollectionId", required = false) assetCollectionId: kotlin.Long?,
        @Parameter(description = "the default album to add the asset to") @Valid @RequestParam(value = "assetAddToDefaultAlbum", required = false) assetAddToDefaultAlbum: kotlin.String?,
        @Parameter(description = "the media library to add the asset to") @Valid @RequestParam(value = "assetAddToMediaLibrary", required = false) assetAddToMediaLibrary: kotlin.Boolean?,
        @Parameter(description = "the version code of the asset") @Valid @RequestParam(value = "assetVersionCode", required = false) assetVersionCode: kotlin.Int?,
        @Parameter(description = "the version name of the asset") @Valid @RequestParam(value = "assetVersionName", required = false) assetVersionName: kotlin.String?,
        @Parameter(description = "the meta data of the asset") @Valid @RequestParam(value = "assetMetaData", required = false) assetMetaData: kotlin.String?,
        @Parameter(description = "the caption of the asset") @Valid @RequestParam(value = "assetCaption", required = false) assetCaption: kotlin.String?,
        @Parameter(description = "the media of the asset") @Valid @RequestParam(value = "assetMedia", required = false) assetMedia: org.springframework.web.multipart.MultipartFile,
        @Parameter(description = "the media URL of the asset") @Valid @RequestParam(value = "assetMediaUrl", required = false) assetMediaUrl: kotlin.String?,
        @Parameter(description = "the media string of the asset") @Valid @RequestParam(value = "assetMediaString", required = false) assetMediaString: kotlin.String?,
        @Parameter(description = "the media string file name of the asset") @Valid @RequestParam(value = "assetMediaStringFileName", required = false) assetMediaStringFileName: kotlin.String?,
        @Parameter(description = "the media string content type of the asset") @Valid @RequestParam(value = "assetMediaStringContentType", required = false) assetMediaStringContentType: kotlin.String?,
        @Parameter(description = "the attached media of the asset") @Valid @RequestParam(value = "assetAttachedMedia", required = false) assetAttachedMedia: org.springframework.web.multipart.MultipartFile,
        @Parameter(description = "the attached media URL of the asset") @Valid @RequestParam(value = "assetAttachedMediaUrl", required = false) assetAttachedMediaUrl: kotlin.String?,
        @Parameter(description = "the attached media string of the asset") @Valid @RequestParam(value = "assetAttachedMediaString", required = false) assetAttachedMediaString: kotlin.String?,
        @Parameter(description = "the attached media string file name of the asset") @Valid @RequestParam(value = "assetAttachedMediaStringFileName", required = false) assetAttachedMediaStringFileName: kotlin.String?,
        @Parameter(description = "the attached media string content type of the asset") @Valid @RequestParam(value = "assetAttachedMediaStringContentType", required = false) assetAttachedMediaStringContentType: kotlin.String?,
        @Parameter(description = "the location description for the asset") @Valid @RequestParam(value = "assetLocationDescription", required = false) assetLocationDescription: kotlin.String?,
        @Parameter(description = "the application for the asset") @Valid @RequestParam(value = "assetApp", required = false) assetApp: kotlin.String?,
        @Parameter(description = "the search tags used for the asset") @Valid @RequestParam(value = "assetSearchTags", required = false) assetSearchTags: kotlin.String?,
        @Parameter(description = "the latitude of the asset") @Valid @RequestParam(value = "assetLatitude", required = false) assetLatitude: kotlin.Double?,
        @Parameter(description = "the longitude of the asset") @Valid @RequestParam(value = "assetLongitude", required = false) assetLongitude: kotlin.Double?
    ): ResponseEntity<NoteResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Update Notification Template",
        operationId = "updateNotificationTemplate",
        description = """Update a notification template. Developers will only be able to update notification templates for their own applications.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = NotificationTemplateResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/notification/template/update"
        value = [PATH_UPDATE_NOTIFICATION_TEMPLATE],
        produces = ["*/*"]
    )
    fun updateNotificationTemplate(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The account ID of the user.", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "The notification template ID to update.", required = true) @Valid @RequestParam(value = "notificationTemplateId", required = true) notificationTemplateId: kotlin.Long,
        @Parameter(description = "The title of the message (this would become the subject title for emails). There is a 191 character limit.") @Valid @RequestParam(value = "title", required = false) title: kotlin.String?,
        @Parameter(description = "The body of the message.") @Valid @RequestParam(value = "body", required = false) body: kotlin.String?,
        @Parameter(description = "The search tags on the template used during search queries.") @Valid @RequestParam(value = "tags", required = false) tags: kotlin.String?
    ): ResponseEntity<NotificationTemplateResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Update Offer",
        operationId = "updateOffer",
        description = """Update an offer, must provide a current list of retailer locations or the current offer locations will be marked as deleted.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = RetailerOfferResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/retailer/offer/update"
        value = [PATH_UPDATE_OFFER],
        produces = ["*/*"]
    )
    fun updateOffer(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The offer to update", required = true) @Valid @RequestParam(value = "offerId", required = true) offerId: kotlin.Long,
        @NotNull @Parameter(description = "If true return all the offer locations associated with the offer", required = true) @Valid @RequestParam(value = "includeOfferLocations", required = true) includeOfferLocations: kotlin.Boolean,
        @Parameter(description = "The device id (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "The account used to perform the update, must have rights to edit the offer (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "") @Valid @RequestParam(value = "parentOfferId", required = false) parentOfferId: kotlin.Long?,
        @Parameter(description = "Comma separated list of retailer location ids. This will assign the offer to these retailer locations.") @Valid @RequestParam(value = "retailerLocationIds", required = false) retailerLocationIds: kotlin.String?,
        @Parameter(description = "A list of json data that has offer location specific values.") @Valid @RequestParam(value = "offerLocations", required = false) offerLocations: kotlin.String?,
        @Parameter(description = "Custom string field for doing full-text searches") @Valid @RequestParam(value = "tags", required = false) tags: kotlin.String?,
        @Parameter(description = "The title (255 char limit)") @Valid @RequestParam(value = "title", required = false) title: kotlin.String?,
        @Parameter(description = "The sub title (255 char limit)") @Valid @RequestParam(value = "subTitle", required = false) subTitle: kotlin.String?,
        @Parameter(description = "The details") @Valid @RequestParam(value = "details", required = false) details: kotlin.String?,
        @Parameter(description = "A string for custom details (255 char limit)") @Valid @RequestParam(value = "subDetails", required = false) subDetails: kotlin.String?,
        @Parameter(description = "The fine print") @Valid @RequestParam(value = "finePrint", required = false) finePrint: kotlin.String?,
        @Parameter(description = "The bar code type {NONE, UPC, CODE_128, QR, CUSTOM_MEDIA}", schema = Schema(allowableValues = ["NONE", "UPC", "CODE_128", "QR", "CUSTOM_MEDIA"])) @Valid @RequestParam(value = "barcodeType", required = false) barcodeType: kotlin.String?,
        @Parameter(description = "The bar code entry string") @Valid @RequestParam(value = "barcodeEntry", required = false) barcodeEntry: kotlin.String?,
        @Parameter(description = "An external identifier. What the identifier will be used for and how it is formatted is up to the frontend developer.") @Valid @RequestParam(value = "externalRedeemOptions", required = false) externalRedeemOptions: kotlin.String?,
        @Parameter(description = "The clickUrl of the offer") @Valid @RequestParam(value = "externalUrl", required = false) externalUrl: kotlin.String?,
        @Parameter(description = "") @Valid @RequestParam(value = "externalId", required = false) externalId: kotlin.String?,
        @Parameter(description = "The type of ticket to reward, null means default type") @Valid @RequestParam(value = "ticketsRewardType", required = false) ticketsRewardType: kotlin.String?,
        @Parameter(description = "Determines how many tickets are awarded") @Valid @RequestParam(value = "ticketsReward", required = false) ticketsReward: kotlin.Long?,
        @Parameter(description = "The date of when the offer will be visible to consumers") @Valid @RequestParam(value = "activated", required = false) activated: kotlin.Long?,
        @Parameter(description = "The date of when the offer expires") @Valid @RequestParam(value = "expires", required = false) expires: kotlin.Long?,
        @Parameter(description = "Overrides the expiration date so that the offer does not expire") @Valid @RequestParam(value = "noExpiration", required = false) noExpiration: kotlin.Boolean?,
        @Parameter(description = "The limit of how many times the offer can be used by consumers") @Valid @RequestParam(value = "availableLimit", required = false) availableLimit: kotlin.Int?,
        @Parameter(description = "The limit of how many times a user can used the same offer") @Valid @RequestParam(value = "availableLimitPerUser", required = false) availableLimitPerUser: kotlin.Int?,
        @Parameter(description = "The limit of how many times the offer can be added to consumer wallets") @Valid @RequestParam(value = "addedLimit", required = false) addedLimit: kotlin.Int?,
        @Parameter(description = "") @Valid @RequestParam(value = "viewLimit", required = false) viewLimit: kotlin.Int?,
        @Parameter(description = "The maximum number of times the offer can be printed") @Valid @RequestParam(value = "maxPrints", required = false) maxPrints: kotlin.Int?,
        @Parameter(description = "the type of ticket needed to buy the offer") @Valid @RequestParam(value = "ticketPriceType", required = false) ticketPriceType: kotlin.String?,
        @Parameter(description = "The cost of the offer in tickets") @Valid @RequestParam(value = "ticketPrice", required = false) ticketPrice: kotlin.Long?,
        @Parameter(description = "The retail/full price cost of the offer in real currency") @Valid @RequestParam(value = "fullPrice", required = false) fullPrice: kotlin.Double?,
        @Parameter(description = "The cost of the offer at a discounted price (what the consumer pays)") @Valid @RequestParam(value = "discountPrice", required = false) discountPrice: kotlin.Double?,
        @Parameter(description = "show remaining offers available") @Valid @RequestParam(value = "showRemaining", required = false) showRemaining: kotlin.Boolean?,
        @Parameter(description = "show how many offers have been redeemed") @Valid @RequestParam(value = "showRedeemed", required = false) showRedeemed: kotlin.Boolean?,
        @Parameter(description = "") @Valid @RequestParam(value = "replaced", required = false) replaced: kotlin.Boolean?,
        @Parameter(description = "whether the offer is featured or not") @Valid @RequestParam(value = "featured", required = false) featured: kotlin.Boolean?,
        @Parameter(description = "The offer type {VOUCHER, COUPON, PRODUCT, MEDIA, EVENT}", schema = Schema(allowableValues = ["VOUCHER", "COUPON", "PRODUCT", "MEDIA", "EVENT", "DEVICE"])) @Valid @RequestParam(value = "offerType", required = false) offerType: kotlin.String?,
        @Parameter(description = "The special offer type {ALL, REGULAR_OFFER, ACT_NOW, GET_THERE_NOW}", schema = Schema(allowableValues = ["ALL", "RESERVABLE", "REGULAR_OFFER", "ACT_NOW", "GET_THERE_NOW", "SQOOT", "TICKETS", "YIPIT"])) @Valid @RequestParam(value = "specialOfferType", required = false) specialOfferType: kotlin.String?,
        @Parameter(description = "The offer visibility {PUBLIC, REWARDABLE, TRIGGERABLE}", schema = Schema(allowableValues = ["PUBLIC", "LISTABLE", "REWARDABLE", "TRIGGERABLE", "PRIVATE"])) @Valid @RequestParam(value = "offerVisibility", required = false) offerVisibility: kotlin.String?,
        @Parameter(description = "Comma separated list of category ids") @Valid @RequestParam(value = "categoryIds", required = false) categoryIds: kotlin.String?,
        @Parameter(description = "Comma separated list of filter ids") @Valid @RequestParam(value = "filterIds", required = false) filterIds: kotlin.String?,
        @Parameter(description = "Sets the active flag") @Valid @RequestParam(value = "active", required = false) active: kotlin.Boolean?,
        @Parameter(description = "The id of the barcode asset") @Valid @RequestParam(value = "barcodeAssetId", required = false) barcodeAssetId: kotlin.Long?,
        @Parameter(description = "The id of the an offer asset") @Valid @RequestParam(value = "imageAssetId", required = false) imageAssetId: kotlin.Long?,
        @Parameter(description = "The id of the an offer asset") @Valid @RequestParam(value = "imageAssetId1", required = false) imageAssetId1: kotlin.Long?,
        @Parameter(description = "The id of the an offer asset") @Valid @RequestParam(value = "imageAssetId2", required = false) imageAssetId2: kotlin.Long?,
        @Parameter(description = "The id of the an offer asset") @Valid @RequestParam(value = "imageAssetId3", required = false) imageAssetId3: kotlin.Long?,
        @Parameter(description = "The id of the an offer asset") @Valid @RequestParam(value = "imageAssetId4", required = false) imageAssetId4: kotlin.Long?,
        @Parameter(description = "The id of the an offer asset") @Valid @RequestParam(value = "imageAssetId5", required = false) imageAssetId5: kotlin.Long?,
        @Parameter(description = "The maker of the item.") @Valid @RequestParam(value = "publisher", required = false) publisher: kotlin.String?,
        @Parameter(description = "The redeemable start date/time of the offer.") @Valid @RequestParam(value = "redeemableStart", required = false) redeemableStart: kotlin.Long?,
        @Parameter(description = "The redeemable start date/time of the offer.") @Valid @RequestParam(value = "redeemableEnd", required = false) redeemableEnd: kotlin.Long?,
        @Parameter(description = "The brand. OfferType PRODUCT only.") @Valid @RequestParam(value = "brand", required = false) brand: kotlin.String?,
        @Parameter(description = "The product type. OfferType PRODUCT only.", schema = Schema(allowableValues = ["APPAREL", "APPLIANCES", "APPS", "ARTS_CRAFTS", "AUTOMOTIVE", "BABY", "BEAUTY", "BOOKS", "CLASSICAL", "COLLECTIBLES", "DVD", "ELECTRONICS", "GIFT_CARDS", "GOURMET_FOOD", "GROCERY", "HEALTH_PERSONAL_CARE", "HOME_GARDEN", "INDUSTRIAL", "JEWELRY", "KITCHEN", "LAWN_GARDEN", "MAGAZINES", "MISCELLANEOUS", "MUSICAL_INSTRUMENTS", "OFFICE_PRODUCTS", "OTHER", "OUTDOOR_LIVING", "PC_HARDWARE", "PET_SUPPLIES", "SHOES", "SOFTWARE", "SPORTING_GOODS", "TOOLS", "TOYS", "VIDEO_GAMES", "WATCHES", "WIRELESS", "WIRELESS_ACCESSORIES"])) @Valid @RequestParam(value = "productType", required = false) productType: kotlin.String?,
        @Parameter(description = "The condition. OfferType PRODUCT only.", schema = Schema(allowableValues = ["NEW", "USED", "REFURBISHED", "OTHER"])) @Valid @RequestParam(value = "conditionType", required = false) conditionType: kotlin.String?,
        @Parameter(description = "The ISBN id. OfferType PRODUCT only.") @Valid @RequestParam(value = "isbn", required = false) isbn: kotlin.String?,
        @Parameter(description = "The ASIN id. OfferType PRODUCT only.") @Valid @RequestParam(value = "asin", required = false) asin: kotlin.String?,
        @Parameter(description = "The list of catelog numbers, comma seperated. OfferType PRODUCT only.") @Valid @RequestParam(value = "catalogNumbers", required = false) catalogNumbers: kotlin.String?,
        @Parameter(description = "The department name. The OfferType PRODUCT only.") @Valid @RequestParam(value = "department", required = false) department: kotlin.String?,
        @Parameter(description = "The list of features, comma seperated. OfferType PRODUCT only.") @Valid @RequestParam(value = "features", required = false) features: kotlin.String?,
        @Parameter(description = "The MAP price. OfferType PRODUCT only.") @Valid @RequestParam(value = "minimumPrice", required = false) minimumPrice: kotlin.Double?,
        @Parameter(description = "The width of the item. OfferType PRODUCT only.") @Valid @RequestParam(value = "width", required = false) width: kotlin.Double?,
        @Parameter(description = "The height of the item. OfferType PRODUCT only.") @Valid @RequestParam(value = "height", required = false) height: kotlin.Double?,
        @Parameter(description = "The depth of the item. OfferType PRODUCT only.") @Valid @RequestParam(value = "depth", required = false) depth: kotlin.Double?,
        @Parameter(description = "The weight of the item. OfferType PRODUCT only.") @Valid @RequestParam(value = "weight", required = false) weight: kotlin.Double?,
        @Parameter(description = "The unit of measurement. OfferType PRODUCT only.", schema = Schema(allowableValues = ["MILIMETER", "CENTIMETER", "METER", "INCH", "FOOT", "YARD"])) @Valid @RequestParam(value = "unit", required = false) unit: kotlin.String?,
        @Parameter(description = "The studio name. OfferType PRODUCT only.") @Valid @RequestParam(value = "studio", required = false) studio: kotlin.String?,
        @Parameter(description = "The parental control rating. OfferType PRODUCT only.") @Valid @RequestParam(value = "parentalRating", required = false) parentalRating: kotlin.String?,
        @Parameter(description = "The date published. OfferType PRODUCT only.") @Valid @RequestParam(value = "publishDate", required = false) publishDate: kotlin.Long?,
        @Parameter(description = "The date available. OfferType PRODUCT only.") @Valid @RequestParam(value = "availabilityDate", required = false) availabilityDate: kotlin.Long?,
        @Parameter(description = "The size Id. OfferType PRODUCT only.") @Valid @RequestParam(value = "sizeId", required = false) sizeId: kotlin.Long?,
        @Parameter(description = "The ID of the event listing") @Valid @RequestParam(value = "listingId", required = false) listingId: kotlin.Long?,
        @Parameter(description = "", schema = Schema(allowableValues = ["APK", "APPLICATION", "IMAGE", "AUDIO", "VIDEO", "MULTIPART", "BAR_CODE", "TEXT", "OTHER"])) @Valid @RequestParam(value = "mediaType", required = false) mediaType: kotlin.String?,
        @Parameter(description = "The total playing time of the media item. OfferType MEDIA only.") @Valid @RequestParam(value = "duration", required = false) duration: kotlin.Int?,
        @Parameter(description = "The created/author of the media item. OfferType MEDIA only.") @Valid @RequestParam(value = "author", required = false) author: kotlin.String?,
        @Parameter(description = "The date/time of when the media item was originally released. OfferType MEDIA only.") @Valid @RequestParam(value = "releaseDate", required = false) releaseDate: kotlin.Long?,
        @Parameter(description = "") @Valid @RequestParam(value = "collectionIds", required = false) collectionIds: kotlin.String?,
        @Parameter(description = "The reboot hour time ranging from 0 to 23") @Valid @RequestParam(value = "rebootTimeHour", required = false) rebootTimeHour: kotlin.Int?,
        @Parameter(description = "The reboot minute time ranging from 0 to 59") @Valid @RequestParam(value = "rebootTimeMinute", required = false) rebootTimeMinute: kotlin.Int?,
        @Parameter(description = "If the device is idle for idleTimeoutInSecond then the device should timeout") @Valid @RequestParam(value = "idleTimeoutInSecond", required = false) idleTimeoutInSecond: kotlin.Int?,
        @Parameter(description = "The serial number on the device") @Valid @RequestParam(value = "serialNumber", required = false) serialNumber: kotlin.String?,
        @Parameter(description = "The unique device id for the device") @Valid @RequestParam(value = "udid", required = false) udid: kotlin.String?,
        @Parameter(description = "The type of the device, for example: \"Kiosk\", \"Beacon\".") @Valid @RequestParam(value = "deviceType", required = false) deviceType: kotlin.String?,
        @Parameter(description = "RSSI reading at 1 meter from device (-10 to -140)") @Valid @RequestParam(value = "devicePower", required = false) devicePower: kotlin.Double?,
        @Parameter(description = "") @Valid @RequestParam(value = "deviceInterference", required = false) deviceInterference: kotlin.Double?,
        @Parameter(description = "") @Valid @RequestParam(value = "availability", required = false) availability: kotlin.String?,
        @Parameter(description = "") @Valid @RequestParam(value = "availabilitySummary", required = false) availabilitySummary: kotlin.String?
    ): ResponseEntity<RetailerOfferResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Activate Offer",
        operationId = "updateOfferStatus",
        description = """Sets the activated date on offers. This will make offers visible for consumers.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/retailer/offer/status"
        value = [PATH_UPDATE_OFFER_STATUS],
        produces = ["*/*"]
    )
    fun updateOfferStatus(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "Comma separated list of offer ids", required = true) @Valid @RequestParam(value = "offerIds", required = true) offerIds: kotlin.String,
        @NotNull @Parameter(description = "Determines whether to make the offer active as well", required = true) @Valid @RequestParam(value = "active", required = true) active: kotlin.Boolean,
        @Parameter(description = "The device id (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "The account used to perform the activation, must have rights to edit the offer.") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Update Wallet Offer",
        operationId = "updateOfferTransaction",
        description = """Update offer status. The status values are: 0 - not redeemable, 1 - redeemable.

Not redeemable means the customer has received the offer but has not decided to use (or print) it yet.  Until they choose to do this the merchant cannot redeem the offer (has not been given permission yet). 

Redeemable means the customer has chosen to use the offer and wishes to redeem it.

Redeemed means the merchant has accepted the offer and the given the customer its value, then marked it a used in the system.  This status change is handled by a merchant end point.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = OfferTransactionResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/wallet/update"
        value = [PATH_UPDATE_OFFER_TRANSACTION],
        produces = ["*/*"]
    )
    fun updateOfferTransaction(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The offer transaction id to remove", required = true) @Valid @RequestParam(value = "transactionId", required = true) transactionId: kotlin.Long,
        @NotNull @Parameter(description = "The status value to change to (0 or 1)", required = true) @Valid @RequestParam(value = "status", required = true) status: kotlin.Int,
        @Parameter(description = "The device id (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "The account id of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "Offer Location Id") @Valid @RequestParam(value = "offerLocationId", required = false) offerLocationId: kotlin.Long?,
        @Parameter(description = "Currency Type", schema = Schema(defaultValue = "CASH")) @Valid @RequestParam(value = "currencyType", required = false, defaultValue = "CASH") currencyType: kotlin.String,
        @Parameter(description = "Use Points") @Valid @RequestParam(value = "usePoints", required = false) usePoints: kotlin.Boolean?,
        @Parameter(description = "App Key") @Valid @RequestParam(value = "appKey", required = false) appKey: kotlin.String?,
        @Parameter(description = "The latitude location of the user") @Valid @RequestParam(value = "latitude", required = false) latitude: kotlin.Double?,
        @Parameter(description = "The latitude location of the user") @Valid @RequestParam(value = "longitude", required = false) longitude: kotlin.Double?,
        @Parameter(description = "External custom client defined data") @Valid @RequestParam(value = "metaData", required = false) metaData: kotlin.String?,
        @Parameter(description = "Determines whether to return a detailed version of the response", schema = Schema(defaultValue = "false")) @Valid @RequestParam(value = "returnFullResponse", required = false, defaultValue = "false") returnFullResponse: kotlin.Boolean,
        @Parameter(description = "Exception Offers, transaction audiences of these offers won't be removed out of the account when up") @Valid @RequestParam(value = "exceptionMembershipOfferIds", required = false) exceptionMembershipOfferIds: kotlin.String?
    ): ResponseEntity<OfferTransactionResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Update Offer Status",
        operationId = "updateOfferTransactionStatus",
        description = """Update an offer status record""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = OfferTransactionStatusResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/offer/status/update"
        value = [PATH_UPDATE_OFFER_TRANSACTION_STATUS],
        produces = ["*/*"]
    )
    fun updateOfferTransactionStatus(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "The device id (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "The account id of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "Used to update the user's current location") @Valid @RequestParam(value = "latitude", required = false) latitude: kotlin.Double?,
        @Parameter(description = "Used to update the user's current location") @Valid @RequestParam(value = "longitude", required = false) longitude: kotlin.Double?,
        @Parameter(description = "The id of the record to update ") @Valid @RequestParam(value = "statusId", required = false) statusId: kotlin.Long?,
        @Parameter(description = "The name of th status") @Valid @RequestParam(value = "name", required = false) name: kotlin.String?,
        @Parameter(description = "The description of the status") @Valid @RequestParam(value = "description", required = false) description: kotlin.String?,
        @Parameter(description = "The status code, must be unique ") @Valid @RequestParam(value = "code", required = false) code: kotlin.Int?,
        @Parameter(description = "The actor that uses the status") @Valid @RequestParam(value = "role", required = false) role: kotlin.String?,
        @Parameter(description = "The active status") @Valid @RequestParam(value = "active", required = false) active: kotlin.Boolean?,
        @Parameter(description = "The applications to associate the status with, if null then for all.") @Valid @RequestParam(value = "applicationIds", required = false) applicationIds: kotlin.String?
    ): ResponseEntity<OfferTransactionStatusResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Update Order",
        operationId = "updateOrder",
        description = """Updates new purchase with some number of items associated with it. The orderId provided is used to retrieve the record and the payment is added to it.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = OrderResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/order/update"
        value = [PATH_UPDATE_ORDER],
        produces = ["*/*"]
    )
    fun updateOrder(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The order to add the purchase to, leave null for new order.", required = true) @Valid @RequestParam(value = "orderId", required = true) orderId: kotlin.Long,
        @NotNull @Parameter(description = "The application requesting the purchase", required = true) @Valid @RequestParam(value = "appKey", required = true) appKey: kotlin.String,
        @NotNull @Parameter(description = "```json [   { \"orderItemType\": \"OFFER\", \"orderItemId\": 234, \"orderCustomType\": \"OfferLocation\", \"orderCustomId\": 123, \"retailerLocationId\": 1234, \"quantity\": 2 },   { \"orderItemType\": \"OFFER\", \"orderItemId\": 235, \"quantity\": 2 },   { \"orderItemType\": \"CUSTOM\", \"amount\": 10.50, \"orderCustomType\": \"ServiceFee\" },   { \"orderItemType\": \"CUSTOM\", \"amount\": 25.10, \"quantity\": 2, \"orderCustomType\": \"Hat\", \"orderCustomId\": 123 } ] ``` ", required = true) @Valid @RequestParam(value = "cart", required = true) cart: kotlin.String,
        @Parameter(description = "The device id (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "The account id of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "The payment transaction to apply the refund to") @Valid @RequestParam(value = "paymentTransactionId", required = false) paymentTransactionId: kotlin.Long?,
        @Parameter(description = "A description of the purchase") @Valid @RequestParam(value = "description", required = false) description: kotlin.String?,
        @Parameter(description = "Determines the method of purchasing offer.  * VOID: used for when there is no payment involved (ie. for updating the status of a purchase order)  * CASH: use card on file  * POINTS: use account balance  * TICKETS: use tickets  * REFUND: not allowed for a create, requires a paymentTransactionId.  * CREDIT: add to the account balance  * RELOAD: charge a credit card then add to the account balance  ", schema = Schema(allowableValues = ["VOID", "CASH", "POINTS", "TICKETS", "REFUND", "CREDIT", "RELOAD"], defaultValue = "CASH")) @Valid @RequestParam(value = "currencyType", required = false, defaultValue = "CASH") currencyType: kotlin.String,
        @Parameter(description = "Use a specific payment method (CASH), if not provided use default") @Valid @RequestParam(value = "paymentMethodId", required = false) paymentMethodId: kotlin.Long?,
        @Parameter(description = "Store identifier from external system") @Valid @RequestParam(value = "externalPaymentId", required = false) externalPaymentId: kotlin.String?,
        @Parameter(description = "External Date") @Valid @RequestParam(value = "externalDate", required = false) externalDate: kotlin.Long?
    ): ResponseEntity<OrderResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Update Pack",
        operationId = "updatePack",
        description = """Update a pack.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = PackResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/pack/update"
        value = [PATH_UPDATE_PACK],
        produces = ["*/*"]
    )
    fun updatePack(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The logged in user.", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "The id of the pack to update.", required = true) @Valid @RequestParam(value = "packId", required = true) packId: kotlin.Long,
        @NotNull @Parameter(description = "Flag to indicate owner should receive tickets for completed packs", required = true) @Valid @RequestParam(value = "allocateTickets", required = true) allocateTickets: kotlin.Boolean,
        @NotNull @Parameter(description = "The number of tickets to reward", required = true) @Valid @RequestParam(value = "ticketCount", required = true) ticketCount: kotlin.Long,
        @Parameter(description = "The title of the pack") @Valid @RequestParam(value = "title", required = false) title: kotlin.String?,
        @Parameter(description = "The description of the pack") @Valid @RequestParam(value = "description", required = false) description: kotlin.String?,
        @Parameter(description = "The tags for searching the pack, comma separated") @Valid @RequestParam(value = "searchTags", required = false) searchTags: kotlin.String?,
        @Parameter(description = "Activate/deactivate the pack") @Valid @RequestParam(value = "active", required = false) active: kotlin.Boolean?,
        @Parameter(description = "This parameter is deprecated.") @Valid @RequestParam(value = "gameType", required = false) gameType: kotlin.String?,
        @Parameter(description = "The application key used to identify the application") @Valid @RequestParam(value = "appKey", required = false) appKey: kotlin.String?,
        @Parameter(description = "The type of the pack", schema = Schema(allowableValues = ["TUTORIAL", "BUILTIN", "DOWNLOAD", "THRESHOLD", "THEME", "TOURNAMENT"])) @Valid @RequestParam(value = "packType", required = false) packType: kotlin.String?,
        @Parameter(description = "The order of the pack") @Valid @RequestParam(value = "packOrder", required = false) packOrder: kotlin.Long?,
        @Parameter(description = "The type of game sequence of the pack", schema = Schema(allowableValues = ["FIRST_AVAILABLE", "ALL_AVAILABLE"])) @Valid @RequestParam(value = "sequenceType", required = false) sequenceType: kotlin.String?,
        @Parameter(description = "The background asset id of the pack") @Valid @RequestParam(value = "backgroundId", required = false) backgroundId: kotlin.Long?,
        @Parameter(description = "The image asset id of the pack") @Valid @RequestParam(value = "imageId", required = false) imageId: kotlin.Long?,
        @Parameter(description = "The date/time to start the pack, send 0 to unset") @Valid @RequestParam(value = "startDate", required = false) startDate: kotlin.Long?,
        @Parameter(description = "The date/time to end the pack, send 0 to unset") @Valid @RequestParam(value = "endDate", required = false) endDate: kotlin.Long?,
        @Parameter(description = "") @Valid @RequestParam(value = "authorOverride", required = false) authorOverride: kotlin.String?,
        @Parameter(description = "The price in tickets to purchase this pack") @Valid @RequestParam(value = "price", required = false) price: kotlin.Int?,
        @Parameter(description = "the type of ticket required to purchase this pack") @Valid @RequestParam(value = "priceType", required = false) priceType: kotlin.String?,
        @Parameter(description = "the game level ids to include in the pack, comma separated") @Valid @RequestParam(value = "gameLevelIds", required = false) gameLevelIds: kotlin.String?,
        @Parameter(description = "") @Valid @RequestParam(value = "inGame", required = false) inGame: kotlin.Boolean?,
        @Parameter(description = "The scoring is highest is best") @Valid @RequestParam(value = "highest", required = false) highest: kotlin.Boolean?,
        @Parameter(description = "The type of ticket to reward, null means default type") @Valid @RequestParam(value = "ticketType", required = false) ticketType: kotlin.String?,
        @Parameter(description = "The number of points to award for completing a pack") @Valid @RequestParam(value = "points", required = false) points: kotlin.Long?
    ): ResponseEntity<PackResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Update Persona",
        operationId = "updatePersona",
        description = """Update the persona by the given personaId. If the given params are null those attributes will be override by null. If active is assigned, all other params will be ignored.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = PreviewPersonaResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/persona/update"
        value = [PATH_UPDATE_PERSONA],
        produces = ["*/*"]
    )
    fun updatePersona(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the account ID of the user", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "the persona ID of the persona to update", required = true) @Valid @RequestParam(value = "personaId", required = true) personaId: kotlin.Long,
        @Parameter(description = "the title of the persona") @Valid @RequestParam(value = "title", required = false) title: kotlin.String?,
        @Parameter(description = "the accounts that are able to preview from this persona") @Valid @RequestParam(value = "previewAccounts", required = false) previewAccounts: kotlin.String?,
        @Parameter(description = "the status of the persona, there can only be one active persona per account") @Valid @RequestParam(value = "active", required = false) active: kotlin.Boolean?,
        @Parameter(description = "the sepcified date that this persona is viewing the app") @Valid @RequestParam(value = "date", required = false) date: kotlin.Long?,
        @Parameter(description = "the specified age of this persona") @Valid @RequestParam(value = "age", required = false) age: kotlin.Int?,
        @Parameter(description = "the specified gender of this persona") @Valid @RequestParam(value = "gender", required = false) gender: kotlin.String?,
        @Parameter(description = "the specified experience level of the persona") @Valid @RequestParam(value = "gameExperienceLevel", required = false) gameExperienceLevel: kotlin.String?,
        @Parameter(description = "the specified latitude of the persona") @Valid @RequestParam(value = "latitude", required = false) latitude: kotlin.Double?,
        @Parameter(description = "the specified longitude of the persona") @Valid @RequestParam(value = "longitude", required = false) longitude: kotlin.Double?
    ): ResponseEntity<PreviewPersonaResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Update Postal Code",
        operationId = "updatePostalCode",
        description = """Update a Postal Code""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = PostalCodeResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/postalCode/update"
        value = [PATH_UPDATE_POSTAL_CODE],
        produces = ["*/*"]
    )
    fun updatePostalCode(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the id of the logged in user", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "the id of the postal code to update", required = true) @Valid @RequestParam(value = "postalCodeId", required = true) postalCodeId: kotlin.Long,
        @Parameter(description = "the postal code to update") @Valid @RequestParam(value = "code", required = false) code: kotlin.String?,
        @Parameter(description = "the latitude of the postal code") @Valid @RequestParam(value = "latitude", required = false) latitude: kotlin.Double?,
        @Parameter(description = "the longitude of the postal code") @Valid @RequestParam(value = "longitude", required = false) longitude: kotlin.Double?,
        @Parameter(description = "the state code (e.g. WA, WI, WY) where the postal code is located") @Valid @RequestParam(value = "stateCode", required = false) stateCode: kotlin.String?,
        @Parameter(description = "the city where the postal code is located") @Valid @RequestParam(value = "city", required = false) city: kotlin.String?,
        @Parameter(description = "whether the postal code is active or inactive") @Valid @RequestParam(value = "active", required = false) active: kotlin.Boolean?
    ): ResponseEntity<PostalCodeResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Update Purchase",
        operationId = "updatePurchaseItem",
        description = """Updates a purchase item for in app purchases""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = PurchaseItemFullResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/purchase/update"
        value = [PATH_UPDATE_PURCHASE_ITEM],
        produces = ["*/*"]
    )
    fun updatePurchaseItem(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The purchase item id", required = true) @Valid @RequestParam(value = "purchaseItemId", required = true) purchaseItemId: kotlin.Long,
        @Parameter(description = "The device id (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "The account id of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "The name of the purchase item") @Valid @RequestParam(value = "name", required = false) name: kotlin.String?,
        @Parameter(description = "The description of the purchase item") @Valid @RequestParam(value = "description", required = false) description: kotlin.String?,
        @Parameter(description = "How much the purchase item is worth in tickets") @Valid @RequestParam(value = "tickets", required = false) tickets: kotlin.Int?,
        @Parameter(description = "How much the purchase item will cost in real money") @Valid @RequestParam(value = "price", required = false) price: kotlin.Float?,
        @Parameter(description = "The purchase provider <ul> <li>SIRQUL - the Sirqul store to make purchases using tickets</li> <li>IOS - the iTunes store for iPhone, iPod, iPod Touch</li> <li>GOOGLE - the Google Play store</li> <li>AMAZON - the Amazon Android store</li> <li>MAC - the iTunes store for OSX</li> <li>WP8 - the Windows Phone 8 store</li> <li>FREE - used for purchase items that are free (can be used for development/testing purposes)</li> </ul>", schema = Schema(allowableValues = ["SIRQUL", "IOS", "GOOGLE", "AMAZON", "MAC", "WP8", "FREE"])) @Valid @RequestParam(value = "purchaseType", required = false) purchaseType: kotlin.String?,
        @Parameter(description = "The unique identifier used by purchase providers to identify in-app-purchases") @Valid @RequestParam(value = "purchaseCode", required = false) purchaseCode: kotlin.String?,
        @Parameter(description = "A secret key from purchase providers that would be used for validation") @Valid @RequestParam(value = "secretKey", required = false) secretKey: kotlin.String?,
        @Parameter(description = "How many times a user acquire the same purchase item") @Valid @RequestParam(value = "purchaseLimit", required = false) purchaseLimit: kotlin.Int?,
        @Parameter(description = "Determines whether the purchase item will enable certain features <ul> <li>DAY_PREMIUM - subscribes a user for a day of membership</li> <li>WEEK_PREMIUM - subscribes a user for a week of membership</li> <li>MONTH_PREMIUM - subscribes a user for a month of membership</li> <li>ADD_TICKET - allows a user to add more tickets to their account</li> <li>ADD_GIFT - allows a user to send/recieve the purchase item as a gift</li> </ul>", schema = Schema(allowableValues = ["DAY_PREMIUM", "WEEK_PREMIUM", "MONTH_PREMIUM", "YEAR_PREMIUM", "LIFETIME_PREMIUM", "ADD_TICKET", "ADD_GIFT", "ADD_POINTS"])) @Valid @RequestParam(value = "serviceAction", required = false) serviceAction: kotlin.String?,
        @Parameter(description = "The cover image of the purchase item") @Valid @RequestParam(value = "coverAssetId", required = false) coverAssetId: kotlin.Long?,
        @Parameter(description = "An application specific asset that can be used to store/provide additional data") @Valid @RequestParam(value = "promoAssetId", required = false) promoAssetId: kotlin.Long?,
        @Parameter(description = "Determines whether the purchase item can be gifted to other users") @Valid @RequestParam(value = "giftable", required = false) giftable: kotlin.Boolean?,
        @Parameter(description = "Determines whether users can attach their own media/asset to the purchase item") @Valid @RequestParam(value = "assetable", required = false) assetable: kotlin.Boolean?,
        @Parameter(description = "Sets whether the purchase item is active or inactive (hidden from consumers)") @Valid @RequestParam(value = "active", required = false) active: kotlin.Boolean?,
        @Parameter(description = "Flag to indicate owner should receive tickets for completed missions", schema = Schema(defaultValue = "false")) @Valid @RequestParam(value = "allocateTickets", required = false, defaultValue = "false") allocateTickets: kotlin.Boolean,
        @Parameter(description = "The type of ticket to reward, null means default type") @Valid @RequestParam(value = "ticketType", required = false) ticketType: kotlin.String?,
        @Parameter(description = "The number of points to award for completing a mission") @Valid @RequestParam(value = "points", required = false) points: kotlin.Long?,
        @Parameter(description = "The offer location that will get added to the user's wallet after purchase.") @Valid @RequestParam(value = "offerLocationId", required = false) offerLocationId: kotlin.Long?
    ): ResponseEntity<PurchaseItemFullResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Update Question",
        operationId = "updateQuestion",
        description = """Update a question and related answers.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = QuestionResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/game/question/update"
        value = [PATH_UPDATE_QUESTION],
        produces = ["*/*"]
    )
    fun updateQuestion(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The id of the question to update.", required = true) @Valid @RequestParam(value = "questionId", required = true) questionId: kotlin.Long,
        @NotNull @Parameter(description = "The logged in user.", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "The number of tickets to reward", required = true) @Valid @RequestParam(value = "ticketCount", required = true) ticketCount: kotlin.Long,
        @Parameter(description = "The text of the question.") @Valid @RequestParam(value = "question", required = false) question: kotlin.String?,
        @Parameter(description = "The json representations of answers for the question.") @Valid @RequestParam(value = "answers", required = false) answers: kotlin.String?,
        @Parameter(description = "The tags of the question for search.") @Valid @RequestParam(value = "tags", required = false) tags: kotlin.String?,
        @Parameter(description = "The video link for the question.") @Valid @RequestParam(value = "videoURL", required = false) videoURL: kotlin.String?,
        @Parameter(description = "The asset id of the question.") @Valid @RequestParam(value = "assetId", required = false) assetId: kotlin.Long?,
        @Parameter(description = "If true set the question to active.") @Valid @RequestParam(value = "active", required = false) active: kotlin.Boolean?,
        @Parameter(description = "If true then scoring will give tickets.") @Valid @RequestParam(value = "allocateTickets", required = false) allocateTickets: kotlin.Boolean?,
        @Parameter(description = "The type of ticket to reward, null means default type") @Valid @RequestParam(value = "ticketType", required = false) ticketType: kotlin.String?,
        @Parameter(description = "The number of points to award for completing a mission") @Valid @RequestParam(value = "points", required = false) points: kotlin.Long?
    ): ResponseEntity<QuestionResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Update Level Questions",
        operationId = "updateQuestionsInLevel",
        description = """Updates a level with question game objects.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/level/questions/update"
        value = [PATH_UPDATE_QUESTIONS_IN_LEVEL],
        produces = ["*/*"]
    )
    fun updateQuestionsInLevel(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the id of the level to update questions on", required = true) @Valid @RequestParam(value = "levelId", required = true) levelId: kotlin.Long,
        @NotNull @Parameter(description = "the id of the logged in user", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "the IDs of the questions to update", required = true) @Valid @RequestParam(value = "questionIds", required = true) questionIds: kotlin.String
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Update Ranking",
        operationId = "updateRankings",
        description = """Update the rank value """,
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/ranking/update"
        value = [PATH_UPDATE_RANKINGS],
        produces = ["*/*"]
    )
    fun updateRankings(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the account id of the user", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "the application key for filtering results by application", required = true) @Valid @RequestParam(value = "appKey", required = true) appKey: kotlin.String,
        @NotNull @Parameter(description = "a unique label for identifying the ranking. This can be any alphanumeric string (no spaces or special characters) with a maximum length of 64 characters. There are also default rank types to use which include: POINTS, DOWNLOADS, INVITATIONS, CREATIONS, VOTES, REDEEMED, ACTIONS", required = true) @Valid @RequestParam(value = "rankType", required = true) rankType: kotlin.String,
        @Parameter(description = "the value to increment", schema = Schema(defaultValue = "1L")) @Valid @RequestParam(value = "increment", required = false, defaultValue = "1L") increment: kotlin.Long,
        @Parameter(description = "the time value to increment") @Valid @RequestParam(value = "timeIncrement", required = false) timeIncrement: kotlin.Long?,
        @Parameter(description = "the analytic tag for this achievement (used to validate scores)") @Valid @RequestParam(value = "tag", required = false) tag: kotlin.String?,
        @Parameter(description = "custom date you can save along with the score for the user") @Valid @RequestParam(value = "startDate", required = false) startDate: kotlin.Long?,
        @Parameter(description = "custom date you can save along with the score for the user") @Valid @RequestParam(value = "endDate", required = false) endDate: kotlin.Long?,
        @Parameter(description = "update the global rankings if true, default is false") @Valid @RequestParam(value = "updateGlobal", required = false) updateGlobal: kotlin.Boolean?,
        @Parameter(description = "create the leaderboard if it does not exist (default false)", schema = Schema(defaultValue = "false")) @Valid @RequestParam(value = "createLeaderboard", required = false, defaultValue = "false") createLeaderboard: kotlin.Boolean
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Update Rating",
        operationId = "updateRating",
        description = """Update an existing rating. Only the creator of the rating have permission to update.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = RatingResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/rating/update"
        value = [PATH_UPDATE_RATING],
        produces = ["*/*"]
    )
    fun updateRating(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The id of the rating (Note: this is not the ratable object id)", required = true) @Valid @RequestParam(value = "ratingId", required = true) ratingId: kotlin.Long,
        @Parameter(description = "The unique device identifier that made the request (either deviceId or accountId must be used)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "The unique accountId that made the request (either deviceId or accountId must be used)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "The rating value to update") @Valid @RequestParam(value = "ratingValue", required = false) ratingValue: kotlin.Int?,
        @Parameter(description = "") @Valid @RequestParam(value = "categoryId", required = false) categoryId: kotlin.Long?,
        @Parameter(description = "A subject title for the user rating (limited to 255 characters)") @Valid @RequestParam(value = "display", required = false) display: kotlin.String?,
        @Parameter(description = "The description of the rating") @Valid @RequestParam(value = "description", required = false) description: kotlin.String?,
        @Parameter(description = "The description of the location") @Valid @RequestParam(value = "locationDescription", required = false) locationDescription: kotlin.String?,
        @Parameter(description = "The current location of the user") @Valid @RequestParam(value = "latitude", required = false) latitude: kotlin.Double?,
        @Parameter(description = "The current location of the user") @Valid @RequestParam(value = "longitude", required = false) longitude: kotlin.Double?
    ): ResponseEntity<RatingResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Update Recurrence Locations",
        operationId = "updateRecurrenceLocations",
        description = """""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(array = ArraySchema(schema = Schema(implementation = Trip::class)))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/trip/{id}/locations/recurrence"
        value = [PATH_UPDATE_RECURRENCE_LOCATIONS],
        produces = ["*/*"]
    )
    fun updateRecurrenceLocations(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "the id of the trip", required = true) @PathVariable("id") id: kotlin.Long,
        @Parameter(description = "") @Valid @RequestBody(required = false) body: Trip?
    ): ResponseEntity<List<Trip>> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Update Recurrence Shipments",
        operationId = "updateRecurrenceShipments",
        description = """""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(array = ArraySchema(schema = Schema(implementation = Trip::class)))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/trip/{id}/shipments/recurrence"
        value = [PATH_UPDATE_RECURRENCE_SHIPMENTS],
        produces = ["*/*"]
    )
    fun updateRecurrenceShipments(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "the id of the trip", required = true) @PathVariable("id") id: kotlin.Long,
        @Parameter(description = "") @Valid @RequestBody(required = false) body: Trip?
    ): ResponseEntity<List<Trip>> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Update Region",
        operationId = "updateRegion",
        description = """Update a region.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = RegionResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/region/update"
        value = [PATH_UPDATE_REGION],
        produces = ["*/*"]
    )
    fun updateRegion(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The id of the account sending the request", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "The id of the region to be updated", required = true) @Valid @RequestParam(value = "regionId", required = true) regionId: kotlin.Long,
        @Parameter(description = "RegionClass of this region") @Valid @RequestParam(value = "regionClass", required = false) regionClass: kotlin.String?,
        @Parameter(description = "Short name of the region. This is optimized for search") @Valid @RequestParam(value = "shortName", required = false) shortName: kotlin.String?,
        @Parameter(description = "Full name of the region") @Valid @RequestParam(value = "fullName", required = false) fullName: kotlin.String?,
        @Parameter(description = "Comma separated region ids that are parents of this region") @Valid @RequestParam(value = "parentIds", required = false) parentIds: kotlin.String?,
        @Parameter(description = "Comma separated region ids that are children of this region") @Valid @RequestParam(value = "childrenIds", required = false) childrenIds: kotlin.String?,
        @Parameter(description = "Comma separated postal code ids the region will include") @Valid @RequestParam(value = "postalCodeIds", required = false) postalCodeIds: kotlin.String?,
        @Parameter(description = "Sets of name,lat,long used to create new postal codes assigned to the region") @Valid @RequestParam(value = "locations", required = false) locations: kotlin.String?,
        @Parameter(description = "the retailer location ID that the region is associated with") @Valid @RequestParam(value = "retailerLocationId", required = false) retailerLocationId: kotlin.Long?,
        @Parameter(description = "The Visibility of the region", schema = Schema(allowableValues = ["PUBLIC", "PRIVATE", "FRIENDS"])) @Valid @RequestParam(value = "visibility", required = false) visibility: kotlin.String?,
        @Parameter(description = "the categories that the region is assigned to") @Valid @RequestParam(value = "categoryIds", required = false) categoryIds: kotlin.String?,
        @Parameter(description = "the filters that the region is assigned to") @Valid @RequestParam(value = "filterIds", required = false) filterIds: kotlin.String?,
        @Parameter(description = "") @Valid @RequestParam(value = "start", required = false) start: kotlin.Long?,
        @Parameter(description = "") @Valid @RequestParam(value = "end", required = false) end: kotlin.Long?,
        @Parameter(description = "the polygon of the region") @Valid @RequestParam(value = "polygon", required = false) polygon: kotlin.String?,
        @Parameter(description = "the meta data of the region") @Valid @RequestParam(value = "metaData", required = false) metaData: kotlin.String?,
        @Parameter(description = "the latitude of the region") @Valid @RequestParam(value = "latitude", required = false) latitude: kotlin.Double?,
        @Parameter(description = "the longitude of the region") @Valid @RequestParam(value = "longitude", required = false) longitude: kotlin.Double?,
        @Parameter(description = "the version code") @Valid @RequestParam(value = "versionCode", required = false) versionCode: kotlin.Int?,
        @Parameter(description = "If this is a root region or not. If true means this region has no parent regions") @Valid @RequestParam(value = "root", required = false) root: kotlin.Boolean?,
        @Parameter(description = "Active or inactive status of the region") @Valid @RequestParam(value = "active", required = false) active: kotlin.Boolean?,
        @Parameter(description = "If true clear the children and postal code lists before add new ones, otherwise just append.") @Valid @RequestParam(value = "clearLists", required = false) clearLists: kotlin.Boolean?
    ): ResponseEntity<RegionResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Update Retailer",
        operationId = "updateRetailer",
        description = """Update a retailer record. Only the owner and the employees of the retailer have access to update its information.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = RetailerFullResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/retailer/update"
        value = [PATH_UPDATE_RETAILER],
        produces = ["*/*"]
    )
    fun updateRetailer(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The ID of the retailer to update", required = true) @Valid @RequestParam(value = "retailerId", required = true) retailerId: kotlin.Long,
        @Parameter(description = "The device id (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "The account id of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "The name of the retailer") @Valid @RequestParam(value = "name", required = false) name: kotlin.String?,
        @Parameter(description = "The street address of the retailer") @Valid @RequestParam(value = "streetAddress", required = false) streetAddress: kotlin.String?,
        @Parameter(description = "Additional address information (such as a suite number, floor number, building name, or PO Box)") @Valid @RequestParam(value = "streetAddress2", required = false) streetAddress2: kotlin.String?,
        @Parameter(description = "The city of the retailer") @Valid @RequestParam(value = "city", required = false) city: kotlin.String?,
        @Parameter(description = "The state of the retailer") @Valid @RequestParam(value = "state", required = false) state: kotlin.String?,
        @Parameter(description = "The postal code of the retailer") @Valid @RequestParam(value = "postalCode", required = false) postalCode: kotlin.String?,
        @Parameter(description = "the country of the retailer") @Valid @RequestParam(value = "country", required = false) country: kotlin.String?,
        @Parameter(description = "The business phone of the retailer") @Valid @RequestParam(value = "businessPhone", required = false) businessPhone: kotlin.String?,
        @Parameter(description = "The business phone extension of the retailer") @Valid @RequestParam(value = "businessPhoneExt", required = false) businessPhoneExt: kotlin.String?,
        @Parameter(description = "The website of the retailer") @Valid @RequestParam(value = "website", required = false) website: kotlin.String?,
        @Parameter(description = "The email of the retailer") @Valid @RequestParam(value = "email", required = false) email: kotlin.String?,
        @Parameter(description = "The facebook URL of the retailer") @Valid @RequestParam(value = "facebookUrl", required = false) facebookUrl: kotlin.String?,
        @Parameter(description = "The twitter URL of the retailer") @Valid @RequestParam(value = "twitterUrl", required = false) twitterUrl: kotlin.String?,
        @Parameter(description = "The retailer logo sent as a multipart binary file (you can optionally use logoAssetId if the asset has already been uploaded before)") @Valid @RequestParam(value = "logo", required = false) logo: org.springframework.web.multipart.MultipartFile,
        @Parameter(description = "The retailer logo asset id") @Valid @RequestParam(value = "logoAssetId", required = false) logoAssetId: kotlin.Long?,
        @Parameter(description = "Optional store-front pictures or product pictures or etc. A multipart binary file (you can optionally use picture1AssetId if the asset has already been uploaded before)") @Valid @RequestParam(value = "picture1", required = false) picture1: org.springframework.web.multipart.MultipartFile,
        @Parameter(description = "An asset id") @Valid @RequestParam(value = "picture1AssetId", required = false) picture1AssetId: kotlin.Long?,
        @Parameter(description = "Optional store-front pictures or product pictures or etc. A multipart binary file (you can optionally use picture2AssetId if the asset has already been uploaded before)") @Valid @RequestParam(value = "picture2", required = false) picture2: org.springframework.web.multipart.MultipartFile,
        @Parameter(description = "An asset id") @Valid @RequestParam(value = "picture2AssetId", required = false) picture2AssetId: kotlin.Long?,
        @Parameter(description = "Comma separated list of category IDs used to filter retailers by categories") @Valid @RequestParam(value = "categoryIds", required = false) categoryIds: kotlin.String?,
        @Parameter(description = "Comma separated list of filter IDs used to filter retailers") @Valid @RequestParam(value = "filterIds", required = false) filterIds: kotlin.String?,
        @Parameter(description = "the latitude of the retailer") @Valid @RequestParam(value = "latitude", required = false) latitude: kotlin.Double?,
        @Parameter(description = "the longitude of the retailer") @Valid @RequestParam(value = "longitude", required = false) longitude: kotlin.Double?,
        @Parameter(description = "External custom client defined data") @Valid @RequestParam(value = "metaData", required = false) metaData: kotlin.String?,
        @Parameter(description = "External custom search keywords") @Valid @RequestParam(value = "searchTags", required = false) searchTags: kotlin.String?,
        @Parameter(description = "External custom type identifier") @Valid @RequestParam(value = "retailerType", required = false) retailerType: kotlin.String?,
        @Parameter(description = "", schema = Schema(allowableValues = ["PUBLIC", "PRIVATE", "FRIENDS"])) @Valid @RequestParam(value = "visibility", required = false) visibility: kotlin.String?,
        @Parameter(description = "Sets whether the retailer is active or inactive (hidden from consumers)") @Valid @RequestParam(value = "active", required = false) active: kotlin.Boolean?,
        @Parameter(description = "The format of the returned response {JSON // default , HTML // for Dojo support when uploading assets}", schema = Schema(allowableValues = ["HTML", "XML", "JSON", "CSV"])) @Valid @RequestParam(value = "responseFormat", required = false) responseFormat: kotlin.String?
    ): ResponseEntity<RetailerFullResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Update Retailer Location",
        operationId = "updateRetailerLocations",
        description = """Updates a location record for a retailer. Only the owner and the employees of the retailer have access to do this.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = RetailerLocationResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/retailer/location/update"
        value = [PATH_UPDATE_RETAILER_LOCATIONS],
        produces = ["*/*"]
    )
    fun updateRetailerLocations(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The ID of the retailer location", required = true) @Valid @RequestParam(value = "retailerLocationId", required = true) retailerLocationId: kotlin.Long,
        @Parameter(description = "The device id (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "The account id of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "The name of the retailer location") @Valid @RequestParam(value = "name", required = false) name: kotlin.String?,
        @Parameter(description = "The street address of the retailer location") @Valid @RequestParam(value = "streetAddress", required = false) streetAddress: kotlin.String?,
        @Parameter(description = "Additional address information (such as a suite number, floor number, building name, or PO Box)") @Valid @RequestParam(value = "streetAddress2", required = false) streetAddress2: kotlin.String?,
        @Parameter(description = "The city of the retailer location") @Valid @RequestParam(value = "city", required = false) city: kotlin.String?,
        @Parameter(description = "The state of the retailer location") @Valid @RequestParam(value = "state", required = false) state: kotlin.String?,
        @Parameter(description = "The postal code of the retailer location") @Valid @RequestParam(value = "postalCode", required = false) postalCode: kotlin.String?,
        @Parameter(description = "the country of the retailer location") @Valid @RequestParam(value = "country", required = false) country: kotlin.String?,
        @Parameter(description = "The business phone number of the retailer location") @Valid @RequestParam(value = "businessPhone", required = false) businessPhone: kotlin.String?,
        @Parameter(description = "The business phone extension of the retailer location") @Valid @RequestParam(value = "businessPhoneExt", required = false) businessPhoneExt: kotlin.String?,
        @Parameter(description = "The website of the retailer location") @Valid @RequestParam(value = "website", required = false) website: kotlin.String?,
        @Parameter(description = "The email of the retailer location") @Valid @RequestParam(value = "email", required = false) email: kotlin.String?,
        @Parameter(description = "An internal identifier used by the retailer") @Valid @RequestParam(value = "internalId", required = false) internalId: kotlin.String?,
        @Parameter(description = "A brief description about the retailer location (255 character limit)") @Valid @RequestParam(value = "detailsHeader", required = false) detailsHeader: kotlin.String?,
        @Parameter(description = "A detailed description about the retailer location") @Valid @RequestParam(value = "detailsBody", required = false) detailsBody: kotlin.String?,
        @Parameter(description = "The hours of operation") @Valid @RequestParam(value = "hours", required = false) hours: kotlin.String?,
        @Parameter(description = "The retailer location logo sent as a multipart binary file (you can optionally use logoAssetId if the asset has already been uploaded before)") @Valid @RequestParam(value = "logo", required = false) logo: org.springframework.web.multipart.MultipartFile,
        @Parameter(description = "The retailer location logo asset id") @Valid @RequestParam(value = "logoAssetId", required = false) logoAssetId: kotlin.Long?,
        @Parameter(description = "Optional store-front pictures or product pictures or etc. A multipart binary file (you can optionally use picture1AssetId if the asset has already been uploaded before)") @Valid @RequestParam(value = "picture1", required = false) picture1: org.springframework.web.multipart.MultipartFile,
        @Parameter(description = "An asset id") @Valid @RequestParam(value = "picture1AssetId", required = false) picture1AssetId: kotlin.Long?,
        @Parameter(description = "Optional store-front pictures or product pictures or etc. A multipart binary file (you can optionally use picture2AssetId if the asset has already been uploaded before)") @Valid @RequestParam(value = "picture2", required = false) picture2: org.springframework.web.multipart.MultipartFile,
        @Parameter(description = "An asset id") @Valid @RequestParam(value = "picture2AssetId", required = false) picture2AssetId: kotlin.Long?,
        @Parameter(description = "Comma separated list of category IDs used to filter retailer locations by categories") @Valid @RequestParam(value = "categoryIds", required = false) categoryIds: kotlin.String?,
        @Parameter(description = "Comma separated list of filter IDs used to filter retailer locations") @Valid @RequestParam(value = "filterIds", required = false) filterIds: kotlin.String?,
        @Parameter(description = "the latituede of the retailer location") @Valid @RequestParam(value = "latitude", required = false) latitude: kotlin.Double?,
        @Parameter(description = "the longitude of the retailer location") @Valid @RequestParam(value = "longitude", required = false) longitude: kotlin.Double?,
        @Parameter(description = "") @Valid @RequestParam(value = "building", required = false) building: kotlin.String?,
        @Parameter(description = "the Google Place ID that the retailer location is associated with") @Valid @RequestParam(value = "googlePlaceId", required = false) googlePlaceId: kotlin.String?,
        @Parameter(description = "the Yelp ID that the retailer location is associated with") @Valid @RequestParam(value = "yelpId", required = false) yelpId: kotlin.String?,
        @Parameter(description = "External custom client defined data") @Valid @RequestParam(value = "metaData", required = false) metaData: kotlin.String?,
        @Parameter(description = "Specifies which payment provider Sirqul will use when making payments") @Valid @RequestParam(value = "paymentProvider", required = false) paymentProvider: kotlin.String?,
        @Parameter(description = "Sets whether the retailer is active or inactive (hidden from consumers)") @Valid @RequestParam(value = "active", required = false) active: kotlin.Boolean?,
        @Parameter(description = "Sets whether the location is public or not") @Valid @RequestParam(value = "publicLocation", required = false) publicLocation: kotlin.Boolean?,
        @Parameter(description = "External custom type identifier") @Valid @RequestParam(value = "locationType", required = false) locationType: kotlin.String?,
        @Parameter(description = "Comma separated list of audience IDs used to assign audiences to the retailer location") @Valid @RequestParam(value = "audienceIds", required = false) audienceIds: kotlin.String?,
        @Parameter(description = "Comma separated list of audience IDs to add to the retailer location") @Valid @RequestParam(value = "audienceIdsToAdd", required = false) audienceIdsToAdd: kotlin.String?,
        @Parameter(description = "Comma separated list of audience IDs to remove from the retailer location") @Valid @RequestParam(value = "audienceIdsToRemove", required = false) audienceIdsToRemove: kotlin.String?,
        @Parameter(description = "The format of the returned response {JSON // default , HTML // for Dojo support when uploading assets}", schema = Schema(allowableValues = ["HTML", "XML", "JSON", "CSV"])) @Valid @RequestParam(value = "responseFormat", required = false) responseFormat: kotlin.String?,
        @Parameter(description = "Custom string field for doing full-text searches") @Valid @RequestParam(value = "tags", required = false) tags: kotlin.String?
    ): ResponseEntity<RetailerLocationResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Update Route",
        operationId = "updateRoute",
        description = """Update an existing route""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = Route::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.PUT],
        // "/api/{version}/route/{routeId}"
        value = [PATH_UPDATE_ROUTE],
        produces = ["*/*"]
    )
    fun updateRoute(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "the id of the route", required = true) @PathVariable("routeId") routeId: kotlin.Long,
        @Parameter(description = "") @Valid @RequestBody(required = false) body: Route?
    ): ResponseEntity<Route> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Update Route Setting",
        operationId = "updateRouteSettings",
        description = """Update an existing route setting""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = RouteSettings::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.PUT],
        // "/api/{version}/route/setting/{routeSettingsId}"
        value = [PATH_UPDATE_ROUTE_SETTINGS],
        produces = ["*/*"]
    )
    fun updateRouteSettings(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "the id of the route settings to update", required = true) @PathVariable("routeSettingsId") routeSettingsId: kotlin.Long,
        @Parameter(description = "") @Valid @RequestBody(required = false) body: RouteSettings?
    ): ResponseEntity<RouteSettings> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Update Route Stop",
        operationId = "updateRouteStop",
        description = """Update a stop on a specified route""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation") ]
    )
    @RequestMapping(
        method = [RequestMethod.PUT],
        // "/api/{version}/route/{routeId}/stop/{stopId}"
        value = [PATH_UPDATE_ROUTE_STOP]
    )
    fun updateRouteStop(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "the id of the route to update stops for", required = true) @PathVariable("routeId") routeId: kotlin.Long,
        @Parameter(description = "the id of the specific stop to update on the route", required = true) @PathVariable("stopId") stopId: kotlin.Long,
        @Parameter(description = "") @Valid @RequestBody(required = false) body: Stop?
    ): ResponseEntity<Unit> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Update Scheduled Notification",
        operationId = "updateScheduledNotification",
        description = """This endpoint updates a Scheduled Notification message that can be configured to process and send periodically at set time periods. Please see createScheduledNotification for more details.

Only the original owner of the Scheduled Notification or someone with write permissions can use this endpoint. Permissions can be granted to other users by using theUserPermissionsApi.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = ScheduledNotificationFullResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/notification/schedule/update"
        value = [PATH_UPDATE_SCHEDULED_NOTIFICATION],
        produces = ["*/*"]
    )
    fun updateScheduledNotification(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The id of scheduled notification to update", required = true) @Valid @RequestParam(value = "scheduledNotificationId", required = true) scheduledNotificationId: kotlin.Long,
        @NotNull @Parameter(description = "The logged in user.", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @Parameter(description = "The name of the scheduled notification") @Valid @RequestParam(value = "name", required = false) name: kotlin.String?,
        @Parameter(description = "The type of scheduled notification. Supported values include: MOBILE_NOTIFICATION - sends push notifications via APNS and GCM EMAIL - sends email messages SMS - sends text messages") @Valid @RequestParam(value = "type", required = false) type: kotlin.String?,
        @Parameter(description = "The message to send") @Valid @RequestParam(value = "message", required = false) message: kotlin.String?,
        @Parameter(description = "The parameters for making an HTTP call") @Valid @RequestParam(value = "payload", required = false) payload: kotlin.String?,
        @Parameter(description = "The payload content ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.") @Valid @RequestParam(value = "contentId", required = false) contentId: kotlin.Long?,
        @Parameter(description = "The payload content name that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.") @Valid @RequestParam(value = "contentName", required = false) contentName: kotlin.String?,
        @Parameter(description = "The payload content type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.") @Valid @RequestParam(value = "contentType", required = false) contentType: kotlin.String?,
        @Parameter(description = "The payload parent ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.") @Valid @RequestParam(value = "parentId", required = false) parentId: kotlin.Long?,
        @Parameter(description = "The payload parent type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.") @Valid @RequestParam(value = "parentType", required = false) parentType: kotlin.String?,
        @Parameter(description = "The application that the notifications will send to. If connectionGroupIds, connectionAccountIds, and audienceIds is not set, this will send to all users who have used the application. This parameter is also required when sending push notifications via the MOBILE_NOTIFICATION type.") @Valid @RequestParam(value = "appKey", required = false) appKey: kotlin.String?,
        @Parameter(description = "Client defined identifier for grouping multiple scheduled notifications. This can be used with the search endpoint to return scheduled notifications with the same groupingId for display purposes. Only results that have been created by the user will be returned when using this feature.") @Valid @RequestParam(value = "groupingId", required = false) groupingId: kotlin.String?,
        @Parameter(description = "The connection groups to use to generate the list of recipients (comma separated list of connection group IDs)") @Valid @RequestParam(value = "connectionGroupIds", required = false) connectionGroupIds: kotlin.String?,
        @Parameter(description = "The connection accounts to use to generate the list of recipients (comma separated list of user account ids)") @Valid @RequestParam(value = "connectionAccountIds", required = false) connectionAccountIds: kotlin.String?,
        @Parameter(description = "This parameter is deprecated. The audience used to generate the list of recipients") @Valid @RequestParam(value = "audienceId", required = false) audienceId: kotlin.Long?,
        @Parameter(description = "The audiences used to generate the list of recipients (comma separated list of audience IDs)") @Valid @RequestParam(value = "audienceIds", required = false) audienceIds: kotlin.String?,
        @Parameter(description = "The album ids to associate with the scheduled notification (comma separated list of album IDs)") @Valid @RequestParam(value = "albumIds", required = false) albumIds: kotlin.String?,
        @Parameter(description = "The report used to generate the the list of recipients") @Valid @RequestParam(value = "reportId", required = false) reportId: kotlin.Long?,
        @Parameter(description = "The parameters to supply to the report used to generate the the list of recipients") @Valid @RequestParam(value = "reportParams", required = false) reportParams: kotlin.String?,
        @Parameter(description = "The URL for making an HTTP call") @Valid @RequestParam(value = "endpointURL", required = false) endpointURL: kotlin.String?,
        @Parameter(description = "The next time when the scheduled notification should begin processing (time in milliseconds). If this is left empty, then the startDate will be used.") @Valid @RequestParam(value = "scheduledDate", required = false) scheduledDate: kotlin.Long?,
        @Parameter(description = "The start time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to be available now.") @Valid @RequestParam(value = "startDate", required = false) startDate: kotlin.Long?,
        @Parameter(description = "The end time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to not have an expiration date.") @Valid @RequestParam(value = "endDate", required = false) endDate: kotlin.Long?,
        @Parameter(description = "The cron expression that represents the processing schedule. This uses the unix cron expression format. For example: 0 0 * * * will run once a day at midnight UTC.") @Valid @RequestParam(value = "cronExpression", required = false) cronExpression: kotlin.String?,
        @Parameter(description = "The cron expression type: UNIX, CRON4J, QUARTZ") @Valid @RequestParam(value = "cronType", required = false) cronType: kotlin.String?,
        @Parameter(description = "Additional metadata for the scheduled notification") @Valid @RequestParam(value = "metaData", required = false) metaData: kotlin.String?,
        @Parameter(description = "Json input representing conditional logic that has to be met before running the scheduled notification") @Valid @RequestParam(value = "conditionalInput", required = false) conditionalInput: kotlin.String?,
        @Parameter(description = "This determines if the Scheduled Notification is a template which is used as a basis for dynamically generating re-occurring Scheduled Notifications. The available types include: REPORTING - saves an adhoc report to be able to run again at another time GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business owner) GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business employee, retailer location, etc) GEOFENCE_TRIGGER - template for sending notifications to the account that triggered the geofence/audience (i.e. the customer) GEOFENCE_HTTP_CALL - template for making http calls when the geofences are triggered") @Valid @RequestParam(value = "templateType", required = false) templateType: kotlin.String?,
        @Parameter(description = "Determines the scope of who is able to find and view the scheduled notification (PUBLIC - openly available to all Sirqul users, PRIVATE - only available to users that have been invited)", schema = Schema(allowableValues = ["PUBLIC", "PRIVATE", "FRIENDS"])) @Valid @RequestParam(value = "visibility", required = false) visibility: kotlin.String?,
        @Parameter(description = "Sets whether the Scheduled Notification is active or not (inactive Scheduled Notifications are not processed). This is a quick way to toggle on or off without altering its schedule.") @Valid @RequestParam(value = "active", required = false) active: kotlin.Boolean?,
        @Parameter(description = "the error message associated with the scheduled notification") @Valid @RequestParam(value = "errorMessage", required = false) errorMessage: kotlin.String?,
        @Parameter(description = "the status of the scheduled notification") @Valid @RequestParam(value = "status", required = false) status: kotlin.String?,
        @Parameter(description = "also updates ScheduledNotifications with the same groupingId and account") @Valid @RequestParam(value = "updateByGroupingId", required = false) updateByGroupingId: kotlin.Boolean?,
        @Parameter(description = "whether to send the scheduled notification now or not") @Valid @RequestParam(value = "sendNow", required = false) sendNow: kotlin.Boolean?,
        @Parameter(description = "Sets the event type for the notification", schema = Schema(defaultValue = "CUSTOM")) @Valid @RequestParam(value = "eventType", required = false, defaultValue = "CUSTOM") eventType: kotlin.String,
        @Parameter(description = "The payload deep link URI that can be used by the client app to direct users to a screen in the app") @Valid @RequestParam(value = "deepLinkURI", required = false) deepLinkURI: kotlin.String?,
        @Parameter(description = "Determines whether to send to all users of the app if set to true for push notifications (appKey is required)") @Valid @RequestParam(value = "sendToAll", required = false) sendToAll: kotlin.Boolean?
    ): ResponseEntity<ScheduledNotificationFullResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Update Secure Application",
        operationId = "updateSecureApplication",
        description = """Update a secure application record.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/secure/application/update"
        value = [PATH_UPDATE_SECURE_APPLICATION],
        produces = ["*/*"]
    )
    fun updateSecureApplication(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The unique id of the user making the request", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "The application to secure", required = true) @Valid @RequestParam(value = "appKey", required = true) appKey: kotlin.String,
        @Parameter(description = "") @Valid @RequestParam(value = "active", required = false) active: kotlin.Boolean?,
        @Parameter(description = "") @Valid @RequestParam(value = "keyCert", required = false) keyCert: org.springframework.web.multipart.MultipartFile,
        @Parameter(description = "") @Valid @RequestParam(value = "trustStore", required = false) trustStore: org.springframework.web.multipart.MultipartFile,
        @Parameter(description = "") @Valid @RequestParam(value = "username", required = false) username: kotlin.String?,
        @Parameter(description = "") @Valid @RequestParam(value = "password", required = false) password: kotlin.String?,
        @Parameter(description = "The type of biometric, options are: - FINGERPRINT - IRIS - FACIAL", schema = Schema(allowableValues = ["FINGERPRINT", "IRIS", "FACIAL"])) @Valid @RequestParam(value = "biometricType", required = false) biometricType: kotlin.String?,
        @Parameter(description = "The position for the biometric file uploaded", schema = Schema(allowableValues = ["UNKNOWN", "LEFT_INDEX", "LEFT_MIDDLE", "LEFT_RING", "LEFT_LITTLE", "LEFT_THUMB", "RIGHT_INDEX", "RIGHT_MIDDLE", "RIGHT_RING", "RIGHT_LITTLE", "RIGHT_THUMB", "LEFT", "RIGHT"])) @Valid @RequestParam(value = "biometricPosition", required = false) biometricPosition: kotlin.String?,
        @Parameter(description = "The position for each the biometric2 file uploaded", schema = Schema(allowableValues = ["UNKNOWN", "LEFT_INDEX", "LEFT_MIDDLE", "LEFT_RING", "LEFT_LITTLE", "LEFT_THUMB", "RIGHT_INDEX", "RIGHT_MIDDLE", "RIGHT_RING", "RIGHT_LITTLE", "RIGHT_THUMB", "LEFT", "RIGHT"])) @Valid @RequestParam(value = "biometricPosition2", required = false) biometricPosition2: kotlin.String?
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Update Account Settings",
        operationId = "updateSettings",
        description = """Update the account settings for a user""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = UserSettingsResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/account/settings/update"
        value = [PATH_UPDATE_SETTINGS],
        produces = ["*/*"]
    )
    fun updateSettings(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "The device id (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "The account id of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "The notifications to be blocked") @Valid @RequestParam(value = "blockedNotifications", required = false) blockedNotifications: kotlin.String?,
        @Parameter(description = "How suggestions are to be sent (APNS, MOBILE_NOTIFICATION, SMS)") @Valid @RequestParam(value = "suggestionMethod", required = false) suggestionMethod: kotlin.String?,
        @Parameter(description = "How many suggestions to receive per time frame") @Valid @RequestParam(value = "suggestionCount", required = false) suggestionCount: kotlin.Int?,
        @Parameter(description = "The time frame in seconds, 3600 would be a 1 hour time frame") @Valid @RequestParam(value = "suggestionTimeFrame", required = false) suggestionTimeFrame: kotlin.Int?,
        @Parameter(description = "Show Others Exact Location") @Valid @RequestParam(value = "showOthersExactLocation", required = false) showOthersExactLocation: kotlin.Boolean?,
        @Parameter(description = "Show As Zipcode") @Valid @RequestParam(value = "showAsZipcode", required = false) showAsZipcode: kotlin.Boolean?,
        @Parameter(description = "Show Exact Location") @Valid @RequestParam(value = "showExactLocation", required = false) showExactLocation: kotlin.Boolean?,
        @Parameter(description = "Show favorites") @Valid @RequestParam(value = "favoriteVisibility", required = false) favoriteVisibility: kotlin.String?,
        @Parameter(description = "The current latitude of the user") @Valid @RequestParam(value = "latitude", required = false) latitude: kotlin.Double?,
        @Parameter(description = "The current longitude of the user") @Valid @RequestParam(value = "longitude", required = false) longitude: kotlin.Double?
    ): ResponseEntity<UserSettingsResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Update Shipment",
        operationId = "updateShipment",
        description = """Update an existing shipment""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = Shipment::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.PUT],
        // "/api/{version}/shipment/{id}"
        value = [PATH_UPDATE_SHIPMENT],
        produces = ["*/*"]
    )
    fun updateShipment(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "the id of the shipment to update", required = true) @PathVariable("id") id: kotlin.Long,
        @Parameter(description = "") @Valid @RequestBody(required = false) body: Shipment?
    ): ResponseEntity<Shipment> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Uupdate Shipment Status",
        operationId = "updateShipmentStatus",
        description = """Update status of an existing shipment""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation") ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/shipment/{id}/status"
        value = [PATH_UPDATE_SHIPMENT_STATUS]
    )
    fun updateShipmentStatus(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "the id of the shipment to update status", required = true) @PathVariable("id") id: kotlin.Long,
        @Parameter(description = "") @Valid @RequestBody(required = false) body: kotlin.collections.Map<kotlin.String, kotlin.Boolean>?
    ): ResponseEntity<Unit> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Update Trip Shipments",
        operationId = "updateShipments",
        description = """""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = Trip::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/trip/{id}/shipments"
        value = [PATH_UPDATE_SHIPMENTS],
        produces = ["*/*"]
    )
    fun updateShipments(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "the id of the trip shipments to update", required = true) @PathVariable("id") id: kotlin.Long,
        @Parameter(description = "") @Valid @RequestBody(required = false) body: Trip?
    ): ResponseEntity<Trip> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Update Vatom Space",
        operationId = "updateSpace",
        description = """Update a Vatom space.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation") ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/vatom/b/spaces/update"
        value = [PATH_UPDATE_SPACE]
    )
    fun updateSpace(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "Sirqul Account Id", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "Sirqul Application Key", required = true) @Valid @RequestParam(value = "appKey", required = true) appKey: kotlin.String,
        @NotNull @Parameter(description = "Vatom Space Id", required = true) @Valid @RequestParam(value = "vatomSpaceId", required = true) vatomSpaceId: kotlin.String,
        @NotNull @Parameter(description = "Vatom Parameters", required = true) @Valid @RequestParam(value = "vatomParameters", required = true) vatomParameters: kotlin.String,
        @Parameter(description = "Return raw response") @Valid @RequestParam(value = "returnRawResponse", required = false) returnRawResponse: kotlin.Boolean?
    ): ResponseEntity<Unit> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Update Stop",
        operationId = "updateStop",
        description = """Update an existing stop""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = Stop::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.PUT],
        // "/api/{version}/stop/{id}"
        value = [PATH_UPDATE_STOP],
        produces = ["*/*"]
    )
    fun updateStop(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "the id of the stop to update", required = true) @PathVariable("id") id: kotlin.Long,
        @Parameter(description = "") @Valid @RequestBody(required = false) body: Stop?
    ): ResponseEntity<Stop> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Update Subscription",
        operationId = "updateSubscription",
        description = """Updates the subscription for the billable entity for an account""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SubscriptionResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/subscription/update"
        value = [PATH_UPDATE_SUBSCRIPTION],
        produces = ["*/*"]
    )
    fun updateSubscription(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The account used to perform the update, must be the responsible manager", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @Parameter(description = "The plan to subscribe to") @Valid @RequestParam(value = "planId", required = false) planId: kotlin.Long?,
        @Parameter(description = "Set a promo code for a discount.") @Valid @RequestParam(value = "promoCode", required = false) promoCode: kotlin.String?,
        @Parameter(description = "Set active status") @Valid @RequestParam(value = "active", required = false) active: kotlin.Boolean?
    ): ResponseEntity<SubscriptionResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Update Task",
        operationId = "updateTask",
        description = """Update a Task""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = TaskResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/task/update"
        value = [PATH_UPDATE_TASK],
        produces = ["*/*"]
    )
    fun updateTask(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "Task Id", required = true) @Valid @RequestParam(value = "taskId", required = true) taskId: kotlin.Long,
        @NotNull @Parameter(description = "The logged in user.", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @Parameter(description = "The name of the task") @Valid @RequestParam(value = "name", required = false) name: kotlin.String?,
        @Parameter(description = "The application to target") @Valid @RequestParam(value = "appKey", required = false) appKey: kotlin.String?,
        @Parameter(description = "Client defined identifier for grouping tasks") @Valid @RequestParam(value = "groupingId", required = false) groupingId: kotlin.String?,
        @Parameter(description = "The URL for making an HTTP call") @Valid @RequestParam(value = "endpointURL", required = false) endpointURL: kotlin.String?,
        @Parameter(description = "The parameters for making an HTTP call") @Valid @RequestParam(value = "payload", required = false) payload: kotlin.String?,
        @Parameter(description = "The date and time of the task") @Valid @RequestParam(value = "scheduledDate", required = false) scheduledDate: kotlin.Long?,
        @Parameter(description = "The starting date of the task") @Valid @RequestParam(value = "startDate", required = false) startDate: kotlin.Long?,
        @Parameter(description = "The ending date of the task") @Valid @RequestParam(value = "endDate", required = false) endDate: kotlin.Long?,
        @Parameter(description = "The cron expression that represents the task's schedule") @Valid @RequestParam(value = "cronExpression", required = false) cronExpression: kotlin.String?,
        @Parameter(description = "The determines the scope of who is able to find and view the scheduled notification (PUBLIC - openly available to all Sirqul users, PRIVATE - only available to users that have been invited)", schema = Schema(allowableValues = ["PUBLIC", "PRIVATE", "FRIENDS"])) @Valid @RequestParam(value = "visibility", required = false) visibility: kotlin.String?,
        @Parameter(description = "Sets whether the Task is active or not (inactive Tasks are not processed)") @Valid @RequestParam(value = "active", required = false) active: kotlin.Boolean?
    ): ResponseEntity<TaskResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Update Territory",
        operationId = "updateTerritory",
        description = """Updates a territory.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = TerritoryResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/territory/update"
        value = [PATH_UPDATE_TERRITORY],
        produces = ["*/*"]
    )
    fun updateTerritory(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The logged in user.", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "the id of the territory to update", required = true) @Valid @RequestParam(value = "territoryId", required = true) territoryId: kotlin.Long,
        @Parameter(description = "The name of the territory") @Valid @RequestParam(value = "name", required = false) name: kotlin.String?,
        @Parameter(description = "If true set the game level as active.") @Valid @RequestParam(value = "active", required = false) active: kotlin.Boolean?
    ): ResponseEntity<TerritoryResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Update Tournament",
        operationId = "updateTournament",
        description = """Update a tournament.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = TournamentResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/tournament/update"
        value = [PATH_UPDATE_TOURNAMENT],
        produces = ["*/*"]
    )
    fun updateTournament(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The logged in user.", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "The mission/tournament to update", required = true) @Valid @RequestParam(value = "missionId", required = true) missionId: kotlin.Long,
        @Parameter(description = "The title of the tournament") @Valid @RequestParam(value = "title", required = false) title: kotlin.String?,
        @Parameter(description = "Custom string client apps can use for searching/filtering missions") @Valid @RequestParam(value = "subType", required = false) subType: kotlin.String?,
        @Parameter(description = "The asset ID to attach to the tournament") @Valid @RequestParam(value = "imageAssetId", required = false) imageAssetId: kotlin.Long?,
        @Parameter(description = "The number of seconds in between the start of each tournament game") @Valid @RequestParam(value = "secondsBetweenLevels", required = false) secondsBetweenLevels: kotlin.Int?,
        @Parameter(description = "The number of seconds to extend the round end time in the case of a tie breaker") @Valid @RequestParam(value = "secondsForTieBreaker", required = false) secondsForTieBreaker: kotlin.Int?,
        @Parameter(description = "The number of seconds in between the start of each tournament round") @Valid @RequestParam(value = "secondsBetweenPacks", required = false) secondsBetweenPacks: kotlin.Int?,
        @Parameter(description = "The maximum number of seconds the match is expected to end at, which gets used to determine when a match should end when there is no activity") @Valid @RequestParam(value = "maximumLevelLength", required = false) maximumLevelLength: kotlin.Int?,
        @Parameter(description = "The number of tickets required to pay to enter the tournament") @Valid @RequestParam(value = "costToPlay", required = false) costToPlay: kotlin.Int?,
        @Parameter(description = "The type of ticket required to pay") @Valid @RequestParam(value = "costToPlayType", required = false) costToPlayType: kotlin.String?,
        @Parameter(description = "The minimum number of players required to sign up for the tournament to be played") @Valid @RequestParam(value = "minimumToPlay", required = false) minimumToPlay: kotlin.Int?,
        @Parameter(description = "The starting number of players for a tournament (filled with AI's)") @Valid @RequestParam(value = "startingLimit", required = false) startingLimit: kotlin.Int?,
        @Parameter(description = "The maximum number of players for a tournament (currently 128 but not enforced)") @Valid @RequestParam(value = "availableLimit", required = false) availableLimit: kotlin.Int?,
        @Parameter(description = "The description of the tournament") @Valid @RequestParam(value = "description", required = false) description: kotlin.String?,
        @Parameter(description = "External custom client defined data") @Valid @RequestParam(value = "metaData", required = false) metaData: kotlin.String?,
        @Parameter(description = "The date/time to start the tournament") @Valid @RequestParam(value = "startDate", required = false) startDate: kotlin.Long?,
        @Parameter(description = "The audiences associated with the tournament") @Valid @RequestParam(value = "audienceIds", required = false) audienceIds: kotlin.String?,
        @Parameter(description = "Activate/deactivate the mission") @Valid @RequestParam(value = "active", required = false) active: kotlin.Boolean?,
        @Parameter(description = "Determines whether to allow players to buy back into a tournament") @Valid @RequestParam(value = "enableBuyBack", required = false) enableBuyBack: kotlin.Boolean?,
        @Parameter(description = "The list of offers to give as a reward beyond the tickets") @Valid @RequestParam(value = "offerIds", required = false) offerIds: kotlin.String?,
        @Parameter(description = "The artwork ID to attach to the reward offer") @Valid @RequestParam(value = "offerAssetId", required = false) offerAssetId: kotlin.Long?,
        @Parameter(description = "If set then do not update the ticket reward, auto set to true if offerIds provided") @Valid @RequestParam(value = "fixedReward", required = false) fixedReward: kotlin.Boolean?,
        @Parameter(description = "Set the rules for handling the reward in case of a tie, values: EVEN split the reward evenly ALL everyone gets the full reward value FIRST first score submitted RANDOM random player who scored", schema = Schema(allowableValues = ["EVEN", "ALL", "FIRST", "RANDOM"])) @Valid @RequestParam(value = "splitReward", required = false) splitReward: kotlin.String?,
        @Parameter(description = "Flag to indicate owner should receive tickets for completed missions") @Valid @RequestParam(value = "allocateTickets", required = false) allocateTickets: kotlin.Boolean?,
        @Parameter(description = "A text based string that will be passed into each tournament setup to populate the content") @Valid @RequestParam(value = "tournamentData", required = false) tournamentData: kotlin.String?,
        @Parameter(description = "Sets the visibility flag for the tournament", schema = Schema(allowableValues = ["PUBLIC", "LISTABLE", "REWARDABLE", "TRIGGERABLE", "PRIVATE"])) @Valid @RequestParam(value = "visibility", required = false) visibility: kotlin.String?,
        @Parameter(description = "The number of initial preliminary groups in a multi-stage tournament (this is expected to be a power of two number)") @Valid @RequestParam(value = "preliminaryGroups", required = false) preliminaryGroups: kotlin.Int?,
        @Parameter(description = "This determines how many people can advance per round in a preliminary group (this is a comma separated list of integers)") @Valid @RequestParam(value = "preliminaryGroupAdvancements", required = false) preliminaryGroupAdvancements: kotlin.String?,
        @Parameter(description = "This determines if multiple submissions/entries are allowed in a multi-stage album tournament") @Valid @RequestParam(value = "enableMultipleEntries", required = false) enableMultipleEntries: kotlin.Boolean?,
        @Parameter(description = "This determines if users are allowed to vote multiple times per group in a multi-stage album tournament") @Valid @RequestParam(value = "enableMultipleVotes", required = false) enableMultipleVotes: kotlin.Boolean?,
        @Parameter(description = "This determines whether the tournament is \"featured\" or not") @Valid @RequestParam(value = "featured", required = false) featured: kotlin.Boolean?,
        @Parameter(description = "This sets what analytic tag is used when a winner is determined") @Valid @RequestParam(value = "winnerTag", required = false) winnerTag: kotlin.String?,
        @Parameter(description = "This sets what analytic tag is used when a winner is determined") @Valid @RequestParam(value = "tieTag", required = false) tieTag: kotlin.String?
    ): ResponseEntity<TournamentResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Update Trigger",
        operationId = "updateTrigger",
        description = """Update a trigger""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = TriggerResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/trigger/update"
        value = [PATH_UPDATE_TRIGGER],
        produces = ["*/*"]
    )
    fun updateTrigger(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The trigger to update", required = true) @Valid @RequestParam(value = "triggerId", required = true) triggerId: kotlin.Long,
        @NotNull @Parameter(description = "The logged in user", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @Parameter(description = "The name of the trigger") @Valid @RequestParam(value = "name", required = false) name: kotlin.String?,
        @Parameter(description = "The application to target") @Valid @RequestParam(value = "appKey", required = false) appKey: kotlin.String?,
        @Parameter(description = "Client defined identifier for grouping triggers") @Valid @RequestParam(value = "groupingId", required = false) groupingId: kotlin.String?,
        @Parameter(description = "The URL for making an HTTP call") @Valid @RequestParam(value = "endpointURL", required = false) endpointURL: kotlin.String?,
        @Parameter(description = "The parameters for making an HTTP call") @Valid @RequestParam(value = "payload", required = false) payload: kotlin.String?,
        @Parameter(description = "The date and time of the next trigger") @Valid @RequestParam(value = "scheduledDate", required = false) scheduledDate: kotlin.Long?,
        @Parameter(description = "The starting date of the trigger") @Valid @RequestParam(value = "startDate", required = false) startDate: kotlin.Long?,
        @Parameter(description = "The ending date of the trigger") @Valid @RequestParam(value = "endDate", required = false) endDate: kotlin.Long?,
        @Parameter(description = "The cron expression that represents the trigger's schedule") @Valid @RequestParam(value = "cronExpression", required = false) cronExpression: kotlin.String?,
        @Parameter(description = "Json input representing conditional logic that has to be met before running the trigger") @Valid @RequestParam(value = "conditionalInput", required = false) conditionalInput: kotlin.String?,
        @Parameter(description = "The determines the scope of who is able to find and view the scheduled notification (PUBLIC - openly available to all Sirqul users, PRIVATE - only available to users that have been invited)", schema = Schema(allowableValues = ["PUBLIC", "PRIVATE", "FRIENDS"])) @Valid @RequestParam(value = "visibility", required = false) visibility: kotlin.String?,
        @Parameter(description = "Sets whether the Trigger is active or not (inactive Triggers are not processed)") @Valid @RequestParam(value = "active", required = false) active: kotlin.Boolean?
    ): ResponseEntity<TriggerResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Update Trip",
        operationId = "updateTrip",
        description = """Update an existing trip. Does not support recurring trip update.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = Trip::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.PUT],
        // "/api/{version}/trip/{id}"
        value = [PATH_UPDATE_TRIP],
        produces = ["*/*"]
    )
    fun updateTrip(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "the id of the trip to update", required = true) @PathVariable("id") id: kotlin.Long,
        @Parameter(description = "") @Valid @RequestBody(required = false) body: Trip?
    ): ResponseEntity<Trip> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Trip Notifications",
        operationId = "updateTripNotifications",
        description = """Update the trip notifications""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = Trip::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/trip/notifications"
        value = [PATH_UPDATE_TRIP_NOTIFICATIONS],
        produces = ["*/*"]
    )
    fun updateTripNotifications(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the id of the trip", required = true) @Valid @RequestParam(value = "id", required = true) id: kotlin.Long,
        @Parameter(description = "the notifications to update on the trip") @Valid @RequestParam(value = "notifications", required = false) notifications: kotlin.String?
    ): ResponseEntity<Trip> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Update Achievement Progress",
        operationId = "updateUserAchievement",
        description = """Update user achievement progress.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/achievement/progress/update"
        value = [PATH_UPDATE_USER_ACHIEVEMENT],
        produces = ["*/*"]
    )
    fun updateUserAchievement(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the account id of the user", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @Parameter(description = "the achievement id (achievementId or tag required)") @Valid @RequestParam(value = "achievementId", required = false) achievementId: kotlin.Long?,
        @Parameter(description = "the analytic tag to identify an achievement (achievementId or tag required)") @Valid @RequestParam(value = "tag", required = false) tag: kotlin.String?,
        @Parameter(description = "a custom identifier used for validation") @Valid @RequestParam(value = "customId", required = false) customId: kotlin.Long?,
        @Parameter(description = "the amount to increment an achievement progress by (if no increment is sent in, the server defaults to using the achievement's rankIncrement value)") @Valid @RequestParam(value = "increment", required = false) increment: kotlin.Long?,
        @Parameter(description = "a custom start date that the client can set (not yet used in server logic)") @Valid @RequestParam(value = "startDate", required = false) startDate: kotlin.Long?,
        @Parameter(description = "a custom end date that the client can set (not yet used in server logic)") @Valid @RequestParam(value = "endDate", required = false) endDate: kotlin.Long?,
        @Parameter(description = "determines whether to return the achievement progress response") @Valid @RequestParam(value = "returnProgress", required = false) returnProgress: kotlin.Boolean?
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Update the coins for a user (as a Business)",
        operationId = "updateUserCoinsAsBusiness",
        description = """Update the coins for a user (as a Business).""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation") ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/vatom/b/users/coins/update"
        value = [PATH_UPDATE_USER_COINS_AS_BUSINESS]
    )
    fun updateUserCoinsAsBusiness(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "Sirqul Account Id", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "Vatom User Id", required = true) @Valid @RequestParam(value = "vatomUserId", required = true) vatomUserId: kotlin.String,
        @NotNull @Parameter(description = "Sirqul Application Key", required = true) @Valid @RequestParam(value = "appKey", required = true) appKey: kotlin.String,
        @NotNull @Parameter(description = "Vatom Parameters", required = true) @Valid @RequestParam(value = "vatomParameters", required = true) vatomParameters: kotlin.String,
        @Parameter(description = "Return raw response") @Valid @RequestParam(value = "returnRawResponse", required = false) returnRawResponse: kotlin.Boolean?
    ): ResponseEntity<Unit> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Update Vatom User Profile",
        operationId = "updateUserProfile",
        description = """Gets the logged in user's profile in Vatom.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation") ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/vatom/me/update"
        value = [PATH_UPDATE_USER_PROFILE]
    )
    fun updateUserProfile(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "Sirqul Account Id", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "Vatom Parameters", required = true) @Valid @RequestParam(value = "vatomParameters", required = true) vatomParameters: kotlin.String,
        @Parameter(description = "Return raw response") @Valid @RequestParam(value = "returnRawResponse", required = false) returnRawResponse: kotlin.Boolean?
    ): ResponseEntity<Unit> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Update Vatom Event",
        operationId = "updateVatomEvent",
        description = """Update a Vatom event.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation") ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/vatom/b/events/update"
        value = [PATH_UPDATE_VATOM_EVENT]
    )
    fun updateVatomEvent(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "Sirqul Account Id", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "Sirqul Application Key", required = true) @Valid @RequestParam(value = "appKey", required = true) appKey: kotlin.String,
        @NotNull @Parameter(description = "Vatom Event Id", required = true) @Valid @RequestParam(value = "vatomEventId", required = true) vatomEventId: kotlin.String,
        @NotNull @Parameter(description = "Vatom Parameters", required = true) @Valid @RequestParam(value = "vatomParameters", required = true) vatomParameters: kotlin.String,
        @Parameter(description = "Return raw response") @Valid @RequestParam(value = "returnRawResponse", required = false) returnRawResponse: kotlin.Boolean?
    ): ResponseEntity<Unit> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Update Vehicle",
        operationId = "updateVehicle",
        description = """Update an existing vehicle""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = Vehicle::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.PUT],
        // "/api/{version}/vehicle/{id}"
        value = [PATH_UPDATE_VEHICLE],
        produces = ["*/*"]
    )
    fun updateVehicle(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "The id of the vehicle to update", required = true) @PathVariable("id") id: kotlin.Long,
        @NotNull @Parameter(description = "A JSON representation of cargo type, for example: ```json {   \"name\": \"Truck\",   \"vehicleType\": { \"id\": 1 },   \"hub\": { \"id\": 1 } } ``` ", required = true) @Valid @RequestParam(value = "vehicle", required = true) vehicle: kotlin.String,
        @Parameter(description = "") @Valid @RequestBody(required = false) body: Vehicle?
    ): ResponseEntity<Vehicle> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Update Vehicle Type",
        operationId = "updateVehicleType",
        description = """Update a vehicle type""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = VehicleType::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.PUT],
        // "/api/{version}/vehicle/type/{vehicleTypeId}"
        value = [PATH_UPDATE_VEHICLE_TYPE],
        produces = ["*/*"]
    )
    fun updateVehicleType(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @Parameter(description = "The id of the vehicle type to update", required = true) @PathVariable("vehicleTypeId") vehicleTypeId: kotlin.Long,
        @NotNull @Parameter(description = "The new data for the vehicle type to update to. A JSON representation of cargo type, for example: ```json {   \"name\": \"Truck\",   \"width\": 100,   \"height\": 200,   \"depth\": 200,   \"maxWeight\": 5000,   \"hub\": { \"id\": 1 } } ``` ", required = true) @Valid @RequestParam(value = "vehicleType", required = true) vehicleType: kotlin.String,
        @Parameter(description = "") @Valid @RequestBody(required = false) body: VehicleType?
    ): ResponseEntity<VehicleType> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Update Word",
        operationId = "updateWord",
        description = """Update a word by the given params.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = WordzWordResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/game/word/update"
        value = [PATH_UPDATE_WORD],
        produces = ["*/*"]
    )
    fun updateWord(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The id of the word to update.", required = true) @Valid @RequestParam(value = "wordId", required = true) wordId: kotlin.Long,
        @NotNull @Parameter(description = "The logged in user.", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "The number of tickets to reward", required = true, schema = Schema(defaultValue = "0L")) @Valid @RequestParam(value = "ticketCount", required = true, defaultValue = "0L") ticketCount: kotlin.Long,
        @Parameter(description = "The text for the word") @Valid @RequestParam(value = "wordText", required = false) wordText: kotlin.String?,
        @Parameter(description = "The definition of the word.") @Valid @RequestParam(value = "definition", required = false) definition: kotlin.String?,
        @Parameter(description = "The asset id of the word.") @Valid @RequestParam(value = "assetId", required = false) assetId: kotlin.Long?,
        @Parameter(description = "If true set the word to active.") @Valid @RequestParam(value = "active", required = false) active: kotlin.Boolean?,
        @Parameter(description = "If true then scoring will give tickets.") @Valid @RequestParam(value = "allocateTickets", required = false) allocateTickets: kotlin.Boolean?,
        @Parameter(description = "The type of ticket to reward, null means default type") @Valid @RequestParam(value = "ticketType", required = false) ticketType: kotlin.String?,
        @Parameter(description = "The number of points to award for completing a mission") @Valid @RequestParam(value = "points", required = false) points: kotlin.Long?
    ): ResponseEntity<WordzWordResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Update Level Words",
        operationId = "updateWordsInLevel",
        description = """Updates a level with word game objects.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/level/words/update"
        value = [PATH_UPDATE_WORDS_IN_LEVEL],
        produces = ["*/*"]
    )
    fun updateWordsInLevel(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the id of the level to update words for", required = true) @Valid @RequestParam(value = "levelId", required = true) levelId: kotlin.Long,
        @NotNull @Parameter(description = "the id of the logged in user", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "the ids of the words to update for the level", required = true) @Valid @RequestParam(value = "wordIds", required = true) wordIds: kotlin.String
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Create Application Certificate",
        operationId = "uploadApplicationCertificate",
        description = """Uploads a certificate for an application that the user has access to.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/application/certificate/create"
        value = [PATH_UPLOAD_APPLICATION_CERTIFICATE],
        produces = ["*/*"]
    )
    fun uploadApplicationCertificate(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The key of the application", required = true) @Valid @RequestParam(value = "appKey", required = true) appKey: kotlin.String,
        @Parameter(description = "Device Id") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "The account used to perform the delete, must have rights to edit the application.") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "Certificate") @Valid @RequestParam(value = "certificate", required = false) certificate: org.springframework.web.multipart.MultipartFile
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Upload CSV",
        operationId = "uploadCSV",
        description = """Uploads a CSV import file.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = CsvImportResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/csvimport/upload"
        value = [PATH_UPLOAD_CSV],
        produces = ["*/*"]
    )
    fun uploadCSV(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the id of the account", required = true) @Valid @RequestParam(value = "accountId", required = true) accountId: kotlin.Long,
        @NotNull @Parameter(description = "the upload type: OFFERS, RETAILERS, RETAILERLOCATIONS, CATEGORIES, OR FILTERS", required = true, schema = Schema(allowableValues = ["OFFERS", "RETAILERS", "RETAILERLOCATIONS", "CATEGORIES", "FILTERS"])) @Valid @RequestParam(value = "uploadType", required = true) uploadType: kotlin.String,
        @NotNull @Parameter(description = "the import file to reference", required = true) @Valid @RequestParam(value = "importFile", required = true) importFile: org.springframework.web.multipart.MultipartFile,
        @NotNull @Parameter(description = "the format of the file", required = true, schema = Schema(allowableValues = ["EXCEL", "MYSQL", "RFC4180", "TDF"])) @Valid @RequestParam(value = "fileFormat", required = true) fileFormat: kotlin.String,
        @Parameter(description = "the application key") @Valid @RequestParam(value = "appKey", required = false) appKey: kotlin.String?
    ): ResponseEntity<CsvImportResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Create Usage Record",
        operationId = "usage",
        description = """Record an analytic record for a known state within the application.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/analytics/usage"
        value = [PATH_USAGE],
        produces = ["*/*"]
    )
    fun usage(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The tag to apply: the name of the action or thing being logged.", required = true) @Valid @RequestParam(value = "tag", required = true) tag: kotlin.String,
        @Parameter(description = "The client deviceID") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "The logged in user ID") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "This parameter is deprecated. This is deprecated, use appKey.") @Valid @RequestParam(value = "applicationId", required = false) applicationId: kotlin.Long?,
        @Parameter(description = "The application key unique to each application.") @Valid @RequestParam(value = "appKey", required = false) appKey: kotlin.String?,
        @Parameter(description = "The current build version of the application") @Valid @RequestParam(value = "appVersion", required = false) appVersion: kotlin.String?,
        @Parameter(description = "The name of the device being used (iPhone5,1 , HTC Nexus One, x86_64, etc.)") @Valid @RequestParam(value = "device", required = false) device: kotlin.String?,
        @Parameter(description = "The type of device (Handheld or Desktop)") @Valid @RequestParam(value = "deviceType", required = false) deviceType: kotlin.String?,
        @Parameter(description = "The operating system that the device is using (iPhone OS 5.0, Android OS 2.3.6, Windows 7 Service Pack 1, etc)") @Valid @RequestParam(value = "deviceOS", required = false) deviceOS: kotlin.String?,
        @Parameter(description = "The model of the device (iPhone5,1 , Nexus One, etc.)") @Valid @RequestParam(value = "model", required = false) model: kotlin.String?,
        @Parameter(description = "The current position of the user") @Valid @RequestParam(value = "latitude", required = false) latitude: kotlin.Double?,
        @Parameter(description = "The current position of the user") @Valid @RequestParam(value = "longitude", required = false) longitude: kotlin.Double?,
        @Parameter(description = "A customId used to associate the usage record with some other record in the system") @Valid @RequestParam(value = "customId", required = false) customId: kotlin.Long?,
        @Parameter(description = "The type of record the customId is recorded for") @Valid @RequestParam(value = "customType", required = false) customType: kotlin.String?,
        @Parameter(description = "This parameter is deprecated. This is deprecated, use \"customValue\". Determines how many achievement points and/or ranking points the user gets if this analytic is associated with an achievement") @Valid @RequestParam(value = "achievementIncrement", required = false) achievementIncrement: kotlin.Long?,
        @Parameter(description = "The current city of the user") @Valid @RequestParam(value = "city", required = false) city: kotlin.String?,
        @Parameter(description = "The current state of the user") @Valid @RequestParam(value = "state", required = false) state: kotlin.String?,
        @Parameter(description = "The current country of the user") @Valid @RequestParam(value = "country", required = false) country: kotlin.String?,
        @Parameter(description = "The current zip of the user") @Valid @RequestParam(value = "zip", required = false) zip: kotlin.String?,
        @Parameter(description = "The general description of the user's location") @Valid @RequestParam(value = "locationDescription", required = false) locationDescription: kotlin.String?,
        @Parameter(description = "Timestamp sent from device") @Valid @RequestParam(value = "clientTime", required = false) clientTime: kotlin.Long?,
        @Parameter(description = "This parameter is deprecated.") @Valid @RequestParam(value = "errorMessage", required = false) errorMessage: kotlin.String?,
        @Parameter(description = "the ip address of the client device") @Valid @RequestParam(value = "ip", required = false) ip: kotlin.String?,
        @Parameter(description = "this is a description of the client (might contain the device's OS, browser version etc - its a common term)") @Valid @RequestParam(value = "userAgent", required = false) userAgent: kotlin.String?,
        @Parameter(description = "This is deprecated.") @Valid @RequestParam(value = "backgroundEvent", required = false) backgroundEvent: kotlin.Boolean?,
        @Parameter(description = "a custom message for the usage record") @Valid @RequestParam(value = "customMessage", required = false) customMessage: kotlin.String?,
        @Parameter(description = "a custom message for the usage record") @Valid @RequestParam(value = "customMessage2", required = false) customMessage2: kotlin.String?,
        @Parameter(description = "a custom value for the usage record") @Valid @RequestParam(value = "customValue", required = false) customValue: kotlin.Double?,
        @Parameter(description = "a custom value for the usage record") @Valid @RequestParam(value = "customValue2", required = false) customValue2: kotlin.Double?,
        @Parameter(description = "a custom long value for the usage record") @Valid @RequestParam(value = "customLong", required = false) customLong: kotlin.Long?,
        @Parameter(description = "a custom long value for the usage record") @Valid @RequestParam(value = "customLong2", required = false) customLong2: kotlin.Long?
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Create Multiple Usage Records",
        operationId = "usageBatch",
        description = """Sends multiple analytics. Can be used to send in the user's stored usage when they did not have internet access. Should not include more than 100 items per batch.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/analytics/usage/batch"
        value = [PATH_USAGE_BATCH],
        produces = ["*/*"]
    )
    fun usageBatch(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The application key unique to each application.", required = true) @Valid @RequestParam(value = "appKey", required = true) appKey: kotlin.String,
        @NotNull @Parameter(description = "The name of the device being used (iPhone5,1 , HTC Nexus One, x86_64, etc.)", required = true) @Valid @RequestParam(value = "device", required = true) device: kotlin.String,
        @NotNull @Parameter(description = "The analytic data AnalyticListResponse", required = true) @Valid @RequestParam(value = "data", required = true) `data`: kotlin.String,
        @Parameter(description = "The unique id of the device making the request") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "The account ID of the logged in user making the request") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "The current build version of the application") @Valid @RequestParam(value = "appVersion", required = false) appVersion: kotlin.String?,
        @Parameter(description = "The type of device (Handheld or Desktop)") @Valid @RequestParam(value = "deviceType", required = false) deviceType: kotlin.String?,
        @Parameter(description = "The operating system that the device is using (iPhone OS 5.0, Android OS 2.3.6, Windows 7 Service Pack 1, etc.)") @Valid @RequestParam(value = "deviceOS", required = false) deviceOS: kotlin.String?,
        @Parameter(description = "The model of the device (iPhone5,1 , Nexus One, etc.)") @Valid @RequestParam(value = "model", required = false) model: kotlin.String?,
        @Parameter(description = "Will create a leaderboard if one does not exist for the \"tag\" yet") @Valid @RequestParam(value = "updateRanking", required = false) updateRanking: kotlin.Boolean?,
        @Parameter(description = "Returns a summary response of the achievements that have been completed due to the analytics") @Valid @RequestParam(value = "returnSummaryResponse", required = false) returnSummaryResponse: kotlin.Boolean?
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Save Validation Status",
        operationId = "validateAccountSignup",
        description = """Validate the account's email address. The token must be valid and not expired. Use the RequestValidateAccount end point to request a new token.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = AccountLoginResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/account/validateAccountSignup"
        value = [PATH_VALIDATE_ACCOUNT_SIGNUP],
        produces = ["*/*"]
    )
    fun validateAccountSignup(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The token associated with the account to update, good for 24 hours", required = true) @Valid @RequestParam(value = "token", required = true) token: kotlin.String
    ): ResponseEntity<AccountLoginResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Validate Password Reset Token",
        operationId = "validatePasswordReset",
        description = """Validate the password reset token. The token must be valid and not expired. Use the RequestPasswordReset end point to request a token. The user receives and email with the reset page, therefore it should be validated before bwing used to reset the password.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = SirqulResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/account/validatepasswordreset"
        value = [PATH_VALIDATE_PASSWORD_RESET],
        produces = ["*/*"]
    )
    fun validatePasswordReset(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The token associated with the account to update, good for 24 hours", required = true) @Valid @RequestParam(value = "token", required = true) token: kotlin.String
    ): ResponseEntity<SirqulResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Vote on Contest",
        operationId = "voteOnAlbumContest",
        description = """Vote on a collection in a contest.""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(schema = Schema(implementation = AlbumContestResponse::class))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.POST],
        // "/api/{version}/consumer/album/contest/vote"
        value = [PATH_VOTE_ON_ALBUM_CONTEST],
        produces = ["*/*"]
    )
    fun voteOnAlbumContest(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "the album contest ID", required = true) @Valid @RequestParam(value = "albumContestId", required = true) albumContestId: kotlin.Long,
        @NotNull @Parameter(description = "the ID of the album to vote on", required = true) @Valid @RequestParam(value = "albumId", required = true) albumId: kotlin.Long,
        @Parameter(description = "a unique ID given by the device (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "the account ID of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "a custom field used for aggregation and searching") @Valid @RequestParam(value = "contestType", required = false) contestType: kotlin.String?,
        @Parameter(description = "latitude used to update the user's current location") @Valid @RequestParam(value = "latitude", required = false) latitude: kotlin.Double?,
        @Parameter(description = "longitude used to update the user's current location") @Valid @RequestParam(value = "longitude", required = false) longitude: kotlin.Double?
    ): ResponseEntity<AlbumContestResponse> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    @Operation(
        summary = "Who has Favorited",
        operationId = "whoHasFavorited",
        description = """Searches for everyone that has favorited an item""",
        responses = [
            ApiResponse(responseCode = "200", description = "successful operation", content = [Content(array = ArraySchema(schema = Schema(implementation = AccountResponse::class)))]) ]
    )
    @RequestMapping(
        method = [RequestMethod.GET],
        // "/api/{version}/favorite/whois"
        value = [PATH_WHO_HAS_FAVORITED],
        produces = ["*/*"]
    )
    fun whoHasFavorited(
        @Parameter(description = "", required = true) @PathVariable("version") version: java.math.BigDecimal,
        @NotNull @Parameter(description = "The ID of the favoritableType to search on", required = true) @Valid @RequestParam(value = "favoritableId", required = true) favoritableId: kotlin.Long,
        @NotNull @Parameter(description = "The type of the object to favorite {OFFER, OFFER_LOCATION, RETAILER_LOCATION, CATEGORY}", required = true) @Valid @RequestParam(value = "favoritableType", required = true) favoritableType: kotlin.String,
        @NotNull @Parameter(description = "The start index for pagination", required = true) @Valid @RequestParam(value = "start", required = true) start: kotlin.Int,
        @NotNull @Parameter(description = "The limit for pagination", required = true) @Valid @RequestParam(value = "limit", required = true) limit: kotlin.Int,
        @Parameter(description = "The unique ID given by the device (deviceId or accountId required)") @Valid @RequestParam(value = "deviceId", required = false) deviceId: kotlin.String?,
        @Parameter(description = "The account ID of the user (deviceId or accountId required)") @Valid @RequestParam(value = "accountId", required = false) accountId: kotlin.Long?,
        @Parameter(description = "The current latitude of the user") @Valid @RequestParam(value = "latitude", required = false) latitude: kotlin.Double?,
        @Parameter(description = "The current longitude of the user") @Valid @RequestParam(value = "longitude", required = false) longitude: kotlin.Double?,
        @Parameter(description = "The keyword to limit that account list") @Valid @RequestParam(value = "keyword", required = false) keyword: kotlin.String?
    ): ResponseEntity<List<AccountResponse>> {
        return ResponseEntity(HttpStatus.NOT_IMPLEMENTED)
    }

    companion object {
        //for your own safety never directly reuse these path definitions in tests
        const val BASE_PATH: String = ""
        const val PATH_ACCEPT_INVITE: String = "/api/{version}/invite/accept"
        const val PATH_ACCOUNT_LOCATION_SEARCH: String = "/api/{version}/account/search"
        const val PATH_ACTIVITIES: String = "/api/{version}/analytics/useractivity"
        const val PATH_ADD_ALBUM_COLLECTION: String = "/api/{version}/album/create"
        const val PATH_ADD_ALBUM_USERS: String = "/api/{version}/album/user/add"
        const val PATH_ADD_CONNECTION_TO_GROUP: String = "/api/{version}/consumer/connection/group/addConnection"
        const val PATH_ADD_CONNECTIONS_TO_GROUP: String = "/api/{version}/connection/group/addConnections"
        const val PATH_ADD_FAVORITE: String = "/api/{version}/favorite/create"
        const val PATH_ADD_FIELD: String = "/api/{version}/object/field/add"
        const val PATH_ADD_MOVIE: String = "/api/{version}/orson/ai/addMovie"
        const val PATH_ADD_OR_UPDATE_ALBUM_CONTEST: String = "/api/{version}/consumer/album/contest"
        const val PATH_ADD_OR_UPDATE_THEME_DESCRIPTOR: String = "/api/{version}/consumer/theme"
        const val PATH_ADD_PAYMENT_METHOD: String = "/api/{version}/billing/update"
        const val PATH_ADD_PREVIEW: String = "/api/{version}/creative/addpreview"
        const val PATH_ADD_SUB_GROUPS: String = "/api/{version}/consumer/connection/group/addSubGroup"
        const val PATH_ADD_USERS_TO_PERMISSIONABLE: String = "/api/{version}/consumer/permissions/add"
        const val PATH_ADS_FIND: String = "/api/{version}/ads/find"
        const val PATH_AGGREGATED_FILTERED_USAGE: String = "/api/{version}/analytics/aggregatedFilteredUsage"
        const val PATH_AI_DOCS: String = "/api/{version}/orson/ai/docs"
        const val PATH_AI_FIND_IMAGES: String = "/api/{version}/orson/ai/img"
        const val PATH_AI_TAGS: String = "/api/{version}/orson/ai/tags"
        const val PATH_AI_TEXT: String = "/api/{version}/orson/ai/text"
        const val PATH_ALBUM_CONTEST_INVITE: String = "/api/{version}/invite/albumContest"
        const val PATH_ALBUM_INVITE: String = "/api/{version}/invite/album"
        const val PATH_API_VERSION_ACHIEVEMENT_TIER_SEARCH_POST: String = "/api/{version}/achievement/tier/search"
        const val PATH_APPROVE_ALBUM: String = "/api/{version}/album/approve"
        const val PATH_APPROVE_ALBUM_CONTEST: String = "/api/{version}/consumer/album/contest/approve"
        const val PATH_APPROVE_PERMISSIONABLE: String = "/api/{version}/permissionable/approve"
        const val PATH_APPROVE_ROUTE: String = "/api/{version}/route/{routeId}/approve"
        const val PATH_ASSET_DOWNLOAD: String = "/api/{version}/asset/download/{filename}"
        const val PATH_ASSET_MORPH: String = "/api/{version}/asset/morph"
        const val PATH_ASSIGMENT_ASSIGNEE_ACCOUNT_SEARCH: String = "/api/{version}/assignment/assignee/search"
        const val PATH_ASSIGN_EMPLOYEE: String = "/api/{version}/employee/assign"
        const val PATH_ASSIGN_TO_LOCATION_EMPLOYEE: String = "/api/{version}/employee/assignToLocation"
        const val PATH_ASSIGNMENT_CREATE: String = "/api/{version}/assignment/create"
        const val PATH_ASSIGNMENT_DELETE: String = "/api/{version}/assignment/delete"
        const val PATH_ASSIGNMENT_GET: String = "/api/{version}/assignment/get"
        const val PATH_ASSIGNMENT_SEARCH: String = "/api/{version}/assignment/search"
        const val PATH_ASSIGNMENT_STATUS_CREATE: String = "/api/{version}/assignment/status/create"
        const val PATH_ASSIGNMENT_STATUS_DELETE: String = "/api/{version}/assignment/status/delete"
        const val PATH_ASSIGNMENT_STATUS_GET: String = "/api/{version}/assignment/status/get"
        const val PATH_ASSIGNMENT_STATUS_SEARCH: String = "/api/{version}/assignment/status/search"
        const val PATH_ASSIGNMENT_STATUS_UPDATE: String = "/api/{version}/assignment/status/update"
        const val PATH_ASSIGNMENT_UPDATE: String = "/api/{version}/assignment/update"
        const val PATH_ATTEND_EVENT: String = "/api/{version}/event/attend"
        const val PATH_AUTHORIZE_TWITTER: String = "/api/{version}/twitter/authorize"
        const val PATH_BATCH: String = "/api/{version}/orson/ai/batch"
        const val PATH_BATCH_OPERATION: String = "/api/{version}/note/batch"
        const val PATH_BATCH_SAVE_TRACKING: String = "/api/{version}/tracking/batch/create"
        const val PATH_BATCH_UPDATE_OFFER_LOCATIONS: String = "/api/{version}/retailer/offer/location/batchUpdate"
        const val PATH_BLOCK_ACCOUNT: String = "/api/{version}/account/block"
        const val PATH_CACHE_TRILATERATION_DATA: String = "/api/{version}/location/trilaterate/cache"
        const val PATH_CACHE_TRILATERATION_DATA_GZIP: String = "/api/{version}/location/trilaterate/cache/submit"
        const val PATH_CANCEL_SHIPMENT: String = "/api/{version}/shipment/{id}/cancel"
        const val PATH_CATEGORY_DISTANCE_SEARCH: String = "/api/{version}/category/distancesearch"
        const val PATH_CHECK_DISBURSEMENTS: String = "/api/{version}/disbursement/check"
        const val PATH_COMPUTE_PATH: String = "/api/{version}/pathing/compute"
        const val PATH_COMPUTE_ROUTING: String = "/api/{version}/routing/compute"
        const val PATH_CONSUMER_CREATE: String = "/api/{version}/queue/consumer/create"
        const val PATH_CONSUMER_UPDATE: String = "/api/{version}/queue/consumer/update"
        const val PATH_COPY_ROUTE: String = "/api/{version}/route/{routeId}/copy"
        const val PATH_CREATE: String = "/api/{version}/cargo/dependent/{accountId}"
        const val PATH_CREATE_ACCOUNT: String = "/api/{version}/account/create"
        const val PATH_CREATE_ACHIEVEMENT: String = "/api/{version}/achievement/create"
        const val PATH_CREATE_ACHIEVEMENT_TIER: String = "/api/{version}/achievement/tier/create"
        const val PATH_CREATE_APPLICATION: String = "/api/{version}/application/create"
        const val PATH_CREATE_APPLICATION_CONFIG: String = "/api/{version}/appconfig/create"
        const val PATH_CREATE_APPLICATION_PLACEMENT: String = "/api/{version}/application/placement/create"
        const val PATH_CREATE_ASSET: String = "/api/{version}/asset/create"
        const val PATH_CREATE_AUDIENCE: String = "/api/{version}/audience/create"
        const val PATH_CREATE_BATCH: String = "/api/{version}/report/batch/create"
        const val PATH_CREATE_BID: String = "/api/{version}/bid/create"
        const val PATH_CREATE_BILLABLE_ENTITY: String = "/api/{version}/billable/create"
        const val PATH_CREATE_CARGO_TYPE: String = "/api/{version}/cargo/type"
        const val PATH_CREATE_CATEGORY: String = "/api/{version}/category/create"
        const val PATH_CREATE_CREATIVE: String = "/api/{version}/creative/create"
        const val PATH_CREATE_CREDENTIAL: String = "/api/{version}/thirdparty/credential/create"
        const val PATH_CREATE_DATA: String = "/api/{version}/object/data/{objectName}"
        const val PATH_CREATE_DISBURSEMENT: String = "/api/{version}/disbursement/create"
        const val PATH_CREATE_EMPLOYEE: String = "/api/{version}/employee/create"
        const val PATH_CREATE_ENTITY_REFERENCE: String = "/api/{version}/entity/reference"
        const val PATH_CREATE_EVENT: String = "/api/{version}/event/create"
        const val PATH_CREATE_FILTER: String = "/api/{version}/filter/create"
        const val PATH_CREATE_FLAG: String = "/api/{version}/flag/create"
        const val PATH_CREATE_FOLLOWING: String = "/api/{version}/vatom/me/rels/following/create"
        const val PATH_CREATE_GAME: String = "/api/{version}/game/create"
        const val PATH_CREATE_GAME_LEVEL: String = "/api/{version}/level/create"
        const val PATH_CREATE_INSTANT_EPISODE: String = "/api/{version}/orson/stories/episodes/instant"
        const val PATH_CREATE_LEADERBOARD: String = "/api/{version}/leaderboard/create"
        const val PATH_CREATE_LISTING: String = "/api/{version}/listing/create"
        const val PATH_CREATE_LOCATION_V2: String = "/api/{version}/location"
        const val PATH_CREATE_MEDIA: String = "/api/{version}/media/create"
        const val PATH_CREATE_MISSION: String = "/api/{version}/mission/create"
        const val PATH_CREATE_MISSION_INVITE: String = "/api/{version}/mission/invite/create"
        const val PATH_CREATE_NETWORK: String = "/api/{version}/thirdparty/network/create"
        const val PATH_CREATE_NOTE: String = "/api/{version}/note/create"
        const val PATH_CREATE_NOTIFICATION_TEMPLATE: String = "/api/{version}/notification/template/create"
        const val PATH_CREATE_OBJECT: String = "/api/{version}/object/create"
        const val PATH_CREATE_OFFER: String = "/api/{version}/retailer/offer/create"
        const val PATH_CREATE_OFFER_TRANSACTION: String = "/api/{version}/wallet/create"
        const val PATH_CREATE_OFFER_TRANSACTION_STATUS: String = "/api/{version}/offer/status/create"
        const val PATH_CREATE_OR_UPDATE_BLOCKED_NOTIFICATIONS: String = "/api/{version}/notification/blocked/batch"
        const val PATH_CREATE_OR_UPDATE_CONNECTION: String = "/api/{version}/consumer/connection/add"
        const val PATH_CREATE_OR_UPDATE_GROUP: String = "/api/{version}/consumer/connection/group"
        const val PATH_CREATE_ORDER: String = "/api/{version}/order/create"
        const val PATH_CREATE_PACK: String = "/api/{version}/pack/create"
        const val PATH_CREATE_PAYMENT_METHOD: String = "/api/{version}/billing/create"
        const val PATH_CREATE_PERSONA: String = "/api/{version}/persona/create"
        const val PATH_CREATE_POSTAL_CODE: String = "/api/{version}/postalCode/create"
        const val PATH_CREATE_PROGRAM: String = "/api/{version}/program"
        const val PATH_CREATE_PURCHASE_ITEM: String = "/api/{version}/purchase/create"
        const val PATH_CREATE_QUESTION: String = "/api/{version}/game/question/create"
        const val PATH_CREATE_RATING: String = "/api/{version}/rating/create"
        const val PATH_CREATE_REGION: String = "/api/{version}/region/create"
        const val PATH_CREATE_REGION_LEG_SUMMARY_BATCH: String = "/api/{version}/report/region/summary/batch"
        const val PATH_CREATE_RESERVATION: String = "/api/{version}/reservation/create"
        const val PATH_CREATE_RETAILER: String = "/api/{version}/retailer/create"
        const val PATH_CREATE_RETAILER_LOCATION_CONSUMER: String = "/api/{version}/location/create"
        const val PATH_CREATE_RETAILER_LOCATIONS: String = "/api/{version}/retailer/location/create"
        const val PATH_CREATE_ROUTE: String = "/api/{version}/route"
        const val PATH_CREATE_ROUTE_DIRECTIONS: String = "/api/{version}/route/{routeId}/directions"
        const val PATH_CREATE_ROUTE_POLYLINE: String = "/api/{version}/route/{routeId}/polyline"
        const val PATH_CREATE_ROUTE_SETTINGS: String = "/api/{version}/route/setting"
        const val PATH_CREATE_SCHEDULED_NOTIFICATION: String = "/api/{version}/notification/schedule/create"
        const val PATH_CREATE_SCORE: String = "/api/{version}/score/create"
        const val PATH_CREATE_SECURE_APPLICATION: String = "/api/{version}/secure/application/create"
        const val PATH_CREATE_SERVICE_HUB: String = "/api/{version}/hub"
        const val PATH_CREATE_SHIPMENT: String = "/api/{version}/shipment"
        const val PATH_CREATE_SHIPMENT_BATCH: String = "/api/{version}/shipment/batch"
        const val PATH_CREATE_SMART_CONTRACT: String = "/api/{version}/billing/crypto/transfer"
        const val PATH_CREATE_SPACE: String = "/api/{version}/vatom/b/spaces/create"
        const val PATH_CREATE_STRIPE_CHECKOUT_SESSION: String = "/api/{version}/stripe/checkout/session/create"
        const val PATH_CREATE_SUBSCRIPTION: String = "/api/{version}/subscription/create"
        const val PATH_CREATE_TASK: String = "/api/{version}/task/create"
        const val PATH_CREATE_TERRITORY: String = "/api/{version}/territory/create"
        const val PATH_CREATE_TOURNAMENT: String = "/api/{version}/tournament/create"
        const val PATH_CREATE_TRIGGER: String = "/api/{version}/trigger/create"
        const val PATH_CREATE_TRIP: String = "/api/{version}/trip"
        const val PATH_CREATE_VATOM_EVENT: String = "/api/{version}/vatom/b/events/create"
        const val PATH_CREATE_VEHICLE: String = "/api/{version}/vehicle"
        const val PATH_CREATE_VEHICLE_TYPE: String = "/api/{version}/vehicle/type"
        const val PATH_CREATE_VOICE_CANVAS: String = "/api/{version}/orson/ai/voiceCanvas"
        const val PATH_CREATE_WORD: String = "/api/{version}/game/word/create"
        const val PATH_DELETE: String = "/api/{version}/trip/{id}"
        const val PATH_DELETE_ACHIEVEMENT: String = "/api/{version}/achievement/delete"
        const val PATH_DELETE_ACHIEVEMENT_TIER: String = "/api/{version}/achievement/tier/delete"
        const val PATH_DELETE_APPLICATION: String = "/api/{version}/application/delete"
        const val PATH_DELETE_APPLICATION_CONFIG: String = "/api/{version}/appconfig/delete"
        const val PATH_DELETE_APPLICATION_PLACEMENT: String = "/api/{version}/application/placement/delete"
        const val PATH_DELETE_ASSET: String = "/api/{version}/asset/delete"
        const val PATH_DELETE_AUDIENCE: String = "/api/{version}/audience/delete"
        const val PATH_DELETE_BATCH: String = "/api/{version}/report/batch/delete"
        const val PATH_DELETE_BID: String = "/api/{version}/bid/delete"
        const val PATH_DELETE_BILLABLE_ENTITY: String = "/api/{version}/billable/delete"
        const val PATH_DELETE_CARGO_TYPE: String = "/api/{version}/cargo/type/{cargoTypeId}"
        const val PATH_DELETE_CATEGORY: String = "/api/{version}/category/delete"
        const val PATH_DELETE_CONTEST: String = "/api/{version}/consumer/album/contest/remove"
        const val PATH_DELETE_CREATIVE: String = "/api/{version}/creative/delete"
        const val PATH_DELETE_CREDENTIAL: String = "/api/{version}/thirdparty/credential/delete"
        const val PATH_DELETE_DATA: String = "/api/{version}/object/data/{objectName}/{objectId}"
        const val PATH_DELETE_EMPLOYEE: String = "/api/{version}/employee/delete"
        const val PATH_DELETE_EVENT: String = "/api/{version}/event/delete"
        const val PATH_DELETE_FAVORITE: String = "/api/{version}/favorite/delete"
        const val PATH_DELETE_FIELD: String = "/api/{version}/object/field/delete"
        const val PATH_DELETE_FILTER: String = "/api/{version}/filter/delete"
        const val PATH_DELETE_FLAG: String = "/api/{version}/flag/delete"
        const val PATH_DELETE_FOLLOWING: String = "/api/{version}/vatom/me/rels/following/delete"
        const val PATH_DELETE_GAME: String = "/api/{version}/game/delete"
        const val PATH_DELETE_GAME_LEVEL: String = "/api/{version}/level/delete"
        const val PATH_DELETE_LEADERBOARD: String = "/api/{version}/leaderboard/delete"
        const val PATH_DELETE_LISTING: String = "/api/{version}/listing/delete"
        const val PATH_DELETE_MEDIA: String = "/api/{version}/media/delete"
        const val PATH_DELETE_MISSION: String = "/api/{version}/mission/delete"
        const val PATH_DELETE_MISSION_INVITE: String = "/api/{version}/mission/invite/delete"
        const val PATH_DELETE_NETWORK: String = "/api/{version}/thirdparty/network/delete"
        const val PATH_DELETE_NOTE: String = "/api/{version}/note/delete"
        const val PATH_DELETE_NOTIFICATION_TEMPLATE: String = "/api/{version}/notification/template/delete"
        const val PATH_DELETE_OBJECT: String = "/api/{version}/object/delete"
        const val PATH_DELETE_OFFER: String = "/api/{version}/retailer/offer/delete"
        const val PATH_DELETE_OFFER_LOCATION: String = "/api/{version}/retailer/offer/location/delete"
        const val PATH_DELETE_OFFER_TRANSACTION: String = "/api/{version}/wallet/delete"
        const val PATH_DELETE_OFFER_TRANSACTION_STATUS: String = "/api/{version}/offer/status/delete"
        const val PATH_DELETE_ORDER: String = "/api/{version}/order/delete"
        const val PATH_DELETE_PACK: String = "/api/{version}/pack/delete"
        const val PATH_DELETE_PERSONA: String = "/api/{version}/persona/delete"
        const val PATH_DELETE_POINTS_BALANCE: String = "/api/{version}/vatom/b/campaign/points/delete"
        const val PATH_DELETE_POSTAL_CODE: String = "/api/{version}/postalCode/delete"
        const val PATH_DELETE_PROGRAM: String = "/api/{version}/program/{id}"
        const val PATH_DELETE_PURCHASE_ITEM: String = "/api/{version}/purchase/delete"
        const val PATH_DELETE_QUESTION: String = "/api/{version}/game/question/delete"
        const val PATH_DELETE_RATING: String = "/api/{version}/rating/delete"
        const val PATH_DELETE_REGION: String = "/api/{version}/region/delete"
        const val PATH_DELETE_RESERVATION: String = "/api/{version}/reservation/delete"
        const val PATH_DELETE_RETAILER: String = "/api/{version}/retailer/delete"
        const val PATH_DELETE_RETAILER_LOCATION: String = "/api/{version}/retailer/location/delete"
        const val PATH_DELETE_ROUTE: String = "/api/{version}/route/{routeId}"
        const val PATH_DELETE_ROUTE_SETTINGS: String = "/api/{version}/route/setting/{routeSettingsId}"
        const val PATH_DELETE_SCHEDULED_NOTIFICATION: String = "/api/{version}/notification/schedule/delete"
        const val PATH_DELETE_SECURE_APPLICATION: String = "/api/{version}/secure/application/delete"
        const val PATH_DELETE_SERVICE_HUB: String = "/api/{version}/hub/{id}"
        const val PATH_DELETE_SHIPMENT: String = "/api/{version}/shipment/{id}"
        const val PATH_DELETE_SHIPMENT_BATCH: String = "/api/{version}/shipment/batch/{batchId}"
        const val PATH_DELETE_SPACE: String = "/api/{version}/vatom/b/spaces/delete"
        const val PATH_DELETE_SUBSCRIPTION: String = "/api/{version}/subscription/delete"
        const val PATH_DELETE_TASK: String = "/api/{version}/task/delete"
        const val PATH_DELETE_TERRITORY: String = "/api/{version}/territory/delete"
        const val PATH_DELETE_TOURNAMENT: String = "/api/{version}/tournament/delete"
        const val PATH_DELETE_TRIGGER: String = "/api/{version}/trigger/delete"
        const val PATH_DELETE_VATOM_EVENT: String = "/api/{version}/vatom/b/events/delete"
        const val PATH_DELETE_VATOM_NFT: String = "/api/{version}/vatom/vatoms/delete"
        const val PATH_DELETE_VEHICLE: String = "/api/{version}/vehicle/{id}"
        const val PATH_DELETE_VEHICLE_TYPE: String = "/api/{version}/vehicle/type/{vehicleTypeId}"
        const val PATH_DELETE_WORD: String = "/api/{version}/game/word/delete"
        const val PATH_DISAPPROVE_ROUTE: String = "/api/{version}/route/{routeId}/disapprove"
        const val PATH_DRIVE_TRIP: String = "/api/{version}/trip/{id}/drive"
        const val PATH_DUPLICATE_CATEGORY: String = "/api/{version}/category/duplicate"
        const val PATH_EDIT_ACCOUNT: String = "/api/{version}/account/profile/update"
        const val PATH_EDIT_USERNAME: String = "/api/{version}/account/username/update"
        const val PATH_EMOTION: String = "/api/{version}/orson/ai/emotion"
        const val PATH_EVENT_INVITE: String = "/api/{version}/invite/event"
        const val PATH_EXECUTE_ACTION_ON_NFT: String = "/api/{version}/vatom/vatoms/execute-action"
        const val PATH_FILTERED_USAGE: String = "/api/{version}/analytics/filteredUsage"
        const val PATH_FIND_MISSIONS: String = "/api/{version}/mission/find"
        const val PATH_FLEXIBLE_TRIP: String = "/api/{version}/trip/{id}/flexible"
        const val PATH_FOLLOW_ACCEPT: String = "/api/{version}/consumer/follow/accept"
        const val PATH_FOLLOW_REJECT: String = "/api/{version}/consumer/follow/reject"
        const val PATH_FOLLOW_REMOVE: String = "/api/{version}/consumer/follow/remove"
        const val PATH_FOLLOW_REQUEST: String = "/api/{version}/consumer/follow/request"
        const val PATH_FRIEND_ACCEPT: String = "/api/{version}/consumer/friend/accept"
        const val PATH_FRIEND_REJECT: String = "/api/{version}/consumer/friend/reject"
        const val PATH_FRIEND_REMOVE: String = "/api/{version}/consumer/friend/remove"
        const val PATH_FRIEND_REQUEST: String = "/api/{version}/consumer/friend/request"
        const val PATH_GAME_INVITE: String = "/api/{version}/invite/gameLevel"
        const val PATH_GEOMAP_SEARCH: String = "/api/{version}/vatom/vatoms/geo-map/search"
        const val PATH_GET_ACCOUNT: String = "/api/{version}/account/profile/get"
        const val PATH_GET_ACHIEVEMENT: String = "/api/{version}/achievement/get"
        const val PATH_GET_ACHIEVEMENT_TIER: String = "/api/{version}/achievement/tier/get"
        const val PATH_GET_ADD_MOVIE_RESULT: String = "/api/{version}/orson/ai/addMovie/{requestId}"
        const val PATH_GET_AGE_GROUPS: String = "/api/{version}/audience/ageGroups"
        const val PATH_GET_ALBUM_COLLECTION: String = "/api/{version}/album/get"
        const val PATH_GET_ALBUM_CONTEST: String = "/api/{version}/consumer/album/contest/get"
        const val PATH_GET_ALBUM_CONTESTS: String = "/api/{version}/consumer/album/contest/search"
        const val PATH_GET_APP_DATA: String = "/api/{version}/app/get"
        const val PATH_GET_APPLICATION: String = "/api/{version}/application/get"
        const val PATH_GET_APPLICATION_CONFIG: String = "/api/{version}/appconfig/get"
        const val PATH_GET_APPLICATION_CONFIG_BY_CONFIG_VERSION: String = "/api/{version}/appconfig/getbyversion"
        const val PATH_GET_APPLICATION_PLACEMENT: String = "/api/{version}/application/placement/get"
        const val PATH_GET_APPLICATION_VERSIONS: String = "/api/{version}/application/versions"
        const val PATH_GET_ASSET: String = "/api/{version}/asset/get"
        const val PATH_GET_AUDIENCE: String = "/api/{version}/audience/get"
        const val PATH_GET_AUDIENCE_LIST: String = "/api/{version}/audience/search"
        const val PATH_GET_BATCH: String = "/api/{version}/orson/ai/batch/{requestId}"
        const val PATH_GET_BID: String = "/api/{version}/bid/get"
        const val PATH_GET_BILLABLE_ENTITY: String = "/api/{version}/billable/get"
        const val PATH_GET_BUSINESS_BEHAVIORS: String = "/api/{version}/vatom/b/behaviors"
        const val PATH_GET_BUSINESS_COINS_BALANCE: String = "/api/{version}/vatom/b/coins/get"
        const val PATH_GET_BUSINESS_IDS: String = "/api/{version}/vatom/me/businesses"
        const val PATH_GET_BUSINESS_INFO: String = "/api/{version}/vatom/b/get"
        const val PATH_GET_BUSINESS_USERS: String = "/api/{version}/vatom/b/users"
        const val PATH_GET_CAMPAIGN_GROUP_ENTITIES: String = "/api/{version}/vatom/b/campaign-groups/entities"
        const val PATH_GET_CAMPAIGN_GROUP_RULES: String = "/api/{version}/vatom/b/campaign-groups/rules"
        const val PATH_GET_CAMPAIGN_GROUP_STATS: String = "/api/{version}/vatom/b/campaign-groups/stats"
        const val PATH_GET_CAMPAIGN_INFO: String = "/api/{version}/vatom/b/campaign-groups/get"
        const val PATH_GET_CARGO_TYPE: String = "/api/{version}/cargo/type/{cargoTypeId}"
        const val PATH_GET_CATEGORY: String = "/api/{version}/category/get"
        const val PATH_GET_CONNECTION_SENT_FRIEND_REQUESTS: String = "/api/{version}/consumer/connection/getRequested"
        const val PATH_GET_CONNECTIONS: String = "/api/{version}/consumer/connection/get"
        const val PATH_GET_CREATIVE: String = "/api/{version}/creative/get"
        const val PATH_GET_CREATIVES_BY_APPLICATION: String = "/api/{version}/creative/search"
        const val PATH_GET_CREDENTIAL: String = "/api/{version}/thirdparty/credential/get"
        const val PATH_GET_CRYPTO_BALANCE: String = "/api/{version}/billing/crypto/get"
        const val PATH_GET_DATA: String = "/api/{version}/object/data/{objectName}/{objectId}"
        const val PATH_GET_DEPENDENTS: String = "/api/{version}/cargo/dependent/{accountId}"
        const val PATH_GET_DEVICES: String = "/api/{version}/audience/devices"
        const val PATH_GET_DISBURSEMENT: String = "/api/{version}/disbursement/get"
        const val PATH_GET_EMOTION: String = "/api/{version}/orson/ai/emotion/{requestId}"
        const val PATH_GET_EMPLOYEE: String = "/api/{version}/employee/get"
        const val PATH_GET_EPISODE_STATUS: String = "/api/{version}/orson/stories/episodes/{episodeId}/status"
        const val PATH_GET_EVENT: String = "/api/{version}/event/get"
        const val PATH_GET_EVENT_GUEST_LIST: String = "/api/{version}/vatom/b/events/guests/get"
        const val PATH_GET_EXPERIENCES: String = "/api/{version}/audience/experiences"
        const val PATH_GET_FAVORITE: String = "/api/{version}/favorite/get"
        const val PATH_GET_FILTER: String = "/api/{version}/filter/get"
        const val PATH_GET_FLAG: String = "/api/{version}/flag/get"
        const val PATH_GET_FLAG_THRESHOLD: String = "/api/{version}/flag/threshold/get"
        const val PATH_GET_GAME: String = "/api/{version}/game/get"
        const val PATH_GET_GAME_LEVEL: String = "/api/{version}/level/get"
        const val PATH_GET_GAME_LEVELS_BY_APPLICATION: String = "/api/{version}/level/search"
        const val PATH_GET_GAME_LEVELS_BY_BILLABLE_ENTITY: String = "/api/{version}/level/searchByBillableEntity"
        const val PATH_GET_GROUP_DETAILS: String = "/api/{version}/consumer/connection/group/details/get"
        const val PATH_GET_GROUPED_AUDIENCES: String = "/api/{version}/audience/grouped/get"
        const val PATH_GET_HISTORICAL_RANKINGS: String = "/api/{version}/ranking/historical/search"
        const val PATH_GET_INVENTORY: String = "/api/{version}/vatom/me/inventory"
        const val PATH_GET_INVITE: String = "/api/{version}/invite/get"
        const val PATH_GET_LEADERBOARD: String = "/api/{version}/leaderboard/get"
        const val PATH_GET_LISTING: String = "/api/{version}/listing/get"
        const val PATH_GET_LOCATION_BY_IP: String = "/api/{version}/location/ip"
        const val PATH_GET_LOCATION_BY_TRILATERATION: String = "/api/{version}/account/location/trilaterate"
        const val PATH_GET_LOCATIONS: String = "/api/{version}/location/search"
        const val PATH_GET_MEDIA: String = "/api/{version}/media/get"
        const val PATH_GET_MISSION: String = "/api/{version}/mission/get"
        const val PATH_GET_MISSION_INVITE: String = "/api/{version}/mission/invite/get"
        const val PATH_GET_MY_FOLLOWING: String = "/api/{version}/vatom/me/rels/following"
        const val PATH_GET_NETWORK: String = "/api/{version}/thirdparty/network/get"
        const val PATH_GET_NOTE: String = "/api/{version}/note/get"
        const val PATH_GET_NOTIFICATION_TEMPLATE: String = "/api/{version}/notification/template/get"
        const val PATH_GET_NOTIFICATIONS: String = "/api/{version}/notification/search"
        const val PATH_GET_OBJECT: String = "/api/{version}/object/get"
        const val PATH_GET_OFFER: String = "/api/{version}/retailer/offer/get"
        const val PATH_GET_OFFER_DETAILS: String = "/api/{version}/offer/get"
        const val PATH_GET_OFFER_LIST_COUNTS: String = "/api/{version}/offer/lists/count"
        const val PATH_GET_OFFER_LOCATION: String = "/api/{version}/offer/location/get"
        const val PATH_GET_OFFER_LOCATIONS_FOR_RETAILERS: String = "/api/{version}/retailer/offer/location/search"
        const val PATH_GET_OFFER_TRANSACTION: String = "/api/{version}/wallet/get"
        const val PATH_GET_OFFER_TRANSACTION_STATUS: String = "/api/{version}/offer/status/get"
        const val PATH_GET_OFFERS_FOR_RETAILERS: String = "/api/{version}/retailer/offer/search"
        const val PATH_GET_OPTIMIZATION_RESULT: String = "/api/{version}/optimize/result/{batchID}"
        const val PATH_GET_ORDER: String = "/api/{version}/order/get"
        const val PATH_GET_PACK: String = "/api/{version}/pack/get"
        const val PATH_GET_PAYMENT_METHOD: String = "/api/{version}/billing/get"
        const val PATH_GET_PERSONA_LIST: String = "/api/{version}/persona/get"
        const val PATH_GET_POINTS_BALANCE: String = "/api/{version}/vatom/u/campaign/points/get"
        const val PATH_GET_POINTS_BALANCE_AS_BUSINESS: String = "/api/{version}/vatom/b/campaign/u/points/get"
        const val PATH_GET_POSTAL_CODE: String = "/api/{version}/postalCode/get"
        const val PATH_GET_POSTAL_CODES: String = "/api/{version}/postalCode/search"
        const val PATH_GET_PREDICTED_LOCATIONS: String = "/api/{version}/tracking/predicted/get"
        const val PATH_GET_PREDICTED_PATH: String = "/api/{version}/tracking/path/get"
        const val PATH_GET_PREFERRED_LOCATIONS: String = "/api/{version}/tracking/preferred/search"
        const val PATH_GET_PROFILE_ASSETS: String = "/api/{version}/account/profile/assets"
        const val PATH_GET_PROGRAM: String = "/api/{version}/program/{id}"
        const val PATH_GET_PURCHASE_ITEM: String = "/api/{version}/purchase/get"
        const val PATH_GET_QUESTION: String = "/api/{version}/game/question/get"
        const val PATH_GET_QUESTIONS_IN_LEVEL: String = "/api/{version}/level/questions/get"
        const val PATH_GET_RANKINGS: String = "/api/{version}/ranking/search"
        const val PATH_GET_REFERRAL_LIST: String = "/api/{version}/account/referral/list"
        const val PATH_GET_REGION: String = "/api/{version}/region/get"
        const val PATH_GET_RENDER_STATUS: String = "/api/{version}/orson/stories/renders/{renderId}/status"
        const val PATH_GET_REPORT_BATCH: String = "/api/{version}/report/batch/get"
        const val PATH_GET_RETAILER: String = "/api/{version}/retailer/get"
        const val PATH_GET_RETAILER_LOCATION: String = "/api/{version}/retailer/location/get"
        const val PATH_GET_RETAILER_LOCATION_CONSUMER: String = "/api/{version}/location/get"
        const val PATH_GET_RETAILERS: String = "/api/{version}/retailer/search"
        const val PATH_GET_RETAOKILER: String = "/api/{version}/retailer"
        const val PATH_GET_ROUTE: String = "/api/{version}/route/{routeId}"
        const val PATH_GET_ROUTE_DIRECTIONS: String = "/api/{version}/route/{routeId}/directions"
        const val PATH_GET_ROUTE_SETTINGS: String = "/api/{version}/route/setting/{routeSettingsId}"
        const val PATH_GET_ROUTE_SHIPMENTS: String = "/api/{version}/route/{routeId}/shipments"
        const val PATH_GET_ROUTE_STOP: String = "/api/{version}/route/{routeId}/stop/{stopId}"
        const val PATH_GET_ROUTE_STOPS: String = "/api/{version}/route/{routeId}/stops"
        const val PATH_GET_STT: String = "/api/{version}/orson/ai/stt/{requestId}"
        const val PATH_GET_SCHEDULED_NOTIFICATION: String = "/api/{version}/notification/schedule/get"
        const val PATH_GET_SCORE: String = "/api/{version}/score/get"
        const val PATH_GET_SERVICE_HUB: String = "/api/{version}/hub/{id}"
        const val PATH_GET_SETTINGS: String = "/api/{version}/account/settings/get"
        const val PATH_GET_SHIPMENT: String = "/api/{version}/shipment/{id}"
        const val PATH_GET_SHIPMENT_BATCH: String = "/api/{version}/shipment/batch/{batchId}"
        const val PATH_GET_SHIPMENT_BATCH_STATUS: String = "/api/{version}/shipment/batch/{batchId}/status"
        const val PATH_GET_SHIPMENTS_AT_STOP: String = "/api/{version}/route/{routeId}/stop/{stopId}/shipments"
        const val PATH_GET_SPACE: String = "/api/{version}/vatom/b/spaces/get"
        const val PATH_GET_STATUS_CSV: String = "/api/{version}/csvimport/batch/status/details"
        const val PATH_GET_STOP: String = "/api/{version}/stop/{id}"
        const val PATH_GET_SUBSCRIPTION: String = "/api/{version}/subscription/get"
        const val PATH_GET_SUBSCRIPTION_PLAN: String = "/api/{version}/subscription/plan/get"
        const val PATH_GET_SUBSCRIPTION_PLANS: String = "/api/{version}/subscription/plan/list"
        const val PATH_GET_SUBSCRIPTION_USAGE: String = "/api/{version}/subscription/usage/get"
        const val PATH_GET_TTS: String = "/api/{version}/orson/ai/tts/{requestId}"
        const val PATH_GET_TASK: String = "/api/{version}/task/get"
        const val PATH_GET_TECH_TUNE: String = "/api/{version}/orson/ai/techTune/{requestId}"
        const val PATH_GET_TERRITORY: String = "/api/{version}/territory/get"
        const val PATH_GET_THEME_DESCRIPTOR: String = "/api/{version}/consumer/theme/get"
        const val PATH_GET_THEME_DESCRIPTORS: String = "/api/{version}/consumer/theme/search"
        const val PATH_GET_TICKET_COUNT: String = "/api/{version}/ticket/count"
        const val PATH_GET_TICKET_LIST: String = "/api/{version}/ticket/getList"
        const val PATH_GET_TOKEN: String = "/api/{version}/facebook/getfbtoken"
        const val PATH_GET_TOPICS: String = "/api/{version}/orson/ai/topics/{requestId}"
        const val PATH_GET_TOURNAMENT: String = "/api/{version}/tournament/get"
        const val PATH_GET_TRACKING_LEGS: String = "/api/{version}/tracking/search"
        const val PATH_GET_TRIGGER: String = "/api/{version}/trigger/get"
        const val PATH_GET_TRIP: String = "/api/{version}/trip/{id}"
        const val PATH_GET_TRIP_MATCHES: String = "/api/{version}/trip/{id}/match"
        const val PATH_GET_UNIQUE_USERS_BY_APP: String = "/api/{version}/application/users"
        const val PATH_GET_USER_ACHIEVEMENTS: String = "/api/{version}/achievement/progress/get"
        const val PATH_GET_USER_COINS_AS_BUSINESS: String = "/api/{version}/vatom/b/users/coins/get"
        const val PATH_GET_USER_COINS_BALANCE: String = "/api/{version}/vatom/u/coins/get"
        const val PATH_GET_USER_FOLLOWERS: String = "/api/{version}/vatom/users/rels/followers"
        const val PATH_GET_USER_FOLLOWING: String = "/api/{version}/vatom/users/rels/following"
        const val PATH_GET_USER_INFO: String = "/api/{version}/vatom/user/get"
        const val PATH_GET_USER_PROFILE: String = "/api/{version}/vatom/me/get"
        const val PATH_GET_USER_RANK: String = "/api/{version}/ranking/personal/ranks"
        const val PATH_GET_VATOM_EVENT: String = "/api/{version}/vatom/b/events/get"
        const val PATH_GET_VATOM_NFT: String = "/api/{version}/vatom/vatoms/get"
        const val PATH_GET_VEHICLE: String = "/api/{version}/vehicle/{id}"
        const val PATH_GET_VEHICLE_TYPE: String = "/api/{version}/vehicle/type/{vehicleTypeId}"
        const val PATH_GET_VOICE_CANVAS: String = "/api/{version}/orson/ai/voiceCanvas/{requestId}"
        const val PATH_GET_WORD: String = "/api/{version}/game/word/get"
        const val PATH_GET_WORDS: String = "/api/{version}/game/word/search"
        const val PATH_GET_WORDS_IN_LEVEL: String = "/api/{version}/level/words/get"
        const val PATH_GIFT_PURCHASE: String = "/api/{version}/purchase/gift"
        const val PATH_GRAPH_INTERFACE: String = "/api/{version}/facebook/graph"
        const val PATH_GROUP_SEARCH: String = "/api/{version}/connection/group/search"
        const val PATH_IMAGE_GENERATION: String = "/api/{version}/openai/v1/images/generations"
        const val PATH_IMPORT_MISSION: String = "/api/{version}/mission/import"
        const val PATH_INDEXED_RETAILER_LOCATION_DISTANCE_SEARCH: String = "/api/{version}/retailer/location/idistancesearch"
        const val PATH_INDEXED_RETAILER_LOCATION_SEARCH: String = "/api/{version}/retailer/location/isearch"
        const val PATH_LEAVE_ALBUM: String = "/api/{version}/album/user/leave"
        const val PATH_LEAVE_FROM_PERMISSIONABLE: String = "/api/{version}/consumer/permissions/leave"
        const val PATH_LIST_ACHIEVEMENT_TAGS: String = "/api/{version}/achievement/tag/list"
        const val PATH_LIST_ACHIEVEMENTS: String = "/api/{version}/achievement/list"
        const val PATH_LIST_APPLICATIONS: String = "/api/{version}/application/list"
        const val PATH_LIST_BY_ACCOUNT: String = "/api/{version}/audience/suggestion/list"
        const val PATH_LIST_BY_AUDIENCE: String = "/api/{version}/audience/suggestion/offersByAudience"
        const val PATH_LIST_COMMUNITIES: String = "/api/{version}/vatom/b/communities/search"
        const val PATH_LIST_EVENTS: String = "/api/{version}/vatom/b/events/search"
        const val PATH_LIST_LASTEST_BY_ACCOUNT: String = "/api/{version}/audience/suggestion/latest"
        const val PATH_LIST_SPACES: String = "/api/{version}/vatom/b/spaces/search"
        const val PATH_LIST_STATUS_CSV: String = "/api/{version}/csvimport/batch/list"
        const val PATH_LIST_USER_COIN_TRANSACTIONS: String = "/api/{version}/vatom/u/coins/txns/search"
        const val PATH_LIST_USER_COIN_TRANSACTIONS_AS_BUSINESS: String = "/api/{version}/vatom/b/users/coins/txns/search"
        const val PATH_LOGIN_DELEGATE: String = "/api/{version}/account/login/delegate"
        const val PATH_LOGIN_GENERAL: String = "/api/{version}/account/login"
        const val PATH_LOGIN_SECURE: String = "/api/{version}/secure/login"
        const val PATH_LOGIN_TWITTER: String = "/api/{version}/twitter/login"
        const val PATH_LOGIN_USERNAME: String = "/api/{version}/account/get"
        const val PATH_LOGOUT: String = "/api/{version}/account/logout"
        const val PATH_MERGE_ACCOUNT: String = "/api/{version}/account/merge"
        const val PATH_MISSION_INVITE: String = "/api/{version}/invite/mission"
        const val PATH_OFFER_INVITE: String = "/api/{version}/invite/offer"
        const val PATH_OFFER_LOCATION_INVITE: String = "/api/{version}/invite/offerLocation"
        const val PATH_OPTIMIZE_ROUTE: String = "/api/{version}/route/{routeId}/optimize"
        const val PATH_OVERRIDE_USER_RANK: String = "/api/{version}/ranking/override"
        const val PATH_PASSWORD_CHANGE: String = "/api/{version}/account/passwordchange"
        const val PATH_PASSWORD_RESET: String = "/api/{version}/account/passwordreset"
        const val PATH_PERFORM_ACTION_ON_NFT: String = "/api/{version}/vatom/me/vatoms/actions"
        const val PATH_POST_APP_DATA: String = "/api/{version}/app/post"
        const val PATH_POST_PROGRAM: String = "/api/{version}/program/{id}"
        const val PATH_POST_SERVICE_HUB: String = "/api/{version}/hub/{id}"
        const val PATH_PREVIEW_OFFER_TRANSACTION: String = "/api/{version}/wallet/preview"
        const val PATH_PREVIEW_ORDER: String = "/api/{version}/order/preview"
        const val PATH_PROCESS_ALL_PARTICIPANTS: String = "/api/{version}/participant/process/all"
        const val PATH_PROCESS_PARTICIPANTS: String = "/api/{version}/participant/process"
        const val PATH_PROCESS_TRIP_MATCHES: String = "/api/{version}/trip/match/process"
        const val PATH_PURCHASE_SECURE: String = "/api/{version}/secure/purchase"
        const val PATH_PUT_PROGRAM: String = "/api/{version}/program/{id}"
        const val PATH_PUT_SERVICE_HUB: String = "/api/{version}/hub/{id}"
        const val PATH_QUEUE_CREATE: String = "/api/{version}/queue/create"
        const val PATH_QUEUE_DELETE: String = "/api/{version}/queue/delete"
        const val PATH_QUEUE_GET: String = "/api/{version}/queue/get"
        const val PATH_QUEUE_PUBLISH: String = "/api/{version}/queue/publish"
        const val PATH_QUEUE_SEARCH: String = "/api/{version}/queue/search"
        const val PATH_QUEUE_UPDATE: String = "/api/{version}/queue/update"
        const val PATH_REDEEM_NFT: String = "/api/{version}/vatom/b/redemptions"
        const val PATH_REDEEM_OFFER_TRANSACTION: String = "/api/{version}/retailer/offer/transaction/update"
        const val PATH_REDEEM_USER_COINS_AS_BUSINESS: String = "/api/{version}/vatom/b/users/coins/redeem"
        const val PATH_REGEN_APP_DATA: String = "/api/{version}/app/regen"
        const val PATH_REGISTER_LIKE: String = "/api/{version}/like"
        const val PATH_REGISTER_NOTIFICATION_TOKEN: String = "/api/{version}/notification/token"
        const val PATH_REMOVE_ALBUM: String = "/api/{version}/album/delete"
        const val PATH_REMOVE_ALBUM_USERS: String = "/api/{version}/album/user/delete"
        const val PATH_REMOVE_ASSET: String = "/api/{version}/asset/remove"
        const val PATH_REMOVE_CONNECTION_FROM_GROUP: String = "/api/{version}/consumer/connection/group/removeConnection"
        const val PATH_REMOVE_CONNECTIONS_FROM_GROUP: String = "/api/{version}/connection/group/removeConnections"
        const val PATH_REMOVE_DEPENDENT: String = "/api/{version}/cargo/dependent/{accountId}"
        const val PATH_REMOVE_GROUP: String = "/api/{version}/consumer/connection/group/remove"
        const val PATH_REMOVE_LIKE: String = "/api/{version}/like/delete"
        const val PATH_REMOVE_PREVIEW: String = "/api/{version}/creative/removepreview"
        const val PATH_REMOVE_STOP: String = "/api/{version}/route/{routeId}/stop/{stopId}"
        const val PATH_REMOVE_SUB_GROUPS: String = "/api/{version}/consumer/connection/group/removeSubGroup"
        const val PATH_REMOVE_THEME_DESCRIPTOR: String = "/api/{version}/consumer/theme/remove"
        const val PATH_REMOVE_USERS_FROM_PERMISSIONABLE: String = "/api/{version}/consumer/permissions/remove"
        const val PATH_REORDER_ROUTE_STOPS_PATCH: String = "/api/{version}/route/{routeId}/stops/reorder"
        const val PATH_REORDER_ROUTE_STOPS_POST: String = "/api/{version}/route/{routeId}/stops/reorder"
        const val PATH_REQUEST_OPTIMIZATION: String = "/api/{version}/optimize/request"
        const val PATH_REQUEST_PASSWORD_RESET: String = "/api/{version}/account/requestpasswordreset"
        const val PATH_REQUEST_VALIDATE_ACCOUNT: String = "/api/{version}/account/requestValidateAccount"
        const val PATH_RESERVABLE_AVAILABILITY: String = "/api/{version}/reservable/availability/update"
        const val PATH_RESET_SECURE: String = "/api/{version}/secure/application/reset"
        const val PATH_RETAILER_LOCATION_INVITE: String = "/api/{version}/invite/retailerLocation"
        const val PATH_RETAILER_LOGIN_CHECK: String = "/api/{version}/retailer/login"
        const val PATH_RIDE: String = "/api/{version}/trip/{id}/ride"
        const val PATH_RUN_REPORT: String = "/api/{version}/report/run"
        const val PATH_RUN_WORKFLOW: String = "/api/{version}/workflow/run"
        const val PATH_SAVE_TICKET: String = "/api/{version}/ticket/save"
        const val PATH_SAVE_TICKET_VIA_FILE_UPLOAD: String = "/api/{version}/ticket/save/fileUpload"
        const val PATH_SAVE_TRACKING_LEG: String = "/api/{version}/tracking/leg/create"
        const val PATH_SAVE_TRACKING_STEP: String = "/api/{version}/tracking/step/create"
        const val PATH_SCHEDULE_NOTIFICATION_LISTINGS: String = "/api/{version}/notification/schedule/generate"
        const val PATH_SEARCH: String = "/api/{version}/trip"
        const val PATH_SEARCH_ACCOUNTS: String = "/api/{version}/account/profile/search"
        const val PATH_SEARCH_ACCOUNTS_WITH_TRACKING_LEGS: String = "/api/{version}/tracking/list"
        const val PATH_SEARCH_ACHIEVEMENTS: String = "/api/{version}/achievement/search"
        const val PATH_SEARCH_ALBUMS: String = "/api/{version}/album/search"
        const val PATH_SEARCH_APPLICATION_CONFIG: String = "/api/{version}/appconfig/search"
        const val PATH_SEARCH_APPLICATION_PLACEMENT: String = "/api/{version}/application/placement/search"
        const val PATH_SEARCH_APPLICATION_SETTINGS: String = "/api/{version}/application/settings/search"
        const val PATH_SEARCH_APPLICATIONS: String = "/api/{version}/application/search"
        const val PATH_SEARCH_ASSETS: String = "/api/{version}/asset/search"
        const val PATH_SEARCH_AVAILABILITY: String = "/api/{version}/reservable/availability/search"
        const val PATH_SEARCH_BATCH: String = "/api/{version}/report/batch/search"
        const val PATH_SEARCH_BLOCKED_NOTIFICATIONS: String = "/api/{version}/notification/blocked/search"
        const val PATH_SEARCH_BUSINESSES: String = "/api/{version}/vatom/b/search"
        const val PATH_SEARCH_CAMPAIGN_GROUPS: String = "/api/{version}/vatom/b/campaign-groups/search"
        const val PATH_SEARCH_CARGO_TYPES: String = "/api/{version}/cargo/type"
        const val PATH_SEARCH_CARRIERS: String = "/api/{version}/carrier/search"
        const val PATH_SEARCH_CATEGORIES: String = "/api/{version}/category/search"
        const val PATH_SEARCH_CONNECTIONS: String = "/api/{version}/connection/search"
        const val PATH_SEARCH_CREDENTIALS: String = "/api/{version}/thirdparty/credential/search"
        const val PATH_SEARCH_DATA: String = "/api/{version}/object/data/{objectName}"
        const val PATH_SEARCH_DISBURSEMENTS: String = "/api/{version}/disbursement/search"
        const val PATH_SEARCH_EMPLOYEES: String = "/api/{version}/employee/search"
        const val PATH_SEARCH_EVENT_TRANSACTIONS: String = "/api/{version}/event/attendance/search"
        const val PATH_SEARCH_EVENTS: String = "/api/{version}/event/search"
        const val PATH_SEARCH_FAVORITES: String = "/api/{version}/favorite/search"
        const val PATH_SEARCH_FILTERS: String = "/api/{version}/filter/search"
        const val PATH_SEARCH_GAMES: String = "/api/{version}/game/search"
        const val PATH_SEARCH_IDENTITIES: String = "/api/{version}/vatom/me/identities/search"
        const val PATH_SEARCH_INVENTORY: String = "/api/{version}/vatom/user-inventory/search"
        const val PATH_SEARCH_LEADERBOARDS: String = "/api/{version}/leaderboard/search"
        const val PATH_SEARCH_LIKES: String = "/api/{version}/like/search"
        const val PATH_SEARCH_LISTING: String = "/api/{version}/listing/search"
        const val PATH_SEARCH_LOCATION_RATING_INDEXES: String = "/api/{version}/location/rating/index/search"
        const val PATH_SEARCH_MEDIA: String = "/api/{version}/media/search"
        const val PATH_SEARCH_MISSION_FORMATS: String = "/api/{version}/mission/format/search"
        const val PATH_SEARCH_MISSION_INVITES: String = "/api/{version}/mission/invite/search"
        const val PATH_SEARCH_MISSIONS: String = "/api/{version}/mission/search"
        const val PATH_SEARCH_MISSIONS_BY_BILLABLE_ENTITY: String = "/api/{version}/mission/searchByBillableEntity"
        const val PATH_SEARCH_NETWORKS: String = "/api/{version}/thirdparty/network/search"
        const val PATH_SEARCH_NOTES: String = "/api/{version}/note/search"
        const val PATH_SEARCH_NOTIFICATION_TEMPLATE: String = "/api/{version}/notification/template/search"
        const val PATH_SEARCH_OBJECT: String = "/api/{version}/object/search"
        const val PATH_SEARCH_OBJECTS: String = "/api/{version}/tournament/object/search"
        const val PATH_SEARCH_OFFER_TRANSACTION_STATUSES: String = "/api/{version}/offer/status/search"
        const val PATH_SEARCH_OFFER_TRANSACTIONS: String = "/api/{version}/wallet/search"
        const val PATH_SEARCH_OFFER_TRANSACTIONS_FOR_RETAILERS: String = "/api/{version}/retailer/offer/transaction/search"
        const val PATH_SEARCH_OFFERS_FOR_CONSUMER: String = "/api/{version}/offer/lists"
        const val PATH_SEARCH_ORDERS: String = "/api/{version}/order/search"
        const val PATH_SEARCH_PACKS: String = "/api/{version}/pack/search"
        const val PATH_SEARCH_PAYMENT_METHOD: String = "/api/{version}/billing/search"
        const val PATH_SEARCH_PERMISSIONABLES: String = "/api/{version}/permissions/search"
        const val PATH_SEARCH_PERMISSIONABLES_FOLLOWING_DISTANCE: String = "/api/{version}/permissions/distancesearch"
        const val PATH_SEARCH_PERSONA: String = "/api/{version}/persona/search"
        const val PATH_SEARCH_PROGRAMS: String = "/api/{version}/program"
        const val PATH_SEARCH_PURCHASE_ITEMS: String = "/api/{version}/purchase/search"
        const val PATH_SEARCH_QUESTIONS: String = "/api/{version}/game/question/search"
        const val PATH_SEARCH_RATING_INDEXES: String = "/api/{version}/rating/index/search"
        const val PATH_SEARCH_RATINGS: String = "/api/{version}/rating/search"
        const val PATH_SEARCH_RECIPIENTS: String = "/api/{version}/notification/recipient/search"
        const val PATH_SEARCH_RECIPIENTS_COUNT: String = "/api/{version}/notification/recipient/search/count"
        const val PATH_SEARCH_REGIONS: String = "/api/{version}/region/search"
        const val PATH_SEARCH_RESERVATIONS: String = "/api/{version}/reservation/search"
        const val PATH_SEARCH_RETAILER_LOCATIONS: String = "/api/{version}/retailer/location/search"
        const val PATH_SEARCH_ROUNDS: String = "/api/{version}/tournament/round/search"
        const val PATH_SEARCH_ROUTE_SETTINGS: String = "/api/{version}/route/setting"
        const val PATH_SEARCH_ROUTES: String = "/api/{version}/route"
        const val PATH_SEARCH_SCHEDULE: String = "/api/{version}/reservable/schedule/search"
        const val PATH_SEARCH_SCHEDULED_NOTIFICATIONS: String = "/api/{version}/notification/schedule/search"
        const val PATH_SEARCH_SCORES: String = "/api/{version}/score/search"
        const val PATH_SEARCH_SERVICE_HUBS: String = "/api/{version}/hub"
        const val PATH_SEARCH_SHIPMENT_BATCH: String = "/api/{version}/shipment/batch"
        const val PATH_SEARCH_SHIPMENTS: String = "/api/{version}/shipment"
        const val PATH_SEARCH_TASKS: String = "/api/{version}/task/search"
        const val PATH_SEARCH_TERRITORIES: String = "/api/{version}/territory/search"
        const val PATH_SEARCH_TOURNAMENTS: String = "/api/{version}/tournament/search"
        const val PATH_SEARCH_TRACKING_LEGS: String = "/api/{version}/tracking/searchByBillable"
        const val PATH_SEARCH_TRIGGERS: String = "/api/{version}/trigger/search"
        const val PATH_SEARCH_TRIPS: String = "/api/{version}/trip/match"
        const val PATH_SEARCH_VEHICLE: String = "/api/{version}/vehicle"
        const val PATH_SEARCH_VEHICLE_TYPES: String = "/api/{version}/vehicle/type"
        const val PATH_SEARCH_WEATHER: String = "/api/{version}/weather/search"
        const val PATH_SECURE_LOGIN: String = "/api/{version}/account/login/validate"
        const val PATH_SECURE_SIGNUP: String = "/api/{version}/account/create/validate"
        const val PATH_SEND_BATCH_NOTIFICATIONS: String = "/api/{version}/notification/batch"
        const val PATH_SEND_BY_ACCOUNT: String = "/api/{version}/audience/suggestion/send"
        const val PATH_SEND_CUSTOM_NOTIFICATIONS: String = "/api/{version}/notification/custom"
        const val PATH_SEND_MFA_CHALLENGE: String = "/api/{version}/thirdparty/credential/mfa/send"
        const val PATH_SEND_NFT: String = "/api/{version}/vatom/b/campaigns/send"
        const val PATH_SET_DRIVER: String = "/api/{version}/route/{id}/driver/{driverId}"
        const val PATH_SET_MATCH_TOKEN: String = "/api/{version}/consumer/profile/matchToken"
        const val PATH_SET_POINTS_BALANCE_AS_BUSINESS: String = "/api/{version}/vatom/b/campaign/u/points/update"
        const val PATH_SIMULATION: String = "/api/{version}/simulation/routing"
        const val PATH_SMS_BUY_OFFER: String = "/api/{version}/sms/buyoffer/{appKey}"
        const val PATH_START_VIDEO_RENDER: String = "/api/{version}/orson/stories/renders"
        const val PATH_STATUS_CSV: String = "/api/{version}/csvimport/batch/status"
        const val PATH_STT: String = "/api/{version}/orson/ai/stt"
        const val PATH_SUBMIT_TOURNAMENT_SCORE: String = "/api/{version}/tournament/score"
        const val PATH_SUBMIT_TOURNAMENT_VOTE: String = "/api/{version}/tournament/vote"
        const val PATH_SUBSTITUTE_TOURNAMENT_PLAYER: String = "/api/{version}/tournament/substitute"
        const val PATH_SUMMARIZE_TOPICS: String = "/api/{version}/orson/ai/topics"
        const val PATH_SUMMARY_LISTING: String = "/api/{version}/listing/summary"
        const val PATH_TECH_TUNE: String = "/api/{version}/orson/ai/techTune"
        const val PATH_TICKET_OFFERS: String = "/api/{version}/ticket/ticketoffers"
        const val PATH_TOP_OFFER_TRANSACTIONS: String = "/api/{version}/offer/top"
        const val PATH_TRANSFER_USER_COINS: String = "/api/{version}/vatom/u/coins/transfer"
        const val PATH_TTS: String = "/api/{version}/orson/ai/tts"
        const val PATH_UNASSIGN_EMPLOYEE: String = "/api/{version}/employee/unassign"
        const val PATH_UPDATE_ACHIEVEMENT: String = "/api/{version}/achievement/update"
        const val PATH_UPDATE_ACHIEVEMENT_TIER: String = "/api/{version}/achievement/tier/update"
        const val PATH_UPDATE_ACTVE_STATUS: String = "/api/{version}/account/active/update"
        const val PATH_UPDATE_ALBUM_COLLECTION: String = "/api/{version}/album/update"
        const val PATH_UPDATE_APPLICATION: String = "/api/{version}/application/update"
        const val PATH_UPDATE_APPLICATION_ACTIVE: String = "/api/{version}/application/active"
        const val PATH_UPDATE_APPLICATION_CONFIG: String = "/api/{version}/appconfig/update"
        const val PATH_UPDATE_APPLICATION_PLACEMENT: String = "/api/{version}/application/placement/update"
        const val PATH_UPDATE_ASSET: String = "/api/{version}/asset/update"
        const val PATH_UPDATE_AUDIENCE: String = "/api/{version}/audience/update"
        const val PATH_UPDATE_BID: String = "/api/{version}/bid/update"
        const val PATH_UPDATE_BILLABLE_ENTITY: String = "/api/{version}/billable/update"
        const val PATH_UPDATE_BUSINESS_COINS: String = "/api/{version}/vatom/b/coins/update"
        const val PATH_UPDATE_CARGO_TYPE: String = "/api/{version}/cargo/type/{cargoTypeId}"
        const val PATH_UPDATE_CATEGORY: String = "/api/{version}/category/update"
        const val PATH_UPDATE_CREATIVE: String = "/api/{version}/creative/update"
        const val PATH_UPDATE_CREDENTIAL: String = "/api/{version}/thirdparty/credential/update"
        const val PATH_UPDATE_DATA: String = "/api/{version}/object/data/{objectName}/{objectId}"
        const val PATH_UPDATE_DISBURSEMENT: String = "/api/{version}/disbursement/update"
        const val PATH_UPDATE_EMPLOYEE: String = "/api/{version}/employee/update"
        const val PATH_UPDATE_EVENT: String = "/api/{version}/event/update"
        const val PATH_UPDATE_EVENT_GUEST_LIST: String = "/api/{version}/vatom/b/events/guests/update"
        const val PATH_UPDATE_FILTER: String = "/api/{version}/filter/update"
        const val PATH_UPDATE_FLAG_THRESHOLD: String = "/api/{version}/flag/threshold/update"
        const val PATH_UPDATE_GAME: String = "/api/{version}/game/update"
        const val PATH_UPDATE_GAME_LEVEL: String = "/api/{version}/level/update"
        const val PATH_UPDATE_LEADERBOARD: String = "/api/{version}/leaderboard/update"
        const val PATH_UPDATE_LISTING: String = "/api/{version}/listing/update"
        const val PATH_UPDATE_LOCATION: String = "/api/{version}/account/location/update"
        const val PATH_UPDATE_LOCATION_V2: String = "/api/{version}/location/{id}"
        const val PATH_UPDATE_LOCATIONS: String = "/api/{version}/trip/{id}/locations"
        const val PATH_UPDATE_MEDIA: String = "/api/{version}/media/update"
        const val PATH_UPDATE_MISSION: String = "/api/{version}/mission/update"
        const val PATH_UPDATE_MISSION_INVITE: String = "/api/{version}/mission/invite/update"
        const val PATH_UPDATE_NETWORK: String = "/api/{version}/thirdparty/network/update"
        const val PATH_UPDATE_NOTE: String = "/api/{version}/note/update"
        const val PATH_UPDATE_NOTIFICATION_TEMPLATE: String = "/api/{version}/notification/template/update"
        const val PATH_UPDATE_OFFER: String = "/api/{version}/retailer/offer/update"
        const val PATH_UPDATE_OFFER_STATUS: String = "/api/{version}/retailer/offer/status"
        const val PATH_UPDATE_OFFER_TRANSACTION: String = "/api/{version}/wallet/update"
        const val PATH_UPDATE_OFFER_TRANSACTION_STATUS: String = "/api/{version}/offer/status/update"
        const val PATH_UPDATE_ORDER: String = "/api/{version}/order/update"
        const val PATH_UPDATE_PACK: String = "/api/{version}/pack/update"
        const val PATH_UPDATE_PERSONA: String = "/api/{version}/persona/update"
        const val PATH_UPDATE_POSTAL_CODE: String = "/api/{version}/postalCode/update"
        const val PATH_UPDATE_PURCHASE_ITEM: String = "/api/{version}/purchase/update"
        const val PATH_UPDATE_QUESTION: String = "/api/{version}/game/question/update"
        const val PATH_UPDATE_QUESTIONS_IN_LEVEL: String = "/api/{version}/level/questions/update"
        const val PATH_UPDATE_RANKINGS: String = "/api/{version}/ranking/update"
        const val PATH_UPDATE_RATING: String = "/api/{version}/rating/update"
        const val PATH_UPDATE_RECURRENCE_LOCATIONS: String = "/api/{version}/trip/{id}/locations/recurrence"
        const val PATH_UPDATE_RECURRENCE_SHIPMENTS: String = "/api/{version}/trip/{id}/shipments/recurrence"
        const val PATH_UPDATE_REGION: String = "/api/{version}/region/update"
        const val PATH_UPDATE_RETAILER: String = "/api/{version}/retailer/update"
        const val PATH_UPDATE_RETAILER_LOCATIONS: String = "/api/{version}/retailer/location/update"
        const val PATH_UPDATE_ROUTE: String = "/api/{version}/route/{routeId}"
        const val PATH_UPDATE_ROUTE_SETTINGS: String = "/api/{version}/route/setting/{routeSettingsId}"
        const val PATH_UPDATE_ROUTE_STOP: String = "/api/{version}/route/{routeId}/stop/{stopId}"
        const val PATH_UPDATE_SCHEDULED_NOTIFICATION: String = "/api/{version}/notification/schedule/update"
        const val PATH_UPDATE_SECURE_APPLICATION: String = "/api/{version}/secure/application/update"
        const val PATH_UPDATE_SETTINGS: String = "/api/{version}/account/settings/update"
        const val PATH_UPDATE_SHIPMENT: String = "/api/{version}/shipment/{id}"
        const val PATH_UPDATE_SHIPMENT_STATUS: String = "/api/{version}/shipment/{id}/status"
        const val PATH_UPDATE_SHIPMENTS: String = "/api/{version}/trip/{id}/shipments"
        const val PATH_UPDATE_SPACE: String = "/api/{version}/vatom/b/spaces/update"
        const val PATH_UPDATE_STOP: String = "/api/{version}/stop/{id}"
        const val PATH_UPDATE_SUBSCRIPTION: String = "/api/{version}/subscription/update"
        const val PATH_UPDATE_TASK: String = "/api/{version}/task/update"
        const val PATH_UPDATE_TERRITORY: String = "/api/{version}/territory/update"
        const val PATH_UPDATE_TOURNAMENT: String = "/api/{version}/tournament/update"
        const val PATH_UPDATE_TRIGGER: String = "/api/{version}/trigger/update"
        const val PATH_UPDATE_TRIP: String = "/api/{version}/trip/{id}"
        const val PATH_UPDATE_TRIP_NOTIFICATIONS: String = "/api/{version}/trip/notifications"
        const val PATH_UPDATE_USER_ACHIEVEMENT: String = "/api/{version}/achievement/progress/update"
        const val PATH_UPDATE_USER_COINS_AS_BUSINESS: String = "/api/{version}/vatom/b/users/coins/update"
        const val PATH_UPDATE_USER_PROFILE: String = "/api/{version}/vatom/me/update"
        const val PATH_UPDATE_VATOM_EVENT: String = "/api/{version}/vatom/b/events/update"
        const val PATH_UPDATE_VEHICLE: String = "/api/{version}/vehicle/{id}"
        const val PATH_UPDATE_VEHICLE_TYPE: String = "/api/{version}/vehicle/type/{vehicleTypeId}"
        const val PATH_UPDATE_WORD: String = "/api/{version}/game/word/update"
        const val PATH_UPDATE_WORDS_IN_LEVEL: String = "/api/{version}/level/words/update"
        const val PATH_UPLOAD_APPLICATION_CERTIFICATE: String = "/api/{version}/application/certificate/create"
        const val PATH_UPLOAD_CSV: String = "/api/{version}/csvimport/upload"
        const val PATH_USAGE: String = "/api/{version}/analytics/usage"
        const val PATH_USAGE_BATCH: String = "/api/{version}/analytics/usage/batch"
        const val PATH_VALIDATE_ACCOUNT_SIGNUP: String = "/api/{version}/account/validateAccountSignup"
        const val PATH_VALIDATE_PASSWORD_RESET: String = "/api/{version}/account/validatepasswordreset"
        const val PATH_VOTE_ON_ALBUM_CONTEST: String = "/api/{version}/consumer/album/contest/vote"
        const val PATH_WHO_HAS_FAVORITED: String = "/api/{version}/favorite/whois"
    }
}
