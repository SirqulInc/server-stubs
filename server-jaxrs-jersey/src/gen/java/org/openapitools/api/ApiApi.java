package org.openapitools.api;

import org.openapitools.api.ApiApiService;
import org.openapitools.api.factories.ApiApiServiceFactory;

import io.swagger.annotations.ApiParam;
import io.swagger.jaxrs.*;

import org.openapitools.model.Account;
import org.openapitools.model.AccountListResponse;
import org.openapitools.model.AccountLoginResponse;
import org.openapitools.model.AccountMiniResponse;
import org.openapitools.model.AccountResponse;
import org.openapitools.model.AchievementProgressResponse;
import org.openapitools.model.AchievementResponse;
import org.openapitools.model.AchievementShortResponse;
import org.openapitools.model.AchievementTierResponse;
import org.openapitools.model.ActivityResponse;
import org.openapitools.model.AgeGroupResponse;
import org.openapitools.model.AlbumContestListResponse;
import org.openapitools.model.AlbumContestResponse;
import org.openapitools.model.AlbumFullResponse;
import org.openapitools.model.AlbumResponse;
import org.openapitools.model.AppResponse;
import org.openapitools.model.ApplicationConfigResponse;
import org.openapitools.model.ApplicationResponse;
import org.openapitools.model.ApplicationSettingsResponse;
import org.openapitools.model.ApplicationShortResponse;
import org.openapitools.model.ApplicationUsageResponse;
import org.openapitools.model.AssetFullResponse;
import org.openapitools.model.AssetListResponse;
import org.openapitools.model.AssetResponse;
import org.openapitools.model.AssetShortResponse;
import org.openapitools.model.AssignmentResponse;
import org.openapitools.model.AssignmentStatusResponse;
import org.openapitools.model.AudienceDeviceResponse;
import org.openapitools.model.AudienceResponse;
import org.openapitools.model.AvailabilityResponse;
import org.openapitools.model.BidResponse;
import java.math.BigDecimal;
import org.openapitools.model.BillableEntityResponse;
import org.openapitools.model.BlockedNotificationResponse;
import org.openapitools.model.CargoType;
import org.openapitools.model.CategoryResponse;
import org.openapitools.model.CategoryTreeResponse;
import org.openapitools.model.CellCarrierResponse;
import org.openapitools.model.ChartData;
import org.openapitools.model.ConnectionGroupResponse;
import org.openapitools.model.ConnectionInfoResponse;
import org.openapitools.model.ConnectionListResponse;
import org.openapitools.model.ConnectionResponse;
import org.openapitools.model.ConsumerInviteResponse;
import org.openapitools.model.CoordsResponse;
import org.openapitools.model.CountResponse;
import org.openapitools.model.CreativeResponse;
import org.openapitools.model.CsvImportResponse;
import org.openapitools.model.Direction;
import org.openapitools.model.DisbursementResponse;
import org.openapitools.model.EmployeeResponse;
import org.openapitools.model.EntityReference;
import org.openapitools.model.EventAttendanceResponse;
import java.io.File;
import org.openapitools.model.FilterResponse;
import org.openapitools.model.FilterTreeResponse;
import org.openapitools.model.FlagResponse;
import org.openapitools.model.GameLevelListResponse;
import org.openapitools.model.GameLevelResponse;
import org.openapitools.model.GameResponse;
import org.openapitools.model.GeoPointResponse;
import org.openapitools.model.ImportStatuses;
import org.openapitools.model.InviteResponse;
import org.openapitools.model.LeaderboardResponse;
import org.openapitools.model.Leg;
import org.openapitools.model.LegResponse;
import org.openapitools.model.LikableResponse;
import org.openapitools.model.ListCountResponse;
import org.openapitools.model.ListingFullResponse;
import org.openapitools.model.ListingGroupResponse;
import org.openapitools.model.ListingResponse;
import org.openapitools.model.Location;
import org.openapitools.model.LocationSearchResponse;
import java.util.Map;
import org.openapitools.model.MediaOfferResponse;
import org.openapitools.model.MissionFormatResponse;
import org.openapitools.model.MissionResponse;
import org.openapitools.model.MissionShortResponse;
import org.openapitools.model.NoteResponse;
import org.openapitools.model.NotificationMessageListResponse;
import org.openapitools.model.NotificationRecipientResponse;
import org.openapitools.model.NotificationRecipientResponseListResponse;
import org.openapitools.model.NotificationTemplateResponse;
import org.openapitools.model.ObjectStoreResponse;
import org.openapitools.model.OfferListResponse;
import org.openapitools.model.OfferResponse;
import org.openapitools.model.OfferShortResponse;
import org.openapitools.model.OfferTransactionResponse;
import org.openapitools.model.OfferTransactionStatusResponse;
import org.openapitools.model.OrderResponse;
import org.openapitools.model.Orders;
import org.openapitools.model.OrsonAiAddMovieResponse;
import org.openapitools.model.OrsonAiBatchResponse;
import org.openapitools.model.OrsonAiEmotionsResponse;
import org.openapitools.model.OrsonAiProtoResponse;
import org.openapitools.model.OrsonAiSTTResponse;
import org.openapitools.model.OrsonAiTTSResponse;
import org.openapitools.model.OrsonAiTechTuneResponse;
import org.openapitools.model.OrsonAiTopicsResponse;
import org.openapitools.model.OrsonAiVoiceCanvasResponse;
import org.openapitools.model.OrsonEpisodeResponse;
import org.openapitools.model.OrsonRenderResponse;
import org.openapitools.model.PackResponse;
import org.openapitools.model.PathingResponse;
import org.openapitools.model.PaymentRequest;
import org.openapitools.model.PaymentTypesResponse;
import org.openapitools.model.PlacementResponse;
import org.openapitools.model.PostalCodeResponse;
import org.openapitools.model.PredictedLocationResponse;
import org.openapitools.model.PreferredLocationResponse;
import org.openapitools.model.PreviewPersonaResponse;
import org.openapitools.model.ProfileInfoResponse;
import org.openapitools.model.ProfileResponse;
import org.openapitools.model.Program;
import org.openapitools.model.PurchaseItemFullResponse;
import org.openapitools.model.PurchaseItemListResponse;
import org.openapitools.model.PurchaseItemResponse;
import org.openapitools.model.QuestionResponse;
import org.openapitools.model.QueueResponse;
import org.openapitools.model.RankFullResponse;
import org.openapitools.model.RatingIndexResponse;
import org.openapitools.model.RatingResponse;
import org.openapitools.model.RegionLegSummary;
import org.openapitools.model.RegionResponse;
import org.openapitools.model.ReportBatchResponse;
import org.openapitools.model.ReportRegionLegSummaryBatchResponse;
import org.openapitools.model.ReportResponse;
import org.openapitools.model.ReservationResponse;
import org.openapitools.model.RetailerFullResponse;
import org.openapitools.model.RetailerLocationResponse;
import org.openapitools.model.RetailerOfferResponse;
import org.openapitools.model.RetailerResponse;
import org.openapitools.model.Route;
import org.openapitools.model.RouteSettings;
import org.openapitools.model.RoutingListResponse;
import org.openapitools.model.ScheduledNotificationFullResponse;
import org.openapitools.model.ScoreResponse;
import org.openapitools.model.SearchResponse;
import org.openapitools.model.ServiceHub;
import org.openapitools.model.Shipment;
import org.openapitools.model.ShipmentBatch;
import org.openapitools.model.ShipmentImportStatus;
import org.openapitools.model.ShipmentOrder;
import org.openapitools.model.SirqulResponse;
import org.openapitools.model.StepResponse;
import org.openapitools.model.Stop;
import org.openapitools.model.SubscriptionPlanResponse;
import org.openapitools.model.SubscriptionResponse;
import org.openapitools.model.TaskResponse;
import org.openapitools.model.TerritoryResponse;
import org.openapitools.model.ThemeDescriptorResponse;
import org.openapitools.model.ThirdPartyCredentialResponse;
import org.openapitools.model.ThirdPartyNetworkResponse;
import org.openapitools.model.ThirdPartyNetworkShortResponse;
import org.openapitools.model.TicketListResponse;
import org.openapitools.model.TicketOfferResponse;
import org.openapitools.model.TimeSlotResponse;
import org.openapitools.model.TokenResponse;
import org.openapitools.model.TournamentResponse;
import org.openapitools.model.TriggerResponse;
import org.openapitools.model.TrilatCacheRequest;
import org.openapitools.model.Trip;
import org.openapitools.model.TwiMLResponse;
import org.openapitools.model.UserActivityResponse;
import org.openapitools.model.UserLocationSearchResponse;
import org.openapitools.model.UserPermissionsResponse;
import org.openapitools.model.UserSettingsResponse;
import org.openapitools.model.Vehicle;
import org.openapitools.model.VehicleType;
import org.openapitools.model.WeatherResponse;
import org.openapitools.model.WordzWordResponse;
import org.openapitools.model.WrappedProxyItemResponse;
import org.openapitools.model.WrappedResponse;

import java.util.Map;
import java.util.List;
import org.openapitools.api.NotFoundException;

import java.io.InputStream;

import org.glassfish.jersey.media.multipart.FormDataParam;
import org.glassfish.jersey.media.multipart.FormDataBodyPart;

import javax.servlet.ServletConfig;
import javax.ws.rs.core.Context;
import javax.ws.rs.core.Response;
import javax.ws.rs.core.SecurityContext;
import javax.ws.rs.*;
import javax.validation.constraints.*;
import javax.validation.Valid;

@Path("/api/{version}")


@io.swagger.annotations.Api(description = "the api API")
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaJerseyServerCodegen", date = "2026-02-09T20:50:30.957039503Z[Etc/UTC]", comments = "Generator version: 7.20.0-SNAPSHOT")
public class ApiApi  {
   private final ApiApiService delegate;

   public ApiApi(@Context ServletConfig servletContext) {
      ApiApiService delegate = null;

      if (servletContext != null) {
         String implClass = servletContext.getInitParameter("ApiApi.implementation");
         if (implClass != null && !"".equals(implClass.trim())) {
            try {
               delegate = (ApiApiService) Class.forName(implClass).getDeclaredConstructor().newInstance();
            } catch (Exception e) {
               throw new RuntimeException(e);
            }
         }
      }

      if (delegate == null) {
         delegate = ApiApiServiceFactory.getApiApi();
      }

      this.delegate = delegate;
   }

    @javax.ws.rs.POST
    @Path("/invite/accept")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Accept Invite", notes = "Allows a user to accept an invite. The user could also become the inviter's friend.", response = ConsumerInviteResponse.class, tags={ "Invite", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = ConsumerInviteResponse.class)
    })
    public Response acceptInvite(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the invite token", required = true) @QueryParam("token") @NotNull  String token,@ApiParam(value = "the accountId of the user who is accepting the invite", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "the album id associated with this invite (if applicable)") @QueryParam("albumId")  Long albumId,@ApiParam(value = "the mission id associated with this invite (if applicable)") @QueryParam("missionId")  Long missionId,@ApiParam(value = "the album contest id associated with this invite (if applicable)") @QueryParam("albumContestId")  Long albumContestId,@ApiParam(value = "the offer id associated with this invite (if applicable)") @QueryParam("offerId")  Long offerId,@ApiParam(value = "the offer location id associated with this invite (if applicable)") @QueryParam("offerLocationId")  Long offerLocationId,@ApiParam(value = "the retailer location id associated with this invite (if applicable)") @QueryParam("retailerLocationId")  Long retailerLocationId,@ApiParam(value = "the application key") @QueryParam("appKey")  String appKey,@ApiParam(value = "whether to auto-friend the invite sender and receiver", defaultValue = "true") @DefaultValue("true") @QueryParam("autoFriend")  Boolean autoFriend,@ApiParam(value = "whether to mark the event as attending automatically after invite is accepted", defaultValue = "false") @DefaultValue("false") @QueryParam("autoAttendEvent")  Boolean autoAttendEvent,@ApiParam(value = "whether to mark the offer as favorited automatically after invite is accepted", defaultValue = "false") @DefaultValue("false") @QueryParam("autoFavoriteOffer")  Boolean autoFavoriteOffer,@ApiParam(value = "whether to mark the offer location as favorited automatically after invite is accepted", defaultValue = "false") @DefaultValue("false") @QueryParam("autoFavoriteOfferLocation")  Boolean autoFavoriteOfferLocation,@ApiParam(value = "whether to mark the retailer location as favorited automatically after invite is accepted", defaultValue = "false") @DefaultValue("false") @QueryParam("autoFavoriteRetailerLocation")  Boolean autoFavoriteRetailerLocation,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.acceptInvite(version, token, accountId, albumId, missionId, albumContestId, offerId, offerLocationId, retailerLocationId, appKey, autoFriend, autoAttendEvent, autoFavoriteOffer, autoFavoriteOfferLocation, autoFavoriteRetailerLocation, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/account/search")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Search Accounts by Location", notes = "Search accounts by their location. This only searches on users that have location data. Use ConnectionApi to perform a regular search on accounts.", response = UserLocationSearchResponse.class, tags={ "Account", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = UserLocationSearchResponse.class)
    })
    public Response accountLocationSearch(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The device id (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "The account id of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "Deprecated - legacy query parameter") @QueryParam("q")  String q,@ApiParam(value = "An optional keyword to search on, will be ignore if empty (NOT implemented yet)") @QueryParam("keyword")  String keyword,@ApiParam(value = "The postal code to search on, either postalCode or the user's exact location is required") @QueryParam("postalCode")  String postalCode,@ApiParam(value = "The latitude of the user, either postalCode or the user's exact location is required") @QueryParam("latitude")  Double latitude,@ApiParam(value = "The longitude of the user, either postalCode or the user's exact location is required") @QueryParam("longitude")  Double longitude,@ApiParam(value = "The application key") @QueryParam("appKey")  String appKey,@ApiParam(value = "The range to search on", defaultValue = "10") @DefaultValue("10") @QueryParam("range")  Double range,@ApiParam(value = "Searches for user's that has updated their location since this date") @QueryParam("locationLastUpdated")  Long locationLastUpdated,@ApiParam(value = "The preferred gender") @QueryParam("gender")  String gender,@ApiParam(value = "The preferred min age") @QueryParam("minAge")  Integer minAge,@ApiParam(value = "The preferred max age") @QueryParam("maxAge")  Integer maxAge,@ApiParam(value = "The preferred companionship index") @QueryParam("companionshipIndex")  Integer companionshipIndex,@ApiParam(value = "this is the start index of a query") @QueryParam("_i")  Integer i,@ApiParam(value = "Start of the pagination", defaultValue = "0") @DefaultValue("0") @QueryParam("start")  Integer start,@ApiParam(value = "this is the limit index of a query") @QueryParam("_l")  Integer l,@ApiParam(value = "Limit of the pagination", defaultValue = "100") @DefaultValue("100") @QueryParam("limit")  Integer limit,@ApiParam(value = "Search mode to use for index searches (e.g. CLOUDINDEX, OPENSEARCH)") @QueryParam("searchMode")  String searchMode,@ApiParam(value = "Sorting field for results (default: DISTANCE)") @QueryParam("sortField")  String sortField,@ApiParam(value = "Whether to sort descending (default: false)") @QueryParam("descending")  Boolean descending,@ApiParam(value = "Roles to filter on") @QueryParam("roles")  String roles,@ApiParam(value = "Tags to filter on") @QueryParam("tags")  String tags,@ApiParam(value = "The experience to filter on") @QueryParam("experience")  String experience,@ApiParam(value = "The category ids to filter on (comma separated)") @QueryParam("categoryIds")  String categoryIds,@ApiParam(value = "The audience ids to filter on (comma separated)") @QueryParam("audienceIds")  String audienceIds,@ApiParam(value = "Operator used to combine audience filters (default: AND)", defaultValue = "AND") @DefaultValue("AND") @QueryParam("audienceOperator")  String audienceOperator,@ApiParam(value = "Whether to use the given lat & long to update the user's current location", defaultValue = "false") @DefaultValue("false") @QueryParam("updateCurrentLocation")  Boolean updateCurrentLocation,@ApiParam(value = "Whether to use the given parameters to update the user's preferred settings", defaultValue = "false") @DefaultValue("false") @QueryParam("updatePreferredSettings")  Boolean updatePreferredSettings,@ApiParam(value = "Determines whether to always display user exact locations", defaultValue = "true") @DefaultValue("true") @QueryParam("showExactLocations")  Boolean showExactLocations,@ApiParam(value = "Return connection of the accounts in the result to the passed in account if there exists any", defaultValue = "false") @DefaultValue("false") @QueryParam("showConnectionToSearcher")  Boolean showConnectionToSearcher,@ApiParam(value = "Return any results that have a minimum of the specified flag count (even ones that have met the flag threshold)") @QueryParam("flagCountMinimum")  Long flagCountMinimum,@ApiParam(value = "Returns only verified users") @QueryParam("verifiedUserOnly")  Boolean verifiedUserOnly,@ApiParam(value = "Returns only content admin users") @QueryParam("contentAdminOnly")  Boolean contentAdminOnly,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.accountLocationSearch(version, deviceId, accountId, q, keyword, postalCode, latitude, longitude, appKey, range, locationLastUpdated, gender, minAge, maxAge, companionshipIndex, i, start, l, limit, searchMode, sortField, descending, roles, tags, experience, categoryIds, audienceIds, audienceOperator, updateCurrentLocation, updatePreferredSettings, showExactLocations, showConnectionToSearcher, flagCountMinimum, verifiedUserOnly, contentAdminOnly, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/analytics/useractivity")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Get User Activity", notes = "Get an activity feed by user.", response = UserActivityResponse.class, responseContainer = "List", tags={ "Analytics", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = UserActivityResponse.class, responseContainer = "List")
    })
    public Response activities(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The start of the pagination", required = true) @QueryParam("start") @NotNull  Integer start,@ApiParam(value = "The limit of the pagination", required = true) @QueryParam("limit") @NotNull  Integer limit,@ApiParam(value = "the account id of the user", required = true) @QueryParam("accountId") @NotNull  Long accountId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.activities(version, start, limit, accountId, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/album/create")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Create Album", notes = "Create an Album.", response = SearchResponse.class, tags={ "Album", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SearchResponse.class)
    })
    public Response addAlbumCollection(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the title of the album", required = true) @QueryParam("title") @NotNull  String title,@ApiParam(value = "determines whether the cover image of the album can be empty, else will use the user's profile picture as the cover image", required = true) @QueryParam("coverAssetNullable") @NotNull  Boolean coverAssetNullable,@ApiParam(value = "determines whether the cover image should be added to the album asset list", required = true) @QueryParam("includeCoverInAssetList") @NotNull  Boolean includeCoverInAssetList,@ApiParam(value = "determines whether the album's participants has read permissions", required = true) @QueryParam("publicRead") @NotNull  Boolean publicRead,@ApiParam(value = "determines whether the album's participants has write permissions", required = true) @QueryParam("publicWrite") @NotNull  Boolean publicWrite,@ApiParam(value = "determines whether the album's participants has delete permissions", required = true) @QueryParam("publicDelete") @NotNull  Boolean publicDelete,@ApiParam(value = "determines whether the album's participants has add permissions", required = true) @QueryParam("publicAdd") @NotNull  Boolean publicAdd,@ApiParam(value = "determines whether the album is posted anonymously", required = true) @QueryParam("anonymous") @NotNull  Boolean anonymous,@ApiParam(value = "a unique ID given by the device (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "the account ID of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "Comma separated list of asset IDs to add to the album's asset list (use \"assetId\" for setting the cover of the album)") @QueryParam("assetsToAdd")  String assetsToAdd,@ApiParam(value = "a MultipartFile containing the cover image of the album (this will only be used if \"assetId\" is empty)") @QueryParam("media")  File media,@ApiParam(value = "this can be used if the \"media\" is a link (this will only be used if \"assetId\" and media are empty)") @QueryParam("mediaURL")  String mediaURL,@ApiParam(value = "The asset ID to set the album cover image") @QueryParam("assetId")  Long assetId,@ApiParam(value = "a MultipartFile containing an asset that the \"media\" file references. Example to upload a video: the \"media\" file should contain a screen capture of the video, and the \"attachedMedia\" should be the actual video.") @QueryParam("attachedMedia")  File attachedMedia,@ApiParam(value = "this can be used if the \"attachedMedia\" is a link (i.e. a Youtube video, etc)") @QueryParam("attachedMediaURL")  String attachedMediaURL,@ApiParam(value = "the start date") @QueryParam("startDate")  Long startDate,@ApiParam(value = "the end date") @QueryParam("endDate")  Long endDate,@ApiParam(value = "the tags") @QueryParam("tags")  String tags,@ApiParam(value = "the description of the album") @QueryParam("description")  String description,@ApiParam(value = "a custom field used for aggregation and searching") @QueryParam("albumType")  String albumType,@ApiParam(value = "a custom indexed number used for aggregation and searching") @QueryParam("albumTypeId")  Long albumTypeId,@ApiParam(value = "a custom string field used for aggregation and searching") @QueryParam("subType")  String subType,@ApiParam(value = "latitude used to update the album's location") @QueryParam("latitude")  Double latitude,@ApiParam(value = "longitude used to update the album's location") @QueryParam("longitude")  Double longitude,@ApiParam(value = "the location description") @QueryParam("locationDescription")  String locationDescription,@ApiParam(value = "the determines the album's participants (PUBLIC - includes everyone in the system as a potential participant, PRIVATE - only considers people who have been invited as participants)", allowableValues="PUBLIC, PRIVATE, FRIENDS") @QueryParam("visibility")  String visibility,@ApiParam(value = "@deprecated, use the appKey") @QueryParam("gameType")  String gameType,@ApiParam(value = "the application key") @QueryParam("appKey")  String appKey,@ApiParam(value = "the cell phone number") @QueryParam("cellPhone")  String cellPhone,@ApiParam(value = "The street address of the location") @QueryParam("streetAddress")  String streetAddress,@ApiParam(value = "Additional address information (such as a suite number, floor number, building name, or PO Box)") @QueryParam("streetAddress2")  String streetAddress2,@ApiParam(value = "The city of the location") @QueryParam("city")  String city,@ApiParam(value = "The state of of the location") @QueryParam("state")  String state,@ApiParam(value = "The postal code of the location") @QueryParam("postalCode")  String postalCode,@ApiParam(value = "The full address of the location which should include the street address, city, state, and postal code") @QueryParam("fullAddress")  String fullAddress,@ApiParam(value = "External custom client defined data") @QueryParam("metaData")  String metaData,@ApiParam(value = "comma separated category ids string associated with the Album") @QueryParam("categoryIds")  String categoryIds,@ApiParam(value = "comma separated filter ids string associated with the Album") @QueryParam("categoryFilterIds")  String categoryFilterIds,@ApiParam(value = "comma separated audience ids string associated with the album") @QueryParam("audienceIds")  String audienceIds,@ApiParam(value = "determines whether to include all app users as members (only admins of the app can do this)") @QueryParam("includeAllAppUsersAsMembers")  Boolean includeAllAppUsersAsMembers,@ApiParam(value = "determines whether to include all users of the audiences as members (only admins of the app can do this)") @QueryParam("includeAudiencesAsMembers")  Boolean includeAudiencesAsMembers,@ApiParam(value = "determines whether to use ands or ors when using the audience list to add users") @QueryParam("audienceOperator")  String audienceOperator,@ApiParam(value = "The approval status to set {PENDING, REJECTED, APPROVED, FEATURED}", allowableValues="PENDING, REJECTED, APPROVED, FEATURED") @QueryParam("approvalStatus")  String approvalStatus,@ApiParam(value = "sets a linked object so that it can be returned as part of the album response") @QueryParam("linkedObjectType")  String linkedObjectType,@ApiParam(value = "sets a linked object id so that it can be returned as part of the album response") @QueryParam("linkedObjectId")  Long linkedObjectId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.addAlbumCollection(version, title, coverAssetNullable, includeCoverInAssetList, publicRead, publicWrite, publicDelete, publicAdd, anonymous, deviceId, accountId, assetsToAdd, media, mediaURL, assetId, attachedMedia, attachedMediaURL, startDate, endDate, tags, description, albumType, albumTypeId, subType, latitude, longitude, locationDescription, visibility, gameType, appKey, cellPhone, streetAddress, streetAddress2, city, state, postalCode, fullAddress, metaData, categoryIds, categoryFilterIds, audienceIds, includeAllAppUsersAsMembers, includeAudiencesAsMembers, audienceOperator, approvalStatus, linkedObjectType, linkedObjectId, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/album/user/add")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Add Album Users", notes = "Add users to an album as participants.", response = SirqulResponse.class, tags={ "Album", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response addAlbumUsers(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the album ID", required = true) @QueryParam("albumId") @NotNull  Long albumId,@ApiParam(value = "determines whether to include all friends as participants", required = true) @QueryParam("includeFriendGroup") @NotNull  Boolean includeFriendGroup,@ApiParam(value = "a unique ID given by the device (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "the account ID of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "determines whether the users being added have read permissions") @QueryParam("read")  Boolean read,@ApiParam(value = "determines whether the users being added have write permissions") @QueryParam("write")  Boolean write,@ApiParam(value = "determines whether the users being added have delete permissions") @QueryParam("delete")  Boolean delete,@ApiParam(value = "determines whether the users being added have add permissions") @QueryParam("add")  Boolean add,@ApiParam(value = "comma separated list of connection IDs") @QueryParam("connections")  String connections,@ApiParam(value = "comma separated list of connection group IDs") @QueryParam("connectionGroups")  String connectionGroups,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.addAlbumUsers(version, albumId, includeFriendGroup, deviceId, accountId, read, write, delete, add, connections, connectionGroups, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/consumer/connection/group/addConnection")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Add Connection", notes = "Adds a connection to a group.", response = SirqulResponse.class, tags={ "Connection", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response addConnectionToGroup(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "whether to return nulls or not", required = true) @QueryParam("returnNulls") @NotNull  Boolean returnNulls,@ApiParam(value = "the group id", required = true) @QueryParam("groupId") @NotNull  Long groupId,@ApiParam(value = "the device id (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "the account id of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "the connection id") @QueryParam("connectionId")  Long connectionId,@ApiParam(value = "the connection account id") @QueryParam("connectionAccountId")  Long connectionAccountId,@ApiParam(value = "the pending id") @QueryParam("pendingId")  Long pendingId,@ApiParam(value = "the current latitude of the user") @QueryParam("latitude")  Double latitude,@ApiParam(value = "the current longitude of the user") @QueryParam("longitude")  Double longitude,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.addConnectionToGroup(version, returnNulls, groupId, deviceId, accountId, connectionId, connectionAccountId, pendingId, latitude, longitude, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/connection/group/addConnections")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Add Connections", notes = "Adds a list of connections to a group.", response = SirqulResponse.class, tags={ "Connection", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response addConnectionsToGroup(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the connection group ID", required = true) @QueryParam("connectionGroupId") @NotNull  Long connectionGroupId,@ApiParam(value = "the device id (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "the account id of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "comma separated list of connection ids") @QueryParam("connectionIds")  String connectionIds,@ApiParam(value = "comma separated list of connection account ids") @QueryParam("connectionAccountIds")  String connectionAccountIds,@ApiParam(value = "the current latitude of the user") @QueryParam("latitude")  Double latitude,@ApiParam(value = "the current longitude of the user") @QueryParam("longitude")  Double longitude,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.addConnectionsToGroup(version, connectionGroupId, deviceId, accountId, connectionIds, connectionAccountIds, latitude, longitude, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/favorite/create")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Create Favorite", notes = "Adds an offer, offer location, retailer location, or category to your favorites.", response = WrappedResponse.class, tags={ "Favorite", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = WrappedResponse.class)
    })
    public Response addFavorite(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The ID of the object to favorite {offerId, offerLocationId, retailerLocationId, categoryId}", required = true) @QueryParam("favoritableId") @NotNull  Long favoritableId,@ApiParam(value = "The type of the object to favorite {OFFER, OFFER_LOCATION, RETAILER_LOCATION, CATEGORY, ALBUM}", required = true) @QueryParam("favoritableType") @NotNull  String favoritableType,@ApiParam(value = "The unique ID given by the device (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "The account ID of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "The current latitude of the user") @QueryParam("latitude")  Double latitude,@ApiParam(value = "The current longitude of the user") @QueryParam("longitude")  Double longitude,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.addFavorite(version, favoritableId, favoritableType, deviceId, accountId, latitude, longitude, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/object/field/add")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Create Field", notes = "Add a field to a specific object.  The field name should be camel   case with the first letter lower case, for example: myFieldName.  Duplicate   field names are not allowed.   The field name cannot be any of the following   reserved words: ACCESSIBLE, ADD, ALL, ALTER, ANALYZE, AND, AS, ASC, ASENSITIVE,   BEFORE, BETWEEN, BIGINT, BINARY, BLOB, BOTH, BY, CALL, CASCADE, CASE, CHANGE,   CHAR, CHARACTER, CHECK, COLLATE, COLUMN, CONDITION, CONSTRAINT, CONTINUE,   CONVERT, CREATE, CROSS, CURRENT_, ATE, CURRENT_TIME, CURRENT_TIMESTAMP,   CURRENT_USER, CURSOR, DATABASE, DATABASES, DAY_HOUR, DAY_MICROSECOND, DAY_MINUTE,   DAY_SECOND, DEC, DECIMAL, DECLARE, DEFAULT, DELAYED, DELETE, DESC, DESCRIBE,   DETERMINISTIC, DISTINCT, DISTINCTROW, DIV, DOUBLE, DROP, DUAL, EACH, ELSE,   ELSEIF, ENCLOSED, ESCAPED, EXISTS, EXIT, EXPLAIN, FALSE, FETCH, FLOAT, FLOAT4,   FLOAT8, FOR, FORCE, FOREIGN, FROM, FULLTEXT, GRANT, GROUP, HAVING, HIGH_PRIORITY,   HOUR_MICROSECOND, HOUR_MINUTE, HOUR_SECOND, IF, IGNORE, IN, INDEX, INFILE,   INNER, INOUT, INSENSITIVE, INSERT, INT, INT1, INT2, INT3, INT4, INT8, INTEGER,   INTERVAL, INTO, IS, ITERATE, JOIN, KEY, KEYS, KILL, LEADING, LEAVE, LEFT,   LIKE, LIMIT, LINEAR, LINES, LOAD, LOCALTIME, LOCALTIMESTAMP, LOCK, LONG,   LONGBLOB, LONGT, XT, LOOP, LOW_PRIORITY, MASTER_SSL_VERIFY_SERVER_CERT,   MATCH, MAXVALUE, MEDIUMBLOB, MEDIUMINT, MEDIUMTEXT, MIDDLEINT, MINUTE_MICROSECOND,   MINUTE_SECOND, MOD, MODIFIES, NATURAL, NOT, NO_WRITE_TO_BINLOG, NULL, NUMERIC,   ON, OPTIMIZE, OPTION, OPTIONALLY, OR, ORDER, OUT, OUTER, OUTFILE, PRECISION,   PRIMARY, PROCEDURE, PURGE, RANGE, READ, READS, READ_WRITE, REAL, REFERENCES,   REGEXP, RELEASE, RENAME, REPEAT, REPLACE, REQUIRE, RESIGNAL, RESTRICT, RETURN,   REVOKE, RIGHT, RLIKE, SCHEMA, SCHEMAS, SECOND_MICROSECOND, SELECT, SENSITIVE,   SEPARATOR, SET, SHOW, SIGNAL, SMALLINT, SPATIAL, SPECIFIC, SQL, SQLEXCEPTION,   SQLSTATE, SQLWARNING, SQL_BIG_RESULT, SQL_CALC_FOUND_ROWS, SQL_SMALL_RESULT,   SSL, STARTING, STRAIGHT_JOIN, TABLE, TERMINATED, THEN, TINYBLOB, TINYINT,   TINYTEXT, TO, TRAILING, TRIGGER, TRUE, NDO, UNION, UNIQUE, UNLOCK, UNSIGNED,   UPDATE, USAGE, USE, USING, UTC_DATE, UTC_TIME, UTC_TIMESTAMP, VALUES, VARBINARY,   VARCHAR, VARCHARACTER, VARYING, WHEN, WHERE, WHILE, WITH, WRITE, XOR, YEAR_MONTH,   ZEROFILL, GENERAL, IGNORE_SERVER_IDS, MASTER_HEARTBEAT_PERIOD, SLOW.     The following field names are reserved (cannot be used directly) and are automatically   included during object creation: ID, OBJECTID, CREATED, UPDATED, DELETED.   Additionally the field names must start with a letter or number.", response = ObjectStoreResponse.class, tags={ "Object Store", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = ObjectStoreResponse.class)
    })
    public Response addField(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The account id of the logged in user", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "The application key for updating an existing application", required = true) @QueryParam("appKey") @NotNull  String appKey,@ApiParam(value = "The name of the object to add the field to", required = true) @QueryParam("objectName") @NotNull  String objectName,@ApiParam(value = "field name The name of the field to add.", required = true) @QueryParam("fieldName") @NotNull  String fieldName,@ApiParam(value = "field type The field type to create, supported types are: STRING, DATE, NUMBER, BOOLEAN, IDENTITY", required = true) @QueryParam("fieldType") @NotNull  String fieldType,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.addField(version, accountId, appKey, objectName, fieldName, fieldType, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/orson/ai/addMovie")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Add Movie", notes = "Add a movie to be indexed for Topics. Indexing a movie analyses the content and incorporates it into the topics model for future /topics calls. This does not store the movie file long-term.", response = OrsonAiAddMovieResponse.class, tags={ "Orson", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = OrsonAiAddMovieResponse.class)
    })
    public Response addMovie(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "Sirqul Account Id", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "Movie Name", required = true) @QueryParam("movieName") @NotNull  String movieName,@ApiParam(value = "A third-party account id that is meaningful to your systems") @QueryParam("thirdPartyAccountId")  String thirdPartyAccountId,@ApiParam(value = "A user defined list (comma-delimited) of tags associated with the movie") @QueryParam("tags")  String tags,@ApiParam(value = "An uploaded recording to analyze (Currently limited to 10MB)") @QueryParam("file")  File _file,@ApiParam(value = "A recording file to download and analyze (Size limit: 1GB)") @QueryParam("url")  String url,@ApiParam(value = "When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open") @QueryParam("callback")  String paramCallback,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.addMovie(version, accountId, movieName, thirdPartyAccountId, tags, _file, url, paramCallback, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/consumer/album/contest")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Create or Update Contest", notes = "Creates or updates a contest.", response = AlbumContestResponse.class, tags={ "Contest", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = AlbumContestResponse.class)
    })
    public Response addOrUpdateAlbumContest(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "determines whether the contest's participants has read permissions", required = true) @QueryParam("publicRead") @NotNull  Boolean publicRead,@ApiParam(value = "determines whether the contest's participants has write permissions", required = true) @QueryParam("publicWrite") @NotNull  Boolean publicWrite,@ApiParam(value = "determines whether the contest's participants has delete permissions", required = true) @QueryParam("publicDelete") @NotNull  Boolean publicDelete,@ApiParam(value = "determines whether the contest's participants has add permissions", required = true) @QueryParam("publicAdd") @NotNull  Boolean publicAdd,@ApiParam(value = "the determines the album's participants (PUBLIC - includes everyone in the system as a potential participant, PRIVATE - only considers people who have been invited as participants)", required = true, allowableValues="PUBLIC, PRIVATE, FRIENDS") @QueryParam("visibility") @NotNull  String visibility,@ApiParam(value = "determines whether to include all friends as participants", required = true) @QueryParam("includeFriendGroup") @NotNull  Boolean includeFriendGroup,@ApiParam(value = "a unique ID given by the device (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "the account ID of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "This parameter is deprecated. the application key") @QueryParam("gameType")  String gameType,@ApiParam(value = "the application key") @QueryParam("appKey")  String appKey,@ApiParam(value = "a custom field used for aggregation and searching") @QueryParam("contestType")  String contestType,@ApiParam(value = "the album contest ID for updating (don't pass in if creating)") @QueryParam("albumContestId")  Long albumContestId,@ApiParam(value = "the title of the contest") @QueryParam("title")  String title,@ApiParam(value = "the description of the contest") @QueryParam("description")  String description,@ApiParam(value = "the album ID for the first album") @QueryParam("albumId1")  Long albumId1,@ApiParam(value = "removes album1 from the contest") @QueryParam("removeAlbum1")  Boolean removeAlbum1,@ApiParam(value = "the album ID for the second album") @QueryParam("albumId2")  Long albumId2,@ApiParam(value = "removes album2 from the contest") @QueryParam("removeAlbum2")  Boolean removeAlbum2,@ApiParam(value = "the start date of the contest (time-stamp in milliseconds)") @QueryParam("startDate")  Long startDate,@ApiParam(value = "the end date of the contest (time-stamp in milliseconds)") @QueryParam("endDate")  Long endDate,@ApiParam(value = "the location description of the contest taking place") @QueryParam("locationDescription")  String locationDescription,@ApiParam(value = "comma separated list of connection IDs") @QueryParam("connectionIdsToAdd")  String connectionIdsToAdd,@ApiParam(value = "comma separated list of connection group IDs") @QueryParam("connectionGroupIdsToAdd")  String connectionGroupIdsToAdd,@ApiParam(value = "latitude used to update the user's current location") @QueryParam("latitude")  Double latitude,@ApiParam(value = "longitude used to update the user's current location") @QueryParam("longitude")  Double longitude,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.addOrUpdateAlbumContest(version, publicRead, publicWrite, publicDelete, publicAdd, visibility, includeFriendGroup, deviceId, accountId, gameType, appKey, contestType, albumContestId, title, description, albumId1, removeAlbum1, albumId2, removeAlbum2, startDate, endDate, locationDescription, connectionIdsToAdd, connectionGroupIdsToAdd, latitude, longitude, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/consumer/theme")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Create/Update Theme", notes = "Creates or updates a theme descriptor that can be used to give applications a customized look and feel. The theme can be created by consumers and shared to other users, allowing them to use and/or collaborate on making the theme.", response = ThemeDescriptorResponse.class, tags={ "Theme Descriptor", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = ThemeDescriptorResponse.class)
    })
    public Response addOrUpdateThemeDescriptor(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "determines whether the theme's participants have read permissions", required = true) @QueryParam("publicRead") @NotNull  Boolean publicRead,@ApiParam(value = "determines whether the theme's participants have write permissions", required = true) @QueryParam("publicWrite") @NotNull  Boolean publicWrite,@ApiParam(value = "determines whether the theme's participants have delete permissions", required = true) @QueryParam("publicDelete") @NotNull  Boolean publicDelete,@ApiParam(value = "", required = true) @QueryParam("publicAdd") @NotNull  Boolean publicAdd,@ApiParam(value = "the determines the theme's participants (PUBLIC - includes everyone in the system as a potential participant, PRIVATE - only considers people who have been invited as participants)", required = true, allowableValues="PUBLIC, PRIVATE, FRIENDS") @QueryParam("visibility") @NotNull  String visibility,@ApiParam(value = "flag to determine whether to share to the user's \"friends\" group", required = true) @QueryParam("includeFriendGroup") @NotNull  Boolean includeFriendGroup,@ApiParam(value = "determines whether to use default values to complete the theme", required = true) @QueryParam("completeWithDefaultValues") @NotNull  Boolean completeWithDefaultValues,@ApiParam(value = "a unique ID given by the device (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "the account ID of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "the application key") @QueryParam("gameType")  String gameType,@ApiParam(value = "the theme descriptor id used to update an existing theme, leave empty for creating a new theme") @QueryParam("themeDescriptorId")  Long themeDescriptorId,@ApiParam(value = "the title of the theme") @QueryParam("title")  String title,@ApiParam(value = "the description of the theme") @QueryParam("description")  String description,@ApiParam(value = "a comma separated list of connection IDs to share to users") @QueryParam("connectionIdsToAdd")  String connectionIdsToAdd,@ApiParam(value = "a comma separated list of connection group IDs to share to groups") @QueryParam("connectionGroupIdsToAdd")  String connectionGroupIdsToAdd,@ApiParam(value = "the application version the theme was created for") @QueryParam("appVersion")  String appVersion,@ApiParam(value = "a json array used to replace colors within the application. Example: ```json [   {     \"name\": \"sceneAtlas\",     \"valueString\": \"100,100,100,255\"   },   {     \"name\": \"bg\",     \"valueString\": \"100,100,100,255\"   } ] ``` ") @QueryParam("colorValueJson")  String colorValueJson,@ApiParam(value = "a json array used to replace strings within the application. Example: ```json [   {     \"name\": \"coins\",     \"valueString\": \"Gems\"   },   {     \"name\": \"lives\",     \"valueString\": \"lives\"   } ] ``` ") @QueryParam("stringReplacerJson")  String stringReplacerJson,@ApiParam(value = "a json object used by the scene atlas to position sprites. Example: ```json {   \"pShootingOffset\": [     {       \"name\": \"x\",       \"valueString\": \"2.2\"     },     {       \"name\": \"y\",       \"valueString\": \"-0.3\"     }   ],   \"e1ShootingOffset\": [     {       \"name\": \"x\",       \"valueString\": \"0.25\"     },     {       \"name\": \"y\",       \"valueString\": \"0.5\"     }   ] } ``` ") @QueryParam("customJsonObjects")  String customJsonObjects,@ApiParam(value = "a MultipartFile containing the image used as the theme icon") @QueryParam("iconImage")  File iconImage,@ApiParam(value = "a MultipartFile containing the scene atlas") @QueryParam("sceneAtlasImage")  File sceneAtlasImage,@ApiParam(value = "a MultipartFile containing the background image") @QueryParam("bgImage")  File bgImage,@ApiParam(value = "a MultipartFile containing the background sound file (preferably in MP3 format)") @QueryParam("bgSound")  File bgSound,@ApiParam(value = "used to select a default sound file that already exists in the application") @QueryParam("musicSelection")  String musicSelection,@ApiParam(value = "the description of the user's current location") @QueryParam("locationDescription")  String locationDescription,@ApiParam(value = "the current latitude of the user") @QueryParam("latitude")  Double latitude,@ApiParam(value = "the current longitude of the user") @QueryParam("longitude")  Double longitude,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.addOrUpdateThemeDescriptor(version, publicRead, publicWrite, publicDelete, publicAdd, visibility, includeFriendGroup, completeWithDefaultValues, deviceId, accountId, gameType, themeDescriptorId, title, description, connectionIdsToAdd, connectionGroupIdsToAdd, appVersion, colorValueJson, stringReplacerJson, customJsonObjects, iconImage, sceneAtlasImage, bgImage, bgSound, musicSelection, locationDescription, latitude, longitude, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/billing/update")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Update Payment Method", notes = "Update a method of payment. If the paymentMethodId is not passed in then will update their default payment method.", response = PaymentTypesResponse.class, tags={ "Billing Info", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = PaymentTypesResponse.class)
    })
    public Response addPaymentMethod(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The account used to perform the the request", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "Payment Method Id") @QueryParam("paymentMethodId")  Long paymentMethodId,@ApiParam(value = "the name of the account") @QueryParam("accountName")  String accountName,@ApiParam(value = "First Name that the account is filed as") @QueryParam("firstName")  String firstName,@ApiParam(value = "Last Name that the account is filed as") @QueryParam("lastName")  String lastName,@ApiParam(value = "Address that the account is filed as") @QueryParam("address")  String address,@ApiParam(value = "City that the account is filed as") @QueryParam("city")  String city,@ApiParam(value = "State that the account is filed as") @QueryParam("state")  String state,@ApiParam(value = "Postal Code that the account is filed as") @QueryParam("postalCode")  String postalCode,@ApiParam(value = "Country that the account is filed as") @QueryParam("country")  String country,@ApiParam(value = "Phone that the account is filed as") @QueryParam("phone")  String phone,@ApiParam(value = "The full credit card number to store on file") @QueryParam("creditCardNumber")  String creditCardNumber,@ApiParam(value = "The credit card expiration date YYYY-MM") @QueryParam("expirationDate")  String expirationDate,@ApiParam(value = "The 3 digit confirmation code") @QueryParam("ccv")  String ccv,@ApiParam(value = "The bank account number") @QueryParam("accountNumber")  String accountNumber,@ApiParam(value = "The bank name") @QueryParam("bankName")  String bankName,@ApiParam(value = "Routing Number") @QueryParam("routingNumber")  String routingNumber,@ApiParam(value = "Default Payment Method") @QueryParam("defaultPaymentMethod")  Boolean defaultPaymentMethod,@ApiParam(value = "Payment Method Nickname") @QueryParam("paymentMethodNickname")  String paymentMethodNickname,@ApiParam(value = "Tax Id") @QueryParam("taxId")  String taxId,@ApiParam(value = "Provider customer profile Id") @QueryParam("providerCustomerProfileId")  String providerCustomerProfileId,@ApiParam(value = "Provider customer payment profile Id") @QueryParam("providerPaymentProfileId")  String providerPaymentProfileId,@ApiParam(value = "Meta Data") @QueryParam("metaData")  String metaData,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.addPaymentMethod(version, accountId, paymentMethodId, accountName, firstName, lastName, address, city, state, postalCode, country, phone, creditCardNumber, expirationDate, ccv, accountNumber, bankName, routingNumber, defaultPaymentMethod, paymentMethodNickname, taxId, providerCustomerProfileId, providerPaymentProfileId, metaData, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/creative/addpreview")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Add Preview", notes = "Enable this ad for preview for this account.", response = SirqulResponse.class, tags={ "Creative", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response addPreview(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the id of the account", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "The id of the creative that want to enable preview. The type of the creative should be CONFIG, otherwise no action will be applied.", required = true) @QueryParam("creativeId") @NotNull  Long creativeId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.addPreview(version, accountId, creativeId, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/consumer/connection/group/addSubGroup")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Add Connection Groups", notes = "Add sub groups to a group.", response = ConnectionGroupResponse.class, tags={ "Connection", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = ConnectionGroupResponse.class)
    })
    public Response addSubGroups(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "whether to return nulls or not", required = true) @QueryParam("returnNulls") @NotNull  Boolean returnNulls,@ApiParam(value = "the parent group id", required = true) @QueryParam("groupId") @NotNull  Long groupId,@ApiParam(value = "comma separated list of group IDs to add to the parent group", required = true) @QueryParam("subGroupIds") @NotNull  String subGroupIds,@ApiParam(value = "the device id (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "the account id of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "the current latitude of the user") @QueryParam("latitude")  Double latitude,@ApiParam(value = "the current longitude of the user") @QueryParam("longitude")  Double longitude,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.addSubGroups(version, returnNulls, groupId, subGroupIds, deviceId, accountId, latitude, longitude, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/consumer/permissions/add")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Add User", notes = "Adds a user to a permissionable object.", response = SirqulResponse.class, tags={ "User Permissions", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response addUsersToPermissionable(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the permissionable type of the object", required = true, allowableValues="ACCOUNT, GAMELEVEL, ALBUM_CONTEST, THEME_DESCRIPTOR, SCHEDULED_NOTIFICATION, TASK, TRIGGER") @QueryParam("permissionableType") @NotNull  String permissionableType,@ApiParam(value = "the id of the permissionable object", required = true) @QueryParam("permissionableId") @NotNull  Long permissionableId,@ApiParam(value = "the device id (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "the account id of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "the read permission of the users/groups", defaultValue = "true") @DefaultValue("true") @QueryParam("read")  Boolean read,@ApiParam(value = "the write permission of the users/groups", defaultValue = "false") @DefaultValue("false") @QueryParam("write")  Boolean write,@ApiParam(value = "the delete permission of the users/groups", defaultValue = "false") @DefaultValue("false") @QueryParam("delete")  Boolean delete,@ApiParam(value = "the add permission of the users/groups", defaultValue = "false") @DefaultValue("false") @QueryParam("add")  Boolean add,@ApiParam(value = "a comma separated list of connection ids (NOT the account ids)") @QueryParam("connectionIds")  String connectionIds,@ApiParam(value = "a comma separated list of account ids") @QueryParam("connectionAccountIds")  String connectionAccountIds,@ApiParam(value = "a comma separated list of connection group ids (these are groups made by the user)") @QueryParam("connectionGroupIds")  String connectionGroupIds,@ApiParam(value = "sets whether the added users are marked as pending (and will require the album admins to accept) - admins can set this to false (to accept)", defaultValue = "false") @DefaultValue("false") @QueryParam("pending")  Boolean pending,@ApiParam(value = "sets whether the added users will become admins or not") @QueryParam("admin")  Boolean admin,@ApiParam(value = "flag to determine whether to include the built-in \"friends\" group", defaultValue = "false") @DefaultValue("false") @QueryParam("includeFriendGroup")  Boolean includeFriendGroup,@ApiParam(value = "the current latitude of the user") @QueryParam("latitude")  Double latitude,@ApiParam(value = "the current longitude of the user") @QueryParam("longitude")  Double longitude,@ApiParam(value = "comma separated list of audience ids. This is a feature only available to the permissionable's application owner (and its employees). This will add all users from these audiences to the permissionable object. Notifications will not be sent to users if this feature is used.") @QueryParam("audienceIds")  String audienceIds,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.addUsersToPermissionable(version, permissionableType, permissionableId, deviceId, accountId, read, write, delete, add, connectionIds, connectionAccountIds, connectionGroupIds, pending, admin, includeFriendGroup, latitude, longitude, audienceIds, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/ads/find")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Find Missions", notes = "Get a set of ad filtered by the parameters provided.", response = MissionResponse.class, responseContainer = "List", tags={ "Creative", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = MissionResponse.class, responseContainer = "List")
    })
    public Response adsFind(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The application key, if provided return missions specific for the app. Will always return mission levels that are app agnostic.", required = true) @QueryParam("appKey") @NotNull  String appKey,@ApiParam(value = "return a random set of results, default is true. If false returns in nature order.", required = true) @QueryParam("randomize") @NotNull  Boolean randomize,@ApiParam(value = "return only ads targets to the specific app, no global ads.", required = true) @QueryParam("targetedAdsOnly") @NotNull  Boolean targetedAdsOnly,@ApiParam(value = "The type of ads to get, possible values are: BANNER, LEADERBOARD, SKYSCRAPER, FULL, VIDEO, ZIP, CONFIG. Use this instead of suffix.") @QueryParam("type")  String type,@ApiParam(value = "The logged in user.") @QueryParam("accountId")  Long accountId,@ApiParam(value = "The version of the application, will not return levels newer than the appVersion.") @QueryParam("appVersion")  String appVersion,@ApiParam(value = "The current location of the requesting device") @QueryParam("latitude")  Double latitude,@ApiParam(value = "The current location of the requesting device") @QueryParam("longitude")  Double longitude,@ApiParam(value = "Should use deviceId if possible. The name of the requesting device; possible values are: Android, iPhone, iPad, iPod, etc. use /audience/devices for list.") @QueryParam("device")  String device,@ApiParam(value = "The device ID of the requesting device, use /audience/devices for list") @QueryParam("deviceIdentifier")  Long deviceIdentifier,@ApiParam(value = "The requesting device version; examples are: 2.3, 5.1.4, 6.1.4. Supports X, X.X, or X.X.X formated string.") @QueryParam("deviceVersion")  String deviceVersion,@ApiParam(value = "The index into the record set to start with.") @QueryParam("start")  Integer start,@ApiParam(value = "The total number of record to return.") @QueryParam("limit")  Integer limit,@ApiParam(value = "If true then return the audience data in the response. Default is false.") @QueryParam("includeAudiences")  Boolean includeAudiences,@ApiParam(value = "If true/false only return missions whose game levels allocate (or don't allocate) tickets. Do not provide a value to return both.") @QueryParam("allocatesTickets")  Boolean allocatesTickets,@ApiParam(value = "return only ads from the specified campaigns.") @QueryParam("missionIds")  String missionIds,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.adsFind(version, appKey, randomize, targetedAdsOnly, type, accountId, appVersion, latitude, longitude, device, deviceIdentifier, deviceVersion, start, limit, includeAudiences, allocatesTickets, missionIds, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/analytics/aggregatedFilteredUsage")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Get Aggregated Filtered Usage", notes = "Query analytics to get data used for nested graphs and charts", response = ChartData.class, tags={ "Analytics", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = ChartData.class)
    })
    public Response aggregatedFilteredUsage(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The unique id of the device making the request (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "The account id of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "This parameter is deprecated.") @QueryParam("applicationId")  Long applicationId,@ApiParam(value = "The application key used to filter results by application") @QueryParam("appKey")  String appKey,@ApiParam(value = "Used to search for results after or equal to this date (UNIX time-stamp in milliseconds)") @QueryParam("startDate")  Long startDate,@ApiParam(value = "Used to search for results before or equal to this date (UNIX time-stamp in milliseconds)") @QueryParam("endDate")  Long endDate,@ApiParam(value = "The device type to filter results by (performs a LIKE search)") @QueryParam("deviceType")  String deviceType,@ApiParam(value = "The device to filter results by (performs a LIKE search)") @QueryParam("device")  String device,@ApiParam(value = "The device OS to filter results by (performs a LIKE search)") @QueryParam("deviceOS")  String deviceOS,@ApiParam(value = "The gender to filter results by {MALE, FEMALE}") @QueryParam("gender")  String gender,@ApiParam(value = "Comma separated list of age groups to filter by {AGE_0_13, AGE_14_17, AGE_18_22, AGE_23_30, AGE_31_54, AGE_55_PLUS}") @QueryParam("ageGroup")  String ageGroup,@ApiParam(value = "The country to filter results by (performs a wild-card search)") @QueryParam("country")  String country,@ApiParam(value = "The state to filter results by (performs a wild-card search)") @QueryParam("state")  String state,@ApiParam(value = "The city to filter results by (performs a wild-card search)") @QueryParam("city")  String city,@ApiParam(value = "The zip to filter results by (performs a wild-card search)") @QueryParam("zip")  String zip,@ApiParam(value = "The model to filter results by (performs a wild-card search)") @QueryParam("model")  String model,@ApiParam(value = "The tag to filter results by (performs a wild-card search)") @QueryParam("tag")  String tag,@ApiParam(value = "The account id to filter results for a particular user") @QueryParam("userAccountId")  Long userAccountId,@ApiParam(value = "The user display to filter results by (performs a wild-card search)") @QueryParam("userAccountDisplay")  String userAccountDisplay,@ApiParam(value = "The username to filter results by (performs a wild-card search)") @QueryParam("userAccountUsername")  String userAccountUsername,@ApiParam(value = "Determines how to group results. For example, passing in 'CREATED' will return results by date. Passing in 'ACCOUNT' will return results by user {TAG, CUSTOM_ID, TOKEN, MODEL, DEVICE_TYPE, DEVICE, DEVICE_OS, IP_ADDRESS, STATE, CITY, ZIP, COUNTRY, ACCOUNT, APPLICATION_ID, APPLICATION_NAME_BY_ID}", allowableValues="TAG_COUNT, TAG, TOKEN, MODEL, DEVICE_TYPE, DEVICE, DEVICE_OS, DEVICE_ID, IP_ADDRESS, STATE, CITY, ZIP, COUNTRY, CREATED, UPDATED, LAST_UPDATED, CLIENT_TIME, ACTIVE, CUSTOM_ID, CUSTOM_TYPE, CUSTOM_VALUE, CUSTOM_VALUE2, CUSTOM_LONG, CUSTOM_LONG2, CUSTOM_MESSAGE, CUSTOM_MESSAGE2, ACCOUNT_ID, ACCOUNT_USERNAME, ACCOUNT_DISPLAY, ACCOUNT_CREATED, ACCOUNT_GENDER, ACCOUNT_AGE_GROUP, APPLICATION_ID, APPLICATION_KEY, APPLICATION_NAME") @QueryParam("groupByRoot")  String groupByRoot,@ApiParam(value = "Determines how to group the nested data. {TAG, CUSTOM_ID, TOKEN, MODEL, DEVICE_TYPE, DEVICE, DEVICE_OS, IP_ADDRESS, STATE, CITY, ZIP, COUNTRY, ACCOUNT, APPLICATION_ID, APPLICATION_NAME_BY_ID}", allowableValues="TAG_COUNT, TAG, TOKEN, MODEL, DEVICE_TYPE, DEVICE, DEVICE_OS, DEVICE_ID, IP_ADDRESS, STATE, CITY, ZIP, COUNTRY, CREATED, UPDATED, LAST_UPDATED, CLIENT_TIME, ACTIVE, CUSTOM_ID, CUSTOM_TYPE, CUSTOM_VALUE, CUSTOM_VALUE2, CUSTOM_LONG, CUSTOM_LONG2, CUSTOM_MESSAGE, CUSTOM_MESSAGE2, ACCOUNT_ID, ACCOUNT_USERNAME, ACCOUNT_DISPLAY, ACCOUNT_CREATED, ACCOUNT_GENDER, ACCOUNT_AGE_GROUP, APPLICATION_ID, APPLICATION_KEY, APPLICATION_NAME") @QueryParam("groupBy")  String groupBy,@ApiParam(value = "Performs a unique query on the specified column. For example, passing in 'ACCOUNT' will return the number of unique users. {TAG, CUSTOM_ID, TOKEN, MODEL, DEVICE_TYPE, DEVICE, DEVICE_OS, IP_ADDRESS, STATE, CITY, ZIP, COUNTRY, ACCOUNT, APPLICATION_ID, NEW_ACCOUNT}", allowableValues="TAG_COUNT, TAG, TOKEN, MODEL, DEVICE_TYPE, DEVICE, DEVICE_OS, DEVICE_ID, IP_ADDRESS, STATE, CITY, ZIP, COUNTRY, CREATED, UPDATED, LAST_UPDATED, CLIENT_TIME, ACTIVE, CUSTOM_ID, CUSTOM_TYPE, CUSTOM_VALUE, CUSTOM_VALUE2, CUSTOM_LONG, CUSTOM_LONG2, CUSTOM_MESSAGE, CUSTOM_MESSAGE2, ACCOUNT_ID, ACCOUNT_USERNAME, ACCOUNT_DISPLAY, ACCOUNT_CREATED, ACCOUNT_GENDER, ACCOUNT_AGE_GROUP, APPLICATION_ID, APPLICATION_KEY, APPLICATION_NAME") @QueryParam("distinctCount")  String distinctCount,@ApiParam(value = "Determines whether the results will be sorted by day or by number of hits {CREATED, TAG_COUNT}", allowableValues="TAG_COUNT, TAG, TOKEN, MODEL, DEVICE_TYPE, DEVICE, DEVICE_OS, DEVICE_ID, IP_ADDRESS, STATE, CITY, ZIP, COUNTRY, CREATED, UPDATED, LAST_UPDATED, CLIENT_TIME, ACTIVE, CUSTOM_ID, CUSTOM_TYPE, CUSTOM_VALUE, CUSTOM_VALUE2, CUSTOM_LONG, CUSTOM_LONG2, CUSTOM_MESSAGE, CUSTOM_MESSAGE2, ACCOUNT_ID, ACCOUNT_USERNAME, ACCOUNT_DISPLAY, ACCOUNT_CREATED, ACCOUNT_GENDER, ACCOUNT_AGE_GROUP, APPLICATION_ID, APPLICATION_KEY, APPLICATION_NAME") @QueryParam("sortField")  String sortField,@ApiParam(value = "Determines whether to return results in descending order") @QueryParam("descending")  Boolean descending,@ApiParam(value = "Determines whether to return data that has empty or unknown values") @QueryParam("hideUnknown")  Boolean hideUnknown,@ApiParam(value = "Determines whether to return a JOSN or XML representation of the graph results", allowableValues="HTML, XML, JSON, CSV") @QueryParam("responseFormat")  String responseFormat,@ApiParam(value = "This parameter is deprecated.") @QueryParam("_l")  Integer l,@ApiParam(value = "Used to limit results to get a cleaner graph. The results that gets filtered out will be combined") @QueryParam("limit")  Integer limit,@ApiParam(value = "the current latitude of the user") @QueryParam("latitude")  Double latitude,@ApiParam(value = "the current longitude of the user") @QueryParam("longitude")  Double longitude,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.aggregatedFilteredUsage(version, deviceId, accountId, applicationId, appKey, startDate, endDate, deviceType, device, deviceOS, gender, ageGroup, country, state, city, zip, model, tag, userAccountId, userAccountDisplay, userAccountUsername, groupByRoot, groupBy, distinctCount, sortField, descending, hideUnknown, responseFormat, l, limit, latitude, longitude, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/orson/ai/docs")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Search Docs", notes = "Takes in a text string representing one or more sentences and it returns a list of documents which are related to the provided document.", response = OrsonAiProtoResponse.class, tags={ "Orson", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = OrsonAiProtoResponse.class)
    })
    public Response aiDocs(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "Sirqul Account Id", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "Doc", required = true) @QueryParam("doc") @NotNull  String doc,@ApiParam(value = "Return Topics") @QueryParam("return_topics")  Boolean returnTopics,@ApiParam(value = "Limit") @QueryParam("limit")  Integer limit,@ApiParam(value = "Offset") @QueryParam("offset")  Integer offset,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.aiDocs(version, accountId, doc, returnTopics, limit, offset, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/orson/ai/img")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Find images", notes = "Returns a list of URIs of images that match the text.", response = OrsonAiProtoResponse.class, tags={ "Orson", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = OrsonAiProtoResponse.class)
    })
    public Response aiFindImages(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "Sirqul Account Id", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "Text", required = true) @QueryParam("text") @NotNull  String text,@ApiParam(value = "Parse Flag") @QueryParam("parse_flag")  String parseFlag,@ApiParam(value = "Fetch Flag") @QueryParam("fetch_flag")  String fetchFlag,@ApiParam(value = "Size") @QueryParam("size")  String size,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.aiFindImages(version, accountId, text, parseFlag, fetchFlag, size, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/orson/ai/tags")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Search Tags", notes = "Search the tags column of user provided tags using this endpoint.", response = OrsonAiProtoResponse.class, tags={ "Orson", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = OrsonAiProtoResponse.class)
    })
    public Response aiTags(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "Sirqul Account Id", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "Tags", required = true) @QueryParam("tags") @NotNull  String tags,@ApiParam(value = "Conditional") @QueryParam("conditional")  String conditional,@ApiParam(value = "Limit") @QueryParam("limit")  Integer limit,@ApiParam(value = "Offset") @QueryParam("offset")  Integer offset,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.aiTags(version, accountId, tags, conditional, limit, offset, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/orson/ai/text")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Search Text", notes = "Search the movie text column of movie text using this endpoint.", response = OrsonAiProtoResponse.class, tags={ "Orson", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = OrsonAiProtoResponse.class)
    })
    public Response aiText(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "Sirqul Account Id", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "Terms", required = true) @QueryParam("terms") @NotNull  String terms,@ApiParam(value = "Conditional") @QueryParam("conditional")  String conditional,@ApiParam(value = "Limit") @QueryParam("limit")  Integer limit,@ApiParam(value = "Offset") @QueryParam("offset")  Integer offset,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.aiText(version, accountId, terms, conditional, limit, offset, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/invite/albumContest")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Invite to Contest", notes = "Allows a user to invite people to gain access to a contest. This will generate an invite token, which when used, will give the invitee access to a contest (whether it is private or not). The invitee will also become the user's friend when the invitation is accepted.", response = InviteResponse.class, tags={ "Invite", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = InviteResponse.class)
    })
    public Response albumContestInvite(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "a unique ID given by the device (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "the account ID of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "This parameter is deprecated.") @QueryParam("appId")  Long appId,@ApiParam(value = "the application key") @QueryParam("appKey")  String appKey,@ApiParam(value = "the album contest to share") @QueryParam("albumContestId")  Long albumContestId,@ApiParam(value = "the current latitude of the user") @QueryParam("latitude")  Double latitude,@ApiParam(value = "the current longitude of the user") @QueryParam("longitude")  Double longitude,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.albumContestInvite(version, deviceId, accountId, appId, appKey, albumContestId, latitude, longitude, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/invite/album")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Invite to Collection", notes = "Allows a user to invite people to gain access to a collection. This will generate an invite token, which when used, will give the invitee access to a collection (whether it is private or not). The invitee will also become the user's friend when the invitation is accepted.", response = InviteResponse.class, tags={ "Invite", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = InviteResponse.class)
    })
    public Response albumInvite(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "a unique ID given by the device (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "the account ID of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "This parameter is deprecated.") @QueryParam("appId")  Long appId,@ApiParam(value = "the application key") @QueryParam("appKey")  String appKey,@ApiParam(value = "the album to share") @QueryParam("albumId")  Long albumId,@ApiParam(value = "the current latitude of the user") @QueryParam("latitude")  Double latitude,@ApiParam(value = "the current longitude of the user") @QueryParam("longitude")  Double longitude,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.albumInvite(version, deviceId, accountId, appId, appKey, albumId, latitude, longitude, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/achievement/tier/search")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Searches an Achievement Tier", notes = "Searches a tier of an achievement (for developer/retailer use). User must have permissions to the application the achievement is created for.", response = AchievementTierResponse.class, tags={ "Achievement", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = AchievementTierResponse.class)
    })
    public Response apiVersionAchievementTierSearchPost(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "a unique id given by the device (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "the account id of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "the application key") @QueryParam("appKey")  String appKey,@ApiParam(value = "the keyword used to filter resutls with (this returns results that have the keyword in the title or the description of the achievement tier)") @QueryParam("keyword")  String keyword,@ApiParam(value = "filter results by achievementType (these are exact case sensitive matches)") @QueryParam("achievementType")  Long achievementType,@ApiParam(value = "filter results by the rankType (these are the exact case sensitive matches)") @QueryParam("rankType")  String rankType,@ApiParam(value = "the field to sort by. See {@link AchievementApiMap}") @QueryParam("sortField")  String sortField,@ApiParam(value = "determines whether the sort list is in descending or ascending order (of the achievement)") @QueryParam("descending")  Boolean descending,@ApiParam(value = "determines whether the results are in descending or ascending order by the tier goal count (after the initial sort on the achievement)") @QueryParam("descendingGoal")  Boolean descendingGoal,@ApiParam(value = "The start of the index for pagination") @QueryParam("start")  Long start,@ApiParam(value = "the limit for pagination (has a hard limit of 1000)") @QueryParam("limit")  Long limit,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.apiVersionAchievementTierSearchPost(version, deviceId, accountId, appKey, keyword, achievementType, rankType, sortField, descending, descendingGoal, start, limit, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/album/approve")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Approve Album", notes = "Sets the approval status of an Album.", response = SirqulResponse.class, tags={ "Album", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response approveAlbum(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The ID of the album", required = true) @QueryParam("albumId") @NotNull  Long albumId,@ApiParam(value = "A unique ID given by the device (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "The account ID of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "The approval status to set {PENDING, REJECTED, APPROVED, FEATURED}", allowableValues="PENDING, REJECTED, APPROVED, FEATURED") @QueryParam("approvalStatus")  String approvalStatus,@ApiParam(value = "Sets whether the album should be marked as \"verified\"") @QueryParam("verified")  Boolean verified,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.approveAlbum(version, albumId, deviceId, accountId, approvalStatus, verified, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/consumer/album/contest/approve")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Approve Contest", notes = "Sets the approval status of a contest.", response = SirqulResponse.class, tags={ "Contest", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response approveAlbumContest(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The ID of the album contest", required = true) @QueryParam("albumContestId") @NotNull  Long albumContestId,@ApiParam(value = "The approval status to set {PENDING, REJECTED, APPROVED, FEATURED}", required = true, allowableValues="PENDING, REJECTED, APPROVED, FEATURED") @QueryParam("approvalStatus") @NotNull  String approvalStatus,@ApiParam(value = "A unique ID given by the device (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "The account ID of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.approveAlbumContest(version, albumContestId, approvalStatus, deviceId, accountId, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/permissionable/approve")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Approve Permissionable", notes = "Sets the approval status of a permissionable object.", response = SirqulResponse.class, tags={ "User Permissions", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response approvePermissionable(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The permissionable type of the object", required = true, allowableValues="ACCOUNT, GAMELEVEL, ALBUM_CONTEST, THEME_DESCRIPTOR, SCHEDULED_NOTIFICATION, TASK, TRIGGER") @QueryParam("permissionableType") @NotNull  String permissionableType,@ApiParam(value = "The id of the permissionable object", required = true) @QueryParam("permissionableId") @NotNull  Long permissionableId,@ApiParam(value = "A unique ID given by the device (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "The account ID of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "The approval status to set {PENDING, REJECTED, APPROVED, FEATURED}", allowableValues="PENDING, REJECTED, APPROVED, FEATURED", defaultValue = "APPROVED") @DefaultValue("APPROVED") @QueryParam("approvalStatus")  String approvalStatus,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.approvePermissionable(version, permissionableType, permissionableId, deviceId, accountId, approvalStatus, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/route/{routeId}/approve")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Approve Route", notes = "Approve a route", response = Route.class, tags={ "Route", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = Route.class)
    })
    public Response approveRoute(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the id of the route to approve", required = true) @PathParam("routeId") @NotNull  Long routeId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.approveRoute(version, routeId, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/asset/download/{filename}")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Download Asset", notes = "Downloads an asset from the server for assets that have been uploaded to the server.", response = SirqulResponse.class, tags={ "Asset", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response assetDownload(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the filename in the following formats: {assetId}-{suffix}.{extension} | {assetId}.{extension} | {assetId}", required = true) @PathParam("filename") @NotNull  @Pattern(regexp=".+") String filename,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.assetDownload(version, filename, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/asset/morph")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Convert Offer to Creative", notes = "Converts an offer image + text into a creative image.", response = AssetShortResponse.class, tags={ "Asset", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = AssetShortResponse.class)
    })
    public Response assetMorph(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "offer id used for inserting offer text/flavor", required = true) @QueryParam("offerId") @NotNull  Long offerId,@ApiParam(value = "the ad size used for selecting a format for the creative image", required = true, allowableValues="CONFIG, BANNER, LEADERBOARD, SKYSCRAPER, VIDEO, ZIP, INTERSTITIAL, CUSTOM1, CUSTOM2, CUSTOM3, CUSTOM4, CUSTOM5, CUSTOM6, CUSTOM7, CUSTOM8, CUSTOM9, CUSTOM10") @QueryParam("adSize") @NotNull  String adSize,@ApiParam(value = "used for inserting the newly created image into") @QueryParam("creativeId")  Long creativeId,@ApiParam(value = "total width of the creative image") @QueryParam("width")  Integer width,@ApiParam(value = "total height of the creative image") @QueryParam("height")  Integer height,@ApiParam(value = "the size of the background") @QueryParam("backgroundSize")  String backgroundSize,@ApiParam(value = "the template to use") @QueryParam("template")  String template,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.assetMorph(version, offerId, adSize, creativeId, width, height, backgroundSize, template, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/assignment/assignee/search")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Search Assignment Assignees", notes = "Search for avaiable users for creating or updating assignment.", response = AccountMiniResponse.class, responseContainer = "List", tags={ "Assignment", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = AccountMiniResponse.class, responseContainer = "List")
    })
    public Response assigmentAssigneeAccountSearch(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The account id sending the request", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "The keyword to filter the returned results") @QueryParam("keyword")  String keyword,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.assigmentAssigneeAccountSearch(version, accountId, keyword, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/employee/assign")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Assign Employee", notes = "Assign An existing account to be an employee", response = EmployeeResponse.class, tags={ "Employee", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = EmployeeResponse.class)
    })
    public Response assignEmployee(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The account id of the logged in user", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "The account id of the manager to assign under", required = true) @QueryParam("managerAccountId") @NotNull  Long managerAccountId,@ApiParam(value = "The account id of the user to be assigned as employee", required = true) @QueryParam("employeeAccountId") @NotNull  Long employeeAccountId,@ApiParam(value = "The role to assign to the employee (e.g. RETAILER or RETAILER_LIMITED)") @QueryParam("role")  String role,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.assignEmployee(version, accountId, managerAccountId, employeeAccountId, role, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/employee/assignToLocation")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Assign Employee to Location", notes = "Assign or unassign the account to a retailer location.", response = SirqulResponse.class, tags={ "Employee", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response assignToLocationEmployee(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The account id of the logged in user", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "The retailer location to apply the change to", required = true) @QueryParam("retailerLocationId") @NotNull  Long retailerLocationId,@ApiParam(value = "The account id of the user to apply the change to") @QueryParam("employeeAccountId")  Long employeeAccountId,@ApiParam(value = "If true (default) assign to the location, otherwise remove from the retailer", defaultValue = "true") @DefaultValue("true") @QueryParam("assign")  Boolean assign,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.assignToLocationEmployee(version, accountId, retailerLocationId, employeeAccountId, assign, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/assignment/create")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Create Assignment", notes = "Create an assignment.", response = AssignmentResponse.class, tags={ "Assignment", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = AssignmentResponse.class)
    })
    public Response assignmentCreate(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the user account id", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "the name for the assignment", required = true) @QueryParam("name") @NotNull  String name,@ApiParam(value = "the account id to assign to", required = true) @QueryParam("assigneeAccountId") @NotNull  Long assigneeAccountId,@ApiParam(value = "the desciprtion for the assignment") @QueryParam("description")  String description,@ApiParam(value = "the retailer location id") @QueryParam("retailerLocationId")  Long retailerLocationId,@ApiParam(value = "the tags") @QueryParam("tags")  String tags,@ApiParam(value = "determines whether the assignment is active or inactive") @QueryParam("active")  Boolean active,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.assignmentCreate(version, accountId, name, assigneeAccountId, description, retailerLocationId, tags, active, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/assignment/delete")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Delete Assignment", notes = "Delete an assignment.", response = SirqulResponse.class, tags={ "Assignment", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response assignmentDelete(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the user account id", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "the assignment id", required = true) @QueryParam("assignmentId") @NotNull  Long assignmentId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.assignmentDelete(version, accountId, assignmentId, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/assignment/get")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Get Assignment", notes = "Get the details of an assignment.", response = AssignmentResponse.class, tags={ "Assignment", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = AssignmentResponse.class)
    })
    public Response assignmentGet(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the user account id", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "the assignment id", required = true) @QueryParam("assignmentId") @NotNull  Long assignmentId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.assignmentGet(version, accountId, assignmentId, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/assignment/search")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Search Assignments", notes = "Search for assignments by the given parameters.", response = AssignmentResponse.class, responseContainer = "List", tags={ "Assignment", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = AssignmentResponse.class, responseContainer = "List")
    })
    public Response assignmentSearch(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the account sending the request", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "sort by table field", required = true, allowableValues="ID, CREATED, UPDATED, DELETED, SEARCH_TAGS, ACTIVE, ASSIGNEE_ID, CREATOR_ID, LOCATION_ID, LOCATION_NAME, CURRENT_STATUS, CURRENT_STATUS_TYPE, STATUSES") @QueryParam("sortField") @NotNull  String sortField,@ApiParam(value = "return results in descending order or not", required = true) @QueryParam("descending") @NotNull  Boolean descending,@ApiParam(value = "return active results only or not", required = true) @QueryParam("activeOnly") @NotNull  Boolean activeOnly,@ApiParam(value = "The record to begin the return set on", required = true) @QueryParam("start") @NotNull  Integer start,@ApiParam(value = "The number of records to return", required = true) @QueryParam("limit") @NotNull  Integer limit,@ApiParam(value = "the creator of the assignment") @QueryParam("creatorAccountId")  Long creatorAccountId,@ApiParam(value = "filter results by assignee accounts. If not provided, all assignments that are assigned to accounts that are managed by the requested account will be returned.") @QueryParam("assigneeAccountIds")  String assigneeAccountIds,@ApiParam(value = "filter results by retailer locations") @QueryParam("retailerLocationIds")  String retailerLocationIds,@ApiParam(value = "filter results by assignment status", allowableValues="NEW, IN_PROGRESS, SUBSCRIBED, ARCHIVED") @QueryParam("currentStatusType")  String currentStatusType,@ApiParam(value = "filter results by keyword search that matches the assignee, creator, or retailer location name") @QueryParam("keyword")  String keyword,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.assignmentSearch(version, accountId, sortField, descending, activeOnly, start, limit, creatorAccountId, assigneeAccountIds, retailerLocationIds, currentStatusType, keyword, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/assignment/status/create")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Create Assignment Status", notes = "Create an assignment status.", response = AssignmentStatusResponse.class, tags={ "Assignment", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = AssignmentStatusResponse.class)
    })
    public Response assignmentStatusCreate(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the user account id", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "the assignment id", required = true) @QueryParam("assignmentId") @NotNull  Long assignmentId,@ApiParam(value = "the scheduled notification id for reminders") @QueryParam("scheduledNotificationId")  Long scheduledNotificationId,@ApiParam(value = "the type of to do. Possible values include: SITE_VISIT, PHONE, RECONTACT, RENEWAL, CREDIT", allowableValues="SITE_VISIT, PHONE, RECONTACT, RENEWAL, CREDIT") @QueryParam("toDo")  String toDo,@ApiParam(value = "the connection type. Possible values include: INITIAL, FOLLOW_UP, DECLINED", allowableValues="INITIAL, FOLLOW_UP, DECLINED") @QueryParam("connection")  String connection,@ApiParam(value = "the communication method type. Possible values include: PHONE, SITE_VISIT, EMAIL", allowableValues="PHONE, SITE_VISIT, EMAIL") @QueryParam("method")  String method,@ApiParam(value = "the status type. Possible values include: ARCHIVED, SUBSCRIBED, UNSUBSCRIBED, CONTACTED, DECLINED, NOT_CONTACTED", allowableValues="ARCHIVED, SUBSCRIBED, UNSUBSCRIBED, CONTACTED, DECLINED, NOT_CONTACTED") @QueryParam("status")  String status,@ApiParam(value = "the closure type. Possible values include: PHONE, SITE_VISIT, PHONE_SITE, WEB", allowableValues="PHONE, SITE_VISIT, PHONE_SITE, WEB") @QueryParam("closure")  String closure,@ApiParam(value = "the message from the assignee") @QueryParam("message")  String message,@ApiParam(value = "the date to follow up by") @QueryParam("followUp")  Long followUp,@ApiParam(value = "determines whether the assignment status is active or inactive") @QueryParam("active")  Boolean active,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.assignmentStatusCreate(version, accountId, assignmentId, scheduledNotificationId, toDo, connection, method, status, closure, message, followUp, active, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/assignment/status/delete")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Deletes Assignment Status", notes = "Deletes an assignment status.", response = SirqulResponse.class, tags={ "Assignment", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response assignmentStatusDelete(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the user account id", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "the assignment status id", required = true) @QueryParam("assignmentStatusId") @NotNull  Long assignmentStatusId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.assignmentStatusDelete(version, accountId, assignmentStatusId, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/assignment/status/get")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Get Assignment Status", notes = "Get an assignment status.", response = AssignmentStatusResponse.class, tags={ "Assignment", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = AssignmentStatusResponse.class)
    })
    public Response assignmentStatusGet(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the user account id", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "the assignment status id", required = true) @QueryParam("assignmentStatusId") @NotNull  Long assignmentStatusId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.assignmentStatusGet(version, accountId, assignmentStatusId, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/assignment/status/search")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Search Assignment Statuses", notes = "Search on assignment statuses.", response = AssignmentStatusResponse.class, responseContainer = "List", tags={ "Assignment", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = AssignmentStatusResponse.class, responseContainer = "List")
    })
    public Response assignmentStatusSearch(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the user account id", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "the field to sort by. Possible values include: ID, CREATED, UPDATED, DELETED, SEARCH_TAGS, ACTIVE, CURRENT_STATUS, TODO, CONNECTION, METHOD, STATUS, CLOSURE, MESSAGE, FOLLOW_UP", required = true, allowableValues="ID, CREATED, UPDATED, DELETED, SEARCH_TAGS, ACTIVE, ASSIGNEE_ID, CREATOR_ID, LOCATION_ID, LOCATION_NAME, CURRENT_STATUS, CURRENT_STATUS_TYPE, TODO, CONNECTION, METHOD, STATUS, CLOSURE, MESSAGE, FOLLOW_UP") @QueryParam("sortField") @NotNull  String sortField,@ApiParam(value = "determines whether the sorted list is in descending or ascending order", required = true) @QueryParam("descending") @NotNull  Boolean descending,@ApiParam(value = "determines whether to only return active results", required = true) @QueryParam("activeOnly") @NotNull  Boolean activeOnly,@ApiParam(value = "the start index for pagination", required = true) @QueryParam("start") @NotNull  Integer start,@ApiParam(value = "the limit for pagination", required = true) @QueryParam("limit") @NotNull  Integer limit,@ApiParam(value = "the assignment id") @QueryParam("assignmentId")  Long assignmentId,@ApiParam(value = "filter results by the account who created the status") @QueryParam("creatorAccountId")  Long creatorAccountId,@ApiParam(value = "filter results by the assignee account") @QueryParam("assigneeAccountId")  Long assigneeAccountId,@ApiParam(value = "filter results by by retailer location") @QueryParam("retailerLocationId")  Long retailerLocationId,@ApiParam(value = "filter results by the status type", allowableValues="ARCHIVED, SUBSCRIBED, UNSUBSCRIBED, CONTACTED, DECLINED, NOT_CONTACTED") @QueryParam("statusType")  String statusType,@ApiParam(value = "filter results by keyword search") @QueryParam("keyword")  String keyword,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.assignmentStatusSearch(version, accountId, sortField, descending, activeOnly, start, limit, assignmentId, creatorAccountId, assigneeAccountId, retailerLocationId, statusType, keyword, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/assignment/status/update")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Update Assignment Status", notes = "Updates an assignment status.", response = AssignmentStatusResponse.class, tags={ "Assignment", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = AssignmentStatusResponse.class)
    })
    public Response assignmentStatusUpdate(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the user account id", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "the assignment status id", required = true) @QueryParam("assignmentStatusId") @NotNull  Long assignmentStatusId,@ApiParam(value = "the scheduled notification id for reminders") @QueryParam("scheduledNotificationId")  Long scheduledNotificationId,@ApiParam(value = "the type of to do. Possible values include: SITE_VISIT, PHONE, RECONTACT, RENEWAL, CREDIT", allowableValues="SITE_VISIT, PHONE, RECONTACT, RENEWAL, CREDIT") @QueryParam("toDo")  String toDo,@ApiParam(value = "the connection type. Possible values include: INITIAL, FOLLOW_UP, DECLINED", allowableValues="INITIAL, FOLLOW_UP, DECLINED") @QueryParam("connection")  String connection,@ApiParam(value = "the communication method type. Possible values include: PHONE, SITE_VISIT, EMAIL", allowableValues="PHONE, SITE_VISIT, EMAIL") @QueryParam("method")  String method,@ApiParam(value = "the status type. Possible values include: ARCHIVED, SUBSCRIBED, UNSUBSCRIBED, CONTACTED, DECLINED, NOT_CONTACTED", allowableValues="ARCHIVED, SUBSCRIBED, UNSUBSCRIBED, CONTACTED, DECLINED, NOT_CONTACTED") @QueryParam("status")  String status,@ApiParam(value = "the closure type. Possible values include: PHONE, SITE_VISIT, PHONE_SITE, WEB", allowableValues="PHONE, SITE_VISIT, PHONE_SITE, WEB") @QueryParam("closure")  String closure,@ApiParam(value = "the message from the assignee") @QueryParam("message")  String message,@ApiParam(value = "the date to follow up by") @QueryParam("followUp")  Long followUp,@ApiParam(value = "determines whether the assignment status is active or inactive") @QueryParam("active")  Boolean active,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.assignmentStatusUpdate(version, accountId, assignmentStatusId, scheduledNotificationId, toDo, connection, method, status, closure, message, followUp, active, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/assignment/update")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Update Assignment", notes = "Updates an assignment.", response = AssignmentResponse.class, tags={ "Assignment", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = AssignmentResponse.class)
    })
    public Response assignmentUpdate(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the user account id", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "the assignment id", required = true) @QueryParam("assignmentId") @NotNull  Long assignmentId,@ApiParam(value = "the name of the assignment") @QueryParam("name")  String name,@ApiParam(value = "the description of the assignment") @QueryParam("description")  String description,@ApiParam(value = "the account id to assign to") @QueryParam("assigneeAccountId")  Long assigneeAccountId,@ApiParam(value = "the retailer location id") @QueryParam("retailerLocationId")  Long retailerLocationId,@ApiParam(value = "the tags") @QueryParam("tags")  String tags,@ApiParam(value = "determines whether the assignment is active or inactive") @QueryParam("active")  Boolean active,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.assignmentUpdate(version, accountId, assignmentId, name, description, assigneeAccountId, retailerLocationId, tags, active, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/event/attend")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Attend Event", notes = " Specify whether the user is attending an event at a particular location. This can also be used as a \"check-in\" action.", response = OfferResponse.class, tags={ "Event", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = OfferResponse.class)
    })
    public Response attendEvent(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The device id (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "The account id (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "The application of where to send notifications about the attend action") @QueryParam("appKey")  String appKey,@ApiParam(value = "The scheduled broadcast or marketing experience id") @QueryParam("listingId")  Long listingId,@ApiParam(value = "The retailer location where the event is being held") @QueryParam("retailerLocationId")  Long retailerLocationId,@ApiParam(value = "The actual event being held") @QueryParam("offerLocationId")  Long offerLocationId,@ApiParam(value = "The wallet item to update the status of, if provided then ignore the listingId, retailerLocationId, and the offerLocationId") @QueryParam("transactionId")  Long transactionId,@ApiParam(value = "Sets whether the user is: undecided (0), attending (1), attending and checked in (2), or not attending (3)") @QueryParam("status")  Integer status,@ApiParam(value = "The location of the status update") @QueryParam("latitude")  Double latitude,@ApiParam(value = "The location of the status update") @QueryParam("longitude")  Double longitude,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.attendEvent(version, deviceId, accountId, appKey, listingId, retailerLocationId, offerLocationId, transactionId, status, latitude, longitude, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/twitter/authorize")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Authorize Twitter", notes = "Makes an authorization call to twitter for a user to login and allow any app permissions.", response = SirqulResponse.class, tags={ "Twitter", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response authorizeTwitter(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the application key", required = true) @QueryParam("appKey") @NotNull  String appKey,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.authorizeTwitter(version, appKey, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/orson/ai/batch")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Batch Analysis", notes = "Run several types of analysis on an audio or video file in a single API call, instead of calling several operations for the same file..", response = OrsonAiBatchResponse.class, tags={ "Orson", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = OrsonAiBatchResponse.class)
    })
    public Response batch(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "Sirqul Account Id", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "A third-party account id that is meaningful to your systems") @QueryParam("thirdPartyAccountId")  String thirdPartyAccountId,@ApiParam(value = "The number of topics to return") @QueryParam("limit")  Integer limit,@ApiParam(value = "The comma-delimited list of A/V batch analysis operations to run on this file. Possible values: Transcript,Topics,Emotions") @QueryParam("operations")  String operations,@ApiParam(value = "An uploaded recording to analyze (Currently limited to 10MB)") @QueryParam("file")  File _file,@ApiParam(value = "A recording file to download and analyze (Size limit: 1GB)") @QueryParam("url")  String url,@ApiParam(value = "When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open") @QueryParam("callback")  String paramCallback,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.batch(version, accountId, thirdPartyAccountId, limit, operations, _file, url, paramCallback, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/note/batch")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Batch Note Operation", notes = "Perform a batch operation on notes for a notable object (for example: DELETE_ALL_NOTES_IN_NOTABLE). ", response = SirqulResponse.class, tags={ "Note", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response batchOperation(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The id of the notable object the batch operation will affect", required = true) @QueryParam("notableId") @NotNull  Long notableId,@ApiParam(value = "The notable object type (for example ALBUM, ASSET, OFFER, etc.)", required = true) @QueryParam("notableType") @NotNull  String notableType,@ApiParam(value = "The device id (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "The account id of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "The batch operation to perform (e.g., DELETE_ALL_NOTES_IN_NOTABLE). Optional.") @QueryParam("batchOperation")  String batchOperation,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.batchOperation(version, notableId, notableType, deviceId, accountId, batchOperation, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/tracking/batch/create")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Create Batch Tracking", notes = "Batch create tracking legs", response = Leg.class, responseContainer = "List", tags={ "Tracking", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = Leg.class, responseContainer = "List")
    })
    public Response batchSaveTracking(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "JSON array of tracking legs ```json [   \"distance\": \"0.08\",   \"duration\": \"10000\",   \"startLatitude\": \"47.614603\",   \"startLongitude\": \"-122.350518\",   \"endLatitude\": \"47.614384\",   \"endLongitude\": \"-122.349161\",   \"startDate\": \"1361924010000\",   \"endDate\": \"1361924020000\",   \"steps\": [     {       \"distance\": \"0.03\",       \"duration\": \"5000\",       \"startLat\": \"47.614603\",       \"startLng\": \"-122.350518\",       \"startDate\": \"1361924010000\",       \"endLat\": \"47.614941\",       \"endLng\": \"-122.350062\",       \"endDate\": \"1361924015000\"     },{       \"distance\": \"0.05\",       \"duration\": \"5000\",       \"startLat\": \"47.614941\",       \"startLng\": \"-122.350062\",       \"startDate\": \"1361924015000\",       \"endLat\": \"47.614384\",       \"endLng\": \"-122.349161\",       \"endDate\": \"1361924020000\"     }   ] ] ``` ", required = true) @QueryParam("data") @NotNull  String data,@ApiParam(value = "the device id (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "the account id of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "Whether to generate accounts for tracking entries when the owner does not exist") @QueryParam("generateAccounts")  Boolean generateAccounts,@ApiParam(value = "Whether to update the account's current location from the incoming tracking data") @QueryParam("updateAccountLocations")  Boolean updateAccountLocations,@ApiParam(value = "The default tag to apply to incoming legs when no tag is provided", defaultValue = "PASSIVE") @DefaultValue("PASSIVE") @QueryParam("defaultTag")  String defaultTag,@ApiParam(value = "") @QueryParam("slaveUID")  String slaveUID,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.batchSaveTracking(version, data, deviceId, accountId, generateAccounts, updateAccountLocations, defaultTag, slaveUID, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/retailer/offer/location/batchUpdate")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Update Offer Locations", notes = "Batch update offer locations.", response = SirqulResponse.class, tags={ "Offer", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response batchUpdateOfferLocations(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "JSON string in the following format: ```json [{   \"offerLocationId\": 1705,   \"latitude\": 54.0,   \"longitude\": -122.0,   \"altitude\": 1.0,   \"locationDetail\": \"floor 1\",   \"locationDescription\": \"behind the Coke sign\" }, {   \"offerLocationId\": 1704,   \"latitude\": 54.1,   \"longitude\": -122.1 }] ``` ", required = true) @QueryParam("data") @NotNull  String data,@ApiParam(value = "The device id (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "The account id of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.batchUpdateOfferLocations(version, data, deviceId, accountId, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/account/block")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Block Account", notes = "Moves or removes an account into the user's blocked group.", response = SirqulResponse.class, tags={ "Account", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response blockAccount(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The id of the account to be blocked/unblocked", required = true) @QueryParam("accountIdBeingBlocked") @NotNull  Long accountIdBeingBlocked,@ApiParam(value = "The device id (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "The account id of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "Determines whether the account is blocked or unblocked", defaultValue = "true") @DefaultValue("true") @QueryParam("blockFlagValue")  Boolean blockFlagValue,@ApiParam(value = "Determines whether the account is removed from all other groups if blocked", defaultValue = "false") @DefaultValue("false") @QueryParam("removeFromGroupsIfBlocked")  Boolean removeFromGroupsIfBlocked,@ApiParam(value = "The current latitude of the user") @QueryParam("latitude")  Double latitude,@ApiParam(value = "The current longitude of the user") @QueryParam("longitude")  Double longitude,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.blockAccount(version, accountIdBeingBlocked, deviceId, accountId, blockFlagValue, removeFromGroupsIfBlocked, latitude, longitude, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/location/trilaterate/cache")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Create Trilateration Data with File", notes = "Creates trilateration samples for a source device (i.e. a router).", response = SirqulResponse.class, tags={ "Location", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response cacheTrilaterationData(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The unique identifier of the source device", required = true) @QueryParam("udid") @NotNull  String udid,@ApiParam(value = "The current timestamp of the source device") @QueryParam("sourceTime")  Long sourceTime,@ApiParam(value = "the minimum number of Edysen devices that must be used to be able to trilaterate a device") @QueryParam("minimumSampleSize")  Integer minimumSampleSize,@ApiParam(value = "The json formated sample data:  ```json {    \"count\": 2,   \"timespan\": 10,    \"samples\": [     {       \"deviceId\": \"device1\",       \"randomizedId\": true,        \"deviceSignature\": \"probe:xyz...\",        \"alternativeId\":\"adc123\",        \"rssi\": [-63, -75]     },      {       \"deviceId\": \"device2\",       \"randomizedId\": true,        \"deviceSignature\": \"probe:xyz...\",        \"alternativeId\": \"adc123\",        \"rssi\": [-83, -79]     }   ] } ``` ") @QueryParam("data")  String data,@ApiParam(value = "Binary file containing data (multipart upload)") @QueryParam("dataFile")  File dataFile,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.cacheTrilaterationData(version, udid, sourceTime, minimumSampleSize, data, dataFile, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/location/trilaterate/cache/submit")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Create Trilateration Data with Rest", notes = "Creates trilateration samples for a source device (i.e. a router).", response = SirqulResponse.class, tags={ "Location", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response cacheTrilaterationDataGzip(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "") @Valid  TrilatCacheRequest body,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.cacheTrilaterationDataGzip(version, body, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/shipment/{id}/cancel")
    
    
    @io.swagger.annotations.ApiOperation(value = "Cancel Shipment", notes = "Remove shipment from route", response = Void.class, tags={ "Shipment", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = Void.class)
    })
    public Response cancelShipment(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the id of the shipment to cancel", required = true) @PathParam("id") @NotNull  Long id,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.cancelShipment(version, id, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/category/distancesearch")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Search Categories by Distance", notes = "Search for categories by distance.", response = CategoryResponse.class, responseContainer = "List", tags={ "Category", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = CategoryResponse.class, responseContainer = "List")
    })
    public Response categoryDistanceSearch(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The account id of the user") @QueryParam("accountId")  Long accountId,@ApiParam(value = "The keyword string to search on") @QueryParam("keyword")  String keyword,@ApiParam(value = "the appKey of the application to retrieve categories for, if not specified then search on the global application.") @QueryParam("appKey")  String appKey,@ApiParam(value = "Restrict the search by specific categories") @QueryParam("categoryIds")  String categoryIds,@ApiParam(value = "Restrict the search by specific parent categories so that only its sub children are searched.") @QueryParam("parentCategoryIds")  String parentCategoryIds,@ApiParam(value = "Restrict the search to only those categories with no parent category assigned.") @QueryParam("rootOnly")  Boolean rootOnly,@ApiParam(value = "The column to sort the search on. Possible values include: ID, CREATED, UPDATED, ACTIVE, NAME, DISPLAY", allowableValues="ID, CREATED, UPDATED, DELETED, SEARCH_TAGS, ACTIVE, NAME, DISPLAY", defaultValue = "DISPLAY") @DefaultValue("DISPLAY") @QueryParam("sortField")  String sortField,@ApiParam(value = "The group of categories to return: ALL, GLOBAL or MINE. ALL returns both global and application specific matches, GLOBAL only returns global matches, and MINE only returns the application specific matches. If not provided search on the application provided.", allowableValues="ALL, GLOBAL, MINE") @QueryParam("responseGroup")  String responseGroup,@ApiParam(value = "The order to return the search results", defaultValue = "false") @DefaultValue("false") @QueryParam("descending")  Boolean descending,@ApiParam(value = "The record to begin the return set on", defaultValue = "0") @DefaultValue("0") @QueryParam("start")  Integer start,@ApiParam(value = "The number of records to return", defaultValue = "20") @DefaultValue("20") @QueryParam("limit")  Integer limit,@ApiParam(value = "Determines whether to return only active categories", defaultValue = "true") @DefaultValue("true") @QueryParam("activeOnly")  Boolean activeOnly,@ApiParam(value = "Determines whether to return extra info about the category's \"Participant\" reference") @QueryParam("returnExternal")  Boolean returnExternal,@ApiParam(value = "If true search categories using the exact keyword, if false then do a partial match (like) search.") @QueryParam("exactMatch")  Boolean exactMatch,@ApiParam(value = "Filters results by the Category's type") @QueryParam("type")  String type,@ApiParam(value = "Filters results by externalType") @QueryParam("externalType")  String externalType,@ApiParam(value = "Filters results to only return Categories that have been referenced by a minimum number of Offers") @QueryParam("minOfferCount")  Integer minOfferCount,@ApiParam(value = "the latitude of where the search is centered on") @QueryParam("latitude")  Double latitude,@ApiParam(value = "the longitude of where the search is centered on") @QueryParam("longitude")  Double longitude,@ApiParam(value = "the maximum range the category can be from the center") @QueryParam("range")  Double range,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.categoryDistanceSearch(version, accountId, keyword, appKey, categoryIds, parentCategoryIds, rootOnly, sortField, responseGroup, descending, start, limit, activeOnly, returnExternal, exactMatch, type, externalType, minOfferCount, latitude, longitude, range, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/disbursement/check")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Check Disbursements", notes = "Checks the status of a captured disbrusement to see if it has been settled.", response = DisbursementResponse.class, tags={ "Disbursement", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = DisbursementResponse.class)
    })
    public Response checkDisbursements(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the ID of the disbursement being checked on", required = true) @QueryParam("disbursementId") @NotNull  Long disbursementId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.checkDisbursements(version, disbursementId, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/pathing/compute")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Calculate Path", notes = "Calculates the shortest path from point to point on a grid", response = PathingResponse.class, tags={ "Pathing", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = PathingResponse.class)
    })
    public Response computePath(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the data to with start, end point and exclusion points", required = true) @QueryParam("data") @NotNull  String data,@ApiParam(value = "the system of measurement for directions: {METRIC, IMPERIAL}", required = true, allowableValues="METRIC, IMPERIAL") @QueryParam("units") @NotNull  String units,@ApiParam(value = "determines whether to reduce the path to go in diagonal lines", required = true) @QueryParam("reducePath") @NotNull  Boolean reducePath,@ApiParam(value = "determines whether to return text directions", required = true) @QueryParam("directions") @NotNull  Boolean directions,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.computePath(version, data, units, reducePath, directions, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/routing/compute")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Compute Route", notes = "This service finds the most optimal routes for delivering items between locations (reducing transit time/resources). It can take in a list of vehicles and a list of items (to be transported).All load items have pick-up and drop-off locations with time windows for when the item is expected to be picked-up and dropped-off. ", response = RoutingListResponse.class, tags={ "Routing", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = RoutingListResponse.class)
    })
    public Response computeRouting(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "Json object containing inputs for generating the routes. See description for more info. Also see RoutingRequest", required = true) @QueryParam("data") @NotNull  String data,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.computeRouting(version, data, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/queue/consumer/create")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Create Consumer", notes = "Create a connection to an existing amqp queue and register as a consumer.", response = QueueResponse.class, tags={ "AMQP", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = QueueResponse.class)
    })
    public Response consumerCreate(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The application key to use when creating an analytic or service request. The account needs to have permissions to the applicaton or it will be denied.", required = true) @QueryParam("appKey") @NotNull  String appKey,@ApiParam(value = "The name of the queue to connect to", required = true) @QueryParam("name") @NotNull  String name,@ApiParam(value = "The hostname of the server the queue is hosted on", required = true) @QueryParam("hostname") @NotNull  String hostname,@ApiParam(value = "The username to access the server the queue is hosted on", required = true) @QueryParam("username") @NotNull  String username,@ApiParam(value = "The password to access the queue to connect to", required = true) @QueryParam("password") @NotNull  String password,@ApiParam(value = "The data mapping information in the format of AMQPRequest", required = true) @QueryParam("dataMapping") @NotNull  String dataMapping,@ApiParam(value = "The client deviceID") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "The logged in user ID") @QueryParam("accountId")  Long accountId,@ApiParam(value = "The port of the server the queue is hosted on", defaultValue = "5672") @DefaultValue("5672") @QueryParam("port")  Integer port,@ApiParam(value = "The virtual host defined on the server the queue is associated on") @QueryParam("virtualHost")  String virtualHost,@ApiParam(value = "The exchanger of the queue to connect to") @QueryParam("exchanger")  String exchanger,@ApiParam(value = "The exchanger type of the queue to connect to") @QueryParam("exchangerType")  String exchangerType,@ApiParam(value = "The number of workers to generate ", defaultValue = "1") @DefaultValue("1") @QueryParam("workers")  Integer workers,@ApiParam(value = "Use SSL") @QueryParam("useSSL")  Boolean useSSL,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.consumerCreate(version, appKey, name, hostname, username, password, dataMapping, deviceId, accountId, port, virtualHost, exchanger, exchangerType, workers, useSSL, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/queue/consumer/update")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Update Consumer", notes = "Update an existing amqp queue's data mapping.", response = QueueResponse.class, tags={ "AMQP", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = QueueResponse.class)
    })
    public Response consumerUpdate(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The application key to use when creating an analytic or service request. The account needs to have permissions to the applicaton or it will be denied.", required = true) @QueryParam("appKey") @NotNull  String appKey,@ApiParam(value = "The queue to update", required = true) @QueryParam("queueId") @NotNull  Long queueId,@ApiParam(value = "The data mapping information in the format of AMQPRequest", required = true) @QueryParam("dataMapping") @NotNull  String dataMapping,@ApiParam(value = "The client deviceID") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "The logged in user ID") @QueryParam("accountId")  Long accountId,@ApiParam(value = "Use SSL") @QueryParam("useSSL")  Boolean useSSL,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.consumerUpdate(version, appKey, queueId, dataMapping, deviceId, accountId, useSSL, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/route/{routeId}/copy")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Copy Route", notes = "Make an copy of the given route with optional overriding properties", response = Route.class, tags={ "Route", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = Route.class)
    })
    public Response copyRoute(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the id of the route to duplicate", required = true) @PathParam("routeId") @NotNull  Long routeId,@ApiParam(value = "") @Valid  Route body,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.copyRoute(version, routeId, body, securityContext);
    }
    @javax.ws.rs.PUT
    @Path("/cargo/dependent/{accountId}")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Create Dependent", notes = "Create dependent of the account", response = SirqulResponse.class, tags={ "Dependent", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response create(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the id of the parent account to create a dependent for", required = true) @PathParam("accountId") @NotNull  Long accountId,@ApiParam(value = "") @Valid  Account body,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.create(version, accountId, body, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/account/create")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Create Account", notes = "Create a new account by role.", response = AccountLoginResponse.class, tags={ "Account", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = AccountLoginResponse.class)
    })
    public Response createAccount(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The access token to authenticate with (ex: username)", required = true) @QueryParam("username") @NotNull  String username,@ApiParam(value = "The secret to authenticate with (ex: password)", required = true) @QueryParam("password") @NotNull  String password,@ApiParam(value = "The full name of the user. If this parameter is NOT empty, the following parameters will be ignored: prefixName, firstName, middleName, lastName, and suffixName") @QueryParam("name")  String name,@ApiParam(value = "If the parameter 'name' is empty or not present, this field will be used to set the prefix of the user's name") @QueryParam("prefixName")  String prefixName,@ApiParam(value = "If the parameter 'name' is empty or not present, this field will be used to set the user's first name") @QueryParam("firstName")  String firstName,@ApiParam(value = "If the parameter 'name' is empty or not present, this field will be used to set the user's middle name") @QueryParam("middleName")  String middleName,@ApiParam(value = "If the parameter 'name' is empty or not present, this field will be used to set the user's last name") @QueryParam("lastName")  String lastName,@ApiParam(value = "If the parameter 'name' is empty or not present, this field will be used to set the suffix of the user's name") @QueryParam("suffixName")  String suffixName,@ApiParam(value = "This field will be used to set the user's job title") @QueryParam("title")  String title,@ApiParam(value = "The unique id of the device making the request") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "The type of device id (this is defined by the client), ie. MAC_ADDRESS, APPLE_UDID, etc") @QueryParam("deviceIdType")  String deviceIdType,@ApiParam(value = "The user's contact email address (NOT the username)") @QueryParam("emailAddress")  String emailAddress,@ApiParam(value = "The asset id to set the user's profile image") @QueryParam("assetId")  Long assetId,@ApiParam(value = "The street address of the user's contact location") @QueryParam("streetAddress")  String streetAddress,@ApiParam(value = "The zipcode of the user's contact location") @QueryParam("zipcode")  String zipcode,@ApiParam(value = "The gender of the user (AudienceGender)") @QueryParam("gender")  String gender,@ApiParam(value = "The birthday date of the user in UTC milliseconds") @QueryParam("birthday")  Long birthday,@ApiParam(value = "The home phone number") @QueryParam("homePhone")  String homePhone,@ApiParam(value = "The cellular phone number") @QueryParam("cellPhone")  String cellPhone,@ApiParam(value = "The cellular service provider") @QueryParam("cellPhoneCarrier")  String cellPhoneCarrier,@ApiParam(value = "The business phone number") @QueryParam("businessPhone")  String businessPhone,@ApiParam(value = "The account role (default: MEMBER)") @QueryParam("role")  String role,@ApiParam(value = "Comma separated list of development platforms") @QueryParam("platforms")  String platforms,@ApiParam(value = "Search tags") @QueryParam("tags")  String tags,@ApiParam(value = "About us information") @QueryParam("aboutUs")  String aboutUs,@ApiParam(value = "Game experience of the user") @QueryParam("gameExperience")  String gameExperience,@ApiParam(value = "A list of category ids that represent interests and associations") @QueryParam("categoryIds")  String categoryIds,@ApiParam(value = "The user's hometown") @QueryParam("hometown")  String hometown,@ApiParam(value = "The user's height") @QueryParam("height")  String height,@ApiParam(value = "The user's height in a numerical value that can be used for ordering/searching") @QueryParam("heightIndex")  Integer heightIndex,@ApiParam(value = "The user's ethnicity") @QueryParam("ethnicity")  String ethnicity,@ApiParam(value = "The user's body type") @QueryParam("bodyType")  String bodyType,@ApiParam(value = "The user's marital status") @QueryParam("maritalStatus")  String maritalStatus,@ApiParam(value = "The user's children status") @QueryParam("children")  String children,@ApiParam(value = "The user's religion") @QueryParam("religion")  String religion,@ApiParam(value = "The user's education") @QueryParam("education")  String education,@ApiParam(value = "The user's education in a numerical value that can be used for ordering/searching") @QueryParam("educationIndex")  Integer educationIndex,@ApiParam(value = "The user's smoke status") @QueryParam("smoke")  String smoke,@ApiParam(value = "The user's drink status") @QueryParam("drink")  String drink,@ApiParam(value = "The user's companionship status") @QueryParam("companionship")  String companionship,@ApiParam(value = "The user's companionship index") @QueryParam("companionshipIndex")  Integer companionshipIndex,@ApiParam(value = "The preferred minimum age in the account location search") @QueryParam("preferredMinAge")  Integer preferredMinAge,@ApiParam(value = "The preferred maximum age in the account location search") @QueryParam("preferredMaxAge")  Integer preferredMaxAge,@ApiParam(value = "The preferred minimum height in the account location search") @QueryParam("preferredMinHeight")  Integer preferredMinHeight,@ApiParam(value = "The preferred maximum height in the account location search") @QueryParam("preferredMaxHeight")  Integer preferredMaxHeight,@ApiParam(value = "The preferred gender in the account location search") @QueryParam("preferredGender")  String preferredGender,@ApiParam(value = "The preferred education in the account location search") @QueryParam("preferredEducation")  String preferredEducation,@ApiParam(value = "The preferred education in a numerical value that can be used for ordering/searching") @QueryParam("preferredEducationIndex")  Integer preferredEducationIndex,@ApiParam(value = "The preferred body type in the account location search") @QueryParam("preferredBodyType")  String preferredBodyType,@ApiParam(value = "The preferred ethnicity in the account location search") @QueryParam("preferredEthnicity")  String preferredEthnicity,@ApiParam(value = "The preferred location in the account location search") @QueryParam("preferredLocation")  String preferredLocation,@ApiParam(value = "The preferred location range in the account location search") @QueryParam("preferredLocationRange")  Double preferredLocationRange,@ApiParam(value = "The current latitude of the user") @QueryParam("latitude")  Double latitude,@ApiParam(value = "The current longitude of the user") @QueryParam("longitude")  Double longitude,@ApiParam(value = "Accepted Terms") @QueryParam("acceptedTerms")  Boolean acceptedTerms,@ApiParam(value = "The inviteToken that the referrer used for this account to sign up") @QueryParam("inviteToken")  String inviteToken,@ApiParam(value = "The accountId of the referrer (used if there is no inviteToken)") @QueryParam("referralAccountId")  Long referralAccountId,@ApiParam(value = "Whether to send validation email") @QueryParam("sendValidation")  Boolean sendValidation,@ApiParam(value = "Deprecated: use appKey") @QueryParam("gameType")  String gameType,@ApiParam(value = "The application key") @QueryParam("appKey")  String appKey,@ApiParam(value = "The application version") @QueryParam("appVersion")  String appVersion,@ApiParam(value = "Returns an AccountLoginResponse if \"AccountLoginResponse\" is passed in") @QueryParam("responseType")  String responseType,@ApiParam(value = "Comma separated list of audience ids to assign to the user") @QueryParam("audienceIdsToAdd")  String audienceIdsToAdd,@ApiParam(value = "Application blob data") @QueryParam("appBlob")  String appBlob,@ApiParam(value = "Enable push for the app") @QueryParam("appEnablePush")  Boolean appEnablePush,@ApiParam(value = "Enable SMS for the app") @QueryParam("appEnableSMS")  Boolean appEnableSMS,@ApiParam(value = "Enable email for the app") @QueryParam("appEnableEmail")  Boolean appEnableEmail,@ApiParam(value = "Location visibility setting") @QueryParam("locationVisibility")  String locationVisibility,@ApiParam(value = "Home latitude") @QueryParam("homeLatitude")  Double homeLatitude,@ApiParam(value = "Home longitude") @QueryParam("homeLongitude")  Double homeLongitude,@ApiParam(value = "The nickname used in the application for this account") @QueryParam("appNickname")  String appNickname,@ApiParam(value = "Personal audience id to associate with this account") @QueryParam("personalAudienceId")  Long personalAudienceId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.createAccount(version, username, password, name, prefixName, firstName, middleName, lastName, suffixName, title, deviceId, deviceIdType, emailAddress, assetId, streetAddress, zipcode, gender, birthday, homePhone, cellPhone, cellPhoneCarrier, businessPhone, role, platforms, tags, aboutUs, gameExperience, categoryIds, hometown, height, heightIndex, ethnicity, bodyType, maritalStatus, children, religion, education, educationIndex, smoke, drink, companionship, companionshipIndex, preferredMinAge, preferredMaxAge, preferredMinHeight, preferredMaxHeight, preferredGender, preferredEducation, preferredEducationIndex, preferredBodyType, preferredEthnicity, preferredLocation, preferredLocationRange, latitude, longitude, acceptedTerms, inviteToken, referralAccountId, sendValidation, gameType, appKey, appVersion, responseType, audienceIdsToAdd, appBlob, appEnablePush, appEnableSMS, appEnableEmail, locationVisibility, homeLatitude, homeLongitude, appNickname, personalAudienceId, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/achievement/create")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Create Achievement", notes = "Updates an achievement (for developer/retailer use). User must have permissions to the application the achievement is created for.", response = AchievementResponse.class, tags={ "Achievement", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = AchievementResponse.class)
    })
    public Response createAchievement(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the application key the achievement is for", required = true) @QueryParam("appKey") @NotNull  String appKey,@ApiParam(value = "the title of the achievement (255 character limit)", required = true) @QueryParam("title") @NotNull  String title,@ApiParam(value = "a unique id given by the device (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "the account id of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "the analytics tag that will trigger when a user's achievement count gets updated") @QueryParam("analyticsTag")  String analyticsTag,@ApiParam(value = "the description of the achievement") @QueryParam("description")  String description,@ApiParam(value = "the rank type for updating leader boards") @QueryParam("rankType")  String rankType,@ApiParam(value = "determines how much the rank count is incremented") @QueryParam("rankIncrement")  Integer rankIncrement,@ApiParam(value = "restrict scores to be above or equal to this minimum value") @QueryParam("minIncrement")  Integer minIncrement,@ApiParam(value = "restrict scores to be below or equal to this maximum value") @QueryParam("maxIncrement")  Integer maxIncrement,@ApiParam(value = "determines whether the customId on analytics are used to validate a user's achievement progress.") @QueryParam("validate")  Boolean validate,@ApiParam(value = "achievement is active or inactive") @QueryParam("active")  Boolean active,@ApiParam(value = "if provided will define what triggers to run after a tier is completed") @QueryParam("triggerDefinition")  String triggerDefinition,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.createAchievement(version, appKey, title, deviceId, accountId, analyticsTag, description, rankType, rankIncrement, minIncrement, maxIncrement, validate, active, triggerDefinition, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/achievement/tier/create")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Create Achievement Tier", notes = "Create a tier of an achievement (for developer/retailer use). User must have permissions to the application the achievement is created for.", response = AchievementTierResponse.class, tags={ "Achievement", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = AchievementTierResponse.class)
    })
    public Response createAchievementTier(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the achievement id for adding a new tier", required = true) @QueryParam("achievementId") @NotNull  Long achievementId,@ApiParam(value = "score all instances", required = true) @QueryParam("scoreAllInstances") @NotNull  Boolean scoreAllInstances,@ApiParam(value = "a unique id given by the device (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "the account id of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "achievement tier icon image file") @QueryParam("icon")  File icon,@ApiParam(value = "the icon assetId, if icon is provided, icon will overrule") @QueryParam("iconAssetId")  Long iconAssetId,@ApiParam(value = "the title of the achievement tier") @QueryParam("title")  String title,@ApiParam(value = "the description of the achievement tier") @QueryParam("description")  String description,@ApiParam(value = "the count requirement for completing the achievement tier") @QueryParam("goalCount")  Long goalCount,@ApiParam(value = "The ID of the mission to associate with the achievement") @QueryParam("missionId")  Long missionId,@ApiParam(value = "The ID of the game to associate with the achievement") @QueryParam("gameId")  Long gameId,@ApiParam(value = "The ID of the pack to associate with the achievement") @QueryParam("packId")  Long packId,@ApiParam(value = "The ID of the game level to associate with the achievement") @QueryParam("gameLevelId")  Long gameLevelId,@ApiParam(value = "The ID of the game object to associate with the achievement") @QueryParam("gameObjectId")  Integer gameObjectId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.createAchievementTier(version, achievementId, scoreAllInstances, deviceId, accountId, icon, iconAssetId, title, description, goalCount, missionId, gameId, packId, gameLevelId, gameObjectId, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/application/create")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Create Application", notes = "Create an application record and one placement record for that application. You can create more placements for this application by using {@link createApplicationPlacement}.", response = ApplicationResponse.class, tags={ "Application", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = ApplicationResponse.class)
    })
    public Response createApplication(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The name of the application", required = true) @QueryParam("appName") @NotNull  String appName,@ApiParam(value = "The unique id of the device making the request (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "The account id of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "The description of the application") @QueryParam("about")  String about,@ApiParam(value = "The application bundle identifier (format - com.company.appName)") @QueryParam("bundleId")  String bundleId,@ApiParam(value = "The application icon asset id") @QueryParam("appIconAssetId")  Long appIconAssetId,@ApiParam(value = "The application logo asset id") @QueryParam("appLogoAssetId")  Long appLogoAssetId,@ApiParam(value = "The Facebook application id") @QueryParam("facebookAppId")  String facebookAppId,@ApiParam(value = "The Facebook application secret") @QueryParam("facebookAppSecret")  String facebookAppSecret,@ApiParam(value = "This is the either the 'server key' or 'browser key' generated from google to enable Google Cloud Messaging") @QueryParam("googleApiKey")  String googleApiKey,@ApiParam(value = "Determines whether to update the EULA date") @QueryParam("updateEULADate")  Boolean updateEULADate,@ApiParam(value = "The EULA version") @QueryParam("eulaVersion")  String eulaVersion,@ApiParam(value = "The landing page URL") @QueryParam("landingPageUrl")  String landingPageUrl,@ApiParam(value = "Determines whether to show the application in the activity feed") @QueryParam("showInActivities")  Boolean showInActivities,@ApiParam(value = "The description of the application in the activity feed") @QueryParam("activityDescription")  String activityDescription,@ApiParam(value = "The text to display on the invite page") @QueryParam("inviteWelcomeText")  String inviteWelcomeText,@ApiParam(value = "The url to the application invite page") @QueryParam("invitePageUrl")  String invitePageUrl,@ApiParam(value = "The protocal the app uses to load the app via a browser") @QueryParam("urlScheme")  String urlScheme,@ApiParam(value = "A json object with a list of supported platforms.  ```json {   \"platforms\": [     {       \"deviceId\": 1,       \"minimum\": 230,       \"maximum\": 421,       \"downloadUrl\": \"http://app.store.com/download\",       \"description\": \"description and version info\"     }   ] } ``` ") @QueryParam("platforms")  String platforms,@ApiParam(value = "Json formatted downloadUrls.  ```json {   \"ios\": \"the-url-to-app-store\",    \"android\": \"the-url-to-google-play\" } ```  ") @QueryParam("downloadUrls")  String downloadUrls,@ApiParam(value = "List of categories to apply") @QueryParam("categoryIds")  String categoryIds,@ApiParam(value = "The type of scoring this application will use {GAME_LEVEL, GAME_OBJECT", allowableValues="GAME_LEVEL, GAME_OBJECT", defaultValue = "GAME_LEVEL") @DefaultValue("GAME_LEVEL") @QueryParam("scoringType")  String scoringType,@ApiParam(value = "The cost of hints", defaultValue = "11") @DefaultValue("11") @QueryParam("hintCost")  Integer hintCost,@ApiParam(value = "The maximum score that will be possible", defaultValue = "125") @DefaultValue("125") @QueryParam("maxScore")  Integer maxScore,@ApiParam(value = "The point-to-ticket conversion ratio", defaultValue = "0.037") @DefaultValue("0.037") @QueryParam("ticketsPerPoint")  Float ticketsPerPoint,@ApiParam(value = "Determines whether the application uses services to save custom game objects", defaultValue = "true") @DefaultValue("true") @QueryParam("hasGameData")  Boolean hasGameData,@ApiParam(value = "Public Notifications") @QueryParam("publicNotifications")  Boolean publicNotifications,@ApiParam(value = "Use Matching Algorithm") @QueryParam("useMatchingAlgorithm")  Boolean useMatchingAlgorithm,@ApiParam(value = "Determines whether earned tickets are applied across all applications", defaultValue = "false") @DefaultValue("false") @QueryParam("globalTickets")  Boolean globalTickets,@ApiParam(value = "The current build version of the application", defaultValue = "1") @DefaultValue("1") @QueryParam("buildVersion")  Float buildVersion,@ApiParam(value = "The current API version the application uses") @QueryParam("apiVersion")  Float apiVersion,@ApiParam(value = "The name of the placement") @QueryParam("placementName")  String placementName,@ApiParam(value = "The description of the placement") @QueryParam("placementDescription")  String placementDescription,@ApiParam(value = "The ad placement size {BANNER, LEADERBOARD, SKYSCRAPER, INTERSTITIAL, CUSTOM (this is required if a placements is to be created)", allowableValues="CONFIG, BANNER, LEADERBOARD, SKYSCRAPER, VIDEO, ZIP, INTERSTITIAL, CUSTOM1, CUSTOM2, CUSTOM3, CUSTOM4, CUSTOM5, CUSTOM6, CUSTOM7, CUSTOM8, CUSTOM9, CUSTOM10") @QueryParam("placementSize")  String placementSize,@ApiParam(value = "The height of a custom ad size") @QueryParam("placementHeight")  Integer placementHeight,@ApiParam(value = "The width of a custom ad size") @QueryParam("placementWidth")  Integer placementWidth,@ApiParam(value = "The refresh interval in seconds") @QueryParam("placementRefreshInterval")  Integer placementRefreshInterval,@ApiParam(value = "Generate a custom object store to use", defaultValue = "true") @DefaultValue("true") @QueryParam("createObjectStore")  Boolean createObjectStore,@ApiParam(value = "Determine whether or not public content requires admin approval before it becomes public", defaultValue = "false") @DefaultValue("false") @QueryParam("publicContentApproval")  Boolean publicContentApproval,@ApiParam(value = "Determines whether the application uses production or sandbox services", defaultValue = "false") @DefaultValue("false") @QueryParam("productionMode")  Boolean productionMode,@ApiParam(value = "Minimum Session Length") @QueryParam("minimumSessionLength")  Integer minimumSessionLength,@ApiParam(value = "Session Gap Length") @QueryParam("sessionGapLength")  Integer sessionGapLength,@ApiParam(value = "Local Ads Enabled", defaultValue = "false") @DefaultValue("false") @QueryParam("localAdsEnabled")  Boolean localAdsEnabled,@ApiParam(value = "Sqoot Api Key") @QueryParam("sqootApiKey")  String sqootApiKey,@ApiParam(value = "Determines how to process trilateration data. Possible values include: DEFAULT, FINGERPRINT", allowableValues="DEFAULT, FINGERPRINT, FINGERPRINT_V2", defaultValue = "FINGERPRINT") @DefaultValue("FINGERPRINT") @QueryParam("trilatProcessingType")  String trilatProcessingType,@ApiParam(value = "Determines what the maximum sample size during trilateration") @QueryParam("maxSampleSize")  Integer maxSampleSize,@ApiParam(value = "Determines what the minimum acceptable RSSI value") @QueryParam("minRSSI")  Double minRSSI,@ApiParam(value = "List modules allowed to be served by the server, possible values include: COMMON, MEDIA, OFFER, GAME, SOCIAL, CONSUMER_WEBSITE, ALL", defaultValue = "ALL") @DefaultValue("ALL") @QueryParam("modules")  String modules,@ApiParam(value = "How many servers the license will support", defaultValue = "1") @DefaultValue("1") @QueryParam("authorizedCount")  Integer authorizedCount,@ApiParam(value = "The list of ip addresses of servers the license will support, leave null for any server") @QueryParam("authorizedServers")  String authorizedServers,@ApiParam(value = "Sets the default timezone for the app (used for leaderboards and other time specific content)") @QueryParam("defaultTimezone")  String defaultTimezone,@ApiParam(value = "SMTP Pass") @QueryParam("smtpPass")  String smtpPass,@ApiParam(value = "The application meta data. Defined by the client") @QueryParam("metaData")  String metaData,@ApiParam(value = "The ad placement meta data. Defined by the client") @QueryParam("placementMetaData")  String placementMetaData,@ApiParam(value = "Create floor tables for Ips", defaultValue = "false") @DefaultValue("false") @QueryParam("ipsFloor")  Boolean ipsFloor,@ApiParam(value = "Enables setting the APNS badge value in the payload", defaultValue = "true") @DefaultValue("true") @QueryParam("enableAPNSBadge")  Boolean enableAPNSBadge,@ApiParam(value = "Enables using the application in session reports", defaultValue = "true") @DefaultValue("true") @QueryParam("includeInReport")  Boolean includeInReport,@ApiParam(value = "Sets the default filter to use (if none is passed in) for certain search APIs including Album Search.") @QueryParam("defaultAppFilterId")  Long defaultAppFilterId,@ApiParam(value = "Enables whether the default welcome email will be sent for new app users") @QueryParam("enableWelcomeEmail")  Boolean enableWelcomeEmail,@ApiParam(value = "The Apple Application ID") @QueryParam("appleAppId")  String appleAppId,@ApiParam(value = "The Apple Team ID") @QueryParam("appleTeamId")  String appleTeamId,@ApiParam(value = "The Apple Auth Key ID") @QueryParam("appleAuthKeyId")  String appleAuthKeyId,@ApiParam(value = "The Apple Auth Signin Key (p8) File") @QueryParam("appleAuthKey")  File appleAuthKey,@ApiParam(value = "The Apple Issuer ID") @QueryParam("appleIssuerId")  String appleIssuerId,@ApiParam(value = "The Apple App Store Key ID") @QueryParam("appStoreKeyId")  String appStoreKeyId,@ApiParam(value = "The Apple App Store Key (p8) File") @QueryParam("appStoreKey")  File appStoreKey,@ApiParam(value = "This is the private key file for your Google service account.") @QueryParam("googlePrivateKeyFile")  File googlePrivateKeyFile,@ApiParam(value = "Authorize Net Api Key") @QueryParam("authorizeNetApiKey")  String authorizeNetApiKey,@ApiParam(value = "Authorize Net Transaction Key") @QueryParam("authorizeNetTransactionKey")  String authorizeNetTransactionKey,@ApiParam(value = "Email Sender") @QueryParam("emailSender")  String emailSender,@ApiParam(value = "SMTP User") @QueryParam("smtpUser")  String smtpUser,@ApiParam(value = "SMTP Host") @QueryParam("smtpHost")  String smtpHost,@ApiParam(value = "Vatom Business Id") @QueryParam("vatomBusinessId")  String vatomBusinessId,@ApiParam(value = "Vatom REST Client Id") @QueryParam("vatomRestClientId")  String vatomRestClientId,@ApiParam(value = "Vatom Secret Key") @QueryParam("vatomRestSecretKey")  String vatomRestSecretKey,@ApiParam(value = "Twilio Account SID") @QueryParam("twilioAccountSID")  String twilioAccountSID,@ApiParam(value = "Twilio Auth Token") @QueryParam("twilioAuthToken")  String twilioAuthToken,@ApiParam(value = "Twilio Sender Phone Number") @QueryParam("twilioSenderPhoneNumber")  String twilioSenderPhoneNumber,@ApiParam(value = "OpenAI Secret API Key") @QueryParam("openAISecretKey")  String openAISecretKey,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.createApplication(version, appName, deviceId, accountId, about, bundleId, appIconAssetId, appLogoAssetId, facebookAppId, facebookAppSecret, googleApiKey, updateEULADate, eulaVersion, landingPageUrl, showInActivities, activityDescription, inviteWelcomeText, invitePageUrl, urlScheme, platforms, downloadUrls, categoryIds, scoringType, hintCost, maxScore, ticketsPerPoint, hasGameData, publicNotifications, useMatchingAlgorithm, globalTickets, buildVersion, apiVersion, placementName, placementDescription, placementSize, placementHeight, placementWidth, placementRefreshInterval, createObjectStore, publicContentApproval, productionMode, minimumSessionLength, sessionGapLength, localAdsEnabled, sqootApiKey, trilatProcessingType, maxSampleSize, minRSSI, modules, authorizedCount, authorizedServers, defaultTimezone, smtpPass, metaData, placementMetaData, ipsFloor, enableAPNSBadge, includeInReport, defaultAppFilterId, enableWelcomeEmail, appleAppId, appleTeamId, appleAuthKeyId, appleAuthKey, appleIssuerId, appStoreKeyId, appStoreKey, googlePrivateKeyFile, authorizeNetApiKey, authorizeNetTransactionKey, emailSender, smtpUser, smtpHost, vatomBusinessId, vatomRestClientId, vatomRestSecretKey, twilioAccountSID, twilioAuthToken, twilioSenderPhoneNumber, openAISecretKey, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/appconfig/create")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Create AppConfig", notes = "Creates a new application configuration. If the configVersion provided already exists for the given app, an invalid response is returned and the application configuration won't be created.", response = ApplicationConfigResponse.class, tags={ "Application Config", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = ApplicationConfigResponse.class)
    })
    public Response createApplicationConfig(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The account ID of the user", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "The application key that the newly created applicationConfig will be associated to", required = true) @QueryParam("appKey") @NotNull  String appKey,@ApiParam(value = "The application configuration, has to be unique within the application", required = true) @QueryParam("configVersion") @NotNull  String configVersion,@ApiParam(value = "The json assetId that stores the configuration detail.", required = true) @QueryParam("assetId") @NotNull  Long assetId,@ApiParam(value = "The retailer id for retailer specific configurations") @QueryParam("retailerId")  Long retailerId,@ApiParam(value = "The retailer location id for retailer location specific configurations") @QueryParam("retailerLocationId")  Long retailerLocationId,@ApiParam(value = "The device udid for device specific configurations") @QueryParam("udid")  String udid,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.createApplicationConfig(version, accountId, appKey, configVersion, assetId, retailerId, retailerLocationId, udid, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/application/placement/create")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Create Ad Placement", notes = "Creates a new ad placement for an application.", response = PlacementResponse.class, tags={ "Application", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = PlacementResponse.class)
    })
    public Response createApplicationPlacement(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The appKey of the application the ad placement is for", required = true) @QueryParam("appKey") @NotNull  String appKey,@ApiParam(value = "The ad placement size {BANNER, LEADERBOARD, SKYSCRAPER, INTERSTITIAL, CUSTOM", required = true, allowableValues="CONFIG, BANNER, LEADERBOARD, SKYSCRAPER, VIDEO, ZIP, INTERSTITIAL, CUSTOM1, CUSTOM2, CUSTOM3, CUSTOM4, CUSTOM5, CUSTOM6, CUSTOM7, CUSTOM8, CUSTOM9, CUSTOM10") @QueryParam("size") @NotNull  String size,@ApiParam(value = "The unique id of the device making the request (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "The account id of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "The name of the placement") @QueryParam("name")  String name,@ApiParam(value = "The description of the placement") @QueryParam("description")  String description,@ApiParam(value = "The height of a custom ad size") @QueryParam("height")  Integer height,@ApiParam(value = "The width of a custom ad size") @QueryParam("width")  Integer width,@ApiParam(value = "The refresh interval in seconds") @QueryParam("refreshInterval")  Integer refreshInterval,@ApiParam(value = "Default Image Id") @QueryParam("defaultImageId")  Long defaultImageId,@ApiParam(value = "Active") @QueryParam("active")  Boolean active,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.createApplicationPlacement(version, appKey, size, deviceId, accountId, name, description, height, width, refreshInterval, defaultImageId, active, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/asset/create")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Create Asset", notes = "Uploads an asset to server and returns an asset id which can be used to assign to various objects.", response = AssetResponse.class, tags={ "Asset", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = AssetResponse.class)
    })
    public Response createAsset(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "to return nulls") @QueryParam("returnNulls")  Boolean returnNulls,@ApiParam(value = "a unique ID given by the device (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "the account ID of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "the album the asset will be added to (optional)") @QueryParam("albumId")  Long albumId,@ApiParam(value = "Deprecated: use collections via the collection endpoints.") @QueryParam("collectionId")  Long collectionId,@ApiParam(value = "Whether to add to a default album") @QueryParam("addToDefaultAlbum")  String addToDefaultAlbum,@ApiParam(value = "Whether to add to the media library") @QueryParam("addToMediaLibrary")  Boolean addToMediaLibrary,@ApiParam(value = "the version code") @QueryParam("versionCode")  Integer versionCode,@ApiParam(value = "the version name") @QueryParam("versionName")  String versionName,@ApiParam(value = "External custom client defined data") @QueryParam("metaData")  String metaData,@ApiParam(value = "the caption (optional)") @QueryParam("caption")  String caption,@ApiParam(value = "the asset type") @QueryParam("assetType")  String assetType,@ApiParam(value = "approval status for the asset") @QueryParam("approvalStatus")  String approvalStatus,@ApiParam(value = "account id assigned to the asset") @QueryParam("assignedAccountId")  Long assignedAccountId,@ApiParam(value = "a MultipartFile containing the mimetype, etc") @QueryParam("media")  File media,@ApiParam(value = "this can be used if the \"media\" is a link (optional)") @QueryParam("mediaUrl")  String mediaUrl,@ApiParam(value = "the media content as a string (optional)") @QueryParam("mediaString")  String mediaString,@ApiParam(value = "file name for mediaString (optional)") @QueryParam("mediaStringFileName")  String mediaStringFileName,@ApiParam(value = "content type for mediaString (optional)") @QueryParam("mediaStringContentType")  String mediaStringContentType,@ApiParam(value = "the media height (optional)") @QueryParam("mediaHeight")  Integer mediaHeight,@ApiParam(value = "the media width (optional)") @QueryParam("mediaWidth")  Integer mediaWidth,@ApiParam(value = "a MultipartFile containing an asset that the \"media\" file references (optional). Example: to upload a video the \"media\" file should contain a screen capture and the \"attachedMedia\" should be the actual video.") @QueryParam("attachedMedia")  File attachedMedia,@ApiParam(value = "this can be used if the \"attachedMedia\" is a link (i.e. a Youtube video, etc) (optional)") @QueryParam("attachedMediaUrl")  String attachedMediaUrl,@ApiParam(value = "attached media content as a string (optional)") @QueryParam("attachedMediaString")  String attachedMediaString,@ApiParam(value = "file name for attachedMediaString (optional)") @QueryParam("attachedMediaStringFileName")  String attachedMediaStringFileName,@ApiParam(value = "content type for attachedMediaString (optional)") @QueryParam("attachedMediaStringContentType")  String attachedMediaStringContentType,@ApiParam(value = "the attached media height (optional)") @QueryParam("attachedMediaHeight")  Integer attachedMediaHeight,@ApiParam(value = "the attached media width (optional)") @QueryParam("attachedMediaWidth")  Integer attachedMediaWidth,@ApiParam(value = "the location description (optional)") @QueryParam("locationDescription")  String locationDescription,@ApiParam(value = "Deprecated: app parameter") @QueryParam("app")  String app,@ApiParam(value = "the application key") @QueryParam("appKey")  String appKey,@ApiParam(value = "the search tags") @QueryParam("searchTags")  String searchTags,@ApiParam(value = "the latitude (optional)") @QueryParam("latitude")  Double latitude,@ApiParam(value = "the longitude (optional)") @QueryParam("longitude")  Double longitude,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.createAsset(version, returnNulls, deviceId, accountId, albumId, collectionId, addToDefaultAlbum, addToMediaLibrary, versionCode, versionName, metaData, caption, assetType, approvalStatus, assignedAccountId, media, mediaUrl, mediaString, mediaStringFileName, mediaStringContentType, mediaHeight, mediaWidth, attachedMedia, attachedMediaUrl, attachedMediaString, attachedMediaStringFileName, attachedMediaStringContentType, attachedMediaHeight, attachedMediaWidth, locationDescription, app, appKey, searchTags, latitude, longitude, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/audience/create")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Create Audience", notes = "Create a user defined audience.", response = AudienceResponse.class, tags={ "Audience", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = AudienceResponse.class)
    })
    public Response createAudience(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The logged in user.", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "The name of the audience", required = true) @QueryParam("name") @NotNull  String name,@ApiParam(value = "The description of the audience") @QueryParam("description")  String description,@ApiParam(value = "The search tags") @QueryParam("searchTags")  String searchTags,@ApiParam(value = "The gender; possible values are: MALE, FEMALE, ANY") @QueryParam("gender")  String gender,@ApiParam(value = "The list of age groups, comma separated; possible values are AGE_0_13, AGE_14_17, AGE_18_22, AGE_23_30, AGE_31_54, AGE_55_PLUS, AGE_ANY (to reset to none)") @QueryParam("ageGroups")  String ageGroups,@ApiParam(value = "The list of category ids, comma separated; possible values are retrieved via /api/{version}/category/search (pass in id values)") @QueryParam("categoryIds")  String categoryIds,@ApiParam(value = "The list of application ids, comma separated; possible values are retrieved via /api/{version}/application/list (pass in id values)") @QueryParam("applicationIds")  String applicationIds,@ApiParam(value = "The experience level of the player; possible values are: ANY, NEW, BEGINNER, INTERMEDIATE, EXPERT") @QueryParam("gameExperienceLevel")  String gameExperienceLevel,@ApiParam(value = "(Deprecated) Use deviceIds. The list of targeted device names, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in name values)") @QueryParam("devices")  String devices,@ApiParam(value = "The list of targeted device ids, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in id values)") @QueryParam("deviceIds")  String deviceIds,@ApiParam(value = "The list of targeted device version ranges that are aligned with the provided devices list, comma separated (examples: 2.3-X, 0-5.1.4, 4.3.1-6.1.4)") @QueryParam("deviceVersions")  String deviceVersions,@ApiParam(value = "The list of locations to build the center around; comma separated list of latitude/longitude pairs (example: lat1,long1,lat2,long2)") @QueryParam("locations")  String locations,@ApiParam(value = "The list of radius of influence for the audience, in miles; comma separated list. Either provide 1 to be applied to all location pairs or a matching list to each lat/long pair.") @QueryParam("radius")  String radius,@ApiParam(value = "Seconds from the start time of an event") @QueryParam("startTimeOffset")  Integer startTimeOffset,@ApiParam(value = "Seconds from the end time of an event") @QueryParam("endTimeOffset")  Integer endTimeOffset,@ApiParam(value = "If true, then notify matching users when they are inside the radius", defaultValue = "true") @DefaultValue("true") @QueryParam("sendSuggestion")  Boolean sendSuggestion,@ApiParam(value = "The description of the associated object") @QueryParam("associateDescription")  String associateDescription,@ApiParam(value = "The type of the object to center the audience geofence") @QueryParam("associateType")  String associateType,@ApiParam(value = "The ID of the object to center the audience geofence") @QueryParam("associateId")  Long associateId,@ApiParam(value = "Optional grouping id for the audience") @QueryParam("groupingId")  String groupingId,@ApiParam(value = "External custom client defined data") @QueryParam("metaData")  String metaData,@ApiParam(value = "Visibility of the audience") @QueryParam("visibility")  String visibility,@ApiParam(value = "Type of audience") @QueryParam("audienceType")  String audienceType,@ApiParam(value = "Use order for cohort") @QueryParam("useOrder")  Boolean useOrder,@ApiParam(value = "Cohort data for \"cohort\" audience type") @QueryParam("cohortRegionsData")  String cohortRegionsData,@ApiParam(value = "Filter results by application key") @QueryParam("appKey")  String appKey,@ApiParam(value = "Trilateration types") @QueryParam("trilaterationTypes")  String trilaterationTypes,@ApiParam(value = "If true, makes sure the audience name is unique") @QueryParam("uniqueName")  Boolean uniqueName,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.createAudience(version, accountId, name, description, searchTags, gender, ageGroups, categoryIds, applicationIds, gameExperienceLevel, devices, deviceIds, deviceVersions, locations, radius, startTimeOffset, endTimeOffset, sendSuggestion, associateDescription, associateType, associateId, groupingId, metaData, visibility, audienceType, useOrder, cohortRegionsData, appKey, trilaterationTypes, uniqueName, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/report/batch/create")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Create Offline Report", notes = "Create an entry for the batch for offline report", response = ReportBatchResponse.class, tags={ "Reporting", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = ReportBatchResponse.class)
    })
    public Response createBatch(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The account id of the user for passing account related params", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "the status of the report", required = true, allowableValues="NEW, ERROR, COMPLETE, PARSE_ERROR, PROCESSING, DUPLICATE, SAVEONLY") @QueryParam("status") @NotNull  String status,@ApiParam(value = "the limit on how much you can preview of the batch report", required = true) @QueryParam("previewLimit") @NotNull  Integer previewLimit,@ApiParam(value = "The application key for passing application related params") @QueryParam("appKey")  String appKey,@ApiParam(value = "") @QueryParam("endpoint")  String endpoint,@ApiParam(value = "a json structure list of the parameter values, example: ```json {   \"string\":\"value\",    \"number\":3.345,   \"date\":\"2014-05-01 00:00:00\" } ``` ") @QueryParam("parameters")  String parameters,@ApiParam(value = "name of the batch report") @QueryParam("name")  String name,@ApiParam(value = "the start date of the batch report") @QueryParam("startDate")  Long startDate,@ApiParam(value = "the end date of the batch report") @QueryParam("endDate")  Long endDate,@ApiParam(value = "the description of the batch report") @QueryParam("description")  String description,@ApiParam(value = "") @QueryParam("pageUrl")  String pageUrl,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.createBatch(version, accountId, status, previewLimit, appKey, endpoint, parameters, name, startDate, endDate, description, pageUrl, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/bid/create")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Create Bid", notes = "Creates a bid on a biddable object", response = BidResponse.class, tags={ "Bid", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = BidResponse.class)
    })
    public Response createBid(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "A biddable object type. Possible values include: CREATIVE (ads).", required = true) @QueryParam("biddableType") @NotNull  String biddableType,@ApiParam(value = "The id of the biddable object", required = true) @QueryParam("biddableId") @NotNull  Long biddableId,@ApiParam(value = "The bid amount for views. For ads, this is the amount that will be taken for each impression.", required = true) @QueryParam("amountPerView") @NotNull  Double amountPerView,@ApiParam(value = "The bid amount for actions. For ads, this is the amount that will be taken for each click.", required = true) @QueryParam("amountPerAction") @NotNull  Double amountPerAction,@ApiParam(value = "The allocated budget amount that will be used", required = true) @QueryParam("budgetAmount") @NotNull  Double budgetAmount,@ApiParam(value = "The schedule for when the allocated budget amount is reset", required = true) @QueryParam("budgetSchedule") @NotNull  String budgetSchedule,@ApiParam(value = "The device id (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "The account id of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.createBid(version, biddableType, biddableId, amountPerView, amountPerAction, budgetAmount, budgetSchedule, deviceId, accountId, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/billable/create")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Create Billable", notes = "reate a billable entity for an account. The creator is assumed to be the responsible account. An account can only have one billable entity", response = BillableEntityResponse.class, tags={ "Billable Entity", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = BillableEntityResponse.class)
    })
    public Response createBillableEntity(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The unique device identifier that made the request (either deviceId or accountId must be used)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "The unique accountId that made the request (either deviceId or accountId must be used)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "The name of the entity responsible for billing ") @QueryParam("name")  String name,@ApiParam(value = "The street address of the billable entity") @QueryParam("streetAddress")  String streetAddress,@ApiParam(value = "Additional address information (such as a suite number, floor number, building name, or PO Box) ") @QueryParam("streetAddress2")  String streetAddress2,@ApiParam(value = "The city of the billable entity") @QueryParam("city")  String city,@ApiParam(value = "The state of the billable entity") @QueryParam("state")  String state,@ApiParam(value = "The postal code of the billable entity") @QueryParam("postalCode")  String postalCode,@ApiParam(value = "The business phone of the billable entity") @QueryParam("businessPhone")  String businessPhone,@ApiParam(value = "The business phone extension") @QueryParam("businessPhoneExt")  String businessPhoneExt,@ApiParam(value = "Authorize Net Api Key") @QueryParam("authorizeNetApiKey")  String authorizeNetApiKey,@ApiParam(value = "Authorize Net Transaction Key") @QueryParam("authorizeNetTransactionKey")  String authorizeNetTransactionKey,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.createBillableEntity(version, deviceId, accountId, name, streetAddress, streetAddress2, city, state, postalCode, businessPhone, businessPhoneExt, authorizeNetApiKey, authorizeNetTransactionKey, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/cargo/type")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Create Cargo Type", notes = "Create new cargo type", response = CargoType.class, tags={ "Cargo Type", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = CargoType.class)
    })
    public Response createCargoType(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "") @Valid  CargoType body,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.createCargoType(version, body, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/category/create")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Create Category", notes = "Create a new category.", response = CategoryTreeResponse.class, tags={ "Category", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = CategoryTreeResponse.class)
    })
    public Response createCategory(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The account id of the user (must have permissions to the target application)", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "The name of the category", required = true) @QueryParam("name") @NotNull  String name,@ApiParam(value = "The appKey of the application to assign the category to, if not provided then the category will be applied to the global application (if the account has permissions)") @QueryParam("appKey")  String appKey,@ApiParam(value = "The ID of the parent category, if not provided then the parent category will be null") @QueryParam("parentCategoryId")  Long parentCategoryId,@ApiParam(value = "The description of the category") @QueryParam("description")  String description,@ApiParam(value = "The type of the category") @QueryParam("type")  String type,@ApiParam(value = "The ID of the image asset previously uploaded using the media service") @QueryParam("assetId")  Long assetId,@ApiParam(value = "A string identifier used by client applications to store external information") @QueryParam("externalId")  String externalId,@ApiParam(value = "A string type used by client applications to store external information") @QueryParam("externalType")  String externalType,@ApiParam(value = "external category slug") @QueryParam("externalCategorySlug")  String externalCategorySlug,@ApiParam(value = "sqoot slug") @QueryParam("sqootSlug")  String sqootSlug,@ApiParam(value = "Sets whether the category is active or inactive (hidden from consumers)") @QueryParam("active")  Boolean active,@ApiParam(value = "external custom client defined data") @QueryParam("metaData")  String metaData,@ApiParam(value = "user defined strings for searching") @QueryParam("searchTags")  String searchTags,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.createCategory(version, accountId, name, appKey, parentCategoryId, description, type, assetId, externalId, externalType, externalCategorySlug, sqootSlug, active, metaData, searchTags, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/creative/create")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Create Creative", notes = "Create a creative", response = CreativeResponse.class, tags={ "Creative", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = CreativeResponse.class)
    })
    public Response createCreative(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The logged in user.", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "The name of the level.", required = true) @QueryParam("name") @NotNull  String name,@ApiParam(value = "If true set the game level as active. Default is false.", required = true) @QueryParam("active") @NotNull  Boolean active,@ApiParam(value = "determines whether the response will wait until the asset gets created", required = true) @QueryParam("waitForAsset") @NotNull  Boolean waitForAsset,@ApiParam(value = "The description of the level.") @QueryParam("description")  String description,@ApiParam(value = "The asset Id of the level image.") @QueryParam("assetImageId")  Long assetImageId,@ApiParam(value = "This parameter is deprecated. deprecated use data field") @QueryParam("action")  String action,@ApiParam(value = "The creative data, json based format depending on type. If not using action then data is required.") @QueryParam("data")  String data,@ApiParam(value = "This parameter is deprecated. deprecated use type field") @QueryParam("suffix")  String suffix,@ApiParam(value = "The type of creative. If not using suffix then type is required.") @QueryParam("type")  String type,@ApiParam(value = "Set the amount of money available to spend, once 0 deactivate level. Set to a negative value for unlimited.") @QueryParam("balance")  Double balance,@ApiParam(value = "if creative related so some other content provided the id") @QueryParam("referenceId")  Long referenceId,@ApiParam(value = "The version of the application, will not return creatives newer than the appVersion. Only used when requesting application configuration creatives.") @QueryParam("appVersion")  String appVersion,@ApiParam(value = "Assign the creative to a campaign for timing and audience matching.") @QueryParam("missionId")  Long missionId,@ApiParam(value = "the id of the offer") @QueryParam("offerId")  Long offerId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.createCreative(version, accountId, name, active, waitForAsset, description, assetImageId, action, data, suffix, type, balance, referenceId, appVersion, missionId, offerId, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/thirdparty/credential/create")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Create Credential", notes = "This endpoint creates a third-party login for a Sirqul account. A third party login is a way for external systems (Third Party Networks) to link their own user accounts with a Sirqul account.   The thirdPartyId parameter is used to determine if the user already exists in Sirqul or not. This parameter needs to be unique for each user in the Third Party Network (identified by the networkUID parameter). Note that subsequent calls will update the user's third-party login credentials for the user with the same thirdPartyId and networkUID combination.    The thirdPartyToken parameter acts as a shared secret and used by client applications to log users into Sirqul without providing a Sirqul username and password. ", response = ProfileResponse.class, tags={ "ThirdParty Credentials", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = ProfileResponse.class)
    })
    public Response createCredential(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the third party user account id", required = true) @QueryParam("thirdPartyId") @NotNull  String thirdPartyId,@ApiParam(value = "the access token to authenticate with (ex: username or fb token or phone number)", required = true) @QueryParam("thirdPartyToken") @NotNull  String thirdPartyToken,@ApiParam(value = "the access provider to authenticate against", required = true) @QueryParam("networkUID") @NotNull  String networkUID,@ApiParam(value = "the application key", required = true) @QueryParam("appKey") @NotNull  String appKey,@ApiParam(value = "the unique id of the account that needs authenticating (optional for PHONE_V2)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "the unique id of the device making the request") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "the session id for the request") @QueryParam("sessionId")  String sessionId,@ApiParam(value = "the third party user's display name") @QueryParam("thirdPartyName")  String thirdPartyName,@ApiParam(value = "optional email address associated with the third party account") @QueryParam("emailAddress")  String emailAddress,@ApiParam(value = "when true will error out if can't find any accounts matching (signin only)", defaultValue = "false") @DefaultValue("false") @QueryParam("signinOnlyMode")  Boolean signinOnlyMode,@ApiParam(value = "this determines how much of the profile should be returned, see ProfileFilters") @QueryParam("responseFilters")  String responseFilters,@ApiParam(value = "the latitude of the user") @QueryParam("latitude")  Double latitude,@ApiParam(value = "the longitude of the user") @QueryParam("longitude")  Double longitude,@ApiParam(value = "External custom client defined data") @QueryParam("metaData")  String metaData,@ApiParam(value = "optional refresh token for the third party") @QueryParam("thirdPartyRefreshToken")  String thirdPartyRefreshToken,@ApiParam(value = "audience ids to add to the account") @QueryParam("audienceIdsToAdd")  String audienceIdsToAdd,@ApiParam(value = "audience ids to remove from the account") @QueryParam("audienceIdsToRemove")  String audienceIdsToRemove,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.createCredential(version, thirdPartyId, thirdPartyToken, networkUID, appKey, accountId, deviceId, sessionId, thirdPartyName, emailAddress, signinOnlyMode, responseFilters, latitude, longitude, metaData, thirdPartyRefreshToken, audienceIdsToAdd, audienceIdsToRemove, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/object/data/{objectName}")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Create Data", notes = "Create a record for the specified object.  If the object does not exist then a new one will be created prior to inserting the record.  If any of the fields included does not exist for the object then they are added to the object. ", response = ObjectStoreResponse.class, tags={ "Object Store", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = ObjectStoreResponse.class)
    })
    public Response createData(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the name of the object to create data for", required = true) @PathParam("objectName") @NotNull  String objectName,@ApiParam(value = "the account id") @QueryParam("accountId")  Long accountId,@ApiParam(value = "")  String body,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.createData(version, objectName, accountId, body, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/disbursement/create")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Create Disbursement", notes = "Creates a Disbursement for sending money to a retailer", response = DisbursementResponse.class, tags={ "Disbursement", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = DisbursementResponse.class)
    })
    public Response createDisbursement(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the ID of the logging in user (must be an EXECUTIVE account)", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "the ID of the account receiving the disbursement", required = true) @QueryParam("receiverAccountId") @NotNull  Long receiverAccountId,@ApiParam(value = "the ID of the original sender account", required = true) @QueryParam("originalSenderAccountId") @NotNull  Long originalSenderAccountId,@ApiParam(value = "the dollar amount of the disbursement", required = true) @QueryParam("amount") @NotNull  BigDecimal amount,@ApiParam(value = "the provider (e.g. Authorize.net, Bill.com, etc.)", required = true, allowableValues="AUTHORIZE_NET, AMAZON_FPS, BILL_COM") @QueryParam("provider") @NotNull  String provider,@ApiParam(value = "the date that the disbursement is scheduled to go out to the payment provider") @QueryParam("scheduledDate")  Long scheduledDate,@ApiParam(value = "a title given for the disbursement") @QueryParam("title")  String title,@ApiParam(value = "a comment that could be made for a disbursement") @QueryParam("comment")  String comment,@ApiParam(value = "external ID, which can be used as a way to reference the disbursement") @QueryParam("externalId")  String externalId,@ApiParam(value = "This is for specifying parameters to make an http callback request for validating that the disbursement is valid") @QueryParam("introspectionParams")  String introspectionParams,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.createDisbursement(version, accountId, receiverAccountId, originalSenderAccountId, amount, provider, scheduledDate, title, comment, externalId, introspectionParams, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/employee/create")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Create Employee", notes = "Create a new account record with the provided information.", response = EmployeeResponse.class, tags={ "Employee", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = EmployeeResponse.class)
    })
    public Response createEmployee(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The account id of the logged in user", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "The account id of the manager to assign under", required = true) @QueryParam("managerAccountId") @NotNull  Long managerAccountId,@ApiParam(value = "The username/email for the new user. This must be unique across the entire the system.", required = true) @QueryParam("username") @NotNull  String username,@ApiParam(value = "The password for the new user", required = true) @QueryParam("password") @NotNull  String password,@ApiParam(value = "a name field") @QueryParam("name")  String name,@ApiParam(value = "The name prefix; Mr, Mrs, etc") @QueryParam("prefixName")  String prefixName,@ApiParam(value = "The first name") @QueryParam("firstName")  String firstName,@ApiParam(value = "The middle name") @QueryParam("middleName")  String middleName,@ApiParam(value = "The last name") @QueryParam("lastName")  String lastName,@ApiParam(value = "The name suffix; Jr, Sr, III, etc") @QueryParam("suffixName")  String suffixName,@ApiParam(value = "The title of the user") @QueryParam("title")  String title,@ApiParam(value = "Additional about/biography text") @QueryParam("aboutUs")  String aboutUs,@ApiParam(value = "the asset id to set the user's profile image") @QueryParam("assetId")  Long assetId,@ApiParam(value = "The gender", allowableValues="MALE, FEMALE, ANY") @QueryParam("gender")  String gender,@ApiParam(value = "The home phone number") @QueryParam("homePhone")  String homePhone,@ApiParam(value = "The cellular phone number") @QueryParam("cellPhone")  String cellPhone,@ApiParam(value = "The cellular service provider. This is required for sending SMS. Leave this empty if the provider is not on the list of supported carriers.") @QueryParam("cellPhoneCarrier")  String cellPhoneCarrier,@ApiParam(value = "The business phone number") @QueryParam("businessPhone")  String businessPhone,@ApiParam(value = "The user's contact email address (NOT the username)") @QueryParam("emailAddress")  String emailAddress,@ApiParam(value = "The street address of the user's contact location") @QueryParam("streetAddress")  String streetAddress,@ApiParam(value = "Additional address information (such as a suite number, floor number, building name, or PO Box)") @QueryParam("streetAddress2")  String streetAddress2,@ApiParam(value = "The city of the user's contact location") @QueryParam("city")  String city,@ApiParam(value = "The state of the user's contact location") @QueryParam("state")  String state,@ApiParam(value = "The zipcode of the user's contact location") @QueryParam("zipcode")  String zipcode,@ApiParam(value = "The country of the user's contact location") @QueryParam("country")  String country,@ApiParam(value = "The role; RETAILER or RETAILER_LIMITED, defaulted to RETAILER_LIMITED") @QueryParam("role")  String role,@ApiParam(value = "the retailer location IDs the employee is associated with") @QueryParam("retailerLocationIds")  String retailerLocationIds,@ApiParam(value = "Determines whether to return the application settings for the employee for a particular application") @QueryParam("settingsAppKey")  String settingsAppKey,@ApiParam(value = "external custom client defined data (per Application)") @QueryParam("appBlob")  String appBlob,@ApiParam(value = "The device id to assign to the user (used for IPS beacon tracking)") @QueryParam("assignedDeviceId")  String assignedDeviceId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.createEmployee(version, accountId, managerAccountId, username, password, name, prefixName, firstName, middleName, lastName, suffixName, title, aboutUs, assetId, gender, homePhone, cellPhone, cellPhoneCarrier, businessPhone, emailAddress, streetAddress, streetAddress2, city, state, zipcode, country, role, retailerLocationIds, settingsAppKey, appBlob, assignedDeviceId, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/entity/reference")
    @Consumes({ "application/json" })
    @Produces({ "application/json" })
    @io.swagger.annotations.ApiOperation(value = "Create an entity reference.", notes = "Creates a reference for an entity for syncing data between servers.", response = ActivityResponse.class, tags={ "Activity", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = ActivityResponse.class)
    })
    public Response createEntityReference(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The entity reference object", required = true) @NotNull @Valid  EntityReference body,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.createEntityReference(version, body, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/event/create")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Create Event", notes = "Create a private event to share with associates.", response = OfferResponse.class, tags={ "Event", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = OfferResponse.class)
    })
    public Response createEvent(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The logged in user.", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "The event title", required = true) @QueryParam("title") @NotNull  String title,@ApiParam(value = "The retailer location to have the event at") @QueryParam("retailerLocationIds")  String retailerLocationIds,@ApiParam(value = "The event sub title") @QueryParam("subTitle")  String subTitle,@ApiParam(value = "The event details") @QueryParam("details")  String details,@ApiParam(value = "The categories the associate the event with") @QueryParam("categoryIds")  String categoryIds,@ApiParam(value = "The filters the associate the event with") @QueryParam("filterIds")  String filterIds,@ApiParam(value = "Is this event active") @QueryParam("active")  Boolean active,@ApiParam(value = "The image to show for the event") @QueryParam("imageAssetId")  Long imageAssetId,@ApiParam(value = "The event start date/time") @QueryParam("redeemableStart")  Long redeemableStart,@ApiParam(value = "The event end date/time") @QueryParam("redeemableEnd")  Long redeemableEnd,@ApiParam(value = "external custom client defined data") @QueryParam("metaData")  String metaData,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.createEvent(version, accountId, title, retailerLocationIds, subTitle, details, categoryIds, filterIds, active, imageAssetId, redeemableStart, redeemableEnd, metaData, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/filter/create")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Create Filter", notes = "Create a filter", response = FilterTreeResponse.class, tags={ "Filter", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = FilterTreeResponse.class)
    })
    public Response createFilter(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The account id of the user (must have permissions to the target application)", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "The name of the filter", required = true) @QueryParam("name") @NotNull  String name,@ApiParam(value = "The appKey of the application to assign the filter to, if not provided then the filter will be applied to the global application (if the account has permissions)") @QueryParam("appKey")  String appKey,@ApiParam(value = "The ID of the parent filter, if not provided then the parent filter will be null") @QueryParam("parentFilterId")  Long parentFilterId,@ApiParam(value = "The description of the filter") @QueryParam("description")  String description,@ApiParam(value = "A string identifier used by client applications to store external information") @QueryParam("externalId")  String externalId,@ApiParam(value = "A string type used by client applications to store external information") @QueryParam("externalType")  String externalType,@ApiParam(value = "Sets whether the filter is active or inactive (hidden from consumers)") @QueryParam("active")  Boolean active,@ApiParam(value = "external custom client defined data") @QueryParam("metaData")  String metaData,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.createFilter(version, accountId, name, appKey, parentFilterId, description, externalId, externalType, active, metaData, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/flag/create")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Create Flag", notes = "Allows a user to flag an object that the user deems inappropriate or offensive. Flagable objects include accounts, albums, album contests, assets, game levels, and theme descriptors", response = SirqulResponse.class, tags={ "Flag", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response createFlag(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The flagable object type {ACCOUNT, ALBUM, ALBUM_CONTEST, ASSET, GAME_LEVEL, THEME_DESCRIPTOR, NOTE, OFFER}", required = true) @QueryParam("flagableType") @NotNull  String flagableType,@ApiParam(value = "The flagable object id", required = true) @QueryParam("flagableId") @NotNull  Long flagableId,@ApiParam(value = "The unique device identifier that made the request (either deviceId or accountId must be used)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "The unique accountId that made the request (either deviceId or accountId must be used)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "An optional description of why is it being flagged") @QueryParam("flagDescription")  String flagDescription,@ApiParam(value = "The current location of the user") @QueryParam("latitude")  Double latitude,@ApiParam(value = "The current location of the user") @QueryParam("longitude")  Double longitude,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.createFlag(version, flagableType, flagableId, deviceId, accountId, flagDescription, latitude, longitude, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/vatom/me/rels/following/create")
    
    
    @io.swagger.annotations.ApiOperation(value = "Create following", notes = "Create following.", response = Void.class, tags={ "Vatom", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = Void.class)
    })
    public Response createFollowing(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "Sirqul Account Id", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "Vatom Parameters", required = true) @QueryParam("vatomParameters") @NotNull  String vatomParameters,@ApiParam(value = "Return raw response") @QueryParam("returnRawResponse")  Boolean returnRawResponse,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.createFollowing(version, accountId, vatomParameters, returnRawResponse, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/game/create")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Create a Game", notes = "Create a Game.", response = GameResponse.class, tags={ "Game", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = GameResponse.class)
    })
    public Response createGame(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The logged in user.") @QueryParam("accountId")  Long accountId,@ApiParam(value = "The game application key to save the level for.") @QueryParam("appKey")  String appKey,@ApiParam(value = "Title of the game.") @QueryParam("title")  String title,@ApiParam(value = "Description of the game.") @QueryParam("description")  String description,@ApiParam(value = "metaData of the Game.") @QueryParam("metaData")  String metaData,@ApiParam(value = "comma separated String of pack Ids that will associate with the game.") @QueryParam("packIds")  String packIds,@ApiParam(value = "Show more details in response.") @QueryParam("includeGameData")  Boolean includeGameData,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.createGame(version, accountId, appKey, title, description, metaData, packIds, includeGameData, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/level/create")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Create Game Level", notes = "Create a game level. Currently does NOT support game objects.", response = GameLevelResponse.class, tags={ "Game Level", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = GameLevelResponse.class)
    })
    public Response createGameLevel(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The logged in user.", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "The name of the level.", required = true) @QueryParam("name") @NotNull  String name,@ApiParam(value = "The game level data: xml, json, or other text based format.", required = true) @QueryParam("gameData") @NotNull  String gameData,@ApiParam(value = "The game level data format type.", required = true) @QueryParam("gameDataSuffix") @NotNull  String gameDataSuffix,@ApiParam(value = "The game application key to save the level for.") @QueryParam("appKey")  String appKey,@ApiParam(value = "The description of the level.") @QueryParam("description")  String description,@ApiParam(value = "The difficulty, possible values are: VERY_EASY, EASY, MEDIUM, HARD, VERY_HARD.") @QueryParam("difficulty")  String difficulty,@ApiParam(value = "The version number of the application required to correctly load/play the level.") @QueryParam("appVersion")  String appVersion,@ApiParam(value = "The asset Id of the level image.") @QueryParam("assetImageId")  Long assetImageId,@ApiParam(value = "The asset Id of the level icon.") @QueryParam("assetIconId")  Long assetIconId,@ApiParam(value = "Is the level visible to others, possible values are: PUBLIC, PRIVATE.") @QueryParam("visibility")  String visibility,@ApiParam(value = "Make the level be readable by all friends.") @QueryParam("friendGroup")  Boolean friendGroup,@ApiParam(value = "Make the level be readable by connections in this list.") @QueryParam("connectionIds")  String connectionIds,@ApiParam(value = "Make the level be readable by connection groups in this list.") @QueryParam("connectionGroupIds")  String connectionGroupIds,@ApiParam(value = "Set the amount of money available to spend, once 0 deactivate level. Set to a negative value for unlimited.") @QueryParam("balance")  Double balance,@ApiParam(value = "If true set the game level as active. Default is false.") @QueryParam("active")  Boolean active,@ApiParam(value = "If true then scoring will give tickets. Default is false.") @QueryParam("allocateTickets")  Boolean allocateTickets,@ApiParam(value = "The number of tickets to reward") @QueryParam("ticketCount")  Long ticketCount,@ApiParam(value = "The type of ticket to reward, null means default type") @QueryParam("ticketType")  String ticketType,@ApiParam(value = "The number of points to award for completing a level") @QueryParam("points")  Long points,@ApiParam(value = "Title of the tutorial.") @QueryParam("tutorialTitle")  String tutorialTitle,@ApiParam(value = "Message of the tutotrial.") @QueryParam("tutorialMessage")  String tutorialMessage,@ApiParam(value = "Alignment of the tutorial image. Default to NONE. Possible values are: NONE, IMAGE_ABOVE, IMAGE_BELOW, IMAGE_LEFT, IMAGE_RIGHT, IMAGE_ONLY, TEXT_ONLY") @QueryParam("tutorialAlignment")  String tutorialAlignment,@ApiParam(value = "Asset id of the tutorial image.") @QueryParam("tutorialImageAssetId")  Long tutorialImageAssetId,@ApiParam(value = "id of the offer") @QueryParam("offerId")  Long offerId,@ApiParam(value = "external custom client defined data") @QueryParam("metaData")  String metaData,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.createGameLevel(version, accountId, name, gameData, gameDataSuffix, appKey, description, difficulty, appVersion, assetImageId, assetIconId, visibility, friendGroup, connectionIds, connectionGroupIds, balance, active, allocateTickets, ticketCount, ticketType, points, tutorialTitle, tutorialMessage, tutorialAlignment, tutorialImageAssetId, offerId, metaData, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/orson/stories/episodes/instant")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Creates an instant episode", notes = "Creates an instant episode for a given StoryStrip by providing all necessary inputs, interview recordings, and pictures, kicking off a render immediately.", response = OrsonEpisodeResponse.class, tags={ "Orson", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = OrsonEpisodeResponse.class)
    })
    public Response createInstantEpisode(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "Sirqul Account Id", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "Request Data String", required = true) @QueryParam("data") @NotNull  String data,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.createInstantEpisode(version, accountId, data, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/leaderboard/create")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Create a leaderboard based on the rankingType, rankMode(leaderboardMode), sortField and limitation", notes = "Create a leaderboard based on the rankingType, rankMode(leaderboardMode), sortField and limitation", response = LeaderboardResponse.class, tags={ "Leaderboard", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = LeaderboardResponse.class)
    })
    public Response createLeaderboard(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The account id of the user creating the leaderboard.") @QueryParam("accountId")  Long accountId,@ApiParam(value = "The application key") @QueryParam("appKey")  String appKey,@ApiParam(value = "a unique label for identifying the ranking. This can be any alphanumeric string with a maximum length of 64 characters. There are also default rank types to use which include: POINTS, DOWNLOADS, INVITATIONS, CREATIONS, VOTES, REDEEMED, ACTIONS") @QueryParam("rankType")  String rankType,@ApiParam(value = "the type of search to perform. Possible values include: GLOBAL - searches scores globally (all users in the system are included in the ranking); LOCAL - filters results by select users and on users that have logged into the same device; SEARCH - does a GLOBAL search by keyword; CUSTOM - does a LOCAL search by keyword") @QueryParam("leaderboardMode")  String leaderboardMode,@ApiParam(value = "a MultipartFile containing the icon image of the leaderboard (this will only be used if \"iconAssetId\" is empty)") @QueryParam("iconMedia")  File iconMedia,@ApiParam(value = "The asset ID to set the leaderboard icon") @QueryParam("iconAssetId")  Long iconAssetId,@ApiParam(value = "a MultipartFile containing the icon banner of the leaderboard (this will only be used if \"bannerAssetId\" is empty)") @QueryParam("bannerMedia")  File bannerMedia,@ApiParam(value = "The asset ID to set the leaderboard banner") @QueryParam("bannerAssetId")  Long bannerAssetId,@ApiParam(value = "limit number of rankings for each leaderboard") @QueryParam("limitation")  Integer limitation,@ApiParam(value = "determines how to order and rank the results. Possible values include: TOTAL, WEEKLY, DAILY, TOP, LOWEST") @QueryParam("sortField")  String sortField,@ApiParam(value = "leaderboard's title") @QueryParam("title")  String title,@ApiParam(value = "leaderboard's description") @QueryParam("description")  String description,@ApiParam(value = "custom meta data for the leaderboard") @QueryParam("metaData")  String metaData,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.createLeaderboard(version, accountId, appKey, rankType, leaderboardMode, iconMedia, iconAssetId, bannerMedia, bannerAssetId, limitation, sortField, title, description, metaData, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/listing/create")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Create Listing", notes = "Creates a listing.", response = ListingFullResponse.class, tags={ "Listing", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = ListingFullResponse.class)
    })
    public Response createListing(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the user's account ID", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "the name of the listing", required = true) @QueryParam("name") @NotNull  String name,@ApiParam(value = "comma separated list of filter IDs") @QueryParam("filterIds")  String filterIds,@ApiParam(value = "the description of the listing") @QueryParam("description")  String description,@ApiParam(value = "the start date of the listing") @QueryParam("start")  Long start,@ApiParam(value = "the end date of the listing") @QueryParam("end")  Long end,@ApiParam(value = "the name of the location the listing will be held at") @QueryParam("locationName")  String locationName,@ApiParam(value = "the description of the location the listing will be held at") @QueryParam("locationDescription")  String locationDescription,@ApiParam(value = "determines whether the listing is public or private", defaultValue = "false") @DefaultValue("false") @QueryParam("isPrivate")  Boolean isPrivate,@ApiParam(value = "external identifier used by a third party") @QueryParam("externalId")  String externalId,@ApiParam(value = "secondary external identifier used by a third party") @QueryParam("externalId2")  String externalId2,@ApiParam(value = "external group identifier used by a third party") @QueryParam("externalGroupId")  String externalGroupId,@ApiParam(value = "Sets the active flag") @QueryParam("active")  Boolean active,@ApiParam(value = "external custom client defined data") @QueryParam("metaData")  String metaData,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.createListing(version, accountId, name, filterIds, description, start, end, locationName, locationDescription, isPrivate, externalId, externalId2, externalGroupId, active, metaData, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/location")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Create new location", notes = "Create a new location from a real object location.", response = SirqulResponse.class, tags={ "LocationApiV2", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response createLocationV2(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "") @Valid  Location body,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.createLocationV2(version, body, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/media/create")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Create Media", notes = "Create a media offering.", response = MediaOfferResponse.class, tags={ "Media", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = MediaOfferResponse.class)
    })
    public Response createMedia(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The account id of the logged in user", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "The title (255 char limit)", required = true) @QueryParam("title") @NotNull  String title,@ApiParam(value = "The bar code type {NONE, UPC, CODE_128, QR, CUSTOM_MEDIA}", required = true, allowableValues="NONE, UPC, CODE_128, QR, CUSTOM_MEDIA") @QueryParam("barcodeType") @NotNull  String barcodeType,@ApiParam(value = "Overrides the expiration date so that the offer does not expire", required = true) @QueryParam("noExpiration") @NotNull  Boolean noExpiration,@ApiParam(value = "The limit of how many times the offer can be used by consumers", required = true) @QueryParam("availableLimit") @NotNull  Integer availableLimit,@ApiParam(value = "The limit of how many times a user can used the same offer", required = true) @QueryParam("availableLimitPerUser") @NotNull  Integer availableLimitPerUser,@ApiParam(value = "The limit of how many times the offer can be added to consumer wallets", required = true) @QueryParam("addedLimit") @NotNull  Integer addedLimit,@ApiParam(value = "The limit of how many times the offer can be viewed", required = true) @QueryParam("viewLimit") @NotNull  Integer viewLimit,@ApiParam(value = "The maximum number of times the offer can be printed", required = true) @QueryParam("maxPrints") @NotNull  Integer maxPrints,@ApiParam(value = "The cost of the offer in tickets", required = true) @QueryParam("ticketPrice") @NotNull  Long ticketPrice,@ApiParam(value = "The retail/full price cost of the offer in real currency", required = true) @QueryParam("fullPrice") @NotNull  Double fullPrice,@ApiParam(value = "The cost of the offer at a discounted price (what the consumer pays)", required = true) @QueryParam("discountPrice") @NotNull  Double discountPrice,@ApiParam(value = "The special offer type {ALL, REGULAR_OFFER, ACT_NOW, GET_THERE_NOW}", required = true, allowableValues="ALL, RESERVABLE, REGULAR_OFFER, ACT_NOW, GET_THERE_NOW, SQOOT, TICKETS, YIPIT") @QueryParam("specialOfferType") @NotNull  String specialOfferType,@ApiParam(value = "The offer visibility {PUBLIC, REWARDABLE, TRIGGERABLE}", required = true, allowableValues="PUBLIC, LISTABLE, REWARDABLE, TRIGGERABLE, PRIVATE") @QueryParam("offerVisibility") @NotNull  String offerVisibility,@ApiParam(value = "Sets the active flag", required = true) @QueryParam("active") @NotNull  Boolean active,@ApiParam(value = "Comma separated list of retailer location ids. This will assign the offer to these retailer locations.") @QueryParam("retailerLocationIds")  String retailerLocationIds,@ApiParam(value = "The sub title (255 char limit)") @QueryParam("subTitle")  String subTitle,@ApiParam(value = "The details of the media") @QueryParam("details")  String details,@ApiParam(value = "A string for custom details (255 char limit)") @QueryParam("subDetails")  String subDetails,@ApiParam(value = "The fine print of the media") @QueryParam("finePrint")  String finePrint,@ApiParam(value = "The bar code entry string") @QueryParam("barcodeEntry")  String barcodeEntry,@ApiParam(value = "An external identifier. What the identifier will be used for and how it is formatted is up to the frontend developer") @QueryParam("externalRedeemOptions")  String externalRedeemOptions,@ApiParam(value = "The clickUrl of the offer") @QueryParam("externalUrl")  String externalUrl,@ApiParam(value = "The type of ticket to reward, null means default type") @QueryParam("ticketsRewardType")  String ticketsRewardType,@ApiParam(value = "Determines how many tickets are awarded") @QueryParam("ticketsReward")  Long ticketsReward,@ApiParam(value = "The date of when the offer will be visible to consumers") @QueryParam("activated")  Long activated,@ApiParam(value = "The date of when the offer expires") @QueryParam("expires")  Long expires,@ApiParam(value = "the type of ticket needed to buy offer") @QueryParam("ticketPriceType")  String ticketPriceType,@ApiParam(value = "show how many of the media is remaining (if there is a limit)") @QueryParam("showRemaining")  Boolean showRemaining,@ApiParam(value = "show how many of the media has been redeemed") @QueryParam("showRedeemed")  Boolean showRedeemed,@ApiParam(value = "if the media has been replaced") @QueryParam("replaced")  Boolean replaced,@ApiParam(value = "if the media should be featured or not") @QueryParam("featured")  Boolean featured,@ApiParam(value = "Comma separated list of category ids") @QueryParam("categoryIds")  String categoryIds,@ApiParam(value = "Comma separated list of filter ids") @QueryParam("filterIds")  String filterIds,@ApiParam(value = "The id of the barcode asset") @QueryParam("barcodeAssetId")  Long barcodeAssetId,@ApiParam(value = "The id of the an offer asset") @QueryParam("imageAssetId")  Long imageAssetId,@ApiParam(value = "The id of the an offer asset") @QueryParam("imageAssetId1")  Long imageAssetId1,@ApiParam(value = "The id of the an offer asset") @QueryParam("imageAssetId2")  Long imageAssetId2,@ApiParam(value = "The id of the an offer asset") @QueryParam("imageAssetId3")  Long imageAssetId3,@ApiParam(value = "The id of the an offer asset") @QueryParam("imageAssetId4")  Long imageAssetId4,@ApiParam(value = "The id of the an offer asset") @QueryParam("imageAssetId5")  Long imageAssetId5,@ApiParam(value = "The maker of the item.") @QueryParam("publisher")  String publisher,@ApiParam(value = "The redeemable start date/time of the offer.") @QueryParam("redeemableStart")  Long redeemableStart,@ApiParam(value = "The redeemable start date/time of the offer.") @QueryParam("redeemableEnd")  Long redeemableEnd,@ApiParam(value = "The condition type of the media", allowableValues="NEW, USED, REFURBISHED, OTHER") @QueryParam("conditionType")  String conditionType,@ApiParam(value = "The ISBN id") @QueryParam("isbn")  String isbn,@ApiParam(value = "The ASIN id") @QueryParam("asin")  String asin,@ApiParam(value = "The list of catelog numbers, comma seperated") @QueryParam("catalogNumbers")  String catalogNumbers,@ApiParam(value = "The parental control rating") @QueryParam("parentalRating")  String parentalRating,@ApiParam(value = "The date the media is available to use") @QueryParam("availabilityDate")  Long availabilityDate,@ApiParam(value = "the media type", allowableValues="APK, APPLICATION, IMAGE, AUDIO, VIDEO, MULTIPART, BAR_CODE, TEXT, OTHER") @QueryParam("mediaType")  String mediaType,@ApiParam(value = "The total playing time of the media item") @QueryParam("duration")  Integer duration,@ApiParam(value = "The created/author of the media item") @QueryParam("author")  String author,@ApiParam(value = "The date/time of when the media item was originally released") @QueryParam("releaseDate")  Long releaseDate,@ApiParam(value = "the IDs of the collections this media should be assigned to") @QueryParam("collectionIds")  String collectionIds,@ApiParam(value = "ability to assign if this media should active or not") @QueryParam("availability")  String availability,@ApiParam(value = "ability to assign when the media expires") @QueryParam("availabilitySummary")  String availabilitySummary,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.createMedia(version, accountId, title, barcodeType, noExpiration, availableLimit, availableLimitPerUser, addedLimit, viewLimit, maxPrints, ticketPrice, fullPrice, discountPrice, specialOfferType, offerVisibility, active, retailerLocationIds, subTitle, details, subDetails, finePrint, barcodeEntry, externalRedeemOptions, externalUrl, ticketsRewardType, ticketsReward, activated, expires, ticketPriceType, showRemaining, showRedeemed, replaced, featured, categoryIds, filterIds, barcodeAssetId, imageAssetId, imageAssetId1, imageAssetId2, imageAssetId3, imageAssetId4, imageAssetId5, publisher, redeemableStart, redeemableEnd, conditionType, isbn, asin, catalogNumbers, parentalRating, availabilityDate, mediaType, duration, author, releaseDate, collectionIds, availability, availabilitySummary, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/mission/create")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Create Mission", notes = "Create a user defined mission.", response = MissionResponse.class, tags={ "Mission", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = MissionResponse.class)
    })
    public Response createMission(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The logged in user.", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "The title of the mission", required = true) @QueryParam("title") @NotNull  String title,@ApiParam(value = "The description of the mission") @QueryParam("description")  String description,@ApiParam(value = "Custom string client apps can use for searching/filtering missions") @QueryParam("subType")  String subType,@ApiParam(value = "The date/time to start the mission, send 0 to unset") @QueryParam("startDate")  Long startDate,@ApiParam(value = "The date/time to end the mission, send 0 to unset") @QueryParam("endDate")  Long endDate,@ApiParam(value = "Activate/deactivate the mission") @QueryParam("active")  Boolean active,@ApiParam(value = "the game level ids to include in the mission, comma separated") @QueryParam("gameLevelIds")  String gameLevelIds,@ApiParam(value = "creatives to associate with the mission") @QueryParam("creativeIds")  String creativeIds,@ApiParam(value = "audiences to associate with the mission") @QueryParam("audienceIds")  String audienceIds,@ApiParam(value = "This parameter is deprecated.") @QueryParam("missionTask")  String missionTask,@ApiParam(value = "The string identifier for a mission format (this is not the missionFormatId)") @QueryParam("formatType")  String formatType,@ApiParam(value = "The offerId to give as a reward") @QueryParam("offerId")  Long offerId,@ApiParam(value = "Set the amount of money available to spend, once 0 deactivate mission. Set to a negative value for unlimited.") @QueryParam("balance")  Double balance,@ApiParam(value = "Flag to mark the mission as eligible for advanced reporting") @QueryParam("advancedReporting")  Boolean advancedReporting,@ApiParam(value = "Flag to indicate owner should receive tickets for completed missions") @QueryParam("allocateTickets")  Boolean allocateTickets,@ApiParam(value = "The number of tickets to reward") @QueryParam("ticketCount")  Long ticketCount,@ApiParam(value = "The type of ticket to reward, null means default type") @QueryParam("ticketType")  String ticketType,@ApiParam(value = "The number of points to award for completing a mission") @QueryParam("points")  Long points,@ApiParam(value = "external custom client defined data") @QueryParam("metaData")  String metaData,@ApiParam(value = "Comma separated list of application ids") @QueryParam("applicationIds")  String applicationIds,@ApiParam(value = "Deprecated parameter for device names") @QueryParam("devices")  String devices,@ApiParam(value = "Comma separated list of device ids") @QueryParam("deviceIds")  String deviceIds,@ApiParam(value = "Comma separated list of device version ranges") @QueryParam("deviceVersions")  String deviceVersions,@ApiParam(value = "List of lat/long pairs for mission locations") @QueryParam("locations")  String locations,@ApiParam(value = "Comma separated list of radii for locations") @QueryParam("radius")  String radius,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.createMission(version, accountId, title, description, subType, startDate, endDate, active, gameLevelIds, creativeIds, audienceIds, missionTask, formatType, offerId, balance, advancedReporting, allocateTickets, ticketCount, ticketType, points, metaData, applicationIds, devices, deviceIds, deviceVersions, locations, radius, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/mission/invite/create")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Create Mission Invite", notes = "Create the mission invite. An account can only be invited to a mission one time. For missions that require user submission and reviewing the permissionableType and permissionableId need to be provided.", response = MissionResponse.class, tags={ "Mission Invite", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = MissionResponse.class)
    })
    public Response createMissionInvite(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the device id (deviceId or accountId required).") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "the account id of the user (deviceId or accountId required).") @QueryParam("accountId")  Long accountId,@ApiParam(value = "The mission to find the invite for.") @QueryParam("missionId")  Long missionId,@ApiParam(value = "code to be entered for user to join the mission") @QueryParam("joinCode")  String joinCode,@ApiParam(value = "Include the game level data with the mission.") @QueryParam("includeGameData")  Boolean includeGameData,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.createMissionInvite(version, deviceId, accountId, missionId, joinCode, includeGameData, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/thirdparty/network/create")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Create Network", notes = "Creates a custom third party network.", response = ThirdPartyNetworkResponse.class, tags={ "ThirdParty Credentials", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = ThirdPartyNetworkResponse.class)
    })
    public Response createNetwork(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The account id making the request", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "The name of the network", required = true) @QueryParam("name") @NotNull  String name,@ApiParam(value = "Whether the network uses introspection calls", required = true) @QueryParam("enableIntrospection") @NotNull  Boolean enableIntrospection,@ApiParam(value = "The description of the network") @QueryParam("description")  String description,@ApiParam(value = "HTTP method to use for introspection calls (e.g., GET, POST)") @QueryParam("introspectionMethod")  String introspectionMethod,@ApiParam(value = "The HTTP URL of the introspection call") @QueryParam("introspectionURL")  String introspectionURL,@ApiParam(value = "The parameters of the introspection call") @QueryParam("introspectionParams")  String introspectionParams,@ApiParam(value = "Required response params") @QueryParam("requiredRootField")  String requiredRootField,@ApiParam(value = "Whether this network uses MFA") @QueryParam("enableMFA")  Boolean enableMFA,@ApiParam(value = "Size of the MFA token") @QueryParam("sizeMFA")  Integer sizeMFA,@ApiParam(value = "Shelf life (seconds) of the MFA token") @QueryParam("shelfLifeMFA")  Integer shelfLifeMFA,@ApiParam(value = "OAuth token endpoint URL") @QueryParam("oauthTokenURL")  String oauthTokenURL,@ApiParam(value = "OAuth private key file (multipart)") @QueryParam("oauthPrivateKey")  File oauthPrivateKey,@ApiParam(value = "OAuth public key file (multipart)") @QueryParam("oauthPublicKey")  File oauthPublicKey,@ApiParam(value = "OAuth client id") @QueryParam("oauthClientId")  String oauthClientId,@ApiParam(value = "OAuth secret key") @QueryParam("oauthSecretKey")  String oauthSecretKey,@ApiParam(value = "")  String body,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.createNetwork(version, accountId, name, enableIntrospection, description, introspectionMethod, introspectionURL, introspectionParams, requiredRootField, enableMFA, sizeMFA, shelfLifeMFA, oauthTokenURL, oauthPrivateKey, oauthPublicKey, oauthClientId, oauthSecretKey, body, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/note/create")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Create Note", notes = "This is used to leave a comment (note) on a notable object (i.e. albums, album contests, assets, game levels, offers, offer locations, retailers, retailer locations, and theme descriptors). Leaving a comment on a notable object will be visiable to everyone who has access to view the object.", response = NoteResponse.class, tags={ "Note", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = NoteResponse.class)
    })
    public Response createNote(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The message the user wishes to leave a comment on", required = true) @QueryParam("comment") @NotNull  String comment,@ApiParam(value = "The unique device identifier that made the request (either deviceId or accountId must be used)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "The unique accountId that made the request (either deviceId or accountId must be used)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "The notable object type {ALBUM, ALBUM_CONTEST, ASSET, GAME_LEVEL, OFFER, OFFER_LOCATION, RETAILER, RETAILER_LOCATION, THEME_DESCRIPTOR}") @QueryParam("notableType")  String notableType,@ApiParam(value = "The id of the notable object") @QueryParam("notableId")  Long notableId,@ApiParam(value = "The custom string defined by the client (used for differentiating various note types)") @QueryParam("noteType")  String noteType,@ApiParam(value = "A comma separated list of asset IDs to add with the note") @QueryParam("assetIds")  String assetIds,@ApiParam(value = "search tags") @QueryParam("tags")  String tags,@ApiParam(value = "This is used for sending out group notifications. For example, when someone adds a note to an asset which is also a part of an album, everyone in the album will receive a notification. This is achieved by passing in the permissionable type (in this case \"album\"), and the permissionable id (the album id). Possible types: {ALBUM, ALBUM_CONTEST, GAME_LEVEL, THEME_DESCRIPTOR}") @QueryParam("permissionableType")  String permissionableType,@ApiParam(value = "The id of the permissionable object (for sending group notifications)") @QueryParam("permissionableId")  Long permissionableId,@ApiParam(value = "The application key used to identify the application") @QueryParam("appKey")  String appKey,@ApiParam(value = "The description of the location") @QueryParam("locationDescription")  String locationDescription,@ApiParam(value = "The current location of the user") @QueryParam("latitude")  Double latitude,@ApiParam(value = "The current location of the user") @QueryParam("longitude")  Double longitude,@ApiParam(value = "External custom client defined data") @QueryParam("metaData")  String metaData,@ApiParam(value = "Comma separated list of additional account IDs that will receive the note notifications") @QueryParam("receiverAccountIds")  String receiverAccountIds,@ApiParam(value = "whether to return the full response or not") @QueryParam("returnFullResponse")  Boolean returnFullResponse,@ApiParam(value = "Check true if need to initialize an asset and assign to current note") @QueryParam("initializeAsset")  Boolean initializeAsset,@ApiParam(value = "Return null fields for asset response when creating an asset") @QueryParam("assetReturnNulls")  Boolean assetReturnNulls,@ApiParam(value = "the album the asset will be added to (optional)") @QueryParam("assetAlbumId")  Long assetAlbumId,@ApiParam(value = "the collection ID that the asset is associated with") @QueryParam("assetCollectionId")  Long assetCollectionId,@ApiParam(value = "the default album to add the asset to") @QueryParam("assetAddToDefaultAlbum")  String assetAddToDefaultAlbum,@ApiParam(value = "the media library to add the asset to") @QueryParam("assetAddToMediaLibrary")  Boolean assetAddToMediaLibrary,@ApiParam(value = "the version code of the asset") @QueryParam("assetVersionCode")  Integer assetVersionCode,@ApiParam(value = "the version name of the asset") @QueryParam("assetVersionName")  String assetVersionName,@ApiParam(value = "the meta data of the asset") @QueryParam("assetMetaData")  String assetMetaData,@ApiParam(value = "the caption of the asset") @QueryParam("assetCaption")  String assetCaption,@ApiParam(value = "the media of the asset") @QueryParam("assetMedia")  File assetMedia,@ApiParam(value = "the media URL of the asset") @QueryParam("assetMediaUrl")  String assetMediaUrl,@ApiParam(value = "the media string of the asset") @QueryParam("assetMediaString")  String assetMediaString,@ApiParam(value = "the media string file name of the asset") @QueryParam("assetMediaStringFileName")  String assetMediaStringFileName,@ApiParam(value = "the media string content type of the asset") @QueryParam("assetMediaStringContentType")  String assetMediaStringContentType,@ApiParam(value = "the attached media of the asset") @QueryParam("assetAttachedMedia")  File assetAttachedMedia,@ApiParam(value = "the attached media URL of the asset") @QueryParam("assetAttachedMediaUrl")  String assetAttachedMediaUrl,@ApiParam(value = "the attached media string of the asset") @QueryParam("assetAttachedMediaString")  String assetAttachedMediaString,@ApiParam(value = "the attached media string file name of the asset") @QueryParam("assetAttachedMediaStringFileName")  String assetAttachedMediaStringFileName,@ApiParam(value = "the attached media string content type of the asset") @QueryParam("assetAttachedMediaStringContentType")  String assetAttachedMediaStringContentType,@ApiParam(value = "the location description for the asset") @QueryParam("assetLocationDescription")  String assetLocationDescription,@ApiParam(value = "the application for the asset") @QueryParam("assetApp")  String assetApp,@ApiParam(value = "the search tags used for the asset") @QueryParam("assetSearchTags")  String assetSearchTags,@ApiParam(value = "the latitude of the asset") @QueryParam("assetLatitude")  Double assetLatitude,@ApiParam(value = "the longitude of the asset") @QueryParam("assetLongitude")  BigDecimal assetLongitude,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.createNote(version, comment, deviceId, accountId, notableType, notableId, noteType, assetIds, tags, permissionableType, permissionableId, appKey, locationDescription, latitude, longitude, metaData, receiverAccountIds, returnFullResponse, initializeAsset, assetReturnNulls, assetAlbumId, assetCollectionId, assetAddToDefaultAlbum, assetAddToMediaLibrary, assetVersionCode, assetVersionName, assetMetaData, assetCaption, assetMedia, assetMediaUrl, assetMediaString, assetMediaStringFileName, assetMediaStringContentType, assetAttachedMedia, assetAttachedMediaUrl, assetAttachedMediaString, assetAttachedMediaStringFileName, assetAttachedMediaStringContentType, assetLocationDescription, assetApp, assetSearchTags, assetLatitude, assetLongitude, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/notification/template/create")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Create Notification Template", notes = "Create a notification template. Developers will only be able to create notification templates for their own applications.", response = NotificationTemplateResponse.class, tags={ "Notification", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = NotificationTemplateResponse.class)
    })
    public Response createNotificationTemplate(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The account ID of the user.", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "Filter results by notification type: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION.", required = true) @QueryParam("conduit") @NotNull  String conduit,@ApiParam(value = "title of the notification template", required = true) @QueryParam("title") @NotNull  String title,@ApiParam(value = "body of the notification template", required = true) @QueryParam("body") @NotNull  String body,@ApiParam(value = "Filter results by application.") @QueryParam("appKey")  String appKey,@ApiParam(value = "Filter results by event.") @QueryParam("event")  String event,@ApiParam(value = "tags associated with the note template") @QueryParam("tags")  String tags,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.createNotificationTemplate(version, accountId, conduit, title, body, appKey, event, tags, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/object/create")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Create Object", notes = "Create an Object Store table.  By default tables will have the columns: id, created, updated, deleted.  Names og objects should be camel case with the first letter capitalized, for example: MyTableName.   Duplicate object names are not allowed.   The object name cannot be any of the following reserved words: ACCESSIBLE, ADD, ALL, ALTER, ANALYZE, AND, AS, ASC, ASENSITIVE, BEFORE, BETWEEN, BIGINT, BINARY, BLOB, BOTH, BY, CALL, CASCADE, CASE, CHANGE, CHAR, CHARACTER, CHECK, COLLATE, COLUMN, CONDITION, CONSTRAINT, CONTINUE, CONVERT, CREATE, CROSS, CURRENT_, ATE, CURRENT_TIME, CURRENT_TIMESTAMP, CURRENT_USER, CURSOR, DATABASE, DATABASES, DAY_HOUR, DAY_MICROSECOND, DAY_MINUTE, DAY_SECOND, DEC, DECIMAL, DECLARE, DEFAULT, DELAYED, DELETE, DESC, DESCRIBE, DETERMINISTIC, DISTINCT, DISTINCTROW, DIV, DOUBLE, DROP, DUAL, EACH, ELSE, ELSEIF, ENCLOSED, ESCAPED, EXISTS, EXIT, EXPLAIN, FALSE, FETCH, FLOAT, FLOAT4, FLOAT8, FOR, FORCE, FOREIGN, FROM, FULLTEXT, GRANT, GROUP, HAVING, HIGH_PRIORITY, HOUR_MICROSECOND, HOUR_MINUTE, HOUR_SECOND, IF, IGNORE, IN, INDEX, INFILE, INNER, INOUT, INSENSITIVE, INSERT, INT, INT1, INT2, INT3, INT4, INT8, INTEGER, INTERVAL, INTO, IS, ITERATE, JOIN, KEY, KEYS, KILL, LEADING, LEAVE, LEFT, LIKE, LIMIT, LINEAR, LINES, LOAD, LOCALTIME, LOCALTIMESTAMP, LOCK, LONG, LONGBLOB, LONGT, XT, LOOP, LOW_PRIORITY, MASTER_SSL_VERIFY_SERVER_CERT, MATCH, MAXVALUE, MEDIUMBLOB, MEDIUMINT, MEDIUMTEXT, MIDDLEINT, MINUTE_MICROSECOND, MINUTE_SECOND, MOD, MODIFIES, NATURAL, NOT, NO_WRITE_TO_BINLOG, NULL, NUMERIC, ON, OPTIMIZE, OPTION, OPTIONALLY, OR, ORDER, OUT, OUTER, OUTFILE, PRECISION, PRIMARY, PROCEDURE, PURGE, RANGE, READ, READS, READ_WRITE, REAL, REFERENCES, REGEXP, RELEASE, RENAME, REPEAT, REPLACE, REQUIRE, RESIGNAL, RESTRICT, RETURN, REVOKE, RIGHT, RLIKE, SCHEMA, SCHEMAS, SECOND_MICROSECOND, SELECT, SENSITIVE, SEPARATOR, SET, SHOW, SIGNAL, SMALLINT, SPATIAL, SPECIFIC, SQL, SQLEXCEPTION, SQLSTATE, SQLWARNING, SQL_BIG_RESULT, SQL_CALC_FOUND_ROWS, SQL_SMALL_RESULT, SSL, STARTING, STRAIGHT_JOIN, TABLE, TERMINATED, THEN, TINYBLOB, TINYINT, TINYTEXT, TO, TRAILING, TRIGGER, TRUE, NDO, UNION, UNIQUE, UNLOCK, UNSIGNED, UPDATE, USAGE, USE, USING, UTC_DATE, UTC_TIME, UTC_TIMESTAMP, VALUES, VARBINARY, VARCHAR, VARCHARACTER, VARYING, WHEN, WHERE, WHILE, WITH, WRITE, XOR, YEAR_MONTH, ZEROFILL, GENERAL, IGNORE_SERVER_IDS, MASTER_HEARTBEAT_PERIOD, SLOW. ", response = ObjectStoreResponse.class, tags={ "Object Store", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = ObjectStoreResponse.class)
    })
    public Response createObject(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The account id of the logged in user", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "The application key for updating an existing application", required = true) @QueryParam("appKey") @NotNull  String appKey,@ApiParam(value = "The name of the object to create", required = true) @QueryParam("objectName") @NotNull  String objectName,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.createObject(version, accountId, appKey, objectName, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/retailer/offer/create")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Create Offer", notes = "Create an offer and assign it to the provided retailer locations.", response = RetailerOfferResponse.class, tags={ "Offer", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = RetailerOfferResponse.class)
    })
    public Response createOffer(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "If true return all the offer locations associated with the offer", required = true) @QueryParam("includeOfferLocations") @NotNull  Boolean includeOfferLocations,@ApiParam(value = "The title (255 char limit)", required = true) @QueryParam("title") @NotNull  String title,@ApiParam(value = "The bar code type {NONE, UPC, CODE_128, QR, CUSTOM_MEDIA}", required = true, allowableValues="NONE, UPC, CODE_128, QR, CUSTOM_MEDIA") @QueryParam("barcodeType") @NotNull  String barcodeType,@ApiParam(value = "Overrides the expiration date so that the offer does not expire", required = true) @QueryParam("noExpiration") @NotNull  Boolean noExpiration,@ApiParam(value = "The limit of how many times the offer can be used by consumers", required = true) @QueryParam("availableLimit") @NotNull  Integer availableLimit,@ApiParam(value = "The limit of how many times a user can used the same offer", required = true) @QueryParam("availableLimitPerUser") @NotNull  Integer availableLimitPerUser,@ApiParam(value = "The limit of how many times the offer can be added to consumer wallets", required = true) @QueryParam("addedLimit") @NotNull  Integer addedLimit,@ApiParam(value = "The limit of how many times the offer can be viewed", required = true) @QueryParam("viewLimit") @NotNull  Integer viewLimit,@ApiParam(value = "The maximum number of times the offer can be printed", required = true) @QueryParam("maxPrints") @NotNull  Integer maxPrints,@ApiParam(value = "The cost of the offer in tickets", required = true) @QueryParam("ticketPrice") @NotNull  Long ticketPrice,@ApiParam(value = "The retail/full price cost of the offer in real currency", required = true) @QueryParam("fullPrice") @NotNull  Double fullPrice,@ApiParam(value = "The cost of the offer at a discounted price (what the consumer pays)", required = true) @QueryParam("discountPrice") @NotNull  Double discountPrice,@ApiParam(value = "The offer type {VOUCHER, COUPON, PRODUCT, EVENT, MEDIA, DEVICE}", required = true, allowableValues="VOUCHER, COUPON, PRODUCT, MEDIA, EVENT, DEVICE") @QueryParam("offerType") @NotNull  String offerType,@ApiParam(value = "The special offer type {ALL, REGULAR_OFFER, ACT_NOW, GET_THERE_NOW}", required = true, allowableValues="ALL, RESERVABLE, REGULAR_OFFER, ACT_NOW, GET_THERE_NOW, SQOOT, TICKETS, YIPIT") @QueryParam("specialOfferType") @NotNull  String specialOfferType,@ApiParam(value = "The offer visibility {PUBLIC, REWARDABLE, TRIGGERABLE}", required = true, allowableValues="PUBLIC, LISTABLE, REWARDABLE, TRIGGERABLE, PRIVATE") @QueryParam("offerVisibility") @NotNull  String offerVisibility,@ApiParam(value = "Sets the active flag", required = true) @QueryParam("active") @NotNull  Boolean active,@ApiParam(value = "The device id (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "The account id (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "Custom string field for doing full-text searches") @QueryParam("tags")  String tags,@ApiParam(value = "the parent offer id") @QueryParam("parentOfferId")  Long parentOfferId,@ApiParam(value = "Comma separated list of retailer location ids. This will assign the offer to these retailer locations.") @QueryParam("retailerLocationIds")  String retailerLocationIds,@ApiParam(value = "A list of json data that has offer location specific values.") @QueryParam("offerLocations")  String offerLocations,@ApiParam(value = "The sub title (255 char limit)") @QueryParam("subTitle")  String subTitle,@ApiParam(value = "The details") @QueryParam("details")  String details,@ApiParam(value = "A string for custom details (255 char limit)") @QueryParam("subDetails")  String subDetails,@ApiParam(value = "The fine print") @QueryParam("finePrint")  String finePrint,@ApiParam(value = "The bar code entry string") @QueryParam("barcodeEntry")  String barcodeEntry,@ApiParam(value = "An external identifier. What the identifier will be used for and how it is formatted is up to the frontend developer") @QueryParam("externalRedeemOptions")  String externalRedeemOptions,@ApiParam(value = "The clickUrl of the offer") @QueryParam("externalUrl")  String externalUrl,@ApiParam(value = "an external identifier. What the identifier will be used for and how it is formatted is up to the frontend developer") @QueryParam("externalId")  String externalId,@ApiParam(value = "The type of ticket to reward, null means default type") @QueryParam("ticketsRewardType")  String ticketsRewardType,@ApiParam(value = "Determines how many tickets are awarded") @QueryParam("ticketsReward")  Long ticketsReward,@ApiParam(value = "The date of when the offer will be visible to consumers") @QueryParam("activated")  Long activated,@ApiParam(value = "The date of when the offer expires") @QueryParam("expires")  Long expires,@ApiParam(value = "the type of ticket needed to buy offer") @QueryParam("ticketPriceType")  String ticketPriceType,@ApiParam(value = "show remaining offers available") @QueryParam("showRemaining")  Boolean showRemaining,@ApiParam(value = "show how many offers have been redeemed") @QueryParam("showRedeemed")  Boolean showRedeemed,@ApiParam(value = "") @QueryParam("replaced")  Boolean replaced,@ApiParam(value = "flag if offer is featured or not") @QueryParam("featured")  Boolean featured,@ApiParam(value = "Comma separated list of category ids") @QueryParam("categoryIds")  String categoryIds,@ApiParam(value = "Comma separated list of filter ids") @QueryParam("filterIds")  String filterIds,@ApiParam(value = "The id of the barcode asset") @QueryParam("barcodeAssetId")  Long barcodeAssetId,@ApiParam(value = "The id of the an offer asset") @QueryParam("imageAssetId")  Long imageAssetId,@ApiParam(value = "The id of the an offer asset") @QueryParam("imageAssetId1")  Long imageAssetId1,@ApiParam(value = "The id of the an offer asset") @QueryParam("imageAssetId2")  Long imageAssetId2,@ApiParam(value = "The id of the an offer asset") @QueryParam("imageAssetId3")  Long imageAssetId3,@ApiParam(value = "The id of the an offer asset") @QueryParam("imageAssetId4")  Long imageAssetId4,@ApiParam(value = "The id of the an offer asset") @QueryParam("imageAssetId5")  Long imageAssetId5,@ApiParam(value = "The maker of the item.") @QueryParam("publisher")  String publisher,@ApiParam(value = "The redeemable start date/time of the offer.") @QueryParam("redeemableStart")  Long redeemableStart,@ApiParam(value = "The redeemable start date/time of the offer.") @QueryParam("redeemableEnd")  Long redeemableEnd,@ApiParam(value = "The brand. OfferType PRODUCT only.") @QueryParam("brand")  String brand,@ApiParam(value = "The product type. OfferType PRODUCT only.", allowableValues="APPAREL, APPLIANCES, APPS, ARTS_CRAFTS, AUTOMOTIVE, BABY, BEAUTY, BOOKS, CLASSICAL, COLLECTIBLES, DVD, ELECTRONICS, GIFT_CARDS, GOURMET_FOOD, GROCERY, HEALTH_PERSONAL_CARE, HOME_GARDEN, INDUSTRIAL, JEWELRY, KITCHEN, LAWN_GARDEN, MAGAZINES, MISCELLANEOUS, MUSICAL_INSTRUMENTS, OFFICE_PRODUCTS, OTHER, OUTDOOR_LIVING, PC_HARDWARE, PET_SUPPLIES, SHOES, SOFTWARE, SPORTING_GOODS, TOOLS, TOYS, VIDEO_GAMES, WATCHES, WIRELESS, WIRELESS_ACCESSORIES") @QueryParam("productType")  String productType,@ApiParam(value = "The condition. OfferType PRODUCT only.", allowableValues="NEW, USED, REFURBISHED, OTHER") @QueryParam("conditionType")  String conditionType,@ApiParam(value = "The ISBN id. OfferType PRODUCT only.") @QueryParam("isbn")  String isbn,@ApiParam(value = "The ASIN id. OfferType PRODUCT only.") @QueryParam("asin")  String asin,@ApiParam(value = "The list of catelog numbers, comma seperated. OfferType PRODUCT only.") @QueryParam("catalogNumbers")  String catalogNumbers,@ApiParam(value = "The department name. The OfferType PRODUCT only.") @QueryParam("department")  String department,@ApiParam(value = "The list of features, comma seperated. OfferType PRODUCT only.") @QueryParam("features")  String features,@ApiParam(value = "The MAP price. OfferType PRODUCT only.") @QueryParam("minimumPrice")  Double minimumPrice,@ApiParam(value = "The width of the item. OfferType PRODUCT only.") @QueryParam("width")  Double width,@ApiParam(value = "The height of the item. OfferType PRODUCT only.") @QueryParam("height")  Double height,@ApiParam(value = "The depth of the item. OfferType PRODUCT only.") @QueryParam("depth")  Double depth,@ApiParam(value = "The weight of the item. OfferType PRODUCT only.") @QueryParam("weight")  Double weight,@ApiParam(value = "The unit of measurement. OfferType PRODUCT only.", allowableValues="MILIMETER, CENTIMETER, METER, INCH, FOOT, YARD") @QueryParam("unit")  String unit,@ApiParam(value = "The studio name. OfferType PRODUCT only.") @QueryParam("studio")  String studio,@ApiParam(value = "The parental control rating. OfferType PRODUCT only.") @QueryParam("parentalRating")  String parentalRating,@ApiParam(value = "The date published. OfferType PRODUCT only.") @QueryParam("publishDate")  Long publishDate,@ApiParam(value = "The date available. OfferType PRODUCT only.") @QueryParam("availabilityDate")  Long availabilityDate,@ApiParam(value = "") @QueryParam("sizeId")  Long sizeId,@ApiParam(value = "The ID of the event listing") @QueryParam("listingId")  Long listingId,@ApiParam(value = "the media type of the offer", allowableValues="APK, APPLICATION, IMAGE, AUDIO, VIDEO, MULTIPART, BAR_CODE, TEXT, OTHER") @QueryParam("mediaType")  String mediaType,@ApiParam(value = "The total playing time of the media item. OfferType MEDIA only.") @QueryParam("duration")  Integer duration,@ApiParam(value = "The created/author of the media item. OfferType MEDIA only.") @QueryParam("author")  String author,@ApiParam(value = "The date/time of when the media item was originally released. OfferType MEDIA only.") @QueryParam("releaseDate")  Long releaseDate,@ApiParam(value = "") @QueryParam("collectionIds")  String collectionIds,@ApiParam(value = "The reboot hour time ranging from 0 to 23") @QueryParam("rebootTimeHour")  Integer rebootTimeHour,@ApiParam(value = "The reboot minute time ranging from 0 to 59") @QueryParam("rebootTimeMinute")  Integer rebootTimeMinute,@ApiParam(value = "If the device is idle for idleTimeoutInSecond then the device should timeout") @QueryParam("idleTimeoutInSecond")  Integer idleTimeoutInSecond,@ApiParam(value = "The serial number on the device") @QueryParam("serialNumber")  String serialNumber,@ApiParam(value = "The unique device id for the device") @QueryParam("udid")  String udid,@ApiParam(value = "The type of the device, for example: \"Kiosk\", \"Beacon\".") @QueryParam("deviceType")  String deviceType,@ApiParam(value = "Edysen device power level setting") @QueryParam("devicePower")  Double devicePower,@ApiParam(value = "Edysen device inteference setting") @QueryParam("deviceInterference")  Double deviceInterference,@ApiParam(value = "") @QueryParam("availability")  String availability,@ApiParam(value = "") @QueryParam("availabilitySummary")  String availabilitySummary,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.createOffer(version, includeOfferLocations, title, barcodeType, noExpiration, availableLimit, availableLimitPerUser, addedLimit, viewLimit, maxPrints, ticketPrice, fullPrice, discountPrice, offerType, specialOfferType, offerVisibility, active, deviceId, accountId, tags, parentOfferId, retailerLocationIds, offerLocations, subTitle, details, subDetails, finePrint, barcodeEntry, externalRedeemOptions, externalUrl, externalId, ticketsRewardType, ticketsReward, activated, expires, ticketPriceType, showRemaining, showRedeemed, replaced, featured, categoryIds, filterIds, barcodeAssetId, imageAssetId, imageAssetId1, imageAssetId2, imageAssetId3, imageAssetId4, imageAssetId5, publisher, redeemableStart, redeemableEnd, brand, productType, conditionType, isbn, asin, catalogNumbers, department, features, minimumPrice, width, height, depth, weight, unit, studio, parentalRating, publishDate, availabilityDate, sizeId, listingId, mediaType, duration, author, releaseDate, collectionIds, rebootTimeHour, rebootTimeMinute, idleTimeoutInSecond, serialNumber, udid, deviceType, devicePower, deviceInterference, availability, availabilitySummary, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/wallet/create")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Create Wallet Offers", notes = "Adds offers to the wallet", response = OfferTransactionResponse.class, responseContainer = "List", tags={ "Wallet", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = OfferTransactionResponse.class, responseContainer = "List")
    })
    public Response createOfferTransaction(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The device id (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "The account id of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "The id of the offer being added (offerId or offeLocationId required)") @QueryParam("offerId")  Long offerId,@ApiParam(value = "The id of the offer location being added (offerId or offeLocationId required)") @QueryParam("offerLocationId")  Long offerLocationId,@ApiParam(value = "A JSON list of offers to purchase. ```json [   {     \"offerId\": 123,     \"offerLocationId\": 234,     \"quantity\": 2   },   {     \"offerId\": 456,     \"offerLocationId\": 567,     \"quantity\": 1   } ] ``` ") @QueryParam("offerCart")  String offerCart,@ApiParam(value = "The promoCode") @QueryParam("promoCode")  String promoCode,@ApiParam(value = "Determines the method of purchasing offer. CASH = use card on file, POINTS = use points, TICKETS = use tickets", defaultValue = "CASH") @DefaultValue("CASH") @QueryParam("currencyType")  String currencyType,@ApiParam(value = "Sets the currencyType to POINTS") @QueryParam("usePoints")  Boolean usePoints,@ApiParam(value = "External custom client defined data") @QueryParam("metaData")  String metaData,@ApiParam(value = "The application requesting the purchase, required when currencyType is TICKETS") @QueryParam("appKey")  String appKey,@ApiParam(value = "Custom status value to change to (0 or 1 for redeem, 5 or 6 for membership)") @QueryParam("status")  Integer status,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.createOfferTransaction(version, deviceId, accountId, offerId, offerLocationId, offerCart, promoCode, currencyType, usePoints, metaData, appKey, status, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/offer/status/create")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Create Offer Status", notes = "Create an offer status record", response = OfferTransactionStatusResponse.class, tags={ "Offer Status", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = OfferTransactionStatusResponse.class)
    })
    public Response createOfferTransactionStatus(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The name of the status", required = true) @QueryParam("name") @NotNull  String name,@ApiParam(value = "The status code, must be unique ", required = true) @QueryParam("code") @NotNull  Integer code,@ApiParam(value = "The device id (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "The account id of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "Used to update the user's current location") @QueryParam("latitude")  Double latitude,@ApiParam(value = "Used to update the user's current location") @QueryParam("longitude")  Double longitude,@ApiParam(value = "The description of the status") @QueryParam("description")  String description,@ApiParam(value = "The actor that uses the status", defaultValue = "ANY") @DefaultValue("ANY") @QueryParam("role")  String role,@ApiParam(value = "The active status", defaultValue = "true") @DefaultValue("true") @QueryParam("active")  Boolean active,@ApiParam(value = "The applications to associate the status with, if null then for all.") @QueryParam("applicationIds")  String applicationIds,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.createOfferTransactionStatus(version, name, code, deviceId, accountId, latitude, longitude, description, role, active, applicationIds, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/notification/blocked/batch")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Create or update blocked notification settings", notes = "Create or update blocked notification settings", response = BlockedNotificationResponse.class, tags={ "Notification", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = BlockedNotificationResponse.class)
    })
    public Response createOrUpdateBlockedNotifications(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The application key", required = true) @QueryParam("appKey") @NotNull  String appKey,@ApiParam(value = "batch data payload (application specific)", required = true) @QueryParam("data") @NotNull  String data,@ApiParam(value = "the account id of the user") @QueryParam("accountId")  Long accountId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.createOrUpdateBlockedNotifications(version, appKey, data, accountId, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/consumer/connection/add")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Create or Update Connection", notes = "Creates or updates the connection of the user and another account. Allows a user to follow, block, mark as trusted, and/or add someone to a group.", response = ConnectionResponse.class, tags={ "Connection", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = ConnectionResponse.class)
    })
    public Response createOrUpdateConnection(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the device id (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "the account id of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "the connection id for editing") @QueryParam("connectionId")  Long connectionId,@ApiParam(value = "the connection account id (i.e. the account id of another user)") @QueryParam("connectionAccountId")  Long connectionAccountId,@ApiParam(value = "the pending id (usually for people who do not have a Sirqul account but are already friends via other third party apps)") @QueryParam("pendingId")  Long pendingId,@ApiParam(value = "optional group id if the user wants to add this person into a group") @QueryParam("groupId")  Long groupId,@ApiParam(value = "This parameter is deprecated.") @QueryParam("gameType")  String gameType,@ApiParam(value = "the application key") @QueryParam("appKey")  String appKey,@ApiParam(value = "determines whether the user is trusting this account") @QueryParam("isTrusted")  Boolean isTrusted,@ApiParam(value = "determines whether the user has set to ignore the user's friend request") @QueryParam("ignoreFriendRequest")  Boolean ignoreFriendRequest,@ApiParam(value = "determines whether the user is a contact of this account") @QueryParam("isContact")  Boolean isContact,@ApiParam(value = "determines whether the user is blocking this account") @QueryParam("isBlocked")  Boolean isBlocked,@ApiParam(value = "determines whether the user is following this account") @QueryParam("isFollowing")  Boolean isFollowing,@ApiParam(value = "whether to return the connection response or not") @QueryParam("connectionResponse")  Boolean connectionResponse,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.createOrUpdateConnection(version, deviceId, accountId, connectionId, connectionAccountId, pendingId, groupId, gameType, appKey, isTrusted, ignoreFriendRequest, isContact, isBlocked, isFollowing, connectionResponse, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/consumer/connection/group")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Create or Update Connection Group", notes = "Creates a new private group.", response = SirqulResponse.class, tags={ "Connection", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response createOrUpdateGroup(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "whether to return nulls or not", required = true) @QueryParam("returnNulls") @NotNull  Boolean returnNulls,@ApiParam(value = "the device id (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "the account id of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "the name of the group") @QueryParam("name")  String name,@ApiParam(value = "the group id to update a group (don't pass anything in if you want to create a new group)") @QueryParam("groupId")  Long groupId,@ApiParam(value = "the asset to attach to the group") @QueryParam("assetId")  Long assetId,@ApiParam(value = "comma separated list of connection IDs") @QueryParam("connections")  String connections,@ApiParam(value = "the description of the group") @QueryParam("description")  String description,@ApiParam(value = "determines whether the connections in the group can see the user's profile info") @QueryParam("canViewProfileInfo")  Boolean canViewProfileInfo,@ApiParam(value = "determines whether the connections in the group can see the user's game info") @QueryParam("canViewGameInfo")  Boolean canViewGameInfo,@ApiParam(value = "determines whether the connections in the group can see the user's friends/connections") @QueryParam("canViewFriendInfo")  Boolean canViewFriendInfo,@ApiParam(value = "Sets whether the connection group is active or inactive") @QueryParam("active")  Boolean active,@ApiParam(value = "the latitude of the group") @QueryParam("latitude")  Double latitude,@ApiParam(value = "the longitude of the group") @QueryParam("longitude")  Double longitude,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.createOrUpdateGroup(version, returnNulls, deviceId, accountId, name, groupId, assetId, connections, description, canViewProfileInfo, canViewGameInfo, canViewFriendInfo, active, latitude, longitude, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/order/create")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Create Order", notes = "Creates a new purchase with some number of items associated with it. The purchase is added to the order that was created", response = OrderResponse.class, tags={ "Purchase Order", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = OrderResponse.class)
    })
    public Response createOrder(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The application requesting the purchase", required = true) @QueryParam("appKey") @NotNull  String appKey,@ApiParam(value = "```json [   { \"orderItemType\": \"OFFER\", \"orderItemId\": 234, \"orderCustomType\": \"OfferLocation\", \"orderCustomId\": 123, \"retailerLocationId\": 1234, \"quantity\": 2 },   { \"orderItemType\": \"OFFER\", \"orderItemId\": 235, \"quantity\": 2 },   { \"orderItemType\": \"CUSTOM\", \"amount\": 10.50, \"orderCustomType\": \"ServiceFee\" },   { \"orderItemType\": \"CUSTOM\", \"amount\": 25.10, \"quantity\": 2, \"orderCustomType\": \"Hat\", \"orderCustomId\": 123 } ] ``` ", required = true) @QueryParam("cart") @NotNull  String cart,@ApiParam(value = "The device id (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "The account id of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "A description of the purchase") @QueryParam("description")  String description,@ApiParam(value = "Determines the method of purchasing offer.  * VOID: used for when there is no payment involved (ie. for updating the status of a purchase order)  * CASH: use card on file  * POINTS: use account balance  * TICKETS: use tickets  * REFUND: not allowed for a create, requires a paymentTransactionId.  * CREDIT: add to the account balance  * RELOAD: charge a credit card then add to the account balance  ", allowableValues="VOID, CASH, POINTS, TICKETS, REFUND, CREDIT, RELOAD", defaultValue = "CASH") @DefaultValue("CASH") @QueryParam("currencyType")  String currencyType,@ApiParam(value = "Use a specific payment method (CASH), if not provided use default") @QueryParam("paymentMethodId")  Long paymentMethodId,@ApiParam(value = "Store identifier from external system") @QueryParam("externalOrderId")  String externalOrderId,@ApiParam(value = "Store identifier from external system") @QueryParam("externalPaymentId")  String externalPaymentId,@ApiParam(value = "Remote Reference type") @QueryParam("remoteRefType")  String remoteRefType,@ApiParam(value = "External Date") @QueryParam("externalDate")  Long externalDate,@ApiParam(value = "The Promo Code") @QueryParam("promoCode")  String promoCode,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.createOrder(version, appKey, cart, deviceId, accountId, description, currencyType, paymentMethodId, externalOrderId, externalPaymentId, remoteRefType, externalDate, promoCode, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/pack/create")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Create Pack", notes = "Create a pack.", response = PackResponse.class, tags={ "Pack", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = PackResponse.class)
    })
    public Response createPack(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The logged in user.", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "The title of the pack", required = true) @QueryParam("title") @NotNull  String title,@ApiParam(value = "The order of the pack", required = true) @QueryParam("packOrder") @NotNull  Long packOrder,@ApiParam(value = "The price in tickets to purchase this pack", required = true) @QueryParam("price") @NotNull  Integer price,@ApiParam(value = "The scoring is highest is best", required = true) @QueryParam("highest") @NotNull  Boolean highest,@ApiParam(value = "Flag to indicate owner should receive tickets for completed packs", required = true) @QueryParam("allocateTickets") @NotNull  Boolean allocateTickets,@ApiParam(value = "The number of tickets to reward", required = true) @QueryParam("ticketCount") @NotNull  Long ticketCount,@ApiParam(value = "The description of the pack") @QueryParam("description")  String description,@ApiParam(value = "The tags for searching the pack, comma separated") @QueryParam("searchTags")  String searchTags,@ApiParam(value = "Activate/deactivate the pack") @QueryParam("active")  Boolean active,@ApiParam(value = "This parameter is deprecated.") @QueryParam("gameType")  String gameType,@ApiParam(value = "The application key used to identify the application") @QueryParam("appKey")  String appKey,@ApiParam(value = "The type of the pack", allowableValues="TUTORIAL, BUILTIN, DOWNLOAD, THRESHOLD, THEME, TOURNAMENT") @QueryParam("packType")  String packType,@ApiParam(value = "The type of game sequence of the pack", allowableValues="FIRST_AVAILABLE, ALL_AVAILABLE") @QueryParam("sequenceType")  String sequenceType,@ApiParam(value = "The background asset id of the pack") @QueryParam("backgroundId")  Long backgroundId,@ApiParam(value = "The image asset id of the pack") @QueryParam("imageId")  Long imageId,@ApiParam(value = "The date/time to start the pack, send 0 to unset") @QueryParam("startDate")  Long startDate,@ApiParam(value = "The date/time to end the pack, send 0 to unset") @QueryParam("endDate")  Long endDate,@ApiParam(value = "") @QueryParam("authorOverride")  String authorOverride,@ApiParam(value = "the type of ticket required to purchase this pack") @QueryParam("priceType")  String priceType,@ApiParam(value = "the game level ids to include in the pack, comma separated") @QueryParam("gameLevelIds")  String gameLevelIds,@ApiParam(value = "") @QueryParam("inGame")  Boolean inGame,@ApiParam(value = "The type of ticket to reward, null means default type") @QueryParam("ticketType")  String ticketType,@ApiParam(value = "The number of points to award for completing a pack") @QueryParam("points")  Long points,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.createPack(version, accountId, title, packOrder, price, highest, allocateTickets, ticketCount, description, searchTags, active, gameType, appKey, packType, sequenceType, backgroundId, imageId, startDate, endDate, authorOverride, priceType, gameLevelIds, inGame, ticketType, points, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/billing/create")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Create Payment Method", notes = "Add a new method of payment.", response = PaymentTypesResponse.class, tags={ "Billing Info", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = PaymentTypesResponse.class)
    })
    public Response createPaymentMethod(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The account used to perform the the request", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "Account Name of the credit card user") @QueryParam("accountName")  String accountName,@ApiParam(value = "The first name on the credit card") @QueryParam("firstName")  String firstName,@ApiParam(value = "The last name on the credit card") @QueryParam("lastName")  String lastName,@ApiParam(value = "The billing address of the credit card") @QueryParam("address")  String address,@ApiParam(value = "The billing city of the credit card") @QueryParam("city")  String city,@ApiParam(value = "The billing state of the credit card") @QueryParam("state")  String state,@ApiParam(value = "The billing zip code of the credit card") @QueryParam("postalCode")  String postalCode,@ApiParam(value = "Country of the credit card") @QueryParam("country")  String country,@ApiParam(value = "The billing phone of the credit card") @QueryParam("phone")  String phone,@ApiParam(value = "The full credit card number to store on file") @QueryParam("creditCardNumber")  String creditCardNumber,@ApiParam(value = "The credit card expiration date YYYY-MM") @QueryParam("expirationDate")  String expirationDate,@ApiParam(value = "The 3 digit confirmation code") @QueryParam("ccv")  String ccv,@ApiParam(value = "The bank account number") @QueryParam("accountNumber")  String accountNumber,@ApiParam(value = "The bank name") @QueryParam("bankName")  String bankName,@ApiParam(value = "The bank routing number") @QueryParam("routingNumber")  String routingNumber,@ApiParam(value = "The nickname to give the payment method") @QueryParam("paymentMethodNickname")  String paymentMethodNickname,@ApiParam(value = "Tax Id") @QueryParam("taxId")  String taxId,@ApiParam(value = "Whether this should be the default payment method", defaultValue = "true") @DefaultValue("true") @QueryParam("defaultPaymentMethod")  Boolean defaultPaymentMethod,@ApiParam(value = "An authorization token for providers that provide this (like Amazon Payments)") @QueryParam("authToken")  String authToken,@ApiParam(value = "The payment provider (see PaymentMethodProvider)", defaultValue = "AUTHORIZE_NET") @DefaultValue("AUTHORIZE_NET") @QueryParam("provider")  String provider,@ApiParam(value = "Provider customer profile Id") @QueryParam("providerCustomerProfileId")  String providerCustomerProfileId,@ApiParam(value = "Provider customer payment profile Id") @QueryParam("providerPaymentProfileId")  String providerPaymentProfileId,@ApiParam(value = "Meta Data") @QueryParam("metaData")  String metaData,@ApiParam(value = "Application Key") @QueryParam("appKey")  String appKey,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.createPaymentMethod(version, accountId, accountName, firstName, lastName, address, city, state, postalCode, country, phone, creditCardNumber, expirationDate, ccv, accountNumber, bankName, routingNumber, paymentMethodNickname, taxId, defaultPaymentMethod, authToken, provider, providerCustomerProfileId, providerPaymentProfileId, metaData, appKey, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/persona/create")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Create Persona", notes = "Creates a new persona. If the given params are null those attributes will be override by null.", response = PreviewPersonaResponse.class, tags={ "Preview Persona", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = PreviewPersonaResponse.class)
    })
    public Response createPersona(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the account ID of the user", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "the title of the persona", required = true) @QueryParam("title") @NotNull  String title,@ApiParam(value = "the accounts that are able to preview from this persona") @QueryParam("previewAccounts")  String previewAccounts,@ApiParam(value = "the sepcified date that this persona is viewing the app") @QueryParam("date")  Long date,@ApiParam(value = "the specified age of this persona") @QueryParam("age")  Integer age,@ApiParam(value = "the specified gender of this persona") @QueryParam("gender")  String gender,@ApiParam(value = "the specified experience level of the persona") @QueryParam("gameExperienceLevel")  String gameExperienceLevel,@ApiParam(value = "the specified latitude of the persona") @QueryParam("latitude")  Double latitude,@ApiParam(value = "the specified longitude of the persona") @QueryParam("longitude")  Double longitude,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.createPersona(version, accountId, title, previewAccounts, date, age, gender, gameExperienceLevel, latitude, longitude, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/postalCode/create")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Create Postal Code", notes = "Create a Postal Code", response = PostalCodeResponse.class, tags={ "Postal Code", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = PostalCodeResponse.class)
    })
    public Response createPostalCode(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the id of the logged in user", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "the postal code", required = true) @QueryParam("code") @NotNull  String code,@ApiParam(value = "the latitude of the postal code", required = true) @QueryParam("latitude") @NotNull  Double latitude,@ApiParam(value = "the longitude of the postal code", required = true) @QueryParam("longitude") @NotNull  Double longitude,@ApiParam(value = "the state code (e.g WA, WV, WI) that the postal code is located") @QueryParam("stateCode")  String stateCode,@ApiParam(value = "the city that the postal code is located") @QueryParam("city")  String city,@ApiParam(value = "whether the postal code created should be active or inactive") @QueryParam("active")  Boolean active,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.createPostalCode(version, accountId, code, latitude, longitude, stateCode, city, active, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/program")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Create Program", notes = "Create a new program", response = Program.class, tags={ "Program", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = Program.class)
    })
    public Response createProgram(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "") @Valid  Program body,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.createProgram(version, body, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/purchase/create")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Create Purchase", notes = "Creates a purchase item for in app purchases", response = PurchaseItemFullResponse.class, tags={ "Purchase Item", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = PurchaseItemFullResponse.class)
    })
    public Response createPurchaseItem(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The application key that the purchase can be used in", required = true) @QueryParam("appKey") @NotNull  String appKey,@ApiParam(value = "The name of the purchase item", required = true) @QueryParam("name") @NotNull  String name,@ApiParam(value = "The purchase provider <ul> <li>SIRQUL - the Sirqul store to make purchases using tickets</li> <li>IOS - the iTunes store for iPhone, iPod, iPod Touch</li> <li>GOOGLE - the Google Play store</li> <li>AMAZON - the Amazon Android store</li> <li>MAC - the iTunes store for OSX</li> <li>WP8 - the Windows Phone 8 store</li> <li>FREE - used for purchase items that are free (can be used for development/testing purposes)</li> </ul>", required = true, allowableValues="SIRQUL, IOS, GOOGLE, AMAZON, MAC, WP8, FREE") @QueryParam("purchaseType") @NotNull  String purchaseType,@ApiParam(value = "The device id (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "The account id of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "The description of the purchase item") @QueryParam("description")  String description,@ApiParam(value = "How much the purchase item is worth in tickets") @QueryParam("tickets")  Integer tickets,@ApiParam(value = "How much the purchase item will cost in real money") @QueryParam("price")  Float price,@ApiParam(value = "The unique identifier used by purchase providers to identify in-app-purchases") @QueryParam("purchaseCode")  String purchaseCode,@ApiParam(value = "A secret key from purchase providers that would be used for validation") @QueryParam("secretKey")  String secretKey,@ApiParam(value = "How many times a user acquire the same purchase item", defaultValue = "0") @DefaultValue("0") @QueryParam("purchaseLimit")  Integer purchaseLimit,@ApiParam(value = "Determines whether the purchase item will enable certain features <ul> <li>DAY_PREMIUM - subscribes a user for a day of membership</li> <li>WEEK_PREMIUM - subscribes a user for a week of membership</li> <li>MONTH_PREMIUM - subscribes a user for a month of membership</li> <li>ADD_TICKET - allows a user to add more tickets to their account</li> <li>ADD_GIFT - allows a user to send/recieve the purchase item as a gift</li> </ul>", allowableValues="DAY_PREMIUM, WEEK_PREMIUM, MONTH_PREMIUM, YEAR_PREMIUM, LIFETIME_PREMIUM, ADD_TICKET, ADD_GIFT, ADD_POINTS") @QueryParam("serviceAction")  String serviceAction,@ApiParam(value = "The cover image of the purchase item") @QueryParam("coverAssetId")  Long coverAssetId,@ApiParam(value = "An application specific asset that can be used to store/provide additional data") @QueryParam("promoAssetId")  Long promoAssetId,@ApiParam(value = "Determines whether the purchase item can be gifted to other users") @QueryParam("giftable")  Boolean giftable,@ApiParam(value = "Determines whether users can attach their own media/asset to the purchase item") @QueryParam("assetable")  Boolean assetable,@ApiParam(value = "Flag to indicate owner should receive tickets for completed missions", defaultValue = "false") @DefaultValue("false") @QueryParam("allocateTickets")  Boolean allocateTickets,@ApiParam(value = "The type of ticket to reward, null means default type") @QueryParam("ticketType")  String ticketType,@ApiParam(value = "The number of points to award for completing a mission") @QueryParam("points")  Long points,@ApiParam(value = "The offer location that will get added to the user's wallet after purchase.") @QueryParam("offerLocationId")  Long offerLocationId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.createPurchaseItem(version, appKey, name, purchaseType, deviceId, accountId, description, tickets, price, purchaseCode, secretKey, purchaseLimit, serviceAction, coverAssetId, promoAssetId, giftable, assetable, allocateTickets, ticketType, points, offerLocationId, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/game/question/create")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Create Question", notes = "Create a question and related answers by the given params.", response = QuestionResponse.class, tags={ "Question", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = QuestionResponse.class)
    })
    public Response createQuestion(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the id of the logged in user", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "the text of the question", required = true) @QueryParam("question") @NotNull  String question,@ApiParam(value = "```json [   {     \"text\": \"1942\",     \"image\": 123,     \"videoURL\": \"http://www.here.com\",     \"correct\": true   },   {     \"text\": \"1943\",     \"image\": 124,     \"videoURL\": \"http://www.there.com\",     \"correct\": false   } ] ``` ", required = true) @QueryParam("answers") @NotNull  String answers,@ApiParam(value = "If true set the question to active. Default to false.", required = true) @QueryParam("active") @NotNull  Boolean active,@ApiParam(value = "If true then scoring will give tickets. Default to false.", required = true) @QueryParam("allocateTickets") @NotNull  Boolean allocateTickets,@ApiParam(value = "The number of tickets to reward", required = true) @QueryParam("ticketCount") @NotNull  Long ticketCount,@ApiParam(value = "The tags of the question for search.") @QueryParam("tags")  String tags,@ApiParam(value = "The video link for the question.") @QueryParam("videoURL")  String videoURL,@ApiParam(value = "The asset id of the question.") @QueryParam("assetId")  Long assetId,@ApiParam(value = "The type of ticket to reward, null means default type") @QueryParam("ticketType")  String ticketType,@ApiParam(value = "The number of points to award for completing a mission") @QueryParam("points")  Long points,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.createQuestion(version, accountId, question, answers, active, allocateTickets, ticketCount, tags, videoURL, assetId, ticketType, points, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/rating/create")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Create Rating", notes = "This is used to leave rating on a ratable object (i.e. retailer locations). Each user can only rate on a ratable object once per category. If a user rates on the same object and category, the previous rating will be overwritten. Leaving a rating on a ratable object will be visible to everyone who has access to view the object.", response = RatingResponse.class, tags={ "Rating", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = RatingResponse.class)
    })
    public Response createRating(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The ratable object type {RETAILER_LOCATION}", required = true) @QueryParam("ratableType") @NotNull  String ratableType,@ApiParam(value = "The id of the ratable object", required = true) @QueryParam("ratableId") @NotNull  Long ratableId,@ApiParam(value = "The integer value of 0-100", required = true) @QueryParam("ratingValue") @NotNull  Integer ratingValue,@ApiParam(value = "The unique device identifier that made the request (either deviceId or accountId must be used)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "The unique accountId that made the request (either deviceId or accountId must be used)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "") @QueryParam("categoryId")  Long categoryId,@ApiParam(value = "A subject title for the user rating (limited to 255 characters)") @QueryParam("display")  String display,@ApiParam(value = "The description of the rating") @QueryParam("description")  String description,@ApiParam(value = "The description of the location") @QueryParam("locationDescription")  String locationDescription,@ApiParam(value = "The current location of the user") @QueryParam("latitude")  Double latitude,@ApiParam(value = "The current location of the user") @QueryParam("longitude")  Double longitude,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.createRating(version, ratableType, ratableId, ratingValue, deviceId, accountId, categoryId, display, description, locationDescription, latitude, longitude, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/region/create")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Create Region", notes = "Create a region.", response = RegionResponse.class, tags={ "Region", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = RegionResponse.class)
    })
    public Response createRegion(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The id of the account sending the request", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "RegionClass of this region", required = true) @QueryParam("regionClass") @NotNull  String regionClass,@ApiParam(value = "Short name of the region. This is optimized for search", required = true) @QueryParam("shortName") @NotNull  String shortName,@ApiParam(value = "Full name of the region") @QueryParam("fullName")  String fullName,@ApiParam(value = "Comma separated region ids that are parents of this region") @QueryParam("parentIds")  String parentIds,@ApiParam(value = "Comma separated region ids that are children of this region") @QueryParam("childrenIds")  String childrenIds,@ApiParam(value = "Comma separated postal code ids the region will include") @QueryParam("postalCodeIds")  String postalCodeIds,@ApiParam(value = "Sets of name,lat,long used to create new postal codes assigned to the region") @QueryParam("locations")  String locations,@ApiParam(value = "the id of the retailer location that the region is being created for") @QueryParam("retailerLocationId")  Long retailerLocationId,@ApiParam(value = "The Visibility of the region", allowableValues="PUBLIC, PRIVATE, FRIENDS") @QueryParam("visibility")  String visibility,@ApiParam(value = "the categories that the region is assigned to") @QueryParam("categoryIds")  String categoryIds,@ApiParam(value = "the filters that the region is assigned to") @QueryParam("filterIds")  String filterIds,@ApiParam(value = "") @QueryParam("start")  Long start,@ApiParam(value = "") @QueryParam("end")  Long end,@ApiParam(value = "the polygon generated for the region") @QueryParam("polygon")  String polygon,@ApiParam(value = "the meta data associated with the region") @QueryParam("metaData")  String metaData,@ApiParam(value = "the latitude of the region") @QueryParam("latitude")  Double latitude,@ApiParam(value = "the longitude of the region") @QueryParam("longitude")  Double longitude,@ApiParam(value = "the version code") @QueryParam("versionCode")  Integer versionCode,@ApiParam(value = "If this is a root region or not. If true means this region has no parent regions") @QueryParam("root")  Boolean root,@ApiParam(value = "Active or inactive status of the region") @QueryParam("active")  Boolean active,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.createRegion(version, accountId, regionClass, shortName, fullName, parentIds, childrenIds, postalCodeIds, locations, retailerLocationId, visibility, categoryIds, filterIds, start, end, polygon, metaData, latitude, longitude, versionCode, root, active, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/report/region/summary/batch")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Create Offline Report", notes = "Create an entry for the batch for offline report", response = ReportRegionLegSummaryBatchResponse.class, tags={ "Reporting", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = ReportRegionLegSummaryBatchResponse.class)
    })
    public Response createRegionLegSummaryBatch(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "") @Valid  List<@Valid RegionLegSummary> body,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.createRegionLegSummaryBatch(version, body, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/reservation/create")
    
    
    @io.swagger.annotations.ApiOperation(value = "Create Reservation", notes = "Creates a reservation on an offer object", response = Void.class, tags={ "Reservation", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = Void.class)
    })
    public Response createReservation(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The device id (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "The account id of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "The start date") @QueryParam("startDate")  Long startDate,@ApiParam(value = "The end date") @QueryParam("endDate")  Long endDate,@ApiParam(value = "The id of the offer being added (offerId or offeLocationId required)") @QueryParam("offerId")  Long offerId,@ApiParam(value = "The id of the offer location being added (offerId or offeLocationId required)") @QueryParam("offerLocationId")  Long offerLocationId,@ApiParam(value = "The application requesting the reservation") @QueryParam("appKey")  String appKey,@ApiParam(value = "External custom client defined data") @QueryParam("metaData")  String metaData,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.createReservation(version, deviceId, accountId, startDate, endDate, offerId, offerLocationId, appKey, metaData, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/retailer/create")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Create Retailer", notes = "Create a retailer record. A billable entity must be created first before a retailer record can be made.", response = RetailerFullResponse.class, tags={ "Retailer", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = RetailerFullResponse.class)
    })
    public Response createRetailer(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The name of the retailer", required = true) @QueryParam("name") @NotNull  String name,@ApiParam(value = "The device id (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "The account id of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "The street address of the retailer") @QueryParam("streetAddress")  String streetAddress,@ApiParam(value = "Additional address information (such as a suite number, floor number, building name, or PO Box)") @QueryParam("streetAddress2")  String streetAddress2,@ApiParam(value = "The city of the retailer") @QueryParam("city")  String city,@ApiParam(value = "The state of the retailer") @QueryParam("state")  String state,@ApiParam(value = "The postal code of the retailer") @QueryParam("postalCode")  String postalCode,@ApiParam(value = "the country of the retailer") @QueryParam("country")  String country,@ApiParam(value = "The business phone number of the retailer") @QueryParam("businessPhone")  String businessPhone,@ApiParam(value = "The business phone extension of the retailer") @QueryParam("businessPhoneExt")  String businessPhoneExt,@ApiParam(value = "The website of the retailer") @QueryParam("website")  String website,@ApiParam(value = "The email of the retailer") @QueryParam("email")  String email,@ApiParam(value = "The facebook URL of the retailer") @QueryParam("facebookUrl")  String facebookUrl,@ApiParam(value = "The twitter URL of the retailer") @QueryParam("twitterUrl")  String twitterUrl,@ApiParam(value = "The retailer logo sent as a multipart binary file (you can optionally use logoAssetId if the asset has already been uploaded before)") @QueryParam("logo")  File logo,@ApiParam(value = "The retailer logo asset id") @QueryParam("logoAssetId")  Long logoAssetId,@ApiParam(value = "Optional store-front pictures or product pictures or etc. A multipart binary file (you can optionally use picture1AssetId if the asset has already been uploaded before)") @QueryParam("picture1")  File picture1,@ApiParam(value = "An asset id") @QueryParam("picture1AssetId")  Long picture1AssetId,@ApiParam(value = "Optional store-front pictures or product pictures or etc. A multipart binary file (you can optionally use picture2AssetId if the asset has already been uploaded before)") @QueryParam("picture2")  File picture2,@ApiParam(value = "An asset id") @QueryParam("picture2AssetId")  Long picture2AssetId,@ApiParam(value = "Comma separated list of category IDs used to filter retailers by categories") @QueryParam("categoryIds")  String categoryIds,@ApiParam(value = "Comma separated list of category IDs to add to the retailer") @QueryParam("categoryIdsToAdd")  String categoryIdsToAdd,@ApiParam(value = "Comma separated list of category IDs to remove from the retailer") @QueryParam("categoryIdsToRemove")  String categoryIdsToRemove,@ApiParam(value = "Comma separated list of filter IDs used to filter retailers") @QueryParam("filterIds")  String filterIds,@ApiParam(value = "the latitude of the retailer") @QueryParam("latitude")  Double latitude,@ApiParam(value = "the longitude of the retailer") @QueryParam("longitude")  Double longitude,@ApiParam(value = "External custom client defined data") @QueryParam("metaData")  String metaData,@ApiParam(value = "External custom search keywords") @QueryParam("searchTags")  String searchTags,@ApiParam(value = "External custom type identifier") @QueryParam("retailerType")  String retailerType,@ApiParam(value = "", allowableValues="PUBLIC, PRIVATE, FRIENDS") @QueryParam("visibility")  String visibility,@ApiParam(value = "Determines whether to create a default location using the retailer information") @QueryParam("createDefaultLocation")  Boolean createDefaultLocation,@ApiParam(value = "The format of the returned response {JSON // default , HTML // for Dojo support when uploading assets}", allowableValues="HTML, XML, JSON, CSV") @QueryParam("responseFormat")  String responseFormat,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.createRetailer(version, name, deviceId, accountId, streetAddress, streetAddress2, city, state, postalCode, country, businessPhone, businessPhoneExt, website, email, facebookUrl, twitterUrl, logo, logoAssetId, picture1, picture1AssetId, picture2, picture2AssetId, categoryIds, categoryIdsToAdd, categoryIdsToRemove, filterIds, latitude, longitude, metaData, searchTags, retailerType, visibility, createDefaultLocation, responseFormat, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/location/create")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Create Retailer Location (Consumer)", notes = "Creates a location record for an application that can support crowd sourced locations.", response = RetailerLocationResponse.class, tags={ "Retailer Location", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = RetailerLocationResponse.class)
    })
    public Response createRetailerLocationConsumer(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the application key", required = true) @QueryParam("appKey") @NotNull  String appKey,@ApiParam(value = "The name of the retailer location", required = true) @QueryParam("name") @NotNull  String name,@ApiParam(value = "The device id (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "The account id of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "The street address of the retailer location") @QueryParam("streetAddress")  String streetAddress,@ApiParam(value = "Additional address information (such as a suite number, floor number, building name, or PO Box)") @QueryParam("streetAddress2")  String streetAddress2,@ApiParam(value = "The city of the retailer location") @QueryParam("city")  String city,@ApiParam(value = "The state of the retailer location") @QueryParam("state")  String state,@ApiParam(value = "The postal code of the retailer location") @QueryParam("postalCode")  String postalCode,@ApiParam(value = "the country of the retailer location") @QueryParam("country")  String country,@ApiParam(value = "The business phone") @QueryParam("businessPhone")  String businessPhone,@ApiParam(value = "The business phone extension") @QueryParam("businessPhoneExt")  String businessPhoneExt,@ApiParam(value = "The website of the retailer location") @QueryParam("website")  String website,@ApiParam(value = "The email of the retailer location") @QueryParam("email")  String email,@ApiParam(value = "A brief description about the retailer location (255 character limit)") @QueryParam("detailsHeader")  String detailsHeader,@ApiParam(value = "A detailed description about the retailer location") @QueryParam("detailsBody")  String detailsBody,@ApiParam(value = "The hours of operation") @QueryParam("hours")  String hours,@ApiParam(value = "Custom string field for doing full-text searches") @QueryParam("tags")  String tags,@ApiParam(value = "The retailer location logo asset id") @QueryParam("logoAssetId")  Long logoAssetId,@ApiParam(value = "An asset id") @QueryParam("picture1AssetId")  Long picture1AssetId,@ApiParam(value = "An asset id") @QueryParam("picture2AssetId")  Long picture2AssetId,@ApiParam(value = "Comma separated list of category IDs used to filter retailer locations by categories") @QueryParam("categoryIds")  String categoryIds,@ApiParam(value = "Comma separated list of filter IDs used to filter retailer locations") @QueryParam("filterIds")  String filterIds,@ApiParam(value = "External custom client defined data") @QueryParam("metaData")  String metaData,@ApiParam(value = "Whether the location is public") @QueryParam("publicLocation")  Boolean publicLocation,@ApiParam(value = "whether the retailer location created should be active or not") @QueryParam("active")  Boolean active,@ApiParam(value = "External custom type identifier") @QueryParam("locationType")  String locationType,@ApiParam(value = "The latitude to center the search on") @QueryParam("latitude")  Double latitude,@ApiParam(value = "The longitude to center the search on") @QueryParam("longitude")  Double longitude,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.createRetailerLocationConsumer(version, appKey, name, deviceId, accountId, streetAddress, streetAddress2, city, state, postalCode, country, businessPhone, businessPhoneExt, website, email, detailsHeader, detailsBody, hours, tags, logoAssetId, picture1AssetId, picture2AssetId, categoryIds, filterIds, metaData, publicLocation, active, locationType, latitude, longitude, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/retailer/location/create")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Create Retailer Location", notes = "Creates a location record for a retailer. Only the owner and the employees of the retailer have access to do this.", response = RetailerLocationResponse.class, tags={ "Retailer Location", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = RetailerLocationResponse.class)
    })
    public Response createRetailerLocations(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The ID of the retailer", required = true) @QueryParam("retailerId") @NotNull  Long retailerId,@ApiParam(value = "The name of the retailer location", required = true) @QueryParam("name") @NotNull  String name,@ApiParam(value = "The street address of the retailer location", required = true) @QueryParam("streetAddress") @NotNull  String streetAddress,@ApiParam(value = "The city of the retailer location", required = true) @QueryParam("city") @NotNull  String city,@ApiParam(value = "The state of the retailer location", required = true) @QueryParam("state") @NotNull  String state,@ApiParam(value = "The postal code of the retailer location", required = true) @QueryParam("postalCode") @NotNull  String postalCode,@ApiParam(value = "The device id (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "The account id of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "Additional address information (such as a suite number, floor number, building name, or PO Box)") @QueryParam("streetAddress2")  String streetAddress2,@ApiParam(value = "the country of the retailer location") @QueryParam("country")  String country,@ApiParam(value = "The business phone number of the retailer location") @QueryParam("businessPhone")  String businessPhone,@ApiParam(value = "The business phone extension") @QueryParam("businessPhoneExt")  String businessPhoneExt,@ApiParam(value = "The website of the retailer location") @QueryParam("website")  String website,@ApiParam(value = "The email of the retailer location") @QueryParam("email")  String email,@ApiParam(value = "An internal identifier used by the retailer") @QueryParam("internalId")  String internalId,@ApiParam(value = "A brief description about the retailer location (255 character limit)") @QueryParam("detailsHeader")  String detailsHeader,@ApiParam(value = "A detailed description about the retailer location") @QueryParam("detailsBody")  String detailsBody,@ApiParam(value = "The hours of operation") @QueryParam("hours")  String hours,@ApiParam(value = "The retailer location logo sent as a multipart binary file (you can optionally use logoAssetId if the asset has already been uploaded before)") @QueryParam("logo")  File logo,@ApiParam(value = "The retailer location logo asset id") @QueryParam("logoAssetId")  Long logoAssetId,@ApiParam(value = "Optional store-front pictures or product pictures or etc. A multipart binary file (you can optionally use picture1AssetId if the asset has already been uploaded before)") @QueryParam("picture1")  File picture1,@ApiParam(value = "An asset id") @QueryParam("picture1AssetId")  Long picture1AssetId,@ApiParam(value = "Optional store-front pictures or product pictures or etc. A multipart binary file (you can optionally use picture2AssetId if the asset has already been uploaded before)") @QueryParam("picture2")  File picture2,@ApiParam(value = "An asset id") @QueryParam("picture2AssetId")  Long picture2AssetId,@ApiParam(value = "Comma separated list of category IDs used to filter retailer locations by categories") @QueryParam("categoryIds")  String categoryIds,@ApiParam(value = "Comma separated list of filter IDs used to filter retailer locations") @QueryParam("filterIds")  String filterIds,@ApiParam(value = "the latitude of the retailer location") @QueryParam("latitude")  Double latitude,@ApiParam(value = "the longitude of the retailer location") @QueryParam("longitude")  Double longitude,@ApiParam(value = "") @QueryParam("building")  String building,@ApiParam(value = "the ID of the Google Place that this retailer location is assigned to") @QueryParam("googlePlaceId")  String googlePlaceId,@ApiParam(value = "the Yelp ID that this retailer location is assigned to") @QueryParam("yelpId")  String yelpId,@ApiParam(value = "whether the retailer location should be active or inactive") @QueryParam("active")  Boolean active,@ApiParam(value = "Sets whether the location is public or not") @QueryParam("publicLocation")  Boolean publicLocation,@ApiParam(value = "External custom type identifier") @QueryParam("locationType")  String locationType,@ApiParam(value = "Comma separated list of audience IDs used to assign audiences to the retailer location") @QueryParam("audienceIds")  String audienceIds,@ApiParam(value = "Comma separated list of audience IDs to add to the retailer location") @QueryParam("audienceIdsToAdd")  String audienceIdsToAdd,@ApiParam(value = "Comma separated list of audience IDs to remove from the retailer location") @QueryParam("audienceIdsToRemove")  String audienceIdsToRemove,@ApiParam(value = "The format of the returned response {JSON // default , HTML // for Dojo support when uploading assets}", allowableValues="HTML, XML, JSON, CSV") @QueryParam("responseFormat")  String responseFormat,@ApiParam(value = "Comma separated list of response includes (e.g. RETAILER,ASSETS,OFFERS,CATEGORIES,FILTERS,AUDIENCES,QRCODE)") @QueryParam("responseIncludes")  String responseIncludes,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.createRetailerLocations(version, retailerId, name, streetAddress, city, state, postalCode, deviceId, accountId, streetAddress2, country, businessPhone, businessPhoneExt, website, email, internalId, detailsHeader, detailsBody, hours, logo, logoAssetId, picture1, picture1AssetId, picture2, picture2AssetId, categoryIds, filterIds, latitude, longitude, building, googlePlaceId, yelpId, active, publicLocation, locationType, audienceIds, audienceIdsToAdd, audienceIdsToRemove, responseFormat, responseIncludes, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/route")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Create Route", notes = "Create new route", response = Route.class, tags={ "Route", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = Route.class)
    })
    public Response createRoute(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "") @Valid  Route body,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.createRoute(version, body, securityContext);
    }
    @javax.ws.rs.PUT
    @Path("/route/{routeId}/directions")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Update Route Directions", notes = "Regenerate the directions of a route", response = Direction.class, responseContainer = "List", tags={ "Route", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = Direction.class, responseContainer = "List")
    })
    public Response createRouteDirections(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the id of the route to update directions for", required = true) @PathParam("routeId") @NotNull  Long routeId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.createRouteDirections(version, routeId, securityContext);
    }
    @javax.ws.rs.PUT
    @Path("/route/{routeId}/polyline")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Create Route Polyline", notes = "Update the polyline of the requested route", response = Route.class, tags={ "Route", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = Route.class)
    })
    public Response createRoutePolyline(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the id of the route to create a polyline for", required = true) @PathParam("routeId") @NotNull  Long routeId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.createRoutePolyline(version, routeId, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/route/setting")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Create Route Setting", notes = "Create a new route setting", response = RouteSettings.class, tags={ "Route Setting", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = RouteSettings.class)
    })
    public Response createRouteSettings(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "") @Valid  RouteSettings body,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.createRouteSettings(version, body, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/notification/schedule/create")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Create Scheduled Notification", notes = "This endpoint creates a Scheduled Notification message that can be configured to process and send periodically at set time periods", response = ScheduledNotificationFullResponse.class, tags={ "Scheduled Notification", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = ScheduledNotificationFullResponse.class)
    })
    public Response createScheduledNotification(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The logged in user.", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "The name of the scheduled notification", required = true) @QueryParam("name") @NotNull  String name,@ApiParam(value = "The type of scheduled notification. Supported values include: MOBILE_NOTIFICATION - sends push notifications via APNS and GCM EMAIL - sends email messages SMS - sends text messages", required = true) @QueryParam("type") @NotNull  String type,@ApiParam(value = "The message to send", required = true) @QueryParam("message") @NotNull  String message,@ApiParam(value = "The payload content ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.") @QueryParam("contentId")  Long contentId,@ApiParam(value = "The payload content name that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.") @QueryParam("contentName")  String contentName,@ApiParam(value = "The payload content type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.") @QueryParam("contentType")  String contentType,@ApiParam(value = "The payload parent ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.") @QueryParam("parentId")  Long parentId,@ApiParam(value = "The payload parent type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.") @QueryParam("parentType")  String parentType,@ApiParam(value = "The application that the notifications will send to. If connectionGroupIds, connectionAccountIds, and audienceIds is not set, this will send to all users who have used the application. This parameter is also required when sending push notifications via the MOBILE_NOTIFICATION type.") @QueryParam("appKey")  String appKey,@ApiParam(value = "Client defined identifier for grouping multiple scheduled notifications. This can be used with the search endpoint to return scheduled notifications with the same groupingId for display purposes. Only results that have been created by the user will be returned when using this feature.") @QueryParam("groupingId")  String groupingId,@ApiParam(value = "The connection groups to use to generate the list of recipients (comma separated list of connection group IDs)") @QueryParam("connectionGroupIds")  String connectionGroupIds,@ApiParam(value = "The connection accounts to use to generate the list of recipients (comma separated list of user account ids)") @QueryParam("connectionAccountIds")  String connectionAccountIds,@ApiParam(value = "This parameter is deprecated. The audience used to generate the list of recipients") @QueryParam("audienceId")  Long audienceId,@ApiParam(value = "The audiences used to generate the list of recipients (comma separated list of audience IDs)") @QueryParam("audienceIds")  String audienceIds,@ApiParam(value = "The album ids to associate with the scheduled notification (comma separated list of album IDs)") @QueryParam("albumIds")  String albumIds,@ApiParam(value = "The report used to generate the the list of recipients") @QueryParam("reportId")  Long reportId,@ApiParam(value = "The parameters to supply to the report used to generate the the list of recipients") @QueryParam("reportParams")  String reportParams,@ApiParam(value = "The URL for making an HTTP call") @QueryParam("endpointURL")  String endpointURL,@ApiParam(value = "The parameters for making an HTTP call") @QueryParam("payload")  String payload,@ApiParam(value = "The next time when the scheduled notification should begin processing (time in milliseconds). If this is left empty, then the startDate will be used.") @QueryParam("scheduledDate")  Long scheduledDate,@ApiParam(value = "The start time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to be available now.") @QueryParam("startDate")  Long startDate,@ApiParam(value = "The end time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to not have an expiration date.") @QueryParam("endDate")  Long endDate,@ApiParam(value = "The cron expression that represents the processing schedule. This uses the unix cron expression format. For example: 0 0 * * * will run once a day at midnight UTC.") @QueryParam("cronExpression")  String cronExpression,@ApiParam(value = "The cron expression type: UNIX, CRON4J, QUARTZ") @QueryParam("cronType")  String cronType,@ApiParam(value = "Additional metadata for the scheduled notification") @QueryParam("metaData")  String metaData,@ApiParam(value = "Json input representing conditional logic that has to be met before running the scheduled notification") @QueryParam("conditionalInput")  String conditionalInput,@ApiParam(value = "This determines if the Scheduled Notification is a template which is used as a basis for dynamically generating re-occurring Scheduled Notifications. The available types include: REPORTING - saves an adhoc report to be able to run again at another time GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business owner) GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business employee, retailer location, etc) GEOFENCE_TRIGGER - template for sending notifications to the account that triggered the geofence/audience (i.e. the customer) GEOFENCE_HTTP_CALL - template for making http calls when the geofences are triggered") @QueryParam("templateType")  String templateType,@ApiParam(value = "Determines the scope of who is able to find and view the scheduled notification (PUBLIC - openly available to all Sirqul users, PRIVATE - only available to users that have been invited)", allowableValues="PUBLIC, PRIVATE, FRIENDS") @QueryParam("visibility")  String visibility,@ApiParam(value = "Sets whether the Scheduled Notification is active or not (inactive Scheduled Notifications are not processed). This is a quick way to toggle on or off without altering its schedule. The default value is 'true'.") @QueryParam("active")  Boolean active,@ApiParam(value = "") @QueryParam("sendNow")  Boolean sendNow,@ApiParam(value = "Sets the event type for the notification", defaultValue = "CUSTOM") @DefaultValue("CUSTOM") @QueryParam("eventType")  String eventType,@ApiParam(value = "The payload deep link URI that can be used by the client app to direct users to a screen in the app") @QueryParam("deepLinkURI")  String deepLinkURI,@ApiParam(value = "Determines whether to send to all users of the app if set to true for push notifications (appKey is required)") @QueryParam("sendToAll")  Boolean sendToAll,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.createScheduledNotification(version, accountId, name, type, message, contentId, contentName, contentType, parentId, parentType, appKey, groupingId, connectionGroupIds, connectionAccountIds, audienceId, audienceIds, albumIds, reportId, reportParams, endpointURL, payload, scheduledDate, startDate, endDate, cronExpression, cronType, metaData, conditionalInput, templateType, visibility, active, sendNow, eventType, deepLinkURI, sendToAll, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/score/create")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Create Score", notes = "Create a score.  The response object will contain a series of   coded messages detailing what items were completed, the score registered,   and any tickets allocated.  Scoring a  level could complete the pack it   is in, completing that pack could complete the game, which  in turn could   complete the mission.  This completion chain is indicated to the client   via  a list of {@link MessageResponse}.", response = ScoreResponse.class, tags={ "Score", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = ScoreResponse.class)
    })
    public Response createScore(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The logged in user.", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "The game application key to save the score for.", required = true) @QueryParam("appKey") @NotNull  String appKey,@ApiParam(value = "The score", required = true) @QueryParam("points") @NotNull  Integer points,@ApiParam(value = "The missionId to score for, ignore if not playing mission.") @QueryParam("missionId")  Long missionId,@ApiParam(value = "The gameId to score for, ignore if not playing mission.") @QueryParam("gameId")  Long gameId,@ApiParam(value = "The packId to score for, send -2 if playing community levels.") @QueryParam("packId")  Long packId,@ApiParam(value = "The gameLevelId to score for.") @QueryParam("gameLevelId")  Long gameLevelId,@ApiParam(value = "The gameObjectId to score for, ignore if level based scoring.") @QueryParam("gameObjectId")  Long gameObjectId,@ApiParam(value = "The time taken to complete task") @QueryParam("timeTaken")  Integer timeTaken,@ApiParam(value = "") @QueryParam("highest")  Boolean highest,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.createScore(version, accountId, appKey, points, missionId, gameId, packId, gameLevelId, gameObjectId, timeTaken, highest, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/secure/application/create")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Create Secure Application", notes = "Create a secure application record.", response = SirqulResponse.class, tags={ "SecureApp", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response createSecureApplication(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The unique id of the user making the request", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "The application to secure", required = true) @QueryParam("appKey") @NotNull  String appKey,@ApiParam(value = "", required = true) @QueryParam("keyCert") @NotNull  File keyCert,@ApiParam(value = "", required = true) @QueryParam("trustStore") @NotNull  File trustStore,@ApiParam(value = "", required = true) @QueryParam("username") @NotNull  String username,@ApiParam(value = "", required = true) @QueryParam("password") @NotNull  String password,@ApiParam(value = "", defaultValue = "true") @DefaultValue("true") @QueryParam("active")  Boolean active,@ApiParam(value = "The type of biometric, options are: - FINGERPRINT - IRIS - FACIAL", allowableValues="FINGERPRINT, IRIS, FACIAL", defaultValue = "FACIAL") @DefaultValue("FACIAL") @QueryParam("biometricType")  String biometricType,@ApiParam(value = "The position for the biometric file uploaded", allowableValues="UNKNOWN, LEFT_INDEX, LEFT_MIDDLE, LEFT_RING, LEFT_LITTLE, LEFT_THUMB, RIGHT_INDEX, RIGHT_MIDDLE, RIGHT_RING, RIGHT_LITTLE, RIGHT_THUMB, LEFT, RIGHT", defaultValue = "UNKNOWN") @DefaultValue("UNKNOWN") @QueryParam("biometricPosition")  String biometricPosition,@ApiParam(value = "The position for each the biometric2 file uploaded", allowableValues="UNKNOWN, LEFT_INDEX, LEFT_MIDDLE, LEFT_RING, LEFT_LITTLE, LEFT_THUMB, RIGHT_INDEX, RIGHT_MIDDLE, RIGHT_RING, RIGHT_LITTLE, RIGHT_THUMB, LEFT, RIGHT", defaultValue = "UNKNOWN") @DefaultValue("UNKNOWN") @QueryParam("biometricPosition2")  String biometricPosition2,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.createSecureApplication(version, accountId, appKey, keyCert, trustStore, username, password, active, biometricType, biometricPosition, biometricPosition2, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/hub")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Create Service Hub", notes = "Create new service hub", response = ServiceHub.class, tags={ "Service Hub", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = ServiceHub.class)
    })
    public Response createServiceHub(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "") @Valid  ServiceHub body,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.createServiceHub(version, body, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/shipment")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Create Shipment", notes = "Create new shipment", response = Shipment.class, tags={ "Shipment", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = Shipment.class)
    })
    public Response createShipment(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "") @Valid  Shipment body,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.createShipment(version, body, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/shipment/batch")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Create Shipment Batch", notes = "Create a new shipment batch", response = ShipmentBatch.class, tags={ "Shipment Batch", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = ShipmentBatch.class)
    })
    public Response createShipmentBatch(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "") @Valid  ShipmentBatch body,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.createShipmentBatch(version, body, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/billing/crypto/transfer")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Create Smart Contract", notes = "Adds a smart contract.", response = PaymentTypesResponse.class, tags={ "Billing Info", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = PaymentTypesResponse.class)
    })
    public Response createSmartContract(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The account used to perform the the request", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "The token name", required = true) @QueryParam("tokenName") @NotNull  String tokenName,@ApiParam(value = "The token symbol", required = true) @QueryParam("tokenSymbol") @NotNull  String tokenSymbol,@ApiParam(value = "The payment method to return details on. If this is not set, then the user's default payment method will be returned.") @QueryParam("paymentMethodId")  Long paymentMethodId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.createSmartContract(version, accountId, tokenName, tokenSymbol, paymentMethodId, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/vatom/b/spaces/create")
    
    
    @io.swagger.annotations.ApiOperation(value = "Create Vatom Space", notes = "Create a Vatom space.", response = Void.class, tags={ "Vatom", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = Void.class)
    })
    public Response createSpace(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "Sirqul Account Id", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "Sirqul Application Key", required = true) @QueryParam("appKey") @NotNull  String appKey,@ApiParam(value = "Vatom Parameters", required = true) @QueryParam("vatomParameters") @NotNull  String vatomParameters,@ApiParam(value = "Return raw response") @QueryParam("returnRawResponse")  Boolean returnRawResponse,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.createSpace(version, accountId, appKey, vatomParameters, returnRawResponse, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/stripe/checkout/session/create")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Create Stripe Checkout Session", notes = "Create a Stripe checkout session", response = SirqulResponse.class, tags={ "Stripe", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response createStripeCheckoutSession(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "Sirqul Application Key", required = true) @QueryParam("appKey") @NotNull  String appKey,@ApiParam(value = "Stripe Parameters", required = true) @QueryParam("stripeParameters") @NotNull  String stripeParameters,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.createStripeCheckoutSession(version, appKey, stripeParameters, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/subscription/create")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Create Subscription", notes = "Create a subscription for a billable entity.  Provide a planId, if not provided then the base plan will be assigned.", response = SubscriptionResponse.class, tags={ "Subscription", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SubscriptionResponse.class)
    })
    public Response createSubscription(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The account used to perform the create, must be the responsible manager", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "The plan to subscribe to, if null use default plan") @QueryParam("planId")  Long planId,@ApiParam(value = "Set a promo code for a discount.") @QueryParam("promoCode")  String promoCode,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.createSubscription(version, accountId, planId, promoCode, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/task/create")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Create Task", notes = "Create a Task", response = TaskResponse.class, tags={ "Task", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = TaskResponse.class)
    })
    public Response createTask(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The logged in user.", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "The name of the task", required = true) @QueryParam("name") @NotNull  String name,@ApiParam(value = "The application to target") @QueryParam("appKey")  String appKey,@ApiParam(value = "Client defined identifier for grouping tasks") @QueryParam("groupingId")  String groupingId,@ApiParam(value = "The URL for making an HTTP call") @QueryParam("endpointURL")  String endpointURL,@ApiParam(value = "The parameters for making an HTTP call") @QueryParam("payload")  String payload,@ApiParam(value = "The date and time of the task") @QueryParam("scheduledDate")  Long scheduledDate,@ApiParam(value = "The starting date of the task") @QueryParam("startDate")  Long startDate,@ApiParam(value = "The ending date of the task") @QueryParam("endDate")  Long endDate,@ApiParam(value = "The cron expression that represents the task's schedule") @QueryParam("cronExpression")  String cronExpression,@ApiParam(value = "The determines the scope of who is able to find and view the scheduled notification (PUBLIC - openly available to all Sirqul users, PRIVATE - only available to users that have been invited)", allowableValues="PUBLIC, PRIVATE, FRIENDS") @QueryParam("visibility")  String visibility,@ApiParam(value = "Sets whether the Task is active or not (inactive Tasks are not processed)", defaultValue = "true") @DefaultValue("true") @QueryParam("active")  Boolean active,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.createTask(version, accountId, name, appKey, groupingId, endpointURL, payload, scheduledDate, startDate, endDate, cronExpression, visibility, active, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/territory/create")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Create Territory", notes = "Creates a territory.", response = TerritoryResponse.class, tags={ "Territory", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = TerritoryResponse.class)
    })
    public Response createTerritory(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The logged in user.", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "The name of the territory", required = true) @QueryParam("name") @NotNull  String name,@ApiParam(value = "If true set the game level as active. Default is true.") @QueryParam("active")  Boolean active,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.createTerritory(version, accountId, name, active, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/tournament/create")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Create Tournament", notes = "Create a tournament.", response = TournamentResponse.class, tags={ "Tournament", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = TournamentResponse.class)
    })
    public Response createTournament(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The logged in user.", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "The appKey the tournament is created for.", required = true) @QueryParam("appKey") @NotNull  String appKey,@ApiParam(value = "The title of the tournament", required = true) @QueryParam("title") @NotNull  String title,@ApiParam(value = "The number of tickets required to pay to enter the tournament", required = true) @QueryParam("costToPlay") @NotNull  Integer costToPlay,@ApiParam(value = "The date/time to start the tournament", required = true) @QueryParam("startDate") @NotNull  Long startDate,@ApiParam(value = "Custom string client apps can use for searching/filtering tournaments") @QueryParam("subType")  String subType,@ApiParam(value = "The asset ID to attach to the tournament") @QueryParam("imageAssetId")  Long imageAssetId,@ApiParam(value = "The number of seconds in between the start of each tournament game/group", defaultValue = "600") @DefaultValue("600") @QueryParam("secondsBetweenLevels")  Integer secondsBetweenLevels,@ApiParam(value = "The number of seconds to extend the round end time in the case of a tie breaker", defaultValue = "600") @DefaultValue("600") @QueryParam("secondsForTieBreaker")  Integer secondsForTieBreaker,@ApiParam(value = "The number of seconds in between the start of each tournament round", defaultValue = "86400") @DefaultValue("86400") @QueryParam("secondsBetweenPacks")  Integer secondsBetweenPacks,@ApiParam(value = "The maximum number of seconds the match is expected to end at, which gets used to determine when a match should end when there is no activity", defaultValue = "1800") @DefaultValue("1800") @QueryParam("maximumLevelLength")  Integer maximumLevelLength,@ApiParam(value = "The type of ticket required to pay") @QueryParam("costToPlayType")  String costToPlayType,@ApiParam(value = "The minimum number of players required to sign up for the tournament to be played", defaultValue = "1") @DefaultValue("1") @QueryParam("minimumToPlay")  Integer minimumToPlay,@ApiParam(value = "The starting number of players for a tournament (filled with AI's)") @QueryParam("startingLimit")  Integer startingLimit,@ApiParam(value = "The maximum number of players for a tournament (currently 128 but not enforced)") @QueryParam("availableLimit")  Integer availableLimit,@ApiParam(value = "The description of the tournament") @QueryParam("description")  String description,@ApiParam(value = "External custom client defined data") @QueryParam("metaData")  String metaData,@ApiParam(value = "The audiences associated with the tournament") @QueryParam("audienceIds")  String audienceIds,@ApiParam(value = "Activate/deactivate the tournament") @QueryParam("active")  Boolean active,@ApiParam(value = "Determines whether to allow players to buy back into a tournament", defaultValue = "false") @DefaultValue("false") @QueryParam("enableBuyBack")  Boolean enableBuyBack,@ApiParam(value = "The list of offers to give as a reward beyond the tickets") @QueryParam("offerIds")  String offerIds,@ApiParam(value = "The artwork ID to attach to the reward tickets offers") @QueryParam("offerAssetId")  Long offerAssetId,@ApiParam(value = "If set then do not update the ticket reward, auto set to true if offerIds provided", defaultValue = "false") @DefaultValue("false") @QueryParam("fixedReward")  Boolean fixedReward,@ApiParam(value = "Set the rules for handling the reward in case of a tie, values: EVEN split the reward evenly ALL everyone gets the full reward value FIRST first score submitted RANDOM random player who scored", allowableValues="EVEN, ALL, FIRST, RANDOM", defaultValue = "ALL") @DefaultValue("ALL") @QueryParam("splitReward")  String splitReward,@ApiParam(value = "Flag to indicate owner should receive tickets for completed missions") @QueryParam("allocateTickets")  Boolean allocateTickets,@ApiParam(value = "A text based string that will be passed into each tournament setup to populate the content") @QueryParam("tournamentData")  String tournamentData,@ApiParam(value = "The style of tournament to build, options are: TOURNAMENT, POOLPLAY", allowableValues="TOURNAMENT, POOLPLAY, MULTISTAGE", defaultValue = "MULTISTAGE") @DefaultValue("MULTISTAGE") @QueryParam("missionType")  String missionType,@ApiParam(value = "Sets the visibility flag for the tournament", allowableValues="PUBLIC, LISTABLE, REWARDABLE, TRIGGERABLE, PRIVATE", defaultValue = "PUBLIC") @DefaultValue("PUBLIC") @QueryParam("visibility")  String visibility,@ApiParam(value = "The number of initial preliminary groups in a multi-stage tournament (this is expected to be a power of two number)", defaultValue = "1") @DefaultValue("1") @QueryParam("preliminaryGroups")  Integer preliminaryGroups,@ApiParam(value = "This determines how many people can advance per round in a preliminary group (this is a comma separated list of integers)", defaultValue = "1") @DefaultValue("1") @QueryParam("preliminaryGroupAdvancements")  String preliminaryGroupAdvancements,@ApiParam(value = "This determines if multiple submissions/entries are allowed in a multi-stage album tournament", defaultValue = "false") @DefaultValue("false") @QueryParam("enableMultipleEntries")  Boolean enableMultipleEntries,@ApiParam(value = "This determines if users are allowed to vote multiple times per group in a multi-stage album tournament", defaultValue = "false") @DefaultValue("false") @QueryParam("enableMultipleVotes")  Boolean enableMultipleVotes,@ApiParam(value = "This determines whether the tournament is \"featured\" or not", defaultValue = "false") @DefaultValue("false") @QueryParam("featured")  Boolean featured,@ApiParam(value = "This sets what analytic tag is used when a winner is determined") @QueryParam("winnerTag")  String winnerTag,@ApiParam(value = "This sets what analytic tag is used when a tie has occurred") @QueryParam("tieTag")  String tieTag,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.createTournament(version, accountId, appKey, title, costToPlay, startDate, subType, imageAssetId, secondsBetweenLevels, secondsForTieBreaker, secondsBetweenPacks, maximumLevelLength, costToPlayType, minimumToPlay, startingLimit, availableLimit, description, metaData, audienceIds, active, enableBuyBack, offerIds, offerAssetId, fixedReward, splitReward, allocateTickets, tournamentData, missionType, visibility, preliminaryGroups, preliminaryGroupAdvancements, enableMultipleEntries, enableMultipleVotes, featured, winnerTag, tieTag, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/trigger/create")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Create Trigger", notes = "Create a trigger", response = TriggerResponse.class, tags={ "Trigger", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = TriggerResponse.class)
    })
    public Response createTrigger(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The logged in user", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "The name of the trigger", required = true) @QueryParam("name") @NotNull  String name,@ApiParam(value = "The application to target") @QueryParam("appKey")  String appKey,@ApiParam(value = "Client defined identifier for grouping triggers") @QueryParam("groupingId")  String groupingId,@ApiParam(value = "The URL for making an HTTP call") @QueryParam("endpointURL")  String endpointURL,@ApiParam(value = "The parameters for making an HTTP call") @QueryParam("payload")  String payload,@ApiParam(value = "The date and time of the next trigger") @QueryParam("scheduledDate")  Long scheduledDate,@ApiParam(value = "The starting date of the trigger") @QueryParam("startDate")  Long startDate,@ApiParam(value = "The ending date of the trigger") @QueryParam("endDate")  Long endDate,@ApiParam(value = "The cron expression that represents the trigger's schedule") @QueryParam("cronExpression")  String cronExpression,@ApiParam(value = "Json input representing conditional logic that has to be met before running the trigger") @QueryParam("conditionalInput")  String conditionalInput,@ApiParam(value = "The determines the scope of who is able to find and view the scheduled notification (PUBLIC - openly available to all Sirqul users, PRIVATE - only available to users that have been invited)", allowableValues="PUBLIC, PRIVATE, FRIENDS") @QueryParam("visibility")  String visibility,@ApiParam(value = "Sets whether the Trigger is active or not (inactive Triggers are not processed)", defaultValue = "true") @DefaultValue("true") @QueryParam("active")  Boolean active,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.createTrigger(version, accountId, name, appKey, groupingId, endpointURL, payload, scheduledDate, startDate, endDate, cronExpression, conditionalInput, visibility, active, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/trip")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Create Trip", notes = "Create a new trip", response = Trip.class, tags={ "Trip", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = Trip.class)
    })
    public Response createTrip(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "") @Valid  Trip body,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.createTrip(version, body, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/vatom/b/events/create")
    
    
    @io.swagger.annotations.ApiOperation(value = "Create Vatom Event", notes = "Create a Vatom event.", response = Void.class, tags={ "Vatom", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = Void.class)
    })
    public Response createVatomEvent(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "Sirqul Account Id", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "Sirqul Application Key", required = true) @QueryParam("appKey") @NotNull  String appKey,@ApiParam(value = "Vatom Parameters", required = true) @QueryParam("vatomParameters") @NotNull  String vatomParameters,@ApiParam(value = "Return raw response") @QueryParam("returnRawResponse")  Boolean returnRawResponse,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.createVatomEvent(version, accountId, appKey, vatomParameters, returnRawResponse, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/vehicle")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Create Vehicle", notes = "Create new vehicle", response = Vehicle.class, tags={ "Vehicle", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = Vehicle.class)
    })
    public Response createVehicle(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "A JSON representation of cargo type. ```json {   \"name\": \"Truck\",   \"vehicleType\": { \"id\": 1 },   \"hub\": { \"id\": 1 } } ``` ", required = true) @QueryParam("vehicle") @NotNull  String vehicle,@ApiParam(value = "") @Valid  Vehicle body,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.createVehicle(version, vehicle, body, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/vehicle/type")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Create Vehicle Type", notes = "Create a new vehicle type", response = VehicleType.class, tags={ "Vehicle Type", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = VehicleType.class)
    })
    public Response createVehicleType(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "A JSON representation of cargo type. ```json {   \"name\": \"Truck\",   \"width\": 100,   \"height\": 200,   \"depth\": 200,   \"maxWeight\": 5000,   \"hub\": { \"id\": 1 } } ``` ", required = true) @QueryParam("vehicleType") @NotNull  String vehicleType,@ApiParam(value = "") @Valid  VehicleType body,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.createVehicleType(version, vehicleType, body, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/orson/ai/voiceCanvas")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Create VoiceCanvas images", notes = "Create VoiceCanvas images for provided text, file upload, or file URL", response = OrsonAiVoiceCanvasResponse.class, tags={ "Orson", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = OrsonAiVoiceCanvasResponse.class)
    })
    public Response createVoiceCanvas(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "Sirqul Account Id", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "Enum: \"256x256\" \"512x512\" \"1024x1024\"", required = true) @QueryParam("dimensions") @NotNull  String dimensions,@ApiParam(value = "A third-party account id that is meaningful to your systems") @QueryParam("thirdPartyAccountId")  String thirdPartyAccountId,@ApiParam(value = "Provide a transcript or previously extracted topics for image generation") @QueryParam("text")  String text,@ApiParam(value = "An uploaded recording to analyze (Currently limited to 10MB)") @QueryParam("file")  File _file,@ApiParam(value = "A recording file to download and analyze (Size limit: 1GB)") @QueryParam("url")  String url,@ApiParam(value = "When false, uses the raw value from text instead of identifying topics to fetch/generate from") @QueryParam("parseFlag")  Boolean parseFlag,@ApiParam(value = "When true, fetches images instead of generating them") @QueryParam("fetchFlag")  Boolean fetchFlag,@ApiParam(value = "When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open") @QueryParam("callback")  String paramCallback,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.createVoiceCanvas(version, accountId, dimensions, thirdPartyAccountId, text, _file, url, parseFlag, fetchFlag, paramCallback, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/game/word/create")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Create Word", notes = "Create a word by the given params.", response = WordzWordResponse.class, tags={ "Word", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = WordzWordResponse.class)
    })
    public Response createWord(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The logged in user.", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "The text of the word.", required = true) @QueryParam("word") @NotNull  String word,@ApiParam(value = "The definition of the word.", required = true) @QueryParam("definition") @NotNull  String definition,@ApiParam(value = "If true set the word to active. Default to false.", required = true, defaultValue = "false") @DefaultValue("false") @QueryParam("active") @NotNull  Boolean active,@ApiParam(value = "If true then scoring will give tickets. Default to false.", required = true, defaultValue = "false") @DefaultValue("false") @QueryParam("allocateTickets") @NotNull  Boolean allocateTickets,@ApiParam(value = "The number of tickets to reward", required = true, defaultValue = "0") @DefaultValue("0") @QueryParam("ticketCount") @NotNull  Long ticketCount,@ApiParam(value = "The asset id of the word.") @QueryParam("assetId")  Long assetId,@ApiParam(value = "The type of ticket to reward, null means default type") @QueryParam("ticketType")  String ticketType,@ApiParam(value = "The number of points to award for completing a mission") @QueryParam("points")  Long points,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.createWord(version, accountId, word, definition, active, allocateTickets, ticketCount, assetId, ticketType, points, securityContext);
    }
    @javax.ws.rs.DELETE
    @Path("/trip/{id}")
    
    
    @io.swagger.annotations.ApiOperation(value = "Delete Trip", notes = "Delete an existing trip", response = Void.class, tags={ "Trip", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = Void.class)
    })
    public Response delete(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the id of the trip to delete", required = true) @PathParam("id") @NotNull  Long id,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.delete(version, id, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/achievement/delete")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Delete Achievement", notes = "Deletes an achievement (for developer/retailer use). User must have permissions to the application the achievement was created for.", response = SirqulResponse.class, tags={ "Achievement", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response deleteAchievement(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The ID of the achievement", required = true) @QueryParam("achievementId") @NotNull  Long achievementId,@ApiParam(value = "the account id of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.deleteAchievement(version, achievementId, accountId, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/achievement/tier/delete")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Delete Achievement Tier", notes = "Deletes an achievement tier (for developer/retailer use). User must have permissions to the application the achievement was created for.", response = SirqulResponse.class, tags={ "Achievement", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response deleteAchievementTier(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the achievement id for deletion", required = true) @QueryParam("achievementTierId") @NotNull  Long achievementTierId,@ApiParam(value = "the account id of the user (deviceId or accountId required).") @QueryParam("accountId")  Long accountId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.deleteAchievementTier(version, achievementTierId, accountId, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/application/delete")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Delete Application", notes = "Set the deleted timestamp to current time. This effectively deletes the application since all queries should ignore any records with a deleted timestamp", response = SirqulResponse.class, tags={ "Application", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response deleteApplication(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The account used to perform the delete, must have rights to edit the application.") @QueryParam("accountId")  Long accountId,@ApiParam(value = "The key of the application to be deleted") @QueryParam("appKey")  String appKey,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.deleteApplication(version, accountId, appKey, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/appconfig/delete")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Delete AppConfig", notes = "Mark the application configuration for deletion.", response = SirqulResponse.class, tags={ "Application Config", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response deleteApplicationConfig(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The account ID of the user", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "The config ID of the application configuration to delete", required = true) @QueryParam("configId") @NotNull  Long configId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.deleteApplicationConfig(version, accountId, configId, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/application/placement/delete")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Delete Ad Placement", notes = "Deletes an ad placement for an application.", response = PlacementResponse.class, tags={ "Application", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = PlacementResponse.class)
    })
    public Response deleteApplicationPlacement(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The id of the placement to delete, the user must have rights to the application the ad placement is for", required = true) @QueryParam("placementId") @NotNull  Long placementId,@ApiParam(value = "The unique id of the device making the request (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "The account id of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.deleteApplicationPlacement(version, placementId, deviceId, accountId, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/asset/delete")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Delete Asset", notes = "Delete an asset.", response = SirqulResponse.class, tags={ "Asset", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response deleteAsset(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the id of the asset to delete", required = true) @QueryParam("assetId") @NotNull  String assetId,@ApiParam(value = "the device id (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "the account id of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "latitude used to update the user's current location") @QueryParam("latitude")  Double latitude,@ApiParam(value = "longitude used to update the user's current location") @QueryParam("longitude")  Double longitude,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.deleteAsset(version, assetId, deviceId, accountId, latitude, longitude, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/audience/delete")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Delete Audience", notes = "Delete an audience. The audience and account must be valid and have the appropirate permissions to view the content.", response = SirqulResponse.class, tags={ "Audience", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response deleteAudience(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The logged in user.", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "The id of the audience to delete.", required = true) @QueryParam("audienceId") @NotNull  Long audienceId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.deleteAudience(version, accountId, audienceId, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/report/batch/delete")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Delete Offline Report", notes = "Deletes a batch report.", response = SirqulResponse.class, tags={ "Reporting", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response deleteBatch(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the id of the account", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "the id of the batch to delete", required = true) @QueryParam("batchId") @NotNull  Long batchId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.deleteBatch(version, accountId, batchId, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/bid/delete")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Delete Bid", notes = "Deleted a bid on a biddable object", response = SirqulResponse.class, tags={ "Bid", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response deleteBid(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The bid id", required = true) @QueryParam("bidId") @NotNull  Long bidId,@ApiParam(value = "The device id (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "The account id of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.deleteBid(version, bidId, deviceId, accountId, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/billable/delete")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Delete Billable", notes = "Mark the billable as deleted", response = SirqulResponse.class, tags={ "Billable Entity", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response deleteBillableEntity(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The device id (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "The account used to perform the delete, must have rights to edit the billable entity.") @QueryParam("accountId")  Long accountId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.deleteBillableEntity(version, deviceId, accountId, securityContext);
    }
    @javax.ws.rs.DELETE
    @Path("/cargo/type/{cargoTypeId}")
    
    
    @io.swagger.annotations.ApiOperation(value = "Delete Cargo Type", notes = "Delete a type of cargo", response = Void.class, tags={ "Cargo Type", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = Void.class)
    })
    public Response deleteCargoType(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the ID of the cargo type", required = true) @PathParam("cargoTypeId") @NotNull  Long cargoTypeId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.deleteCargoType(version, cargoTypeId, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/category/delete")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Delete Category", notes = "Delete a category.", response = SirqulResponse.class, tags={ "Category", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response deleteCategory(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the ID of the account", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "the ID of the category", required = true) @QueryParam("categoryId") @NotNull  Long categoryId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.deleteCategory(version, accountId, categoryId, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/consumer/album/contest/remove")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Delete Contest", notes = "Deletes a contest.", response = SirqulResponse.class, tags={ "Contest", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response deleteContest(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the album contest ID", required = true) @QueryParam("albumContestId") @NotNull  Long albumContestId,@ApiParam(value = "a unique ID given by the device (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "the account ID of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "latitude used to update the user's current location") @QueryParam("latitude")  Double latitude,@ApiParam(value = "longitude used to update the user's current location") @QueryParam("longitude")  Double longitude,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.deleteContest(version, albumContestId, deviceId, accountId, latitude, longitude, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/creative/delete")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Delete Creative", notes = "Delete a creative", response = SirqulResponse.class, tags={ "Creative", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response deleteCreative(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the id of the logged in user", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "the id of the creative to delete", required = true) @QueryParam("creativeId") @NotNull  Long creativeId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.deleteCreative(version, accountId, creativeId, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/thirdparty/credential/delete")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Delete Credential", notes = "Delete a third party network on a Sirqul account.", response = SirqulResponse.class, tags={ "ThirdParty Credentials", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response deleteCredential(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The account id of the user", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "The third party network identifier", required = true) @QueryParam("networkUID") @NotNull  String networkUID,@ApiParam(value = "The third party user id", required = true) @QueryParam("thirdPartyId") @NotNull  String thirdPartyId,@ApiParam(value = "the application key", required = true) @QueryParam("appKey") @NotNull  String appKey,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.deleteCredential(version, accountId, networkUID, thirdPartyId, appKey, securityContext);
    }
    @javax.ws.rs.DELETE
    @Path("/object/data/{objectName}/{objectId}")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Delete Data", notes = "Delete a record for the specified object. Cannot be undone so use only when abolutely sure.", response = ObjectStoreResponse.class, tags={ "Object Store", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = ObjectStoreResponse.class)
    })
    public Response deleteData(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The name of the object to search upon", required = true) @PathParam("objectName") @NotNull  String objectName,@ApiParam(value = "objectId The id of the record to return", required = true) @PathParam("objectId") @NotNull  String objectId,@ApiParam(value = "The account id of the logged in user") @QueryParam("accountId")  Long accountId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.deleteData(version, objectName, objectId, accountId, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/employee/delete")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Delete Employee", notes = "Set the deleted date field which marks the record as deleted.", response = SirqulResponse.class, tags={ "Employee", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response deleteEmployee(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the id of the logged in user", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "the id of the employee to delete", required = true) @QueryParam("employeeAccountId") @NotNull  Long employeeAccountId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.deleteEmployee(version, accountId, employeeAccountId, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/event/delete")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Delete Event", notes = "Delete an event that the user has permissions to.", response = SirqulResponse.class, tags={ "Event", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response deleteEvent(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the id of the logged in user", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "the id of the event to update", required = true) @QueryParam("eventId") @NotNull  Long eventId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.deleteEvent(version, accountId, eventId, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/favorite/delete")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Delete Favorite", notes = "Removes a favorited item from the user's favorites list.", response = SirqulResponse.class, tags={ "Favorite", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response deleteFavorite(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The unique ID given by the device (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "The account ID of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "The ID of the favorite reference record (only optional if favoritableId & favoritableType is pass in instead)") @QueryParam("favoriteId")  Long favoriteId,@ApiParam(value = "The ID of the object to un-favorite {offerId, offerLocationId, retailerLocationId, categoryId} (this is required if favoriteId is NOT passed in)") @QueryParam("favoritableId")  Long favoritableId,@ApiParam(value = "The type of the object to un-favorite {OFFER, OFFER_LOCATION, RETAILER_LOCATION, CATEGORY} (this is required if favoriteId is NOT passed in)") @QueryParam("favoritableType")  String favoritableType,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.deleteFavorite(version, deviceId, accountId, favoriteId, favoritableId, favoritableType, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/object/field/delete")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Delete Field", notes = "Delete a field from an object.  This will remove the field, indexes,   and foreign keys associated with the field.   The following field names   are reserved and cannot be removed from the object: ID, OBJECTID, CREATED,   UPDATED, DELETED", response = ObjectStoreResponse.class, tags={ "Object Store", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = ObjectStoreResponse.class)
    })
    public Response deleteField(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The account id of the logged in user", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "The application key for updating an existing application", required = true) @QueryParam("appKey") @NotNull  String appKey,@ApiParam(value = "The name of the object to remove the field from", required = true) @QueryParam("objectName") @NotNull  String objectName,@ApiParam(value = "field name The name of the field to remove.", required = true) @QueryParam("fieldName") @NotNull  String fieldName,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.deleteField(version, accountId, appKey, objectName, fieldName, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/filter/delete")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Delete Filter", notes = "Delete a filter.", response = SirqulResponse.class, tags={ "Filter", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response deleteFilter(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The account id of the user (must have permissions to the filter's assigned application)", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "The ID of the filter to delete", required = true) @QueryParam("filterId") @NotNull  Long filterId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.deleteFilter(version, accountId, filterId, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/flag/delete")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Delete Flag", notes = "Deletes a flag.", response = SirqulResponse.class, tags={ "Flag", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response deleteFlag(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The unique device identifier that made the request (either deviceId or accountId must be used)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "The unique accountId that made the request (either deviceId or accountId must be used)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "This parameter is deprecated.") @QueryParam("itemBeingFlaggedType")  String itemBeingFlaggedType,@ApiParam(value = "This parameter is deprecated.") @QueryParam("itemBeingFlaggedId")  Long itemBeingFlaggedId,@ApiParam(value = "The flagable object type {ACCOUNT, ALBUM, ALBUM_CONTEST, ASSET, GAME_LEVEL, THEME_DESCRIPTOR, OFFER, NOTE}") @QueryParam("flagableType")  String flagableType,@ApiParam(value = "The flagable object id") @QueryParam("flagableId")  Long flagableId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.deleteFlag(version, deviceId, accountId, itemBeingFlaggedType, itemBeingFlaggedId, flagableType, flagableId, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/vatom/me/rels/following/delete")
    
    
    @io.swagger.annotations.ApiOperation(value = "Delete following", notes = "Delete following.", response = Void.class, tags={ "Vatom", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = Void.class)
    })
    public Response deleteFollowing(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "Sirqul Account Id", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "Vatom Rels Key", required = true) @QueryParam("vatomRelsKey") @NotNull  String vatomRelsKey,@ApiParam(value = "Return raw response") @QueryParam("returnRawResponse")  Boolean returnRawResponse,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.deleteFollowing(version, accountId, vatomRelsKey, returnRawResponse, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/game/delete")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Delete a Game", notes = "Delete a game.", response = SirqulResponse.class, tags={ "Game", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response deleteGame(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The logged in user.", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "the updating game's id.", required = true) @QueryParam("gameId") @NotNull  Long gameId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.deleteGame(version, accountId, gameId, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/level/delete")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Delete Game Level", notes = "Delete a game level. The level and account must be valid and have the appropirate permissions to view the content.", response = SirqulResponse.class, tags={ "Game Level", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response deleteGameLevel(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The logged in user.", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "The id of the level to return.", required = true) @QueryParam("levelId") @NotNull  Long levelId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.deleteGameLevel(version, accountId, levelId, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/leaderboard/delete")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Delete the Leader Board", notes = "Removes a leader board id.", response = SirqulResponse.class, tags={ "Leaderboard", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response deleteLeaderboard(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The leaderboard id to delete.", required = true) @QueryParam("leaderboardId") @NotNull  Long leaderboardId,@ApiParam(value = "The account id of the user making the request.") @QueryParam("accountId")  Long accountId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.deleteLeaderboard(version, leaderboardId, accountId, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/listing/delete")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Delete Listing", notes = "Delete a listing.", response = SirqulResponse.class, tags={ "Listing", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response deleteListing(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the id of the logged in user", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "the id of the listing to delete", required = true) @QueryParam("listingId") @NotNull  Long listingId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.deleteListing(version, accountId, listingId, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/media/delete")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Delete Media", notes = "Delete a media offering that the user has permissions to.", response = SirqulResponse.class, tags={ "Media", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response deleteMedia(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the id of the logged in user", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "the ID of the media to delete", required = true) @QueryParam("mediaId") @NotNull  Long mediaId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.deleteMedia(version, accountId, mediaId, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/mission/delete")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Delete Mission", notes = "Delete a mission.", response = SirqulResponse.class, tags={ "Mission", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response deleteMission(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the id of the logged in user", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "the id of the mission to delete", required = true) @QueryParam("missionId") @NotNull  Long missionId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.deleteMission(version, accountId, missionId, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/mission/invite/delete")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Delete Mission Invite", notes = "Update the mission invite status to quit.", response = SirqulResponse.class, tags={ "Mission Invite", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response deleteMissionInvite(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the device id (deviceId or accountId required).") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "the account id of the user (deviceId or accountId required).") @QueryParam("accountId")  Long accountId,@ApiParam(value = "The mission to find the invite for (missionId or missionInviteId requried).") @QueryParam("missionId")  Long missionId,@ApiParam(value = "The mission invite id. This checks on the user's billable for permission (missionId or missionInviteId requried).") @QueryParam("missionInviteId")  Long missionInviteId,@ApiParam(value = "Include the game level data with the mission.") @QueryParam("includeGameData")  Boolean includeGameData,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.deleteMissionInvite(version, deviceId, accountId, missionId, missionInviteId, includeGameData, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/thirdparty/network/delete")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Delete Network", notes = "Marks a custom third party network as deleted. Only the network owners and managers have access to this.", response = SirqulResponse.class, tags={ "ThirdParty Credentials", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response deleteNetwork(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the id of the logged in user", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "The unique identifier for the third party network defined by Sirqul", required = true) @QueryParam("networkUID") @NotNull  String networkUID,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.deleteNetwork(version, accountId, networkUID, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/note/delete")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Delete Note", notes = "Sets a comment (note) as deleted.", response = SirqulResponse.class, tags={ "Note", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response deleteNote(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The ID of the note to delete", required = true) @QueryParam("noteId") @NotNull  Long noteId,@ApiParam(value = "The unique device identifier that made the request (either deviceId or accountId must be used)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "The unique accountId that made the request (either deviceId or accountId must be used)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "The current location of the user") @QueryParam("latitude")  Double latitude,@ApiParam(value = "The current location of the user") @QueryParam("longitude")  Double longitude,@ApiParam(value = "The application key used to identify the application") @QueryParam("appKey")  String appKey,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.deleteNote(version, noteId, deviceId, accountId, latitude, longitude, appKey, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/notification/template/delete")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Delete Notification Template", notes = "Deletes a notification template. Developers will only be able to delete notification templates for their own applications.", response = NotificationTemplateResponse.class, tags={ "Notification", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = NotificationTemplateResponse.class)
    })
    public Response deleteNotificationTemplate(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the account id of the user", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "the id of the notification template to delete", required = true) @QueryParam("notificationTemplateId") @NotNull  Long notificationTemplateId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.deleteNotificationTemplate(version, accountId, notificationTemplateId, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/object/delete")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Delete Object", notes = "Delete and Object in the store.  This will delete the table and clean up and foreign keys referencing it. Cannot be undone so use only when abolutely sure.", response = ObjectStoreResponse.class, tags={ "Object Store", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = ObjectStoreResponse.class)
    })
    public Response deleteObject(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the id of the logged in user", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "the application key", required = true) @QueryParam("appKey") @NotNull  String appKey,@ApiParam(value = "the name of the object to delete", required = true) @QueryParam("objectName") @NotNull  String objectName,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.deleteObject(version, accountId, appKey, objectName, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/retailer/offer/delete")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Delete Offer", notes = "Set the deleted timestamp to current time. This effectively deletes the offer since all queries should ignore any records with a deleted time stamp.", response = SirqulResponse.class, tags={ "Offer", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response deleteOffer(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The ID of the offer to be deleted", required = true) @QueryParam("offerId") @NotNull  Long offerId,@ApiParam(value = "The device id (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "The account used to perform the delete, must have rights to edit the offer.") @QueryParam("accountId")  Long accountId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.deleteOffer(version, offerId, deviceId, accountId, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/retailer/offer/location/delete")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Delete Offer Location", notes = "Set the deleted timestamp to current time. This effectively deletes the offer location since all queries should ignore any records with a deleted time stamp.", response = SirqulResponse.class, tags={ "Offer", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response deleteOfferLocation(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The ID of the offer location to be deleted", required = true) @QueryParam("offerLocationId") @NotNull  Long offerLocationId,@ApiParam(value = "The device id (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "The account used to perform the delete, must have rights to edit the offer location.") @QueryParam("accountId")  Long accountId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.deleteOfferLocation(version, offerLocationId, deviceId, accountId, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/wallet/delete")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Delete Wallet Offer", notes = "Removes the transaction from the wallet by setting the deleted date to the current date/time.  Requires a valid account and transactionId.", response = SirqulResponse.class, tags={ "Wallet", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response deleteOfferTransaction(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The offer transaction id to remove", required = true) @QueryParam("transactionId") @NotNull  Long transactionId,@ApiParam(value = "The device id (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "The account id of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.deleteOfferTransaction(version, transactionId, deviceId, accountId, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/offer/status/delete")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Delete Offer Status", notes = "Mark an offer status record as deleted", response = SirqulResponse.class, tags={ "Offer Status", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response deleteOfferTransactionStatus(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The id of the record to delete", required = true) @QueryParam("statusId") @NotNull  Long statusId,@ApiParam(value = "The device id (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "The account id of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "Used to update the user's current location") @QueryParam("latitude")  Double latitude,@ApiParam(value = "Used to update the user's current location") @QueryParam("longitude")  Double longitude,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.deleteOfferTransactionStatus(version, statusId, deviceId, accountId, latitude, longitude, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/order/delete")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Delete Order", notes = "Removes the transaction from the wallet by setting the deleted date to the current date/time.  Requires a valid account and transactionId.", response = SirqulResponse.class, tags={ "Purchase Order", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response deleteOrder(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "Order Id", required = true) @QueryParam("orderId") @NotNull  Long orderId,@ApiParam(value = "The device id (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "The account id of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.deleteOrder(version, orderId, deviceId, accountId, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/pack/delete")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Delete Pack", notes = "Delete a pack.", response = SirqulResponse.class, tags={ "Pack", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response deletePack(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the id of the logged in user", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "the id of the pack to delete", required = true) @QueryParam("packId") @NotNull  Long packId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.deletePack(version, accountId, packId, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/persona/delete")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Delete Persona", notes = "Mark the persona for deletion.", response = SirqulResponse.class, tags={ "Preview Persona", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response deletePersona(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the account id of the user", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "the id of the persona to delete", required = true) @QueryParam("personaId") @NotNull  Long personaId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.deletePersona(version, accountId, personaId, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/vatom/b/campaign/points/delete")
    
    
    @io.swagger.annotations.ApiOperation(value = "Reset All Points Balance", notes = "Reset All Points Balance.", response = Void.class, tags={ "Vatom", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = Void.class)
    })
    public Response deletePointsBalance(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "Sirqul Account Id", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "Sirqul Application Key", required = true) @QueryParam("appKey") @NotNull  String appKey,@ApiParam(value = "Vatom Campaign Id", required = true) @QueryParam("vatomCampaignId") @NotNull  String vatomCampaignId,@ApiParam(value = "Return raw response") @QueryParam("returnRawResponse")  Boolean returnRawResponse,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.deletePointsBalance(version, accountId, appKey, vatomCampaignId, returnRawResponse, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/postalCode/delete")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Delete Postal Code", notes = "Delete a Postal Code", response = SirqulResponse.class, tags={ "Postal Code", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response deletePostalCode(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the id of the logged in user", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "the id of the postal code to delete", required = true) @QueryParam("postalCodeId") @NotNull  Long postalCodeId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.deletePostalCode(version, accountId, postalCodeId, securityContext);
    }
    @javax.ws.rs.DELETE
    @Path("/program/{id}")
    
    
    @io.swagger.annotations.ApiOperation(value = "Delete Program", notes = "Delete an existing program", response = Void.class, tags={ "Program", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = Void.class)
    })
    public Response deleteProgram(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the id of the program", required = true) @PathParam("id") @NotNull  Long id,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.deleteProgram(version, id, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/purchase/delete")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Delete Purchase", notes = "Marks the purchase item as deleted", response = SirqulResponse.class, tags={ "Purchase Item", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response deletePurchaseItem(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The purchase item id", required = true) @QueryParam("purchaseItemId") @NotNull  Long purchaseItemId,@ApiParam(value = "The device id (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "The account id of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.deletePurchaseItem(version, purchaseItemId, deviceId, accountId, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/game/question/delete")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Delete Question", notes = "Delete a question by the given questionId. The accountId given needs to be the owner or executive to delete.", response = SirqulResponse.class, tags={ "Question", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response deleteQuestion(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the id of the question to delete", required = true) @QueryParam("questionId") @NotNull  Long questionId,@ApiParam(value = "the id of the account that can execute this request", required = true) @QueryParam("accountId") @NotNull  Long accountId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.deleteQuestion(version, questionId, accountId, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/rating/delete")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Delete Rating", notes = "Sets a rating as deleted.", response = SirqulResponse.class, tags={ "Rating", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response deleteRating(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The ID of the rating to delete", required = true) @QueryParam("ratingId") @NotNull  Long ratingId,@ApiParam(value = "The unique device identifier that made the request (either deviceId or accountId must be used)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "The unique accountId that made the request (either deviceId or accountId must be used)") @QueryParam("accountId")  Long accountId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.deleteRating(version, ratingId, deviceId, accountId, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/region/delete")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Delete Region", notes = "Delete a region.", response = RegionResponse.class, tags={ "Region", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = RegionResponse.class)
    })
    public Response deleteRegion(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the id of the account logged in", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "the id of the region", required = true) @QueryParam("regionId") @NotNull  Long regionId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.deleteRegion(version, accountId, regionId, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/reservation/delete")
    
    
    @io.swagger.annotations.ApiOperation(value = "Delete Reservation", notes = "Deleted a reservation on a reservation object", response = Void.class, tags={ "Reservation", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = Void.class)
    })
    public Response deleteReservation(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The reservation id", required = true) @QueryParam("reservationId") @NotNull  Long reservationId,@ApiParam(value = "The device id (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "The account id of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.deleteReservation(version, reservationId, deviceId, accountId, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/retailer/delete")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Delete Retailer", notes = "Set the deleted timestamp to current time.", response = SirqulResponse.class, tags={ "Retailer", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response deleteRetailer(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The device id (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "The account used to perform the delete, must have rights to edit the retailer.") @QueryParam("accountId")  Long accountId,@ApiParam(value = "The ID of the retailer to be deleted") @QueryParam("retailerId")  Long retailerId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.deleteRetailer(version, deviceId, accountId, retailerId, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/retailer/location/delete")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Delete Retailer Location", notes = "Set the deleted timestamp to current time. This effectively deletes the retailer location since all queries should ignore any records with a deleted time stamp.", response = SirqulResponse.class, tags={ "Retailer Location", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response deleteRetailerLocation(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the device id") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "the id of the logged in user") @QueryParam("accountId")  Long accountId,@ApiParam(value = "the id of the retailer location to delete") @QueryParam("retailerLocationId")  Long retailerLocationId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.deleteRetailerLocation(version, deviceId, accountId, retailerLocationId, securityContext);
    }
    @javax.ws.rs.DELETE
    @Path("/route/{routeId}")
    
    
    @io.swagger.annotations.ApiOperation(value = "Delete Route", notes = "Delete an existing route", response = Void.class, tags={ "Route", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = Void.class)
    })
    public Response deleteRoute(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the id of the route", required = true) @PathParam("routeId") @NotNull  Long routeId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.deleteRoute(version, routeId, securityContext);
    }
    @javax.ws.rs.DELETE
    @Path("/route/setting/{routeSettingsId}")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Delete Route Setting", notes = "Delete an existing route setting", response = Object.class, tags={ "Route Setting", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = Object.class)
    })
    public Response deleteRouteSettings(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the id of the route setting to delete", required = true) @PathParam("routeSettingsId") @NotNull  Long routeSettingsId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.deleteRouteSettings(version, routeSettingsId, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/notification/schedule/delete")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Delete Scheduled Notification", notes = "This endpoint deletes a Scheduled Notification. Only the original owner of the Scheduled Notification or someone with write permissions can use this endpoint. Permissions can be granted to other users by using the UserPermissionsApi.", response = ScheduledNotificationFullResponse.class, tags={ "Scheduled Notification", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = ScheduledNotificationFullResponse.class)
    })
    public Response deleteScheduledNotification(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the id of the logged in user", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "the id of the scheduled notification to delete", required = true) @QueryParam("scheduledNotificationId") @NotNull  Long scheduledNotificationId,@ApiParam(value = "If set to true, also deletes Scheduled Notifications under the same account with the same groupingId.") @QueryParam("deleteByGroupingId")  Boolean deleteByGroupingId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.deleteScheduledNotification(version, accountId, scheduledNotificationId, deleteByGroupingId, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/secure/application/delete")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Delete Secure Application", notes = "Delete a secure application record.", response = SirqulResponse.class, tags={ "SecureApp", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response deleteSecureApplication(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The unique id of the user making the request", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "The application to secure", required = true) @QueryParam("appKey") @NotNull  String appKey,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.deleteSecureApplication(version, accountId, appKey, securityContext);
    }
    @javax.ws.rs.DELETE
    @Path("/hub/{id}")
    
    
    @io.swagger.annotations.ApiOperation(value = "Delete Service Hub", notes = "Delete an existing service hub", response = Void.class, tags={ "Service Hub", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = Void.class)
    })
    public Response deleteServiceHub(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the id of the service hub to delete", required = true) @PathParam("id") @NotNull  Long id,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.deleteServiceHub(version, id, securityContext);
    }
    @javax.ws.rs.DELETE
    @Path("/shipment/{id}")
    
    
    @io.swagger.annotations.ApiOperation(value = "Delete Shipment", notes = "Delete an existing shipment", response = Void.class, tags={ "Shipment", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = Void.class)
    })
    public Response deleteShipment(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the id of the shipment to delete", required = true) @PathParam("id") @NotNull  Long id,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.deleteShipment(version, id, securityContext);
    }
    @javax.ws.rs.DELETE
    @Path("/shipment/batch/{batchId}")
    
    
    @io.swagger.annotations.ApiOperation(value = "Delete Shipment Batch", notes = "Search for shipment batches", response = Void.class, tags={ "Shipment Batch", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = Void.class)
    })
    public Response deleteShipmentBatch(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the id of the shipment batch to delete", required = true) @PathParam("batchId") @NotNull  Long batchId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.deleteShipmentBatch(version, batchId, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/vatom/b/spaces/delete")
    
    
    @io.swagger.annotations.ApiOperation(value = "Delete Vatom Space", notes = "Delete a Vatom space.", response = Void.class, tags={ "Vatom", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = Void.class)
    })
    public Response deleteSpace(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "Sirqul Account Id", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "Sirqul Application Key", required = true) @QueryParam("appKey") @NotNull  String appKey,@ApiParam(value = "Vatom Space Id", required = true) @QueryParam("vatomSpaceId") @NotNull  String vatomSpaceId,@ApiParam(value = "Return raw response") @QueryParam("returnRawResponse")  Boolean returnRawResponse,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.deleteSpace(version, accountId, appKey, vatomSpaceId, returnRawResponse, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/subscription/delete")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Delete Subscription", notes = "Suspend the current subscription for the billable entity managed by the account.  The account must be the responsible manager to perform this action", response = SirqulResponse.class, tags={ "Subscription", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response deleteSubscription(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The account used to perform the delete, must be the responsible manager", required = true) @QueryParam("accountId") @NotNull  Long accountId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.deleteSubscription(version, accountId, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/task/delete")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Delete Task", notes = "Delete a Task", response = SirqulResponse.class, tags={ "Task", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response deleteTask(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The logged in user.", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "The id of the Task to delete.", required = true) @QueryParam("taskId") @NotNull  Long taskId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.deleteTask(version, accountId, taskId, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/territory/delete")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Delete Territory", notes = "Deletes a territory.", response = SirqulResponse.class, tags={ "Territory", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response deleteTerritory(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the id of the logged in user", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "the id of the territory to delete", required = true) @QueryParam("territoryId") @NotNull  Long territoryId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.deleteTerritory(version, accountId, territoryId, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/tournament/delete")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Delete Tournament", notes = "Delete a tournament.", response = SirqulResponse.class, tags={ "Tournament", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response deleteTournament(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the id of the logged in user", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "the id of the mission to delete", required = true) @QueryParam("missionId") @NotNull  Long missionId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.deleteTournament(version, accountId, missionId, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/trigger/delete")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Delete Trigger", notes = "Mark a trigger as deleted.", response = SirqulResponse.class, tags={ "Trigger", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response deleteTrigger(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The logged in user.", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "The id of the trigger to delete.", required = true) @QueryParam("triggerId") @NotNull  Long triggerId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.deleteTrigger(version, accountId, triggerId, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/vatom/b/events/delete")
    
    
    @io.swagger.annotations.ApiOperation(value = "Delete Vatom Event", notes = "Delete a Vatom event.", response = Void.class, tags={ "Vatom", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = Void.class)
    })
    public Response deleteVatomEvent(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "Sirqul Account Id", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "Sirqul Application Key", required = true) @QueryParam("appKey") @NotNull  String appKey,@ApiParam(value = "Vatom Event Id", required = true) @QueryParam("vatomEventId") @NotNull  String vatomEventId,@ApiParam(value = "Return raw response") @QueryParam("returnRawResponse")  Boolean returnRawResponse,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.deleteVatomEvent(version, accountId, appKey, vatomEventId, returnRawResponse, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/vatom/vatoms/delete")
    
    
    @io.swagger.annotations.ApiOperation(value = "Delete Vatom NFT", notes = "Delete Vatom NFT", response = Void.class, tags={ "Vatom", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = Void.class)
    })
    public Response deleteVatomNFT(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "Sirqul Account Id", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "Vatom NFT Id", required = true) @QueryParam("vatomId") @NotNull  String vatomId,@ApiParam(value = "Return raw response") @QueryParam("returnRawResponse")  Boolean returnRawResponse,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.deleteVatomNFT(version, accountId, vatomId, returnRawResponse, securityContext);
    }
    @javax.ws.rs.DELETE
    @Path("/vehicle/{id}")
    
    
    @io.swagger.annotations.ApiOperation(value = "Delete Vehicle", notes = "Delete an existing vehicle", response = Void.class, tags={ "Vehicle", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = Void.class)
    })
    public Response deleteVehicle(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The id of the vehicle to delete", required = true) @PathParam("id") @NotNull  Long id,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.deleteVehicle(version, id, securityContext);
    }
    @javax.ws.rs.DELETE
    @Path("/vehicle/type/{vehicleTypeId}")
    
    
    @io.swagger.annotations.ApiOperation(value = "Delete Vehicle Type", notes = "Delete a vehicle type", response = Void.class, tags={ "Vehicle Type", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = Void.class)
    })
    public Response deleteVehicleType(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The id of the requested vehicle type", required = true) @PathParam("vehicleTypeId") @NotNull  Long vehicleTypeId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.deleteVehicleType(version, vehicleTypeId, securityContext);
    }
    @javax.ws.rs.DELETE
    @Path("/game/word/delete")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Delete Word", notes = "Delete a word by the given id. The accountId given needs to be the owner or executive to delete.", response = SirqulResponse.class, tags={ "Word", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response deleteWord(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The id of the word to delete.", required = true) @QueryParam("wordId") @NotNull  Long wordId,@ApiParam(value = "The account vor validating permission", required = true) @QueryParam("accountId") @NotNull  Long accountId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.deleteWord(version, wordId, accountId, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/route/{routeId}/disapprove")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Disapprove Route", notes = "Disapprove a route", response = Route.class, tags={ "Route", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = Route.class)
    })
    public Response disapproveRoute(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the id of the route to reject", required = true) @PathParam("routeId") @NotNull  Long routeId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.disapproveRoute(version, routeId, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/trip/{id}/drive")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Set Trip Preference Driver", notes = "Update trip preference to drive, also create a route and assign the trip to the route", response = Trip.class, tags={ "Trip", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = Trip.class)
    })
    public Response driveTrip(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the id of the trip", required = true) @PathParam("id") @NotNull  Long id,@ApiParam(value = "the frequency of the trip (e.g. weekly, until 2018-08-09)", required = true) @QueryParam("recurrence") @NotNull  Boolean recurrence,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.driveTrip(version, id, recurrence, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/category/duplicate")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Duplicate Category", notes = "Duplicate a category, including all its children.", response = CategoryTreeResponse.class, tags={ "Category", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = CategoryTreeResponse.class)
    })
    public Response duplicateCategory(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The account id of the user (must have permissions to the target application)", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "The category ID to duplicate (includes all children)", required = true) @QueryParam("categoryId") @NotNull  Long categoryId,@ApiParam(value = "The application to assign the new category to, may be different then the application the source category is assigned to") @QueryParam("appKey")  String appKey,@ApiParam(value = "The parent category ID to add the target category to.") @QueryParam("parentCategoryId")  Long parentCategoryId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.duplicateCategory(version, accountId, categoryId, appKey, parentCategoryId, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/account/profile/update")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Update Account", notes = "Edit the user's profile information", response = ProfileInfoResponse.class, tags={ "Account", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = ProfileInfoResponse.class)
    })
    public Response editAccount(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The device id (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "The account id of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "The account id used to edit another person's account") @QueryParam("connectionAccountId")  Long connectionAccountId,@ApiParam(value = "The account role to change to") @QueryParam("role")  String role,@ApiParam(value = "The asset id to set the user's profile image") @QueryParam("assetId")  Long assetId,@ApiParam(value = "The full name of the user. If this parameter is NOT empty, the  following parameters will be ignored: prefixName, firstName, middleName,  lastName, and suffixName ") @QueryParam("name")  String name,@ApiParam(value = "If the parameter 'name' is empty or not present, this field will be used to set the prefix of the user's name") @QueryParam("prefixName")  String prefixName,@ApiParam(value = "If the parameter 'name' is empty or not present, this field will be used to set the user's first name") @QueryParam("firstName")  String firstName,@ApiParam(value = "If the parameter 'name' is empty or not present, this field will be used to set the user's middle name") @QueryParam("middleName")  String middleName,@ApiParam(value = "If the parameter 'name' is empty or not present, this field will be used to set the user's last name") @QueryParam("lastName")  String lastName,@ApiParam(value = "If the parameter 'name' is empty or not present, this field will be used to set the suffix of the user's name") @QueryParam("suffixName")  String suffixName,@ApiParam(value = "This field will be used to set the user's job title") @QueryParam("title")  String title,@ApiParam(value = "The gender of the user AudienceGender") @QueryParam("gender")  String gender,@ApiParam(value = "This is deperecated, use the birthday parameter") @QueryParam("age")  Integer age,@ApiParam(value = "The birthday date of the user in UTC milliseconds") @QueryParam("birthday")  Long birthday,@ApiParam(value = "The home phone number") @QueryParam("homePhone")  String homePhone,@ApiParam(value = "The cellular phone number") @QueryParam("cellPhone")  String cellPhone,@ApiParam(value = "The cellular service provider") @QueryParam("cellPhoneCarrier")  String cellPhoneCarrier,@ApiParam(value = "The business phone number") @QueryParam("businessPhone")  String businessPhone,@ApiParam(value = "The user's contact email address (NOT the username)") @QueryParam("emailAddress")  String emailAddress,@ApiParam(value = "The street address of the user's contact location") @QueryParam("streetAddress")  String streetAddress,@ApiParam(value = "Additional address information (such as a suite number, floor number, building name, or PO Box)") @QueryParam("streetAddress2")  String streetAddress2,@ApiParam(value = "The city of the user's contact location") @QueryParam("city")  String city,@ApiParam(value = "The state of the user's contact location") @QueryParam("state")  String state,@ApiParam(value = "The zipcode of the user's contact location") @QueryParam("zipcode")  String zipcode,@ApiParam(value = "The country of the user's contact location") @QueryParam("country")  String country,@ApiParam(value = "Allow anyone to view the user's personal profile") @QueryParam("makeProfileInfoPublic")  Boolean makeProfileInfoPublic,@ApiParam(value = "Allow anyone to view the user's game/app info") @QueryParam("makeGameInfoPublic")  Boolean makeGameInfoPublic,@ApiParam(value = "Allow anyone to view the user's friends list") @QueryParam("makeFriendsInfoPublic")  Boolean makeFriendsInfoPublic,@ApiParam(value = "The user's hometown") @QueryParam("hometown")  String hometown,@ApiParam(value = "The user's height") @QueryParam("height")  String height,@ApiParam(value = "The user's height in a numerical value that can be used for ordering/searching") @QueryParam("heightIndex")  Integer heightIndex,@ApiParam(value = "The user's ethnicity") @QueryParam("ethnicity")  String ethnicity,@ApiParam(value = "The user's body type") @QueryParam("bodyType")  String bodyType,@ApiParam(value = "The user's marital status") @QueryParam("maritalStatus")  String maritalStatus,@ApiParam(value = "The user's children status") @QueryParam("children")  String children,@ApiParam(value = "The user's religion") @QueryParam("religion")  String religion,@ApiParam(value = "The user's education") @QueryParam("education")  String education,@ApiParam(value = "The user's education in a numerical value that can be used for ordering/searching") @QueryParam("educationIndex")  Integer educationIndex,@ApiParam(value = "The user's smoke status") @QueryParam("smoke")  String smoke,@ApiParam(value = "The user's drink status") @QueryParam("drink")  String drink,@ApiParam(value = "The user's companionship status") @QueryParam("companionship")  String companionship,@ApiParam(value = "The user's companionship index") @QueryParam("companionshipIndex")  Integer companionshipIndex,@ApiParam(value = "The preferred minimum age in the account location search") @QueryParam("preferredMinAge")  Integer preferredMinAge,@ApiParam(value = "The preferred maximum age in the account location search") @QueryParam("preferredMaxAge")  Integer preferredMaxAge,@ApiParam(value = "The preferred minimum height in the account location search") @QueryParam("preferredMinHeight")  Integer preferredMinHeight,@ApiParam(value = "The preferred maximum height in the account location search") @QueryParam("preferredMaxHeight")  Integer preferredMaxHeight,@ApiParam(value = "The preferred gender in the account location search") @QueryParam("preferredGender")  String preferredGender,@ApiParam(value = "The preferred education in the account location search") @QueryParam("preferredEducation")  String preferredEducation,@ApiParam(value = "The preferred education in a numerical value that can be used for ordering/searching") @QueryParam("preferredEducationIndex")  Integer preferredEducationIndex,@ApiParam(value = "The preferred body type in the account location search") @QueryParam("preferredBodyType")  String preferredBodyType,@ApiParam(value = "The preferred ethnicity in the account location search") @QueryParam("preferredEthnicity")  String preferredEthnicity,@ApiParam(value = "The preferred education in the account location search") @QueryParam("preferredLocation")  String preferredLocation,@ApiParam(value = "The preferred location range in the account location search") @QueryParam("preferredLocationRange")  Double preferredLocationRange,@ApiParam(value = "Platforms") @QueryParam("platforms")  String platforms,@ApiParam(value = "Tags") @QueryParam("tags")  String tags,@ApiParam(value = "About Us") @QueryParam("aboutUs")  String aboutUs,@ApiParam(value = "Match Token") @QueryParam("matchToken")  String matchToken,@ApiParam(value = "Game Experience") @QueryParam("gameExperience")  String gameExperience,@ApiParam(value = "Deprecated use categoryIds") @QueryParam("categories")  String categories,@ApiParam(value = "A list of category ids that represent interests and associations") @QueryParam("categoryIds")  String categoryIds,@ApiParam(value = "A comma separated list of ProfileFilters for filtering the returned response data", defaultValue = "PROFILE,PROFILE_CONTACT") @DefaultValue("PROFILE,PROFILE_CONTACT") @QueryParam("responseFilters")  String responseFilters,@ApiParam(value = "The user's preference if they want to be shown by zipcode on a map") @QueryParam("showAsZipcode")  Boolean showAsZipcode,@ApiParam(value = "The user's preference if they want to be shown by their exact location on a map") @QueryParam("showExactLocation")  Boolean showExactLocation,@ApiParam(value = "The user's preference if they want to see others exact location on a map") @QueryParam("showOthersExactLocation")  Boolean showOthersExactLocation,@ApiParam(value = "Accepted Terms") @QueryParam("acceptedTerms")  Boolean acceptedTerms,@ApiParam(value = "Location Visibility") @QueryParam("locationVisibility")  String locationVisibility,@ApiParam(value = "App Blob") @QueryParam("appBlob")  String appBlob,@ApiParam(value = "App Enable Push") @QueryParam("appEnablePush")  Boolean appEnablePush,@ApiParam(value = "App Enable SMS") @QueryParam("appEnableSMS")  Boolean appEnableSMS,@ApiParam(value = "App Enable Email") @QueryParam("appEnableEmail")  Boolean appEnableEmail,@ApiParam(value = "Game Type") @QueryParam("gameType")  String gameType,@ApiParam(value = "The application key") @QueryParam("appKey")  String appKey,@ApiParam(value = "The current latitude of the user") @QueryParam("latitude")  Double latitude,@ApiParam(value = "The current longitude of the user") @QueryParam("longitude")  Double longitude,@ApiParam(value = "Return Profile") @QueryParam("returnProfile")  Boolean returnProfile,@ApiParam(value = "Audience Ids to add") @QueryParam("audienceIdsToAdd")  String audienceIdsToAdd,@ApiParam(value = "Audience Ids to remove") @QueryParam("audienceIdsToRemove")  String audienceIdsToRemove,@ApiParam(value = "The account id of the referrer") @QueryParam("referralAccountId")  Long referralAccountId,@ApiParam(value = "App nickname") @QueryParam("appNickname")  String appNickname,@ApiParam(value = "Personal Audience") @QueryParam("personalAudienceId")  Long personalAudienceId,@ApiParam(value = "The user's username to update with if they currently have a guest username") @QueryParam("nonGuestUsername")  String nonGuestUsername,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.editAccount(version, deviceId, accountId, connectionAccountId, role, assetId, name, prefixName, firstName, middleName, lastName, suffixName, title, gender, age, birthday, homePhone, cellPhone, cellPhoneCarrier, businessPhone, emailAddress, streetAddress, streetAddress2, city, state, zipcode, country, makeProfileInfoPublic, makeGameInfoPublic, makeFriendsInfoPublic, hometown, height, heightIndex, ethnicity, bodyType, maritalStatus, children, religion, education, educationIndex, smoke, drink, companionship, companionshipIndex, preferredMinAge, preferredMaxAge, preferredMinHeight, preferredMaxHeight, preferredGender, preferredEducation, preferredEducationIndex, preferredBodyType, preferredEthnicity, preferredLocation, preferredLocationRange, platforms, tags, aboutUs, matchToken, gameExperience, categories, categoryIds, responseFilters, showAsZipcode, showExactLocation, showOthersExactLocation, acceptedTerms, locationVisibility, appBlob, appEnablePush, appEnableSMS, appEnableEmail, gameType, appKey, latitude, longitude, returnProfile, audienceIdsToAdd, audienceIdsToRemove, referralAccountId, appNickname, personalAudienceId, nonGuestUsername, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/account/username/update")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Update Username and Email", notes = "Update account's own username and/or emailAddress", response = SirqulResponse.class, tags={ "Account", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response editUsername(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The device id") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "The account id of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "the user's contact email address (NOT the username) which is also used for email validation") @QueryParam("emailAddress")  String emailAddress,@ApiParam(value = "the user's username to update with if they currently have a guest username") @QueryParam("username")  String username,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.editUsername(version, deviceId, accountId, emailAddress, username, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/orson/ai/emotion")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Detect emotions", notes = "Detects emotions in an audio or video recording.", response = OrsonAiEmotionsResponse.class, tags={ "Orson", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = OrsonAiEmotionsResponse.class)
    })
    public Response emotion(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "Sirqul Account Id", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "A third-party account id that is meaningful to your systems") @QueryParam("thirdPartyAccountId")  String thirdPartyAccountId,@ApiParam(value = "An uploaded recording to analyze (Currently limited to 10MB)") @QueryParam("file")  File _file,@ApiParam(value = "A recording file to download and analyze (Size limit: 1GB)") @QueryParam("url")  String url,@ApiParam(value = "When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open") @QueryParam("callback")  String paramCallback,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.emotion(version, accountId, thirdPartyAccountId, _file, url, paramCallback, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/invite/event")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Invite to Event", notes = "Allows a user to invite people to attend an event. This will generate an invite token, which when used, will allow the invitee to add the offer to their wallet.", response = InviteResponse.class, tags={ "Invite", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = InviteResponse.class)
    })
    public Response eventInvite(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the account ID of the user making the share", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "the application key", required = true) @QueryParam("appKey") @NotNull  String appKey,@ApiParam(value = "The ID of the event listing", required = true) @QueryParam("listingId") @NotNull  Long listingId,@ApiParam(value = "the account ID of a Sirqul user they would like to share an event with") @QueryParam("receiverAccountIds")  String receiverAccountIds,@ApiParam(value = "The retailer location id of where the event will take place") @QueryParam("retailerLocationId")  Long retailerLocationId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.eventInvite(version, accountId, appKey, listingId, receiverAccountIds, retailerLocationId, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/vatom/vatoms/execute-action")
    
    
    @io.swagger.annotations.ApiOperation(value = "Execute Action on NFT", notes = "Execute Action on NFT.", response = Void.class, tags={ "Vatom", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = Void.class)
    })
    public Response executeActionOnNFT(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "Sirqul Account Id", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "Vatom NFT Id", required = true) @QueryParam("vatomId") @NotNull  String vatomId,@ApiParam(value = "Vatom Parameters", required = true) @QueryParam("vatomParameters") @NotNull  String vatomParameters,@ApiParam(value = "Return raw response") @QueryParam("returnRawResponse")  Boolean returnRawResponse,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.executeActionOnNFT(version, accountId, vatomId, vatomParameters, returnRawResponse, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/analytics/filteredUsage")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Get Filtered Usage", notes = "Query analytics to get data used for graphs and charts", response = ChartData.class, tags={ "Analytics", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = ChartData.class)
    })
    public Response filteredUsage(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The unique id of the device making the request (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "The account id of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "This parameter is deprecated.") @QueryParam("applicationId")  Long applicationId,@ApiParam(value = "The application key used to filter results by application") @QueryParam("appKey")  String appKey,@ApiParam(value = "Used to search for results after or equal to this date (UNIX time-stamp in milliseconds)") @QueryParam("startDate")  Long startDate,@ApiParam(value = "Used to search for results before or equal to this date (UNIX time-stamp in milliseconds)") @QueryParam("endDate")  Long endDate,@ApiParam(value = "The device type to filter results by (performs a LIKE search)") @QueryParam("deviceType")  String deviceType,@ApiParam(value = "The device to filter results by (performs a LIKE search)") @QueryParam("device")  String device,@ApiParam(value = "The device OS to filter results by (performs a LIKE search)") @QueryParam("deviceOS")  String deviceOS,@ApiParam(value = "The gender to filter results by {MALE, FEMALE}") @QueryParam("gender")  String gender,@ApiParam(value = "Comma separated list of age groups to filter by {AGE_0_13, AGE_14_17, AGE_18_22, AGE_23_30, AGE_31_54, AGE_55_PLUS}") @QueryParam("ageGroup")  String ageGroup,@ApiParam(value = "The country to filter results by (performs a wild-card search)") @QueryParam("country")  String country,@ApiParam(value = "The state to filter results by (performs a wild-card search)") @QueryParam("state")  String state,@ApiParam(value = "The city to filter results by (performs a wild-card search)") @QueryParam("city")  String city,@ApiParam(value = "The zip to filter results by (performs a wild-card search)") @QueryParam("zip")  String zip,@ApiParam(value = "The model to filter results by (performs a wild-card search)") @QueryParam("model")  String model,@ApiParam(value = "The tag to filter results by (performs a wild-card search)") @QueryParam("tag")  String tag,@ApiParam(value = "The account id to filter results for a particular user") @QueryParam("userAccountId")  Long userAccountId,@ApiParam(value = "The user display to filter results by (performs a wild-card search)") @QueryParam("userAccountDisplay")  String userAccountDisplay,@ApiParam(value = "The username to filter results by (performs a wild-card search)") @QueryParam("userAccountUsername")  String userAccountUsername,@ApiParam(value = "The ID for the custom table column") @QueryParam("customId")  Long customId,@ApiParam(value = "The type defined for the custom table column") @QueryParam("customType")  String customType,@ApiParam(value = "The value for the custom table column") @QueryParam("customValue")  Double customValue,@ApiParam(value = "The value for another custom table column") @QueryParam("customValue2")  Double customValue2,@ApiParam(value = "The value that supports Longs for custom table column") @QueryParam("customLong")  Long customLong,@ApiParam(value = "The value that supports Longs for custom table column") @QueryParam("customLong2")  Long customLong2,@ApiParam(value = "The message for the custom table column") @QueryParam("customMessage")  String customMessage,@ApiParam(value = "The message for the custom table column") @QueryParam("customMessage2")  String customMessage2,@ApiParam(value = "Determines how to group results. For example, passing in 'CREATED' will return results by date. Passing in 'ACCOUNT' will return results by user {TAG, CUSTOM_ID, TOKEN, MODEL, DEVICE_TYPE, DEVICE, DEVICE_OS, DEVICE_ID, IP_ADDRESS, STATE, CITY, ZIP, COUNTRY, ACCOUNT, APPLICATION_ID}", allowableValues="TAG_COUNT, TAG, TOKEN, MODEL, DEVICE_TYPE, DEVICE, DEVICE_OS, DEVICE_ID, IP_ADDRESS, STATE, CITY, ZIP, COUNTRY, CREATED, UPDATED, LAST_UPDATED, CLIENT_TIME, ACTIVE, CUSTOM_ID, CUSTOM_TYPE, CUSTOM_VALUE, CUSTOM_VALUE2, CUSTOM_LONG, CUSTOM_LONG2, CUSTOM_MESSAGE, CUSTOM_MESSAGE2, ACCOUNT_ID, ACCOUNT_USERNAME, ACCOUNT_DISPLAY, ACCOUNT_CREATED, ACCOUNT_GENDER, ACCOUNT_AGE_GROUP, APPLICATION_ID, APPLICATION_KEY, APPLICATION_NAME") @QueryParam("groupBy")  String groupBy,@ApiParam(value = "Performs a unique query on the specified column. For example, passing in 'ACCOUNT' will return the number of unique users. {TAG, CUSTOM_ID, TOKEN, MODEL, DEVICE_TYPE, DEVICE, DEVICE_OS, DEVICE_ID, IP_ADDRESS, STATE, CITY, ZIP, COUNTRY, ACCOUNT, APPLICATION_ID}", allowableValues="TAG_COUNT, TAG, TOKEN, MODEL, DEVICE_TYPE, DEVICE, DEVICE_OS, DEVICE_ID, IP_ADDRESS, STATE, CITY, ZIP, COUNTRY, CREATED, UPDATED, LAST_UPDATED, CLIENT_TIME, ACTIVE, CUSTOM_ID, CUSTOM_TYPE, CUSTOM_VALUE, CUSTOM_VALUE2, CUSTOM_LONG, CUSTOM_LONG2, CUSTOM_MESSAGE, CUSTOM_MESSAGE2, ACCOUNT_ID, ACCOUNT_USERNAME, ACCOUNT_DISPLAY, ACCOUNT_CREATED, ACCOUNT_GENDER, ACCOUNT_AGE_GROUP, APPLICATION_ID, APPLICATION_KEY, APPLICATION_NAME") @QueryParam("distinctCount")  String distinctCount,@ApiParam(value = "sum of the column values", allowableValues="TAG_COUNT, TAG, TOKEN, MODEL, DEVICE_TYPE, DEVICE, DEVICE_OS, DEVICE_ID, IP_ADDRESS, STATE, CITY, ZIP, COUNTRY, CREATED, UPDATED, LAST_UPDATED, CLIENT_TIME, ACTIVE, CUSTOM_ID, CUSTOM_TYPE, CUSTOM_VALUE, CUSTOM_VALUE2, CUSTOM_LONG, CUSTOM_LONG2, CUSTOM_MESSAGE, CUSTOM_MESSAGE2, ACCOUNT_ID, ACCOUNT_USERNAME, ACCOUNT_DISPLAY, ACCOUNT_CREATED, ACCOUNT_GENDER, ACCOUNT_AGE_GROUP, APPLICATION_ID, APPLICATION_KEY, APPLICATION_NAME") @QueryParam("sumColumn")  String sumColumn,@ApiParam(value = "Determines whether the results will be sorted by day or by number of hits {CREATED, TAG_COUNT}", allowableValues="TAG_COUNT, TAG, TOKEN, MODEL, DEVICE_TYPE, DEVICE, DEVICE_OS, DEVICE_ID, IP_ADDRESS, STATE, CITY, ZIP, COUNTRY, CREATED, UPDATED, LAST_UPDATED, CLIENT_TIME, ACTIVE, CUSTOM_ID, CUSTOM_TYPE, CUSTOM_VALUE, CUSTOM_VALUE2, CUSTOM_LONG, CUSTOM_LONG2, CUSTOM_MESSAGE, CUSTOM_MESSAGE2, ACCOUNT_ID, ACCOUNT_USERNAME, ACCOUNT_DISPLAY, ACCOUNT_CREATED, ACCOUNT_GENDER, ACCOUNT_AGE_GROUP, APPLICATION_ID, APPLICATION_KEY, APPLICATION_NAME") @QueryParam("sortField")  String sortField,@ApiParam(value = "Determines whether to return results in descending order") @QueryParam("descending")  Boolean descending,@ApiParam(value = "Determines whether to return data that has empty or unknown values") @QueryParam("hideUnknown")  Boolean hideUnknown,@ApiParam(value = "Determines whether to return a JOSN or XML representation of the graph results", allowableValues="HTML, XML, JSON, CSV") @QueryParam("responseFormat")  String responseFormat,@ApiParam(value = "This parameter is deprecated.") @QueryParam("_l")  Integer l,@ApiParam(value = "Used to limit results to get a cleaner graph. The results that gets filtered out will be combined") @QueryParam("limit")  Integer limit,@ApiParam(value = "the current latitude of the user") @QueryParam("latitude")  Double latitude,@ApiParam(value = "the current longitude of the user") @QueryParam("longitude")  Double longitude,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.filteredUsage(version, deviceId, accountId, applicationId, appKey, startDate, endDate, deviceType, device, deviceOS, gender, ageGroup, country, state, city, zip, model, tag, userAccountId, userAccountDisplay, userAccountUsername, customId, customType, customValue, customValue2, customLong, customLong2, customMessage, customMessage2, groupBy, distinctCount, sumColumn, sortField, descending, hideUnknown, responseFormat, l, limit, latitude, longitude, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/mission/find")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Find Missions", notes = "Get a set of ad filtered by the parameters provided.", response = MissionResponse.class, tags={ "Mission", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = MissionResponse.class)
    })
    public Response findMissions(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The application key, if provided return missions specific for the app. Will always return mission levels that are app agnostic.", required = true) @QueryParam("appKey") @NotNull  String appKey,@ApiParam(value = "The type of mission to get, possible values are: click_banner, click_leaderboard, click_skyscraper, click_full, click_video, or click_zip") @QueryParam("suffix")  String suffix,@ApiParam(value = "The type of ads to get, possible values are: BANNER, LEADERBOARD, SKYSCRAPER, FULL, VIDEO, ZIP, CONFIG. Use this instead of suffix.") @QueryParam("type")  String type,@ApiParam(value = "The logged in user.") @QueryParam("accountId")  Long accountId,@ApiParam(value = "The version of the application, will not return levels newer than the appVersion.") @QueryParam("appVersion")  String appVersion,@ApiParam(value = "The current location of the requesting device") @QueryParam("latitude")  Double latitude,@ApiParam(value = "The current location of the requesting device") @QueryParam("longitude")  Double longitude,@ApiParam(value = "Should use deviceId if possible. The name of the requesting device; possible values are: Android, iPhone, iPad, iPod, etc. use /audience/devices for list.") @QueryParam("device")  String device,@ApiParam(value = "The device ID of the requesting device, use /audience/devices for list") @QueryParam("deviceIdentifier")  Long deviceIdentifier,@ApiParam(value = "The requesting device version; examples are: 2.3, 5.1.4, 6.1.4. Supports X, X.X, or X.X.X formated string.") @QueryParam("deviceVersion")  String deviceVersion,@ApiParam(value = "The index into the record set to start with.") @QueryParam("start")  Integer start,@ApiParam(value = "The total number of record to return.") @QueryParam("limit")  Integer limit,@ApiParam(value = "Include the game level data with the mission.") @QueryParam("includeGameData")  Boolean includeGameData,@ApiParam(value = "If true then return the audience data in the response. Default is false.") @QueryParam("includeAudiences")  Boolean includeAudiences,@ApiParam(value = "If true/false only return missions whose game levels allocate (or don't allocate) tickets. Do not provide a value to return both.") @QueryParam("allocatesTickets")  Boolean allocatesTickets,@ApiParam(value = "return a random set of results, default is true. If false returns in natural order.") @QueryParam("randomize")  Boolean randomize,@ApiParam(value = "return only ads targeted to the specific app, no global ads.") @QueryParam("targetedAdsOnly")  Boolean targetedAdsOnly,@ApiParam(value = "return only ads from the specified campaigns.") @QueryParam("missionIds")  String missionIds,@ApiParam(value = "will return the items that have at least 1 or all of their audiences exist in the logged in users audiences, depending if the value is OR or AND") @QueryParam("audienceOperator")  String audienceOperator,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.findMissions(version, appKey, suffix, type, accountId, appVersion, latitude, longitude, device, deviceIdentifier, deviceVersion, start, limit, includeGameData, includeAudiences, allocatesTickets, randomize, targetedAdsOnly, missionIds, audienceOperator, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/trip/{id}/flexible")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Set Trip Preference Flexible", notes = "Update trip preference to flexible.", response = Trip.class, tags={ "Trip", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = Trip.class)
    })
    public Response flexibleTrip(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the id of the trip", required = true) @PathParam("id") @NotNull  Long id,@ApiParam(value = "the frequency of the trip (e.g. weekly, until 2018-08-09)", required = true) @QueryParam("recurrence") @NotNull  Boolean recurrence,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.flexibleTrip(version, id, recurrence, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/consumer/follow/accept")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Accept Follow Request", notes = "Accept someone's follow request.", response = SirqulResponse.class, tags={ "Connection", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response followAccept(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the account id of the user", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "the account ID of the user who initiated the follow", required = true) @QueryParam("connectionAccountId") @NotNull  Long connectionAccountId,@ApiParam(value = "the application key for sending notifications", required = true) @QueryParam("appKey") @NotNull  String appKey,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.followAccept(version, accountId, connectionAccountId, appKey, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/consumer/follow/reject")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Reject Follow Request", notes = "Reject someone's follow request or remove them as a follower.", response = SirqulResponse.class, tags={ "Connection", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response followReject(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the account id of the user", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "the account ID of the user who initiated the follow", required = true) @QueryParam("connectionAccountId") @NotNull  Long connectionAccountId,@ApiParam(value = "the application key for sending notifications", required = true) @QueryParam("appKey") @NotNull  String appKey,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.followReject(version, accountId, connectionAccountId, appKey, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/consumer/follow/remove")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Remove Follower / Unfollow", notes = "Unfollow someone you are following or remove them as a follower.", response = SirqulResponse.class, tags={ "Connection", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response followRemove(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the account id of the user", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "the account ID of the user who you want to unfollow", required = true) @QueryParam("connectionAccountId") @NotNull  Long connectionAccountId,@ApiParam(value = "the application key for sending notifications", required = true) @QueryParam("appKey") @NotNull  String appKey,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.followRemove(version, accountId, connectionAccountId, appKey, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/consumer/follow/request")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Send Follow Request", notes = "Send a request to follow someone.", response = SirqulResponse.class, tags={ "Connection", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response followRequest(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the account id of the user", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "the account ID of the user who you want to follow", required = true) @QueryParam("connectionAccountId") @NotNull  Long connectionAccountId,@ApiParam(value = "the application key for sending notifications", required = true) @QueryParam("appKey") @NotNull  String appKey,@ApiParam(value = "determines if the other user needs to confirm the follow request", defaultValue = "true") @DefaultValue("true") @QueryParam("approvalNeeded")  Boolean approvalNeeded,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.followRequest(version, accountId, connectionAccountId, appKey, approvalNeeded, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/consumer/friend/accept")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Accept Friend", notes = "Accept a friend request and optionally sends a notification.", response = SirqulResponse.class, tags={ "Connection", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response friendAccept(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the friend's account id", required = true) @QueryParam("friendAccountId") @NotNull  Long friendAccountId,@ApiParam(value = "determines whether to send a notification to the afflicting party", required = true) @QueryParam("notifyFriend") @NotNull  Boolean notifyFriend,@ApiParam(value = "the device id (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "the account id of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "This parameter is deprecated.") @QueryParam("gameType")  String gameType,@ApiParam(value = "the application key") @QueryParam("appKey")  String appKey,@ApiParam(value = "optional message to send in a notification") @QueryParam("notificationMessage")  String notificationMessage,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.friendAccept(version, friendAccountId, notifyFriend, deviceId, accountId, gameType, appKey, notificationMessage, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/consumer/friend/reject")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Decline Friend", notes = "Request a friend request and optionally sends a notification.", response = SirqulResponse.class, tags={ "Connection", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response friendReject(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the friend's account id", required = true) @QueryParam("friendAccountId") @NotNull  Long friendAccountId,@ApiParam(value = "the device id (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "the account id of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "This parameter is deprecated.") @QueryParam("gameType")  String gameType,@ApiParam(value = "the application key") @QueryParam("appKey")  String appKey,@ApiParam(value = "determines whether to send a notification to the afflicting party") @QueryParam("notifyFriend")  Boolean notifyFriend,@ApiParam(value = "optional message to send in a notification") @QueryParam("notificationMessage")  String notificationMessage,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.friendReject(version, friendAccountId, deviceId, accountId, gameType, appKey, notifyFriend, notificationMessage, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/consumer/friend/remove")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Delete Friend", notes = "Removes a friend from the user's friends list.", response = SirqulResponse.class, tags={ "Connection", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response friendRemove(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the account ID of the friend to remove", required = true) @QueryParam("friendAccountId") @NotNull  Long friendAccountId,@ApiParam(value = "the device id (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "the account id of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "optionally notifies the connection that they have been removed as a friend") @QueryParam("notifyFriend")  Boolean notifyFriend,@ApiParam(value = "optionally removes the connection from the user's groups") @QueryParam("removeFromGroups")  Boolean removeFromGroups,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.friendRemove(version, friendAccountId, deviceId, accountId, notifyFriend, removeFromGroups, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/consumer/friend/request")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Request Friend", notes = "Sends a friend request notification to another user.", response = SirqulResponse.class, tags={ "Connection", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response friendRequest(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the friend's account id", required = true) @QueryParam("friendAccountId") @NotNull  Long friendAccountId,@ApiParam(value = "the device id (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "the account id of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "This parameter is deprecated.") @QueryParam("gameType")  String gameType,@ApiParam(value = "the application key") @QueryParam("appKey")  String appKey,@ApiParam(value = "optional message to send in a notification") @QueryParam("notificationMessage")  String notificationMessage,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.friendRequest(version, friendAccountId, deviceId, accountId, gameType, appKey, notificationMessage, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/invite/gameLevel")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Invite to Game Level", notes = "Allows a user to invite people to gain access to an album. This will generate an invite token, which when used, will give the invitee access to an album (whether it is private or not). The invitee will also become the user's friend when the invitation is accepted.", response = InviteResponse.class, tags={ "Invite", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = InviteResponse.class)
    })
    public Response gameInvite(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "a unique ID given by the device (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "the account ID of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "This parameter is deprecated.") @QueryParam("appId")  Long appId,@ApiParam(value = "the application key") @QueryParam("appKey")  String appKey,@ApiParam(value = "the game level that the user owns and is giving access to") @QueryParam("gameLevelId")  Long gameLevelId,@ApiParam(value = "the current latitude of the user") @QueryParam("latitude")  Double latitude,@ApiParam(value = "the current longitude of the user") @QueryParam("longitude")  Double longitude,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.gameInvite(version, deviceId, accountId, appId, appKey, gameLevelId, latitude, longitude, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/vatom/vatoms/geo-map/search")
    
    
    @io.swagger.annotations.ApiOperation(value = "Search Vatom Geo Map", notes = "Search Vatom Geo Map", response = Void.class, tags={ "Vatom", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = Void.class)
    })
    public Response geomapSearch(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "Sirqul Account Id", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "Vatom Parameters", required = true) @QueryParam("vatomParameters") @NotNull  String vatomParameters,@ApiParam(value = "Return raw response") @QueryParam("returnRawResponse")  Boolean returnRawResponse,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.geomapSearch(version, accountId, vatomParameters, returnRawResponse, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/account/profile/get")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Get Account", notes = "Gets a user's account profile. Application settings and account settings will also be returned for the owner of the account.", response = ProfileResponse.class, tags={ "Account", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = ProfileResponse.class)
    })
    public Response getAccount(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "Return Nulls", defaultValue = "false") @DefaultValue("false") @QueryParam("returnNulls")  Boolean returnNulls,@ApiParam(value = "The device id (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "The account id of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "Connection Account Email") @QueryParam("connectionAccountEmail")  String connectionAccountEmail,@ApiParam(value = "The account id used to view another person's account", defaultValue = "0") @DefaultValue("0") @QueryParam("connectionAccountId")  Long connectionAccountId,@ApiParam(value = "A comma separated list of ProfileFilters for filtering the returned response data", defaultValue = "PROFILE") @DefaultValue("PROFILE") @QueryParam("responseFilters")  String responseFilters,@ApiParam(value = "Game Type") @QueryParam("gameType")  String gameType,@ApiParam(value = "The application key") @QueryParam("appKey")  String appKey,@ApiParam(value = "Purchase Type", defaultValue = "SIRQUL") @DefaultValue("SIRQUL") @QueryParam("purchaseType")  String purchaseType,@ApiParam(value = "Determines whether to track if a person has viewed someone's profile", defaultValue = "false") @DefaultValue("false") @QueryParam("updateViewedDate")  Boolean updateViewedDate,@ApiParam(value = "Latitude used to update the user's current location") @QueryParam("latitude")  Double latitude,@ApiParam(value = "Longitude used to update the user's current location") @QueryParam("longitude")  Double longitude,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getAccount(version, returnNulls, deviceId, accountId, connectionAccountEmail, connectionAccountId, responseFilters, gameType, appKey, purchaseType, updateViewedDate, latitude, longitude, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/achievement/get")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Get Achievement", notes = "Get an achievement (for developer/retailer use). User must have permissions to the application the achievement is created for.", response = AchievementTierResponse.class, tags={ "Achievement", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = AchievementTierResponse.class)
    })
    public Response getAchievement(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The ID of the achievement", required = true) @QueryParam("achievementId") @NotNull  Long achievementId,@ApiParam(value = "a unique id given by the device (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "the account id of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "achievementType") @QueryParam("achievementType")  String achievementType,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getAchievement(version, achievementId, deviceId, accountId, achievementType, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/achievement/tier/get")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Gets an achievement tier", notes = "Gets an achievement tier (for developer/retailer use). User must have permissions to the application the achievement is created for.", response = AchievementTierResponse.class, tags={ "Achievement", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = AchievementTierResponse.class)
    })
    public Response getAchievementTier(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the account id of the user (deviceId or accountId required)", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "the achievement tier id that is being retrieved", required = true) @QueryParam("achievementTierId") @NotNull  Long achievementTierId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getAchievementTier(version, accountId, achievementTierId, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/orson/ai/addMovie/{requestId}")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Get Add Movie Result", notes = "Get the result of an in progress Add Movie request from an earlier POST.", response = OrsonAiAddMovieResponse.class, tags={ "Orson", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = OrsonAiAddMovieResponse.class)
    })
    public Response getAddMovieResult(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "Orson Request Id", required = true) @PathParam("requestId") @NotNull  String requestId,@ApiParam(value = "Sirqul Account Id", required = true) @QueryParam("accountId") @NotNull  Long accountId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getAddMovieResult(version, requestId, accountId, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/audience/ageGroups")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Get Age Groups", notes = "Gets the list of available age groups that can be selected by consumers and retailers targeting offers.", response = AgeGroupResponse.class, responseContainer = "List", tags={ "Audience", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = AgeGroupResponse.class, responseContainer = "List")
    })
    public Response getAgeGroups(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getAgeGroups(version, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/album/get")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = " Get Album", notes = "Get an Album.", response = AlbumFullResponse.class, tags={ "Album", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = AlbumFullResponse.class)
    })
    public Response getAlbumCollection(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "This parameter is deprecated.", required = true) @QueryParam("returnNulls") @NotNull  Boolean returnNulls,@ApiParam(value = "the album to look up", required = true) @QueryParam("albumId") @NotNull  Long albumId,@ApiParam(value = "a unique ID given by the device (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "the account ID of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "returns the last X likes. To search on and paginate the remaining likes - please use the \"/like/search\" endpoint.") @QueryParam("likePreviewSize")  Integer likePreviewSize,@ApiParam(value = "returns the first X assets. To search on and paginate the remaining assets - please use the \"/assets/search\" endpoint.") @QueryParam("assetPreviewSize")  Integer assetPreviewSize,@ApiParam(value = "returns the last X notes. To search on and paginate the remaining notes - please use the \"/note/search\" endpoint.") @QueryParam("notePreviewSize")  Integer notePreviewSize,@ApiParam(value = "returns the first X users/connections. To search on and paginate the remaining connections - please use the \"/permissions/search\" endpoint.") @QueryParam("connectionPreviewSize")  Integer connectionPreviewSize,@ApiParam(value = "returns the first X audiences. To search on and paginate the remaining audiences - please use the \"/audience/search\" endpoint.") @QueryParam("audiencePreviewSize")  Integer audiencePreviewSize,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getAlbumCollection(version, returnNulls, albumId, deviceId, accountId, likePreviewSize, assetPreviewSize, notePreviewSize, connectionPreviewSize, audiencePreviewSize, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/consumer/album/contest/get")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Get Contest", notes = "Gets the contest object including the likes and notes", response = AlbumContestResponse.class, tags={ "Contest", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = AlbumContestResponse.class)
    })
    public Response getAlbumContest(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the album contest ID", required = true) @QueryParam("albumContestId") @NotNull  Long albumContestId,@ApiParam(value = "a unique ID given by the device (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "the account ID of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "latitude used to update the user's current location") @QueryParam("latitude")  Double latitude,@ApiParam(value = "longitude used to update the user's current location") @QueryParam("longitude")  Double longitude,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getAlbumContest(version, albumContestId, deviceId, accountId, latitude, longitude, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/consumer/album/contest/search")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Search Contests", notes = "Searches on contests.", response = AlbumContestListResponse.class, tags={ "Contest", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = AlbumContestListResponse.class)
    })
    public Response getAlbumContests(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "a comma separated list of Ownership", required = true) @QueryParam("filter") @NotNull  String filter,@ApiParam(value = "the field to sort by. See AlbumContestApiMap", required = true) @QueryParam("sortField") @NotNull  String sortField,@ApiParam(value = "determines whether the sorted list is in descending or ascending order", required = true) @QueryParam("descending") @NotNull  Boolean descending,@ApiParam(value = "the start index for pagination", required = true) @QueryParam("start") @NotNull  Integer start,@ApiParam(value = "the limit for pagination (there is a hard limit of 30)", required = true) @QueryParam("limit") @NotNull  Integer limit,@ApiParam(value = "a unique ID given by the device (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "the account ID of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "This parameter is deprecated.") @QueryParam("gameType")  String gameType,@ApiParam(value = "the application key") @QueryParam("appKey")  String appKey,@ApiParam(value = "the application type") @QueryParam("appType")  String appType,@ApiParam(value = "filter contests with this contest type") @QueryParam("contestType")  String contestType,@ApiParam(value = "search on contests that have been created by this account (that the user has permissions to)") @QueryParam("ownerId")  Long ownerId,@ApiParam(value = "This parameter is deprecated.") @QueryParam("q")  String q,@ApiParam(value = "keyword search string") @QueryParam("keyword")  String keyword,@ApiParam(value = "This parameter is deprecated.") @QueryParam("_i")  Integer i,@ApiParam(value = "This parameter is deprecated.") @QueryParam("_l")  Integer l,@ApiParam(value = "filter on items that have been created before this date") @QueryParam("dateCreated")  Long dateCreated,@ApiParam(value = "latitude used to update the user's current location") @QueryParam("latitude")  Double latitude,@ApiParam(value = "longitude used to update the user's current location") @QueryParam("longitude")  Double longitude,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getAlbumContests(version, filter, sortField, descending, start, limit, deviceId, accountId, gameType, appKey, appType, contestType, ownerId, q, keyword, i, l, dateCreated, latitude, longitude, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/app/get")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Get App Data", notes = "Get the application data structure.  The basic structure is a   node tree, with the root node being a AppResponse.  The response contains   the user's profile, messages from the system, and a list of MissionResponse.    A mission can have any number of GameResponses but typically is a single   game type.  A game then has any number of PackResponses which help group   the game levels. Packs are then composed of any number of GameLevelResponses.     Using the various parameters can return the applications default mission   (built-in packs to play), the list of community levels published, the user's   saved levels, or explicity levels desired.  You can choose to include the   profile or not, or just return parts of the profile.  You can also filter   out game levels that have been published with a higher version of the application.", response = AppResponse.class, tags={ "AppData", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = AppResponse.class)
    })
    public Response getAppData(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "start the search results at a record.", required = true) @QueryParam("start") @NotNull  Integer start,@ApiParam(value = "limit the search results to some number.", required = true) @QueryParam("limit") @NotNull  Integer limit,@ApiParam(value = "the device id (deviceId or accountId required).") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "the account id of the user (deviceId or accountId required).") @QueryParam("accountId")  Long accountId,@ApiParam(value = "the game to retrieve the data for, use your application key.") @QueryParam("gameType")  String gameType,@ApiParam(value = "if true then include the game data blob, otherwise don't include.") @QueryParam("includeGameData")  Boolean includeGameData,@ApiParam(value = "This parameter is deprecated.") @QueryParam("q")  String q,@ApiParam(value = "query string used to filter the search results when looking for community and saved levels.") @QueryParam("keyword")  String keyword,@ApiParam(value = "how to sort the results when looking for community and saved levels. possible values are: LEVEL_NAME, LEVEL_CREATED, LEVEL_UPDATED, LEVEL_LIKES, LEVEL_DISLIKES, LEVEL_NOTES, LEVEL_PLAYS.") @QueryParam("sortField")  String sortField,@ApiParam(value = "order the search results descending or ascending when looking for community and saved levels.") @QueryParam("descending")  Boolean descending,@ApiParam(value = "This parameter is deprecated.") @QueryParam("_i")  Integer i,@ApiParam(value = "This parameter is deprecated.") @QueryParam("_l")  Integer l,@ApiParam(value = "if true then include the game object count, otherwise don't include.") @QueryParam("gameObjectCount")  Boolean gameObjectCount,@ApiParam(value = "restrict the search to items with certain permissions, possible values are: MINE, FRIENDS, PUBLIC, ALL_PUBLIC, ALL, LIKED") @QueryParam("filter")  String filter,@ApiParam(value = "restrict the search to items created less then date") @QueryParam("dateCreated")  Long dateCreated,@ApiParam(value = "get levels owned by a particular account") @QueryParam("ownerId")  Long ownerId,@ApiParam(value = "get missions by specified id, comman seperated list of long ids") @QueryParam("missionIds")  String missionIds,@ApiParam(value = "get games by specified id, comman seperated list of long ids") @QueryParam("gameIds")  String gameIds,@ApiParam(value = "get packs by specified id, comman seperated list of long ids") @QueryParam("packIds")  String packIds,@ApiParam(value = "get game levels by specified id, comman seperated list of long ids") @QueryParam("gameLevelIds")  String gameLevelIds,@ApiParam(value = "the application version, used to versin the game level data") @QueryParam("appVersion")  String appVersion,@ApiParam(value = "default is false and will not include any packs that have levels above the specified appVersion. If true then will return all levels regardless of version.") @QueryParam("includeHigherVersionPacks")  Boolean includeHigherVersionPacks,@ApiParam(value = "default is false and will not include any levels above the specified appVersion. If true then will return all levels regardless of version.") @QueryParam("includeHigherVersionLevels")  Boolean includeHigherVersionLevels,@ApiParam(value = "use response groups to include large parts of the structure. possible values are: * MISSION_DEFAULT (default) - include the default mission (built-in packs), excludes all other mission groups * MISSION_DEFAULT_LEVELS_SAVED - include saved levels, excludes all other mission groups * MISSION_DEFAULT_LEVELS_COMMUNITY - include community levels, excludes all other mission groups * MISSION_INVITED (default) - include challenges sent to user * PROFILE (default) - include entire profile * PROFILE_DATA - only include profile date (exclude friends) * PROFILE_FRIENDS - include friends list ") @QueryParam("responseGroups")  String responseGroups,@ApiParam(value = "the will return the correct in app purchases for the device, possible values are: * SIRQUL (default) - purchasing from the sirqul store using tickets * IOS - purchasing from the itunes store for iPhone, iPod, iPod Touch * GOOGLE - purchasing from the google android store * AMAZON - purchasing from the amazon android store * MAC - purchasing from the itunes store for OSX * FREE - the item is free to purchase ") @QueryParam("purchaseType")  String purchaseType,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getAppData(version, start, limit, deviceId, accountId, gameType, includeGameData, q, keyword, sortField, descending, i, l, gameObjectCount, filter, dateCreated, ownerId, missionIds, gameIds, packIds, gameLevelIds, appVersion, includeHigherVersionPacks, includeHigherVersionLevels, responseGroups, purchaseType, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/application/get")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Get Application", notes = "Get a specific application by appKey", response = ApplicationResponse.class, tags={ "Application", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = ApplicationResponse.class)
    })
    public Response getApplication(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The key of the application") @QueryParam("appKey")  String appKey,@ApiParam(value = "Application Id") @QueryParam("applicationId")  Long applicationId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getApplication(version, appKey, applicationId, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/appconfig/get")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Get AppConfig", notes = "Gets the appConfig data by the given configId. If appConfig cannot be found, it returns an invalid response.", response = ApplicationConfigResponse.class, tags={ "Application Config", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = ApplicationConfigResponse.class)
    })
    public Response getApplicationConfig(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The account ID of the user", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "The config ID of the application configuration", required = true) @QueryParam("configId") @NotNull  Long configId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getApplicationConfig(version, accountId, configId, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/appconfig/getbyversion")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Get AppConfig by Version", notes = "Gets the appConfig data by the given appKey and app configVersion number.If the appKey is is invalid or appConfig is not found, it returns an invalid response. ", response = ApplicationConfigResponse.class, tags={ "Application Config", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = ApplicationConfigResponse.class)
    })
    public Response getApplicationConfigByConfigVersion(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The application key", required = true) @QueryParam("appKey") @NotNull  String appKey,@ApiParam(value = "The version of the application configuration", required = true) @QueryParam("configVersion") @NotNull  String configVersion,@ApiParam(value = "Only returns the config that matches the given retailer") @QueryParam("retailerId")  Long retailerId,@ApiParam(value = "Only returns the config that matches the given retailer location") @QueryParam("retailerLocationId")  Long retailerLocationId,@ApiParam(value = "Only returns only returns the config that matches the given device udid") @QueryParam("udid")  String udid,@ApiParam(value = "Determines whether to return older config versions if the exact version is not found. If this happens, will try to return the latest version.", defaultValue = "false") @DefaultValue("false") @QueryParam("allowOlderVersions")  Boolean allowOlderVersions,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getApplicationConfigByConfigVersion(version, appKey, configVersion, retailerId, retailerLocationId, udid, allowOlderVersions, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/application/placement/get")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Get Ad Placement", notes = "Get details of an ad placement", response = PlacementResponse.class, tags={ "Application", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = PlacementResponse.class)
    })
    public Response getApplicationPlacement(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The id of the placement", required = true) @QueryParam("placementId") @NotNull  Long placementId,@ApiParam(value = "The unique id of the device making the request (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "The account id of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getApplicationPlacement(version, placementId, deviceId, accountId, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/application/versions")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Get API versions", notes = "Will return a comma separated list of numbers, newest first. For example: 3.0, 2.2, 2.1, 1.8", response = SirqulResponse.class, tags={ "Application", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response getApplicationVersions(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getApplicationVersions(version, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/asset/get")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Get Asset", notes = "Gets the full asset response including attached likes and notes.", response = AssetFullResponse.class, tags={ "Asset", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = AssetFullResponse.class)
    })
    public Response getAsset(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the asset ID", required = true) @QueryParam("assetId") @NotNull  Long assetId,@ApiParam(value = "a unique ID given by the device (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "the account ID of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "determines whether the notes on the asset are in descending order", defaultValue = "false") @DefaultValue("false") @QueryParam("noteDescending")  Boolean noteDescending,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getAsset(version, assetId, deviceId, accountId, noteDescending, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/audience/get")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Get Audience", notes = "Get an audience. The audience and account must be valid and have the appropriate permissions to view the content.", response = AudienceResponse.class, tags={ "Audience", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = AudienceResponse.class)
    })
    public Response getAudience(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The logged in user.", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "The id of the audience to return.", required = true) @QueryParam("audienceId") @NotNull  Long audienceId,@ApiParam(value = "The application key (optional). If provided, results may be scoped to this application.") @QueryParam("appKey")  String appKey,@ApiParam(value = "(boolean) set to true to include the accountCount associated with current audience of the current app", defaultValue = "false") @DefaultValue("false") @QueryParam("returnAccountCount")  Boolean returnAccountCount,@ApiParam(value = "(boolean) set to true to include the albumCount associated with current audience of the current app", defaultValue = "false") @DefaultValue("false") @QueryParam("returnAlbumCount")  Boolean returnAlbumCount,@ApiParam(value = "(String) comma separated list, return an array with each item is the count of each album type. If not provided, \"all_types\" count is returned.") @QueryParam("albumTypesForCount")  String albumTypesForCount,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getAudience(version, accountId, audienceId, appKey, returnAccountCount, returnAlbumCount, albumTypesForCount, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/audience/search")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Search Audiences", notes = "Get the list audiences owned by the account", response = SearchResponse.class, responseContainer = "List", tags={ "Audience", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SearchResponse.class, responseContainer = "List")
    })
    public Response getAudienceList(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The logged in user.") @QueryParam("accountId")  Long accountId,@ApiParam(value = "Comma separated list of album IDs to filter results with") @QueryParam("albumIds")  String albumIds,@ApiParam(value = "The keyword used to search") @QueryParam("keyword")  String keyword,@ApiParam(value = "Comma separated list of fields that the keywords will match against. Possible values include: SEARCH_TAGS, NAME, DESCRIPTION, OWNER_DISPLAY", defaultValue = "SEARCH_TAGS,NAME,DESCRIPTION") @DefaultValue("SEARCH_TAGS,NAME,DESCRIPTION") @QueryParam("keywordFields")  String keywordFields,@ApiParam(value = "The field to sort by, possible values include: {ID, CREATED, UPDATED, DELETED, SEARCH_TAGS, ACTIVE, NAME, DESCRIPTION, OWNER_ID, OWNER_DISPLAY, GENDER}", allowableValues="ID, CREATED, UPDATED, DELETED, SEARCH_TAGS, ACTIVE, NAME, DESCRIPTION, SEND_SUGGESTION, OWNER_ID, OWNER_DISPLAY, GENDER", defaultValue = "NAME") @DefaultValue("NAME") @QueryParam("sortField")  String sortField,@ApiParam(value = "The order to return the results. Default is false, which will return the results in ascending order.", defaultValue = "false") @DefaultValue("false") @QueryParam("descending")  Boolean descending,@ApiParam(value = "The index into the record set to start with.", defaultValue = "0") @DefaultValue("0") @QueryParam("start")  Integer start,@ApiParam(value = "The total number of record to return (there is a hard limit of 100).", defaultValue = "20") @DefaultValue("20") @QueryParam("limit")  Integer limit,@ApiParam(value = "Filter results based on whether or not the audience is set to send suggestions") @QueryParam("sendSuggestion")  Boolean sendSuggestion,@ApiParam(value = "Determines whether to return only active results. Default is false.") @QueryParam("activeOnly")  Boolean activeOnly,@ApiParam(value = "Groups results by the audience groupingId (this does not work in conjunction with the following parameters: albumIds, audienceType, appKey, returnGlobal)") @QueryParam("groupByGroupingId")  Boolean groupByGroupingId,@ApiParam(value = "Filter results by application key") @QueryParam("appKey")  String appKey,@ApiParam(value = "If filtering by appKey, determines whether or not audiences that do not have an application set will also be returned as well") @QueryParam("returnGlobal")  Boolean returnGlobal,@ApiParam(value = "If true, match keyword exactly") @QueryParam("exactKeyword")  Boolean exactKeyword,@ApiParam(value = "(Deprecated) Filter results by audience type") @QueryParam("audienceType")  String audienceType,@ApiParam(value = "comma separated string with the different audience types you want to filter for") @QueryParam("audienceTypes")  String audienceTypes,@ApiParam(value = "(boolean) set to true to include the accountCount associated with current audience of the current app", defaultValue = "false") @DefaultValue("false") @QueryParam("returnAccountCount")  Boolean returnAccountCount,@ApiParam(value = "(boolean) set to true to include the albumCount associated with current audience of the current app", defaultValue = "false") @DefaultValue("false") @QueryParam("returnAlbumCount")  Boolean returnAlbumCount,@ApiParam(value = "(String) comma separated list, return an array with each item is the count of each album type. If not provided, \"all_types\" count is returned.") @QueryParam("albumTypesForCount")  String albumTypesForCount,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getAudienceList(version, accountId, albumIds, keyword, keywordFields, sortField, descending, start, limit, sendSuggestion, activeOnly, groupByGroupingId, appKey, returnGlobal, exactKeyword, audienceType, audienceTypes, returnAccountCount, returnAlbumCount, albumTypesForCount, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/orson/ai/batch/{requestId}")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Get Batch Analysis Results", notes = "Gets the completed Video Batch results, if done, or an error or status update if not.", response = OrsonAiBatchResponse.class, tags={ "Orson", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = OrsonAiBatchResponse.class)
    })
    public Response getBatch(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "Orson Request Id", required = true) @PathParam("requestId") @NotNull  String requestId,@ApiParam(value = "Sirqul Account Id", required = true) @QueryParam("accountId") @NotNull  Long accountId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getBatch(version, requestId, accountId, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/bid/get")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Get Bid", notes = "Get the bid details of a biddable object", response = BidResponse.class, tags={ "Bid", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = BidResponse.class)
    })
    public Response getBid(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The bid id", required = true) @QueryParam("bidId") @NotNull  Long bidId,@ApiParam(value = "The device id (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "The account id of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getBid(version, bidId, deviceId, accountId, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/billable/get")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Get Billable", notes = "Used to determine the associated BillableEntity of an account", response = BillableEntityResponse.class, tags={ "Billable Entity", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = BillableEntityResponse.class)
    })
    public Response getBillableEntity(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The unique device identifier that made the request (either deviceId or accountId must be used)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "The unique accountId that made the request (either deviceId or accountId must be used)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "Determines whether to include the retailer dash board counts into the response", defaultValue = "false") @DefaultValue("false") @QueryParam("includeCounts")  Boolean includeCounts,@ApiParam(value = "Whether to enable payments or not", defaultValue = "true") @DefaultValue("true") @QueryParam("includePayments")  Boolean includePayments,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getBillableEntity(version, deviceId, accountId, includeCounts, includePayments, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/vatom/b/behaviors")
    
    
    @io.swagger.annotations.ApiOperation(value = "Get Vatom Business Behaviors", notes = "Gets the behaviors of a business.", response = Void.class, tags={ "Vatom", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = Void.class)
    })
    public Response getBusinessBehaviors(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "Sirqul Account Id", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "Sirqul Application Key", required = true) @QueryParam("appKey") @NotNull  String appKey,@ApiParam(value = "Return raw response") @QueryParam("returnRawResponse")  Boolean returnRawResponse,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getBusinessBehaviors(version, accountId, appKey, returnRawResponse, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/vatom/b/coins/get")
    
    
    @io.swagger.annotations.ApiOperation(value = "Get the coins for a Business", notes = "Get the coins for a Businesss.", response = Void.class, tags={ "Vatom", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = Void.class)
    })
    public Response getBusinessCoinsBalance(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "Sirqul Account Id", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "Sirqul Application Key", required = true) @QueryParam("appKey") @NotNull  String appKey,@ApiParam(value = "Return raw response") @QueryParam("returnRawResponse")  Boolean returnRawResponse,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getBusinessCoinsBalance(version, accountId, appKey, returnRawResponse, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/vatom/me/businesses")
    
    
    @io.swagger.annotations.ApiOperation(value = "Get the user business ids", notes = "Get the business ids the logged in user has access to.", response = Void.class, tags={ "Vatom", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = Void.class)
    })
    public Response getBusinessIds(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "Sirqul Account Id", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "Return raw response") @QueryParam("returnRawResponse")  Boolean returnRawResponse,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getBusinessIds(version, accountId, returnRawResponse, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/vatom/b/get")
    
    
    @io.swagger.annotations.ApiOperation(value = "Get Vatom Business Info", notes = "Gets the business info tied to this account.", response = Void.class, tags={ "Vatom", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = Void.class)
    })
    public Response getBusinessInfo(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "Sirqul Account Id", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "Sirqul Application Key", required = true) @QueryParam("appKey") @NotNull  String appKey,@ApiParam(value = "Vatom Parameters") @QueryParam("vatomParameters")  String vatomParameters,@ApiParam(value = "Return raw response") @QueryParam("returnRawResponse")  Boolean returnRawResponse,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getBusinessInfo(version, accountId, appKey, vatomParameters, returnRawResponse, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/vatom/b/users")
    
    
    @io.swagger.annotations.ApiOperation(value = "Get Vatom Business Users", notes = "Gets the users of a business.", response = Void.class, tags={ "Vatom", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = Void.class)
    })
    public Response getBusinessUsers(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "Sirqul Account Id", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "Sirqul Application Key", required = true) @QueryParam("appKey") @NotNull  String appKey,@ApiParam(value = "Return raw response") @QueryParam("returnRawResponse")  Boolean returnRawResponse,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getBusinessUsers(version, accountId, appKey, returnRawResponse, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/vatom/b/campaign-groups/entities")
    
    
    @io.swagger.annotations.ApiOperation(value = "Get Campaign Group Entities", notes = "Get campaign group entities.", response = Void.class, tags={ "Vatom", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = Void.class)
    })
    public Response getCampaignGroupEntities(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "Sirqul Account Id", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "Sirqul Application Key", required = true) @QueryParam("appKey") @NotNull  String appKey,@ApiParam(value = "Vatom Campaign Id", required = true) @QueryParam("vatomCampaignId") @NotNull  String vatomCampaignId,@ApiParam(value = "Return raw response") @QueryParam("returnRawResponse")  Boolean returnRawResponse,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getCampaignGroupEntities(version, accountId, appKey, vatomCampaignId, returnRawResponse, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/vatom/b/campaign-groups/rules")
    
    
    @io.swagger.annotations.ApiOperation(value = "Get Campaign Group Rules", notes = "Get campaign group rules.", response = Void.class, tags={ "Vatom", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = Void.class)
    })
    public Response getCampaignGroupRules(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "Sirqul Account Id", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "Sirqul Application Key", required = true) @QueryParam("appKey") @NotNull  String appKey,@ApiParam(value = "Vatom Campaign Id", required = true) @QueryParam("vatomCampaignId") @NotNull  String vatomCampaignId,@ApiParam(value = "Return raw response") @QueryParam("returnRawResponse")  Boolean returnRawResponse,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getCampaignGroupRules(version, accountId, appKey, vatomCampaignId, returnRawResponse, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/vatom/b/campaign-groups/stats")
    
    
    @io.swagger.annotations.ApiOperation(value = "Get Campaign Group Stats", notes = "Get campaign group stats.", response = Void.class, tags={ "Vatom", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = Void.class)
    })
    public Response getCampaignGroupStats(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "Sirqul Account Id", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "Sirqul Application Key", required = true) @QueryParam("appKey") @NotNull  String appKey,@ApiParam(value = "Vatom Campaign Id", required = true) @QueryParam("vatomCampaignId") @NotNull  String vatomCampaignId,@ApiParam(value = "Return raw response") @QueryParam("returnRawResponse")  Boolean returnRawResponse,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getCampaignGroupStats(version, accountId, appKey, vatomCampaignId, returnRawResponse, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/vatom/b/campaign-groups/get")
    
    
    @io.swagger.annotations.ApiOperation(value = "Get Campaign Info", notes = "Gets the info on a campaign.", response = Void.class, tags={ "Vatom", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = Void.class)
    })
    public Response getCampaignInfo(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "Sirqul Account Id", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "Sirqul Application Key", required = true) @QueryParam("appKey") @NotNull  String appKey,@ApiParam(value = "Vatom Campaign Id", required = true) @QueryParam("vatomCampaignId") @NotNull  String vatomCampaignId,@ApiParam(value = "Return raw response") @QueryParam("returnRawResponse")  Boolean returnRawResponse,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getCampaignInfo(version, accountId, appKey, vatomCampaignId, returnRawResponse, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/cargo/type/{cargoTypeId}")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Get Cargo Type", notes = "Get an existing cargo type", response = CargoType.class, tags={ "Cargo Type", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = CargoType.class)
    })
    public Response getCargoType(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the cargo type ID", required = true) @PathParam("cargoTypeId") @NotNull  Long cargoTypeId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getCargoType(version, cargoTypeId, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/category/get")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Get Category", notes = "Get the details of a specific category. Recursively include all child categories and their children.", response = CategoryTreeResponse.class, tags={ "Category", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = CategoryTreeResponse.class)
    })
    public Response getCategory(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the ID of the category", required = true) @QueryParam("categoryId") @NotNull  Long categoryId,@ApiParam(value = "Determines whether to return extra info about the category's \"Participant\" reference", defaultValue = "true") @DefaultValue("true") @QueryParam("returnExternal")  Boolean returnExternal,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getCategory(version, categoryId, returnExternal, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/consumer/connection/getRequested")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Get Sent Friend Requests", notes = "Gets the connection sent friend requests.", response = ConnectionListResponse.class, tags={ "Connection", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = ConnectionListResponse.class)
    })
    public Response getConnectionSentFriendRequests(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the ID of the device") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "the id of the account") @QueryParam("accountId")  Long accountId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getConnectionSentFriendRequests(version, deviceId, accountId, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/consumer/connection/get")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Search Connections", notes = "Gets the connections.", response = ConnectionListResponse.class, tags={ "Connection", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = ConnectionListResponse.class)
    })
    public Response getConnections(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "whether to return nulls or not", required = true) @QueryParam("returnNulls") @NotNull  Boolean returnNulls,@ApiParam(value = "a comma separated list of ConnectionApiMap. (NOTE on FOLLOWER vs FOLLOWING: FOLLOWER will get me a list of followers, FOLLOWING will get me a list of people I am following)", required = true) @QueryParam("filter") @NotNull  String filter,@ApiParam(value = "sorts the response list by ConnectionApiMap", required = true) @QueryParam("sortField") @NotNull  String sortField,@ApiParam(value = "sorts the response list by descending order if true", required = true) @QueryParam("descending") @NotNull  Boolean descending,@ApiParam(value = "start index of the pagination", required = true) @QueryParam("start") @NotNull  Integer start,@ApiParam(value = "limit of the pagination", required = true) @QueryParam("limit") @NotNull  Integer limit,@ApiParam(value = "the device id (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "the account id (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "optional parameter to search on other account's connections") @QueryParam("connectionAccountId")  Long connectionAccountId,@ApiParam(value = "This parameter is deprecated.") @QueryParam("q")  String q,@ApiParam(value = "an optional keyword to search on, this parameter is ignored if empty") @QueryParam("keyword")  String keyword,@ApiParam(value = "This parameter is deprecated.") @QueryParam("_i")  Integer i,@ApiParam(value = "This parameter is deprecated.") @QueryParam("_l")  Integer l,@ApiParam(value = "the current latitude of the user") @QueryParam("latitude")  Double latitude,@ApiParam(value = "the current longitude of the user") @QueryParam("longitude")  Double longitude,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getConnections(version, returnNulls, filter, sortField, descending, start, limit, deviceId, accountId, connectionAccountId, q, keyword, i, l, latitude, longitude, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/creative/get")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Get Creative", notes = "Get a creative", response = CreativeResponse.class, tags={ "Creative", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = CreativeResponse.class)
    })
    public Response getCreative(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the id of the logged in user", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "the ID of the creative to get", required = true) @QueryParam("creativeId") @NotNull  Long creativeId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getCreative(version, accountId, creativeId, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/creative/search")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Search Creatives", notes = "Get a list of levels for an application, just those the account has permissions to view.", response = CreativeResponse.class, responseContainer = "List", tags={ "Creative", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = CreativeResponse.class, responseContainer = "List")
    })
    public Response getCreativesByApplication(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The logged in user.", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "the application key", required = true) @QueryParam("appKey") @NotNull  String appKey,@ApiParam(value = "Start the result set at some index.", required = true) @QueryParam("start") @NotNull  Integer start,@ApiParam(value = "Limit the result to some number.", required = true) @QueryParam("limit") @NotNull  Integer limit,@ApiParam(value = "Creatives contained in the provided mission.") @QueryParam("missionId")  Long missionId,@ApiParam(value = "Match the keyword to the owner name or level name.") @QueryParam("keyword")  String keyword,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getCreativesByApplication(version, accountId, appKey, start, limit, missionId, keyword, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/thirdparty/credential/get")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Get Credential", notes = "Gets the account information given a third party token.", response = ProfileResponse.class, tags={ "ThirdParty Credentials", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = ProfileResponse.class)
    })
    public Response getCredential(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the access provider to authenticate against", required = true) @QueryParam("networkUID") @NotNull  String networkUID,@ApiParam(value = "the application key", required = true) @QueryParam("appKey") @NotNull  String appKey,@ApiParam(value = "the unique account id of a specific account that will be bound to the third-party credentials") @QueryParam("accountId")  Long accountId,@ApiParam(value = "the unique id of the device making the request") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "the session id for the request") @QueryParam("sessionId")  String sessionId,@ApiParam(value = "the third-party credentials id from the response of the credential/create step") @QueryParam("thirdPartyCredentialId")  Long thirdPartyCredentialId,@ApiParam(value = "the access token to authenticate with") @QueryParam("thirdPartyToken")  String thirdPartyToken,@ApiParam(value = "the secret code to authenticate with (used for MFA)") @QueryParam("thirdPartySecret")  String thirdPartySecret,@ApiParam(value = "flag to force creation of a new account when no accountId is passed and user chooses not to use listed accounts", defaultValue = "false") @DefaultValue("false") @QueryParam("createNewAccount")  Boolean createNewAccount,@ApiParam(value = "this determines how much of the profile should be returned, see ProfileFilters") @QueryParam("responseFilters")  String responseFilters,@ApiParam(value = "the latitude of the user") @QueryParam("latitude")  Double latitude,@ApiParam(value = "the longitude of the user") @QueryParam("longitude")  Double longitude,@ApiParam(value = "audience ids to add to the account") @QueryParam("audienceIdsToAdd")  String audienceIdsToAdd,@ApiParam(value = "audience ids to remove from the account") @QueryParam("audienceIdsToRemove")  String audienceIdsToRemove,@ApiParam(value = "account id of the referrer (inviter-invitee relationship)") @QueryParam("referralAccountId")  Long referralAccountId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getCredential(version, networkUID, appKey, accountId, deviceId, sessionId, thirdPartyCredentialId, thirdPartyToken, thirdPartySecret, createNewAccount, responseFilters, latitude, longitude, audienceIdsToAdd, audienceIdsToRemove, referralAccountId, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/billing/crypto/get")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Get Crypto Balances", notes = "Get the cypto balance details for a user", response = PaymentTypesResponse.class, tags={ "Billing Info", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = PaymentTypesResponse.class)
    })
    public Response getCryptoBalance(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The account used to perform the the request", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "The account to retreive balances for") @QueryParam("ownerAccountId")  Long ownerAccountId,@ApiParam(value = "The payment method to return details on. If this is not set, then the user's default payment method will be returned.") @QueryParam("paymentMethodId")  Long paymentMethodId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getCryptoBalance(version, accountId, ownerAccountId, paymentMethodId, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/object/data/{objectName}/{objectId}")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Get Data", notes = "Get a specific record from a specified object.", response = ObjectStoreResponse.class, tags={ "Object Store", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = ObjectStoreResponse.class)
    })
    public Response getData(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The name of the object to search upon", required = true) @PathParam("objectName") @NotNull  String objectName,@ApiParam(value = "objectId The id of the record to return", required = true) @PathParam("objectId") @NotNull  String objectId,@ApiParam(value = "The account id of the logged in user") @QueryParam("accountId")  Long accountId,@ApiParam(value = "") @QueryParam("include")  String include,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getData(version, objectName, objectId, accountId, include, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/cargo/dependent/{accountId}")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Get dependent list of an account", notes = "Get the dependent list of an account", response = SirqulResponse.class, tags={ "Dependent", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response getDependents(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the id of the parent account to get a list of dependents", required = true) @PathParam("accountId") @NotNull  Long accountId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getDependents(version, accountId, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/audience/devices")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Get Devices", notes = "Gets the list of available devices that can be selected by consumers and retailers.", response = AudienceDeviceResponse.class, responseContainer = "List", tags={ "Audience", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = AudienceDeviceResponse.class, responseContainer = "List")
    })
    public Response getDevices(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "If true return inactive record as well. default is false.", required = true) @QueryParam("includeInactive") @NotNull  Boolean includeInactive,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getDevices(version, includeInactive, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/disbursement/get")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Get Disbursement", notes = "Get Disbursement details", response = DisbursementResponse.class, tags={ "Disbursement", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = DisbursementResponse.class)
    })
    public Response getDisbursement(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The logged in user.", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "the id of the disbursement", required = true) @QueryParam("disbursementId") @NotNull  Long disbursementId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getDisbursement(version, accountId, disbursementId, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/orson/ai/emotion/{requestId}")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Get Emotion Results", notes = "Checks the Emotion analysis and returns in progress, results, or error.", response = OrsonAiEmotionsResponse.class, tags={ "Orson", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = OrsonAiEmotionsResponse.class)
    })
    public Response getEmotion(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "Orson Request Id", required = true) @PathParam("requestId") @NotNull  String requestId,@ApiParam(value = "Sirqul Account Id", required = true) @QueryParam("accountId") @NotNull  Long accountId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getEmotion(version, requestId, accountId, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/employee/get")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Get Employee", notes = "Get the account record for the account id provided.", response = EmployeeResponse.class, tags={ "Employee", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = EmployeeResponse.class)
    })
    public Response getEmployee(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the id of logged in user", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "the id of the employee account to get", required = true) @QueryParam("employeeAccountId") @NotNull  Long employeeAccountId,@ApiParam(value = "Determines whether to return the application settings for the employee for a particular application") @QueryParam("settingsAppKey")  String settingsAppKey,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getEmployee(version, accountId, employeeAccountId, settingsAppKey, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/orson/stories/episodes/{episodeId}/status")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Check episode status", notes = "Gets a summary of the episode's status, including any renders.", response = OrsonEpisodeResponse.class, tags={ "Orson", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = OrsonEpisodeResponse.class)
    })
    public Response getEpisodeStatus(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "Episode ID", required = true) @PathParam("episodeId") @NotNull  Long episodeId,@ApiParam(value = "Sirqul Account Id", required = true) @QueryParam("accountId") @NotNull  Long accountId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getEpisodeStatus(version, episodeId, accountId, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/event/get")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Get Event", notes = "Get an event.", response = OfferResponse.class, tags={ "Event", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = OfferResponse.class)
    })
    public Response getEvent(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the id of the logged in user", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "The id of the event to return", required = true) @QueryParam("eventId") @NotNull  Long eventId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getEvent(version, accountId, eventId, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/vatom/b/events/guests/get")
    
    
    @io.swagger.annotations.ApiOperation(value = "Get Vatom Event Guest List", notes = "Gets the guest list of an event.", response = Void.class, tags={ "Vatom", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = Void.class)
    })
    public Response getEventGuestList(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "Sirqul Account Id", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "Sirqul Application Key", required = true) @QueryParam("appKey") @NotNull  String appKey,@ApiParam(value = "Vatom Event Id", required = true) @QueryParam("vatomEventId") @NotNull  String vatomEventId,@ApiParam(value = "Return raw response") @QueryParam("returnRawResponse")  Boolean returnRawResponse,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getEventGuestList(version, accountId, appKey, vatomEventId, returnRawResponse, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/audience/experiences")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Get Experiences", notes = "Gets the list of available experiences that can be selected by consumers and retailers.", response = SirqulResponse.class, tags={ "Audience", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response getExperiences(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getExperiences(version, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/favorite/get")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Get Favorite", notes = "Retrieves a single favorited item.", response = WrappedResponse.class, tags={ "Favorite", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = WrappedResponse.class)
    })
    public Response getFavorite(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The ID of the favorite reference record", required = true) @QueryParam("favoriteId") @NotNull  Long favoriteId,@ApiParam(value = "The unique ID given by the device (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "The account ID of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "The current latitude of the user") @QueryParam("latitude")  Double latitude,@ApiParam(value = "The current longitude of the user") @QueryParam("longitude")  Double longitude,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getFavorite(version, favoriteId, deviceId, accountId, latitude, longitude, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/filter/get")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Get Filter", notes = "Get the details of a specific filter. Recursively include all child filters and their children.", response = FilterTreeResponse.class, tags={ "Filter", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = FilterTreeResponse.class)
    })
    public Response getFilter(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the id of the filter to get", required = true) @QueryParam("filterId") @NotNull  Long filterId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getFilter(version, filterId, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/flag/get")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Get Flag", notes = "Gets the details on whether the user has flagged a particular flagable object.", response = FlagResponse.class, tags={ "Flag", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = FlagResponse.class)
    })
    public Response getFlag(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The flagable object type {ACCOUNT, ALBUM, ALBUM_CONTEST, ASSET, GAME_LEVEL, THEME_DESCRIPTOR, NOTE, OFFER}", required = true) @QueryParam("flagableType") @NotNull  String flagableType,@ApiParam(value = "The flagable object id", required = true) @QueryParam("flagableId") @NotNull  Long flagableId,@ApiParam(value = "The unique device identifier that made the request (either deviceId or accountId must be used)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "The unique accountId that made the request (either deviceId or accountId must be used)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "The current location of the user") @QueryParam("latitude")  Double latitude,@ApiParam(value = "The current location of the user") @QueryParam("longitude")  Double longitude,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getFlag(version, flagableType, flagableId, deviceId, accountId, latitude, longitude, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/flag/threshold/get")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Get Flag Threshold", notes = "Get the flag threshold value on an object type for a particular application.", response = CountResponse.class, tags={ "Flag", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = CountResponse.class)
    })
    public Response getFlagThreshold(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The flagable object type {ACCOUNT, ALBUM, ALBUM_CONTEST, ASSET, GAME_LEVEL, THEME_DESCRIPTOR, OFFER, NOTE}", required = true) @QueryParam("itemBeingFlaggedType") @NotNull  String itemBeingFlaggedType,@ApiParam(value = "The application key", required = true) @QueryParam("appKey") @NotNull  String appKey,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getFlagThreshold(version, itemBeingFlaggedType, appKey, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/game/get")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Get a Game by id", notes = "Get a Game by id.", response = GameResponse.class, tags={ "Game", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = GameResponse.class)
    })
    public Response getGame(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The logged in user.", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "the updating game's id.", required = true) @QueryParam("gameId") @NotNull  Long gameId,@ApiParam(value = "If true include the game level data, otherwise don't. default is false.") @QueryParam("includeGameData")  Boolean includeGameData,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getGame(version, accountId, gameId, includeGameData, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/level/get")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Get Game Level", notes = "Get a game level. The level and account must be valid and have the appropirate permissions to view the content.", response = GameLevelResponse.class, tags={ "Game Level", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = GameLevelResponse.class)
    })
    public Response getGameLevel(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The logged in user.", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "The id of the level to return.", required = true) @QueryParam("levelId") @NotNull  Long levelId,@ApiParam(value = "If true include the game level data, otherwise don't. default is false.") @QueryParam("includeGameData")  Boolean includeGameData,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getGameLevel(version, accountId, levelId, includeGameData, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/level/search")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Search Game Levels", notes = "Get a list of levels for an application, just those the account has permissions to view.", response = GameLevelListResponse.class, tags={ "Game Level", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = GameLevelListResponse.class)
    })
    public Response getGameLevelsByApplication(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The logged in user.", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "the application key", required = true) @QueryParam("appKey") @NotNull  String appKey,@ApiParam(value = "Match the keyword to the owner name or level name.") @QueryParam("keyword")  String keyword,@ApiParam(value = "what field to sort on") @QueryParam("sortField")  String sortField,@ApiParam(value = "whether to return levels in ascending or descending order") @QueryParam("descending")  Boolean descending,@ApiParam(value = "Start the result set at some index.") @QueryParam("start")  Integer start,@ApiParam(value = "Limit the result to some number.") @QueryParam("limit")  Integer limit,@ApiParam(value = "The maximum version of the level to return.") @QueryParam("appVersion")  String appVersion,@ApiParam(value = "If true include the game level data, otherwise don't. default is false.") @QueryParam("includeGameData")  Boolean includeGameData,@ApiParam(value = "") @QueryParam("filters")  String filters,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getGameLevelsByApplication(version, accountId, appKey, keyword, sortField, descending, start, limit, appVersion, includeGameData, filters, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/level/searchByBillableEntity")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Search Game Level by Billable Entity", notes = "Searches on game levels that the logged in user has access to. A user would have access if the creator of the game level is managed under the same BillableEntity.", response = GameLevelResponse.class, tags={ "Game Level", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = GameLevelResponse.class)
    })
    public Response getGameLevelsByBillableEntity(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The account id of the user", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "the application key") @QueryParam("appKey")  String appKey,@ApiParam(value = "The keyword used to search") @QueryParam("keyword")  String keyword,@ApiParam(value = "The column to sort the search on", allowableValues="LEVEL_ACTIVE, LEVEL_NAME, LEVEL_DESCRIPTION, LEVEL_CREATED, LEVEL_UPDATED, LEVEL_LIKES, LEVEL_DISLIKES, LEVEL_NOTES, LEVEL_PLAYS, LEVEL_DOWNLOADS, LEVEL_QUITS, LEVEL_COMPLETES, LEVEL_VERSION, LEVEL_MISSION_TYPE, LEVEL_OWNER_DISPLAY, GAME_OWNER_DISPLAY, GAME_TITLE, GAME_DESCRIPTION, GAME_LIKES, GAME_DISLIKES, APP_NAME, APP_SCORING_TYPE") @QueryParam("sortField")  String sortField,@ApiParam(value = "The order to return the search results") @QueryParam("descending")  Boolean descending,@ApiParam(value = "Return only active results") @QueryParam("activeOnly")  Boolean activeOnly,@ApiParam(value = "The record to begin the return set on") @QueryParam("start")  Long start,@ApiParam(value = "The number of records to return") @QueryParam("limit")  Long limit,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getGameLevelsByBillableEntity(version, accountId, appKey, keyword, sortField, descending, activeOnly, start, limit, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/consumer/connection/group/details/get")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Get Connection Group", notes = "", response = ConnectionGroupResponse.class, tags={ "Connection", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = ConnectionGroupResponse.class)
    })
    public Response getGroupDetails(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "whether to combine connections or not", required = true) @QueryParam("combineConnections") @NotNull  Boolean combineConnections,@ApiParam(value = "the device id (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "the account id of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "the group id") @QueryParam("groupId")  Long groupId,@ApiParam(value = "the current latitude of the user") @QueryParam("latitude")  Double latitude,@ApiParam(value = "the current longitude of the user") @QueryParam("longitude")  Double longitude,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getGroupDetails(version, combineConnections, deviceId, accountId, groupId, latitude, longitude, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/audience/grouped/get")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Get GroupedAudiences", notes = "Get a group of audiences. The audience and account must be valid and have the appropriate permissions to view the content.", response = AudienceResponse.class, tags={ "Audience", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = AudienceResponse.class)
    })
    public Response getGroupedAudiences(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The logged in user.", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "The audience grouping id to return.", required = true) @QueryParam("audienceGroupingId") @NotNull  String audienceGroupingId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getGroupedAudiences(version, accountId, audienceGroupingId, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/ranking/historical/search")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Search Historical Rankings", notes = "Get historical leaderboard rankings by time-frame.", response = RankFullResponse.class, tags={ "Ranking", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = RankFullResponse.class)
    })
    public Response getHistoricalRankings(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the application key for filtering results by application", required = true) @QueryParam("appKey") @NotNull  String appKey,@ApiParam(value = "the rank type to return", required = true) @QueryParam("rankType") @NotNull  String rankType,@ApiParam(value = "timestamp in milliseconds to filter results with", required = true) @QueryParam("startDate") @NotNull  Long startDate,@ApiParam(value = "timestamp in milliseconds to filter results with", required = true) @QueryParam("endDate") @NotNull  Long endDate,@ApiParam(value = "a unique id given by the device (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "the account id of the user") @QueryParam("accountId")  Long accountId,@ApiParam(value = "determines how to order and rank the results. Possible values include: TOTAL, MONTHLY, WEEKLY, DAILY, TOP, LOWEST", defaultValue = "TOTAL") @DefaultValue("TOTAL") @QueryParam("sortField")  String sortField,@ApiParam(value = "determines whether to return results in ascending or descending order", defaultValue = "true") @DefaultValue("true") @QueryParam("descending")  Boolean descending,@ApiParam(value = "the start index for pagination", defaultValue = "0") @DefaultValue("0") @QueryParam("start")  Integer start,@ApiParam(value = "the limit for pagination", defaultValue = "100") @DefaultValue("100") @QueryParam("limit")  Integer limit,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getHistoricalRankings(version, appKey, rankType, startDate, endDate, deviceId, accountId, sortField, descending, start, limit, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/vatom/me/inventory")
    
    
    @io.swagger.annotations.ApiOperation(value = "Get Vatom User's Inventory", notes = "Gets the logged in user's Vatom Inventory.", response = Void.class, tags={ "Vatom", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = Void.class)
    })
    public Response getInventory(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "Sirqul Account Id", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "Vatom Parameters", required = true) @QueryParam("vatomParameters") @NotNull  String vatomParameters,@ApiParam(value = "Return raw response") @QueryParam("returnRawResponse")  Boolean returnRawResponse,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getInventory(version, accountId, vatomParameters, returnRawResponse, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/invite/get")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Get Invite", notes = "This is used to determine whether an invite token is valid. If the token is valid, this will also return information about who invited the user, and what they are invited to.", response = SirqulResponse.class, tags={ "Invite", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response getInvite(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "Account ID of the user if they are logged in") @QueryParam("accountId")  Long accountId,@ApiParam(value = "the invite token") @QueryParam("token")  String token,@ApiParam(value = "album id to match the invite against (if applicable)") @QueryParam("albumId")  Long albumId,@ApiParam(value = "mission id to match the invite against (if applicable)") @QueryParam("missionId")  Long missionId,@ApiParam(value = "album contest id to match the invite against (if applicable)") @QueryParam("albumContestId")  Long albumContestId,@ApiParam(value = "offer id to match the invite against (if applicable)") @QueryParam("offerId")  Long offerId,@ApiParam(value = "offer location id to match the invite against (if applicable)") @QueryParam("offerLocationId")  Long offerLocationId,@ApiParam(value = "retailer location id to match the invite against (if applicable)") @QueryParam("retailerLocationId")  Long retailerLocationId,@ApiParam(value = "the application key") @QueryParam("appKey")  String appKey,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getInvite(version, accountId, token, albumId, missionId, albumContestId, offerId, offerLocationId, retailerLocationId, appKey, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/leaderboard/get")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Read a leaderboard by id and retrieve the matching ranking list", notes = "Read a leaderboard by id and retrieve the matching ranking list", response = LeaderboardResponse.class, tags={ "Leaderboard", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = LeaderboardResponse.class)
    })
    public Response getLeaderboard(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The leaderboard id.", required = true) @QueryParam("leaderboardId") @NotNull  Long leaderboardId,@ApiParam(value = "A valid account.") @QueryParam("accountId")  Long accountId,@ApiParam(value = "set to true if need to return the leaderboard's full ranking list") @QueryParam("includeFullRankingList")  Boolean includeFullRankingList,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getLeaderboard(version, leaderboardId, accountId, includeFullRankingList, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/listing/get")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Get Listing", notes = "Get a listing by id.", response = ListingFullResponse.class, tags={ "Listing", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = ListingFullResponse.class)
    })
    public Response getListing(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the id of the listing to get", required = true) @QueryParam("listingId") @NotNull  Long listingId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getListing(version, listingId, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/location/ip")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Get Location by IP", notes = "Get location information based on an IP address.", response = CoordsResponse.class, tags={ "Location", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = CoordsResponse.class)
    })
    public Response getLocationByIp(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the ip address of the client device") @QueryParam("ip")  String ip,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getLocationByIp(version, ip, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/account/location/trilaterate")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Get Location by Trilateration", notes = "Send in device data and calculate a position based on signal strengths.", response = GeoPointResponse.class, tags={ "Location", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = GeoPointResponse.class)
    })
    public Response getLocationByTrilateration(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The account making the request, if provided the last know location will be updated") @QueryParam("accountId")  Long accountId,@ApiParam(value = "The known GPS latitude to compare to the calculated version") @QueryParam("latitude")  Double latitude,@ApiParam(value = "The known GPS longitude to compare to the calculated version") @QueryParam("longitude")  Double longitude,@ApiParam(value = "The json formated sample data:  ```json {    \"count\": 2,   \"timespan\": 10,    \"samples\": [     {       \"deviceId\": \"device1\",       \"rssi\": [-63, -75]     },      {       \"deviceId\": \"device2\",       \"rssi\": [-83, -79]     }   ] } ``` ") @QueryParam("data")  String data,@ApiParam(value = "Optional response filters (not used currently)") @QueryParam("responseFilters")  String responseFilters,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getLocationByTrilateration(version, accountId, latitude, longitude, data, responseFilters, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/location/search")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Search Regions or Postal Codes", notes = "Searches geographic locations by proximity via address or keyword.", response = LocationSearchResponse.class, tags={ "Location", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = LocationSearchResponse.class)
    })
    public Response getLocations(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the device id") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "the account id") @QueryParam("accountId")  Long accountId,@ApiParam(value = "This parameter is deprecated.") @QueryParam("currentlatitude")  Double currentlatitude,@ApiParam(value = "This parameter is deprecated.") @QueryParam("currentlongitude")  Double currentlongitude,@ApiParam(value = "the current latitude of the user") @QueryParam("currentLatitude")  Double currentLatitude,@ApiParam(value = "the current longitude of the user") @QueryParam("currentLongitude")  Double currentLongitude,@ApiParam(value = "the query results by keyword or address") @QueryParam("query")  String query,@ApiParam(value = "This parameter is deprecated.") @QueryParam("zipcode")  String zipcode,@ApiParam(value = "the zip code to filter results") @QueryParam("zipCode")  String zipCode,@ApiParam(value = "This parameter is deprecated.") @QueryParam("selectedMaplatitude")  Double selectedMaplatitude,@ApiParam(value = "This parameter is deprecated.") @QueryParam("selectedMaplongitude")  Double selectedMaplongitude,@ApiParam(value = "the latitude of where the search should originate from") @QueryParam("selectedMapLatitude")  Double selectedMapLatitude,@ApiParam(value = "the longitude of where the search should originate from") @QueryParam("selectedMapLongitude")  Double selectedMapLongitude,@ApiParam(value = "the search range of the search in miles", defaultValue = "5") @DefaultValue("5") @QueryParam("searchRange")  Double searchRange,@ApiParam(value = "determines whether to allow searches via address", defaultValue = "false") @DefaultValue("false") @QueryParam("useGeocode")  Boolean useGeocode,@ApiParam(value = "This parameter is deprecated.") @QueryParam("_i")  Integer i,@ApiParam(value = "the start index for pagination", defaultValue = "0") @DefaultValue("0") @QueryParam("start")  Integer start,@ApiParam(value = "This parameter is deprecated.") @QueryParam("_l")  Integer l,@ApiParam(value = "the limit for pagination", defaultValue = "20") @DefaultValue("20") @QueryParam("limit")  Integer limit,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getLocations(version, deviceId, accountId, currentlatitude, currentlongitude, currentLatitude, currentLongitude, query, zipcode, zipCode, selectedMaplatitude, selectedMaplongitude, selectedMapLatitude, selectedMapLongitude, searchRange, useGeocode, i, start, l, limit, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/media/get")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Media Get", notes = "Get a media offering.", response = MediaOfferResponse.class, tags={ "Media", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = MediaOfferResponse.class)
    })
    public Response getMedia(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the id of the logged in user", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "the id of the media to get", required = true) @QueryParam("mediaId") @NotNull  Long mediaId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getMedia(version, accountId, mediaId, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/mission/get")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Get Mission", notes = "Get a mission.", response = MissionResponse.class, tags={ "Mission", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = MissionResponse.class)
    })
    public Response getMission(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The logged in user.", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "The id of the mission to return.", required = true) @QueryParam("missionId") @NotNull  Long missionId,@ApiParam(value = "Return creatives associated with the mission when true") @QueryParam("returnCreative")  Boolean returnCreative,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getMission(version, accountId, missionId, returnCreative, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/mission/invite/get")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Get Mission Invite", notes = "Get the mission invite. An account can only be invited to a mission one time.", response = MissionResponse.class, tags={ "Mission Invite", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = MissionResponse.class)
    })
    public Response getMissionInvite(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the device id (deviceId or accountId required).") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "the account id of the user (deviceId or accountId required).") @QueryParam("accountId")  Long accountId,@ApiParam(value = "The mission to find the invite for (missionId or missionInviteId requried).") @QueryParam("missionId")  Long missionId,@ApiParam(value = "The mission invite id. This checks on the user's billable for permission (missionId or missionInviteId requried).") @QueryParam("missionInviteId")  Long missionInviteId,@ApiParam(value = "Include the game level data with the mission.") @QueryParam("includeGameData")  Boolean includeGameData,@ApiParam(value = "include the scores with the mission") @QueryParam("includeScores")  String includeScores,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getMissionInvite(version, deviceId, accountId, missionId, missionInviteId, includeGameData, includeScores, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/vatom/me/rels/following")
    
    
    @io.swagger.annotations.ApiOperation(value = "Get following", notes = "Get following.", response = Void.class, tags={ "Vatom", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = Void.class)
    })
    public Response getMyFollowing(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "Sirqul Account Id", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "Return raw response") @QueryParam("returnRawResponse")  Boolean returnRawResponse,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getMyFollowing(version, accountId, returnRawResponse, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/thirdparty/network/get")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Get Network", notes = "Get the details of a third party network. Only the network owners and managers have access to this.", response = ThirdPartyNetworkResponse.class, tags={ "ThirdParty Credentials", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = ThirdPartyNetworkResponse.class)
    })
    public Response getNetwork(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The account id making the request", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "The unique identifier for the third party network defined by Sirqul", required = true) @QueryParam("networkUID") @NotNull  String networkUID,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getNetwork(version, accountId, networkUID, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/note/get")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Get Note", notes = "Get for a note based on its Id.", response = SirqulResponse.class, tags={ "Note", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response getNote(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the id of the note to get", required = true) @QueryParam("noteId") @NotNull  Long noteId,@ApiParam(value = "The unique device identifier that made the request (either deviceId or accountId must be used)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "The unique accountId that made the request (either deviceId or accountId must be used)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "Determines whether to return the NoteFullResponse for the item") @QueryParam("returnFullResponse")  Boolean returnFullResponse,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getNote(version, noteId, deviceId, accountId, returnFullResponse, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/notification/template/get")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Get Notification Template", notes = "Get the details of a notification template. Developers will only be able to see notification templates for their own applications.", response = NotificationTemplateResponse.class, tags={ "Notification", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = NotificationTemplateResponse.class)
    })
    public Response getNotificationTemplate(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the id of the account", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "the id of the notification template to get", required = true) @QueryParam("notificationTemplateId") @NotNull  Long notificationTemplateId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getNotificationTemplate(version, accountId, notificationTemplateId, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/notification/search")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Get Notifications", notes = "Get a list of notifications for a user. If the \"markAsRead\" parameter is set to true, the returned notifications will be marked as \"read\" after the response has been sent. By default, read messages will not be returned, so to see read messages, set \"returnReadMessages\" to true.", response = NotificationMessageListResponse.class, tags={ "Notification", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = NotificationMessageListResponse.class)
    })
    public Response getNotifications(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the unique id of the device making the request (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "the account id of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "the account id used to view another person's notifications") @QueryParam("connectionAccountId")  Long connectionAccountId,@ApiParam(value = "the application key to filter messages by application") @QueryParam("appKey")  String appKey,@ApiParam(value = "comma separated list of EVENTS. Filters search results to only include these events. Don't include this parameter or pass in an empty string to return all event types.") @QueryParam("eventType")  String eventType,@ApiParam(value = "comma separated list of content ids to search notifications on") @QueryParam("contentIds")  String contentIds,@ApiParam(value = "comma separated list of content types to search notifications on") @QueryParam("contentTypes")  String contentTypes,@ApiParam(value = "comma separated list of parent ids to search notifications on") @QueryParam("parentIds")  String parentIds,@ApiParam(value = "comma separated list of parent types to search notifications on") @QueryParam("parentTypes")  String parentTypes,@ApiParam(value = "Action category used to filter notifications") @QueryParam("actionCategory")  String actionCategory,@ApiParam(value = "comma separated list of conduits to search notifications on") @QueryParam("conduits")  String conduits,@ApiParam(value = "search notifications via keyword") @QueryParam("keyword")  String keyword,@ApiParam(value = "if set to true, will return notifications that have been marked as read") @QueryParam("returnReadMessages")  Boolean returnReadMessages,@ApiParam(value = "if set to true, the returned notifications will be marked as \\\"read\\\" after the response has been sent") @QueryParam("markAsRead")  Boolean markAsRead,@ApiParam(value = "filter notifications from this date") @QueryParam("fromDate")  Long fromDate,@ApiParam(value = "latitude used to update the user's current location") @QueryParam("latitude")  Double latitude,@ApiParam(value = "longitude used to update the user's current location") @QueryParam("longitude")  Double longitude,@ApiParam(value = "whether to include notifications sent by the requester in the response") @QueryParam("returnSent")  Boolean returnSent,@ApiParam(value = "whether to ignore flagged notifications") @QueryParam("ignoreFlagged")  Boolean ignoreFlagged,@ApiParam(value = "start of the pagination") @QueryParam("start")  Integer start,@ApiParam(value = "limit of the pagination") @QueryParam("limit")  Integer limit,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getNotifications(version, deviceId, accountId, connectionAccountId, appKey, eventType, contentIds, contentTypes, parentIds, parentTypes, actionCategory, conduits, keyword, returnReadMessages, markAsRead, fromDate, latitude, longitude, returnSent, ignoreFlagged, start, limit, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/object/get")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Get Object", notes = "Get the definition of an Object. Returns all field names, types, and current size. The types supported are: STRING, DATE, NUMBER, BOOLEAN, IDENTITY.", response = ObjectStoreResponse.class, tags={ "Object Store", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = ObjectStoreResponse.class)
    })
    public Response getObject(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The account id of the logged in user", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "The application key for updating an existing application", required = true) @QueryParam("appKey") @NotNull  String appKey,@ApiParam(value = "The name of the object to get the definition for", required = true) @QueryParam("objectName") @NotNull  String objectName,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getObject(version, accountId, appKey, objectName, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/retailer/offer/get")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Get Offer", notes = "Gets the details of an offer that the user has access to.", response = RetailerOfferResponse.class, tags={ "Offer", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = RetailerOfferResponse.class)
    })
    public Response getOffer(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The id of the offer", required = true) @QueryParam("offerId") @NotNull  Long offerId,@ApiParam(value = "", required = true) @QueryParam("includeOfferLocations") @NotNull  Boolean includeOfferLocations,@ApiParam(value = "The device id (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "The account id (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getOffer(version, offerId, includeOfferLocations, deviceId, accountId, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/offer/get")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Get Offer", notes = "Gets offer or offer location details as a consumer.  Will check if it is a favorite if the deviceId/accountId is provided.  If the offerId is provided it will look up the main offer and ignore the the offerLocationId. If no offerId is provided then an offerLocationId must be specified.", response = OfferResponse.class, tags={ "Offer", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = OfferResponse.class)
    })
    public Response getOfferDetails(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The device id for returning account information (i.e. favorites)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "The account id for returning account information (i.e. favorites)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "The offer id (either offeLocationId or offerId must be provided)") @QueryParam("offerId")  Long offerId,@ApiParam(value = "The offer location id (either offeLocationId or offerId must be provided)") @QueryParam("offerLocationId")  Long offerLocationId,@ApiParam(value = "The distance of the offer from the user's current location (this is returned when the offer is searched)") @QueryParam("distance")  Double distance,@ApiParam(value = "The latitude to calculate distance from the offer") @QueryParam("latitude")  Double latitude,@ApiParam(value = "The longitude to calculate distance from the offer") @QueryParam("longitude")  Double longitude,@ApiParam(value = "Determines whether to return offer locations for the offer", defaultValue = "false") @DefaultValue("false") @QueryParam("includeOfferLocations")  Boolean includeOfferLocations,@ApiParam(value = "Determines whether to return the retailer location info for each offer location response (includeOfferLocations must also be true for this to work)", defaultValue = "false") @DefaultValue("false") @QueryParam("includeRetailerLocations")  Boolean includeRetailerLocations,@ApiParam(value = "Determines whether to include child offers in the response", defaultValue = "false") @DefaultValue("false") @QueryParam("includeChildOffers")  Boolean includeChildOffers,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getOfferDetails(version, deviceId, accountId, offerId, offerLocationId, distance, latitude, longitude, includeOfferLocations, includeRetailerLocations, includeChildOffers, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/offer/lists/count")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Get Offers (Counts)", notes = "Gets the offer list counts.", response = ListCountResponse.class, tags={ "Offer", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = ListCountResponse.class)
    })
    public Response getOfferListCounts(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The latitude of where the search will center at", required = true) @QueryParam("latitude") @NotNull  Double latitude,@ApiParam(value = "The longitude of where the search will center at", required = true) @QueryParam("longitude") @NotNull  Double longitude,@ApiParam(value = "The range of the search", defaultValue = "5") @DefaultValue("5") @QueryParam("searchRange")  BigDecimal searchRange,@ApiParam(value = "The units to use for distance calculations (e.g. MILES, KILOMETERS)", allowableValues="MILES, KILOMETERS", defaultValue = "MILES") @DefaultValue("MILES") @QueryParam("distanceUnit")  String distanceUnit,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getOfferListCounts(version, latitude, longitude, searchRange, distanceUnit, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/offer/location/get")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Get Offer Location", notes = "Gets the offer location by offer location id or udid (of a device)", response = OfferShortResponse.class, tags={ "Offer", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = OfferShortResponse.class)
    })
    public Response getOfferLocation(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the id of the offer location to get") @QueryParam("offerLocationId")  Long offerLocationId,@ApiParam(value = "the UDID of the device") @QueryParam("udid")  String udid,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getOfferLocation(version, offerLocationId, udid, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/retailer/offer/location/search")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Search Offer Locations", notes = "Searches on offer locations, which are records that represent an offer that has been assigned to a retailer location. If an offer does not have any locations assigned, then it will NOT be returned.", response = OfferShortResponse.class, responseContainer = "List", tags={ "Offer", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = OfferShortResponse.class, responseContainer = "List")
    })
    public Response getOfferLocationsForRetailers(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The column to sort the results on. Default is \"TITLE\", which will sort the results by the offer title. Possible input values: {CREATED, UPDATED, ACTIVE, ACTIVATED, EXPIRES, TITLE, SUBTITLE, DETAILS, OFFER_TYPE, RETAILER_ID,RETAILER_LOCATION_ID, BILLABLE_ENTITY_NAME, RESPONSIBLE_DISPLAY}", required = true, allowableValues="ID, CREATED, UPDATED, DELETED, SEARCH_TAGS, ACTIVE, OFFER_ID, ACTIVATED, EXPIRES, TITLE, SUBTITLE, DETAILS, OFFER_TYPE, SPECIAL_OFFER_TYPE, OFFER_VISIBILITY, RETAILER_ID, RETAILER_LOCATION_ID, BILLABLE_ENTITY_ID, BILLABLE_ENTITY_NAME, RESPONSIBLE_DISPLAY") @QueryParam("sortField") @NotNull  String sortField,@ApiParam(value = "The order to return the results. Default is false, which will return the results in ascending order.", required = true) @QueryParam("descending") @NotNull  Boolean descending,@ApiParam(value = "The index into the record set to start with. Default is 0.", required = true) @QueryParam("start") @NotNull  Integer start,@ApiParam(value = "The total number of records to return. Default is 20.", required = true) @QueryParam("limit") @NotNull  Integer limit,@ApiParam(value = "Determines whether to return only active results. Default is false.", required = true) @QueryParam("activeOnly") @NotNull  Boolean activeOnly,@ApiParam(value = "", required = true) @QueryParam("includeRetailerLocation") @NotNull  Boolean includeRetailerLocation,@ApiParam(value = "The device id (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "The account id of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "The keyword used to search") @QueryParam("keyword")  String keyword,@ApiParam(value = "Filter results for a specific retailer") @QueryParam("retailerId")  Long retailerId,@ApiParam(value = "Filter results for a specific retailer location") @QueryParam("retailerLocationId")  Long retailerLocationId,@ApiParam(value = "Filter results to only return COUPON, VOUCHER, PRODUCT, MEDIA, or EVENT offers", allowableValues="VOUCHER, COUPON, PRODUCT, MEDIA, EVENT, DEVICE") @QueryParam("offerType")  String offerType,@ApiParam(value = "Filter results to only return REGULAR_OFFER, ACT_NOW, GET_THERE_NOW offer specials", allowableValues="ALL, RESERVABLE, REGULAR_OFFER, ACT_NOW, GET_THERE_NOW, SQOOT, TICKETS, YIPIT") @QueryParam("specialOfferType")  String specialOfferType,@ApiParam(value = "") @QueryParam("barcodeType")  String barcodeType,@ApiParam(value = "") @QueryParam("barcodeEntry")  String barcodeEntry,@ApiParam(value = "") @QueryParam("isbn")  String isbn,@ApiParam(value = "") @QueryParam("asin")  String asin,@ApiParam(value = "Edysen device status, running, warning, or down", allowableValues="RUNNING, WARNING, DOWN") @QueryParam("deviceStatus")  String deviceStatus,@ApiParam(value = "") @QueryParam("needsNotificationSent")  Boolean needsNotificationSent,@ApiParam(value = "") @QueryParam("lastNotificationSent")  Long lastNotificationSent,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getOfferLocationsForRetailers(version, sortField, descending, start, limit, activeOnly, includeRetailerLocation, deviceId, accountId, keyword, retailerId, retailerLocationId, offerType, specialOfferType, barcodeType, barcodeEntry, isbn, asin, deviceStatus, needsNotificationSent, lastNotificationSent, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/wallet/get")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Get Wallet Offer", notes = "", response = OfferTransactionResponse.class, tags={ "Wallet", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = OfferTransactionResponse.class)
    })
    public Response getOfferTransaction(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The offer transaction id to get details of", required = true) @QueryParam("transactionId") @NotNull  Long transactionId,@ApiParam(value = "The device id (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "The account id of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "If true then include mission data, false to not include", defaultValue = "false") @DefaultValue("false") @QueryParam("includeMission")  Boolean includeMission,@ApiParam(value = "The latitude location of the user") @QueryParam("latitude")  Double latitude,@ApiParam(value = "The latitude location of the user") @QueryParam("longitude")  Double longitude,@ApiParam(value = "Determines whether to return a detailed version of the response", defaultValue = "true") @DefaultValue("true") @QueryParam("returnFullResponse")  Boolean returnFullResponse,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getOfferTransaction(version, transactionId, deviceId, accountId, includeMission, latitude, longitude, returnFullResponse, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/offer/status/get")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Get Offer Status", notes = "Get an offer status record", response = OfferTransactionStatusResponse.class, tags={ "Offer Status", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = OfferTransactionStatusResponse.class)
    })
    public Response getOfferTransactionStatus(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The id of the record to get ", required = true) @QueryParam("statusId") @NotNull  Long statusId,@ApiParam(value = "The device id (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "The account id of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "Used to update the user's current location") @QueryParam("latitude")  Double latitude,@ApiParam(value = "Used to update the user's current location") @QueryParam("longitude")  Double longitude,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getOfferTransactionStatus(version, statusId, deviceId, accountId, latitude, longitude, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/retailer/offer/search")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Search Offers", notes = "Searches on offers that the account has access to.", response = OfferResponse.class, responseContainer = "List", tags={ "Offer", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = OfferResponse.class, responseContainer = "List")
    })
    public Response getOffersForRetailers(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "", required = true, allowableValues="PUBLIC, LISTABLE, REWARDABLE, TRIGGERABLE, PRIVATE") @QueryParam("offerVisibility") @NotNull  String offerVisibility,@ApiParam(value = "The column to sort the search on. Possible values include: ID, CREATED, UPDATED, ACTIVE, ACTIVATED, EXPIRES, TITLE, SUBTITLE, DETAILS, OFFER_TYPE, SPECIAL_OFFER_TYPE, OFFER_VISIBILITY, ESTIMATED_VALUE, VOUCHER_PRICE, RETAILER_ID, RETAILER_NAME, RETAILER_LOCATION_ID, RETAILER_LOCATION_NAME, BILLABLE_ENTITY_ID, BILLABLE_ENTITY_NAME, RESPONSIBLE_DISPLAY", required = true, allowableValues="ID, CREATED, UPDATED, DELETED, SEARCH_TAGS, ACTIVE, ACTIVATED, EXPIRES, REDEEMABLE_START, REDEEMABLE_END, TITLE, SUBTITLE, DETAILS, OFFER_TYPE, SPECIAL_OFFER_TYPE, OFFER_VISIBILITY, ESTIMATED_VALUE, VOUCHER_PRICE, VOUCHER_DISCOUNT_PRICE, FULL_PRICE, DICOUNT_PRICE, TICKETS_REWARD, AVAILABILITY_DATE, RELEASE_DATE, RETAILER_ID, RETAILER_NAME, RETAILER_LOCATION_ID, RETAILER_LOCATION_NAME, BILLABLE_ENTITY_ID, BILLABLE_ENTITY_NAME, RESPONSIBLE_DISPLAY") @QueryParam("sortField") @NotNull  String sortField,@ApiParam(value = "The order to return the search results", required = true) @QueryParam("descending") @NotNull  Boolean descending,@ApiParam(value = "The record to begin the return set on", required = true) @QueryParam("start") @NotNull  Integer start,@ApiParam(value = "The number of records to return", required = true) @QueryParam("limit") @NotNull  Integer limit,@ApiParam(value = "Return only results that are currently being promoted (is activated and not expired)", required = true) @QueryParam("availableOnly") @NotNull  Boolean availableOnly,@ApiParam(value = "Return only active results", required = true) @QueryParam("activeOnly") @NotNull  Boolean activeOnly,@ApiParam(value = "", required = true) @QueryParam("includeCategories") @NotNull  Boolean includeCategories,@ApiParam(value = "", required = true) @QueryParam("includeFilters") @NotNull  Boolean includeFilters,@ApiParam(value = "", required = true) @QueryParam("includeOfferLocations") @NotNull  Boolean includeOfferLocations,@ApiParam(value = "The device id (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "The account id of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "") @QueryParam("categoryIds")  String categoryIds,@ApiParam(value = "") @QueryParam("filterIds")  String filterIds,@ApiParam(value = "This parameter is deprecated.") @QueryParam("q")  String q,@ApiParam(value = "The keyword used to search") @QueryParam("keyword")  String keyword,@ApiParam(value = "the id of the retailer") @QueryParam("retailerId")  Long retailerId,@ApiParam(value = "the id of the retailer location") @QueryParam("retailerLocationId")  Long retailerLocationId,@ApiParam(value = "This parameter is deprecated.", allowableValues="VOUCHER, COUPON, PRODUCT, MEDIA, EVENT, DEVICE") @QueryParam("couponType")  String couponType,@ApiParam(value = "This parameter is deprecated. Use offer types. Filter results to only return COUPON, VOUCHER, PRODUCT, MEDIA, or EVENT offers", allowableValues="VOUCHER, COUPON, PRODUCT, MEDIA, EVENT, DEVICE") @QueryParam("offerType")  String offerType,@ApiParam(value = "Comma separated list of offer types {COUPON, VOUCHER, PRODUCT, MEDIA, EVENT, DEVICE}") @QueryParam("offerTypes")  String offerTypes,@ApiParam(value = "Filter results to only return REGULAR_OFFER, ACT_NOW, GET_THERE_NOW offer specials", allowableValues="ALL, RESERVABLE, REGULAR_OFFER, ACT_NOW, GET_THERE_NOW, SQOOT, TICKETS, YIPIT") @QueryParam("specialOfferType")  String specialOfferType,@ApiParam(value = "This parameter is deprecated.") @QueryParam("_i")  Integer i,@ApiParam(value = "This parameter is deprecated.") @QueryParam("_l")  Integer l,@ApiParam(value = "") @QueryParam("barcodeType")  String barcodeType,@ApiParam(value = "") @QueryParam("barcodeEntry")  String barcodeEntry,@ApiParam(value = "") @QueryParam("isbn")  String isbn,@ApiParam(value = "") @QueryParam("asin")  String asin,@ApiParam(value = "Edysen device status", allowableValues="RUNNING, WARNING, DOWN") @QueryParam("deviceStatus")  String deviceStatus,@ApiParam(value = "") @QueryParam("needsNotificationSent")  Boolean needsNotificationSent,@ApiParam(value = "") @QueryParam("lastNotificationSent")  Long lastNotificationSent,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getOffersForRetailers(version, offerVisibility, sortField, descending, start, limit, availableOnly, activeOnly, includeCategories, includeFilters, includeOfferLocations, deviceId, accountId, categoryIds, filterIds, q, keyword, retailerId, retailerLocationId, couponType, offerType, offerTypes, specialOfferType, i, l, barcodeType, barcodeEntry, isbn, asin, deviceStatus, needsNotificationSent, lastNotificationSent, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/optimize/result/{batchID}")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Get Optimization Result", notes = "Get the results of the import batch.", response = ShipmentOrder.class, responseContainer = "Map", tags={ "Optimize", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = ShipmentOrder.class, responseContainer = "Map")
    })
    public Response getOptimizationResult(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The batchID for getting the import status of.", required = true) @PathParam("batchID") @NotNull  String batchID,@ApiParam(value = "The start index for pagination", required = true) @QueryParam("start") @NotNull  Integer start,@ApiParam(value = "The limit for pagination", required = true) @QueryParam("limit") @NotNull  Integer limit,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getOptimizationResult(version, batchID, start, limit, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/order/get")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Get Order", notes = "Get an order record", response = OrderResponse.class, tags={ "Purchase Order", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = OrderResponse.class)
    })
    public Response getOrder(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The device id (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "The account id of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "The order id to get details of, either orderId or externalOrderId must be provided") @QueryParam("orderId")  Long orderId,@ApiParam(value = "The external order id to get details of, either orderId or externalOrderId must be provided") @QueryParam("externalOrderId")  String externalOrderId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getOrder(version, deviceId, accountId, orderId, externalOrderId, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/pack/get")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Get Pack", notes = "Get a pack.", response = PackResponse.class, tags={ "Pack", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = PackResponse.class)
    })
    public Response getPack(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The logged in user.", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "The id of the pack to return.", required = true) @QueryParam("packId") @NotNull  Long packId,@ApiParam(value = "If true include the game level data, otherwise don't. default is false.", required = true) @QueryParam("includeGameData") @NotNull  Boolean includeGameData,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getPack(version, accountId, packId, includeGameData, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/billing/get")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Get Payment Method", notes = "Get the details of the user's payment method or their current default method of payment", response = PaymentTypesResponse.class, tags={ "Billing Info", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = PaymentTypesResponse.class)
    })
    public Response getPaymentMethod(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The account used to perform the the request", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "The payment method to return details on. If this is not set, then the user's default payment method will be returned.") @QueryParam("paymentMethodId")  Long paymentMethodId,@ApiParam(value = "Determines whether to get the user's current balance for the requested payment method option (not all payment method options support this)") @QueryParam("getCurrentBalance")  Boolean getCurrentBalance,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getPaymentMethod(version, accountId, paymentMethodId, getCurrentBalance, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/persona/get")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Get Persona", notes = "Get the persona by the given persona ID. If the persona cannot be found, a invalid response is returned.", response = PreviewPersonaResponse.class, tags={ "Preview Persona", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = PreviewPersonaResponse.class)
    })
    public Response getPersonaList(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the account ID of the user", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "the persona ID of the persona", required = true) @QueryParam("personaId") @NotNull  Long personaId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getPersonaList(version, accountId, personaId, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/vatom/u/campaign/points/get")
    
    
    @io.swagger.annotations.ApiOperation(value = "Get Points Balance", notes = "Gets the points balance of a Vatom user.", response = Void.class, tags={ "Vatom", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = Void.class)
    })
    public Response getPointsBalance(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "Sirqul Account Id", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "Vatom User Id", required = true) @QueryParam("vatomUserId") @NotNull  String vatomUserId,@ApiParam(value = "Vatom Campaign Id", required = true) @QueryParam("vatomCampaignId") @NotNull  String vatomCampaignId,@ApiParam(value = "Return raw response") @QueryParam("returnRawResponse")  Boolean returnRawResponse,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getPointsBalance(version, accountId, vatomUserId, vatomCampaignId, returnRawResponse, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/vatom/b/campaign/u/points/get")
    
    
    @io.swagger.annotations.ApiOperation(value = "Get Points Balance as Business", notes = "Gets the points balance of a Vatom user.", response = Void.class, tags={ "Vatom", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = Void.class)
    })
    public Response getPointsBalanceAsBusiness(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "Sirqul Account Id", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "Sirqul Application Key", required = true) @QueryParam("appKey") @NotNull  String appKey,@ApiParam(value = "Vatom User Id", required = true) @QueryParam("vatomUserId") @NotNull  String vatomUserId,@ApiParam(value = "Vatom Campaign Id", required = true) @QueryParam("vatomCampaignId") @NotNull  String vatomCampaignId,@ApiParam(value = "Return raw response") @QueryParam("returnRawResponse")  Boolean returnRawResponse,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getPointsBalanceAsBusiness(version, accountId, appKey, vatomUserId, vatomCampaignId, returnRawResponse, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/postalCode/get")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Get Postal Code", notes = "Get a Postal Code", response = PostalCodeResponse.class, tags={ "Postal Code", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = PostalCodeResponse.class)
    })
    public Response getPostalCode(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the id of the postal code to get", required = true) @QueryParam("postalCodeId") @NotNull  Long postalCodeId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getPostalCode(version, postalCodeId, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/postalCode/search")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Search Postal Codes", notes = "Get the list of regions. If latitude or longitude is null, will return all postal codes in the system with paginated response.", response = PostalCodeResponse.class, responseContainer = "List", tags={ "Postal Code", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = PostalCodeResponse.class, responseContainer = "List")
    })
    public Response getPostalCodes(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the field to sort the results on", required = true) @QueryParam("sortField") @NotNull  String sortField,@ApiParam(value = "whether to order results in ascending or descending order", required = true) @QueryParam("descending") @NotNull  Boolean descending,@ApiParam(value = "the latitude of the postal code to search on") @QueryParam("latitude")  Double latitude,@ApiParam(value = "the longitude of the postal code to search on") @QueryParam("longitude")  Double longitude,@ApiParam(value = "the keyword of the postal code to search on") @QueryParam("keyword")  String keyword,@ApiParam(value = "how far (in miles) to search on for the postal code") @QueryParam("miles")  Double miles,@ApiParam(value = "the start of the index and/or pagination") @QueryParam("start")  Integer start,@ApiParam(value = "the limit of the index and/or pagination") @QueryParam("limit")  Integer limit,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getPostalCodes(version, sortField, descending, latitude, longitude, keyword, miles, start, limit, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/tracking/predicted/get")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Get Predicted Locations", notes = "Get the predicted location for a customer based on previous behavior.  If a customer resides in a place for a period of time this is marked as a preferred location.  We look back over the previous few days and the previous days of the week from the day specified.  If for instance the day was a Wednesday then this would check the days before, including: Tuesday, Monday, Sunday, etc. It will also check some number of previous Wednesdays in the past few weeks.", response = PredictedLocationResponse.class, tags={ "Tracking", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = PredictedLocationResponse.class)
    })
    public Response getPredictedLocations(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The account id of the customer", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "latitude to return a more likely result set based on the user's current location") @QueryParam("latitude")  Double latitude,@ApiParam(value = "longitude to return a more likely result set based on the user's current location") @QueryParam("longitude")  Double longitude,@ApiParam(value = "Used to specify which day to get predicted locations for. So if you want to look at where they might be tomorrow, pass in tomorrow's date (timestamp in milliseconds). If no value is passed in, the current date will be used.") @QueryParam("dateCheck")  Long dateCheck,@ApiParam(value = "Comma separated list of hours that will filter the results on the hours specified. For example, if you want to see predicted locations for the mornings and evening you can pass in \"8,9,10,11,17,18,19,20\".") @QueryParam("hourCheck")  String hourCheck,@ApiParam(value = "The minimum number matches in 1 hour to be considered a likely location.", defaultValue = "1") @DefaultValue("1") @QueryParam("threshold")  Long threshold,@ApiParam(value = "Determines which unit of measurement gets returned for distances: {MILES, KILOMETERS}", allowableValues="MILES, KILOMETERS", defaultValue = "MILES") @DefaultValue("MILES") @QueryParam("distanceUnit")  String distanceUnit,@ApiParam(value = "Filter results so only locations within the specified radius will be returned. The distance can either be in miles or kilometers as specified in the distanceUnit parameter. A value of \"0\" (zero) will ignore the radius restriction.", defaultValue = "0") @DefaultValue("0") @QueryParam("searchRange")  Double searchRange,@ApiParam(value = "The ordering algorithm for sorting the returned results: {MATCHES, DISTANCE, WEIGHTED}", allowableValues="MATCHES, DISTANCE, WEIGHTED", defaultValue = "MATCHES") @DefaultValue("MATCHES") @QueryParam("sortOrder")  String sortOrder,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getPredictedLocations(version, accountId, latitude, longitude, dateCheck, hourCheck, threshold, distanceUnit, searchRange, sortOrder, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/tracking/path/get")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Get Tracking Path", notes = "Get the path (lat/long coordinates) between 2 steps previously logged for a customer.", response = StepResponse.class, responseContainer = "List", tags={ "Tracking", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = StepResponse.class, responseContainer = "List")
    })
    public Response getPredictedPath(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The account id of the customer", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "The stepId to begin from", required = true) @QueryParam("startStepId") @NotNull  Long startStepId,@ApiParam(value = "The stepId to end with", required = true) @QueryParam("endStepId") @NotNull  Long endStepId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getPredictedPath(version, accountId, startStepId, endStepId, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/tracking/preferred/search")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Search Preferred Locations", notes = "Search on preferred locations for a user, which is created when a customer resides in a place for a period of time.", response = PreferredLocationResponse.class, responseContainer = "List", tags={ "Tracking", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = PreferredLocationResponse.class, responseContainer = "List")
    })
    public Response getPreferredLocations(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The account id of the customer", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "latitude to return a more likely result set based on the user's current location") @QueryParam("latitude")  Double latitude,@ApiParam(value = "longitude to return a more likely result set based on the user's current location") @QueryParam("longitude")  Double longitude,@ApiParam(value = "Used to specify which day to get preferred locations for. So if you want to look at where they might be tomorrow, pass in tomorrow's date (timestamp in milliseconds). If no value is passed in, results from all time will be returned.") @QueryParam("dateCheck")  Long dateCheck,@ApiParam(value = "Comma separated list of hours that will filter the results on the hours specified. For example, if you want to see preferred locations for the mornings and evening you can pass in \"8,9,10,11,17,18,19,20\".") @QueryParam("hourCheck")  String hourCheck,@ApiParam(value = "Specifies how the results will be ordered. Supported values include: CREATED - the time of when the preferred location data was processed. PREFERRED_DATE - the time of when the user sent in the tracking data. HOUR - the hour of when the user sent in the tracking data. DURATION - the duration of the preferred location", defaultValue = "PREFERRED_DATE") @DefaultValue("PREFERRED_DATE") @QueryParam("sortField")  String sortField,@ApiParam(value = "Determines whether the sorted list is in descending or ascending order", defaultValue = "true") @DefaultValue("true") @QueryParam("descending")  Boolean descending,@ApiParam(value = "The start index for pagination", defaultValue = "0") @DefaultValue("0") @QueryParam("start")  Integer start,@ApiParam(value = "The limit for pagination", defaultValue = "20") @DefaultValue("20") @QueryParam("limit")  Integer limit,@ApiParam(value = "Filter results so only locations within the specified radius will be returned. The distance can either be in miles or kilometers as specified in the distanceUnit parameter. A value of \"0\" (zero) will ignore the radius restriction.", defaultValue = "0") @DefaultValue("0") @QueryParam("searchRange")  Double searchRange,@ApiParam(value = "Determines which unit of measurement gets returned for distances: {MILES, KILOMETERS}", allowableValues="MILES, KILOMETERS", defaultValue = "MILES") @DefaultValue("MILES") @QueryParam("distanceUnit")  String distanceUnit,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getPreferredLocations(version, accountId, latitude, longitude, dateCheck, hourCheck, sortField, descending, start, limit, searchRange, distanceUnit, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/account/profile/assets")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Get Profile Assets", notes = "Get a list of assets a person has ever uploaded. Filters the list based on parameters.", response = AssetListResponse.class, tags={ "Account", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = AssetListResponse.class)
    })
    public Response getProfileAssets(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "Determines whether to return null fields in the response", defaultValue = "false") @DefaultValue("false") @QueryParam("returnNulls")  Boolean returnNulls,@ApiParam(value = "The device id (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "The account id of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "The account id of the person the user wants to view") @QueryParam("ownerId")  Long ownerId,@ApiParam(value = "Comma separated list of MediaType") @QueryParam("mediaTypes")  String mediaTypes,@ApiParam(value = "Comma separated list of mime types") @QueryParam("mimeTypes")  String mimeTypes,@ApiParam(value = "Determines what the returning list will be sorted by (see AssetApiMap)", defaultValue = "CREATED") @DefaultValue("CREATED") @QueryParam("sortField")  String sortField,@ApiParam(value = "Determines whether to return the resulting list in descending or ascending order", defaultValue = "true") @DefaultValue("true") @QueryParam("descending")  Boolean descending,@ApiParam(value = "Latitude used to update the user's current location") @QueryParam("latitude")  Double latitude,@ApiParam(value = "Longitude used to update the user's current location") @QueryParam("longitude")  Double longitude,@ApiParam(value = "_i") @QueryParam("_i")  Integer i,@ApiParam(value = "Start of the pagination", defaultValue = "0") @DefaultValue("0") @QueryParam("start")  Integer start,@ApiParam(value = "_l") @QueryParam("_l")  Integer l,@ApiParam(value = "Limit of the pagination", defaultValue = "0") @DefaultValue("0") @QueryParam("limit")  Integer limit,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getProfileAssets(version, returnNulls, deviceId, accountId, ownerId, mediaTypes, mimeTypes, sortField, descending, latitude, longitude, i, start, l, limit, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/program/{id}")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Get Program", notes = "Get an existing program", response = Program.class, tags={ "Program", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = Program.class)
    })
    public Response getProgram(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the id of the program", required = true) @PathParam("id") @NotNull  Long id,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getProgram(version, id, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/purchase/get")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Get Purchase", notes = "Get detailed information about a purchase item", response = PurchaseItemFullResponse.class, tags={ "Purchase Item", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = PurchaseItemFullResponse.class)
    })
    public Response getPurchaseItem(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The purchase item id", required = true) @QueryParam("purchaseItemId") @NotNull  Long purchaseItemId,@ApiParam(value = "The device id (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "The account id of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getPurchaseItem(version, purchaseItemId, deviceId, accountId, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/game/question/get")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Get Question", notes = "Get a question by the given id.", response = QuestionResponse.class, tags={ "Question", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = QuestionResponse.class)
    })
    public Response getQuestion(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the id of the question to get", required = true) @QueryParam("questionId") @NotNull  Long questionId,@ApiParam(value = "the id of the account that can make this request", required = true) @QueryParam("accountId") @NotNull  Long accountId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getQuestion(version, questionId, accountId, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/level/questions/get")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Get Level Questions", notes = "Get questions within a level.", response = QuestionResponse.class, tags={ "Game Level", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = QuestionResponse.class)
    })
    public Response getQuestionsInLevel(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the id of the level to get questions from", required = true) @QueryParam("levelId") @NotNull  Long levelId,@ApiParam(value = "the id of the logged in user", required = true) @QueryParam("accountId") @NotNull  Long accountId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getQuestionsInLevel(version, levelId, accountId, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/ranking/search")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Search Rankings", notes = "Get leader board rankings. This is an all in one endpoint that can return multiple ranking types and also the current user rank.", response = RankFullResponse.class, tags={ "Ranking", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = RankFullResponse.class)
    })
    public Response getRankings(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "a unique id given by the device (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "the account id of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "This parameter is deprecated.") @QueryParam("gameType")  String gameType,@ApiParam(value = "the application key for filtering results by application (required for non-EXECUTIVE users)") @QueryParam("appKey")  String appKey,@ApiParam(value = "This parameter is deprecated.") @QueryParam("q")  String q,@ApiParam(value = "keyword to search for") @QueryParam("keyword")  String keyword,@ApiParam(value = "a comma separated list of rank types to return. Possible default rank types: POINTS, DOWNLOADS, INVITATIONS", defaultValue = "POINTS,DOWNLOADS,INVITATIONS") @DefaultValue("POINTS,DOWNLOADS,INVITATIONS") @QueryParam("rankType")  String rankType,@ApiParam(value = "the type of search to perform. Possible values include: GLOBAL - searches scores globally (all users in the system are included in the ranking) LOCAL - filters results by select users and on users that have logged into the same device CUSTOM - allows for custom filtering using the params: withinAccountIds, albumId, audienceId", defaultValue = "GLOBAL") @DefaultValue("GLOBAL") @QueryParam("leaderboardMode")  String leaderboardMode,@ApiParam(value = "comma separated list of account ids. If performing a LOCAL or CUSTOM search, the query will include these accounts.") @QueryParam("withinAccountIds")  String withinAccountIds,@ApiParam(value = "determines whether to return the user's current rank in the response. This can be turned off for sequential paginated requests.", defaultValue = "true") @DefaultValue("true") @QueryParam("returnUserRank")  Boolean returnUserRank,@ApiParam(value = "album id to use when performing CUSTOM filters") @QueryParam("albumId")  Long albumId,@ApiParam(value = "audience id to use when performing CUSTOM filters") @QueryParam("audienceId")  Long audienceId,@ApiParam(value = "determines how to order and rank the results. Possible values include: TOTAL - order results by total score MONTHLY - order results by monthly score WEEKLY - order results by weekly score DAILY - order results by daily score TOP - order results by top score LOWEST - order results by lowest score", defaultValue = "TOTAL") @DefaultValue("TOTAL") @QueryParam("sortField")  String sortField,@ApiParam(value = "determines whether to return results in ascending or descending order", defaultValue = "true") @DefaultValue("true") @QueryParam("descending")  Boolean descending,@ApiParam(value = "This parameter is deprecated.") @QueryParam("_i")  Integer i,@ApiParam(value = "the start index for pagination", defaultValue = "0") @DefaultValue("0") @QueryParam("start")  Integer start,@ApiParam(value = "This parameter is deprecated.") @QueryParam("_l")  Integer l,@ApiParam(value = "the limit for pagination", defaultValue = "100") @DefaultValue("100") @QueryParam("limit")  Integer limit,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getRankings(version, deviceId, accountId, gameType, appKey, q, keyword, rankType, leaderboardMode, withinAccountIds, returnUserRank, albumId, audienceId, sortField, descending, i, start, l, limit, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/account/referral/list")
    
    
    @io.swagger.annotations.ApiOperation(value = "Search Accounts", notes = "Gets a user's account profile and their referral List.", response = Void.class, tags={ "Account", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = Void.class)
    })
    public Response getReferralList(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The account id of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "The application key") @QueryParam("appKey")  String appKey,@ApiParam(value = "one of these option - GET_CHILDREN will get all accounts that had signed up using the current account invite link - GET_ANCESTOR will get all accounts that referred the current account and it's parents, recursively - GET_ALL will get all of the above") @QueryParam("retrieveType")  String retrieveType,@ApiParam(value = "level limit for children and ancestors of current account, starts from current account") @QueryParam("levelLimit")  BigDecimal levelLimit,@ApiParam(value = "level limit for ancestors, will override levelLimit if this is set") @QueryParam("ancestorLevelLimit")  BigDecimal ancestorLevelLimit,@ApiParam(value = "level limit for children, will override levelLimit if this is set") @QueryParam("childrenLevelLimit")  BigDecimal childrenLevelLimit,@ApiParam(value = "pagination start for children list") @QueryParam("ancestorListStart")  BigDecimal ancestorListStart,@ApiParam(value = "pagination limit for children list") @QueryParam("ancestorListLimit")  BigDecimal ancestorListLimit,@ApiParam(value = "pagination start for children list") @QueryParam("childrenListStart")  BigDecimal childrenListStart,@ApiParam(value = "pagination limit for children list") @QueryParam("childrenListLimit")  BigDecimal childrenListLimit,@ApiParam(value = "if true, on each item in ancestor and children list, return the childrenTotalNumber and ancestorTotalNumber for that item", defaultValue = "true") @DefaultValue("true") @QueryParam("childrenChildren")  Boolean childrenChildren,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getReferralList(version, accountId, appKey, retrieveType, levelLimit, ancestorLevelLimit, childrenLevelLimit, ancestorListStart, ancestorListLimit, childrenListStart, childrenListLimit, childrenChildren, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/region/get")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Get Region", notes = "Get a region.", response = RegionResponse.class, tags={ "Region", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = RegionResponse.class)
    })
    public Response getRegion(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the id of the region to get", required = true) @QueryParam("regionId") @NotNull  Long regionId,@ApiParam(value = "the id of the logged in user") @QueryParam("accountId")  Long accountId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getRegion(version, regionId, accountId, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/orson/stories/renders/{renderId}/status")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Check episode status", notes = "Gets a summary of the episode's status, including any renders.", response = OrsonRenderResponse.class, tags={ "Orson", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = OrsonRenderResponse.class)
    })
    public Response getRenderStatus(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "Render ID", required = true) @PathParam("renderId") @NotNull  String renderId,@ApiParam(value = "Sirqul Account Id", required = true) @QueryParam("accountId") @NotNull  Long accountId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getRenderStatus(version, renderId, accountId, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/report/batch/get")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Get Offline Report", notes = "Checks status of batch report.", response = ReportBatchResponse.class, tags={ "Reporting", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = ReportBatchResponse.class)
    })
    public Response getReportBatch(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the id of the logged in user", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "returned by /report/batch/create", required = true) @QueryParam("batchId") @NotNull  Long batchId,@ApiParam(value = "whether to return all batch results or not", required = true) @QueryParam("allResults") @NotNull  Boolean allResults,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getReportBatch(version, accountId, batchId, allResults, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/retailer/get")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Get Retailer", notes = "Gets a retailer. Only the owner and the employees of a retailer have access to view its information.", response = RetailerFullResponse.class, tags={ "Retailer", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = RetailerFullResponse.class)
    })
    public Response getRetailer(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the ID of the retailer", required = true) @QueryParam("retailerId") @NotNull  Long retailerId,@ApiParam(value = "the device id (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "the account id of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "Determines whether to include counts in the response (default true)") @QueryParam("includeCounts")  Boolean includeCounts,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getRetailer(version, retailerId, deviceId, accountId, includeCounts, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/retailer/location/get")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Get Retailer Location", notes = "Gets a retailer location. Only the owner and the employees of the retailer have access to view its information.", response = RetailerLocationResponse.class, tags={ "Retailer Location", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = RetailerLocationResponse.class)
    })
    public Response getRetailerLocation(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The ID of the retailer location", required = true) @QueryParam("retailerLocationId") @NotNull  Long retailerLocationId,@ApiParam(value = "The device id (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "The account id of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "the unique token of the retailer location") @QueryParam("retailerLocationToken")  String retailerLocationToken,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getRetailerLocation(version, retailerLocationId, deviceId, accountId, retailerLocationToken, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/location/get")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Get Retailer Location (Consumer)", notes = "Gets the details of a retailer location as a consumer.", response = RetailerLocationResponse.class, tags={ "Retailer Location", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = RetailerLocationResponse.class)
    })
    public Response getRetailerLocationConsumer(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The retailer location id", required = true) @QueryParam("retailerLocationId") @NotNull  Long retailerLocationId,@ApiParam(value = "The device id for returning account information (i.e. favorites)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "The account id for returning account information (i.e. favorites)") @QueryParam("accountId")  Long accountId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getRetailerLocationConsumer(version, retailerLocationId, deviceId, accountId, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/retailer/search")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Search Retailers", notes = "earches on retailers that the account has access to.", response = RetailerResponse.class, responseContainer = "List", tags={ "Retailer", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = RetailerResponse.class, responseContainer = "List")
    })
    public Response getRetailers(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "", required = true, allowableValues="PUBLIC, PRIVATE, FRIENDS") @QueryParam("visibility") @NotNull  String visibility,@ApiParam(value = "The column to sort the search on", required = true, allowableValues="ID, CREATED, UPDATED, DELETED, SEARCH_TAGS, ACTIVE, BILLABLE_ENTITY_ID, BILLABLE_ENTITY_NAME, RESPONSIBLE_DISPLAY, ADDRESS_STREET, ADDRESS_CITY, ADDRESS_STATE, ADDRESS_POSTAL_CODE, ADDRESS_COUNTRY, FILTERS, CATEGORIES, VISIBILITY, NAME") @QueryParam("sortField") @NotNull  String sortField,@ApiParam(value = "The order to return the search results", required = true) @QueryParam("descending") @NotNull  Boolean descending,@ApiParam(value = "The record to begin the return set on", required = true) @QueryParam("start") @NotNull  Integer start,@ApiParam(value = "The number of records to return", required = true) @QueryParam("limit") @NotNull  Integer limit,@ApiParam(value = "Return only active results", required = true) @QueryParam("activeOnly") @NotNull  Boolean activeOnly,@ApiParam(value = "The device id (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "The account id of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "This parameter is deprecated.") @QueryParam("q")  String q,@ApiParam(value = "The keyword used to search") @QueryParam("keyword")  String keyword,@ApiParam(value = "the categories that the retailer is associated with") @QueryParam("categoryIds")  String categoryIds,@ApiParam(value = "the filters that the retailer is associated with") @QueryParam("filterIds")  String filterIds,@ApiParam(value = "This parameter is deprecated.") @QueryParam("_i")  Integer i,@ApiParam(value = "This parameter is deprecated.") @QueryParam("_l")  Integer l,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getRetailers(version, visibility, sortField, descending, start, limit, activeOnly, deviceId, accountId, q, keyword, categoryIds, filterIds, i, l, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/retailer")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Get Retailer", notes = "Gets a retailer. Only the owner and the employees of a retailer have access to view its information.", response = SirqulResponse.class, tags={ "Retailer V2", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response getRetaokiler(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the id of the retailer", required = true) @QueryParam("retailerId") @NotNull  Long retailerId,@ApiParam(value = "whether to return results that are active only or all", required = true, defaultValue = "true") @DefaultValue("true") @QueryParam("activeOnly") @NotNull  Boolean activeOnly,@ApiParam(value = "the keyword to search on to get retailer") @QueryParam("keyword")  String keyword,@ApiParam(value = "the field to sort on", defaultValue = "id") @DefaultValue("id") @QueryParam("sortField")  String sortField,@ApiParam(value = "the start of the index and/or pagination", defaultValue = "0") @DefaultValue("0") @QueryParam("start")  Long start,@ApiParam(value = "the limit of the index and/or pagination", defaultValue = "20") @DefaultValue("20") @QueryParam("limit")  Long limit,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getRetaokiler(version, retailerId, activeOnly, keyword, sortField, start, limit, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/route/{routeId}")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Get Route", notes = "Get an existing route", response = Route.class, tags={ "Route", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = Route.class)
    })
    public Response getRoute(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the id of the route to get", required = true) @PathParam("routeId") @NotNull  Long routeId,@ApiParam(value = "return inherited properties from parent or not", required = true) @QueryParam("showInheritedProperties") @NotNull  Boolean showInheritedProperties,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getRoute(version, routeId, showInheritedProperties, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/route/{routeId}/directions")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Get Route Directions", notes = "Get the directions of a route", response = Direction.class, responseContainer = "List", tags={ "Route", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = Direction.class, responseContainer = "List")
    })
    public Response getRouteDirections(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the id of the route to get directions for", required = true) @PathParam("routeId") @NotNull  Long routeId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getRouteDirections(version, routeId, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/route/setting/{routeSettingsId}")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Get Route Setting", notes = "Get an existing route settings", response = RouteSettings.class, tags={ "Route Setting", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = RouteSettings.class)
    })
    public Response getRouteSettings(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the id of the route settings to get", required = true) @PathParam("routeSettingsId") @NotNull  Long routeSettingsId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getRouteSettings(version, routeSettingsId, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/route/{routeId}/shipments")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Get Route Shipments", notes = "Get the shipments on the requested route", response = Shipment.class, responseContainer = "List", tags={ "Route", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = Shipment.class, responseContainer = "List")
    })
    public Response getRouteShipments(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the id of the route to get shipments for", required = true) @PathParam("routeId") @NotNull  Long routeId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getRouteShipments(version, routeId, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/route/{routeId}/stop/{stopId}")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Get Route Stop", notes = "Get the specific stop on a route", response = Stop.class, tags={ "Route", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = Stop.class)
    })
    public Response getRouteStop(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the id of the route to get stops for", required = true) @PathParam("routeId") @NotNull  Long routeId,@ApiParam(value = "the id of the specific stop on the route", required = true) @PathParam("stopId") @NotNull  Long stopId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getRouteStop(version, routeId, stopId, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/route/{routeId}/stops")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Get Route Stops", notes = "The stops of the route requested", response = Stop.class, responseContainer = "List", tags={ "Route", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = Stop.class, responseContainer = "List")
    })
    public Response getRouteStops(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the id of the route", required = true) @PathParam("routeId") @NotNull  Long routeId,@ApiParam(value = "only get stops that have been confirmed or not", required = true) @QueryParam("confirmedOnly") @NotNull  Boolean confirmedOnly,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getRouteStops(version, routeId, confirmedOnly, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/orson/ai/stt/{requestId}")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Get Speach to Text Result", notes = "The results of the video transcription and optional translation.", response = OrsonAiSTTResponse.class, tags={ "Orson", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = OrsonAiSTTResponse.class)
    })
    public Response getSTT(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "Orson Request Id", required = true) @PathParam("requestId") @NotNull  String requestId,@ApiParam(value = "Sirqul Account Id", required = true) @QueryParam("accountId") @NotNull  Long accountId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getSTT(version, requestId, accountId, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/notification/schedule/get")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Get Scheduled Notification", notes = "Get a ScheduledNotification", response = ScheduledNotificationFullResponse.class, tags={ "Scheduled Notification", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = ScheduledNotificationFullResponse.class)
    })
    public Response getScheduledNotification(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the id of the account logged in", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "the id of the scheduled notification to get", required = true) @QueryParam("scheduledNotificationId") @NotNull  Long scheduledNotificationId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getScheduledNotification(version, accountId, scheduledNotificationId, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/score/get")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Get Score", notes = "Get the high score for an item.  Pass in the full path IDs for the score.", response = ScoreResponse.class, tags={ "Score", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = ScoreResponse.class)
    })
    public Response getScore(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The logged in user.", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "The game application key to get the level for.", required = true) @QueryParam("appKey") @NotNull  String appKey,@ApiParam(value = "The missionId to score for, null if not playing mission.") @QueryParam("missionId")  Long missionId,@ApiParam(value = "The gameId to score for, null if not playing mission.") @QueryParam("gameId")  Long gameId,@ApiParam(value = "The packId to score for, null if playing community levels.") @QueryParam("packId")  Long packId,@ApiParam(value = "The gameLevelId to score for.") @QueryParam("gameLevelId")  Long gameLevelId,@ApiParam(value = "The gameObjectId to score for, null if level based scoring.") @QueryParam("gameObjectId")  Long gameObjectId,@ApiParam(value = "The object type to filter scores by (TicketObjectType)") @QueryParam("scoreObjectType")  String scoreObjectType,@ApiParam(value = "The status of the score to filter (ScoreStatus)") @QueryParam("scoreStatus")  String scoreStatus,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getScore(version, accountId, appKey, missionId, gameId, packId, gameLevelId, gameObjectId, scoreObjectType, scoreStatus, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/hub/{id}")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Get Service Hub", notes = "Get an existing service hub", response = Object.class, tags={ "Service Hub", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = Object.class)
    })
    public Response getServiceHub(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the id of the service hub to get", required = true) @PathParam("id") @NotNull  Long id,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getServiceHub(version, id, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/account/settings/get")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Get Account Settings", notes = "Get the account settings for a user", response = UserSettingsResponse.class, tags={ "Account", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = UserSettingsResponse.class)
    })
    public Response getSettings(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The device id (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "The account id of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "The current latitude of the user") @QueryParam("latitude")  Double latitude,@ApiParam(value = "The current longitude of the user") @QueryParam("longitude")  Double longitude,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getSettings(version, deviceId, accountId, latitude, longitude, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/shipment/{id}")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Get Shipment", notes = "Get an existing shipment", response = Shipment.class, tags={ "Shipment", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = Shipment.class)
    })
    public Response getShipment(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the id of the shipment to get", required = true) @PathParam("id") @NotNull  Long id,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getShipment(version, id, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/shipment/batch/{batchId}")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Get Shipment Batch", notes = "Get an existing shipment batch", response = ShipmentBatch.class, tags={ "Shipment Batch", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = ShipmentBatch.class)
    })
    public Response getShipmentBatch(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the id of the shipment batch to get", required = true) @PathParam("batchId") @NotNull  Long batchId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getShipmentBatch(version, batchId, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/shipment/batch/{batchId}/status")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Get Shipment Batch Status", notes = "Get the import status list of the import shipment batch", response = ShipmentImportStatus.class, responseContainer = "List", tags={ "Shipment Batch", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = ShipmentImportStatus.class, responseContainer = "List")
    })
    public Response getShipmentBatchStatus(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The id of the requested shipment batch", required = true) @PathParam("batchId") @NotNull  Long batchId,@ApiParam(value = "the id of the logged in user", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "The field to sort by", required = true) @QueryParam("sortField") @NotNull  String sortField,@ApiParam(value = "Determines whether the sorted list is in descending or ascending order", required = true) @QueryParam("descending") @NotNull  Boolean descending,@ApiParam(value = "The start index for pagination", required = true) @QueryParam("start") @NotNull  Integer start,@ApiParam(value = "The limit for pagination", required = true) @QueryParam("limit") @NotNull  Integer limit,@ApiParam(value = "Valid import status only or not") @QueryParam("valid")  Boolean valid,@ApiParam(value = "Started import status only") @QueryParam("started")  Boolean started,@ApiParam(value = "Completed import status only") @QueryParam("completed")  Boolean completed,@ApiParam(value = "Has shipment associate to the status") @QueryParam("hasShipment")  Boolean hasShipment,@ApiParam(value = "Has route associate to the status") @QueryParam("hasRoute")  Boolean hasRoute,@ApiParam(value = "The keyword to search for") @QueryParam("keyword")  String keyword,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getShipmentBatchStatus(version, batchId, accountId, sortField, descending, start, limit, valid, started, completed, hasShipment, hasRoute, keyword, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/route/{routeId}/stop/{stopId}/shipments")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Get Shipments At Stop", notes = "Get the list of shipments on the requested route at a stop", response = Shipment.class, responseContainer = "List", tags={ "Route", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = Shipment.class, responseContainer = "List")
    })
    public Response getShipmentsAtStop(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the id of the route", required = true) @PathParam("routeId") @NotNull  Long routeId,@ApiParam(value = "the id of the stop to get shipments on", required = true) @PathParam("stopId") @NotNull  Long stopId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getShipmentsAtStop(version, routeId, stopId, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/vatom/b/spaces/get")
    
    
    @io.swagger.annotations.ApiOperation(value = "Get Vatom Space", notes = "Gets the details of a space.", response = Void.class, tags={ "Vatom", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = Void.class)
    })
    public Response getSpace(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "Sirqul Account Id", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "Sirqul Application Key", required = true) @QueryParam("appKey") @NotNull  String appKey,@ApiParam(value = "Vatom Space Id", required = true) @QueryParam("vatomSpaceId") @NotNull  String vatomSpaceId,@ApiParam(value = "Return raw response") @QueryParam("returnRawResponse")  Boolean returnRawResponse,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getSpace(version, accountId, appKey, vatomSpaceId, returnRawResponse, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/csvimport/batch/status/details")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Detail Status", notes = "", response = SirqulResponse.class, tags={ "CSV Import", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response getStatusCSV(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the id of the logged in user", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "the id of the batch", required = true) @QueryParam("batchId") @NotNull  Long batchId,@ApiParam(value = "The group of categories to return: SUMMARY, DETAILS, ERRORS, OR ALL", required = true, allowableValues="SUMMARY, DETAILS, ERRORS, ALL") @QueryParam("responseGroup") @NotNull  String responseGroup,@ApiParam(value = "the start of the pagination", required = true) @QueryParam("start") @NotNull  Long start,@ApiParam(value = "the limit of the pagination", required = true) @QueryParam("limit") @NotNull  Long limit,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getStatusCSV(version, accountId, batchId, responseGroup, start, limit, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/stop/{id}")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Get Stop", notes = "Get an existing stop", response = Stop.class, tags={ "Stop", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = Stop.class)
    })
    public Response getStop(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the id of the stop to get", required = true) @PathParam("id") @NotNull  Long id,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getStop(version, id, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/subscription/get")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Get Subscription", notes = "Use the accountId to determine the associated BillableEntity.  Then get the subscription.", response = SubscriptionResponse.class, tags={ "Subscription", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SubscriptionResponse.class)
    })
    public Response getSubscription(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The account used to perform the lookup", required = true) @QueryParam("accountId") @NotNull  Long accountId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getSubscription(version, accountId, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/subscription/plan/get")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Get Subscription Plan", notes = "Get the matched subscription plan", response = SubscriptionPlanResponse.class, tags={ "Subscription", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SubscriptionPlanResponse.class)
    })
    public Response getSubscriptionPlan(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The ID of the plan to get", required = true) @QueryParam("planId") @NotNull  Long planId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getSubscriptionPlan(version, planId, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/subscription/plan/list")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "List Subscription Plans", notes = "Get the matched subscription plan", response = SubscriptionPlanResponse.class, responseContainer = "List", tags={ "Subscription", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SubscriptionPlanResponse.class, responseContainer = "List")
    })
    public Response getSubscriptionPlans(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "Include visible only (true), hidden only (false), or all (null)") @QueryParam("visible")  Boolean visible,@ApiParam(value = "The role the plan is targeted for, values are: DEVELOPER, RETAILER, ADVERTISER") @QueryParam("role")  String role,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getSubscriptionPlans(version, visible, role, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/subscription/usage/get")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Get Subscription Usage", notes = "Use the accountId to determine the associated BillableEntity.  Then get the application usage.", response = ApplicationUsageResponse.class, tags={ "Subscription", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = ApplicationUsageResponse.class)
    })
    public Response getSubscriptionUsage(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The account used to perform the lookup", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "Get for just 1 application instead of the BillableEntity") @QueryParam("applicationId")  Long applicationId,@ApiParam(value = "The start time frame") @QueryParam("start")  Long start,@ApiParam(value = "The end time frame") @QueryParam("end")  Long end,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getSubscriptionUsage(version, accountId, applicationId, start, end, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/orson/ai/tts/{requestId}")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Get Text to Speach Result", notes = "Check the status of an in progress Text-to-Speech call or download the result.", response = OrsonAiTTSResponse.class, tags={ "Orson", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = OrsonAiTTSResponse.class)
    })
    public Response getTTS(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "Orson Request Id", required = true) @PathParam("requestId") @NotNull  String requestId,@ApiParam(value = "Sirqul Account Id", required = true) @QueryParam("accountId") @NotNull  Long accountId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getTTS(version, requestId, accountId, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/task/get")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Get Task", notes = "Get a Task", response = TaskResponse.class, tags={ "Task", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = TaskResponse.class)
    })
    public Response getTask(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The logged in user.", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "The id of the Task to return.", required = true) @QueryParam("taskId") @NotNull  Long taskId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getTask(version, accountId, taskId, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/orson/ai/techTune/{requestId}")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Get TechTune Results", notes = "Get a result or continue waiting for a pending request for TechTune analysis.", response = OrsonAiTechTuneResponse.class, tags={ "Orson", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = OrsonAiTechTuneResponse.class)
    })
    public Response getTechTune(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "Orson Request Id", required = true) @PathParam("requestId") @NotNull  String requestId,@ApiParam(value = "Sirqul Account Id", required = true) @QueryParam("accountId") @NotNull  Long accountId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getTechTune(version, requestId, accountId, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/territory/get")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Get Territory", notes = "Get a territory.", response = TerritoryResponse.class, tags={ "Territory", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = TerritoryResponse.class)
    })
    public Response getTerritory(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the id of the territory to get", required = true) @QueryParam("territoryId") @NotNull  Long territoryId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getTerritory(version, territoryId, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/consumer/theme/get")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Get Theme", notes = "Gets a theme.", response = PurchaseItemListResponse.class, tags={ "Theme Descriptor", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = PurchaseItemListResponse.class)
    })
    public Response getThemeDescriptor(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the theme id", required = true) @QueryParam("themeDescriptorId") @NotNull  Long themeDescriptorId,@ApiParam(value = "a unique ID given by the device (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "the account ID of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "the application key") @QueryParam("gameType")  String gameType,@ApiParam(value = "latitude used to update the user's current location") @QueryParam("latitude")  Double latitude,@ApiParam(value = "longitude used to update the user's current location") @QueryParam("longitude")  Double longitude,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getThemeDescriptor(version, themeDescriptorId, deviceId, accountId, gameType, latitude, longitude, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/consumer/theme/search")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Search Themes", notes = "Searches for themes.", response = PurchaseItemListResponse.class, tags={ "Theme Descriptor", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = PurchaseItemListResponse.class)
    })
    public Response getThemeDescriptors(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "a comma separated list of Ownership", required = true) @QueryParam("filter") @NotNull  String filter,@ApiParam(value = "the field to sort by. See ThemeDescriptorApiMap", required = true) @QueryParam("sortField") @NotNull  String sortField,@ApiParam(value = "determines whether the sorted list is in descending or ascending order", required = true) @QueryParam("descending") @NotNull  Boolean descending,@ApiParam(value = "the start parameter for pagination", required = true) @QueryParam("start") @NotNull  Integer start,@ApiParam(value = "the limit parameter for pagination", required = true) @QueryParam("limit") @NotNull  Integer limit,@ApiParam(value = "a unique id given by the device (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "the account id of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "the unique title of an application given from the admin tool") @QueryParam("gameType")  String gameType,@ApiParam(value = "contest type") @QueryParam("contestType")  String contestType,@ApiParam(value = "search on contests that an account has access to") @QueryParam("ownerId")  Long ownerId,@ApiParam(value = "This parameter is deprecated.") @QueryParam("q")  String q,@ApiParam(value = "a keyword to search on") @QueryParam("keyword")  String keyword,@ApiParam(value = "This parameter is deprecated.") @QueryParam("_i")  Integer i,@ApiParam(value = "This parameter is deprecated.") @QueryParam("_l")  Integer l,@ApiParam(value = "filter on items that have been created before this date") @QueryParam("dateCreated")  Long dateCreated,@ApiParam(value = "application version of the theme to filter by") @QueryParam("appVersion")  String appVersion,@ApiParam(value = "latitude used to update the user's current location") @QueryParam("latitude")  Double latitude,@ApiParam(value = "longitude used to update the user's current location") @QueryParam("longitude")  Double longitude,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getThemeDescriptors(version, filter, sortField, descending, start, limit, deviceId, accountId, gameType, contestType, ownerId, q, keyword, i, l, dateCreated, appVersion, latitude, longitude, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/ticket/count")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Get Ticket Count", notes = "Gets the ticket count.", response = CountResponse.class, tags={ "Ticket", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = CountResponse.class)
    })
    public Response getTicketCount(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the id of the device that owns the tickets") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "the id of the account that owns the tickets") @QueryParam("accountId")  Long accountId,@ApiParam(value = "this is deprecated.") @QueryParam("gameType")  String gameType,@ApiParam(value = "the applicationkey") @QueryParam("appKey")  String appKey,@ApiParam(value = "the type of ticket") @QueryParam("ticketType")  String ticketType,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getTicketCount(version, deviceId, accountId, gameType, appKey, ticketType, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/ticket/getList")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Get Ticket List", notes = "Gets the list of tickets.", response = TicketListResponse.class, tags={ "Ticket", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = TicketListResponse.class)
    })
    public Response getTicketList(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the id of the device that owns the tickets") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "the id of the account that owns the tickets") @QueryParam("accountId")  Long accountId,@ApiParam(value = "comma separated list of TicketObjectType") @QueryParam("ticketObjectType")  String ticketObjectType,@ApiParam(value = "comma separated list of TicketActionType") @QueryParam("actionType")  String actionType,@ApiParam(value = "the ids of the tickets to get") @QueryParam("ticketIds")  String ticketIds,@ApiParam(value = "the ids of the objects to get") @QueryParam("objectIds")  String objectIds,@ApiParam(value = "") @QueryParam("receiptTokens")  String receiptTokens,@ApiParam(value = "") @QueryParam("gameType")  String gameType,@ApiParam(value = "the application key") @QueryParam("appKey")  String appKey,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getTicketList(version, deviceId, accountId, ticketObjectType, actionType, ticketIds, objectIds, receiptTokens, gameType, appKey, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/facebook/getfbtoken")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Get Facebook Token", notes = "Gets a user's Facebook token.", response = TokenResponse.class, tags={ "Facebook", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = TokenResponse.class)
    })
    public Response getToken(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "a unique id given by the device (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "the account id of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "used to update the user's current location") @QueryParam("latitude")  Double latitude,@ApiParam(value = "used to update the user's current location") @QueryParam("longitude")  Double longitude,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getToken(version, deviceId, accountId, latitude, longitude, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/orson/ai/topics/{requestId}")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Get Topics", notes = "Get the result of an in progress Topics Analysis from an earlier POST.", response = OrsonAiTopicsResponse.class, tags={ "Orson", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = OrsonAiTopicsResponse.class)
    })
    public Response getTopics(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "Orson Request Id", required = true) @PathParam("requestId") @NotNull  String requestId,@ApiParam(value = "Sirqul Account Id", required = true) @QueryParam("accountId") @NotNull  Long accountId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getTopics(version, requestId, accountId, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/tournament/get")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Get Tournament", notes = "Get a tournament.", response = TournamentResponse.class, tags={ "Tournament", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = TournamentResponse.class)
    })
    public Response getTournament(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The id of the logged in user", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "The id of the mission to return (either missionId or joinCode is required)") @QueryParam("missionId")  Long missionId,@ApiParam(value = "Optional identifier for getting the tournament (either missionId or joinCode is required)") @QueryParam("joinCode")  String joinCode,@ApiParam(value = "Determines which type of scores are returned. Possible values include: ALL, MINE", allowableValues="ALL, MINE") @QueryParam("includeScores")  String includeScores,@ApiParam(value = "Determines the max number of game objects that will get returned for each game level response", defaultValue = "50") @DefaultValue("50") @QueryParam("objectPreviewSize")  Integer objectPreviewSize,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getTournament(version, accountId, missionId, joinCode, includeScores, objectPreviewSize, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/tracking/search")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Search Tracking", notes = "Retrieve tracking data to be able to show where a user has been.", response = LegResponse.class, responseContainer = "List", tags={ "Tracking", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = LegResponse.class, responseContainer = "List")
    })
    public Response getTrackingLegs(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the device id (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "the account id of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "the account id of the person the user wants to tracking data for") @QueryParam("ownerId")  Long ownerId,@ApiParam(value = "the id of the tracking device") @QueryParam("trackingDeviceId")  String trackingDeviceId,@ApiParam(value = "the start date in (UTC milliseconds) to filter the tracking results. If no startDate is passed in, the last 30 days will be returned.") @QueryParam("startDate")  Long startDate,@ApiParam(value = "the end date in (UTC milliseconds) to filter the tracking results") @QueryParam("endDate")  Long endDate,@ApiParam(value = "filter results by tag") @QueryParam("tags")  String tags,@ApiParam(value = "gets the last known location of the user", defaultValue = "false") @DefaultValue("false") @QueryParam("getLastPoint")  Boolean getLastPoint,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getTrackingLegs(version, deviceId, accountId, ownerId, trackingDeviceId, startDate, endDate, tags, getLastPoint, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/trigger/get")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Get Trigger", notes = "Get a trigger", response = TriggerResponse.class, tags={ "Trigger", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = TriggerResponse.class)
    })
    public Response getTrigger(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The logged in user.", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "The id of the Trigger to return.", required = true) @QueryParam("triggerId") @NotNull  Long triggerId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getTrigger(version, accountId, triggerId, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/trip/{id}")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Get Trip", notes = "Get an existing trip", response = Trip.class, tags={ "Trip", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = Trip.class)
    })
    public Response getTrip(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the id of the trip to get", required = true) @PathParam("id") @NotNull  Long id,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getTrip(version, id, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/trip/{id}/match")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Get Trip Matches", notes = "Get matching trips of specific trip", response = Trip.class, responseContainer = "List", tags={ "Trip", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = Trip.class, responseContainer = "List")
    })
    public Response getTripMatches(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The id The id of the trip to search for matches for", required = true) @PathParam("id") @NotNull  Long id,@ApiParam(value = "The field to sort by", required = true) @QueryParam("sortField") @NotNull  String sortField,@ApiParam(value = "Determines whether the sorted list is in descending or ascending order", required = true) @QueryParam("descending") @NotNull  Boolean descending,@ApiParam(value = "The start index for pagination", required = true) @QueryParam("start") @NotNull  Integer start,@ApiParam(value = "The limit for pagination", required = true) @QueryParam("limit") @NotNull  Integer limit,@ApiParam(value = "Return only active results", required = true) @QueryParam("activeOnly") @NotNull  Boolean activeOnly,@ApiParam(value = "Only return matchings that already have route assigned") @QueryParam("matchedHasRoute")  Boolean matchedHasRoute,@ApiParam(value = "Only return matchings that already have driver assigned") @QueryParam("matchedHasDriver")  Boolean matchedHasDriver,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getTripMatches(version, id, sortField, descending, start, limit, activeOnly, matchedHasRoute, matchedHasDriver, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/application/users")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Search Application Users", notes = "Get a list of users per application", response = AccountListResponse.class, tags={ "Application", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = AccountListResponse.class)
    })
    public Response getUniqueUsersByApp(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The application key", required = true) @QueryParam("appKey") @NotNull  String appKey,@ApiParam(value = "Q") @QueryParam("q")  String q,@ApiParam(value = "The keyword used to search") @QueryParam("keyword")  String keyword,@ApiParam(value = "Return accounts that have been active after this date (UNIX time-stamp in milliseconds)") @QueryParam("since")  Long since,@ApiParam(value = "the start of the index") @QueryParam("_i")  Integer i,@ApiParam(value = "The start of the pagination", defaultValue = "0") @DefaultValue("0") @QueryParam("start")  Integer start,@ApiParam(value = "the limit of the index") @QueryParam("_l")  Integer l,@ApiParam(value = "The limit of the pagination", defaultValue = "20") @DefaultValue("20") @QueryParam("limit")  Integer limit,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getUniqueUsersByApp(version, appKey, q, keyword, since, i, start, l, limit, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/achievement/progress/get")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Get Achievement Progress", notes = "Gets a list of user achievements.", response = AchievementProgressResponse.class, responseContainer = "List", tags={ "Achievement", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = AchievementProgressResponse.class, responseContainer = "List")
    })
    public Response getUserAchievements(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "determines whether to return null fields in the response", required = true, defaultValue = "true") @DefaultValue("true") @QueryParam("returnNulls") @NotNull  Boolean returnNulls,@ApiParam(value = "the application key for filtering results by application", required = true) @QueryParam("appKey") @NotNull  String appKey,@ApiParam(value = "determines whether to return achievements that the user has not discovered yet", required = true, defaultValue = "true") @DefaultValue("true") @QueryParam("includeUndiscovered") @NotNull  Boolean includeUndiscovered,@ApiParam(value = "a unique id given by the device (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "the account id of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "the email of the account to view achievements") @QueryParam("connectionAccountEmail")  String connectionAccountEmail,@ApiParam(value = "the id of the account to view achievements") @QueryParam("connectionAccountId")  Long connectionAccountId,@ApiParam(value = "filter results by achievement rankType") @QueryParam("rankType")  String rankType,@ApiParam(value = "filter results by achievement type") @QueryParam("achievementType")  String achievementType,@ApiParam(value = "the current latitude of the user") @QueryParam("latitude")  Double latitude,@ApiParam(value = "the current longitude of the user") @QueryParam("longitude")  Double longitude,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getUserAchievements(version, returnNulls, appKey, includeUndiscovered, deviceId, accountId, connectionAccountEmail, connectionAccountId, rankType, achievementType, latitude, longitude, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/vatom/b/users/coins/get")
    
    
    @io.swagger.annotations.ApiOperation(value = "Get the coins for a user (as a Business)", notes = "Get the coins for a user (as a Business).", response = Void.class, tags={ "Vatom", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = Void.class)
    })
    public Response getUserCoinsAsBusiness(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "Sirqul Account Id", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "Vatom User Id", required = true) @QueryParam("vatomUserId") @NotNull  String vatomUserId,@ApiParam(value = "Sirqul Application Key", required = true) @QueryParam("appKey") @NotNull  String appKey,@ApiParam(value = "Return raw response") @QueryParam("returnRawResponse")  Boolean returnRawResponse,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getUserCoinsAsBusiness(version, accountId, vatomUserId, appKey, returnRawResponse, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/vatom/u/coins/get")
    
    
    @io.swagger.annotations.ApiOperation(value = "Gets the coins balance for a Vatom User", notes = "Gets the coins balance for a Vatom User.", response = Void.class, tags={ "Vatom", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = Void.class)
    })
    public Response getUserCoinsBalance(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "Sirqul Account Id", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "Vatom User Id", required = true) @QueryParam("vatomUserId") @NotNull  String vatomUserId,@ApiParam(value = "Vatom Parameters") @QueryParam("vatomParameters")  String vatomParameters,@ApiParam(value = "Return raw response") @QueryParam("returnRawResponse")  Boolean returnRawResponse,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getUserCoinsBalance(version, accountId, vatomUserId, vatomParameters, returnRawResponse, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/vatom/users/rels/followers")
    
    
    @io.swagger.annotations.ApiOperation(value = "Get user followers", notes = "Get user followers.", response = Void.class, tags={ "Vatom", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = Void.class)
    })
    public Response getUserFollowers(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "Sirqul Account Id", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "Vatom User Id", required = true) @QueryParam("vatomUserId") @NotNull  String vatomUserId,@ApiParam(value = "Return raw response") @QueryParam("returnRawResponse")  Boolean returnRawResponse,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getUserFollowers(version, accountId, vatomUserId, returnRawResponse, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/vatom/users/rels/following")
    
    
    @io.swagger.annotations.ApiOperation(value = "Get user following", notes = "Get user following.", response = Void.class, tags={ "Vatom", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = Void.class)
    })
    public Response getUserFollowing(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "Sirqul Account Id", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "Vatom User Id", required = true) @QueryParam("vatomUserId") @NotNull  String vatomUserId,@ApiParam(value = "Return raw response") @QueryParam("returnRawResponse")  Boolean returnRawResponse,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getUserFollowing(version, accountId, vatomUserId, returnRawResponse, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/vatom/user/get")
    
    
    @io.swagger.annotations.ApiOperation(value = "Get User Info", notes = "Get a User's Info.", response = Void.class, tags={ "Vatom", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = Void.class)
    })
    public Response getUserInfo(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "Sirqul Account Id", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "Vatom User Id", required = true) @QueryParam("vatomUserId") @NotNull  String vatomUserId,@ApiParam(value = "Return raw response") @QueryParam("returnRawResponse")  Boolean returnRawResponse,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getUserInfo(version, accountId, vatomUserId, returnRawResponse, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/vatom/me/get")
    
    
    @io.swagger.annotations.ApiOperation(value = "Get Vatom User Profile", notes = "Gets the logged in user's profile in Vatom.", response = Void.class, tags={ "Vatom", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = Void.class)
    })
    public Response getUserProfile(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "Sirqul Account Id", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "Return raw response") @QueryParam("returnRawResponse")  Boolean returnRawResponse,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getUserProfile(version, accountId, returnRawResponse, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/ranking/personal/ranks")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Get Personal Rankings", notes = "Returns the user's ranks for one or more rank types and modes.", response = Object.class, tags={ "Ranking", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = Object.class)
    })
    public Response getUserRank(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "a unique id given by the device (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "the account id of the user") @QueryParam("accountId")  Long accountId,@ApiParam(value = "the application key for filtering results by application (required)") @QueryParam("appKey")  String appKey,@ApiParam(value = "pass in all rankTypes and children rankTypes") @QueryParam("rankType")  String rankType,@ApiParam(value = "determines whether to return the user's current rank in the response, for each rankType", defaultValue = "false") @DefaultValue("false") @QueryParam("returnUserRank")  Boolean returnUserRank,@ApiParam(value = "the type of search to perform. Possible values include: GLOBAL, LOCAL, SEARCH, CUSTOM", defaultValue = "GLOBAL") @DefaultValue("GLOBAL") @QueryParam("leaderboardMode")  String leaderboardMode,@ApiParam(value = "determines how to order and rank the results. Possible values include: TOTAL, MONTHLY, WEEKLY, DAILY, TOP, LOWEST", defaultValue = "TOTAL") @DefaultValue("TOTAL") @QueryParam("sortField")  String sortField,@ApiParam(value = "keyword to search for (on rankType)") @QueryParam("keyword")  String keyword,@ApiParam(value = "determines whether to return results in descending order", defaultValue = "true") @DefaultValue("true") @QueryParam("descending")  Boolean descending,@ApiParam(value = "the start index for pagination", defaultValue = "0") @DefaultValue("0") @QueryParam("start")  Integer start,@ApiParam(value = "the limit for pagination", defaultValue = "100") @DefaultValue("100") @QueryParam("limit")  Integer limit,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getUserRank(version, deviceId, accountId, appKey, rankType, returnUserRank, leaderboardMode, sortField, keyword, descending, start, limit, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/vatom/b/events/get")
    
    
    @io.swagger.annotations.ApiOperation(value = "Get Vatom Event", notes = "Gets the details of a event.", response = Void.class, tags={ "Vatom", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = Void.class)
    })
    public Response getVatomEvent(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "Sirqul Account Id", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "Sirqul Application Key", required = true) @QueryParam("appKey") @NotNull  String appKey,@ApiParam(value = "Vatom Event Id", required = true) @QueryParam("vatomEventId") @NotNull  String vatomEventId,@ApiParam(value = "Return raw response") @QueryParam("returnRawResponse")  Boolean returnRawResponse,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getVatomEvent(version, accountId, appKey, vatomEventId, returnRawResponse, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/vatom/vatoms/get")
    
    
    @io.swagger.annotations.ApiOperation(value = "Get Vatom NFT Details", notes = "Get Vatom NFT Details", response = Void.class, tags={ "Vatom", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = Void.class)
    })
    public Response getVatomNFT(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "Sirqul Account Id", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "Vatom NFT Id", required = true) @QueryParam("vatomId") @NotNull  String vatomId,@ApiParam(value = "Return raw response") @QueryParam("returnRawResponse")  Boolean returnRawResponse,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getVatomNFT(version, accountId, vatomId, returnRawResponse, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/vehicle/{id}")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Get Vehicle", notes = "Get an existing vehicle", response = Vehicle.class, tags={ "Vehicle", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = Vehicle.class)
    })
    public Response getVehicle(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The id of the vehicle requested", required = true) @PathParam("id") @NotNull  Long id,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getVehicle(version, id, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/vehicle/type/{vehicleTypeId}")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Get Vehicle Type", notes = "Get a vehicle type", response = VehicleType.class, tags={ "Vehicle Type", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = VehicleType.class)
    })
    public Response getVehicleType(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The id of the requested vehicle type", required = true) @PathParam("vehicleTypeId") @NotNull  Long vehicleTypeId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getVehicleType(version, vehicleTypeId, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/orson/ai/voiceCanvas/{requestId}")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Get VoiceCanvas images", notes = "Get a result or continue waiting for a pending request for VoiceCanvas Images.", response = OrsonAiVoiceCanvasResponse.class, tags={ "Orson", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = OrsonAiVoiceCanvasResponse.class)
    })
    public Response getVoiceCanvas(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "Orson Request Id", required = true) @PathParam("requestId") @NotNull  String requestId,@ApiParam(value = "Sirqul Account Id", required = true) @QueryParam("accountId") @NotNull  Long accountId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getVoiceCanvas(version, requestId, accountId, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/game/word/get")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Get Word", notes = "Get a word by the given id.", response = WordzWordResponse.class, tags={ "Word", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = WordzWordResponse.class)
    })
    public Response getWord(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The id of the word to get.", required = true) @QueryParam("wordId") @NotNull  Long wordId,@ApiParam(value = "The logged in user.", required = true) @QueryParam("accountId") @NotNull  Long accountId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getWord(version, wordId, accountId, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/game/word/search")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Search Words", notes = "Search for words by the given params.", response = WordzWordResponse.class, responseContainer = "List", tags={ "Word", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = WordzWordResponse.class, responseContainer = "List")
    })
    public Response getWords(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The logged in user.", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "The column to sort the search on", required = true, defaultValue = "id") @DefaultValue("id") @QueryParam("sortField") @NotNull  String sortField,@ApiParam(value = "The order to return the search results", required = true, defaultValue = "false") @DefaultValue("false") @QueryParam("descending") @NotNull  Boolean descending,@ApiParam(value = "Return only active results if set to true.", required = true, defaultValue = "false") @DefaultValue("false") @QueryParam("activeOnly") @NotNull  Boolean activeOnly,@ApiParam(value = "The record to begin the return set on.", required = true, defaultValue = "0") @DefaultValue("0") @QueryParam("start") @NotNull  Integer start,@ApiParam(value = "The number of records to return.", required = true, defaultValue = "20") @DefaultValue("20") @QueryParam("limit") @NotNull  Integer limit,@ApiParam(value = "The keyword for searching words with matching definition or word text.") @QueryParam("keyword")  String keyword,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getWords(version, accountId, sortField, descending, activeOnly, start, limit, keyword, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/level/words/get")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Get Level Words", notes = "Get words within a level.", response = WordzWordResponse.class, tags={ "Game Level", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = WordzWordResponse.class)
    })
    public Response getWordsInLevel(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the id of the level to get words for", required = true) @QueryParam("levelId") @NotNull  Long levelId,@ApiParam(value = "the id of the logged in user", required = true) @QueryParam("accountId") @NotNull  Long accountId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getWordsInLevel(version, levelId, accountId, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/purchase/gift")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Gift Tickets", notes = "Gift tickets to another user.", response = SirqulResponse.class, tags={ "Ticket", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response giftPurchase(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the id of the account receiving the tickets", required = true) @QueryParam("receiverAccountId") @NotNull  Long receiverAccountId,@ApiParam(value = "the id of the tickets", required = true) @QueryParam("ticketId") @NotNull  Long ticketId,@ApiParam(value = "the id of the device") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "the id of the gift owner") @QueryParam("accountId")  Long accountId,@ApiParam(value = "the id of the asset") @QueryParam("assetId")  Long assetId,@ApiParam(value = "a message that can be written to go along with the gift") @QueryParam("customMessage")  String customMessage,@ApiParam(value = "the type of game associated with the tickets") @QueryParam("gameType")  String gameType,@ApiParam(value = "the application key") @QueryParam("appKey")  String appKey,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.giftPurchase(version, receiverAccountId, ticketId, deviceId, accountId, assetId, customMessage, gameType, appKey, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/facebook/graph")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Post to Facebook", notes = "Make Facebook posts on behalf of the user.", response = SirqulResponse.class, tags={ "Facebook", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response graphInterface(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the type of Sirqul event {DOWNLOADED_APP, CHALLENGE, LEVEL_COMPLETED, LEVEL_CREATED}", required = true) @QueryParam("event") @NotNull  String event,@ApiParam(value = "a unique id given by the device (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "the account id of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "for posting about information related to an object. Possible types: {ALBUM, ALBUM_CONTEST, GAME_LEVEL, THEME_DESCRIPTOR}") @QueryParam("permissionableType")  String permissionableType,@ApiParam(value = "the object id") @QueryParam("permissionableId")  Long permissionableId,@ApiParam(value = "used to include an asset on a Facebook post") @QueryParam("assetId")  Long assetId,@ApiParam(value = "This parameter is deprecated.") @QueryParam("gameType")  String gameType,@ApiParam(value = "the application key") @QueryParam("appKey")  String appKey,@ApiParam(value = "used to update the user's current location") @QueryParam("latitude")  Double latitude,@ApiParam(value = "used to update the user's current location") @QueryParam("longitude")  Double longitude,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.graphInterface(version, event, deviceId, accountId, permissionableType, permissionableId, assetId, gameType, appKey, latitude, longitude, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/connection/group/search")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Search Connection Groups", notes = "Gets a user's private groups and default groups.", response = ConnectionInfoResponse.class, responseContainer = "List", tags={ "Connection", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = ConnectionInfoResponse.class, responseContainer = "List")
    })
    public Response groupSearch(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the field to sort by", required = true, allowableValues="CREATED, UPDATED, ACTIVE, NAME, DESCRIPTION, CAN_VIEW_PROFILE_INFO, CAN_VIEW_GAME_INFO, CAN_VIEW_FRIEND_INFO, INVITE_CODE, OWNER_DISPLAY, OWNER_USERNAME") @QueryParam("sortField") @NotNull  String sortField,@ApiParam(value = "whether to return results in descending or ascending order", required = true) @QueryParam("descending") @NotNull  Boolean descending,@ApiParam(value = "to search on active only or not", required = true) @QueryParam("activeOnly") @NotNull  Boolean activeOnly,@ApiParam(value = "The start of the pagination", required = true) @QueryParam("start") @NotNull  Integer start,@ApiParam(value = "the limit of the pagination", required = true) @QueryParam("limit") @NotNull  Integer limit,@ApiParam(value = "the device id (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "the account id of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "the current latitude of the user") @QueryParam("latitude")  Double latitude,@ApiParam(value = "the current longitude of the user") @QueryParam("longitude")  Double longitude,@ApiParam(value = "keyword search string") @QueryParam("keyword")  String keyword,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.groupSearch(version, sortField, descending, activeOnly, start, limit, deviceId, accountId, latitude, longitude, keyword, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/openai/v1/images/generations")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Generate images with OpenAI", notes = "Generate images with OpenAI.", response = WrappedProxyItemResponse.class, tags={ "OpenAI", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = WrappedProxyItemResponse.class)
    })
    public Response imageGeneration(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "Sirqul Account Id", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "Post Body Parameters", required = true) @QueryParam("postBody") @NotNull  String postBody,@ApiParam(value = "Return raw response") @QueryParam("returnRawResponse")  Boolean returnRawResponse,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.imageGeneration(version, accountId, postBody, returnRawResponse, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/mission/import")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Import Mission", notes = "Create a mission using a source item such as an offer location.", response = SirqulResponse.class, tags={ "Mission", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response importMission(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The logged in user.", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "The current location of the requesting device", required = true) @QueryParam("latitude") @NotNull  Double latitude,@ApiParam(value = "The current location of the requesting device", required = true) @QueryParam("longitude") @NotNull  Double longitude,@ApiParam(value = "the application key", required = true) @QueryParam("appKey") @NotNull  String appKey,@ApiParam(value = "the keyword of the mission") @QueryParam("keyword")  String keyword,@ApiParam(value = "The starting index in the result set to return. Default is 0.") @QueryParam("start")  Integer start,@ApiParam(value = "The total number of records to return. Default is 20.") @QueryParam("limit")  Integer limit,@ApiParam(value = "the size of the ad", allowableValues="CONFIG, BANNER, LEADERBOARD, SKYSCRAPER, VIDEO, ZIP, INTERSTITIAL, CUSTOM1, CUSTOM2, CUSTOM3, CUSTOM4, CUSTOM5, CUSTOM6, CUSTOM7, CUSTOM8, CUSTOM9, CUSTOM10") @QueryParam("adSize")  String adSize,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.importMission(version, accountId, latitude, longitude, appKey, keyword, start, limit, adSize, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/retailer/location/idistancesearch")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Distance Search Retailer Locations (Indexed)", notes = "Retailer location indexed search by distance. This searches on any retailer location with location data and returns the results sorted by distance.", response = RetailerLocationResponse.class, responseContainer = "List", tags={ "Retailer Location", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = RetailerLocationResponse.class, responseContainer = "List")
    })
    public Response indexedRetailerLocationDistanceSearch(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The latitude to center the search on", required = true) @QueryParam("latitude") @NotNull  Double latitude,@ApiParam(value = "The longitude to center the search on", required = true) @QueryParam("longitude") @NotNull  Double longitude,@ApiParam(value = "The search range in the distanceUnit specified; default is MILES.", required = true) @QueryParam("searchRange") @NotNull  Double searchRange,@ApiParam(value = "The start index for pagination", required = true) @QueryParam("start") @NotNull  Integer start,@ApiParam(value = "The limit for pagination", required = true) @QueryParam("limit") @NotNull  Integer limit,@ApiParam(value = "The account id of the user") @QueryParam("accountId")  Long accountId,@ApiParam(value = "Used to return results using this address as the center") @QueryParam("address")  String address,@ApiParam(value = "boolean to indicate whether to include retailer locations that have no offers") @QueryParam("hasOffers")  Boolean hasOffers,@ApiParam(value = "Comma separate list of category ids") @QueryParam("categories")  String categories,@ApiParam(value = "Comma separated list of filter ids") @QueryParam("filters")  String filters,@ApiParam(value = "Comma separated list of audience ids") @QueryParam("audiences")  String audiences,@ApiParam(value = "Comma separated list of retailer ids") @QueryParam("retailerIds")  String retailerIds,@ApiParam(value = "Comma separated list of retailer location ids") @QueryParam("retailerLocationIds")  String retailerLocationIds,@ApiParam(value = "Does a full-text search on tags") @QueryParam("tags")  String tags,@ApiParam(value = "Location type filter") @QueryParam("locationType")  String locationType,@ApiParam(value = "The field to sort the result set on. Possible values include: DISTANCE, RETAILER_NAME, RETAILER_LOCATION_NAME") @QueryParam("sortField")  String sortField,@ApiParam(value = "Determines whether the sorted list is in descending or ascending order") @QueryParam("descending")  Boolean descending,@ApiParam(value = "This parameter is deprecated.") @QueryParam("q")  String q,@ApiParam(value = "Search by keyword") @QueryParam("keyword")  String keyword,@ApiParam(value = "Determines the operator used when there are multiple words in the 'keyword' parameter") @QueryParam("keywordOperator")  String keywordOperator,@ApiParam(value = "Search expression to further refine results") @QueryParam("searchExpression")  String searchExpression,@ApiParam(value = "Unit of distance", allowableValues="MILES, KILOMETERS") @QueryParam("distanceUnit")  String distanceUnit,@ApiParam(value = "(deprecated) return favorited flag") @QueryParam("returnFavorited")  Boolean returnFavorited,@ApiParam(value = "Return retailer info") @QueryParam("returnRetailer")  Boolean returnRetailer,@ApiParam(value = "Return assets") @QueryParam("returnAssets")  Boolean returnAssets,@ApiParam(value = "Return offers") @QueryParam("returnOffers")  Boolean returnOffers,@ApiParam(value = "Return categories") @QueryParam("returnCategories")  Boolean returnCategories,@ApiParam(value = "Return filters") @QueryParam("returnFilters")  Boolean returnFilters,@ApiParam(value = "Return audiences") @QueryParam("returnAudiences")  Boolean returnAudiences,@ApiParam(value = "Return QR code info") @QueryParam("returnQrCode")  Boolean returnQrCode,@ApiParam(value = "Return external category data") @QueryParam("returnExternalCategoryData")  Boolean returnExternalCategoryData,@ApiParam(value = "Include favorites in response") @QueryParam("includeFavorite")  Boolean includeFavorite,@ApiParam(value = "Include liked flag in response") @QueryParam("includeLiked")  Boolean includeLiked,@ApiParam(value = "Include rating info in response") @QueryParam("includeRating")  Boolean includeRating,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.indexedRetailerLocationDistanceSearch(version, latitude, longitude, searchRange, start, limit, accountId, address, hasOffers, categories, filters, audiences, retailerIds, retailerLocationIds, tags, locationType, sortField, descending, q, keyword, keywordOperator, searchExpression, distanceUnit, returnFavorited, returnRetailer, returnAssets, returnOffers, returnCategories, returnFilters, returnAudiences, returnQrCode, returnExternalCategoryData, includeFavorite, includeLiked, includeRating, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/retailer/location/isearch")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Keyword Search Retailer Locations (Indexed)", notes = "Retailer location (faster) indexed search. This searches all retailer locations.", response = RetailerLocationResponse.class, responseContainer = "List", tags={ "Retailer Location", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = RetailerLocationResponse.class, responseContainer = "List")
    })
    public Response indexedRetailerLocationSearch(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The account id of the user") @QueryParam("accountId")  Long accountId,@ApiParam(value = "The start index for pagination") @QueryParam("start")  Integer start,@ApiParam(value = "The limit for pagination") @QueryParam("limit")  Integer limit,@ApiParam(value = "boolean to indicate whether to include retailer locations that have no offers") @QueryParam("hasOffers")  Boolean hasOffers,@ApiParam(value = "Comma separate list of category ids") @QueryParam("categories")  String categories,@ApiParam(value = "Comma separated list of filter ids") @QueryParam("filters")  String filters,@ApiParam(value = "Comma separated list of audience ids") @QueryParam("audiences")  String audiences,@ApiParam(value = "Comma separated list of retailer ids") @QueryParam("retailerIds")  String retailerIds,@ApiParam(value = "Comma separated list of retailer location ids") @QueryParam("retailerLocationIds")  String retailerLocationIds,@ApiParam(value = "Does a full-text search on tags") @QueryParam("tags")  String tags,@ApiParam(value = "Location type filter") @QueryParam("locationType")  String locationType,@ApiParam(value = "The field to sort the result set on. Possible values include: RETAILER_NAME, RETAILER_LOCATION_NAME") @QueryParam("sortField")  String sortField,@ApiParam(value = "Determines whether the sorted list is in descending or ascending order") @QueryParam("descending")  Boolean descending,@ApiParam(value = "This parameter is deprecated.") @QueryParam("q")  String q,@ApiParam(value = "Search by keyword") @QueryParam("keyword")  String keyword,@ApiParam(value = "Determines the operator used when there are multiple words in the 'keyword' parameter") @QueryParam("keywordOperator")  String keywordOperator,@ApiParam(value = "Search expression to further refine results") @QueryParam("searchExpression")  String searchExpression,@ApiParam(value = "Return retailer info") @QueryParam("returnRetailer")  Boolean returnRetailer,@ApiParam(value = "Return assets") @QueryParam("returnAssets")  Boolean returnAssets,@ApiParam(value = "Return offers") @QueryParam("returnOffers")  Boolean returnOffers,@ApiParam(value = "Return categories") @QueryParam("returnCategories")  Boolean returnCategories,@ApiParam(value = "Return filters") @QueryParam("returnFilters")  Boolean returnFilters,@ApiParam(value = "Return audiences") @QueryParam("returnAudiences")  Boolean returnAudiences,@ApiParam(value = "Return QR code info") @QueryParam("returnQrCode")  Boolean returnQrCode,@ApiParam(value = "Return external category data") @QueryParam("returnExternalCategoryData")  Boolean returnExternalCategoryData,@ApiParam(value = "Include favorites in response") @QueryParam("includeFavorite")  Boolean includeFavorite,@ApiParam(value = "Include liked flag in response") @QueryParam("includeLiked")  Boolean includeLiked,@ApiParam(value = "Include rating info in response") @QueryParam("includeRating")  Boolean includeRating,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.indexedRetailerLocationSearch(version, accountId, start, limit, hasOffers, categories, filters, audiences, retailerIds, retailerLocationIds, tags, locationType, sortField, descending, q, keyword, keywordOperator, searchExpression, returnRetailer, returnAssets, returnOffers, returnCategories, returnFilters, returnAudiences, returnQrCode, returnExternalCategoryData, includeFavorite, includeLiked, includeRating, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/album/user/leave")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Leave Album", notes = " Allows a user to leave an album (they are no longer considered a participant). The album creator cannot leave their own albums.", response = SirqulResponse.class, tags={ "Album", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response leaveAlbum(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the album ID", required = true) @QueryParam("albumId") @NotNull  Long albumId,@ApiParam(value = "a unique ID given by the device (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "the account ID of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.leaveAlbum(version, albumId, deviceId, accountId, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/consumer/permissions/leave")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Leave", notes = "Used when the user wants to leave from someone else's permissionable object", response = SirqulResponse.class, tags={ "User Permissions", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response leaveFromPermissionable(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the permissionable type PermissionableType", required = true) @QueryParam("permissionableType") @NotNull  String permissionableType,@ApiParam(value = "the id of the permissionable object", required = true) @QueryParam("permissionableId") @NotNull  Long permissionableId,@ApiParam(value = "the device id (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "the account id of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "the current latitude of the user") @QueryParam("latitude")  Double latitude,@ApiParam(value = "the current longitude of the user") @QueryParam("longitude")  Double longitude,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.leaveFromPermissionable(version, permissionableType, permissionableId, deviceId, accountId, latitude, longitude, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/achievement/tag/list")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "List Achievement Tags", notes = "List achievement tags by application", response = SirqulResponse.class, tags={ "Achievement", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response listAchievementTags(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "filter results by application key") @QueryParam("appKey")  String appKey,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.listAchievementTags(version, appKey, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/achievement/list")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "List Achievements", notes = "List achievements by billable.", response = AchievementShortResponse.class, responseContainer = "List", tags={ "Achievement", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = AchievementShortResponse.class, responseContainer = "List")
    })
    public Response listAchievements(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the field to sort by. See AchievementApiMap", required = true, allowableValues="CREATED, UPDATED, DELETED, SEARCH_TAGS, ACTIVE, TITLE, DESCRIPTION, RANK_TYPE, APPLICATION_ID, APPLICATION_NAME, BILLABLE_ID") @QueryParam("sortField") @NotNull  String sortField,@ApiParam(value = "determines whether the sorted list is in descending or ascending order", required = true) @QueryParam("descending") @NotNull  Boolean descending,@ApiParam(value = "the start index for pagination", required = true) @QueryParam("start") @NotNull  Integer start,@ApiParam(value = "the limit for pagination (has a hard limit of 1000)", required = true) @QueryParam("limit") @NotNull  Integer limit,@ApiParam(value = "Filter results to only return active achievements", required = true) @QueryParam("activeOnly") @NotNull  Boolean activeOnly,@ApiParam(value = "a unique id given by the device (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "the account id of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "the application key") @QueryParam("appKey")  String appKey,@ApiParam(value = "the keyword used to filter results with (this returns results that have the keyword in the title or description of the achievement)") @QueryParam("keyword")  String keyword,@ApiParam(value = "filter results by the achievementType (these are exact case sensitive matches)") @QueryParam("achievementType")  String achievementType,@ApiParam(value = "filter results by the rankType (these are exact case sensitive matches)") @QueryParam("rankType")  String rankType,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.listAchievements(version, sortField, descending, start, limit, activeOnly, deviceId, accountId, appKey, keyword, achievementType, rankType, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/application/list")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "List Applications", notes = "List active applications matching the criteria (as a consumer)", response = ApplicationShortResponse.class, responseContainer = "List", tags={ "Application", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = ApplicationShortResponse.class, responseContainer = "List")
    })
    public Response listApplications(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The account id of the application owner/manager") @QueryParam("accountId")  Long accountId,@ApiParam(value = "Q") @QueryParam("q")  String q,@ApiParam(value = "The keyword used to search for title, about, and description fields") @QueryParam("keyword")  String keyword,@ApiParam(value = "Deprecated, use deviceIds and deviceVersions") @QueryParam("platforms")  String platforms,@ApiParam(value = "The list of targeted device ids, comma separated; possible values are retreived via /api/{version/audience/devices com.sirqul.geoapps.common.service.AudienceApi#getDevices getDevices (pass in deviceId values)") @QueryParam("deviceIds")  String deviceIds,@ApiParam(value = "The list of targeted device version ranges that are aligned  with the provided devices list (see devices param for possible values),  comma separated; examples are: 2.3-X, 0-5.1.4, 4.3.1-6.1.4 where X  is no maximum and 0 is no minimum. ") @QueryParam("deviceVersions")  String deviceVersions,@ApiParam(value = "The list of category ids to filter the list by") @QueryParam("categoryIds")  String categoryIds,@ApiParam(value = "The column to sort the search on, possible values include: UPDATED (default), CREATED, TITLE", allowableValues="CREATED, UPDATED, DELETED, SEARCH_TAGS, ACTIVE, HAS_ADVERTISEMENTS, PUBLIC_NOTIFICATIONS, PLACEMENTS, BILLABLE_ENTITY_ID, BILLABLE_ENTITY_NAME, RESPONSIBLE_DISPLAY, TITLE, NAME, ABOUT, DESCRIPTION, APPLICATION_ID, APP_TYPE, GAME_TYPE, BUNDLE_ID, SCORING_TYPE, LANDING_PAGE_URL, EULA_VERSION, BUILD_VERSION, API_VERSION", defaultValue = "UPDATED") @DefaultValue("UPDATED") @QueryParam("sortField")  String sortField,@ApiParam(value = "Filter results on whether the application supports ads or not. Ignore this parameter to return all results.") @QueryParam("hasAds")  Boolean hasAds,@ApiParam(value = "Filter results on whether the application is available for public trigger notifications") @QueryParam("publicNotifications")  Boolean publicNotifications,@ApiParam(value = "Determines whether to only return applications that the user has access to") @QueryParam("filterBillable")  Boolean filterBillable,@ApiParam(value = "Determines whether to only return applications that the user is a content admin of") @QueryParam("filterContentAdmin")  Boolean filterContentAdmin,@ApiParam(value = "The order to return the search results", defaultValue = "true") @DefaultValue("true") @QueryParam("descending")  Boolean descending,@ApiParam(value = "the start of the index") @QueryParam("_i")  Integer i,@ApiParam(value = "The start of the pagination", defaultValue = "0") @DefaultValue("0") @QueryParam("start")  Integer start,@ApiParam(value = "The limit of the index") @QueryParam("_l")  Integer l,@ApiParam(value = "The limit of the pagination", defaultValue = "20") @DefaultValue("20") @QueryParam("limit")  Integer limit,@ApiParam(value = "The list of application ids, comma separated. If provided will ignore all other params.") @QueryParam("applicationIds")  String applicationIds,@ApiParam(value = "Only include applications with a object store (default is false)", defaultValue = "false") @DefaultValue("false") @QueryParam("hasObjectStore")  Boolean hasObjectStore,@ApiParam(value = "Return only active results", defaultValue = "true") @DefaultValue("true") @QueryParam("activeOnly")  Boolean activeOnly,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.listApplications(version, accountId, q, keyword, platforms, deviceIds, deviceVersions, categoryIds, sortField, hasAds, publicNotifications, filterBillable, filterContentAdmin, descending, i, start, l, limit, applicationIds, hasObjectStore, activeOnly, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/audience/suggestion/list")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "List Suggestions by Audience", notes = "List either Missions or Offers that the user matches the assigned audience.", response = OfferListResponse.class, tags={ "Audience", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = OfferListResponse.class)
    })
    public Response listByAccount(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The account to match offers for.", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "the limit of the index", required = true) @QueryParam("limit") @NotNull  Integer limit,@ApiParam(value = "the type of suggestion", required = true) @QueryParam("suggestionType") @NotNull  String suggestionType,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.listByAccount(version, accountId, limit, suggestionType, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/audience/suggestion/offersByAudience")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "List Offers by Audience", notes = "Get a list of offer locations based on audience information provided.", response = OfferListResponse.class, tags={ "Audience", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = OfferListResponse.class)
    })
    public Response listByAudience(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "this is the limit of the index", required = true) @QueryParam("limit") @NotNull  Integer limit,@ApiParam(value = "this is the gender to list offers by") @QueryParam("gender")  String gender,@ApiParam(value = "this is the age to list offers by") @QueryParam("age")  Integer age,@ApiParam(value = "this is the category IDs to list offers by") @QueryParam("categoryIds")  String categoryIds,@ApiParam(value = "this is the latitude to list offers by") @QueryParam("latitude")  Double latitude,@ApiParam(value = "this is the longitude to list offers by") @QueryParam("longitude")  Double longitude,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.listByAudience(version, limit, gender, age, categoryIds, latitude, longitude, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/vatom/b/communities/search")
    
    
    @io.swagger.annotations.ApiOperation(value = "List Vatom Communities", notes = "Gets the communities tied to a business.", response = Void.class, tags={ "Vatom", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = Void.class)
    })
    public Response listCommunities(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "Sirqul Account Id", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "Sirqul Application Key", required = true) @QueryParam("appKey") @NotNull  String appKey,@ApiParam(value = "Vatom Parameters") @QueryParam("vatomParameters")  String vatomParameters,@ApiParam(value = "Return raw response") @QueryParam("returnRawResponse")  Boolean returnRawResponse,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.listCommunities(version, accountId, appKey, vatomParameters, returnRawResponse, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/vatom/b/events/search")
    
    
    @io.swagger.annotations.ApiOperation(value = "List Vatom Events", notes = "Gets the events tied to a business.", response = Void.class, tags={ "Vatom", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = Void.class)
    })
    public Response listEvents(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "Sirqul Account Id", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "Sirqul Application Key", required = true) @QueryParam("appKey") @NotNull  String appKey,@ApiParam(value = "Vatom Parameters") @QueryParam("vatomParameters")  String vatomParameters,@ApiParam(value = "Return raw response") @QueryParam("returnRawResponse")  Boolean returnRawResponse,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.listEvents(version, accountId, appKey, vatomParameters, returnRawResponse, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/audience/suggestion/latest")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "List Sent Suggestions ", notes = "Return list of recent trigger suggestions that have been sent to the user.", response = OfferListResponse.class, tags={ "Audience", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = OfferListResponse.class)
    })
    public Response listLastestByAccount(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The account to match offers for.", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "The timeframe in seconds of the latest suggestions", required = true) @QueryParam("timeframe") @NotNull  Integer timeframe,@ApiParam(value = "The type of trigger suggestions to return", required = true) @QueryParam("suggestionType") @NotNull  String suggestionType,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.listLastestByAccount(version, accountId, timeframe, suggestionType, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/vatom/b/spaces/search")
    
    
    @io.swagger.annotations.ApiOperation(value = "List Vatom Spaces", notes = "Gets the spaces tied to a business.", response = Void.class, tags={ "Vatom", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = Void.class)
    })
    public Response listSpaces(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "Sirqul Account Id", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "Sirqul Application Key", required = true) @QueryParam("appKey") @NotNull  String appKey,@ApiParam(value = "Vatom Parameters") @QueryParam("vatomParameters")  String vatomParameters,@ApiParam(value = "Return raw response") @QueryParam("returnRawResponse")  Boolean returnRawResponse,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.listSpaces(version, accountId, appKey, vatomParameters, returnRawResponse, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/csvimport/batch/list")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Search Status", notes = "Retrieves batches for a user.", response = CsvImportResponse.class, tags={ "CSV Import", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = CsvImportResponse.class)
    })
    public Response listStatusCSV(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the id of the account", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "the start of the pagination", required = true) @QueryParam("start") @NotNull  Integer start,@ApiParam(value = "the limit of the pagination", required = true) @QueryParam("limit") @NotNull  Integer limit,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.listStatusCSV(version, accountId, start, limit, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/vatom/u/coins/txns/search")
    
    
    @io.swagger.annotations.ApiOperation(value = "List Coin Transactions for a Vatom User", notes = "Gets the logged in user's Vatom coin transactions.", response = Void.class, tags={ "Vatom", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = Void.class)
    })
    public Response listUserCoinTransactions(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "Sirqul Account Id", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "Vatom User Id", required = true) @QueryParam("vatomUserId") @NotNull  String vatomUserId,@ApiParam(value = "Vatom Parameters") @QueryParam("vatomParameters")  String vatomParameters,@ApiParam(value = "Return raw response") @QueryParam("returnRawResponse")  Boolean returnRawResponse,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.listUserCoinTransactions(version, accountId, vatomUserId, vatomParameters, returnRawResponse, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/vatom/b/users/coins/txns/search")
    
    
    @io.swagger.annotations.ApiOperation(value = "List coin transactions for a user (as a Business)", notes = "List coin transactions for a user (as a Business).", response = Void.class, tags={ "Vatom", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = Void.class)
    })
    public Response listUserCoinTransactionsAsBusiness(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "Sirqul Account Id", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "Vatom User Id", required = true) @QueryParam("vatomUserId") @NotNull  String vatomUserId,@ApiParam(value = "Sirqul Application Key", required = true) @QueryParam("appKey") @NotNull  String appKey,@ApiParam(value = "Vatom Parameters") @QueryParam("vatomParameters")  String vatomParameters,@ApiParam(value = "Return raw response") @QueryParam("returnRawResponse")  Boolean returnRawResponse,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.listUserCoinTransactionsAsBusiness(version, accountId, vatomUserId, appKey, vatomParameters, returnRawResponse, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/account/login/delegate")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Login as Account", notes = "A login service that supports logging in as someone else (accounts that the user manages). Intended for internal use for now.", response = ProfileResponse.class, tags={ "Account", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = ProfileResponse.class)
    })
    public Response loginDelegate(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "", required = true) @QueryParam("accessToken") @NotNull  String accessToken,@ApiParam(value = "", required = true) @QueryParam("appKey") @NotNull  String appKey,@ApiParam(value = "") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "") @QueryParam("accessTokenSecret")  String accessTokenSecret,@ApiParam(value = "") @QueryParam("delegatedAccountId")  Long delegatedAccountId,@ApiParam(value = "") @QueryParam("delegatedUsername")  String delegatedUsername,@ApiParam(value = "The access provider to authenticate against (default: USERNAME). Supported values: FACEBOOK, TWITTER, USERNAME, PHONE", defaultValue = "USERNAME") @DefaultValue("USERNAME") @QueryParam("networkUID")  String networkUID,@ApiParam(value = "Checks user's birthday to see if they meet an age requirement. If the user is under age, an error message is returned.", defaultValue = "0") @DefaultValue("0") @QueryParam("ageRestriction")  Integer ageRestriction,@ApiParam(value = "This determines how much of the profile should be returned, see ProfileFilters", defaultValue = "PROFILE") @DefaultValue("PROFILE") @QueryParam("responseFilters")  String responseFilters,@ApiParam(value = "") @QueryParam("latitude")  Double latitude,@ApiParam(value = "") @QueryParam("longitude")  Double longitude,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.loginDelegate(version, accessToken, appKey, deviceId, accessTokenSecret, delegatedAccountId, delegatedUsername, networkUID, ageRestriction, responseFilters, latitude, longitude, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/account/login")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Login Account", notes = "General login service that supports various authentication methods. Currently supports Facebook, Twitter, Sirqul Username, and Sirqul Phone by default. Can also support custom networks created using the {@link ThirdPartyApi}", response = ProfileResponse.class, tags={ "Account", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = ProfileResponse.class)
    })
    public Response loginGeneral(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The access token to authenticate with (ex: username or fb token)", required = true) @QueryParam("accessToken") @NotNull  String accessToken,@ApiParam(value = "The access provider to authenticate against. This can be custom  networks created using the ThirdPartyApi as well. Supported values by default  include: FACEBOOK, TWITTER, USERNAME, PHONE ", required = true, defaultValue = "USERNAME") @DefaultValue("USERNAME") @QueryParam("networkUID") @NotNull  String networkUID,@ApiParam(value = "The application key", required = true) @QueryParam("appKey") @NotNull  String appKey,@ApiParam(value = "The unique id of the device making the request") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "The type of device id (this is defined by the client), ie. MAC_ADDRESS, APPLE_UDID, etc") @QueryParam("deviceIdType")  String deviceIdType,@ApiParam(value = "The secret to authenticate with (ex: password)") @QueryParam("accessTokenSecret")  String accessTokenSecret,@ApiParam(value = "Checks user's birthday to see if they meet an age requirement. If the user is under age, an error message is returned.", defaultValue = "0") @DefaultValue("0") @QueryParam("ageRestriction")  Integer ageRestriction,@ApiParam(value = "This determines how much of the profile should be returned, see ProfileFilters", defaultValue = "PROFILE") @DefaultValue("PROFILE") @QueryParam("responseFilters")  String responseFilters,@ApiParam(value = "Used to update the user's current location") @QueryParam("latitude")  Double latitude,@ApiParam(value = "Used to update the user's current location") @QueryParam("longitude")  Double longitude,@ApiParam(value = "Option to check for email if username doesn't match, also support multiple accounts", defaultValue = "false") @DefaultValue("false") @QueryParam("emailMatch")  Boolean emailMatch,@ApiParam(value = "Chosen account Id sent from the app - pass in the 2nd request to choose an account from multiple accounts matching the email - use one of the account id from the previous request", defaultValue = "0") @DefaultValue("0") @QueryParam("chosenAccountId")  Long chosenAccountId,@ApiParam(value = "Third-party credential Id, pass in the 2nd request to choose an account from multiple accounts matching the email - use the id from the previous call ThirdPartyCredential object", defaultValue = "0") @DefaultValue("0") @QueryParam("thirdPartyCredentialId")  Long thirdPartyCredentialId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.loginGeneral(version, accessToken, networkUID, appKey, deviceId, deviceIdType, accessTokenSecret, ageRestriction, responseFilters, latitude, longitude, emailMatch, chosenAccountId, thirdPartyCredentialId, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/secure/login")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Login Clear", notes = "Login via Clear.me. Creates a new account if logging in for the first time.", response = ProfileResponse.class, tags={ "SecureApp", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = ProfileResponse.class)
    })
    public Response loginSecure(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The application making the request, defines what type and position is required to make a secure login the request.", required = true) @QueryParam("appKey") @NotNull  String appKey,@ApiParam(value = "The data file used to perform authentication", required = true) @QueryParam("biometricFile") @NotNull  File biometricFile,@ApiParam(value = "The unique id of the device making the request") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "The data file used to perform authentication") @QueryParam("biometricFile2")  File biometricFile2,@ApiParam(value = "Checks user's birthday to see if they meet an age requirement. If the user is under age, an error message is returned.", defaultValue = "0") @DefaultValue("0") @QueryParam("ageRestriction")  Integer ageRestriction,@ApiParam(value = "Determines whether to return a ProfileResponse on success, or a PaymentTypesResponse", defaultValue = "false") @DefaultValue("false") @QueryParam("returnProfile")  Boolean returnProfile,@ApiParam(value = "If returnProfile is set to true, this determines how much of the profile should be returned, see ProfileFilters", defaultValue = "PROFILE") @DefaultValue("PROFILE") @QueryParam("responseFilters")  String responseFilters,@ApiParam(value = "Used to update the user's current location") @QueryParam("latitude")  Double latitude,@ApiParam(value = "Used to update the user's current location") @QueryParam("longitude")  Double longitude,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.loginSecure(version, appKey, biometricFile, deviceId, biometricFile2, ageRestriction, returnProfile, responseFilters, latitude, longitude, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/twitter/login")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Login Twitter", notes = "Returns the user profile information given an access token and the secret access token. This call verifies the tokens with twitter and creates a Sirqul account for the user if its their first time logging in.", response = ProfileResponse.class, tags={ "Twitter", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = ProfileResponse.class)
    })
    public Response loginTwitter(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The access token", required = true) @QueryParam("accessToken") @NotNull  String accessToken,@ApiParam(value = "The secret access token", required = true) @QueryParam("accessTokenSecret") @NotNull  String accessTokenSecret,@ApiParam(value = "The application key", required = true) @QueryParam("appKey") @NotNull  String appKey,@ApiParam(value = "a comma separated list of ProfileFilters for filtering the returned response data", required = true) @QueryParam("responseFilters") @NotNull  String responseFilters,@ApiParam(value = "The device id") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "The current latitude of the user") @QueryParam("latitude")  Double latitude,@ApiParam(value = "The current longitude of the user") @QueryParam("longitude")  Double longitude,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.loginTwitter(version, accessToken, accessTokenSecret, appKey, responseFilters, deviceId, latitude, longitude, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/account/get")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Login Account (Username)", notes = "Login to system with an account", response = ProfileResponse.class, tags={ "Account", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = ProfileResponse.class)
    })
    public Response loginUsername(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the user's email address they used to sign-up", required = true) @QueryParam("username") @NotNull  String username,@ApiParam(value = "the password", required = true) @QueryParam("password") @NotNull  String password,@ApiParam(value = "the device id") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "the current latitude of the user") @QueryParam("latitude")  Double latitude,@ApiParam(value = "the current longitude of the user") @QueryParam("longitude")  Double longitude,@ApiParam(value = "the app") @QueryParam("app")  String app,@ApiParam(value = "This parameter is deprecated. This is deprecated, use appKey.") @QueryParam("gameType")  String gameType,@ApiParam(value = "the application key") @QueryParam("appKey")  String appKey,@ApiParam(value = "the profile to return") @QueryParam("returnProfile")  Boolean returnProfile,@ApiParam(value = "a comma separated list of ProfileFilters for filtering the returned response data") @QueryParam("responseFilters")  String responseFilters,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.loginUsername(version, username, password, deviceId, latitude, longitude, app, gameType, appKey, returnProfile, responseFilters, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/account/logout")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Logout Account", notes = "Cleans up the users data for logging out.", response = SirqulResponse.class, tags={ "Account", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response logout(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The device id (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "Device Id Type") @QueryParam("deviceIdType")  String deviceIdType,@ApiParam(value = "The account id of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "The current latitude of the user") @QueryParam("latitude")  Double latitude,@ApiParam(value = "The current longitude of the user") @QueryParam("longitude")  Double longitude,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.logout(version, deviceId, deviceIdType, accountId, latitude, longitude, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/account/merge")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Merge Account", notes = "Merges the analytics, achievements, leaderboards of two accounts.", response = SirqulResponse.class, tags={ "Account", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response mergeAccount(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The id of the account to being merged", required = true) @QueryParam("mergeAccountId") @NotNull  Long mergeAccountId,@ApiParam(value = "The application key", required = true) @QueryParam("appKey") @NotNull  String appKey,@ApiParam(value = "The device id (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "The account id of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.mergeAccount(version, mergeAccountId, appKey, deviceId, accountId, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/invite/mission")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Invite to Mission", notes = "Allows a user to invite people to gain access to a mission. This will generate an invite token, which when used, will give the invitee access to a mission (whether it is private or not). The invitee will also become the user's friend when the invitation is accepted.", response = InviteResponse.class, tags={ "Invite", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = InviteResponse.class)
    })
    public Response missionInvite(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "a unique ID given by the device (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "the account ID of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "This parameter is deprecated.") @QueryParam("appId")  Long appId,@ApiParam(value = "the application key") @QueryParam("appKey")  String appKey,@ApiParam(value = "the mission to share") @QueryParam("missionId")  Long missionId,@ApiParam(value = "the current latitude of the user") @QueryParam("latitude")  Double latitude,@ApiParam(value = "the current longitude of the user") @QueryParam("longitude")  Double longitude,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.missionInvite(version, deviceId, accountId, appId, appKey, missionId, latitude, longitude, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/invite/offer")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Invite to Offer", notes = "Allows a user to invite people to favorite an offer. This will generate an invite token, which when used, will give the invitee the offer in their favorite's list.", response = InviteResponse.class, tags={ "Invite", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = InviteResponse.class)
    })
    public Response offerInvite(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the account ID of the user making the share", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "the application key", required = true) @QueryParam("appKey") @NotNull  String appKey,@ApiParam(value = "the ID of the offer used to invite to favorite", required = true) @QueryParam("offerId") @NotNull  Long offerId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.offerInvite(version, accountId, appKey, offerId, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/invite/offerLocation")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Invite to Offer Location", notes = "Allows a user to invite people to favorite an offer location. This will generate an invite token, which when used, will give the invitee the offer location in their favorite's list.", response = InviteResponse.class, tags={ "Invite", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = InviteResponse.class)
    })
    public Response offerLocationInvite(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the account ID of the user making the share", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "the application key", required = true) @QueryParam("appKey") @NotNull  String appKey,@ApiParam(value = "the id of the offer location to share", required = true) @QueryParam("offerLocationId") @NotNull  Long offerLocationId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.offerLocationInvite(version, accountId, appKey, offerLocationId, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/route/{routeId}/optimize")
    
    
    @io.swagger.annotations.ApiOperation(value = "Optimize Route", notes = "Optimize a route. The optimization method based on how the server is configured.", response = Void.class, tags={ "Route", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = Void.class)
    })
    public Response optimizeRoute(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the id of the route to optimize", required = true) @PathParam("routeId") @NotNull  Long routeId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.optimizeRoute(version, routeId, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/ranking/override")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Override User Rank", notes = "Allows an admin of an application to override a user's scores for a leaderboard.", response = SirqulResponse.class, tags={ "Ranking", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response overrideUserRank(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the logged in user's account id (must have permissions to manage data for the application)", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "the end user's account id to override", required = true) @QueryParam("ownerAccountId") @NotNull  Long ownerAccountId,@ApiParam(value = "the application key the leaderboard is for", required = true) @QueryParam("appKey") @NotNull  String appKey,@ApiParam(value = "the rankType of the leaderboard", required = true) @QueryParam("rankType") @NotNull  String rankType,@ApiParam(value = "the total score to update") @QueryParam("totalScore")  Long totalScore,@ApiParam(value = "the total count to update") @QueryParam("totalCount")  Long totalCount,@ApiParam(value = "the total time to update") @QueryParam("totalTime")  Long totalTime,@ApiParam(value = "the daily score to update") @QueryParam("dailyScore")  Long dailyScore,@ApiParam(value = "the daily count to update") @QueryParam("dailyCount")  Long dailyCount,@ApiParam(value = "the daily time to update") @QueryParam("dailyTime")  Long dailyTime,@ApiParam(value = "the weekly score to update") @QueryParam("weeklyScore")  Long weeklyScore,@ApiParam(value = "the weekly count to update") @QueryParam("weeklyCount")  Long weeklyCount,@ApiParam(value = "the weekly time to update") @QueryParam("weeklyTime")  Long weeklyTime,@ApiParam(value = "the monthly score to update") @QueryParam("monthlyScore")  Long monthlyScore,@ApiParam(value = "the monthly count to update") @QueryParam("monthlyCount")  Long monthlyCount,@ApiParam(value = "the monthly time to update") @QueryParam("monthlyTime")  Long monthlyTime,@ApiParam(value = "the top score to update") @QueryParam("topScore")  Long topScore,@ApiParam(value = "the lowest score to update") @QueryParam("lowestScore")  Long lowestScore,@ApiParam(value = "the streak count to update") @QueryParam("streakCount")  Long streakCount,@ApiParam(value = "the best streak count to update") @QueryParam("streakBestCount")  Long streakBestCount,@ApiParam(value = "the start date to update") @QueryParam("startDate")  Long startDate,@ApiParam(value = "the end date to update") @QueryParam("endDate")  Long endDate,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.overrideUserRank(version, accountId, ownerAccountId, appKey, rankType, totalScore, totalCount, totalTime, dailyScore, dailyCount, dailyTime, weeklyScore, weeklyCount, weeklyTime, monthlyScore, monthlyCount, monthlyTime, topScore, lowestScore, streakCount, streakBestCount, startDate, endDate, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/account/passwordchange")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Update Password", notes = "Update the account password.", response = SirqulResponse.class, tags={ "Account", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response passwordChange(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The account to update", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "The current password, used to validate access", required = true) @QueryParam("oldPassword") @NotNull  String oldPassword,@ApiParam(value = "The new password to set, cannot be empty", required = true) @QueryParam("newPassword") @NotNull  String newPassword,@ApiParam(value = "The new password to confirm, must match newPassword", required = true) @QueryParam("confirmPassword") @NotNull  String confirmPassword,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.passwordChange(version, accountId, oldPassword, newPassword, confirmPassword, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/account/passwordreset")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Reset Password", notes = "Reset the account password. The token must be valid and not expired. Use the RequestPasswordReset end point to request a token.", response = SirqulResponse.class, tags={ "Account", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response passwordReset(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The token associated with the account to update, good for 24 hours", required = true) @QueryParam("token") @NotNull  String token,@ApiParam(value = "The new password to set, cannot be empty", required = true) @QueryParam("password") @NotNull  String password,@ApiParam(value = "The new password to confirm, must match newPassword", required = true) @QueryParam("confirm") @NotNull  String confirm,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.passwordReset(version, token, password, confirm, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/vatom/me/vatoms/actions")
    
    
    @io.swagger.annotations.ApiOperation(value = "Perform Action on NFT", notes = "Perform Action on NFT.", response = Void.class, tags={ "Vatom", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = Void.class)
    })
    public Response performActionOnNFT(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "Sirqul Account Id", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "Vatom NFT Id", required = true) @QueryParam("vatomId") @NotNull  String vatomId,@ApiParam(value = "Vatom Action", required = true) @QueryParam("vatomAction") @NotNull  String vatomAction,@ApiParam(value = "Vatom Parameters", required = true) @QueryParam("vatomParameters") @NotNull  String vatomParameters,@ApiParam(value = "Return raw response") @QueryParam("returnRawResponse")  Boolean returnRawResponse,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.performActionOnNFT(version, accountId, vatomId, vatomAction, vatomParameters, returnRawResponse, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/app/post")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Create App Data", notes = "Publish the application data structure.  Can be used to save levels   and scores.  It then returns the application data structure.  The basic   structure is a node tree, with the root node being a AppResponse.  The response   contains the user's profile, messages from the system, and a list of MissionResponse.    A mission can have any number of GameResponses but typically is a single   game type.  A game then has any number of PackResponses which help group   the game levels. Packs are then composed of any number of GameLevelResponses.      Using the various parameters can return the applications default mission   (built-in packs to play), the list of community levels published, the user's   saved levels, or explicity levels desired.  You can choose to include the   profile or not, or just return parts of the profile.  You can also filter   out game levels that have been published with a higher version of the application", response = AppResponse.class, tags={ "AppData", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = AppResponse.class)
    })
    public Response postAppData(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the game to retrieve the data for, use your application key.", required = true) @QueryParam("gameType") @NotNull  String gameType,@ApiParam(value = "start the search results at a record.", required = true) @QueryParam("start") @NotNull  Integer start,@ApiParam(value = "limit the search results to some number.", required = true) @QueryParam("limit") @NotNull  Integer limit,@ApiParam(value = "The analytic data AnalyticListResponse", required = true) @QueryParam("data") @NotNull  String data,@ApiParam(value = "the device id (deviceId or accountId required).") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "the account id of the user (deviceId or accountId required).") @QueryParam("accountId")  Long accountId,@ApiParam(value = "if true then include the game data blob, otherwise don't include.") @QueryParam("includeGameData")  Boolean includeGameData,@ApiParam(value = "This parameter is deprecated.") @QueryParam("q")  String q,@ApiParam(value = "query string used to filter the search results when looking for community and saved levels.") @QueryParam("keyword")  String keyword,@ApiParam(value = "how to sort the results when looking for community and saved levels. possible values are: LEVEL_NAME, LEVEL_CREATED, LEVEL_UPDATED, LEVEL_LIKES, LEVEL_DISLIKES, LEVEL_NOTES, LEVEL_PLAYS.") @QueryParam("sortField")  String sortField,@ApiParam(value = "order the search results descending or ascending when looking for community and saved levels.") @QueryParam("descending")  Boolean descending,@ApiParam(value = "This parameter is deprecated.") @QueryParam("_i")  Integer i,@ApiParam(value = "This parameter is deprecated.") @QueryParam("_l")  Integer l,@ApiParam(value = "if true then include the game object count, otherwise don't include.") @QueryParam("gameObjectCount")  Boolean gameObjectCount,@ApiParam(value = "restrict the search to items with certain permissions, possible values are: MINE, FRIENDS, PUBLIC, ALL_PUBLIC, ALL, LIKED") @QueryParam("filter")  String filter,@ApiParam(value = "restrict the search to items created less then date") @QueryParam("dateCreated")  Long dateCreated,@ApiParam(value = "get levels owned by a particular account") @QueryParam("ownerId")  Long ownerId,@ApiParam(value = "get missions by specified id, comman seperated list of long ids") @QueryParam("missionIds")  String missionIds,@ApiParam(value = "get games by specified id, comman seperated list of long ids") @QueryParam("gameIds")  String gameIds,@ApiParam(value = "get packs by specified id, comman seperated list of long ids") @QueryParam("packIds")  String packIds,@ApiParam(value = "get game levels by specified id, comman seperated list of long ids") @QueryParam("gameLevelIds")  String gameLevelIds,@ApiParam(value = "the application version, used to versin the game level data") @QueryParam("appVersion")  String appVersion,@ApiParam(value = "default is false and will not include any packs that have levels above the specified appVersion. If true then will return all levels regardless of version.") @QueryParam("includeHigherVersionPacks")  Boolean includeHigherVersionPacks,@ApiParam(value = "default is false and will not include any levels above the specified appVersion. If true then will return all levels regardless of version.") @QueryParam("includeHigherVersionLevels")  Boolean includeHigherVersionLevels,@ApiParam(value = "use response groups to include large parts of the structure. possible values are: * MISSION_DEFAULT (default) - include the default mission (built-in packs), excludes all other mission groups * MISSION_DEFAULT_LEVELS_SAVED - include saved levels, excludes all other mission groups * MISSION_DEFAULT_LEVELS_COMMUNITY - include community levels, excludes all other mission groups * MISSION_INVITED (default) - include challenges sent to user * PROFILE (default) - include entire profile * PROFILE_DATA - only include profile date (exclude friends) * PROFILE_FRIENDS - include friends list ") @QueryParam("responseGroups")  String responseGroups,@ApiParam(value = "the will return the correct in app purchases for the device, possible values are: * SIRQUL (default) - purchasing from the sirqul store using tickets * IOS - purchasing from the itunes store for iPhone, iPod, iPod Touch * GOOGLE - purchasing from the google android store * AMAZON - purchasing from the amazon android store * MAC - purchasing from the itunes store for OSX * FREE - the item is free to purchase ") @QueryParam("purchaseType")  String purchaseType,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.postAppData(version, gameType, start, limit, data, deviceId, accountId, includeGameData, q, keyword, sortField, descending, i, l, gameObjectCount, filter, dateCreated, ownerId, missionIds, gameIds, packIds, gameLevelIds, appVersion, includeHigherVersionPacks, includeHigherVersionLevels, responseGroups, purchaseType, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/program/{id}")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Update Program", notes = "Update an existing program", response = Program.class, tags={ "Program", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = Program.class)
    })
    public Response postProgram(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the id of the program", required = true) @PathParam("id") @NotNull  Long id,@ApiParam(value = "") @Valid  Program body,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.postProgram(version, id, body, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/hub/{id}")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Update Service Hub", notes = "Update an existing service hub", response = ServiceHub.class, tags={ "Service Hub", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = ServiceHub.class)
    })
    public Response postServiceHub(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the id of the service hub", required = true) @PathParam("id") @NotNull  Long id,@ApiParam(value = "") @Valid  ServiceHub body,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.postServiceHub(version, id, body, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/wallet/preview")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Preview Wallet Offers", notes = "Preview the final cost of a transaction without charging the user", response = OfferTransactionResponse.class, responseContainer = "List", tags={ "Wallet", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = OfferTransactionResponse.class, responseContainer = "List")
    })
    public Response previewOfferTransaction(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The device id (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "The account id of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "The id of the offer being added (offerId or offeLocationId required)") @QueryParam("offerId")  Long offerId,@ApiParam(value = "The id of the offer location being added (offerId or offeLocationId required)") @QueryParam("offerLocationId")  Long offerLocationId,@ApiParam(value = "A JSON list of offers to purchase.") @QueryParam("offerCart")  String offerCart,@ApiParam(value = "The promoCode") @QueryParam("promoCode")  String promoCode,@ApiParam(value = "Determines the method of purchasing offer. CASH = use card on file, POINTS = use points, TICKETS = use tickets", defaultValue = "CASH") @DefaultValue("CASH") @QueryParam("currencyType")  String currencyType,@ApiParam(value = "Sets the currencyType to POINTS") @QueryParam("usePoints")  Boolean usePoints,@ApiParam(value = "External custom client defined data") @QueryParam("metaData")  String metaData,@ApiParam(value = "The application requesting the purchase, required when currencyType is TICKETS") @QueryParam("appKey")  String appKey,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.previewOfferTransaction(version, deviceId, accountId, offerId, offerLocationId, offerCart, promoCode, currencyType, usePoints, metaData, appKey, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/order/preview")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Preview Order", notes = "Previews a purchase to see the total cost before making it.", response = OrderResponse.class, tags={ "Purchase Order", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = OrderResponse.class)
    })
    public Response previewOrder(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The application requesting the purchase", required = true) @QueryParam("appKey") @NotNull  String appKey,@ApiParam(value = "A JSON list of items to purchase", required = true) @QueryParam("cart") @NotNull  String cart,@ApiParam(value = "The device id (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "The account id of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "A description of the purchase") @QueryParam("description")  String description,@ApiParam(value = "Determines the method of purchasing offer. ```json {   \"VOID\": \"used for when there is no payment involved (ie. for updating the status of a purchase order)\",   \"CASH\": \"use card on file\",   \"POINTS\": \"use account balance\",   \"TICKETS\": \"use tickets\",   \"REFUND\": \"not allowed for a create, requires a paymentTransactionId\",   \"CREDIT\": \"add to the account balance\",   \"RELOAD\": \"charge a credit card then add to the account balance\" } ``` ", allowableValues="VOID, CASH, POINTS, TICKETS, REFUND, CREDIT, RELOAD", defaultValue = "CASH") @DefaultValue("CASH") @QueryParam("currencyType")  String currencyType,@ApiParam(value = "Use a specific payment method (CASH), if not provided use default") @QueryParam("paymentMethodId")  Long paymentMethodId,@ApiParam(value = "Store identifier from external system") @QueryParam("externalOrderId")  String externalOrderId,@ApiParam(value = "Store identifier from external system") @QueryParam("externalPaymentId")  String externalPaymentId,@ApiParam(value = "Remote Reference type") @QueryParam("remoteRefType")  String remoteRefType,@ApiParam(value = "External Date") @QueryParam("externalDate")  Long externalDate,@ApiParam(value = "The Promo Code") @QueryParam("promoCode")  String promoCode,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.previewOrder(version, appKey, cart, deviceId, accountId, description, currencyType, paymentMethodId, externalOrderId, externalPaymentId, remoteRefType, externalDate, promoCode, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/participant/process/all")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Process All Participant Feeds", notes = "Processes all supported participant feeds.", response = SirqulResponse.class, tags={ "Participants", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response processAllParticipants(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The account id of the user", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "The application key used to identify the application") @QueryParam("appKey")  String appKey,@ApiParam(value = "Whether to use short name as the participant ID") @QueryParam("useShortNameAsID")  Boolean useShortNameAsID,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.processAllParticipants(version, accountId, appKey, useShortNameAsID, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/participant/process")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Process Participants Feed", notes = "Processes a participant feed or uploaded file for a specific league.", response = SirqulResponse.class, tags={ "Participants", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response processParticipants(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The account id of the user", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "The league identifier to process", required = true) @QueryParam("league") @NotNull  String league,@ApiParam(value = "The application key used to identify the application") @QueryParam("appKey")  String appKey,@ApiParam(value = "Whether to use short name as the participant ID") @QueryParam("useShortNameAsID")  Boolean useShortNameAsID,@ApiParam(value = "Multipart file containing participant feed contents") @QueryParam("file")  File _file,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.processParticipants(version, accountId, league, appKey, useShortNameAsID, _file, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/trip/match/process")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Process Trip Matches", notes = "Process trip matching, assign trips with no route to matched trips with route.", response = Trip.class, responseContainer = "List", tags={ "Trip", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = Trip.class, responseContainer = "List")
    })
    public Response processTripMatches(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The lower bound date to process matchings") @QueryParam("startDate")  Long startDate,@ApiParam(value = "The upper bound date to process matchings") @QueryParam("endDate")  Long endDate,@ApiParam(value = "the id of the trip to process") @QueryParam("tripId")  Long tripId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.processTripMatches(version, startDate, endDate, tripId, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/secure/purchase")
    @Consumes({ "application/json" })
    @Produces({ "application/json" })
    @io.swagger.annotations.ApiOperation(value = "Purchase Clear", notes = "Purchase via Clear.me. Creates a new account if purchasing for the first time.", response = ProfileResponse.class, tags={ "SecureApp", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = ProfileResponse.class)
    })
    public Response purchaseSecure(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The payment request object", required = true) @NotNull @Valid  PaymentRequest body,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.purchaseSecure(version, body, securityContext);
    }
    @javax.ws.rs.PUT
    @Path("/program/{id}")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Update Program", notes = "Update an existing program", response = Program.class, tags={ "Program", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = Program.class)
    })
    public Response putProgram(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the id of the program", required = true) @PathParam("id") @NotNull  Long id,@ApiParam(value = "") @Valid  Program body,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.putProgram(version, id, body, securityContext);
    }
    @javax.ws.rs.PUT
    @Path("/hub/{id}")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Update Service Hub", notes = "Update an existing service hub", response = ServiceHub.class, tags={ "Service Hub", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = ServiceHub.class)
    })
    public Response putServiceHub(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the id of the service hub", required = true) @PathParam("id") @NotNull  Long id,@ApiParam(value = "") @Valid  ServiceHub body,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.putServiceHub(version, id, body, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/queue/create")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Create Queue", notes = "Create a basic AMQP queue. If the username and password and virtual host is not sepcified, the queue will be created on the virtual host assigned to the application.", response = QueueResponse.class, tags={ "AMQP", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = QueueResponse.class)
    })
    public Response queueCreate(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The application key unique to each application.", required = true) @QueryParam("appKey") @NotNull  String appKey,@ApiParam(value = "The name of the queue to create", required = true) @QueryParam("name") @NotNull  String name,@ApiParam(value = "The client deviceID") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "The logged in user ID") @QueryParam("accountId")  Long accountId,@ApiParam(value = "The number of workers to generate ", defaultValue = "1") @DefaultValue("1") @QueryParam("workers")  Integer workers,@ApiParam(value = "If provided the analytic processing will publsih to this queue instead of the default one for the provided list of tags") @QueryParam("analyticTags")  String analyticTags,@ApiParam(value = "The hostname of the server the queue is hosted on") @QueryParam("hostname")  String hostname,@ApiParam(value = "The port of the server the queue is hosted on") @QueryParam("port")  Integer port,@ApiParam(value = "The username to access the server that the queue is on") @QueryParam("username")  String username,@ApiParam(value = "The password to access the queue to connect to") @QueryParam("password")  String password,@ApiParam(value = "The virtual host defined on the server to queue") @QueryParam("virtualHost")  String virtualHost,@ApiParam(value = "Use SSL") @QueryParam("useSSL")  Boolean useSSL,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.queueCreate(version, appKey, name, deviceId, accountId, workers, analyticTags, hostname, port, username, password, virtualHost, useSSL, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/queue/delete")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Delete Queue", notes = "Delete the stored queue record and close any active connections to the AMQP servers.", response = SirqulResponse.class, tags={ "AMQP", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response queueDelete(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The id of the queue to find", required = true) @QueryParam("queueId") @NotNull  Long queueId,@ApiParam(value = "The client device ID") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "The logged in user ID") @QueryParam("accountId")  Long accountId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.queueDelete(version, queueId, deviceId, accountId, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/queue/get")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Get Queue", notes = "Get the stored queue record. Must supply the queueId, or the name and hostname and virtualHost, or the name and appKey to find the record.", response = QueueResponse.class, tags={ "AMQP", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = QueueResponse.class)
    })
    public Response queueGet(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The client device ID") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "The logged in user ID") @QueryParam("accountId")  Long accountId,@ApiParam(value = "The id of the queue to find") @QueryParam("queueId")  Long queueId,@ApiParam(value = "The application key the queue was assigned to") @QueryParam("appKey")  String appKey,@ApiParam(value = "The name of the queue to find") @QueryParam("name")  String name,@ApiParam(value = "The hostname of the queue to find") @QueryParam("hostname")  String hostname,@ApiParam(value = "The virtual host of the queue to find") @QueryParam("virtualHost")  String virtualHost,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.queueGet(version, deviceId, accountId, queueId, appKey, name, hostname, virtualHost, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/queue/publish")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Publish Queue", notes = "Publish a message to a stored queue. Must supply the queueId, or the name and hostname and virtualHost, or the name and appKey to find the record.", response = SirqulResponse.class, tags={ "AMQP", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response queuePublish(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The payload to send to the queue", required = true) @QueryParam("message") @NotNull  String message,@ApiParam(value = "The id of the queue to publish to") @QueryParam("queueId")  Long queueId,@ApiParam(value = "The application key the queue was assigned to") @QueryParam("appKey")  String appKey,@ApiParam(value = "The name of the queue to publish to or the analytic tag to handle if the analytic param is true") @QueryParam("name")  String name,@ApiParam(value = "The hostname of the server the queue is hosted on") @QueryParam("hostname")  String hostname,@ApiParam(value = "The virtual host defined on the server to queue") @QueryParam("virtualHost")  String virtualHost,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.queuePublish(version, message, queueId, appKey, name, hostname, virtualHost, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/queue/search")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Search Queue", notes = "Get the queues setup for the BillableEntity's applications.", response = QueueResponse.class, tags={ "AMQP", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = QueueResponse.class)
    })
    public Response queueSearch(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The id of the queue to find") @QueryParam("queueId")  Long queueId,@ApiParam(value = "The client device ID") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "The logged in user ID") @QueryParam("accountId")  Long accountId,@ApiParam(value = "The name of the queue to find") @QueryParam("name")  String name,@ApiParam(value = "Start of the index", defaultValue = "0") @DefaultValue("0") @QueryParam("start")  Integer start,@ApiParam(value = "Limit of the index", defaultValue = "10") @DefaultValue("10") @QueryParam("limit")  Integer limit,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.queueSearch(version, queueId, deviceId, accountId, name, start, limit, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/queue/update")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Update Queue", notes = "Update the basic AMQP queue.", response = QueueResponse.class, tags={ "AMQP", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = QueueResponse.class)
    })
    public Response queueUpdate(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The id of the queue to update", required = true) @QueryParam("queueId") @NotNull  Long queueId,@ApiParam(value = "The client deviceID") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "The logged in user ID") @QueryParam("accountId")  Long accountId,@ApiParam(value = "The application key unique to each application.") @QueryParam("appKey")  String appKey,@ApiParam(value = "The number of workers to generate") @QueryParam("workers")  Integer workers,@ApiParam(value = "If provided the analytic processing will publsih to this queue instead of the default one for the provided list of tags") @QueryParam("analyticTags")  String analyticTags,@ApiParam(value = "The hostname of the server the queue is hosted on") @QueryParam("hostname")  String hostname,@ApiParam(value = "The port of the server the queue is hosted on") @QueryParam("port")  Integer port,@ApiParam(value = "The username to access the server that the queue is on") @QueryParam("username")  String username,@ApiParam(value = "The password to access the queue to connect to") @QueryParam("password")  String password,@ApiParam(value = "The virtual host defined on the server to queue") @QueryParam("virtualHost")  String virtualHost,@ApiParam(value = "the SSL to use") @QueryParam("useSSL")  Boolean useSSL,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.queueUpdate(version, queueId, deviceId, accountId, appKey, workers, analyticTags, hostname, port, username, password, virtualHost, useSSL, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/vatom/b/redemptions")
    
    
    @io.swagger.annotations.ApiOperation(value = "Redeem NFT", notes = "Redeem an NFT.", response = Void.class, tags={ "Vatom", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = Void.class)
    })
    public Response redeemNFT(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "Sirqul Account Id", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "Sirqul Application Key", required = true) @QueryParam("appKey") @NotNull  String appKey,@ApiParam(value = "Vatom Parameters", required = true) @QueryParam("vatomParameters") @NotNull  String vatomParameters,@ApiParam(value = "Return raw response") @QueryParam("returnRawResponse")  Boolean returnRawResponse,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.redeemNFT(version, accountId, appKey, vatomParameters, returnRawResponse, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/retailer/offer/transaction/update")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Update Offer Transaction", notes = "Redeems an offer.", response = SirqulResponse.class, tags={ "Offer", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response redeemOfferTransaction(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the OfferTransaction ID of the transaction being redeemed", required = true) @QueryParam("offerTransactionId") @NotNull  Long offerTransactionId,@ApiParam(value = "the status to set the offer transaction to - 1 sets it to redeemable and 2 sets it to redeemed", required = true) @QueryParam("status") @NotNull  Integer status,@ApiParam(value = "the device id (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "the account id of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "the OfferLocation ID where the offer is being redeemed") @QueryParam("offerLocationId")  Long offerLocationId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.redeemOfferTransaction(version, offerTransactionId, status, deviceId, accountId, offerLocationId, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/vatom/b/users/coins/redeem")
    
    
    @io.swagger.annotations.ApiOperation(value = "Redeem the coins for a user (as a Business)", notes = "Redeem the coins for a user (as a Business).", response = Void.class, tags={ "Vatom", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = Void.class)
    })
    public Response redeemUserCoinsAsBusiness(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "Sirqul Account Id", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "Vatom User Id", required = true) @QueryParam("vatomUserId") @NotNull  String vatomUserId,@ApiParam(value = "Sirqul Application Key", required = true) @QueryParam("appKey") @NotNull  String appKey,@ApiParam(value = "Vatom Parameters", required = true) @QueryParam("vatomParameters") @NotNull  String vatomParameters,@ApiParam(value = "Return raw response") @QueryParam("returnRawResponse")  Boolean returnRawResponse,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.redeemUserCoinsAsBusiness(version, accountId, vatomUserId, appKey, vatomParameters, returnRawResponse, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/app/regen")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Regenerate App Data", notes = "Regenerate the app data cache for apps", response = SirqulResponse.class, tags={ "AppData", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response regenAppData(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the account id of the user") @QueryParam("accountId")  Long accountId,@ApiParam(value = "process a specific application, if null process all apps with caches") @QueryParam("appKey")  String appKey,@ApiParam(value = "create a specific version, if null use current version. Be careful if processing all") @QueryParam("buildVersion")  String buildVersion,@ApiParam(value = "create a specific version, if null use current version. Be careful if processing all") @QueryParam("apiVersion")  String apiVersion,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.regenAppData(version, accountId, appKey, buildVersion, apiVersion, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/like")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Create Like", notes = "Allows a user to like or dislike accounts, albums, album contests, assets, game levels, notes, and theme descriptors. Multiple likes\\dislikes on the same object will replace the previous one.", response = LikableResponse.class, tags={ "Like", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = LikableResponse.class)
    })
    public Response registerLike(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The type of likable object {ALBUM, ALBUM_CONTEST, ASSET, GAME_LEVEL, NOTE, THEME_DESCRIPTOR}", required = true) @QueryParam("likableType") @NotNull  String likableType,@ApiParam(value = "The id of the likable object", required = true) @QueryParam("likableId") @NotNull  Long likableId,@ApiParam(value = "The unique device identifier that made the request (either deviceId or accountId must be used)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "The unique accountId that made the request (either deviceId or accountId must be used)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "This is used for sending out group notifications. For example, when someone likes an asset which is also a part of an album, everyone in the album will receive a notification. This is achieved by passing in the permissionable type (in this case \"album\"), and the permissionable id (the album id). Possible types: {ALBUM, ALBUM_CONTEST, GAME_LEVEL, THEME_DESCRIPTOR}") @QueryParam("permissionableType")  String permissionableType,@ApiParam(value = "The id of the permissionable object (for sending group notifications)") @QueryParam("permissionableId")  Long permissionableId,@ApiParam(value = "determines whether the user likes or dislikes the object") @QueryParam("like")  Boolean like,@ApiParam(value = "This parameter is deprecated. This is deprecated, use \"appKey\" instead.") @QueryParam("app")  String app,@ApiParam(value = "This parameter is deprecated. This is deprecated, use \"appKey\" instead.") @QueryParam("gameType")  String gameType,@ApiParam(value = "the application key") @QueryParam("appKey")  String appKey,@ApiParam(value = "The current location of the user") @QueryParam("latitude")  Double latitude,@ApiParam(value = "The current location of the user") @QueryParam("longitude")  Double longitude,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.registerLike(version, likableType, likableId, deviceId, accountId, permissionableType, permissionableId, like, app, gameType, appKey, latitude, longitude, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/notification/token")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Register Notification Token", notes = "Register a token to send application dependent notifications like Google Cloud Messaging, or Apple Push Notifications.", response = SirqulResponse.class, tags={ "Notification", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response registerNotificationToken(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "A token that is generated by the device to sign requests for the notification service providers", required = true) @QueryParam("token") @NotNull  String token,@ApiParam(value = "The type of push notification. Possible values include: APNS, GCM", required = true, allowableValues="APNS, GCM, BAIDU, XGPUSH, JPUSH") @QueryParam("pushType") @NotNull  String pushType,@ApiParam(value = "The unique id of the device making the request (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "The account id of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "Determines if the token is a DEVELOPMENT or PRODUCTION token") @QueryParam("environment")  String environment,@ApiParam(value = "The application key") @QueryParam("appKey")  String appKey,@ApiParam(value = "This parameter is deprecated (use appKey instead)") @QueryParam("gameType")  String gameType,@ApiParam(value = "Sets whether the token is active or not (non-active tokens are not used)") @QueryParam("active")  Boolean active,@ApiParam(value = "Latitude used to update the user's current location") @QueryParam("latitude")  Double latitude,@ApiParam(value = "Longitude used to update the user's current location") @QueryParam("longitude")  Double longitude,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.registerNotificationToken(version, token, pushType, deviceId, accountId, environment, appKey, gameType, active, latitude, longitude, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/album/delete")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Delete Album", notes = "Deletes an Album", response = SirqulResponse.class, tags={ "Album", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response removeAlbum(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the album ID to delete", required = true) @QueryParam("albumId") @NotNull  Long albumId,@ApiParam(value = "a unique ID given by the device (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "the account ID of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.removeAlbum(version, albumId, deviceId, accountId, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/album/user/delete")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Remove Album Users", notes = "Remove participants of an album.", response = SirqulResponse.class, tags={ "Album", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response removeAlbumUsers(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the album ID", required = true) @QueryParam("albumId") @NotNull  Long albumId,@ApiParam(value = "remove friend group", required = true) @QueryParam("removeFriendGroup") @NotNull  Boolean removeFriendGroup,@ApiParam(value = "a unique ID given by the device (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "the account ID of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "comma separated list of connection IDs") @QueryParam("connections")  String connections,@ApiParam(value = "comma separated list of connection group IDs") @QueryParam("connectionGroups")  String connectionGroups,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.removeAlbumUsers(version, albumId, removeFriendGroup, deviceId, accountId, connections, connectionGroups, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/asset/remove")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Remove Asset from Collection", notes = "Remove assets from collections", response = SirqulResponse.class, tags={ "Asset", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response removeAsset(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the id of the asset to remove", required = true) @QueryParam("assetId") @NotNull  String assetId,@ApiParam(value = "the device id (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "the account id of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "the album id to remove the asset from") @QueryParam("albumId")  Long albumId,@ApiParam(value = "the collection id to remove the asset from") @QueryParam("collectionId")  Long collectionId,@ApiParam(value = "remove from the user's profile album") @QueryParam("removeFromDefaultAlbums")  Boolean removeFromDefaultAlbums,@ApiParam(value = "latitude used to update the user's current location") @QueryParam("latitude")  Double latitude,@ApiParam(value = "longitude used to update the user's current location") @QueryParam("longitude")  Double longitude,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.removeAsset(version, assetId, deviceId, accountId, albumId, collectionId, removeFromDefaultAlbums, latitude, longitude, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/consumer/connection/group/removeConnection")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Delete Connection", notes = "Removes the connection from group.", response = SirqulResponse.class, tags={ "Connection", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response removeConnectionFromGroup(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "whether to return nulls or not", required = true) @QueryParam("returnNulls") @NotNull  Boolean returnNulls,@ApiParam(value = "the group id", required = true) @QueryParam("groupId") @NotNull  Long groupId,@ApiParam(value = "the device id (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "the account id of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "the connection id") @QueryParam("connectionId")  Long connectionId,@ApiParam(value = "the connection account id") @QueryParam("connectionAccountId")  Long connectionAccountId,@ApiParam(value = "the pending id") @QueryParam("pendingId")  Long pendingId,@ApiParam(value = "the current latitude of the user") @QueryParam("latitude")  Double latitude,@ApiParam(value = "the current longitude of the user") @QueryParam("longitude")  Double longitude,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.removeConnectionFromGroup(version, returnNulls, groupId, deviceId, accountId, connectionId, connectionAccountId, pendingId, latitude, longitude, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/connection/group/removeConnections")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Remove Connections", notes = "Remove a list of connections from a group.", response = SirqulResponse.class, tags={ "Connection", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response removeConnectionsFromGroup(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "connection group id", required = true) @QueryParam("connectionGroupId") @NotNull  Long connectionGroupId,@ApiParam(value = "the device id (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "the account id of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "comma separated list of connection ids") @QueryParam("connectionIds")  String connectionIds,@ApiParam(value = "comma separated list of connection account ids") @QueryParam("connectionAccountIds")  String connectionAccountIds,@ApiParam(value = "the current latitude of the user") @QueryParam("latitude")  Double latitude,@ApiParam(value = "the current longitude of the user") @QueryParam("longitude")  Double longitude,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.removeConnectionsFromGroup(version, connectionGroupId, deviceId, accountId, connectionIds, connectionAccountIds, latitude, longitude, securityContext);
    }
    @javax.ws.rs.DELETE
    @Path("/cargo/dependent/{accountId}")
    
    
    @io.swagger.annotations.ApiOperation(value = "Delete Dependent", notes = "Delete the Dependent", response = Void.class, tags={ "Dependent", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = Void.class)
    })
    public Response removeDependent(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the id of the parent account tied to the dependent", required = true) @PathParam("accountId") @NotNull  Long accountId,@ApiParam(value = "the id of the dependent to delete", required = true) @PathParam("dependentId") @NotNull  Long dependentId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.removeDependent(version, accountId, dependentId, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/consumer/connection/group/remove")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Delete Connection Group", notes = "Remove a user's group.", response = SirqulResponse.class, tags={ "Connection", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response removeGroup(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "whether to return nulls or not", required = true) @QueryParam("returnNulls") @NotNull  Boolean returnNulls,@ApiParam(value = "the group id", required = true) @QueryParam("groupId") @NotNull  Long groupId,@ApiParam(value = "the device id (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "the account id of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "the current latitude of the user") @QueryParam("latitude")  Double latitude,@ApiParam(value = "the current longitude of the user") @QueryParam("longitude")  Double longitude,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.removeGroup(version, returnNulls, groupId, deviceId, accountId, latitude, longitude, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/like/delete")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Delete Like", notes = "Removes a like. This will make the user \"neutral\".", response = LikableResponse.class, tags={ "Like", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = LikableResponse.class)
    })
    public Response removeLike(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The type of the likable object {ALBUM, ALBUM_CONTEST, ASSET, GAME_LEVEL, NOTE, THEME_DESCRIPTOR}", required = true) @QueryParam("likableType") @NotNull  String likableType,@ApiParam(value = "The id of the likable object", required = true) @QueryParam("likableId") @NotNull  Long likableId,@ApiParam(value = "The unique device identifier that made the request (either deviceId or accountId must be used)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "The unique accountId that made the request (either deviceId or accountId must be used)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "The current location of the user") @QueryParam("latitude")  Double latitude,@ApiParam(value = "The current location of the user") @QueryParam("longitude")  Double longitude,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.removeLike(version, likableType, likableId, deviceId, accountId, latitude, longitude, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/creative/removepreview")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Remove Preview", notes = "Remove this ad for preview for this account.", response = SirqulResponse.class, tags={ "Creative", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response removePreview(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the ID of the logged in user", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "the ID of the creative to remove preview", required = true) @QueryParam("creativeId") @NotNull  Long creativeId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.removePreview(version, accountId, creativeId, securityContext);
    }
    @javax.ws.rs.DELETE
    @Path("/route/{routeId}/stop/{stopId}")
    
    
    @io.swagger.annotations.ApiOperation(value = "Delete Stop", notes = "Delete a stop on a route", response = Void.class, tags={ "Route", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = Void.class)
    })
    public Response removeStop(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the id of the route", required = true) @PathParam("routeId") @NotNull  Long routeId,@ApiParam(value = "the id of the specific stop to delete on the route", required = true) @PathParam("stopId") @NotNull  Long stopId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.removeStop(version, routeId, stopId, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/consumer/connection/group/removeSubGroup")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Remove Connection Groups", notes = "Remove sub groups from a group", response = SirqulResponse.class, tags={ "Connection", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response removeSubGroups(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "whether to return nulls or not", required = true) @QueryParam("returnNulls") @NotNull  Boolean returnNulls,@ApiParam(value = "the parent group id", required = true) @QueryParam("groupId") @NotNull  Long groupId,@ApiParam(value = "comma separated list of group IDs to remove from the parent group", required = true) @QueryParam("subGroupIds") @NotNull  String subGroupIds,@ApiParam(value = "the device id (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "the account id of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "the current latitude of the user") @QueryParam("latitude")  Double latitude,@ApiParam(value = "the current longitude of the user") @QueryParam("longitude")  Double longitude,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.removeSubGroups(version, returnNulls, groupId, subGroupIds, deviceId, accountId, latitude, longitude, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/consumer/theme/remove")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Delete Theme", notes = "Removes a theme.", response = SirqulResponse.class, tags={ "Theme Descriptor", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response removeThemeDescriptor(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the theme id to remove", required = true) @QueryParam("themeDescriptorId") @NotNull  Long themeDescriptorId,@ApiParam(value = "a unique id given by the device (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "the account id of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "the unique title of an application given from the admin tool") @QueryParam("gameType")  String gameType,@ApiParam(value = "latitude used to update the user's current location") @QueryParam("latitude")  Double latitude,@ApiParam(value = "longitude used to update the user's current location") @QueryParam("longitude")  Double longitude,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.removeThemeDescriptor(version, themeDescriptorId, deviceId, accountId, gameType, latitude, longitude, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/consumer/permissions/remove")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Remove User", notes = "Used to remove someone (assuming they have permission) from a permissionable object", response = SirqulResponse.class, tags={ "User Permissions", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response removeUsersFromPermissionable(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the permissionable type of the object", required = true, allowableValues="ACCOUNT, GAMELEVEL, ALBUM_CONTEST, THEME_DESCRIPTOR, SCHEDULED_NOTIFICATION, TASK, TRIGGER") @QueryParam("permissionableType") @NotNull  String permissionableType,@ApiParam(value = "the id of the permissionable object", required = true) @QueryParam("permissionableId") @NotNull  Long permissionableId,@ApiParam(value = "the device id (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "the account id of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "a comma separated list of connection ids (NOT the account ids)") @QueryParam("connectionIds")  String connectionIds,@ApiParam(value = "a comma separated list of account ids") @QueryParam("connectionAccountIds")  String connectionAccountIds,@ApiParam(value = "a comma separated list of connection group ids (these are groups made by the user)") @QueryParam("connectionGroupIds")  String connectionGroupIds,@ApiParam(value = "flag to determine whether to remove the built-in \"friends\" group", defaultValue = "false") @DefaultValue("false") @QueryParam("removeFriendGroup")  Boolean removeFriendGroup,@ApiParam(value = "the current latitude of the user") @QueryParam("latitude")  Double latitude,@ApiParam(value = "the current longitude of the user") @QueryParam("longitude")  Double longitude,@ApiParam(value = "comma separated list of audience ids. This will remove all users from these audiences from the permissionable object. Notifications will not be sent to users if this feature is used.") @QueryParam("audienceIds")  String audienceIds,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.removeUsersFromPermissionable(version, permissionableType, permissionableId, deviceId, accountId, connectionIds, connectionAccountIds, connectionGroupIds, removeFriendGroup, latitude, longitude, audienceIds, securityContext);
    }
    @javax.ws.rs.PATCH
    @Path("/route/{routeId}/stops/reorder")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Reorder Route Stops", notes = "Reordering the stops on the route with and update route distance, time, direction, and polyline", response = Stop.class, responseContainer = "List", tags={ "Route", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = Stop.class, responseContainer = "List")
    })
    public Response reorderRouteStopsPatch(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the id of the route", required = true) @PathParam("routeId") @NotNull  Long routeId,@ApiParam(value = "") @Valid  List<@Valid Stop> body,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.reorderRouteStopsPatch(version, routeId, body, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/route/{routeId}/stops/reorder")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Reorder Route Stops", notes = "Reordering the stops on the route with and update route distance, time, direction, and polyline", response = Stop.class, responseContainer = "List", tags={ "Route", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = Stop.class, responseContainer = "List")
    })
    public Response reorderRouteStopsPost(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the id of the route", required = true) @PathParam("routeId") @NotNull  Long routeId,@ApiParam(value = "") @Valid  List<@Valid Stop> body,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.reorderRouteStopsPost(version, routeId, body, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/optimize/request")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Request Optimization", notes = "Request and upload of shipment orders and create ShipmentImportBatch for optimization.", response = ImportStatuses.class, tags={ "Optimize", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = ImportStatuses.class)
    })
    public Response requestOptimization(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "") @Valid  Orders body,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.requestOptimization(version, body, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/account/requestpasswordreset")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Request Password Reset", notes = "Request that an account password be reset. The account is looked up by email address and then a link is sent via email to that account with a reset token. The token is valid for 24 hours.", response = SirqulResponse.class, tags={ "Account", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response requestPasswordReset(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The email/username of the account", required = true) @QueryParam("email") @NotNull  String email,@ApiParam(value = "this is the sender email", defaultValue = "Sirqul") @DefaultValue("Sirqul") @QueryParam("from")  String from,@ApiParam(value = "this is the domain (like dev.sirqul.com) used to generate the password reset link") @QueryParam("domain")  String domain,@ApiParam(value = "this is the the subUrl (like resetpassword) used to generate a password reset link") @QueryParam("subUrl")  String subUrl,@ApiParam(value = "this is used to generate a password reset link", defaultValue = "http://dev.sirqul.com/resetpassword") @DefaultValue("http://dev.sirqul.com/resetpassword") @QueryParam("referer")  String referer,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.requestPasswordReset(version, email, from, domain, subUrl, referer, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/account/requestValidateAccount")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Send Validation Request", notes = "Send an email to validate a user's account.", response = SirqulResponse.class, tags={ "Account", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response requestValidateAccount(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The account id of the user", required = true) @QueryParam("accountId") @NotNull  Long accountId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.requestValidateAccount(version, accountId, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/reservable/availability/update")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Update Availability", notes = "", response = AvailabilityResponse.class, responseContainer = "List", tags={ "Reservation", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = AvailabilityResponse.class, responseContainer = "List")
    })
    public Response reservableAvailability(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the id of the reservation", required = true) @QueryParam("reservableId") @NotNull  Long reservableId,@ApiParam(value = "the type of reservation", required = true, allowableValues="LOCATABLE, RESERVABLE, PERMISSIONABLE, NOTABLE, ASSETABLE, LIKABLE, FLAGABLE, FAVORITABLE, RATABLE, ALBUM, COLLECTION, APPLICATION, APPLICATION_SETTING, APPLICATION_CERT, APPLICATION_PLACEMENT, ACCOUNT, ACCOUNT_SETTING, GAME_LEVEL, PACK, MISSION, TOURNAMENT, ASSET, ALBUM_CONTEST, THEME_DESCRIPTOR, OFFER, OFFER_LOCATION, EVENT, RETAILER, RETAILER_LOCATION, NOTE, CREATIVE, FAVORITE, LIKE, RATING, ANALYTIC, THIRD_PARTY_CREDENTIAL, THIRD_PARTY_NETWORK, REGION") @QueryParam("reservableType") @NotNull  String reservableType,@ApiParam(value = "the device id of the reservation") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "the id of the logged in user") @QueryParam("accountId")  Long accountId,@ApiParam(value = "Availability") @QueryParam("availability")  String availability,@ApiParam(value = "Availability Summary") @QueryParam("availabilitySummary")  String availabilitySummary,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.reservableAvailability(version, reservableId, reservableType, deviceId, accountId, availability, availabilitySummary, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/secure/application/reset")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Rest Secure Application", notes = "Reset a secure application client.", response = SirqulResponse.class, tags={ "SecureApp", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response resetSecure(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The unique id of the user making the request", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "The application to secure", required = true) @QueryParam("appKey") @NotNull  String appKey,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.resetSecure(version, accountId, appKey, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/invite/retailerLocation")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Invite to Retailer Location", notes = "Allows a user to invite people to favorite a retailer location. This will generate an invite token, which when used, will give the invitee the retailer location in their favorite's list.", response = InviteResponse.class, tags={ "Invite", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = InviteResponse.class)
    })
    public Response retailerLocationInvite(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the account ID of the user making the share", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "the application key", required = true) @QueryParam("appKey") @NotNull  String appKey,@ApiParam(value = "The retailer location id of where the event will take place", required = true) @QueryParam("retailerLocationId") @NotNull  Long retailerLocationId,@ApiParam(value = "Optional album id to link with the invite") @QueryParam("albumId")  Long albumId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.retailerLocationInvite(version, accountId, appKey, retailerLocationId, albumId, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/retailer/login")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Login Retailer", notes = "Retailer login check.", response = AccountLoginResponse.class, tags={ "Retailer", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = AccountLoginResponse.class)
    })
    public Response retailerLoginCheck(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the user's email address they used to sign-up", required = true) @QueryParam("username") @NotNull  String username,@ApiParam(value = "the password", required = true) @QueryParam("password") @NotNull  String password,@ApiParam(value = "the device id (optional)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "the current latitude of the user") @QueryParam("latitude")  Double latitude,@ApiParam(value = "the current longitude of the user") @QueryParam("longitude")  Double longitude,@ApiParam(value = "the application key") @QueryParam("appKey")  String appKey,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.retailerLoginCheck(version, username, password, deviceId, latitude, longitude, appKey, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/trip/{id}/ride")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Set Trip Preference Rider", notes = "Update trip preference to ride.", response = Trip.class, tags={ "Trip", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = Trip.class)
    })
    public Response ride(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the id of the trip", required = true) @PathParam("id") @NotNull  Long id,@ApiParam(value = "the frequency of the trip (e.g. weekly, until 2018-08-09)", required = true) @QueryParam("recurrence") @NotNull  Boolean recurrence,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.ride(version, id, recurrence, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/report/run")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Run Report", notes = " This endpoint allows you to run a set of predefined reports that can be used to understand your users' behavior as well as trends within your application.", response = ReportResponse.class, tags={ "Reporting", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = ReportResponse.class)
    })
    public Response runReport(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "If true then descending order, false is ascending", required = true) @QueryParam("desc") @NotNull  Boolean desc,@ApiParam(value = "The account id of the user for passing account related params") @QueryParam("accountId")  Long accountId,@ApiParam(value = "The named identifier of the query") @QueryParam("query")  String query,@ApiParam(value = "Parameter values used in the query in JSON format, example: ```json {   \"string\":\"value\",    \"number\":3.345,   \"date\":\"2014-05-01 00:00:00\" } ``` ") @QueryParam("parameters")  String parameters,@ApiParam(value = "The order to use, must be a column name (see response results for list of column names)") @QueryParam("order")  String order,@ApiParam(value = "The start of the pagination") @QueryParam("start")  Long start,@ApiParam(value = "The limit of the pagination") @QueryParam("limit")  Long limit,@ApiParam(value = "Determines what response format to return. Options are: JSON or CSV", allowableValues="HTML, XML, JSON, CSV") @QueryParam("responseFormat")  String responseFormat,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.runReport(version, desc, accountId, query, parameters, order, start, limit, responseFormat, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/workflow/run")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Run Workflow", notes = "Runs a published executable workflow", response = SirqulResponse.class, tags={ "Workflow", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response runWorkflow(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the account ID of the user", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "the workflow to run", required = true) @QueryParam("workflowId") @NotNull  Long workflowId,@ApiParam(value = "this runs a particular sku on the workflow") @QueryParam("skuId")  Long skuId,@ApiParam(value = "this runs a particular sku version on the workflow") @QueryParam("versionCode")  Integer versionCode,@ApiParam(value = "Override parameters in JSON format. Example: ```json {   \"arguments_81\": { \"filter\": \"PUBLIC\" },   \"arguments_87\": { \"tag\": \"custom_tag\" } } ``` ") @QueryParam("parameters")  String parameters,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.runWorkflow(version, accountId, workflowId, skuId, versionCode, parameters, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/ticket/save")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Save Ticket", notes = "Allow user to acquire a purchase item and generate a ticket record. Used to redeem tickets or add tickets to the system.", response = ProfileResponse.class, tags={ "Ticket", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = ProfileResponse.class)
    })
    public Response saveTicket(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the action being performed, values: COMPLETED, // ADD TICKETS FOR COMPLETING A MISSION, CHALLENGE, GAME, PACK, LEVEL, LEVEL OBJECT REDEEMED, // REMOVE TICKETS FOR BUYING PACKS, HINTS, AND PEN TOOLS OPTIONS, ETC USERS_PLAYED, // ADD TICKETS FOR LEVELS PLAYED BY OTHER USERS TOURNAMENT_OWNER, // ADD TICKETS FOR TOURNAMENTS BY OTHER USERS PURCHASED, // ADD TICKET VIA IN APP PURCHASING SUMATION, // SUMATION OF TICKETS EARNED FROM CHILDREN GIFTED, // TRANSFERING OF PURCHASE ITEMS TO OTHER PEOPLE REFUNDED // FOR REFUNDING TICKETS BACK TO THE USER", required = true) @QueryParam("actionType") @NotNull  String actionType,@ApiParam(value = "the type of object being purchased, values: GAME_OBJECT, GAME_LEVEL, PACK, GAME, MISSION, PROFILE, APPLICATION, TICKETS, ASSET, CUSTOM", required = true) @QueryParam("ticketObjectType") @NotNull  String ticketObjectType,@ApiParam(value = "whether to return nulls or not") @QueryParam("returnNulls")  Boolean returnNulls,@ApiParam(value = "the device id that owns the tickets") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "the account id that owns the tickets") @QueryParam("accountId")  Long accountId,@ApiParam(value = "This parameter is deprecated. deprecated, use the appKey") @QueryParam("gameType")  String gameType,@ApiParam(value = "the application key") @QueryParam("appKey")  String appKey,@ApiParam(value = "the ID of the item being purchased") @QueryParam("objectId")  Long objectId,@ApiParam(value = "a unique string identifier defined by the application owner or Executive") @QueryParam("purchaseCode")  String purchaseCode,@ApiParam(value = "a unique transaction identifier from the purchase provider (i.e. the transaction ID from iTunes, Google Play, etc)") @QueryParam("receiptToken")  String receiptToken,@ApiParam(value = "the receipt/transaction data for validating a purchase via iTunes/Gooogle/etc. This should be in string format.") @QueryParam("receiptData")  String receiptData,@ApiParam(value = "the count of tickets") @QueryParam("count")  Long count,@ApiParam(value = "the ticket type") @QueryParam("ticketType")  String ticketType,@ApiParam(value = "the provider for making the purchase {ITUNES, ITUNES_SANDBOX, GOOGLE}") @QueryParam("purchaseProvider")  String purchaseProvider,@ApiParam(value = "a comma separated list of purchase types { SIRQUL, // purchasing from the sirqul store using tickets IOS, // purchasing from the itunes store for iPhone, iPod, iPod Touch GOOGLE, // purchasing from the google android store AMAZON, // purchasing from the amazon android store MAC, // purchasing from the itunes store for OSX WP8, // purhasing from the windows phone 8 store FREE }") @QueryParam("purchaseType")  String purchaseType,@ApiParam(value = "returns a ProfileResponse if true, otherwise will return an AppResponse") @QueryParam("returnProfileResponse")  Boolean returnProfileResponse,@ApiParam(value = "if returnProfileResponse is false, will return an AppResponse with profile data if true") @QueryParam("includeProfileResponse")  Boolean includeProfileResponse,@ApiParam(value = "the application version") @QueryParam("appVersion")  String appVersion,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.saveTicket(version, actionType, ticketObjectType, returnNulls, deviceId, accountId, gameType, appKey, objectId, purchaseCode, receiptToken, receiptData, count, ticketType, purchaseProvider, purchaseType, returnProfileResponse, includeProfileResponse, appVersion, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/ticket/save/fileUpload")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Save Ticket with Reciept", notes = "Similar to the Save Ticket endpoint but allows the receiptData to be in binary format. This must be a multi-part post", response = ProfileResponse.class, tags={ "Ticket", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = ProfileResponse.class)
    })
    public Response saveTicketViaFileUpload(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the action being performed { COMPLETED, // ADD TICKETS FOR COMPLETING A MISSION, CHALLENGE, GAME, PACK, LEVEL, LEVEL OBJECT REDEEMED, // REMOVE TICKETS FOR BUYING PACKS, HINTS, AND PEN TOOLS OPTIONS, ETC USERS_PLAYED, // ADD TICKETS FOR LEVELS PLAYED BY OTHER USERS TOURNAMENT_OWNER, // ADD TICKETS FOR TOURNAMENTS BY OTHER USERS PURCHASED, // ADD TICKET VIA IN APP PURCHASING SUMATION, // SUMATION OF TICKETS EARNED FROM CHILDREN GIFTED, // TRANSFERING OF PURCHASE ITEMS TO OTHER PEOPLE REFUNDED // FOR REFUNDING TICKETS BACK TO THE USER }", required = true) @QueryParam("actionType") @NotNull  String actionType,@ApiParam(value = "the type of object being purchased {GAME_OBJECT, GAME_LEVEL, PACK, GAME, MISSION, PROFILE, APPLICATION, TICKETS, ASSET, CUSTOM}", required = true) @QueryParam("ticketObjectType") @NotNull  String ticketObjectType,@ApiParam(value = "the receipt/transaction data for validating a purchase via iTunes/Gooogle/etc. This should be in binary format.", required = true) @QueryParam("receiptData") @NotNull  File receiptData,@ApiParam(value = "whether to return nulls or not") @QueryParam("returnNulls")  Boolean returnNulls,@ApiParam(value = "the device id") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "the account id") @QueryParam("accountId")  Long accountId,@ApiParam(value = "This parameter is deprecated. deprecated, use the appKey") @QueryParam("gameType")  String gameType,@ApiParam(value = "the application key") @QueryParam("appKey")  String appKey,@ApiParam(value = "the ID of the item being purchased") @QueryParam("objectId")  Long objectId,@ApiParam(value = "a unique string identifier defined by the application owner or Executive") @QueryParam("purchaseCode")  String purchaseCode,@ApiParam(value = "a unique transaction identifier from the purchase provider (i.e. the transaction ID from iTunes, Google Play, etc)") @QueryParam("receiptToken")  String receiptToken,@ApiParam(value = "the count of tickets") @QueryParam("count")  Long count,@ApiParam(value = "the ticket type") @QueryParam("ticketType")  String ticketType,@ApiParam(value = "the provider for making the purchase {ITUNES, ITUNES_SANDBOX, GOOGLE}") @QueryParam("purchaseProvider")  String purchaseProvider,@ApiParam(value = "a comma separated list of purchase types { SIRQUL, // purchasing from the sirqul store using tickets IOS, // purchasing from the itunes store for iPhone, iPod, iPod Touch GOOGLE, // purchasing from the google android store AMAZON, // purchasing from the amazon android store MAC, // purchasing from the itunes store for OSX WP8, // purhasing from the windows phone 8 store FREE }") @QueryParam("purchaseType")  String purchaseType,@ApiParam(value = "returns a ProfileResponse if true, otherwise will return an AppResponse") @QueryParam("returnProfileResponse")  Boolean returnProfileResponse,@ApiParam(value = "if returnProfileResponse is false, will return an AppResponse with profile data if true") @QueryParam("includeProfileResponse")  Boolean includeProfileResponse,@ApiParam(value = "the application version") @QueryParam("appVersion")  String appVersion,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.saveTicketViaFileUpload(version, actionType, ticketObjectType, receiptData, returnNulls, deviceId, accountId, gameType, appKey, objectId, purchaseCode, receiptToken, count, ticketType, purchaseProvider, purchaseType, returnProfileResponse, includeProfileResponse, appVersion, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/tracking/leg/create")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Create Tracking Leg", notes = "Send tracking points to be able to generate pathing data", response = SirqulResponse.class, tags={ "Tracking", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response saveTrackingLeg(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the latitude of the first point", required = true) @QueryParam("startLat") @NotNull  Double startLat,@ApiParam(value = "the longitude of the first point", required = true) @QueryParam("startLng") @NotNull  Double startLng,@ApiParam(value = "the start date (in UTC milliseconds) of the first point", required = true) @QueryParam("startDate") @NotNull  Long startDate,@ApiParam(value = "the latitude of the last point", required = true) @QueryParam("endLat") @NotNull  Double endLat,@ApiParam(value = "the longitude of the last point", required = true) @QueryParam("endLng") @NotNull  Double endLng,@ApiParam(value = "the end date (in UTC milliseconds) of the last point", required = true) @QueryParam("endDate") @NotNull  Long endDate,@ApiParam(value = "the device id (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "the account id of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "the total distance") @QueryParam("distance")  Double distance,@ApiParam(value = "the total duration") @QueryParam("duration")  Long duration,@ApiParam(value = "JSON array of tracking vectors used for smoother pathing data. If null then the leg data will be used to generate a single step, if an empty array then no steps will be generated. ```json [{   \"distance\": \"0.03\",   \"duration\": \"5000\",   \"startLat\": \"47.614603\",   \"startLng\": \"-122.350518\",   \"startDate\": \"1361924010000\",   \"endLat\": \"47.614941\",   \"endLng\": \"-122.350062\",   \"endDate\": \"1361924015000\" }] ``` ") @QueryParam("steps")  String steps,@ApiParam(value = "name the leg for searching") @QueryParam("tags")  String tags,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.saveTrackingLeg(version, startLat, startLng, startDate, endLat, endLng, endDate, deviceId, accountId, distance, duration, steps, tags, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/tracking/step/create")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Create Tracking Step", notes = "Send tracking points to be able to generate pathing data", response = SirqulResponse.class, tags={ "Tracking", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response saveTrackingStep(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the leg to add the step to", required = true) @QueryParam("legId") @NotNull  Long legId,@ApiParam(value = "the latitude of the first point", required = true) @QueryParam("startLat") @NotNull  Double startLat,@ApiParam(value = "the longitude of the first point", required = true) @QueryParam("startLng") @NotNull  Double startLng,@ApiParam(value = "the start date (in UTC milliseconds) of the first point", required = true) @QueryParam("startDate") @NotNull  Long startDate,@ApiParam(value = "the latitude of the last point", required = true) @QueryParam("endLat") @NotNull  Double endLat,@ApiParam(value = "the longitude of the last point", required = true) @QueryParam("endLng") @NotNull  Double endLng,@ApiParam(value = "the end date (in UTC milliseconds) of the last point", required = true) @QueryParam("endDate") @NotNull  Long endDate,@ApiParam(value = "the device id (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "the account id of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "the total distance") @QueryParam("distance")  Double distance,@ApiParam(value = "the total duration") @QueryParam("duration")  Long duration,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.saveTrackingStep(version, legId, startLat, startLng, startDate, endLat, endLng, endDate, deviceId, accountId, distance, duration, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/notification/schedule/generate")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Generate Schedule Notifications", notes = "Use a report to identify events that are starting soon and then create a scheduled notification to push a message to matching users.", response = SirqulResponse.class, tags={ "Scheduled Notification", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response scheduleNotificationListings(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The logged in user.", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "The application to target", required = true) @QueryParam("appKey") @NotNull  String appKey,@ApiParam(value = "The name of the report used to identify events. The report must return columns named: id, name, date, params, and type otherwise it will fail", required = true) @QueryParam("reportName") @NotNull  String reportName,@ApiParam(value = "The message to be sent to the recipients. If you set %name% the report row name value will be swapped in. If you set %time% or %date% the report row start date/time value will be swapped in", required = true) @QueryParam("message") @NotNull  String message,@ApiParam(value = "Time in munites before the event starts to notify recipients", required = true) @QueryParam("offset") @NotNull  Integer offset,@ApiParam(value = "The report id used to generate the recipient list", required = true) @QueryParam("recipientReportId") @NotNull  Long recipientReportId,@ApiParam(value = "The parameters of the report used to identify events in a json structure, example: ```json {   \"string\": \"value\",   \"number\": 3.345,   \"date\": \"2014-05-01 00:00:00\" } ``` ") @QueryParam("reportParams")  String reportParams,@ApiParam(value = "The type of scheduled notification; supported values are: MOBILE_NOTIFICATION") @QueryParam("type")  String type,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.scheduleNotificationListings(version, accountId, appKey, reportName, message, offset, recipientReportId, reportParams, type, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/trip")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Search Trips", notes = "Search for trips", response = Trip.class, responseContainer = "List", tags={ "Trip", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = Trip.class, responseContainer = "List")
    })
    public Response search(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The owner of the trips", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "The field to sort by", required = true) @QueryParam("sortField") @NotNull  String sortField,@ApiParam(value = "Determines whether the sorted list is in descending or ascending order", required = true) @QueryParam("descending") @NotNull  Boolean descending,@ApiParam(value = "The start index for pagination", required = true) @QueryParam("start") @NotNull  Integer start,@ApiParam(value = "The limit for pagination", required = true) @QueryParam("limit") @NotNull  Integer limit,@ApiParam(value = "Return only active results", required = true) @QueryParam("activeOnly") @NotNull  Boolean activeOnly,@ApiParam(value = "The lower bound limit of time") @QueryParam("startDate")  Long startDate,@ApiParam(value = "The upper bound limit of time") @QueryParam("endDate")  Long endDate,@ApiParam(value = "whether to search on trips that have notifications or not") @QueryParam("hasNotifications")  Boolean hasNotifications,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.search(version, accountId, sortField, descending, start, limit, activeOnly, startDate, endDate, hasNotifications, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/account/profile/search")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Search Accounts", notes = "Search for account profiles.", response = ProfileResponse.class, responseContainer = "List", tags={ "Account", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = ProfileResponse.class, responseContainer = "List")
    })
    public Response searchAccounts(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The id of the account requesting", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "The application key", required = true) @QueryParam("appKey") @NotNull  String appKey,@ApiParam(value = "The keyword for for querying the account") @QueryParam("keyword")  String keyword,@ApiParam(value = "the latitude") @QueryParam("latitude")  Double latitude,@ApiParam(value = "the longitude") @QueryParam("longitude")  Double longitude,@ApiParam(value = "the radius", defaultValue = "5") @DefaultValue("5") @QueryParam("radius")  Double radius,@ApiParam(value = "the user's gender", allowableValues="MALE, FEMALE, ANY") @QueryParam("gender")  String gender,@ApiParam(value = "the user's Game Experience", allowableValues="ANY, NEW, BEGINNER, INTERMEDIATE, EXPERT") @QueryParam("gameExperience")  String gameExperience,@ApiParam(value = "the user's age") @QueryParam("age")  Integer age,@ApiParam(value = "the user's Category Ids") @QueryParam("categoryIds")  String categoryIds,@ApiParam(value = "Return Nulls", defaultValue = "true") @DefaultValue("true") @QueryParam("returnNulls")  Boolean returnNulls,@ApiParam(value = "A comma separated list of ProfileFilters for filtering the returned response data", defaultValue = "PROFILE") @DefaultValue("PROFILE") @QueryParam("responseFilters")  String responseFilters,@ApiParam(value = "A comma separated list of PurchaseType", defaultValue = "SIRQUL") @DefaultValue("SIRQUL") @QueryParam("purchaseType")  String purchaseType,@ApiParam(value = "The field to sort by", defaultValue = "id") @DefaultValue("id") @QueryParam("sortField")  String sortField,@ApiParam(value = "The order to return the results. Default is false, which will return the results in ascending order.", defaultValue = "false") @DefaultValue("false") @QueryParam("descending")  Boolean descending,@ApiParam(value = "The index into the record set to start with.", defaultValue = "0") @DefaultValue("0") @QueryParam("start")  Integer start,@ApiParam(value = "The total number of record to return.", defaultValue = "20") @DefaultValue("20") @QueryParam("limit")  Integer limit,@ApiParam(value = "Determines whether to return only active results. Default is false.", defaultValue = "false") @DefaultValue("false") @QueryParam("activeOnly")  Boolean activeOnly,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.searchAccounts(version, accountId, appKey, keyword, latitude, longitude, radius, gender, gameExperience, age, categoryIds, returnNulls, responseFilters, purchaseType, sortField, descending, start, limit, activeOnly, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/tracking/list")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "List Tracking", notes = "Search for all accounts that have tracking legs data by the given constraints.", response = AccountMiniResponse.class, responseContainer = "List", tags={ "Tracking", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = AccountMiniResponse.class, responseContainer = "List")
    })
    public Response searchAccountsWithTrackingLegs(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The account id of the user", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "Used for LIKE search of first or last name on the acocunt") @QueryParam("keyword")  String keyword,@ApiParam(value = "Range to begin in UTC milliseconds") @QueryParam("startDate")  Long startDate,@ApiParam(value = "Range to end in UTC milliseconds") @QueryParam("endDate")  Long endDate,@ApiParam(value = "Exact match on tag field of Legs's searchTag") @QueryParam("tags")  String tags,@ApiParam(value = "") @QueryParam("audienceIds")  String audienceIds,@ApiParam(value = "Origin latitude to perform searching constraints with given range") @QueryParam("latitude")  Double latitude,@ApiParam(value = "Origin longitude to perform searching constraints with given range") @QueryParam("longitude")  Double longitude,@ApiParam(value = "The radius, in miles, to perform the search for", defaultValue = "5") @DefaultValue("5") @QueryParam("range")  Double range,@ApiParam(value = "The column to sort the search on. Possible values include: {LEG_START_DATE, ACCOUNT_DISPLAY}", defaultValue = "LEG_START_DATE") @DefaultValue("LEG_START_DATE") @QueryParam("sortField")  String sortField,@ApiParam(value = "The order to return the results. Default is false, which will return the results in ascending order.", defaultValue = "true") @DefaultValue("true") @QueryParam("descending")  Boolean descending,@ApiParam(value = "The index into the record set to start with. Default is 0.", defaultValue = "0") @DefaultValue("0") @QueryParam("start")  Integer start,@ApiParam(value = "The total number of records to return. Default is 20.", defaultValue = "20") @DefaultValue("20") @QueryParam("limit")  Integer limit,@ApiParam(value = "Determines whether to return only active results. Default is false.", defaultValue = "false") @DefaultValue("false") @QueryParam("activeOnly")  Boolean activeOnly,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.searchAccountsWithTrackingLegs(version, accountId, keyword, startDate, endDate, tags, audienceIds, latitude, longitude, range, sortField, descending, start, limit, activeOnly, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/achievement/search")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Search Achievements", notes = "Searches achievements by application for consumers.", response = AchievementShortResponse.class, responseContainer = "List", tags={ "Achievement", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = AchievementShortResponse.class, responseContainer = "List")
    })
    public Response searchAchievements(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the application key", required = true) @QueryParam("appKey") @NotNull  String appKey,@ApiParam(value = "the field to sort by. See AchievementApiMap", required = true, allowableValues="CREATED, UPDATED, DELETED, SEARCH_TAGS, ACTIVE, TITLE, DESCRIPTION, RANK_TYPE, APPLICATION_ID, APPLICATION_NAME, BILLABLE_ID", defaultValue = "TITLE") @DefaultValue("TITLE") @QueryParam("sortField") @NotNull  String sortField,@ApiParam(value = "determines whether the sorted list is in descending or ascending order", required = true, defaultValue = "false") @DefaultValue("false") @QueryParam("descending") @NotNull  Boolean descending,@ApiParam(value = "return tiers, only applicable for version >3.18", required = true, defaultValue = "false") @DefaultValue("false") @QueryParam("includeTiers") @NotNull  Boolean includeTiers,@ApiParam(value = "return inactive tiers, only applicable when includeTiers is true, only applicable for version >3.18", required = true, defaultValue = "false") @DefaultValue("false") @QueryParam("includeInactiveTiers") @NotNull  Boolean includeInactiveTiers,@ApiParam(value = "the start index for pagination", required = true, defaultValue = "0") @DefaultValue("0") @QueryParam("start") @NotNull  Integer start,@ApiParam(value = "the limit for pagination (has a hard limit of 1000)", required = true, defaultValue = "100") @DefaultValue("100") @QueryParam("limit") @NotNull  Integer limit,@ApiParam(value = "a unique id given by the device (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "the account id of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "the keyword used to filter results with (this returns results that have the keyword in the title or description of the achievement)") @QueryParam("keyword")  String keyword,@ApiParam(value = "filter results by the achievementType (these are exact case sensitive matches)") @QueryParam("achievementType")  String achievementType,@ApiParam(value = "filter results by the rankType (these are exact case sensitive matches)") @QueryParam("rankType")  String rankType,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.searchAchievements(version, appKey, sortField, descending, includeTiers, includeInactiveTiers, start, limit, deviceId, accountId, keyword, achievementType, rankType, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/album/search")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Search Albums", notes = "Searches on Albums.", response = AlbumFullResponse.class, responseContainer = "List", tags={ "Album", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = AlbumFullResponse.class, responseContainer = "List")
    })
    public Response searchAlbums(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "a comma separated list of filters: * MINE - Return albums that the user has created. * SHARED - Return albums that have been shared to the user via addAlbumUsers, or addUsersToPermissionable . * FOLLOWER - Return albums that have been created by the user's followers (the content needs to have been APPROVED or FEATURED). * FOLLOWING - Return albums that have been created by people who the user is following (the content needs to have been APPROVED or FEATURED). * PUBLIC - Return all PUBLIC albums that have been APPROVED or FEATURED. * ALL_PUBLIC - Return all PUBLIC albums regardless of whether they are approved or not (ignores the approval status). * LIKED - Return all albums that the user has liked. * FEATURED - Return all albums that have been featured. * PENDING - Return all pending albums. ", required = true) @QueryParam("filter") @NotNull  String filter,@ApiParam(value = "id of custom albumType", required = true) @QueryParam("albumTypeId") @NotNull  Long albumTypeId,@ApiParam(value = "filter albums with this album sub type", required = true) @QueryParam("subType") @NotNull  String subType,@ApiParam(value = "determines whether to return inactive albums", required = true) @QueryParam("includeInactive") @NotNull  Boolean includeInactive,@ApiParam(value = "the field to sort by. See AlbumApiMap", required = true) @QueryParam("sortField") @NotNull  String sortField,@ApiParam(value = "determines whether the sorted list is in descending or ascending order", required = true) @QueryParam("descending") @NotNull  Boolean descending,@ApiParam(value = "the start index for pagination", required = true) @QueryParam("start") @NotNull  Integer start,@ApiParam(value = "the limit for pagination (There is a hard limit of 100)", required = true) @QueryParam("limit") @NotNull  Integer limit,@ApiParam(value = "the maximum range the album can be from the center (used when sortField=ALBUM_DISTANCE)", required = true) @QueryParam("range") @NotNull  Double range,@ApiParam(value = "returns whether or not the current logged in user has liked the album", required = true) @QueryParam("includeLiked") @NotNull  Boolean includeLiked,@ApiParam(value = "returns whether or not the current logged in user has favorited the album", required = true) @QueryParam("includeFavorited") @NotNull  Boolean includeFavorited,@ApiParam(value = "returns permission details on whether they have read/write/delete permissions etc (client app probably doesn't need this)", required = true) @QueryParam("includePermissions") @NotNull  Boolean includePermissions,@ApiParam(value = "returns the last X likes", required = true) @QueryParam("likePreviewSize") @NotNull  Integer likePreviewSize,@ApiParam(value = "returns the first X assets", required = true) @QueryParam("assetPreviewSize") @NotNull  Integer assetPreviewSize,@ApiParam(value = "returns the last X notes", required = true) @QueryParam("notePreviewSize") @NotNull  Integer notePreviewSize,@ApiParam(value = "returns the first X users/connections", required = true) @QueryParam("connectionPreviewSize") @NotNull  Integer connectionPreviewSize,@ApiParam(value = "returns the first X audiences. To search on and paginate the remaining audiences, please use the \"/audience/search\" endpoint.", required = true) @QueryParam("audiencePreviewSize") @NotNull  Integer audiencePreviewSize,@ApiParam(value = "a unique ID given by the device (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "the account ID of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "the account ID of the user that the results will be based on. This is used to return albums that this account has liked/favorited.") @QueryParam("connectionAccountId")  Long connectionAccountId,@ApiParam(value = "search on albums that have been created by this account (that the user has permissions to)") @QueryParam("ownerId")  Long ownerId,@ApiParam(value = "search on album within a comma separated list of album IDs (this does not work with sortField=ALBUM_DISTANCE, or when stackSearch=true)") @QueryParam("albumIds")  String albumIds,@ApiParam(value = "Only for CLOUDINDEX mode, exclude albums with ids matching this list") @QueryParam("excludeAlbumIds")  String excludeAlbumIds,@ApiParam(value = "search on albums that are in a particular media offering") @QueryParam("mediaId")  Long mediaId,@ApiParam(value = "keyword search string") @QueryParam("keyword")  String keyword,@ApiParam(value = "filter albums with this album type") @QueryParam("albumType")  String albumType,@ApiParam(value = "When using multiple album types this sets a per-album-type limit (used with cloud index mode)") @QueryParam("limitPerAlbumType")  Integer limitPerAlbumType,@ApiParam(value = "return items that have been created before this date (time-stamp in milliseconds)") @QueryParam("dateCreated")  Long dateCreated,@ApiParam(value = "return items that have been updated since this date (time-stamp in milliseconds)") @QueryParam("updatedSince")  Long updatedSince,@ApiParam(value = "return items that have been updated before this date (time-stamp in milliseconds)") @QueryParam("updatedBefore")  Long updatedBefore,@ApiParam(value = "return items that have been created since this date (time-stamp in milliseconds)") @QueryParam("createdSince")  Long createdSince,@ApiParam(value = "return items that have been created before this date (time-stamp in milliseconds)") @QueryParam("createdBefore")  Long createdBefore,@ApiParam(value = "return items that have been started since this date (time-stamp in milliseconds)") @QueryParam("startedSince")  Long startedSince,@ApiParam(value = "return items that have been started before this date (time-stamp in milliseconds)") @QueryParam("startedBefore")  Long startedBefore,@ApiParam(value = "return items that have been ended since this date (time-stamp in milliseconds)") @QueryParam("endedSince")  Long endedSince,@ApiParam(value = "return items that have been ended before this date (time-stamp in milliseconds)") @QueryParam("endedBefore")  Long endedBefore,@ApiParam(value = "the latitude of where the search is centered on (used when sortField=ALBUM_DISTANCE)") @QueryParam("latitude")  Double latitude,@ApiParam(value = "the longitude of where the search is centered on (used when sortField=ALBUM_DISTANCE)") @QueryParam("longitude")  Double longitude,@ApiParam(value = "the application key to filter results by application. This is required for consumer searches. Leaving this empty will return albums for the applications that the logged in user owns or has access to.") @QueryParam("appKey")  String appKey,@ApiParam(value = "return results with categories matching this list") @QueryParam("categoryIds")  String categoryIds,@ApiParam(value = "return results with filters matching this list") @QueryParam("categoryFilterIds")  String categoryFilterIds,@ApiParam(value = "return results with audiences matching this list") @QueryParam("audienceIds")  String audienceIds,@ApiParam(value = "exclude audiences with ids matching this list") @QueryParam("excludeAudienceIds")  String excludeAudienceIds,@ApiParam(value = "returns the user's completable object for the album if it exists") @QueryParam("includeCompletable")  Boolean includeCompletable,@ApiParam(value = "returns the user's rating for the album if it exists") @QueryParam("includeRating")  Boolean includeRating,@ApiParam(value = "The search index mode to use (RDS, LUCENE, or CLOUDINDEX). If not provided will use server default.") @QueryParam("searchMode")  String searchMode,@ApiParam(value = "groups similar albums together that have the same albumTypeId, within a time window defined in stackWindowSize") @QueryParam("stackSearch")  Boolean stackSearch,@ApiParam(value = "size of each window for each stack") @QueryParam("stackWindowSize")  Integer stackWindowSize,@ApiParam(value = "The minimum number of stacks returned in a response. For example,  first call, minStackPerPage = 20, the API will return at least 20 results") @QueryParam("minStackPerPage")  Integer minStackPerPage,@ApiParam(value = "this is used to tell the system where it left off on the previous previous page, since we can't use start/limit for stackSearch") @QueryParam("stackPaginationIdentifier")  String stackPaginationIdentifier,@ApiParam(value = "set this to true when making the call to view the albums in the stack") @QueryParam("stackDetails")  Boolean stackDetails,@ApiParam(value = "Return any results that have a minimum of the specified flag count (even ones that have met the flag threshold)") @QueryParam("flagCountMinimum")  Long flagCountMinimum,@ApiParam(value = "return items that have flagCount >= flagThreshold (controls removal of flagged content)", defaultValue = "true") @DefaultValue("true") @QueryParam("removeFlaggedContent")  Boolean removeFlaggedContent,@ApiParam(value = "setting to true will return only verified albums only, setting to false will return non-verified albums only (leave empty to return both)") @QueryParam("verifiedFilter")  Boolean verifiedFilter,@ApiParam(value = "filter results by the linkedObjectType") @QueryParam("linkedObjectType")  String linkedObjectType,@ApiParam(value = "filter results by the linkedObjectId") @QueryParam("linkedObjectId")  Long linkedObjectId,@ApiParam(value = "determines whether to use the order assigned via the /album/order/_* api (which is tied to an audience)") @QueryParam("orderAudienceId")  Long orderAudienceId,@ApiParam(value = "if true, ignore the application's default app filter when searching") @QueryParam("ignoreDefaultAppFilter")  Boolean ignoreDefaultAppFilter,@ApiParam(value = "Advanced search expression to be used by the server") @QueryParam("searchExpression")  String searchExpression,@ApiParam(value = "If true and results are empty, attempt to generate albums via templates") @QueryParam("generateAlbums")  Boolean generateAlbums,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.searchAlbums(version, filter, albumTypeId, subType, includeInactive, sortField, descending, start, limit, range, includeLiked, includeFavorited, includePermissions, likePreviewSize, assetPreviewSize, notePreviewSize, connectionPreviewSize, audiencePreviewSize, deviceId, accountId, connectionAccountId, ownerId, albumIds, excludeAlbumIds, mediaId, keyword, albumType, limitPerAlbumType, dateCreated, updatedSince, updatedBefore, createdSince, createdBefore, startedSince, startedBefore, endedSince, endedBefore, latitude, longitude, appKey, categoryIds, categoryFilterIds, audienceIds, excludeAudienceIds, includeCompletable, includeRating, searchMode, stackSearch, stackWindowSize, minStackPerPage, stackPaginationIdentifier, stackDetails, flagCountMinimum, removeFlaggedContent, verifiedFilter, linkedObjectType, linkedObjectId, orderAudienceId, ignoreDefaultAppFilter, searchExpression, generateAlbums, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/appconfig/search")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Search AppConfigs", notes = "Gets all versions of application configurations in a particular app by the given appKey.", response = ApplicationConfigResponse.class, responseContainer = "List", tags={ "Application Config", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = ApplicationConfigResponse.class, responseContainer = "List")
    })
    public Response searchApplicationConfig(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The account ID of the user", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "The application key to filter results by application Leaving this empty will return all application configurations for all applications (executive user only)") @QueryParam("appKey")  String appKey,@ApiParam(value = "Only returns the configs that matches the given retailer") @QueryParam("retailerId")  Long retailerId,@ApiParam(value = "Only returns the configs that matches the given retailer location") @QueryParam("retailerLocationId")  Long retailerLocationId,@ApiParam(value = "Only returns only returns the configs that matches the given device udid") @QueryParam("udid")  String udid,@ApiParam(value = "Config Version") @QueryParam("configVersion")  String configVersion,@ApiParam(value = "Orders the results by: CREATED, UPDATED, ACTIVE, APPLICATION_ID,  APPLICATION_KEY, APPLICATION_NAME, RETAILER_NAME, RETAILER_ID, RETAILER_LOCATION_NAME,  RETAILER_LOCATION_ID, OFFER_TITLE, OFFER_ID, OFFER_LOCATION_ID, CONFIG_VERSION_MINOR,  CONFIG_VERSION_MAJOR, CONFIG_VERSION_INDEX ", defaultValue = "CONFIG_VERSION_INDEX") @DefaultValue("CONFIG_VERSION_INDEX") @QueryParam("sortField")  String sortField,@ApiParam(value = "Determines whether the results are in descending or ascending order", defaultValue = "true") @DefaultValue("true") @QueryParam("descending")  Boolean descending,@ApiParam(value = "The start index for pagination", defaultValue = "0") @DefaultValue("0") @QueryParam("start")  Integer start,@ApiParam(value = "The limit for pagination (There is a hard limit of 100)", defaultValue = "20") @DefaultValue("20") @QueryParam("limit")  Integer limit,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.searchApplicationConfig(version, accountId, appKey, retailerId, retailerLocationId, udid, configVersion, sortField, descending, start, limit, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/application/placement/search")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Search for Ad Placements", notes = "Searches placements for an application.", response = PlacementResponse.class, responseContainer = "List", tags={ "Application", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = PlacementResponse.class, responseContainer = "List")
    })
    public Response searchApplicationPlacement(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The key of the application", required = true) @QueryParam("appKey") @NotNull  String appKey,@ApiParam(value = "The unique id of the device making the request (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "The account id of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "The start of the pagination", defaultValue = "0") @DefaultValue("0") @QueryParam("start")  Integer start,@ApiParam(value = "The limit of the pagination", defaultValue = "100") @DefaultValue("100") @QueryParam("limit")  Integer limit,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.searchApplicationPlacement(version, appKey, deviceId, accountId, start, limit, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/application/settings/search")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Search for Application Settings", notes = "Returns a list of applications that the user has logged into before, and returns specific settings for that application and user", response = ApplicationSettingsResponse.class, tags={ "Application", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = ApplicationSettingsResponse.class)
    })
    public Response searchApplicationSettings(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The device id (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "The account id of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "The account id used to view another person's account") @QueryParam("connectionAccountId")  Long connectionAccountId,@ApiParam(value = "The string to search applications on") @QueryParam("keyword")  String keyword,@ApiParam(value = "The column to sort the search on. Possible values include: CREATED, UPDATED, APPLICATION_TITLE", defaultValue = "APPLICATION_TITLE") @DefaultValue("APPLICATION_TITLE") @QueryParam("sortField")  String sortField,@ApiParam(value = "The order to return the search results", defaultValue = "false") @DefaultValue("false") @QueryParam("descending")  Boolean descending,@ApiParam(value = "The start index for pagination", defaultValue = "0") @DefaultValue("0") @QueryParam("start")  Integer start,@ApiParam(value = "The limit per result set for pagination", defaultValue = "20") @DefaultValue("20") @QueryParam("limit")  Integer limit,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.searchApplicationSettings(version, deviceId, accountId, connectionAccountId, keyword, sortField, descending, start, limit, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/application/search")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Search Applications", notes = "Search for applications matching the criteria that the logged in user has access to", response = ApplicationResponse.class, responseContainer = "List", tags={ "Application", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = ApplicationResponse.class, responseContainer = "List")
    })
    public Response searchApplications(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The unique id of the device making the request (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "The account id of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "The location of the device") @QueryParam("latitude")  Double latitude,@ApiParam(value = "The location of the device") @QueryParam("longitude")  Double longitude,@ApiParam(value = "Q") @QueryParam("q")  String q,@ApiParam(value = "The keyword used to search") @QueryParam("keyword")  String keyword,@ApiParam(value = "The columns to applied the keyword search to", defaultValue = "NAME,ABOUT,BILLABLE_ENTITY_NAME") @DefaultValue("NAME,ABOUT,BILLABLE_ENTITY_NAME") @QueryParam("qSearchFields")  String qSearchFields,@ApiParam(value = "The column to sort the search on", allowableValues="CREATED, UPDATED, DELETED, SEARCH_TAGS, ACTIVE, HAS_ADVERTISEMENTS, PUBLIC_NOTIFICATIONS, PLACEMENTS, BILLABLE_ENTITY_ID, BILLABLE_ENTITY_NAME, RESPONSIBLE_DISPLAY, TITLE, NAME, ABOUT, DESCRIPTION, APPLICATION_ID, APP_TYPE, GAME_TYPE, BUNDLE_ID, SCORING_TYPE, LANDING_PAGE_URL, EULA_VERSION, BUILD_VERSION, API_VERSION", defaultValue = "APPLICATION_ID") @DefaultValue("APPLICATION_ID") @QueryParam("sortField")  String sortField,@ApiParam(value = "The order to return the search results", defaultValue = "false") @DefaultValue("false") @QueryParam("descending")  Boolean descending,@ApiParam(value = "the start of the index") @QueryParam("_i")  Integer i,@ApiParam(value = "The start of the pagination", defaultValue = "0") @DefaultValue("0") @QueryParam("start")  Integer start,@ApiParam(value = "the limit of the index") @QueryParam("_l")  Integer l,@ApiParam(value = "The limit of the pagination", defaultValue = "100") @DefaultValue("100") @QueryParam("limit")  Integer limit,@ApiParam(value = "Filter results on whether the application supports ads or not. Ignore this parameter to return all results.") @QueryParam("hasAds")  Boolean hasAds,@ApiParam(value = "Filter results on whether the application is available for public trigger notifications") @QueryParam("publicNotifications")  Boolean publicNotifications,@ApiParam(value = "Return only active results", defaultValue = "false") @DefaultValue("false") @QueryParam("activeOnly")  Boolean activeOnly,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.searchApplications(version, deviceId, accountId, latitude, longitude, q, keyword, qSearchFields, sortField, descending, i, start, l, limit, hasAds, publicNotifications, activeOnly, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/asset/search")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Search Assets", notes = "Searches for assets", response = AssetResponse.class, responseContainer = "List", tags={ "Asset", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = AssetResponse.class, responseContainer = "List")
    })
    public Response searchAssets(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "a unique ID given by the device (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "the account ID of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "comma separated list of album ids to search on") @QueryParam("albumIds")  String albumIds,@ApiParam(value = "comma separated list of asset ids to search on") @QueryParam("assetIds")  String assetIds,@ApiParam(value = "the application key to filter results by application.") @QueryParam("appKey")  String appKey,@ApiParam(value = "filter results by media type. Possible values include: APPLICATION, IMAGE, AUDIO, VIDEO, MULTIPART, TEXT") @QueryParam("mediaType")  String mediaType,@ApiParam(value = "filter results by mime type") @QueryParam("mimeType")  String mimeType,@ApiParam(value = "keyword search string") @QueryParam("keyword")  String keyword,@ApiParam(value = "filter results by version code") @QueryParam("versionCode")  Integer versionCode,@ApiParam(value = "filter results by version name") @QueryParam("versionName")  String versionName,@ApiParam(value = "return items that have been updated since this date (time-stamp in milliseconds)") @QueryParam("updatedSince")  Long updatedSince,@ApiParam(value = "return items that have been updated before this date (time-stamp in milliseconds)") @QueryParam("updatedBefore")  Long updatedBefore,@ApiParam(value = "the field to sort by. See AssetApiMap") @QueryParam("sortField")  String sortField,@ApiParam(value = "determines whether the sorted list is in descending or ascending order") @QueryParam("descending")  Boolean descending,@ApiParam(value = "determines whether to search on the media library album") @QueryParam("searchMediaLibrary")  Boolean searchMediaLibrary,@ApiParam(value = "filter results by billable entity") @QueryParam("filterByBillable")  Boolean filterByBillable,@ApiParam(value = "if only searching for active assets") @QueryParam("activeOnly")  Boolean activeOnly,@ApiParam(value = "determines whether to include the application response as part of the asset response") @QueryParam("returnApp")  Boolean returnApp,@ApiParam(value = "the start index for pagination") @QueryParam("start")  Integer start,@ApiParam(value = "the limit for pagination (there is a hard limit of 200)") @QueryParam("limit")  Integer limit,@ApiParam(value = "search mode for index (SearchIndexMode)") @QueryParam("searchMode")  String searchMode,@ApiParam(value = "filter by asset type") @QueryParam("assetType")  String assetType,@ApiParam(value = "filter by approval status") @QueryParam("approvalStatus")  String approvalStatus,@ApiParam(value = "filter results by an assigned account id") @QueryParam("assignedAccountId")  Long assignedAccountId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.searchAssets(version, deviceId, accountId, albumIds, assetIds, appKey, mediaType, mimeType, keyword, versionCode, versionName, updatedSince, updatedBefore, sortField, descending, searchMediaLibrary, filterByBillable, activeOnly, returnApp, start, limit, searchMode, assetType, approvalStatus, assignedAccountId, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/reservable/availability/search")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Search Availability", notes = "", response = AvailabilityResponse.class, responseContainer = "List", tags={ "Reservation", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = AvailabilityResponse.class, responseContainer = "List")
    })
    public Response searchAvailability(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the id of the reservation", required = true) @QueryParam("reservableId") @NotNull  Long reservableId,@ApiParam(value = "the reservable type", required = true, allowableValues="LOCATABLE, RESERVABLE, PERMISSIONABLE, NOTABLE, ASSETABLE, LIKABLE, FLAGABLE, FAVORITABLE, RATABLE, ALBUM, COLLECTION, APPLICATION, APPLICATION_SETTING, APPLICATION_CERT, APPLICATION_PLACEMENT, ACCOUNT, ACCOUNT_SETTING, GAME_LEVEL, PACK, MISSION, TOURNAMENT, ASSET, ALBUM_CONTEST, THEME_DESCRIPTOR, OFFER, OFFER_LOCATION, EVENT, RETAILER, RETAILER_LOCATION, NOTE, CREATIVE, FAVORITE, LIKE, RATING, ANALYTIC, THIRD_PARTY_CREDENTIAL, THIRD_PARTY_NETWORK, REGION") @QueryParam("reservableType") @NotNull  String reservableType,@ApiParam(value = "the device ID that the reservation is on") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "the id of the logged in user") @QueryParam("accountId")  Long accountId,@ApiParam(value = "the start date of the reservation") @QueryParam("startDate")  Long startDate,@ApiParam(value = "the end date of the reservation") @QueryParam("endDate")  Long endDate,@ApiParam(value = "the start of the index and/or pagination", defaultValue = "0") @DefaultValue("0") @QueryParam("start")  Integer start,@ApiParam(value = "the limit of the index and/or pagination", defaultValue = "100") @DefaultValue("100") @QueryParam("limit")  Integer limit,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.searchAvailability(version, reservableId, reservableType, deviceId, accountId, startDate, endDate, start, limit, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/report/batch/search")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Search Offline Reports", notes = "Retrieves batches for a user..", response = ReportBatchResponse.class, responseContainer = "List", tags={ "Reporting", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = ReportBatchResponse.class, responseContainer = "List")
    })
    public Response searchBatch(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the id of the account logged in", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "the start of the index and/or pagination", required = true) @QueryParam("start") @NotNull  Integer start,@ApiParam(value = "the limit of the index and/or pagination", required = true) @QueryParam("limit") @NotNull  Integer limit,@ApiParam(value = "the names of the report batch to search on") @QueryParam("names")  String names,@ApiParam(value = "the application key") @QueryParam("appKey")  String appKey,@ApiParam(value = "the report batch status", allowableValues="NEW, ERROR, COMPLETE, PARSE_ERROR, PROCESSING, DUPLICATE, SAVEONLY") @QueryParam("status")  String status,@ApiParam(value = "the global app to search on") @QueryParam("globalAppSearch")  Boolean globalAppSearch,@ApiParam(value = "the start date of the report batch to search on") @QueryParam("startDate")  Long startDate,@ApiParam(value = "the end date of the report batch to search on") @QueryParam("endDate")  Long endDate,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.searchBatch(version, accountId, start, limit, names, appKey, status, globalAppSearch, startDate, endDate, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/notification/blocked/search")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Search on the user's blocked notification settings", notes = "Search on the user's blocked notification settings", response = BlockedNotificationResponse.class, tags={ "Notification", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = BlockedNotificationResponse.class)
    })
    public Response searchBlockedNotifications(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The application key", required = true) @QueryParam("appKey") @NotNull  String appKey,@ApiParam(value = "the account id of the user") @QueryParam("accountId")  Long accountId,@ApiParam(value = "search tags to filter results") @QueryParam("searchTags")  String searchTags,@ApiParam(value = "events to filter by (comma separated)") @QueryParam("events")  String events,@ApiParam(value = "conduits to filter by (comma separated)") @QueryParam("conduits")  String conduits,@ApiParam(value = "custom types to filter by (comma separated)") @QueryParam("customTypes")  String customTypes,@ApiParam(value = "content types to filter by (comma separated)") @QueryParam("contentTypes")  String contentTypes,@ApiParam(value = "content ids to filter by (comma separated)") @QueryParam("contentIds")  String contentIds,@ApiParam(value = "sort field for results") @QueryParam("sortField")  String sortField,@ApiParam(value = "whether to sort descending") @QueryParam("descending")  Boolean descending,@ApiParam(value = "start of the pagination") @QueryParam("start")  Integer start,@ApiParam(value = "limit of the pagination") @QueryParam("limit")  Integer limit,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.searchBlockedNotifications(version, appKey, accountId, searchTags, events, conduits, customTypes, contentTypes, contentIds, sortField, descending, start, limit, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/vatom/b/search")
    
    
    @io.swagger.annotations.ApiOperation(value = "Search for Vatom Businesses", notes = "Searches for Vatom businesses.", response = Void.class, tags={ "Vatom", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = Void.class)
    })
    public Response searchBusinesses(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "Sirqul Account Id", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "Vatom Parameters") @QueryParam("vatomParameters")  String vatomParameters,@ApiParam(value = "Return raw response") @QueryParam("returnRawResponse")  Boolean returnRawResponse,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.searchBusinesses(version, accountId, vatomParameters, returnRawResponse, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/vatom/b/campaign-groups/search")
    
    
    @io.swagger.annotations.ApiOperation(value = "Search Campaign Groups", notes = "Search campaign groups.", response = Void.class, tags={ "Vatom", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = Void.class)
    })
    public Response searchCampaignGroups(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "Sirqul Account Id", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "Sirqul Application Key", required = true) @QueryParam("appKey") @NotNull  String appKey,@ApiParam(value = "Return raw response") @QueryParam("returnRawResponse")  Boolean returnRawResponse,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.searchCampaignGroups(version, accountId, appKey, returnRawResponse, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/cargo/type")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Search Cargo Type", notes = "Search for types of cargo", response = CargoType.class, responseContainer = "List", tags={ "Cargo Type", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = CargoType.class, responseContainer = "List")
    })
    public Response searchCargoTypes(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the sort field to use for the cargo type", required = true) @QueryParam("sortField") @NotNull  String sortField,@ApiParam(value = "if the cargo type should be should be in descending order", required = true) @QueryParam("descending") @NotNull  Boolean descending,@ApiParam(value = "the start of the search", required = true) @QueryParam("start") @NotNull  Integer start,@ApiParam(value = "the limit of the search", required = true) @QueryParam("limit") @NotNull  Integer limit,@ApiParam(value = "if search should be on active only", required = true) @QueryParam("activeOnly") @NotNull  Boolean activeOnly,@ApiParam(value = "the id of the retailer location") @QueryParam("retailerId")  Long retailerId,@ApiParam(value = "the ID of the hub") @QueryParam("hubId")  Long hubId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.searchCargoTypes(version, sortField, descending, start, limit, activeOnly, retailerId, hubId, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/carrier/search")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Search Carriers", notes = "Search on supported mobile telephone carriers that can be used to send SMS notifications via email.", response = CellCarrierResponse.class, responseContainer = "List", tags={ "Carrier", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = CellCarrierResponse.class, responseContainer = "List")
    })
    public Response searchCarriers(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The keyword to search on") @QueryParam("keyword")  String keyword,@ApiParam(value = "Determines whether the sorted list is in descending or ascending order", defaultValue = "false") @DefaultValue("false") @QueryParam("descending")  Boolean descending,@ApiParam(value = "The start index for pagination", defaultValue = "0") @DefaultValue("0") @QueryParam("start")  Integer start,@ApiParam(value = "The limit for pagination", defaultValue = "20") @DefaultValue("20") @QueryParam("limit")  Integer limit,@ApiParam(value = "Determines whether to return inactive results", defaultValue = "true") @DefaultValue("true") @QueryParam("activeOnly")  Boolean activeOnly,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.searchCarriers(version, keyword, descending, start, limit, activeOnly, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/category/search")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Search Categories", notes = "Search for categories.", response = CategoryResponse.class, responseContainer = "List", tags={ "Category", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = CategoryResponse.class, responseContainer = "List")
    })
    public Response searchCategories(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The account id of the user") @QueryParam("accountId")  Long accountId,@ApiParam(value = "The string to search on") @QueryParam("keyword")  String keyword,@ApiParam(value = "the appKey of the application to retrieve categories for, if not specified then search on the global application.") @QueryParam("appKey")  String appKey,@ApiParam(value = "@Deprecated, use parentCategoryIds instead") @QueryParam("categoryId")  String categoryId,@ApiParam(value = "Restrict the search by specific categories") @QueryParam("categoryIds")  String categoryIds,@ApiParam(value = "Restrict the search by specific parent categories so that only its sub children are searched.") @QueryParam("parentCategoryIds")  String parentCategoryIds,@ApiParam(value = "Restrict the search to only those categories with no parent category assigned.") @QueryParam("rootOnly")  Boolean rootOnly,@ApiParam(value = "The column to sort the search on. Possible values include: ID, CREATED, UPDATED, ACTIVE, NAME, DISPLAY", allowableValues="ID, CREATED, UPDATED, DELETED, SEARCH_TAGS, ACTIVE, NAME, DISPLAY", defaultValue = "DISPLAY") @DefaultValue("DISPLAY") @QueryParam("sortField")  String sortField,@ApiParam(value = "The group of categories to return: ALL, GLOBAL or MINE. ALL returns both global and application specific matches, GLOBAL only returns global matches, and MINE only returns the application specific matches. If not provided search on the application provided.", allowableValues="ALL, GLOBAL, MINE") @QueryParam("responseGroup")  String responseGroup,@ApiParam(value = "The order to return the search results", defaultValue = "false") @DefaultValue("false") @QueryParam("descending")  Boolean descending,@ApiParam(value = "The record to begin the return set on", defaultValue = "0") @DefaultValue("0") @QueryParam("start")  Integer start,@ApiParam(value = "The number of records to return", defaultValue = "20") @DefaultValue("20") @QueryParam("limit")  Integer limit,@ApiParam(value = "Determines whether to return only active categories", defaultValue = "true") @DefaultValue("true") @QueryParam("activeOnly")  Boolean activeOnly,@ApiParam(value = "Determines whether to return extra info about the category's \"Participant\" reference", defaultValue = "true") @DefaultValue("true") @QueryParam("returnExternal")  Boolean returnExternal,@ApiParam(value = "If true search categories using the exact keyword, if false then do a partial match (like) search. Default is false.", defaultValue = "false") @DefaultValue("false") @QueryParam("exactMatch")  Boolean exactMatch,@ApiParam(value = "Filters results by the Category's type") @QueryParam("type")  String type,@ApiParam(value = "Filters results by externalType") @QueryParam("externalType")  String externalType,@ApiParam(value = "Determines whether the \"externalType\" param is excluded from the search results") @QueryParam("excludeExternalType")  Boolean excludeExternalType,@ApiParam(value = "Filters results to only return Categories that have been referenced by a minimum number of Offers") @QueryParam("minOfferCount")  Integer minOfferCount,@ApiParam(value = "When searching by a specific parent category (to return sub children), this determines the number of child layers to search in. The minimum is 1, the maximum is 4.", defaultValue = "4") @DefaultValue("4") @QueryParam("searchDepth")  Integer searchDepth,@ApiParam(value = "The search index mode to use (e.g. OPENSEARCH or RDS)") @QueryParam("searchMode")  String searchMode,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.searchCategories(version, accountId, keyword, appKey, categoryId, categoryIds, parentCategoryIds, rootOnly, sortField, responseGroup, descending, start, limit, activeOnly, returnExternal, exactMatch, type, externalType, excludeExternalType, minOfferCount, searchDepth, searchMode, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/connection/search")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Search Possible Connections", notes = "Search for accounts that the user may not have a connection with.", response = ConnectionListResponse.class, tags={ "Connection", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = ConnectionListResponse.class)
    })
    public Response searchConnections(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "return all json attributes if true. defualt is true.", required = true) @QueryParam("returnNulls") @NotNull  Boolean returnNulls,@ApiParam(value = "start index of the pagination", required = true) @QueryParam("start") @NotNull  Integer start,@ApiParam(value = "limit of the pagination", required = true) @QueryParam("limit") @NotNull  Integer limit,@ApiParam(value = "the device id (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "the account id (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "This parameter is deprecated.") @QueryParam("q")  String q,@ApiParam(value = "keyword to search on, optional and this parameter is ignored if empt") @QueryParam("keyword")  String keyword,@ApiParam(value = "the current latitude of the user") @QueryParam("latitude")  Double latitude,@ApiParam(value = "the current longitude of the user") @QueryParam("longitude")  Double longitude,@ApiParam(value = "This parameter is deprecated.") @QueryParam("gameType")  String gameType,@ApiParam(value = "the public application key, if provided only looks for users of that application") @QueryParam("appKey")  String appKey,@ApiParam(value = "This parameter is deprecated.") @QueryParam("_i")  Integer i,@ApiParam(value = "This parameter is deprecated.") @QueryParam("_l")  Integer l,@ApiParam(value = "the field to sort on") @QueryParam("sortField")  String sortField,@ApiParam(value = "whether the search has location or not") @QueryParam("hasLocation")  Boolean hasLocation,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.searchConnections(version, returnNulls, start, limit, deviceId, accountId, q, keyword, latitude, longitude, gameType, appKey, i, l, sortField, hasLocation, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/thirdparty/credential/search")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Search Credentials", notes = "Search on a user's linked third party networks.", response = ThirdPartyCredentialResponse.class, responseContainer = "List", tags={ "ThirdParty Credentials", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = ThirdPartyCredentialResponse.class, responseContainer = "List")
    })
    public Response searchCredentials(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The account id of the user", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "The keyword used to search on the third party name and network string") @QueryParam("keyword")  String keyword,@ApiParam(value = "The network UID to filter results with") @QueryParam("networkUID")  String networkUID,@ApiParam(value = "The order to return the search results") @QueryParam("descending")  Boolean descending,@ApiParam(value = "The start of the pagination", defaultValue = "0") @DefaultValue("0") @QueryParam("start")  Integer start,@ApiParam(value = "The limit of the pagination", defaultValue = "20") @DefaultValue("20") @QueryParam("limit")  Integer limit,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.searchCredentials(version, accountId, keyword, networkUID, descending, start, limit, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/object/data/{objectName}")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Search Data", notes = "Search for records given the specified criteria.  The criteria is a defined set of json values used to build a query", response = ObjectStoreResponse.class, tags={ "Object Store", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = ObjectStoreResponse.class)
    })
    public Response searchData(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The name of the object to search upon", required = true) @PathParam("objectName") @NotNull  String objectName,@ApiParam(value = "If true just return the record count of the search. False (default) will return the actual records", required = true) @QueryParam("count") @NotNull  Boolean count,@ApiParam(value = "The start of the pagination", required = true) @QueryParam("start") @NotNull  Long start,@ApiParam(value = "The limit of the pagination", required = true) @QueryParam("limit") @NotNull  Long limit,@ApiParam(value = "The account id of the logged in user") @QueryParam("accountId")  Long accountId,@ApiParam(value = "The search criteria") @QueryParam("criteria")  String criteria,@ApiParam(value = "The order of results; comma seperated list of field names. Illegal field names will be ignored. Direction by defualt is ascending. Prepend a minus to the field name to make that field descending.") @QueryParam("order")  String order,@ApiParam(value = "") @QueryParam("include")  String include,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.searchData(version, objectName, count, start, limit, accountId, criteria, order, include, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/disbursement/search")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Search Disbursements", notes = "Search Disbursements", response = DisbursementResponse.class, responseContainer = "List", tags={ "Disbursement", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = DisbursementResponse.class, responseContainer = "List")
    })
    public Response searchDisbursements(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the id of the logged in user", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "filter results by the id of the account receiving the disbursement") @QueryParam("receiverAccountId")  Long receiverAccountId,@ApiParam(value = "comma separated list of status values to search for, possilbe values include: NEW, APPROVED, VALIDATING, ERROR, AUTHORIZED, CAPTURED, SETTLED") @QueryParam("statuses")  String statuses,@ApiParam(value = "comma separated list of payment providers to search for, possbile values include: AUTHORIZE_NET, AMAZON_FPS, BILL_COM") @QueryParam("providers")  String providers,@ApiParam(value = "the date for searching disbursements before it has been processed") @QueryParam("beforeDate")  Long beforeDate,@ApiParam(value = "the date for searching disbursements before it has been processed") @QueryParam("afterDate")  Long afterDate,@ApiParam(value = "the start index for pagination", defaultValue = "0") @DefaultValue("0") @QueryParam("start")  Integer start,@ApiParam(value = "the limit per result set for pagination", defaultValue = "20") @DefaultValue("20") @QueryParam("limit")  Integer limit,@ApiParam(value = "search on disbursements that are active only", defaultValue = "false") @DefaultValue("false") @QueryParam("activeOnly")  Boolean activeOnly,@ApiParam(value = "search results by this external ID (that can be used to reference the disbursement)") @QueryParam("externalId")  String externalId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.searchDisbursements(version, accountId, receiverAccountId, statuses, providers, beforeDate, afterDate, start, limit, activeOnly, externalId, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/employee/search")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Search Employees", notes = "Use the accountId to determine the associated BillableEntity. From there get a list of all accounts associated as managers/employees.", response = EmployeeResponse.class, responseContainer = "List", tags={ "Employee", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = EmployeeResponse.class, responseContainer = "List")
    })
    public Response searchEmployees(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The account id of the logged in user", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "The role to limit the search to: RETAILER or RETAILER_LIMITED. Leave empty to search on both roles.") @QueryParam("role")  String role,@ApiParam(value = "Filters employees by retailer") @QueryParam("retailerId")  Long retailerId,@ApiParam(value = "Filter employees by retailer locations") @QueryParam("retailerLocationId")  Long retailerLocationId,@ApiParam(value = "Deprecated parameter") @QueryParam("q")  String q,@ApiParam(value = "an optional keyword to search on; ignored if empty") @QueryParam("keyword")  String keyword,@ApiParam(value = "The field to sort by. Possible values include: DISPLAY, CREATED, UPDATED, ACTIVE, DELETED, LAST_LOGGED_IN, CONTACT_EMAIL, RETAILER_LOCATION_NAME, RETAILER_NAME", allowableValues="ID, DISPLAY, CREATED, UPDATED, ACTIVE, DELETED, LAST_LOGGED_IN, CONTACT_EMAIL, ACCOUNT_TYPE, RETAILER_LOCATION_NAME, RETAILER_NAME") @QueryParam("sortField")  String sortField,@ApiParam(value = "Determines whether the sorted list is in descending or ascending order", defaultValue = "false") @DefaultValue("false") @QueryParam("descending")  Boolean descending,@ApiParam(value = "Deprecated parameter") @QueryParam("_i")  Integer i,@ApiParam(value = "Start the result set at some index", defaultValue = "0") @DefaultValue("0") @QueryParam("start")  Integer start,@ApiParam(value = "Deprecated parameter") @QueryParam("_l")  Integer l,@ApiParam(value = "Limit the result to some number", defaultValue = "20") @DefaultValue("20") @QueryParam("limit")  Integer limit,@ApiParam(value = "Filter results to only return active employees", defaultValue = "true") @DefaultValue("true") @QueryParam("activeOnly")  Boolean activeOnly,@ApiParam(value = "Filter results to only employees that you manage") @QueryParam("managedOnly")  Boolean managedOnly,@ApiParam(value = "Determines whether to return the application settings for the employee for a particular application") @QueryParam("settingsAppKey")  String settingsAppKey,@ApiParam(value = "Comma separated list of category ids to filter results") @QueryParam("categoryIds")  String categoryIds,@ApiParam(value = "Legacy/reporting query parameter used for formatting employee responses") @QueryParam("query")  String query,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.searchEmployees(version, accountId, role, retailerId, retailerLocationId, q, keyword, sortField, descending, i, start, l, limit, activeOnly, managedOnly, settingsAppKey, categoryIds, query, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/event/attendance/search")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Search Event Attendance", notes = "Searches on event type transactions. This can be used to see who is attending an event.", response = EventAttendanceResponse.class, responseContainer = "List", tags={ "Event", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = EventAttendanceResponse.class, responseContainer = "List")
    })
    public Response searchEventTransactions(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The device id (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "The account id of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "The application key") @QueryParam("appKey")  String appKey,@ApiParam(value = "The keyword to search for") @QueryParam("keyword")  String keyword,@ApiParam(value = "Filter results for this retailer") @QueryParam("retailerId")  Long retailerId,@ApiParam(value = "Filter results for this retailer location") @QueryParam("retailerLocationId")  Long retailerLocationId,@ApiParam(value = "Exclude results from this retailer location") @QueryParam("excludeRetailerLocationId")  Long excludeRetailerLocationId,@ApiParam(value = "Filter results for this event listing") @QueryParam("listingId")  Long listingId,@ApiParam(value = "Filter results for this offer") @QueryParam("offerId")  Long offerId,@ApiParam(value = "Filter results for this offer location") @QueryParam("offerLocationId")  Long offerLocationId,@ApiParam(value = "Filter results by accounts") @QueryParam("customerAccountIds")  String customerAccountIds,@ApiParam(value = "Comma separated list of category ids to determine whether the attendee is affiliated with the category") @QueryParam("affiliatedCategoryIds")  String affiliatedCategoryIds,@ApiParam(value = "Filter on attendance starting on or after this date (milliseconds since epoch)") @QueryParam("startDate")  Long startDate,@ApiParam(value = "Filter on attendance starting on or before this date (milliseconds since epoch)") @QueryParam("endDate")  Long endDate,@ApiParam(value = "Comma separated list of transaction statuses to filter on") @QueryParam("statuses")  String statuses,@ApiParam(value = "Determines what to sort the results by {CREATED, UPDATED, SEARCH_TAGS, ACTIVE, ACTIVATED, EXPIRES, TITLE, SUBTITLE, OFFER_TYPE, SPECIAL_OFFER_TYPE, OFFER_VISIBILITY, CUSTOMER_ID, CUSTOMER_DISPLAY, RETAILER_ID, RETAILER_NAME, RETAILER_LOCATION_ID, RETAILER_LOCATION_NAME, BILLABLE_ENTITY_ID, BILLABLE_ENTITY_NAME, RESPONSIBLE_DISPLAY}", allowableValues="ID, CREATED, UPDATED, DELETED, SEARCH_TAGS, ACTIVE, ACTIVATED, EXPIRES, TITLE, SUBTITLE, DETAILS, OFFER_TYPE, SPECIAL_OFFER_TYPE, OFFER_VISIBILITY, REDEEMABLE_START, REDEEMABLE_END, CUSTOMER_ID, CUSTOMER_DISPLAY, RETAILER_ID, RETAILER_NAME, RETAILER_LOCATION_ID, RETAILER_LOCATION_NAME, BILLABLE_ENTITY_ID, BILLABLE_ENTITY_NAME, RESPONSIBLE_DISPLAY") @QueryParam("sortField")  String sortField,@ApiParam(value = "Determines whether the results are in descending order") @QueryParam("descending")  Boolean descending,@ApiParam(value = "The start index for pagination") @QueryParam("start")  Integer start,@ApiParam(value = "The limit for pagination") @QueryParam("limit")  Integer limit,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.searchEventTransactions(version, deviceId, accountId, appKey, keyword, retailerId, retailerLocationId, excludeRetailerLocationId, listingId, offerId, offerLocationId, customerAccountIds, affiliatedCategoryIds, startDate, endDate, statuses, sortField, descending, start, limit, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/event/search")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Search Events", notes = "Searches on events that the account has access to.", response = OfferShortResponse.class, responseContainer = "List", tags={ "Event", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = OfferShortResponse.class, responseContainer = "List")
    })
    public Response searchEvents(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The logged in user.", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "The keyword used to search") @QueryParam("keyword")  String keyword,@ApiParam(value = "Return only active results") @QueryParam("activeOnly")  Boolean activeOnly,@ApiParam(value = "the IDs of the categories that this event is associated with") @QueryParam("categoryIds")  String categoryIds,@ApiParam(value = "the IDs of the filters that this event is associated with") @QueryParam("filterIds")  String filterIds,@ApiParam(value = "Offer audience ids to filter on") @QueryParam("offerAudienceIds")  String offerAudienceIds,@ApiParam(value = "Transaction audience ids to filter on") @QueryParam("transactionAudienceIds")  String transactionAudienceIds,@ApiParam(value = "The column to sort the search on. Possible values include: ID, CREATED, UPDATED, ACTIVE, ACTIVATED, EXPIRES, TITLE, SUBTITLE, DETAILS, OFFER_TYPE, SPECIAL_OFFER_TYPE, OFFER_VISIBILITY, ESTIMATED_VALUE, VOUCHER_PRICE, RETAILER_ID, RETAILER_NAME, RETAILER_LOCATION_ID, RETAILER_LOCATION_NAME, BILLABLE_ENTITY_ID, BILLABLE_ENTITY_NAME, RESPONSIBLE_DISPLAY", allowableValues="ID, CREATED, UPDATED, DELETED, SEARCH_TAGS, ACTIVE, ACTIVATED, EXPIRES, REDEEMABLE_START, REDEEMABLE_END, TITLE, SUBTITLE, DETAILS, OFFER_TYPE, SPECIAL_OFFER_TYPE, OFFER_VISIBILITY, ESTIMATED_VALUE, VOUCHER_PRICE, VOUCHER_DISCOUNT_PRICE, FULL_PRICE, DICOUNT_PRICE, TICKETS_REWARD, AVAILABILITY_DATE, RELEASE_DATE, RETAILER_ID, RETAILER_NAME, RETAILER_LOCATION_ID, RETAILER_LOCATION_NAME, BILLABLE_ENTITY_ID, BILLABLE_ENTITY_NAME, RESPONSIBLE_DISPLAY") @QueryParam("sortField")  String sortField,@ApiParam(value = "The order to return the search results") @QueryParam("descending")  Boolean descending,@ApiParam(value = "Filter the events to return only those that start on or after the date") @QueryParam("startDate")  Long startDate,@ApiParam(value = "Filter the events to return only those that start on or before the date") @QueryParam("endDate")  Long endDate,@ApiParam(value = "The record to begin the return set on") @QueryParam("start")  Integer start,@ApiParam(value = "The number of records to return") @QueryParam("limit")  Integer limit,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.searchEvents(version, accountId, keyword, activeOnly, categoryIds, filterIds, offerAudienceIds, transactionAudienceIds, sortField, descending, startDate, endDate, start, limit, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/favorite/search")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Search Favorites", notes = "Searches on the user's favorites.", response = SearchResponse.class, tags={ "Favorite", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SearchResponse.class)
    })
    public Response searchFavorites(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The type of the object to favorite {OFFER, OFFER_LOCATION, RETAILER_LOCATION, CATEGORY}", required = true) @QueryParam("favoritableType") @NotNull  String favoritableType,@ApiParam(value = "Determines what to sort the results by {CREATED, UPDATED, DISPLAY}", required = true, allowableValues="ID, CREATED, UPDATED, DELETED, SEARCH_TAGS, ACTIVE, DISPLAY") @QueryParam("sortField") @NotNull  String sortField,@ApiParam(value = "Determines whether the results are in descending order", required = true) @QueryParam("descending") @NotNull  Boolean descending,@ApiParam(value = "The start index for pagination", required = true) @QueryParam("start") @NotNull  Integer start,@ApiParam(value = "The limit for pagination (there is a hard limit of 1000)", required = true) @QueryParam("limit") @NotNull  Integer limit,@ApiParam(value = "Determines whether to only return active favorites", required = true) @QueryParam("activeOnly") @NotNull  Boolean activeOnly,@ApiParam(value = "Determines whether to return a detailed version of the response list", required = true) @QueryParam("returnFullResponse") @NotNull  Boolean returnFullResponse,@ApiParam(value = "The unique ID given by the device (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "The account ID of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "The ID of an account the user would like to view favorites for") @QueryParam("connectionAccountId")  Long connectionAccountId,@ApiParam(value = "") @QueryParam("secondaryType")  String secondaryType,@ApiParam(value = "The keyword to search for") @QueryParam("keyword")  String keyword,@ApiParam(value = "The current latitude of the user") @QueryParam("latitude")  Double latitude,@ApiParam(value = "The current longitude of the user") @QueryParam("longitude")  Double longitude,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.searchFavorites(version, favoritableType, sortField, descending, start, limit, activeOnly, returnFullResponse, deviceId, accountId, connectionAccountId, secondaryType, keyword, latitude, longitude, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/filter/search")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Search Filters", notes = "Search for filters.", response = FilterResponse.class, responseContainer = "List", tags={ "Filter", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = FilterResponse.class, responseContainer = "List")
    })
    public Response searchFilters(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The account id of the user") @QueryParam("accountId")  Long accountId,@ApiParam(value = "The string to search on") @QueryParam("keyword")  String keyword,@ApiParam(value = "the appKey of the application to retrieve filters for") @QueryParam("appKey")  String appKey,@ApiParam(value = "The group of filters to return: ALL, GLOBAL or MINE. ALL returns both global and application specific matches, GLOBAL only returns global matches, and MINE only returns the application specific matches. If not provided search on the application provided.", allowableValues="ALL, GLOBAL, MINE") @QueryParam("responseGroup")  String responseGroup,@ApiParam(value = "Restrict the search to only those filters with no parent filter assigned.") @QueryParam("rootOnly")  Boolean rootOnly,@ApiParam(value = "The column to sort the search on. Possible values include: ID, CREATED, UPDATED, ACTIVE, NAME, DISPLAY", allowableValues="ID, CREATED, UPDATED, DELETED, SEARCH_TAGS, ACTIVE, NAME, DISPLAY", defaultValue = "DISPLAY") @DefaultValue("DISPLAY") @QueryParam("sortField")  String sortField,@ApiParam(value = "The order to return the search results", defaultValue = "false") @DefaultValue("false") @QueryParam("descending")  Boolean descending,@ApiParam(value = "The record to begin the return set on", defaultValue = "0") @DefaultValue("0") @QueryParam("start")  Integer start,@ApiParam(value = "The number of records to return", defaultValue = "20") @DefaultValue("20") @QueryParam("limit")  Integer limit,@ApiParam(value = "Determines whether to return only active categories", defaultValue = "true") @DefaultValue("true") @QueryParam("activeOnly")  Boolean activeOnly,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.searchFilters(version, accountId, keyword, appKey, responseGroup, rootOnly, sortField, descending, start, limit, activeOnly, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/game/search")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Search a Game", notes = "Get a list of games for an application, just those the account has permissions to view.", response = GameResponse.class, tags={ "Game", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = GameResponse.class)
    })
    public Response searchGames(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The logged in user.", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "the application key", required = true) @QueryParam("appKey") @NotNull  String appKey,@ApiParam(value = "Start the result set at some index.", required = true) @QueryParam("start") @NotNull  Integer start,@ApiParam(value = "Limit the result to some number.", required = true) @QueryParam("limit") @NotNull  Integer limit,@ApiParam(value = "Match the keyword to the owner name or level name.") @QueryParam("keyword")  String keyword,@ApiParam(value = "The maximum version of the level to return.") @QueryParam("appVersion")  String appVersion,@ApiParam(value = "more details in response") @QueryParam("includeGameData")  Boolean includeGameData,@ApiParam(value = "more details in response") @QueryParam("includeInactive")  Boolean includeInactive,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.searchGames(version, accountId, appKey, start, limit, keyword, appVersion, includeGameData, includeInactive, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/vatom/me/identities/search")
    
    
    @io.swagger.annotations.ApiOperation(value = "Search User Identities", notes = "Search User Identities.", response = Void.class, tags={ "Vatom", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = Void.class)
    })
    public Response searchIdentities(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "Sirqul Account Id", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "Return raw response") @QueryParam("returnRawResponse")  Boolean returnRawResponse,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.searchIdentities(version, accountId, returnRawResponse, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/vatom/user-inventory/search")
    
    
    @io.swagger.annotations.ApiOperation(value = "Search Vatom User's Inventory", notes = "Searches the logged in user's Vatom Inventory.", response = Void.class, tags={ "Vatom", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = Void.class)
    })
    public Response searchInventory(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "Sirqul Account Id", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "Vatom Parameters") @QueryParam("vatomParameters")  String vatomParameters,@ApiParam(value = "Return raw response") @QueryParam("returnRawResponse")  Boolean returnRawResponse,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.searchInventory(version, accountId, vatomParameters, returnRawResponse, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/leaderboard/search")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Search leaderboard and retrieve the matching ranking list", notes = "Search leaderboard and retrieve the matching ranking list", response = LeaderboardResponse.class, tags={ "Leaderboard", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = LeaderboardResponse.class)
    })
    public Response searchLeaderboards(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The account id of the user requesting the search.") @QueryParam("accountId")  Long accountId,@ApiParam(value = "The application key.") @QueryParam("appKey")  String appKey,@ApiParam(value = "only include global leaderboards (this overrides the appKey filter)") @QueryParam("globalOnly")  Boolean globalOnly,@ApiParam(value = "keyword to search by title") @QueryParam("keyword")  String keyword,@ApiParam(value = "comma separated list of leaderboard ids to filter results with") @QueryParam("leaderboardIds")  String leaderboardIds,@ApiParam(value = "comma separated list of rankType to filter results with") @QueryParam("rankTypes")  String rankTypes,@ApiParam(value = "sortField of the result, from LeaderboardApiMap (TITLE, DESCRIPTION, CREATED, UPDATED, RANK_TYPE, RANK_MODE)") @QueryParam("sortField")  String sortField,@ApiParam(value = "Determines whether the sorted list is in descending or ascending order") @QueryParam("descending")  Boolean descending,@ApiParam(value = "include inactive in the result") @QueryParam("includeInactive")  Boolean includeInactive,@ApiParam(value = "determines whether to include the application response for each leaderboard") @QueryParam("includeAppResponse")  Boolean includeAppResponse,@ApiParam(value = "Start the result set at some index.") @QueryParam("start")  Integer start,@ApiParam(value = "Limit the result to some number.") @QueryParam("limit")  Integer limit,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.searchLeaderboards(version, accountId, appKey, globalOnly, keyword, leaderboardIds, rankTypes, sortField, descending, includeInactive, includeAppResponse, start, limit, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/like/search")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Search Likes", notes = "Search for likes on a likable object.", response = SearchResponse.class, tags={ "Like", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SearchResponse.class)
    })
    public Response searchLikes(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The type of the likable object {ALBUM, ALBUM_CONTEST, ASSET, GAME_LEVEL, NOTE, THEME_DESCRIPTOR}", required = true) @QueryParam("likableType") @NotNull  String likableType,@ApiParam(value = "The id of the likable object", required = true) @QueryParam("likableId") @NotNull  Long likableId,@ApiParam(value = "The unique device identifier that made the request (either deviceId or accountId must be used)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "The unique accountId that made the request (either deviceId or accountId must be used)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "Comma separated list of account IDs for filtering on users") @QueryParam("connectionAccountIds")  String connectionAccountIds,@ApiParam(value = "The field to sort by. Possible values include: ID", defaultValue = "ID") @DefaultValue("ID") @QueryParam("sortField")  String sortField,@ApiParam(value = "Determines whether the sorted list is in descending or ascending order", defaultValue = "true") @DefaultValue("true") @QueryParam("descending")  Boolean descending,@ApiParam(value = "return items that have been updated since this date (time-stamp in milliseconds)") @QueryParam("updatedSince")  Long updatedSince,@ApiParam(value = "return items that have been updated before this date (time-stamp in milliseconds)") @QueryParam("updatedBefore")  Long updatedBefore,@ApiParam(value = "the start index for pagination", defaultValue = "0") @DefaultValue("0") @QueryParam("start")  Integer start,@ApiParam(value = "the limit for pagination", defaultValue = "20") @DefaultValue("20") @QueryParam("limit")  Integer limit,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.searchLikes(version, likableType, likableId, deviceId, accountId, connectionAccountIds, sortField, descending, updatedSince, updatedBefore, start, limit, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/listing/search")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Search Listings", notes = "Search for event listings from the start time to end time", response = ListingResponse.class, responseContainer = "List", tags={ "Listing", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = ListingResponse.class, responseContainer = "List")
    })
    public Response searchListing(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the account id of the user") @QueryParam("accountId")  Long accountId,@ApiParam(value = "search the event name and description for this keyword") @QueryParam("keyword")  String keyword,@ApiParam(value = "the record to begin the return set on", defaultValue = "0") @DefaultValue("0") @QueryParam("start")  Integer start,@ApiParam(value = "the number of records to return", defaultValue = "20") @DefaultValue("20") @QueryParam("limit")  Integer limit,@ApiParam(value = "whether to search on active listings only", defaultValue = "false") @DefaultValue("false") @QueryParam("activeOnly")  Boolean activeOnly,@ApiParam(value = "the current latitude of the user") @QueryParam("latitude")  Double latitude,@ApiParam(value = "the current longitude of the user") @QueryParam("longitude")  Double longitude,@ApiParam(value = "the start date to search from") @QueryParam("startDate")  Long startDate,@ApiParam(value = "the end date to search to") @QueryParam("endDate")  Long endDate,@ApiParam(value = "only return items of these categories") @QueryParam("categoryIds")  String categoryIds,@ApiParam(value = "") @QueryParam("filterIds")  String filterIds,@ApiParam(value = "determines whether to use configured listing order ids", defaultValue = "true") @DefaultValue("true") @QueryParam("useListingOrderIds")  Boolean useListingOrderIds,@ApiParam(value = "external identifier used by a third party") @QueryParam("externalId")  String externalId,@ApiParam(value = "secondary external identifier used by a third party") @QueryParam("externalId2")  String externalId2,@ApiParam(value = "external group identifier used by a third party") @QueryParam("externalGroupId")  String externalGroupId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.searchListing(version, accountId, keyword, start, limit, activeOnly, latitude, longitude, startDate, endDate, categoryIds, filterIds, useListingOrderIds, externalId, externalId2, externalGroupId, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/location/rating/index/search")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Search Location Rating Indexes", notes = "Search for retailer locations by averages near you.", response = RatingIndexResponse.class, responseContainer = "List", tags={ "Rating", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = RatingIndexResponse.class, responseContainer = "List")
    })
    public Response searchLocationRatingIndexes(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "Comma separated list of category ids to filter the results by") @QueryParam("categoryIds")  String categoryIds,@ApiParam(value = "The keyword used to search") @QueryParam("keyword")  String keyword,@ApiParam(value = "The type of location to filter the results by") @QueryParam("locationType")  String locationType,@ApiParam(value = "The column to sort the search on {ID, CREATED, UPDATED, ACTIVE, RATABLE_TYPE, RATABLE_ID, RATABLE_DISPLAY, CATEGORY_ID, CATEGORY_NAME, CATEGORY_SHORT_NAME, CATEGORY_DISPLAY, COUNT, SUMMATION, AVERAGE, VALUE}", allowableValues="ID, CREATED, UPDATED, DELETED, SEARCH_TAGS, ACTIVE, RATABLE_TYPE, RATABLE_ID, RATABLE_DISPLAY, CATEGORY_ID, CATEGORY_NAME, CATEGORY_SHORT_NAME, CATEGORY_DISPLAY, COUNT, SUMMATION, AVERAGE, VALUE") @QueryParam("sortField")  String sortField,@ApiParam(value = "The order to return the search results") @QueryParam("descending")  Boolean descending,@ApiParam(value = "The record to begin the return set on") @QueryParam("start")  Integer start,@ApiParam(value = "The number of records to return") @QueryParam("limit")  Integer limit,@ApiParam(value = "The search radius in kilometers to filter results") @QueryParam("searchRange")  Double searchRange,@ApiParam(value = "The current location of the user") @QueryParam("latitude")  Double latitude,@ApiParam(value = "The current location of the user") @QueryParam("longitude")  Double longitude,@ApiParam(value = "Determines whether to return the overall rating record instead") @QueryParam("returnOverallRating")  Boolean returnOverallRating,@ApiParam(value = "", allowableValues="MILES, KILOMETERS") @QueryParam("distanceUnit")  String distanceUnit,@ApiParam(value = "whether to return the retailer or not") @QueryParam("returnRetailer")  Boolean returnRetailer,@ApiParam(value = "whether to return the assets or not") @QueryParam("returnAssets")  Boolean returnAssets,@ApiParam(value = "whether to return the offers or not") @QueryParam("returnOffers")  Boolean returnOffers,@ApiParam(value = "whether to return the categories or not") @QueryParam("returnCategories")  Boolean returnCategories,@ApiParam(value = "whether to return the filters or not") @QueryParam("returnFilters")  Boolean returnFilters,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.searchLocationRatingIndexes(version, categoryIds, keyword, locationType, sortField, descending, start, limit, searchRange, latitude, longitude, returnOverallRating, distanceUnit, returnRetailer, returnAssets, returnOffers, returnCategories, returnFilters, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/media/search")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Search Media", notes = "Searches on events that the account has access to.", response = MediaOfferResponse.class, responseContainer = "List", tags={ "Media", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = MediaOfferResponse.class, responseContainer = "List")
    })
    public Response searchMedia(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The logged in user.", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "Return only active results", required = true) @QueryParam("activeOnly") @NotNull  Boolean activeOnly,@ApiParam(value = "The column to sort the search on. Possible values include: ID, CREATED, UPDATED, ACTIVE, ACTIVATED, EXPIRES, TITLE, SUBTITLE, DETAILS, OFFER_TYPE, SPECIAL_OFFER_TYPE, OFFER_VISIBILITY, ESTIMATED_VALUE, VOUCHER_PRICE, RETAILER_ID, RETAILER_NAME, RETAILER_LOCATION_ID, RETAILER_LOCATION_NAME, BILLABLE_ENTITY_ID, BILLABLE_ENTITY_NAME, RESPONSIBLE_DISPLAY, AVAILABILITY_DATE, RELEASE_DATE", required = true, allowableValues="ID, CREATED, UPDATED, DELETED, SEARCH_TAGS, ACTIVE, ACTIVATED, EXPIRES, REDEEMABLE_START, REDEEMABLE_END, TITLE, SUBTITLE, DETAILS, OFFER_TYPE, SPECIAL_OFFER_TYPE, OFFER_VISIBILITY, ESTIMATED_VALUE, VOUCHER_PRICE, VOUCHER_DISCOUNT_PRICE, FULL_PRICE, DICOUNT_PRICE, TICKETS_REWARD, AVAILABILITY_DATE, RELEASE_DATE, RETAILER_ID, RETAILER_NAME, RETAILER_LOCATION_ID, RETAILER_LOCATION_NAME, BILLABLE_ENTITY_ID, BILLABLE_ENTITY_NAME, RESPONSIBLE_DISPLAY") @QueryParam("sortField") @NotNull  String sortField,@ApiParam(value = "The order to return the search results", required = true) @QueryParam("descending") @NotNull  Boolean descending,@ApiParam(value = "The keyword used to search") @QueryParam("keyword")  String keyword,@ApiParam(value = "") @QueryParam("categoryIds")  String categoryIds,@ApiParam(value = "") @QueryParam("filterIds")  String filterIds,@ApiParam(value = "The record to begin the return set on") @QueryParam("start")  Integer start,@ApiParam(value = "The number of records to return") @QueryParam("limit")  Integer limit,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.searchMedia(version, accountId, activeOnly, sortField, descending, keyword, categoryIds, filterIds, start, limit, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/mission/format/search")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Search Mission Formats", notes = "Searches on pre-defined mission formats", response = MissionFormatResponse.class, responseContainer = "List", tags={ "Mission", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = MissionFormatResponse.class, responseContainer = "List")
    })
    public Response searchMissionFormats(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The starting index in the result set to return. Default is 0.", required = true) @QueryParam("start") @NotNull  Integer start,@ApiParam(value = "The total number of records to return. Default is 20.", required = true) @QueryParam("limit") @NotNull  Integer limit,@ApiParam(value = "Determines whether to return only active results. Default is false.", required = true) @QueryParam("activeOnly") @NotNull  Boolean activeOnly,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.searchMissionFormats(version, start, limit, activeOnly, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/mission/invite/search")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Search Mission Invites", notes = "Get a list of mission invites that the account has.", response = MissionResponse.class, responseContainer = "List", tags={ "Mission Invite", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = MissionResponse.class, responseContainer = "List")
    })
    public Response searchMissionInvites(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the device id (deviceId or accountId required).") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "the account id of the user (deviceId or accountId required).") @QueryParam("accountId")  Long accountId,@ApiParam(value = "the app to retrieve the data for, use your application key.") @QueryParam("appKey")  String appKey,@ApiParam(value = "the application version, used to version the game level data") @QueryParam("appVersion")  String appVersion,@ApiParam(value = "the mission id to filter on") @QueryParam("missionId")  Long missionId,@ApiParam(value = "The invite status to filter for, comma separated list {AVAILABLE, PENDING, UPDATED, ACCEPTED, ACTIVE, QUIT, COMPLETED, PENDING_REVIEW, REJECTED}") @QueryParam("status")  String status,@ApiParam(value = "Only return invites that have been updated since this date/time (long)") @QueryParam("lastUpdated")  Long lastUpdated,@ApiParam(value = "The index into the record set to start with.") @QueryParam("start")  Integer start,@ApiParam(value = "The total number of record to return.") @QueryParam("limit")  Integer limit,@ApiParam(value = "the keyword to search on") @QueryParam("keyword")  String keyword,@ApiParam(value = "") @QueryParam("missionTypes")  String missionTypes,@ApiParam(value = "filter results by the account's billable") @QueryParam("filterByBillable")  Boolean filterByBillable,@ApiParam(value = "Include the game level data with the mission.") @QueryParam("includeGameData")  Boolean includeGameData,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.searchMissionInvites(version, deviceId, accountId, appKey, appVersion, missionId, status, lastUpdated, start, limit, keyword, missionTypes, filterByBillable, includeGameData, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/mission/search")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Search Missions", notes = "Get the list missions available to the account.  ", response = MissionResponse.class, responseContainer = "List", tags={ "Mission", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = MissionResponse.class, responseContainer = "List")
    })
    public Response searchMissions(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The logged in user.", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "Filter by keyword") @QueryParam("keyword")  String keyword,@ApiParam(value = "Custom string client apps can use for searching/filtering missions") @QueryParam("subType")  String subType,@ApiParam(value = "The index into the record set to start with. Default is 0.") @QueryParam("start")  Integer start,@ApiParam(value = "The total number of record to return. Default is 20, maximum is 100.") @QueryParam("limit")  Integer limit,@ApiParam(value = "If true then return the game level data in the response. Default is false.") @QueryParam("includeGameData")  Boolean includeGameData,@ApiParam(value = "If true then return the audience data in the response. Default is false.") @QueryParam("includeAudiences")  Boolean includeAudiences,@ApiParam(value = "If true then include inactive missions. Default is false.") @QueryParam("includeInactive")  Boolean includeInactive,@ApiParam(value = "A list of game types to include; click_leaderboard, click_banner, click_skyscraper, click_full, click_video, click_zip, create, vote, question, invite, share, json, xml") @QueryParam("suffix")  String suffix,@ApiParam(value = "The field to sort the search on (for example TITLE)") @QueryParam("sortField")  String sortField,@ApiParam(value = "Whether to sort in descending order (default true)") @QueryParam("descending")  Boolean descending,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.searchMissions(version, accountId, keyword, subType, start, limit, includeGameData, includeAudiences, includeInactive, suffix, sortField, descending, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/mission/searchByBillableEntity")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Search Missions by Billable Entity", notes = "Use the accountId to determine the associated BillableEntity.  From there get a list of all accounts associated as managers.  Get the list missions owned by all associated managers.", response = MissionResponse.class, responseContainer = "List", tags={ "Mission", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = MissionResponse.class, responseContainer = "List")
    })
    public Response searchMissionsByBillableEntity(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The logged in user.", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "Filter by keyword") @QueryParam("keyword")  String keyword,@ApiParam(value = "The index into the record set to start with. Default is 0.") @QueryParam("start")  Integer start,@ApiParam(value = "The total number of record to return. Default id 20.") @QueryParam("limit")  Integer limit,@ApiParam(value = "If true then return the game level data in the response. Default is false.") @QueryParam("includeGameData")  Boolean includeGameData,@ApiParam(value = "If true then return the audience data in the response. Default is false.") @QueryParam("includeAudiences")  Boolean includeAudiences,@ApiParam(value = "If true then include inactive missions. Default is false.") @QueryParam("includeInactive")  Boolean includeInactive,@ApiParam(value = "A list of game types to include; click_leaderboard, click_banner, click_skyscraper, click_full, click_video, click_zip, create, vote, question, invite, share, json, xml") @QueryParam("suffix")  String suffix,@ApiParam(value = "The field to sort the search on (for example TITLE)") @QueryParam("sortField")  String sortField,@ApiParam(value = "Whether to sort in descending order (default true)") @QueryParam("descending")  Boolean descending,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.searchMissionsByBillableEntity(version, accountId, keyword, start, limit, includeGameData, includeAudiences, includeInactive, suffix, sortField, descending, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/thirdparty/network/search")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Search Networks", notes = "Search on supported third party networks and custom networks from external users.", response = ThirdPartyNetworkShortResponse.class, responseContainer = "List", tags={ "ThirdParty Credentials", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = ThirdPartyNetworkShortResponse.class, responseContainer = "List")
    })
    public Response searchNetworks(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The account id making the request", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "The column to sort the search on, possible values include: UPDATED (default), CREATED, NAME", required = true, allowableValues="ID, CREATED, UPDATED, DELETED, SEARCH_TAGS, ACTIVE, BILLABLE_ENTITY_ID, BILLABLE_ENTITY_NAME, RESPONSIBLE_DISPLAY, NAME, DESCRIPTION") @QueryParam("sortField") @NotNull  String sortField,@ApiParam(value = "The order to return the search results", required = true) @QueryParam("descending") @NotNull  Boolean descending,@ApiParam(value = "The start of the pagination", required = true) @QueryParam("start") @NotNull  Integer start,@ApiParam(value = "The limit of the pagination", required = true) @QueryParam("limit") @NotNull  Integer limit,@ApiParam(value = "Return only active results", required = true) @QueryParam("activeOnly") @NotNull  Boolean activeOnly,@ApiParam(value = "The keyword used to search on the network name and description fields") @QueryParam("keyword")  String keyword,@ApiParam(value = "Determines whether to only return applications that the user has access to") @QueryParam("filterBillable")  Boolean filterBillable,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.searchNetworks(version, accountId, sortField, descending, start, limit, activeOnly, keyword, filterBillable, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/note/search")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Search Notes", notes = "Search for notes on a notable object.", response = NoteResponse.class, responseContainer = "List", tags={ "Note", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = NoteResponse.class, responseContainer = "List")
    })
    public Response searchNotes(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The device id (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "The account id of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "The notable object type {ALBUM, ALBUM_CONTEST, ASSET, GAME_LEVEL, OFFER, OFFER_LOCATION, RETAILER, RETAILER_LOCATION, THEME_DESCRIPTOR}") @QueryParam("notableType")  String notableType,@ApiParam(value = "The id of the notable object") @QueryParam("notableId")  Long notableId,@ApiParam(value = "Comma separated list of noteType strings to filter results with") @QueryParam("noteTypes")  String noteTypes,@ApiParam(value = "The application key used to identify the application") @QueryParam("appKey")  String appKey,@ApiParam(value = "The keyword used to search") @QueryParam("keyword")  String keyword,@ApiParam(value = "return items that has flagCount >= flagCountMinimum if this is set, return all items, even ones with flagCount >= flagThreshold") @QueryParam("flagCountMinimum")  Long flagCountMinimum,@ApiParam(value = "return items that has flagCount >= flagThreshold, which are hidden by default") @QueryParam("flagsExceedThreshold")  Boolean flagsExceedThreshold,@ApiParam(value = "include inactive in the result") @QueryParam("includeInactive")  Boolean includeInactive,@ApiParam(value = "The column to sort the search on", allowableValues="ID, CREATED, UPDATED, DELETED, SEARCH_TAGS, ACTIVE, OWNER_DISPLAY, NOTABLE_TYPE, NOTE_TAG, NOTE_COUNT, LIKES, DISLIKES") @QueryParam("sortField")  String sortField,@ApiParam(value = "The order to return the search results") @QueryParam("descending")  Boolean descending,@ApiParam(value = "Determines whether to return the NoteFullResponse for each search item") @QueryParam("returnFullResponse")  Boolean returnFullResponse,@ApiParam(value = "return items that have been updated since this date (time-stamp in milliseconds)") @QueryParam("updatedSince")  Long updatedSince,@ApiParam(value = "return items that have been updated before this date (time-stamp in milliseconds)") @QueryParam("updatedBefore")  Long updatedBefore,@ApiParam(value = "The record to begin the return set on") @QueryParam("start")  Integer start,@ApiParam(value = "The number of records to return") @QueryParam("limit")  Integer limit,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.searchNotes(version, deviceId, accountId, notableType, notableId, noteTypes, appKey, keyword, flagCountMinimum, flagsExceedThreshold, includeInactive, sortField, descending, returnFullResponse, updatedSince, updatedBefore, start, limit, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/notification/template/search")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Search Notification Templates", notes = "Search for notification templates on owned applications.", response = NotificationTemplateResponse.class, tags={ "Notification", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = NotificationTemplateResponse.class)
    })
    public Response searchNotificationTemplate(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The account ID of the user.", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "Specifies how results are ordered.ID - order results by the notificationTemplateId CREATED - order results by the created date UPDATED - order results by the updated date TITLE - order results by title EVENT - order results by event CONDUIT - order results by conduit APP_NAME - order results by the application name ('global' templates will not have an application and will be returned last if 'descending' is set to false.", required = true) @QueryParam("sortField") @NotNull  String sortField,@ApiParam(value = "Specified whether the results are returned in descending or ascending order.", required = true) @QueryParam("descending") @NotNull  Boolean descending,@ApiParam(value = "The start of the pagination.", required = true) @QueryParam("start") @NotNull  Integer start,@ApiParam(value = "The limit of the pagination.", required = true) @QueryParam("limit") @NotNull  Integer limit,@ApiParam(value = "Filter results by application.") @QueryParam("appKey")  String appKey,@ApiParam(value = "Filter results by event.") @QueryParam("event")  String event,@ApiParam(value = "Filter results by notification type: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION.") @QueryParam("conduit")  String conduit,@ApiParam(value = "Returns only templates that have been reserved for system use on all applications (only for admin accounts).") @QueryParam("globalOnly")  Boolean globalOnly,@ApiParam(value = "Returns only templates that use reserved events.") @QueryParam("reservedOnly")  Boolean reservedOnly,@ApiParam(value = "Filter results by keyword on the title, tags.") @QueryParam("keyword")  String keyword,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.searchNotificationTemplate(version, accountId, sortField, descending, start, limit, appKey, event, conduit, globalOnly, reservedOnly, keyword, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/object/search")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Search Objects", notes = "Search for Objects and return the list of names found.  Use this in conjunction with the object get service to present the current data model defined.", response = ObjectStoreResponse.class, tags={ "Object Store", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = ObjectStoreResponse.class)
    })
    public Response searchObject(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The account id of the logged in user", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "The application key for updating an existing application", required = true) @QueryParam("appKey") @NotNull  String appKey,@ApiParam(value = "The start of the pagination", required = true) @QueryParam("start") @NotNull  Long start,@ApiParam(value = "The limit of the pagination", required = true) @QueryParam("limit") @NotNull  Long limit,@ApiParam(value = "The name of the object(s) to search for, can be a partial match") @QueryParam("keyword")  String keyword,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.searchObject(version, accountId, appKey, start, limit, keyword, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/tournament/object/search")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Search Tournament Objects", notes = "Search on game objects of tournaments", response = SirqulResponse.class, tags={ "Tournament", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response searchObjects(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the account ID", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "the game level id to filter results by", required = true) @QueryParam("gameLevelId") @NotNull  Long gameLevelId,@ApiParam(value = "the field to sort by", allowableValues="ID, PLAYER_SCORE_COUNT", defaultValue = "PLAYER_SCORE_COUNT") @DefaultValue("PLAYER_SCORE_COUNT") @QueryParam("sortField")  String sortField,@ApiParam(value = "determines whether the sorted list is in descending or ascending order", defaultValue = "true") @DefaultValue("true") @QueryParam("descending")  Boolean descending,@ApiParam(value = "the start index for pagination", defaultValue = "0") @DefaultValue("0") @QueryParam("start")  Integer start,@ApiParam(value = "the limit for pagination", defaultValue = "20") @DefaultValue("20") @QueryParam("limit")  Integer limit,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.searchObjects(version, accountId, gameLevelId, sortField, descending, start, limit, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/offer/status/search")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Search Offer Status", notes = "Search for the available offer statuses", response = OfferTransactionStatusResponse.class, responseContainer = "List", tags={ "Offer Status", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = OfferTransactionStatusResponse.class, responseContainer = "List")
    })
    public Response searchOfferTransactionStatuses(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The device id (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "The account id of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "Used to update the user's current location") @QueryParam("latitude")  Double latitude,@ApiParam(value = "Used to update the user's current location") @QueryParam("longitude")  Double longitude,@ApiParam(value = "Search the name and description fields") @QueryParam("keyword")  String keyword,@ApiParam(value = "The actors role, possible values are: CUSTOMER, RETAILER, or ANY") @QueryParam("role")  String role,@ApiParam(value = "The application making the request") @QueryParam("appKey")  String appKey,@ApiParam(value = "The field to sort on, possible values are: ID, CREATED, UPDATED, DELETED, SEARCH_TAGS, ACTIVE, NAME, DESCRIPTION, CODE, ROLE", allowableValues="ID, CREATED, UPDATED, DELETED, SEARCH_TAGS, ACTIVE, NAME, DESCRIPTION, CODE, ROLE", defaultValue = "CODE") @DefaultValue("CODE") @QueryParam("sortField")  String sortField,@ApiParam(value = "Determines whether the results are in descending order", defaultValue = "true") @DefaultValue("true") @QueryParam("descending")  Boolean descending,@ApiParam(value = "The start index for pagination", defaultValue = "0") @DefaultValue("0") @QueryParam("start")  Integer start,@ApiParam(value = "The limit for pagination", defaultValue = "20") @DefaultValue("20") @QueryParam("limit")  Integer limit,@ApiParam(value = "If true include inactive items", defaultValue = "false") @DefaultValue("false") @QueryParam("includeInactive")  Boolean includeInactive,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.searchOfferTransactionStatuses(version, deviceId, accountId, latitude, longitude, keyword, role, appKey, sortField, descending, start, limit, includeInactive, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/wallet/search")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Search Wallet Offers", notes = "Search on active offers currently in the user's wallet, or past offers the user has already redeemed.", response = OfferTransactionResponse.class, responseContainer = "List", tags={ "Wallet", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = OfferTransactionResponse.class, responseContainer = "List")
    })
    public Response searchOfferTransactions(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The device id (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "The account id of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "The keyword to search for") @QueryParam("keyword")  String keyword,@ApiParam(value = "Filter results for this retailer") @QueryParam("retailerId")  Long retailerId,@ApiParam(value = "Filter results for a list of retailers") @QueryParam("retailerIds")  String retailerIds,@ApiParam(value = "Filter results for this retailer location") @QueryParam("retailerLocationId")  Long retailerLocationId,@ApiParam(value = "Filter results for a list of retailer locations") @QueryParam("retailerLocationIds")  String retailerLocationIds,@ApiParam(value = "Filter results to exclude retailer locations") @QueryParam("excludeRetailerLocationIds")  String excludeRetailerLocationIds,@ApiParam(value = "Filter results for this offer") @QueryParam("offerId")  Long offerId,@ApiParam(value = "Filter results for a list of offer") @QueryParam("offerIds")  String offerIds,@ApiParam(value = "Filter results for this offer location") @QueryParam("offerLocationId")  Long offerLocationId,@ApiParam(value = "Filter results for a list of offer locations") @QueryParam("offerLocationIds")  String offerLocationIds,@ApiParam(value = "Filter results to return a specific offer type", allowableValues="VOUCHER, COUPON, PRODUCT, MEDIA, EVENT, DEVICE") @QueryParam("offerType")  String offerType,@ApiParam(value = "Filter results to return specific offer types") @QueryParam("offerTypes")  String offerTypes,@ApiParam(value = "Filter results to return a specific special offer type") @QueryParam("specialOfferType")  String specialOfferType,@ApiParam(value = "Filter results to return specific special offer types") @QueryParam("specialOfferTypes")  String specialOfferTypes,@ApiParam(value = "Category Ids") @QueryParam("categoryIds")  String categoryIds,@ApiParam(value = "Filter Ids") @QueryParam("filterIds")  String filterIds,@ApiParam(value = "Offer Audience Ids") @QueryParam("offerAudienceIds")  String offerAudienceIds,@ApiParam(value = "Determines what to sort the results by", allowableValues="ID, CREATED, UPDATED, DELETED, SEARCH_TAGS, ACTIVE, ACTIVATED, EXPIRES, TITLE, SUBTITLE, DETAILS, OFFER_TYPE, SPECIAL_OFFER_TYPE, OFFER_VISIBILITY, REDEEMABLE_START, REDEEMABLE_END, CUSTOMER_ID, CUSTOMER_DISPLAY, RETAILER_ID, RETAILER_NAME, RETAILER_LOCATION_ID, RETAILER_LOCATION_NAME, BILLABLE_ENTITY_ID, BILLABLE_ENTITY_NAME, RESPONSIBLE_DISPLAY", defaultValue = "CREATED") @DefaultValue("CREATED") @QueryParam("sortField")  String sortField,@ApiParam(value = "Determines whether the results are in descending order", defaultValue = "true") @DefaultValue("true") @QueryParam("descending")  Boolean descending,@ApiParam(value = "The start index for pagination", defaultValue = "0") @DefaultValue("0") @QueryParam("start")  Integer start,@ApiParam(value = "The limit for pagination", defaultValue = "20") @DefaultValue("20") @QueryParam("limit")  Integer limit,@ApiParam(value = "The latitude location of the user") @QueryParam("latitude")  Double latitude,@ApiParam(value = "The latitude location of the user") @QueryParam("longitude")  Double longitude,@ApiParam(value = "Filter results by the offer redeemable date") @QueryParam("redeemableStartDate")  Long redeemableStartDate,@ApiParam(value = "Filter results by the offer redeemable date") @QueryParam("redeemableEndDate")  Long redeemableEndDate,@ApiParam(value = "Apply params to offer's parent", defaultValue = "false") @DefaultValue("false") @QueryParam("filterByParentOffer")  Boolean filterByParentOffer,@ApiParam(value = "Filter results by the offer start date") @QueryParam("startedSince")  Long startedSince,@ApiParam(value = "Filter results by the offer start date") @QueryParam("startedBefore")  Long startedBefore,@ApiParam(value = "Filter results by the offer end date") @QueryParam("endedSince")  Long endedSince,@ApiParam(value = "Filter results by the offer end date") @QueryParam("endedBefore")  Long endedBefore,@ApiParam(value = "If true return redeemed transactions (status 2), otherwise return active transactions (status 0 or 1)", defaultValue = "false") @DefaultValue("false") @QueryParam("redeemed")  Boolean redeemed,@ApiParam(value = "Custom status value to change to (0 or 1 for redeem, 5 or 6 for membership)") @QueryParam("statuses")  String statuses,@ApiParam(value = "Returns only reservation transactions if true", defaultValue = "false") @DefaultValue("false") @QueryParam("reservationsOnly")  Boolean reservationsOnly,@ApiParam(value = "Active Only", defaultValue = "false") @DefaultValue("false") @QueryParam("activeOnly")  Boolean activeOnly,@ApiParam(value = "Determines whether to return a detailed version of the response", defaultValue = "false") @DefaultValue("false") @QueryParam("returnFullResponse")  Boolean returnFullResponse,@ApiParam(value = "Filter results by the recurring billing start date") @QueryParam("recurringStartedSince")  Long recurringStartedSince,@ApiParam(value = "Filter results by the recurring billing start date") @QueryParam("recurringStartedBefore")  Long recurringStartedBefore,@ApiParam(value = "Filter results by the recurring billing expiration date") @QueryParam("recurringExpirationSince")  Long recurringExpirationSince,@ApiParam(value = "Filter results by the recurring billing expiration date") @QueryParam("recurringExpirationBefore")  Long recurringExpirationBefore,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.searchOfferTransactions(version, deviceId, accountId, keyword, retailerId, retailerIds, retailerLocationId, retailerLocationIds, excludeRetailerLocationIds, offerId, offerIds, offerLocationId, offerLocationIds, offerType, offerTypes, specialOfferType, specialOfferTypes, categoryIds, filterIds, offerAudienceIds, sortField, descending, start, limit, latitude, longitude, redeemableStartDate, redeemableEndDate, filterByParentOffer, startedSince, startedBefore, endedSince, endedBefore, redeemed, statuses, reservationsOnly, activeOnly, returnFullResponse, recurringStartedSince, recurringStartedBefore, recurringExpirationSince, recurringExpirationBefore, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/retailer/offer/transaction/search")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Search Offer Transactions", notes = "Searches on offer transactions for offers that the account has access to.", response = OfferTransactionResponse.class, responseContainer = "List", tags={ "Offer", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = OfferTransactionResponse.class, responseContainer = "List")
    })
    public Response searchOfferTransactionsForRetailers(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "Determines what to sort the results by {CREATED, UPDATED, SEARCH_TAGS, ACTIVE, ACTIVATED, EXPIRES, TITLE, SUBTITLE, OFFER_TYPE, SPECIAL_OFFER_TYPE, OFFER_VISIBILITY, CUSTOMER_ID, CUSTOMER_DISPLAY, RETAILER_ID, RETAILER_NAME, RETAILER_LOCATION_ID, RETAILER_LOCATION_NAME, BILLABLE_ENTITY_ID, BILLABLE_ENTITY_NAME, RESPONSIBLE_DISPLAY}", required = true, allowableValues="ID, CREATED, UPDATED, DELETED, SEARCH_TAGS, ACTIVE, ACTIVATED, EXPIRES, TITLE, SUBTITLE, DETAILS, OFFER_TYPE, SPECIAL_OFFER_TYPE, OFFER_VISIBILITY, REDEEMABLE_START, REDEEMABLE_END, CUSTOMER_ID, CUSTOMER_DISPLAY, RETAILER_ID, RETAILER_NAME, RETAILER_LOCATION_ID, RETAILER_LOCATION_NAME, BILLABLE_ENTITY_ID, BILLABLE_ENTITY_NAME, RESPONSIBLE_DISPLAY") @QueryParam("sortField") @NotNull  String sortField,@ApiParam(value = "Determines whether the results are in descending order", required = true) @QueryParam("descending") @NotNull  Boolean descending,@ApiParam(value = "The start index for pagination", required = true) @QueryParam("start") @NotNull  Integer start,@ApiParam(value = "The limit for pagination", required = true) @QueryParam("limit") @NotNull  Integer limit,@ApiParam(value = "Determines whether to only return active offer transactions", required = true) @QueryParam("activeOnly") @NotNull  Boolean activeOnly,@ApiParam(value = "The device id (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "The account id of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "This parameter is deprecated.") @QueryParam("q")  String q,@ApiParam(value = "The keyword to search for") @QueryParam("keyword")  String keyword,@ApiParam(value = "Filter results for this retailer") @QueryParam("retailerId")  Long retailerId,@ApiParam(value = "Filter results for this retailer location") @QueryParam("retailerLocationId")  Long retailerLocationId,@ApiParam(value = "Filter results for this offer") @QueryParam("offerId")  Long offerId,@ApiParam(value = "Filter results for this offer location") @QueryParam("offerLocationId")  Long offerLocationId,@ApiParam(value = "if true return redeemed transactions (status 2), if false return active transactions (status 0 or 1)") @QueryParam("redeemed")  Boolean redeemed,@ApiParam(value = "returns only reservation transactions if true") @QueryParam("reservationsOnly")  Boolean reservationsOnly,@ApiParam(value = "This parameter is deprecated.", allowableValues="VOUCHER, COUPON, PRODUCT, MEDIA, EVENT, DEVICE") @QueryParam("couponType")  String couponType,@ApiParam(value = "Filter results to only return COUPON, VOUCHER, PRODUCT, MEDIA, or EVENT offers", allowableValues="VOUCHER, COUPON, PRODUCT, MEDIA, EVENT, DEVICE") @QueryParam("offerType")  String offerType,@ApiParam(value = "Filter results to only return REGULAR_OFFER, ACT_NOW, GET_THERE_NOW offer specials", allowableValues="ALL, RESERVABLE, REGULAR_OFFER, ACT_NOW, GET_THERE_NOW, SQOOT, TICKETS, YIPIT") @QueryParam("specialOfferType")  String specialOfferType,@ApiParam(value = "Filter results by accounts") @QueryParam("customerAccountIds")  String customerAccountIds,@ApiParam(value = "") @QueryParam("categoryIds")  String categoryIds,@ApiParam(value = "") @QueryParam("redeemableStartDate")  Long redeemableStartDate,@ApiParam(value = "") @QueryParam("redeemableEndDate")  Long redeemableEndDate,@ApiParam(value = "This parameter is deprecated.") @QueryParam("_i")  Integer i,@ApiParam(value = "This parameter is deprecated.") @QueryParam("_l")  Integer l,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.searchOfferTransactionsForRetailers(version, sortField, descending, start, limit, activeOnly, deviceId, accountId, q, keyword, retailerId, retailerLocationId, offerId, offerLocationId, redeemed, reservationsOnly, couponType, offerType, specialOfferType, customerAccountIds, categoryIds, redeemableStartDate, redeemableEndDate, i, l, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/offer/lists")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Search Offers", notes = "Searches for offers as a consumer.", response = OfferListResponse.class, tags={ "Offer", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = OfferListResponse.class)
    })
    public Response searchOffersForConsumer(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The latitude of where the search will center at", required = true) @QueryParam("latitude") @NotNull  Double latitude,@ApiParam(value = "The longitude of where the search will center at", required = true) @QueryParam("longitude") @NotNull  Double longitude,@ApiParam(value = "The method to use to gather recommendations: WALLET base relevance on items in users wallets CLICKS base relevance on items users have clicked on BLENDED blend using all methods available", required = true, allowableValues="WALLET, CLICKS, BLENDED") @QueryParam("recommendationType") @NotNull  String recommendationType,@ApiParam(value = "This parameter is deprecated. The location id", required = true) @QueryParam("locationId") @NotNull  Long locationId,@ApiParam(value = "The start index for pagination", required = true) @QueryParam("start") @NotNull  Integer start,@ApiParam(value = "The limit for pagination", required = true) @QueryParam("limit") @NotNull  Integer limit,@ApiParam(value = "", required = true) @QueryParam("maxRecommendations") @NotNull  Integer maxRecommendations,@ApiParam(value = "", required = true, allowableValues="MILES, KILOMETERS") @QueryParam("distanceUnit") @NotNull  String distanceUnit,@ApiParam(value = "The application key used to identify the application") @QueryParam("appKey")  String appKey,@ApiParam(value = "The device id for returning account information (i.e. offer transactions made by the user)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "The account id for returning account information (i.e. offer transactions made by the user)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "The range of the search", defaultValue = "5") @DefaultValue("5") @QueryParam("searchRange")  Double searchRange,@ApiParam(value = "Does a full-text search on tags") @QueryParam("tags")  String tags,@ApiParam(value = "supported postal codes") @QueryParam("supportedPostalCodes")  String supportedPostalCodes,@ApiParam(value = "The keyword to filter results by") @QueryParam("keyword")  String keyword,@ApiParam(value = "Comma separate list of category ids") @QueryParam("categories")  String categories,@ApiParam(value = "Comma separated list of filter ids") @QueryParam("filters")  String filters,@ApiParam(value = "Comma separated list of offer types {COUPON, VOUCHER, PRODUCT, MEDIA, EVENT, DEVICE}", defaultValue = "COUPON, VOUCHER") @DefaultValue("COUPON, VOUCHER") @QueryParam("offerTypes")  String offerTypes,@ApiParam(value = "The special offer type {ALL, RESERVABLE, REGULAR_OFFER, ACT_NOW, GET_THERE_NOW}") @QueryParam("type")  String type,@ApiParam(value = "The field to sort the result set on:DISTANCE Sort the offers nearest to farthest BUSINESS_NAME Sort the offers alphabetically by location name SHUFFLE Sort the nearest offers randomly USERPREFS accountId must accompany this parameter. Gives the first X recommendations where X equals the parameter maxRecommendations") @QueryParam("sortField")  String sortField,@ApiParam(value = "Return recommendations based on these offers IDs") @QueryParam("recommendOfferIds")  String recommendOfferIds,@ApiParam(value = "Only return offer locations for the specific retailer locations.") @QueryParam("retailerLocationIds")  String retailerLocationIds,@ApiParam(value = "Only return offer locations for the specific offer.") @QueryParam("offerId")  Long offerId,@ApiParam(value = "If true include the mission response as part of the offer. Default is false.") @QueryParam("includeMission")  Boolean includeMission,@ApiParam(value = "If true include the category list response as part of the offer. Default is false.") @QueryParam("includeCategories")  Boolean includeCategories,@ApiParam(value = "If true include the filter list response as part of the offer. Default is false.") @QueryParam("includeFilters")  Boolean includeFilters,@ApiParam(value = "If true then ignore the expired dates. Default is false.") @QueryParam("includeExpired")  Boolean includeExpired,@ApiParam(value = "If true then ignore the favorite. Default is false.") @QueryParam("includeFavorite")  Boolean includeFavorite,@ApiParam(value = "This parameter is deprecated. see groupBy. If true then it only returns the offer location for an offer closest to the given lat/lon") @QueryParam("closestOfferOnly")  Boolean closestOfferOnly,@ApiParam(value = "") @QueryParam("searchExpression")  String searchExpression,@ApiParam(value = "groups the results by a certain field. For example, if you want to return the closest offer location of an offer, then pass in groupBy=OFFER_ID and sortField=DISTANCE (to sort by distance).", allowableValues="ID, CREATED, UPDATED, DELETED, SEARCH_TAGS, ACTIVE, OFFER_ID, ACTIVATED, EXPIRES, TITLE, SUBTITLE, DETAILS, OFFER_TYPE, SPECIAL_OFFER_TYPE, OFFER_VISIBILITY, RETAILER_ID, RETAILER_LOCATION_ID, BILLABLE_ENTITY_ID, BILLABLE_ENTITY_NAME, RESPONSIBLE_DISPLAY") @QueryParam("groupBy")  String groupBy,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.searchOffersForConsumer(version, latitude, longitude, recommendationType, locationId, start, limit, maxRecommendations, distanceUnit, appKey, deviceId, accountId, searchRange, tags, supportedPostalCodes, keyword, categories, filters, offerTypes, type, sortField, recommendOfferIds, retailerLocationIds, offerId, includeMission, includeCategories, includeFilters, includeExpired, includeFavorite, closestOfferOnly, searchExpression, groupBy, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/order/search")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Search Orders", notes = "Search on active orders by customer", response = OrderResponse.class, responseContainer = "List", tags={ "Purchase Order", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = OrderResponse.class, responseContainer = "List")
    })
    public Response searchOrders(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The application requesting the purchase", required = true) @QueryParam("appKey") @NotNull  String appKey,@ApiParam(value = "The device id (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "The account id of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "The start index for pagination", defaultValue = "0") @DefaultValue("0") @QueryParam("start")  Integer start,@ApiParam(value = "The limit for pagination", defaultValue = "20") @DefaultValue("20") @QueryParam("limit")  Integer limit,@ApiParam(value = "Determines whether to return the resulting list in descending or ascending order", defaultValue = "true") @DefaultValue("true") @QueryParam("descending")  Boolean descending,@ApiParam(value = "Only return active orders", defaultValue = "false") @DefaultValue("false") @QueryParam("activeOnly")  Boolean activeOnly,@ApiParam(value = "Determines whether to ignore the customer filter (requires an Admin/Exec account)", defaultValue = "false") @DefaultValue("false") @QueryParam("ignoreCustomerFilter")  Boolean ignoreCustomerFilter,@ApiParam(value = "Filter results by orderItemTypes") @QueryParam("orderItemTypes")  String orderItemTypes,@ApiParam(value = "Filter results by orderItemIds") @QueryParam("orderItemIds")  String orderItemIds,@ApiParam(value = "Filter results by orderCustomTypes") @QueryParam("orderCustomTypes")  String orderCustomTypes,@ApiParam(value = "Filter results by orderCustomIds") @QueryParam("orderCustomIds")  String orderCustomIds,@ApiParam(value = "Determines what to sort the results by", defaultValue = "ID") @DefaultValue("ID") @QueryParam("sortField")  String sortField,@ApiParam(value = "Filter results by offer type") @QueryParam("offerTypes")  String offerTypes,@ApiParam(value = "Filter results by special offer type") @QueryParam("specialOfferTypes")  String specialOfferTypes,@ApiParam(value = "Filter results by category Ids") @QueryParam("categoryIds")  String categoryIds,@ApiParam(value = "Filter results by filter Ids") @QueryParam("filterIds")  String filterIds,@ApiParam(value = "Filter results by offer audience Ids") @QueryParam("offerAudienceIds")  String offerAudienceIds,@ApiParam(value = "Filter results by transaction audience Ids") @QueryParam("transactionAudienceIds")  String transactionAudienceIds,@ApiParam(value = "Filter results by offer Ids") @QueryParam("offerIds")  String offerIds,@ApiParam(value = "Filter results by offer location Ids") @QueryParam("offerLocationIds")  String offerLocationIds,@ApiParam(value = "Filter results by retailer Ids") @QueryParam("retailerIds")  String retailerIds,@ApiParam(value = "Filter results by retailer location Ids") @QueryParam("retailerLocationIds")  String retailerLocationIds,@ApiParam(value = "Filter results by offer transaction status (0: non-redeemable, 1: redeemable, 2: redeemed, 3: user deleted, 4: unclaimed/rewarded, 5: membership active, 6: membership cancelled)") @QueryParam("statuses")  String statuses,@ApiParam(value = "The keyword to search for") @QueryParam("keyword")  String keyword,@ApiParam(value = "Filter results by the offer redeemable date") @QueryParam("redeemableStartDate")  Long redeemableStartDate,@ApiParam(value = "Filter results by the offer redeemable date") @QueryParam("redeemableEndDate")  Long redeemableEndDate,@ApiParam(value = "Filter results by the offer start date") @QueryParam("startedSince")  Long startedSince,@ApiParam(value = "Filter results by the offer start date") @QueryParam("startedBefore")  Long startedBefore,@ApiParam(value = "Filter results by the offer end date") @QueryParam("endedSince")  Long endedSince,@ApiParam(value = "Filter results by the offer end date") @QueryParam("endedBefore")  Long endedBefore,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.searchOrders(version, appKey, deviceId, accountId, start, limit, descending, activeOnly, ignoreCustomerFilter, orderItemTypes, orderItemIds, orderCustomTypes, orderCustomIds, sortField, offerTypes, specialOfferTypes, categoryIds, filterIds, offerAudienceIds, transactionAudienceIds, offerIds, offerLocationIds, retailerIds, retailerLocationIds, statuses, keyword, redeemableStartDate, redeemableEndDate, startedSince, startedBefore, endedSince, endedBefore, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/pack/search")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Search Packs", notes = "Search on packs.", response = PackResponse.class, responseContainer = "List", tags={ "Pack", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = PackResponse.class, responseContainer = "List")
    })
    public Response searchPacks(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The logged in user.", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "The field to sort by. Possible values include: TITLE, DESCRIPTION, CREATED, UPDATED", required = true, allowableValues="TITLE, DESCRIPTION, CREATED, UPDATED") @QueryParam("sortField") @NotNull  String sortField,@ApiParam(value = "Determines whether the sorted list is in descending or ascending order", required = true) @QueryParam("descending") @NotNull  Boolean descending,@ApiParam(value = "Keyword search on the pack name") @QueryParam("keyword")  String keyword,@ApiParam(value = "Filters results on pack type", allowableValues="TUTORIAL, BUILTIN, DOWNLOAD, THRESHOLD, THEME, TOURNAMENT") @QueryParam("packType")  String packType,@ApiParam(value = "Start the result set at some index.") @QueryParam("start")  Integer start,@ApiParam(value = "Limit the result to some number.") @QueryParam("limit")  Integer limit,@ApiParam(value = "Determines whether to include game data in the results") @QueryParam("includeGameData")  Boolean includeGameData,@ApiParam(value = "Determines whether to include inactive results") @QueryParam("includeInactive")  Boolean includeInactive,@ApiParam(value = "The application to filter results on") @QueryParam("appKey")  String appKey,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.searchPacks(version, accountId, sortField, descending, keyword, packType, start, limit, includeGameData, includeInactive, appKey, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/billing/search")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Search Payment Methods", notes = "Search the payment methods of an account", response = PaymentTypesResponse.class, tags={ "Billing Info", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = PaymentTypesResponse.class)
    })
    public Response searchPaymentMethod(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "Account Id to search on", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "Provider to search on", defaultValue = "AUTHORIZE_NET") @DefaultValue("AUTHORIZE_NET") @QueryParam("provider")  String provider,@ApiParam(value = "the type to search on") @QueryParam("type")  String type,@ApiParam(value = "the keyword to search on") @QueryParam("keyword")  String keyword,@ApiParam(value = "the sort field to use for the search", defaultValue = "UPDATED") @DefaultValue("UPDATED") @QueryParam("sortField")  String sortField,@ApiParam(value = "if the results should be in descending order", defaultValue = "true") @DefaultValue("true") @QueryParam("descending")  Boolean descending,@ApiParam(value = "the start of the search", defaultValue = "0") @DefaultValue("0") @QueryParam("start")  Integer start,@ApiParam(value = "the limit of the search", defaultValue = "5") @DefaultValue("5") @QueryParam("limit")  Integer limit,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.searchPaymentMethod(version, accountId, provider, type, keyword, sortField, descending, start, limit, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/permissions/search")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Search Permissionables", notes = "Search on UserPermissions", response = UserPermissionsResponse.class, responseContainer = "List", tags={ "User Permissions", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = UserPermissionsResponse.class, responseContainer = "List")
    })
    public Response searchPermissionables(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "A unique ID given by the device (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "The account ID of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "Filter results for a specific user account") @QueryParam("connectionAccountId")  Long connectionAccountId,@ApiParam(value = "Comma separated list of account IDs to filter results with") @QueryParam("connectionAccountIds")  String connectionAccountIds,@ApiParam(value = "Filter user permissions by the permissionable object type", allowableValues="ACCOUNT, GAMELEVEL, ALBUM_CONTEST, THEME_DESCRIPTOR, SCHEDULED_NOTIFICATION, TASK, TRIGGER") @QueryParam("permissionableType")  String permissionableType,@ApiParam(value = "The id of the permissionable object to filter by") @QueryParam("permissionableId")  Long permissionableId,@ApiParam(value = "Keyword to search within permissionable records") @QueryParam("keyword")  String keyword,@ApiParam(value = "Field to sort results on") @QueryParam("sortField")  String sortField,@ApiParam(value = "Sort descending when true") @QueryParam("descending")  Boolean descending,@ApiParam(value = "Return user permissions that are pending") @QueryParam("pending")  Boolean pending,@ApiParam(value = "Return user permissions that are admins") @QueryParam("admin")  Boolean admin,@ApiParam(value = "the start index for pagination", defaultValue = "0") @DefaultValue("0") @QueryParam("start")  Integer start,@ApiParam(value = "the limit for pagination", defaultValue = "20") @DefaultValue("20") @QueryParam("limit")  Integer limit,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.searchPermissionables(version, deviceId, accountId, connectionAccountId, connectionAccountIds, permissionableType, permissionableId, keyword, sortField, descending, pending, admin, start, limit, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/permissions/distancesearch")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Search Permissionables by Distnace", notes = "Search on UserPermissions by distance", response = UserPermissionsResponse.class, responseContainer = "List", tags={ "User Permissions", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = UserPermissionsResponse.class, responseContainer = "List")
    })
    public Response searchPermissionablesFollowingDistance(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The latitude of the current account", required = true) @QueryParam("latitude") @NotNull  Double latitude,@ApiParam(value = "The longitude of the current account", required = true) @QueryParam("longitude") @NotNull  Double longitude,@ApiParam(value = "A unique ID given by the device (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "The account ID of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "Filter results for a specific user account") @QueryParam("connectionAccountId")  Long connectionAccountId,@ApiParam(value = "Comma separated list of account IDs to filter results with") @QueryParam("connectionAccountIds")  String connectionAccountIds,@ApiParam(value = "Filter user permissions by the permissionable object type", allowableValues="ACCOUNT, GAMELEVEL, ALBUM_CONTEST, THEME_DESCRIPTOR, SCHEDULED_NOTIFICATION, TASK, TRIGGER") @QueryParam("permissionableType")  String permissionableType,@ApiParam(value = "The id of the permissionable object to filter by") @QueryParam("permissionableId")  Long permissionableId,@ApiParam(value = "The search range in miles", defaultValue = "5") @DefaultValue("5") @QueryParam("searchRange")  Double searchRange,@ApiParam(value = "Keyword to search within permissionable records") @QueryParam("keyword")  String keyword,@ApiParam(value = "Return user permissions that are pending") @QueryParam("pending")  Boolean pending,@ApiParam(value = "Return user permissions that are admins") @QueryParam("admin")  Boolean admin,@ApiParam(value = "The start index for pagination", defaultValue = "0") @DefaultValue("0") @QueryParam("start")  Integer start,@ApiParam(value = "The limit for pagination", defaultValue = "20") @DefaultValue("20") @QueryParam("limit")  Integer limit,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.searchPermissionablesFollowingDistance(version, latitude, longitude, deviceId, accountId, connectionAccountId, connectionAccountIds, permissionableType, permissionableId, searchRange, keyword, pending, admin, start, limit, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/persona/search")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Search Personas", notes = "Search for persona that the account owns by the given account ID.", response = PreviewPersonaResponse.class, tags={ "Preview Persona", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = PreviewPersonaResponse.class)
    })
    public Response searchPersona(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the account ID of the user", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "the start index for pagination", required = true) @QueryParam("start") @NotNull  Integer start,@ApiParam(value = "the limit for pagination (There is a hard limit of 100)", required = true) @QueryParam("limit") @NotNull  Integer limit,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.searchPersona(version, accountId, start, limit, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/program")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Search Programs", notes = "Search for programs", response = Program.class, responseContainer = "List", tags={ "Program", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = Program.class, responseContainer = "List")
    })
    public Response searchPrograms(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The field to sort by", required = true) @QueryParam("sortField") @NotNull  String sortField,@ApiParam(value = "Determines whether the sorted list is in descending or ascending order", required = true) @QueryParam("descending") @NotNull  Boolean descending,@ApiParam(value = "The start index for pagination", required = true) @QueryParam("start") @NotNull  Integer start,@ApiParam(value = "The limit for pagination", required = true) @QueryParam("limit") @NotNull  Integer limit,@ApiParam(value = "Return only active results", required = true) @QueryParam("activeOnly") @NotNull  Boolean activeOnly,@ApiParam(value = "The keyword to filter results by") @QueryParam("keyword")  String keyword,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.searchPrograms(version, sortField, descending, start, limit, activeOnly, keyword, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/purchase/search")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Search Purchases", notes = "Search for purchasable items from the system", response = PurchaseItemResponse.class, responseContainer = "List", tags={ "Purchase Item", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = PurchaseItemResponse.class, responseContainer = "List")
    })
    public Response searchPurchaseItems(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The device id (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "The account id of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "The application key to filter results by application") @QueryParam("appKey")  String appKey,@ApiParam(value = "Determines whether to filter results by the user's billable entity", defaultValue = "false") @DefaultValue("false") @QueryParam("filterByBillable")  Boolean filterByBillable,@ApiParam(value = "A comma separated list of purchase providers to filter by. Possible values include: <ul> <li>SIRQUL - purchases from the Sirqul store using tickets</li> <li>IOS - purchases from the iTunes store for iPhone, iPod, iPod Touch</li> <li>GOOGLE - purchases from the Google Play store</li> <li>AMAZON - purchases from the Amazon Android store</li> <li>MAC - purchases from the iTunes store for OSX</li> <li>WP8 - purchases from the Windows Phone 8 store</li> <li>FREE - purchases that are free (can be used for development/testing purposes)</li> </ul>") @QueryParam("purchaseType")  String purchaseType,@ApiParam(value = "A comma separated list of service actions to filter results by. Possible values include: <ul> <li>DAY_PREMIUM - purchases that subscribes a user for a day of membership</li> <li>WEEK_PREMIUM - purchases that subscribes a user for a week of membership</li> <li>MONTH_PREMIUM - purchases that subscribes a user for a month of membership</li> <li>ADD_TICKET - purchases that allow users to add more tickets</li> <li>ADD_GIFT - purchases that allow users to recieve gifts</li> </ul>") @QueryParam("serviceAction")  String serviceAction,@ApiParam(value = "The keyword used to search") @QueryParam("keyword")  String keyword,@ApiParam(value = "The column to sort the search on. Possible values include: ID, CREATED, UPDATED, ACTIVE, ACTIVATED, EXPIRES, TITLE, SUBTITLE, DETAILS, OFFER_TYPE, SPECIAL_OFFER_TYPE, OFFER_VISIBILITY, ESTIMATED_VALUE, VOUCHER_PRICE, RETAILER_ID, RETAILER_NAME, RETAILER_LOCATION_ID, RETAILER_LOCATION_NAME, BILLABLE_ENTITY_ID, BILLABLE_ENTITY_NAME, RESPONSIBLE_DISPLAY", allowableValues="ID, CREATED, UPDATED, DELETED, SEARCH_TAGS, ACTIVE, NAME, DESCRIPTION, TICKETS, PRICE, PURCHASE_TYPE, PURCHASE_CODE, PURCHASE_LIMIT, SERIVCE_ACTION, GIFTABLE, ASSETABLE, APPLICATION_ID, APPLICATION_NAME", defaultValue = "NAME") @DefaultValue("NAME") @QueryParam("sortField")  String sortField,@ApiParam(value = "The order to return the search results", defaultValue = "false") @DefaultValue("false") @QueryParam("descending")  Boolean descending,@ApiParam(value = "The record to begin the return set on", defaultValue = "0") @DefaultValue("0") @QueryParam("start")  Integer start,@ApiParam(value = "The number of records to return", defaultValue = "20") @DefaultValue("20") @QueryParam("limit")  Integer limit,@ApiParam(value = "Return only active results", defaultValue = "false") @DefaultValue("false") @QueryParam("activeOnly")  Boolean activeOnly,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.searchPurchaseItems(version, deviceId, accountId, appKey, filterByBillable, purchaseType, serviceAction, keyword, sortField, descending, start, limit, activeOnly, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/game/question/search")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Search Questions", notes = "Search for questions by the given params.", response = QuestionResponse.class, responseContainer = "List", tags={ "Question", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = QuestionResponse.class, responseContainer = "List")
    })
    public Response searchQuestions(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The logged in user.", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "The column to sort the search on", required = true) @QueryParam("sortField") @NotNull  String sortField,@ApiParam(value = "The order to return the search results", required = true) @QueryParam("descending") @NotNull  Boolean descending,@ApiParam(value = "Return only active results if set to true.", required = true) @QueryParam("activeOnly") @NotNull  Boolean activeOnly,@ApiParam(value = "The record to begin the return set on.", required = true) @QueryParam("start") @NotNull  Integer start,@ApiParam(value = "The number of records to return.", required = true) @QueryParam("limit") @NotNull  Integer limit,@ApiParam(value = "The keyword for searching questions with matching tags or question text.") @QueryParam("keyword")  String keyword,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.searchQuestions(version, accountId, sortField, descending, activeOnly, start, limit, keyword, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/rating/index/search")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Search Rating Indexes", notes = "Search for ratable items by averages.", response = RatingIndexResponse.class, responseContainer = "List", tags={ "Rating", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = RatingIndexResponse.class, responseContainer = "List")
    })
    public Response searchRatingIndexes(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "Filter results by a ratable type {RETAILER_LOCATION}", required = true, allowableValues="LOCATABLE, RESERVABLE, PERMISSIONABLE, NOTABLE, ASSETABLE, LIKABLE, FLAGABLE, FAVORITABLE, RATABLE, ALBUM, COLLECTION, APPLICATION, APPLICATION_SETTING, APPLICATION_CERT, APPLICATION_PLACEMENT, ACCOUNT, ACCOUNT_SETTING, GAME_LEVEL, PACK, MISSION, TOURNAMENT, ASSET, ALBUM_CONTEST, THEME_DESCRIPTOR, OFFER, OFFER_LOCATION, EVENT, RETAILER, RETAILER_LOCATION, NOTE, CREATIVE, FAVORITE, LIKE, RATING, ANALYTIC, THIRD_PARTY_CREDENTIAL, THIRD_PARTY_NETWORK, REGION") @QueryParam("ratableType") @NotNull  String ratableType,@ApiParam(value = "Comma separated list of ratable ids to filter the resuts by") @QueryParam("ratableIds")  String ratableIds,@ApiParam(value = "Comma separated list of category ids to filter the results by") @QueryParam("categoryIds")  String categoryIds,@ApiParam(value = "") @QueryParam("secondaryType")  String secondaryType,@ApiParam(value = "The keyword used to search") @QueryParam("keyword")  String keyword,@ApiParam(value = "The column to sort the search on {ID, CREATED, UPDATED, ACTIVE, RATABLE_TYPE, RATABLE_ID, RATABLE_DISPLAY, CATEGORY_ID, CATEGORY_NAME, CATEGORY_SHORT_NAME, CATEGORY_DISPLAY, COUNT, SUMMATION, AVERAGE, VALUE}", allowableValues="ID, CREATED, UPDATED, DELETED, SEARCH_TAGS, ACTIVE, RATABLE_TYPE, RATABLE_ID, RATABLE_DISPLAY, CATEGORY_ID, CATEGORY_NAME, CATEGORY_SHORT_NAME, CATEGORY_DISPLAY, COUNT, SUMMATION, AVERAGE, VALUE") @QueryParam("sortField")  String sortField,@ApiParam(value = "The order to return the search results") @QueryParam("descending")  Boolean descending,@ApiParam(value = "The record to begin the return set on") @QueryParam("start")  Integer start,@ApiParam(value = "The number of records to return") @QueryParam("limit")  Integer limit,@ApiParam(value = "") @QueryParam("latitude")  Double latitude,@ApiParam(value = "") @QueryParam("longitude")  Double longitude,@ApiParam(value = "Determines whether to return the ratable object in the response") @QueryParam("returnRatable")  Boolean returnRatable,@ApiParam(value = "Determines whether to return the overall rating record instead") @QueryParam("returnOverallRating")  Boolean returnOverallRating,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.searchRatingIndexes(version, ratableType, ratableIds, categoryIds, secondaryType, keyword, sortField, descending, start, limit, latitude, longitude, returnRatable, returnOverallRating, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/rating/search")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Search Ratings", notes = "Search for ratings on a ratable object.", response = RatingResponse.class, responseContainer = "List", tags={ "Rating", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = RatingResponse.class, responseContainer = "List")
    })
    public Response searchRatings(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The device id (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "The account id of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "Filter results for a particular account") @QueryParam("filterAccountId")  Long filterAccountId,@ApiParam(value = "The ratable object type {RETAILER_LOCATION}") @QueryParam("ratableType")  String ratableType,@ApiParam(value = "The id of the ratable object") @QueryParam("ratableId")  Long ratableId,@ApiParam(value = "Comma separated list of category ids to filter the results by") @QueryParam("categoryIds")  String categoryIds,@ApiParam(value = "The keyword used to search") @QueryParam("keyword")  String keyword,@ApiParam(value = "The column to sort the search on {ID, CREATED, UPDATED, ACTIVE, OWNER_DISPLAY, RATABLE_TYPE, RATABLE_ID, RATABLE_DISPLAY, CATEGORY_ID, CATEGORY_NAME, CATEGORY_SHORT_NAME, CATEGORY_DISPLAY, VALUE}", allowableValues="ID, CREATED, UPDATED, DELETED, SEARCH_TAGS, ACTIVE, OWNER_DISPLAY, RATABLE_TYPE, RATABLE_ID, RATABLE_DISPLAY, CATEGORY_ID, CATEGORY_NAME, CATEGORY_SHORT_NAME, CATEGORY_DISPLAY, VALUE") @QueryParam("sortField")  String sortField,@ApiParam(value = "The order to return the search results") @QueryParam("descending")  Boolean descending,@ApiParam(value = "The record to begin the return set on") @QueryParam("start")  Integer start,@ApiParam(value = "The number of records to return") @QueryParam("limit")  Integer limit,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.searchRatings(version, deviceId, accountId, filterAccountId, ratableType, ratableId, categoryIds, keyword, sortField, descending, start, limit, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/notification/recipient/search")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Search for Recipients", notes = "Search for application users to send notifications.", response = NotificationRecipientResponse.class, responseContainer = "List", tags={ "Notification", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = NotificationRecipientResponse.class, responseContainer = "List")
    })
    public Response searchRecipients(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The field to sort by. Possible values include: {ACCOUNT_DISPLAY, CREATED, UPDATED, ACTIVE, DELETED, LAST_LOGGED_IN, CONTACT_EMAIL, RETAILER_LOCATION_NAME, RETAILER_NAME, APPLICATION_NAME}", required = true, allowableValues="ID, HAS_SMS, HAS_EMAIL, HAS_APNS, HAS_GCM, APPLICATION_ID, APPLICATION_NAME, ACCOUNT_ID, ACCOUNT_USERNAME, ACCOUNT_DISPLAY, ACCOUNT_TYPE") @QueryParam("sortField") @NotNull  String sortField,@ApiParam(value = "the unique id of the device making the request (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "the account id of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "filters results by application. If this is empty, will return all recipients for all applications that the user has access to.") @QueryParam("appKey")  String appKey,@ApiParam(value = "the type of notification to send: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION.") @QueryParam("conduit")  String conduit,@ApiParam(value = "search by keyword on user's display name and email") @QueryParam("keyword")  String keyword,@ApiParam(value = "This parameter is deprecated. filter results by audience") @QueryParam("audienceId")  Long audienceId,@ApiParam(value = "filter results by audiences (comma separated list of audience ids)") @QueryParam("audienceIds")  String audienceIds,@ApiParam(value = "filter results by connection groups (comma separated list of connection group ids)") @QueryParam("connectionGroupIds")  String connectionGroupIds,@ApiParam(value = "filter results by accounts (comma separated list of account ids)") @QueryParam("recipientAccountIds")  String recipientAccountIds,@ApiParam(value = "Determines whether the sorted list is in descending or ascending order") @QueryParam("descending")  Boolean descending,@ApiParam(value = "start of the pagination") @QueryParam("start")  Integer start,@ApiParam(value = "limit of the pagination (hard limit of 1000)") @QueryParam("limit")  Integer limit,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.searchRecipients(version, sortField, deviceId, accountId, appKey, conduit, keyword, audienceId, audienceIds, connectionGroupIds, recipientAccountIds, descending, start, limit, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/notification/recipient/search/count")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Search for Recipients (Counts/Grouped)", notes = "Search for application users to send notifications (count/grouped variant).", response = NotificationRecipientResponseListResponse.class, tags={ "Notification", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = NotificationRecipientResponseListResponse.class)
    })
    public Response searchRecipientsCount(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the unique id of the device making the request (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "the account id of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "filters results by application. If this is empty, will return all recipients for all applications that the user has access to.") @QueryParam("appKey")  String appKey,@ApiParam(value = "the type of notification to send: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION.") @QueryParam("conduit")  String conduit,@ApiParam(value = "search by keyword on user's display name and email") @QueryParam("keyword")  String keyword,@ApiParam(value = "This parameter is deprecated. filter results by audience") @QueryParam("audienceId")  Long audienceId,@ApiParam(value = "filter results by audiences (comma separated list of audience ids)") @QueryParam("audienceIds")  String audienceIds,@ApiParam(value = "filter results by connection groups (comma separated list of connection group ids)") @QueryParam("connectionGroupIds")  String connectionGroupIds,@ApiParam(value = "The field to sort by (see API docs for allowed values).") @QueryParam("sortField")  String sortField,@ApiParam(value = "Determines whether the sorted list is in descending or ascending order") @QueryParam("descending")  Boolean descending,@ApiParam(value = "start of the pagination") @QueryParam("start")  Integer start,@ApiParam(value = "limit of the pagination") @QueryParam("limit")  Integer limit,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.searchRecipientsCount(version, deviceId, accountId, appKey, conduit, keyword, audienceId, audienceIds, connectionGroupIds, sortField, descending, start, limit, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/region/search")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Search Regions", notes = "Get the list of regions.", response = RegionResponse.class, responseContainer = "List", tags={ "Region", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = RegionResponse.class, responseContainer = "List")
    })
    public Response searchRegions(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the owner account id of the region to be created") @QueryParam("accountId")  Long accountId,@ApiParam(value = "This parameter is deprecated. deprecated - use \"keyword\"") @QueryParam("query")  String query,@ApiParam(value = "the keyword to filter results on") @QueryParam("keyword")  String keyword,@ApiParam(value = "the latitude of the user") @QueryParam("latitude")  Double latitude,@ApiParam(value = "the longitude of the user") @QueryParam("longitude")  Double longitude,@ApiParam(value = "the search radius") @QueryParam("range")  Double range,@ApiParam(value = "", allowableValues="NATIONAL, STATE, COUNTY, METRO_AREA, CITY, NEIGHBORHOOD, TERRITORY, CUSTOM, ZONE") @QueryParam("regionClass")  String regionClass,@ApiParam(value = "", allowableValues="PUBLIC, PRIVATE, FRIENDS") @QueryParam("visibility")  String visibility,@ApiParam(value = "the SearchIndexMode: RDS, LUCENE, or CLOUDINDEX. If not provided, will use the default defined in the Sirqul server", allowableValues="RDS, LUCENE, CLOUDINDEX") @QueryParam("searchMode")  String searchMode,@ApiParam(value = "the field to order results by: ID, UPDATED, NAME, or DISTANCE. If not provided, will use the default which is by ID for text and DISTANCE when lat/long is provided.", allowableValues="ID, UPDATED, NAME, DISTANCE") @QueryParam("sortField")  String sortField,@ApiParam(value = "determines if the results get ordered in descending order") @QueryParam("descending")  Boolean descending,@ApiParam(value = "include the parent region or not") @QueryParam("includeParent")  Boolean includeParent,@ApiParam(value = "include the chidren regions or not") @QueryParam("includeChildren")  Boolean includeChildren,@ApiParam(value = "include the postal codes associated with the region or not") @QueryParam("includePostalCodes")  Boolean includePostalCodes,@ApiParam(value = "search on the categories associated with the region") @QueryParam("categoryIds")  String categoryIds,@ApiParam(value = "search on the filters associated with the region") @QueryParam("filterIds")  String filterIds,@ApiParam(value = "filter by a specific version code") @QueryParam("versionCode")  Integer versionCode,@ApiParam(value = "filter to show only active results") @QueryParam("activeOnly")  Boolean activeOnly,@ApiParam(value = "If showDeleted is true and activeOnly is false, will return regions that have been deleted") @QueryParam("showDeleted")  Boolean showDeleted,@ApiParam(value = "only returns records that have last updated since this date \\(UTC timestamp in milliseconds\\)") @QueryParam("lastUpdatedSince")  Long lastUpdatedSince,@ApiParam(value = "the start index for pagination") @QueryParam("start")  Integer start,@ApiParam(value = "the limit for pagination") @QueryParam("limit")  Integer limit,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.searchRegions(version, accountId, query, keyword, latitude, longitude, range, regionClass, visibility, searchMode, sortField, descending, includeParent, includeChildren, includePostalCodes, categoryIds, filterIds, versionCode, activeOnly, showDeleted, lastUpdatedSince, start, limit, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/reservation/search")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Search Reservations", notes = "", response = ReservationResponse.class, responseContainer = "List", tags={ "Reservation", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = ReservationResponse.class, responseContainer = "List")
    })
    public Response searchReservations(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "Device Id") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "Appilcation Key") @QueryParam("appKey")  String appKey,@ApiParam(value = "the id of the logged in user") @QueryParam("accountId")  Long accountId,@ApiParam(value = "filter reservations by account ID") @QueryParam("filterAccountId")  Long filterAccountId,@ApiParam(value = "the reservation ID") @QueryParam("reservableId")  Long reservableId,@ApiParam(value = "the type of reservation", allowableValues="LOCATABLE, RESERVABLE, PERMISSIONABLE, NOTABLE, ASSETABLE, LIKABLE, FLAGABLE, FAVORITABLE, RATABLE, ALBUM, COLLECTION, APPLICATION, APPLICATION_SETTING, APPLICATION_CERT, APPLICATION_PLACEMENT, ACCOUNT, ACCOUNT_SETTING, GAME_LEVEL, PACK, MISSION, TOURNAMENT, ASSET, ALBUM_CONTEST, THEME_DESCRIPTOR, OFFER, OFFER_LOCATION, EVENT, RETAILER, RETAILER_LOCATION, NOTE, CREATIVE, FAVORITE, LIKE, RATING, ANALYTIC, THIRD_PARTY_CREDENTIAL, THIRD_PARTY_NETWORK, REGION") @QueryParam("reservableType")  String reservableType,@ApiParam(value = "the keyword to search the reservation on") @QueryParam("keyword")  String keyword,@ApiParam(value = "the start date of the reservation search") @QueryParam("startDate")  Long startDate,@ApiParam(value = "the end date of the reservation search") @QueryParam("endDate")  Long endDate,@ApiParam(value = "the start of the index and/or pagination", defaultValue = "0") @DefaultValue("0") @QueryParam("start")  Integer start,@ApiParam(value = "the limit of the index and/or pagination", defaultValue = "100") @DefaultValue("100") @QueryParam("limit")  Integer limit,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.searchReservations(version, deviceId, appKey, accountId, filterAccountId, reservableId, reservableType, keyword, startDate, endDate, start, limit, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/retailer/location/search")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Search Retailer Locations (Owned)", notes = "Searches on retailer locations that the account has access to.", response = RetailerLocationResponse.class, responseContainer = "List", tags={ "Retailer Location", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = RetailerLocationResponse.class, responseContainer = "List")
    })
    public Response searchRetailerLocations(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The device id (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "The account id of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "This parameter is deprecated.") @QueryParam("q")  String q,@ApiParam(value = "The keyword used to search") @QueryParam("keyword")  String keyword,@ApiParam(value = "Comma separated list of retailer IDs which when passed in will filter the results to only return these retailers.") @QueryParam("retailerIds")  String retailerIds,@ApiParam(value = "Comma separated list of retailer location IDs") @QueryParam("retailerLocationIds")  String retailerLocationIds,@ApiParam(value = "Location type filter") @QueryParam("locationType")  String locationType,@ApiParam(value = "The column to sort the search on", allowableValues="ID, CREATED, UPDATED, DELETED, SEARCH_TAGS, ACTIVE, RETAILER_ID, BILLABLE_ENTITY_ID, BILLABLE_ENTITY_NAME, RESPONSIBLE_DISPLAY, ADDRESS_STREET, ADDRESS_CITY, ADDRESS_STATE, ADDRESS_POSTAL_CODE, ADDRESS_COUNTRY, NAME, CODE") @QueryParam("sortField")  String sortField,@ApiParam(value = "The order to return the search results") @QueryParam("descending")  Boolean descending,@ApiParam(value = "This parameter is deprecated.") @QueryParam("_i")  Integer i,@ApiParam(value = "The record to begin the return set on") @QueryParam("start")  Integer start,@ApiParam(value = "This parameter is deprecated.") @QueryParam("_l")  Integer l,@ApiParam(value = "The number of records to return") @QueryParam("limit")  Integer limit,@ApiParam(value = "Whether to include public locations in the results") @QueryParam("showPublicLocations")  Boolean showPublicLocations,@ApiParam(value = "Return only active results") @QueryParam("activeOnly")  Boolean activeOnly,@ApiParam(value = "Return retailer info") @QueryParam("returnRetailer")  Boolean returnRetailer,@ApiParam(value = "Return assets") @QueryParam("returnAssets")  Boolean returnAssets,@ApiParam(value = "Return offers") @QueryParam("returnOffers")  Boolean returnOffers,@ApiParam(value = "Return categories") @QueryParam("returnCategories")  Boolean returnCategories,@ApiParam(value = "Return filters") @QueryParam("returnFilters")  Boolean returnFilters,@ApiParam(value = "Return audiences") @QueryParam("returnAudiences")  Boolean returnAudiences,@ApiParam(value = "Return QR code info") @QueryParam("returnQrCode")  Boolean returnQrCode,@ApiParam(value = "Include favorites in response") @QueryParam("includeFavorite")  Boolean includeFavorite,@ApiParam(value = "Include liked flag in response") @QueryParam("includeLiked")  Boolean includeLiked,@ApiParam(value = "Include rating info in response") @QueryParam("includeRating")  Boolean includeRating,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.searchRetailerLocations(version, deviceId, accountId, q, keyword, retailerIds, retailerLocationIds, locationType, sortField, descending, i, start, l, limit, showPublicLocations, activeOnly, returnRetailer, returnAssets, returnOffers, returnCategories, returnFilters, returnAudiences, returnQrCode, includeFavorite, includeLiked, includeRating, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/tournament/round/search")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Search Tournament Rounds", notes = "Search for the user's tournament games.", response = SirqulResponse.class, tags={ "Tournament", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response searchRounds(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the account ID", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "the application key", required = true) @QueryParam("appKey") @NotNull  String appKey,@ApiParam(value = "comma separated list of statuses to filter results by", defaultValue = "ACCEPTED,ACTIVE") @DefaultValue("ACCEPTED,ACTIVE") @QueryParam("status")  String status,@ApiParam(value = "The style of tournament to search for, options are: TOURNAMENT, POOLPLAY", allowableValues="TOURNAMENT, POOLPLAY") @QueryParam("missionType")  String missionType,@ApiParam(value = "search for games that are flagged current only", defaultValue = "true") @DefaultValue("true") @QueryParam("currentOnly")  Boolean currentOnly,@ApiParam(value = "Filter tournament rounds by the mission visibility flag", defaultValue = "PUBLIC") @DefaultValue("PUBLIC") @QueryParam("visibilities")  String visibilities,@ApiParam(value = "the start index for pagination", defaultValue = "0") @DefaultValue("0") @QueryParam("start")  Integer start,@ApiParam(value = "the limit for pagination", defaultValue = "20") @DefaultValue("20") @QueryParam("limit")  Integer limit,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.searchRounds(version, accountId, appKey, status, missionType, currentOnly, visibilities, start, limit, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/route/setting")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Search Route Settings", notes = "Search for route settings", response = RouteSettings.class, responseContainer = "List", tags={ "Route Setting", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = RouteSettings.class, responseContainer = "List")
    })
    public Response searchRouteSettings(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The field to sort by", required = true) @QueryParam("sortField") @NotNull  String sortField,@ApiParam(value = "Determines whether the sorted list is in descending or ascending order", required = true) @QueryParam("descending") @NotNull  Boolean descending,@ApiParam(value = "The start index for pagination", required = true) @QueryParam("start") @NotNull  Integer start,@ApiParam(value = "The limit for pagination", required = true) @QueryParam("limit") @NotNull  Integer limit,@ApiParam(value = "Return only active results", required = true) @QueryParam("activeOnly") @NotNull  Boolean activeOnly,@ApiParam(value = "The service hub that the route belongs under") @QueryParam("hubId")  Long hubId,@ApiParam(value = "The program that the route belongs under") @QueryParam("programId")  Long programId,@ApiParam(value = "The keyword to search for the route") @QueryParam("keyword")  String keyword,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.searchRouteSettings(version, sortField, descending, start, limit, activeOnly, hubId, programId, keyword, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/route")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Search Routes", notes = "Search for routes.", response = Route.class, responseContainer = "List", tags={ "Route", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = Route.class, responseContainer = "List")
    })
    public Response searchRoutes(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The field to sort by", required = true) @QueryParam("sortField") @NotNull  String sortField,@ApiParam(value = "Determines whether the sorted list is in descending or ascending order", required = true) @QueryParam("descending") @NotNull  Boolean descending,@ApiParam(value = "The start index for pagination", required = true) @QueryParam("start") @NotNull  Integer start,@ApiParam(value = "The limit for pagination", required = true) @QueryParam("limit") @NotNull  Integer limit,@ApiParam(value = "Return only active results", required = true) @QueryParam("activeOnly") @NotNull  Boolean activeOnly,@ApiParam(value = "Include empty routes or not", required = true) @QueryParam("includesEmpty") @NotNull  Boolean includesEmpty,@ApiParam(value = "Only return root instance routes", required = true) @QueryParam("rootOnly") @NotNull  Boolean rootOnly,@ApiParam(value = "Display root route properties", required = true) @QueryParam("showInheritedProperties") @NotNull  Boolean showInheritedProperties,@ApiParam(value = "Filter results by service hub") @QueryParam("hubId")  Long hubId,@ApiParam(value = "Filter results by program") @QueryParam("programId")  Long programId,@ApiParam(value = "The start date to filter the results by") @QueryParam("scheduledStart")  Long scheduledStart,@ApiParam(value = "The end date to filter the results by") @QueryParam("scheduledEnd")  Long scheduledEnd,@ApiParam(value = "The lower bound of updated date") @QueryParam("updatedStart")  Long updatedStart,@ApiParam(value = "The upper bound of updated date") @QueryParam("updatedEnd")  Long updatedEnd,@ApiParam(value = "The route is featured or not") @QueryParam("featured")  Boolean featured,@ApiParam(value = "Has at least this many seat available") @QueryParam("seatCount")  Integer seatCount,@ApiParam(value = "Has been approved or not") @QueryParam("approved")  Boolean approved,@ApiParam(value = "Has started or not") @QueryParam("started")  Boolean started,@ApiParam(value = "Has completed or not") @QueryParam("completed")  Boolean completed,@ApiParam(value = "Is valid or not") @QueryParam("valid")  Boolean valid,@ApiParam(value = "If it is a recurring route based on the parent route") @QueryParam("parentId")  Long parentId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.searchRoutes(version, sortField, descending, start, limit, activeOnly, includesEmpty, rootOnly, showInheritedProperties, hubId, programId, scheduledStart, scheduledEnd, updatedStart, updatedEnd, featured, seatCount, approved, started, completed, valid, parentId, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/reservable/schedule/search")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Search Schedule", notes = "", response = TimeSlotResponse.class, responseContainer = "List", tags={ "Reservation", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = TimeSlotResponse.class, responseContainer = "List")
    })
    public Response searchSchedule(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the id of the reservation", required = true) @QueryParam("reservableId") @NotNull  Long reservableId,@ApiParam(value = "the reservation type", required = true, allowableValues="LOCATABLE, RESERVABLE, PERMISSIONABLE, NOTABLE, ASSETABLE, LIKABLE, FLAGABLE, FAVORITABLE, RATABLE, ALBUM, COLLECTION, APPLICATION, APPLICATION_SETTING, APPLICATION_CERT, APPLICATION_PLACEMENT, ACCOUNT, ACCOUNT_SETTING, GAME_LEVEL, PACK, MISSION, TOURNAMENT, ASSET, ALBUM_CONTEST, THEME_DESCRIPTOR, OFFER, OFFER_LOCATION, EVENT, RETAILER, RETAILER_LOCATION, NOTE, CREATIVE, FAVORITE, LIKE, RATING, ANALYTIC, THIRD_PARTY_CREDENTIAL, THIRD_PARTY_NETWORK, REGION") @QueryParam("reservableType") @NotNull  String reservableType,@ApiParam(value = "the start date of the reservation", required = true) @QueryParam("startDate") @NotNull  Long startDate,@ApiParam(value = "the end date of the reservation", required = true) @QueryParam("endDate") @NotNull  Long endDate,@ApiParam(value = "the id of the device that the reservation is on") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "the id of the logged in user") @QueryParam("accountId")  Long accountId,@ApiParam(value = "the length of time in minutes to search on for reservation", defaultValue = "30") @DefaultValue("30") @QueryParam("timeBucketMins")  Integer timeBucketMins,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.searchSchedule(version, reservableId, reservableType, startDate, endDate, deviceId, accountId, timeBucketMins, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/notification/schedule/search")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Search Scheduled Notifications", notes = "This endpoint searches on Scheduled Notifications. If a scheduled notification was created with the visibility parameter set to PUBLIC, then anyone can search on it if the filter parameter includes the PUBLIC value. PRIVATE visibility means that it can only be searched on by the owner or if it has been shared to the user using the UserPermissionsApi.  In addition, if a PUBLIC Scheduled Notification was created for an application that requires content approval (using the publicContentApproval parameter), then an administrator of the application needs to approve it before it can be search on by other users. Before this happens, it is in a PENDING state, and only the original creator or the owner of the application can search and see it. Also, only the owner of the application can use the UserPermissionsApi to approve or reject it. Scheduled notifications that have been rejected are only visible to the original creators.", response = ScheduledNotificationFullResponse.class, tags={ "Scheduled Notification", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = ScheduledNotificationFullResponse.class)
    })
    public Response searchScheduledNotifications(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The logged in user.", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "Filter results by a grouping identifier defined by the client") @QueryParam("groupingId")  String groupingId,@ApiParam(value = "Filter results by audience") @QueryParam("audienceId")  Long audienceId,@ApiParam(value = "a comma separated list of filters: MINE - Return scheduled notifications that the user has created. SHARED - Return scheduled notifications that have been shared to the user via addUsersToPermissionable. FOLLOWER - Return scheduled notifications that have been created by the users followers (the content needs to have been APPROVED or FEATURED). FOLLOWING - Return scheduled notifications that have been created by people who the user is following (the content needs to have been APPROVED or FEATURED). PUBLIC - Return all PUBLIC scheduled notifications that have been APPROVED or FEATURED. ALL_PUBLIC - Return all PUBLIC scheduled notifications regardless of whether they are approved or not (ignores the approval status). LIKED - Return all scheduled notifications that the user has liked. FEATURED - Return all scheduled notifications that have been featured. PENDING - Return all pending scheduled notifications.") @QueryParam("filter")  String filter,@ApiParam(value = "Filter results by notification types (comma separated list). Values include: HTTP, EMAIL, SMS, MOBILE_NOTIFICATION") @QueryParam("types")  String types,@ApiParam(value = "search using content IDs") @QueryParam("contentIds")  String contentIds,@ApiParam(value = "search using content types") @QueryParam("contentTypes")  String contentTypes,@ApiParam(value = "search using parent IDs") @QueryParam("parentIds")  String parentIds,@ApiParam(value = "search using parent types") @QueryParam("parentTypes")  String parentTypes,@ApiParam(value = "Filter results by status (comma separated list). Possible values include: NEW - scheduled to run ERROR - encountered an error during processing COMPLETE - processing has completed and it is no longer scheduled to run PROCESSING - currently processing/sending") @QueryParam("statuses")  String statuses,@ApiParam(value = "") @QueryParam("templateTypes")  String templateTypes,@ApiParam(value = "Filter the list by a specific application") @QueryParam("appKey")  String appKey,@ApiParam(value = "Keyword search on the scheduled notification names.") @QueryParam("keyword")  String keyword,@ApiParam(value = "The field to sort by. Possible values include: ID - order by the scheduledNotificationId CREATED - order by the timestamp it was created UPDATED - order by the timestamp it was last updated ACTIVE - order by whether it is active or inactive NAME - order by the scheduled notification name SCHEDULED_DATE - order by the next scheduled date START_DATE - order by the start date END_DATE - order by the end date") @QueryParam("sortField")  String sortField,@ApiParam(value = "Determines whether the sorted list is in descending or ascending order") @QueryParam("descending")  Boolean descending,@ApiParam(value = "Start the result set at some index.") @QueryParam("start")  Integer start,@ApiParam(value = "Limit the result to some number.") @QueryParam("limit")  Integer limit,@ApiParam(value = "Determines whether to return only active results") @QueryParam("activeOnly")  Boolean activeOnly,@ApiParam(value = "Determines whether to group results with the same groupingId together.") @QueryParam("groupByGroupingId")  Boolean groupByGroupingId,@ApiParam(value = "If true, include audience account counts in the response") @QueryParam("returnAudienceAccountCount")  Boolean returnAudienceAccountCount,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.searchScheduledNotifications(version, accountId, groupingId, audienceId, filter, types, contentIds, contentTypes, parentIds, parentTypes, statuses, templateTypes, appKey, keyword, sortField, descending, start, limit, activeOnly, groupByGroupingId, returnAudienceAccountCount, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/score/search")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Search Score", notes = "Search the scores for an item.  Pass in the full path IDs for the scores.", response = ScoreResponse.class, responseContainer = "List", tags={ "Score", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = ScoreResponse.class, responseContainer = "List")
    })
    public Response searchScores(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The logged in user.", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "The game application key to get the level for.", required = true) @QueryParam("appKey") @NotNull  String appKey,@ApiParam(value = "The missionId to score for, null if not playing mission.") @QueryParam("missionId")  Long missionId,@ApiParam(value = "The gameId to score for, null if not playing mission.") @QueryParam("gameId")  Long gameId,@ApiParam(value = "The packId to score for, null if playing community levels.") @QueryParam("packId")  Long packId,@ApiParam(value = "The gameLevelId to score for.") @QueryParam("gameLevelId")  Long gameLevelId,@ApiParam(value = "The gameObjectId to score for, null if level based scoring.") @QueryParam("gameObjectId")  Long gameObjectId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.searchScores(version, accountId, appKey, missionId, gameId, packId, gameLevelId, gameObjectId, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/hub")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Search Service Hubs", notes = "Search for service hubs.", response = ServiceHub.class, responseContainer = "List", tags={ "Service Hub", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = ServiceHub.class, responseContainer = "List")
    })
    public Response searchServiceHubs(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The field to sort by", required = true) @QueryParam("sortField") @NotNull  String sortField,@ApiParam(value = "Determines whether the sorted list is in descending or ascending order", required = true) @QueryParam("descending") @NotNull  Boolean descending,@ApiParam(value = "The start index for pagination", required = true) @QueryParam("start") @NotNull  Integer start,@ApiParam(value = "The limit for pagination", required = true) @QueryParam("limit") @NotNull  Integer limit,@ApiParam(value = "Return only active results", required = true) @QueryParam("activeOnly") @NotNull  Boolean activeOnly,@ApiParam(value = "The keyword to search for") @QueryParam("keyword")  String keyword,@ApiParam(value = "The retailer belongs to") @QueryParam("retailerId")  Long retailerId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.searchServiceHubs(version, sortField, descending, start, limit, activeOnly, keyword, retailerId, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/shipment/batch")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Search Shipment Batch", notes = "Search for shipment batches", response = ShipmentBatch.class, responseContainer = "List", tags={ "Shipment Batch", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = ShipmentBatch.class, responseContainer = "List")
    })
    public Response searchShipmentBatch(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The associated service hub", required = true) @QueryParam("hubId") @NotNull  Long hubId,@ApiParam(value = "The field to sort by", required = true) @QueryParam("sortField") @NotNull  String sortField,@ApiParam(value = "Determines whether the sorted list is in descending or ascending order", required = true) @QueryParam("descending") @NotNull  Boolean descending,@ApiParam(value = "The start index for pagination", required = true) @QueryParam("start") @NotNull  Integer start,@ApiParam(value = "The limit for pagination", required = true) @QueryParam("limit") @NotNull  Integer limit,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.searchShipmentBatch(version, hubId, sortField, descending, start, limit, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/shipment")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Search Shipments", notes = "Search for shipments", response = Shipment.class, responseContainer = "List", tags={ "Shipment", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = Shipment.class, responseContainer = "List")
    })
    public Response searchShipments(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The field to sort by", required = true) @QueryParam("sortField") @NotNull  String sortField,@ApiParam(value = "Determines whether the sorted list is in descending or ascending order", required = true) @QueryParam("descending") @NotNull  Boolean descending,@ApiParam(value = "The start index for pagination", required = true) @QueryParam("start") @NotNull  Integer start,@ApiParam(value = "The limit for pagination", required = true) @QueryParam("limit") @NotNull  Integer limit,@ApiParam(value = "Return only active results", required = true) @QueryParam("activeOnly") @NotNull  Boolean activeOnly,@ApiParam(value = "The owner of the shipment") @QueryParam("ownerId")  Long ownerId,@ApiParam(value = "The rider associate to this shipment") @QueryParam("riderId")  Long riderId,@ApiParam(value = "The route associate to this shipment") @QueryParam("routeId")  Long routeId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.searchShipments(version, sortField, descending, start, limit, activeOnly, ownerId, riderId, routeId, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/task/search")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Search Tasks", notes = "Search on Tasks", response = TaskResponse.class, responseContainer = "List", tags={ "Task", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = TaskResponse.class, responseContainer = "List")
    })
    public Response searchTasks(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The logged in user.", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "Filter results by a grouping identifier defined by the client") @QueryParam("groupingId")  String groupingId,@ApiParam(value = "A comma separated list of filters:  * MINE - Return tasks that the user has created * SHARED - Return tasks that have been shared to the user * FOLLOWER - Return tasks that have been created by the user''s followers (the content needs to have been APPROVED or FEATURED) * FOLLOWING - Return tasks that have been created by people who the user is following (the content needs to have been APPROVED or FEATURED) * PUBLIC - Return all PUBLIC tasks that have been APPROVED or FEATURED * ALL_PUBLIC - Return all PUBLIC tasks regardless of whether they are approved or not (ignores the approval status) * LIKED - Return all tasks that the user has liked * FEATURED - Return all tasks that have been featured * PENDING - Return all pending tasks ", defaultValue = "MINE") @DefaultValue("MINE") @QueryParam("filter")  String filter,@ApiParam(value = "Filter results by status (comma separated list). Values include: NEW, ERROR, COMPLETE, PROCESSING, TEMPLATE", defaultValue = "NEW,ERROR,COMPLETE,PROCESSING") @DefaultValue("NEW,ERROR,COMPLETE,PROCESSING") @QueryParam("statuses")  String statuses,@ApiParam(value = "Template Types") @QueryParam("templateTypes")  String templateTypes,@ApiParam(value = "Filter the list by a specific application") @QueryParam("appKey")  String appKey,@ApiParam(value = "Keyword search on the task names.") @QueryParam("keyword")  String keyword,@ApiParam(value = "The field to sort by. Possible values include: ID, CREATED, UPDATED, ACTIVE, NAME, SCHEDULED_DATE, START_DATE, END_DATE", defaultValue = "CREATED") @DefaultValue("CREATED") @QueryParam("sortField")  String sortField,@ApiParam(value = "Determines whether the sorted list is in descending or ascending order", defaultValue = "true") @DefaultValue("true") @QueryParam("descending")  Boolean descending,@ApiParam(value = "Start the result set at some index.", defaultValue = "0") @DefaultValue("0") @QueryParam("start")  Integer start,@ApiParam(value = "Limit the result to some number.", defaultValue = "20") @DefaultValue("20") @QueryParam("limit")  Integer limit,@ApiParam(value = "Determines whether to return only active results", defaultValue = "true") @DefaultValue("true") @QueryParam("activeOnly")  Boolean activeOnly,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.searchTasks(version, accountId, groupingId, filter, statuses, templateTypes, appKey, keyword, sortField, descending, start, limit, activeOnly, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/territory/search")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Search Territories", notes = "Searches on territories.", response = TerritoryResponse.class, responseContainer = "List", tags={ "Territory", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = TerritoryResponse.class, responseContainer = "List")
    })
    public Response searchTerritories(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the field to sort by. Supported values include: ID, CREATED, UPDATED, NAME", required = true, allowableValues="ID, UPDATED, CREATED, NAME") @QueryParam("sortField") @NotNull  String sortField,@ApiParam(value = "determines whether the sorted list is in descending or ascending order", required = true) @QueryParam("descending") @NotNull  Boolean descending,@ApiParam(value = "Return results that match this keyword.") @QueryParam("keyword")  String keyword,@ApiParam(value = "The start index for pagination") @QueryParam("start")  Integer start,@ApiParam(value = "The limit for pagination") @QueryParam("limit")  Integer limit,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.searchTerritories(version, sortField, descending, keyword, start, limit, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/tournament/search")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Search Tournaments", notes = "Search for tournaments", response = MissionShortResponse.class, tags={ "Tournament", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = MissionShortResponse.class)
    })
    public Response searchTournaments(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The logged in user.", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "The application key", required = true) @QueryParam("appKey") @NotNull  String appKey,@ApiParam(value = "the keyword to search tournament on") @QueryParam("keyword")  String keyword,@ApiParam(value = "filter results by subType") @QueryParam("subType")  String subType,@ApiParam(value = "whether to include inactives in the search or not", defaultValue = "false") @DefaultValue("false") @QueryParam("includeInactive")  Boolean includeInactive,@ApiParam(value = "comma separated list of mission types to filter results, possbile values include: TOURNAMENT, POOLPLAY, MULTISTAGE", defaultValue = "MULTISTAGE,TOURNAMENT,POOLPLAY") @DefaultValue("MULTISTAGE,TOURNAMENT,POOLPLAY") @QueryParam("missionTypes")  String missionTypes,@ApiParam(value = "filter tournaments by the tournament's current state", allowableValues="ALL, UPCOMING, PAST, PRESENT, ACTIVE", defaultValue = "UPCOMING") @DefaultValue("UPCOMING") @QueryParam("filter")  String filter,@ApiParam(value = "which field to sort on", allowableValues="ACTIVE, TITLE, DESCRIPTION, CREATED, UPDATED, MISSION_TYPE, OWNER_DISPLAY, START_DATE, END_DATE, STARTING_LIMIT, AVAILABLE_LIMIT, INVITE_COUNT, ACCEPTED_COUNT", defaultValue = "START_DATE") @DefaultValue("START_DATE") @QueryParam("sortField")  String sortField,@ApiParam(value = "Determines whether to return results in descending order. The default value will be true if the filter is \"PAST\", otherwise the default value will be false.") @QueryParam("descending")  Boolean descending,@ApiParam(value = "Comma separated list of visibility flags for search for, possible values include: PUBLIC, LISTABLE, REWARDABLE, TRIGGERABLE, PRIVATE", defaultValue = "PUBLIC") @DefaultValue("PUBLIC") @QueryParam("visibility")  String visibility,@ApiParam(value = "Start the result set at some index.", defaultValue = "0") @DefaultValue("0") @QueryParam("start")  Integer start,@ApiParam(value = "Limit the result to some number", defaultValue = "20") @DefaultValue("20") @QueryParam("limit")  Integer limit,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.searchTournaments(version, accountId, appKey, keyword, subType, includeInactive, missionTypes, filter, sortField, descending, visibility, start, limit, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/tracking/searchByBillable")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Search Tracking (Billable)", notes = "Retrieve tracking data for billable/account scoped queries.", response = LegResponse.class, responseContainer = "List", tags={ "Tracking", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = LegResponse.class, responseContainer = "List")
    })
    public Response searchTrackingLegs(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The account id to search tracking for", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "The application key", required = true) @QueryParam("appKey") @NotNull  String appKey,@ApiParam(value = "The id of the tracking device") @QueryParam("trackingDeviceId")  String trackingDeviceId,@ApiParam(value = "The start date in (UTC milliseconds) to filter the tracking results") @QueryParam("startDate")  Long startDate,@ApiParam(value = "The end date in (UTC milliseconds) to filter the tracking results") @QueryParam("endDate")  Long endDate,@ApiParam(value = "Filter results by tag") @QueryParam("tags")  String tags,@ApiParam(value = "The start index for pagination", defaultValue = "0") @DefaultValue("0") @QueryParam("start")  Integer start,@ApiParam(value = "The limit for pagination", defaultValue = "100") @DefaultValue("100") @QueryParam("limit")  Integer limit,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.searchTrackingLegs(version, accountId, appKey, trackingDeviceId, startDate, endDate, tags, start, limit, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/trigger/search")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Search Triggers", notes = "Search for triggers", response = TriggerResponse.class, responseContainer = "List", tags={ "Trigger", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = TriggerResponse.class, responseContainer = "List")
    })
    public Response searchTriggers(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The logged in user.", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "Filter results by a grouping identifier defined by the client") @QueryParam("groupingId")  String groupingId,@ApiParam(value = "A comma separated list of filters. * MINE - Return triggers that the user has created * SHARED - Return triggers that have been shared to the user * FOLLOWER - Return triggers that have been created by the user''s followers (the content needs to have been APPROVED or FEATURED) * FOLLOWING - Return triggers that have been created by people who the user is following (the content needs to have been APPROVED or FEATURED) * PUBLIC - Return all PUBLIC triggers that have been APPROVED or FEATURED * ALL_PUBLIC - Return all PUBLIC triggers regardless of whether they are approved or not (ignores the approval status) * LIKED - Return all triggers that the user has liked * FEATURED - Return all triggers that have been featured * PENDING - Return all pending triggers ", defaultValue = "MINE") @DefaultValue("MINE") @QueryParam("filter")  String filter,@ApiParam(value = "Filter results by status (comma separated list). Values include: NEW, ERROR, COMPLETE, PROCESSING, TEMPLATE", defaultValue = "NEW,ERROR,COMPLETE,PROCESSING") @DefaultValue("NEW,ERROR,COMPLETE,PROCESSING") @QueryParam("statuses")  String statuses,@ApiParam(value = "Template Types") @QueryParam("templateTypes")  String templateTypes,@ApiParam(value = "Filter the list by a specific application") @QueryParam("appKey")  String appKey,@ApiParam(value = "Keyword search on the trigger names.") @QueryParam("keyword")  String keyword,@ApiParam(value = "The field to sort by. Possible values include: ID, CREATED, UPDATED, ACTIVE, NAME, SCHEDULED_DATE, START_DATE, END_DATE", defaultValue = "CREATED") @DefaultValue("CREATED") @QueryParam("sortField")  String sortField,@ApiParam(value = "Determines whether the sorted list is in descending or ascending order", defaultValue = "true") @DefaultValue("true") @QueryParam("descending")  Boolean descending,@ApiParam(value = "Start the result set at some index.", defaultValue = "0") @DefaultValue("0") @QueryParam("start")  Integer start,@ApiParam(value = "Limit the result to some number.", defaultValue = "20") @DefaultValue("20") @QueryParam("limit")  Integer limit,@ApiParam(value = "Determines whether to return only active results", defaultValue = "true") @DefaultValue("true") @QueryParam("activeOnly")  Boolean activeOnly,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.searchTriggers(version, accountId, groupingId, filter, statuses, templateTypes, appKey, keyword, sortField, descending, start, limit, activeOnly, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/trip/match")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Search Trips", notes = "Search for trips with matching information.", response = Trip.class, responseContainer = "List", tags={ "Trip", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = Trip.class, responseContainer = "List")
    })
    public Response searchTrips(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The owner of the trips", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "The field to sort by", required = true) @QueryParam("sortField") @NotNull  String sortField,@ApiParam(value = "Determines whether the sorted list is in descending or ascending order", required = true) @QueryParam("descending") @NotNull  Boolean descending,@ApiParam(value = "The start index for pagination", required = true) @QueryParam("start") @NotNull  Integer start,@ApiParam(value = "The limit for pagination", required = true) @QueryParam("limit") @NotNull  Integer limit,@ApiParam(value = "Return only active results", required = true) @QueryParam("activeOnly") @NotNull  Boolean activeOnly,@ApiParam(value = "The lower bound limit of time") @QueryParam("startDate")  Long startDate,@ApiParam(value = "The upper bound limit of time") @QueryParam("endDate")  Long endDate,@ApiParam(value = "Only return matchings that already have route assigned") @QueryParam("matchedHasRoute")  Boolean matchedHasRoute,@ApiParam(value = "Only return matchings that already have driver assigned") @QueryParam("matchedHasDriver")  Boolean matchedHasDriver,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.searchTrips(version, accountId, sortField, descending, start, limit, activeOnly, startDate, endDate, matchedHasRoute, matchedHasDriver, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/vehicle")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Search Vehicle", notes = "Search for vehicles", response = Vehicle.class, responseContainer = "List", tags={ "Vehicle", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = Vehicle.class, responseContainer = "List")
    })
    public Response searchVehicle(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "Filter by service hub", required = true) @QueryParam("hubId") @NotNull  Long hubId,@ApiParam(value = "The field to sort by", required = true, defaultValue = "id") @DefaultValue("id") @QueryParam("sortField") @NotNull  String sortField,@ApiParam(value = "Determines whether the sorted list is in descending or ascending order", required = true, defaultValue = "false") @DefaultValue("false") @QueryParam("descending") @NotNull  Boolean descending,@ApiParam(value = "The start index for pagination", required = true, defaultValue = "0") @DefaultValue("0") @QueryParam("start") @NotNull  Integer start,@ApiParam(value = "The limit for pagination", required = true, defaultValue = "20") @DefaultValue("20") @QueryParam("limit") @NotNull  Integer limit,@ApiParam(value = "Return only active results", required = true, defaultValue = "true") @DefaultValue("true") @QueryParam("activeOnly") @NotNull  Boolean activeOnly,@ApiParam(value = "The keyword to search for") @QueryParam("keyword")  String keyword,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.searchVehicle(version, hubId, sortField, descending, start, limit, activeOnly, keyword, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/vehicle/type")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Search Vehicle Type", notes = "Search for types of vehicles", response = VehicleType.class, responseContainer = "List", tags={ "Vehicle Type", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = VehicleType.class, responseContainer = "List")
    })
    public Response searchVehicleTypes(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The field to sort by", required = true, defaultValue = "id") @DefaultValue("id") @QueryParam("sortField") @NotNull  String sortField,@ApiParam(value = "Determines whether the sorted list is in descending or ascending order", required = true, defaultValue = "false") @DefaultValue("false") @QueryParam("descending") @NotNull  Boolean descending,@ApiParam(value = "The start index for pagination", required = true, defaultValue = "0") @DefaultValue("0") @QueryParam("start") @NotNull  Integer start,@ApiParam(value = "The limit for pagination", required = true, defaultValue = "20") @DefaultValue("20") @QueryParam("limit") @NotNull  Integer limit,@ApiParam(value = "Return only active results", required = true, defaultValue = "true") @DefaultValue("true") @QueryParam("activeOnly") @NotNull  Boolean activeOnly,@ApiParam(value = "Filter by retailer") @QueryParam("retailerId")  Long retailerId,@ApiParam(value = "Filter by service hub") @QueryParam("hubId")  Long hubId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.searchVehicleTypes(version, sortField, descending, start, limit, activeOnly, retailerId, hubId, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/weather/search")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Search Weather", notes = "Search the weather forcast for the next 5 days", response = WeatherResponse.class, tags={ "Weather", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = WeatherResponse.class)
    })
    public Response searchWeather(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "Region Id") @QueryParam("regionId")  Long regionId,@ApiParam(value = "Latitude") @QueryParam("latitude")  Double latitude,@ApiParam(value = "Longitude") @QueryParam("longitude")  Double longitude,@ApiParam(value = "Timezone Offset", defaultValue = "-6") @DefaultValue("-6") @QueryParam("timezoneOffset")  Long timezoneOffset,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.searchWeather(version, regionId, latitude, longitude, timezoneOffset, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/account/login/validate")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Login Account (Encrypted Username)", notes = "ogin with encrypted user-name and password.", response = ProfileResponse.class, tags={ "Account", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = ProfileResponse.class)
    })
    public Response secureLogin(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The user's encrypted email address they used to sign-up", required = true) @QueryParam("username") @NotNull  String username,@ApiParam(value = "The encrypted password", required = true) @QueryParam("password") @NotNull  String password,@ApiParam(value = "The application key", required = true) @QueryParam("gameType") @NotNull  String gameType,@ApiParam(value = "The device id") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "Charset Name", defaultValue = "UTF-8") @DefaultValue("UTF-8") @QueryParam("charsetName")  String charsetName,@ApiParam(value = "The current latitude of the user") @QueryParam("latitude")  Double latitude,@ApiParam(value = "The current longitude of the user") @QueryParam("longitude")  Double longitude,@ApiParam(value = "Return Profile", defaultValue = "false") @DefaultValue("false") @QueryParam("returnProfile")  Boolean returnProfile,@ApiParam(value = "A comma separated list of ProfileFilters for filtering the returned response data", defaultValue = "PROFILE") @DefaultValue("PROFILE") @QueryParam("responseFilters")  String responseFilters,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.secureLogin(version, username, password, gameType, deviceId, charsetName, latitude, longitude, returnProfile, responseFilters, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/account/create/validate")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Create Account (Encrypted Username)", notes = "Create a new account by role (with encrypted user-name and password)", response = ProfileInfoResponse.class, tags={ "Account", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = ProfileInfoResponse.class)
    })
    public Response secureSignup(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The device id", required = true) @QueryParam("deviceId") @NotNull  String deviceId,@ApiParam(value = "The encrypted email of the user, this is what will be used when they login", required = true) @QueryParam("username") @NotNull  String username,@ApiParam(value = "The encrypted password of the user", required = true) @QueryParam("password") @NotNull  String password,@ApiParam(value = "The full name of the user. If this parameter is not empty, the  following parameters will be ignored: prefixName, firstName, middleName,  lastName, and suffixName ") @QueryParam("name")  String name,@ApiParam(value = "the inviteToken that the referrer use for this account to sign up") @QueryParam("inviteToken")  String inviteToken,@ApiParam(value = "If the parameter 'name' is empty or not present, this field will be used to set the prefix of the user's name") @QueryParam("prefixName")  String prefixName,@ApiParam(value = "If the parameter 'name' is empty or not present, this field will be used to set the user's first name") @QueryParam("firstName")  String firstName,@ApiParam(value = "If the parameter 'name' is empty or not present, this field will be used to set the user's middle name") @QueryParam("middleName")  String middleName,@ApiParam(value = "If the parameter 'name' is empty or not present, this field will be used to set the user's last name") @QueryParam("lastName")  String lastName,@ApiParam(value = "If the parameter 'name' is empty or not present, this field will be used to set the suffix of the user's name") @QueryParam("suffixName")  String suffixName,@ApiParam(value = "Title") @QueryParam("title")  String title,@ApiParam(value = "Device Id Type") @QueryParam("deviceIdType")  String deviceIdType,@ApiParam(value = "The user's contact email address (NOT the username) which is also used for email validation") @QueryParam("emailAddress")  String emailAddress,@ApiParam(value = "The asset id to set the user's profile image") @QueryParam("assetId")  Long assetId,@ApiParam(value = "the user's address") @QueryParam("address")  String address,@ApiParam(value = "The street zipcode of the user's contact location") @QueryParam("zipcode")  String zipcode,@ApiParam(value = "The gender of the user AudienceGender") @QueryParam("gender")  String gender,@ApiParam(value = "The birthday date of the user in milliseconds") @QueryParam("birthday")  Long birthday,@ApiParam(value = "the user's home phone number") @QueryParam("homePhone")  String homePhone,@ApiParam(value = "the user's cell phone number") @QueryParam("cellPhone")  String cellPhone,@ApiParam(value = "the user's Cell Phone Carrier") @QueryParam("cellPhoneCarrier")  String cellPhoneCarrier,@ApiParam(value = "the user's Business Phone Number") @QueryParam("businessPhone")  String businessPhone,@ApiParam(value = "The type of account being created {RETAILER, MEMBER, DEVELOPER, GUEST", defaultValue = "MEMBER") @DefaultValue("MEMBER") @QueryParam("role")  String role,@ApiParam(value = "Comma separated list of development platforms: MAC, WINDOWS, IOS, ANDROID, WINDOWSPHONE, KINDLE, UNITY3D, COCOS2D, HTML5, FACEBOOK") @QueryParam("platforms")  String platforms,@ApiParam(value = "Search tags") @QueryParam("tags")  String tags,@ApiParam(value = "About Us information") @QueryParam("aboutUs")  String aboutUs,@ApiParam(value = "Game experience level of the user {ANY, NEW, BEGINNER, INTERMEDIATE, EXPERT") @QueryParam("gameExperience")  String gameExperience,@ApiParam(value = "A list of category ids that represent interests and associations") @QueryParam("categoryIds")  String categoryIds,@ApiParam(value = "The user's hometown") @QueryParam("hometown")  String hometown,@ApiParam(value = "The user's height") @QueryParam("height")  String height,@ApiParam(value = "The user's height in a numerical value that can be used for ordering/searching") @QueryParam("heightIndex")  Integer heightIndex,@ApiParam(value = "The user's ethnicity") @QueryParam("ethnicity")  String ethnicity,@ApiParam(value = "The user's body type") @QueryParam("bodyType")  String bodyType,@ApiParam(value = "The user's maritial status") @QueryParam("maritalStatus")  String maritalStatus,@ApiParam(value = "The user's children status") @QueryParam("children")  String children,@ApiParam(value = "The user's religion") @QueryParam("religion")  String religion,@ApiParam(value = "The user's education") @QueryParam("education")  String education,@ApiParam(value = "The user's education in a numerical value that can be used for ordering/searching") @QueryParam("educationIndex")  Integer educationIndex,@ApiParam(value = "The user's smoke status") @QueryParam("smoke")  String smoke,@ApiParam(value = "The user's drink status") @QueryParam("drink")  String drink,@ApiParam(value = "The user's companionship status") @QueryParam("companionship")  String companionship,@ApiParam(value = "The user's companionship index") @QueryParam("companionshipIndex")  Integer companionshipIndex,@ApiParam(value = "The preferred minimum age in the account location search") @QueryParam("preferredMinAge")  Integer preferredMinAge,@ApiParam(value = "The preferred maximum age in the account location search") @QueryParam("preferredMaxAge")  Integer preferredMaxAge,@ApiParam(value = "The preferred minimum height in the account location search") @QueryParam("preferredMinHeight")  Integer preferredMinHeight,@ApiParam(value = "The preferred maximum height in the account location search") @QueryParam("preferredMaxHeight")  Integer preferredMaxHeight,@ApiParam(value = "The preferred gender in the account location search") @QueryParam("preferredGender")  String preferredGender,@ApiParam(value = "The preferred education in the account location search") @QueryParam("preferredEducation")  String preferredEducation,@ApiParam(value = "The preferred education in a numerical value that can be used for ordering/searching") @QueryParam("preferredEducationIndex")  Integer preferredEducationIndex,@ApiParam(value = "The preferred body type in the account location search") @QueryParam("preferredBodyType")  String preferredBodyType,@ApiParam(value = "The preferred ethnicity in the account location search") @QueryParam("preferredEthnicity")  String preferredEthnicity,@ApiParam(value = "The preferred education in the account location search") @QueryParam("preferredLocation")  String preferredLocation,@ApiParam(value = "The preferred location range in the account location search") @QueryParam("preferredLocationRange")  Double preferredLocationRange,@ApiParam(value = "The current latitude of the user") @QueryParam("latitude")  Double latitude,@ApiParam(value = "The current longitude of the user") @QueryParam("longitude")  Double longitude,@ApiParam(value = "Accepted Terms", defaultValue = "true") @DefaultValue("true") @QueryParam("acceptedTerms")  Boolean acceptedTerms,@ApiParam(value = "Charset Name", defaultValue = "UTF-8") @DefaultValue("UTF-8") @QueryParam("charsetName")  String charsetName,@ApiParam(value = "Game Type") @QueryParam("gameType")  String gameType,@ApiParam(value = "The application key") @QueryParam("appKey")  String appKey,@ApiParam(value = "App Version") @QueryParam("appVersion")  String appVersion,@ApiParam(value = "Response Type") @QueryParam("responseType")  String responseType,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.secureSignup(version, deviceId, username, password, name, inviteToken, prefixName, firstName, middleName, lastName, suffixName, title, deviceIdType, emailAddress, assetId, address, zipcode, gender, birthday, homePhone, cellPhone, cellPhoneCarrier, businessPhone, role, platforms, tags, aboutUs, gameExperience, categoryIds, hometown, height, heightIndex, ethnicity, bodyType, maritalStatus, children, religion, education, educationIndex, smoke, drink, companionship, companionshipIndex, preferredMinAge, preferredMaxAge, preferredMinHeight, preferredMaxHeight, preferredGender, preferredEducation, preferredEducationIndex, preferredBodyType, preferredEthnicity, preferredLocation, preferredLocationRange, latitude, longitude, acceptedTerms, charsetName, gameType, appKey, appVersion, responseType, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/notification/batch")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Send Batch Notifications", notes = "Send notifications to all users of an application. Only someone with permissions to the application can do this.", response = SirqulResponse.class, tags={ "Notification", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response sendBatchNotifications(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The account id of the application owner/manager", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "The application key for updating an existing application", required = true) @QueryParam("appKey") @NotNull  String appKey,@ApiParam(value = "Message string that will be displayed in on the notification", required = true) @QueryParam("customMessage") @NotNull  String customMessage,@ApiParam(value = "The type of notification to send: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION.") @QueryParam("conduit")  String conduit,@ApiParam(value = "Default notification pay-load field (usage is dependent on the app and the type of event)") @QueryParam("contentId")  Long contentId,@ApiParam(value = "Default notification pay-load field (usage is dependent on the app and the type of event)") @QueryParam("contentName")  String contentName,@ApiParam(value = "Default notification pay-load field (usage is dependent on the app and the type of event)") @QueryParam("contentType")  String contentType,@ApiParam(value = "Default notification pay-load field (usage is dependent on the app and the type of event)") @QueryParam("parentId")  Long parentId,@ApiParam(value = "Default notification pay-load field (usage is dependent on the app and the type of event)") @QueryParam("parentType")  String parentType,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.sendBatchNotifications(version, accountId, appKey, customMessage, conduit, contentId, contentName, contentType, parentId, parentType, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/audience/suggestion/send")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Send Suggestions", notes = "Use the accountId to determine the associated BillableEntity. From there get a list of all triggers associated with the BillableEntity.", response = SirqulResponse.class, tags={ "Audience", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response sendByAccount(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The account to match offers for.", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "the latitude", required = true) @QueryParam("latitude") @NotNull  Double latitude,@ApiParam(value = "the longitude", required = true) @QueryParam("longitude") @NotNull  Double longitude,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.sendByAccount(version, accountId, latitude, longitude, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/notification/custom")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Send Custom Notifications", notes = "Send your own custom notification to a user. NOTE: the EventType of these notifications will be CUSTOM. Notifications sent to yourself will currently be ignored.", response = SirqulResponse.class, tags={ "Notification", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response sendCustomNotifications(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the unique id of the device making the request (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "the account id of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "comma separated list of account IDs that will receive the notification") @QueryParam("receiverAccountIds")  String receiverAccountIds,@ApiParam(value = "determines whether to send to all of the user's friends, this flag must be true or receiverAccountIds must not be empty") @QueryParam("includeFriendGroup")  Boolean includeFriendGroup,@ApiParam(value = "the application key") @QueryParam("appKey")  String appKey,@ApiParam(value = "This parameter is deprecated.") @QueryParam("gameType")  String gameType,@ApiParam(value = "the type of notification to send: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION.") @QueryParam("conduit")  String conduit,@ApiParam(value = "default notification pay-load field (usage is dependent on the app and the type of event)") @QueryParam("contentId")  Long contentId,@ApiParam(value = "default notification pay-load field (usage is dependent on the app and the type of event)") @QueryParam("contentName")  String contentName,@ApiParam(value = "default notification pay-load field (usage is dependent on the app and the type of event)") @QueryParam("contentType")  String contentType,@ApiParam(value = "default notification pay-load field (usage is dependent on the app and the type of event)") @QueryParam("parentId")  Long parentId,@ApiParam(value = "default notification pay-load field (usage is dependent on the app and the type of event)") @QueryParam("parentType")  String parentType,@ApiParam(value = "") @QueryParam("actionCategory")  String actionCategory,@ApiParam(value = "the subject line of an email #@param customPayload custom json definition of notification pay-load (usage is dependent on the app and the type of event)") @QueryParam("subject")  String subject,@ApiParam(value = "message string that will be displayed in on the notification") @QueryParam("customMessage")  String customMessage,@ApiParam(value = "only sends APNS to people who are friends of the user (still saves the notification message for feed polling)") @QueryParam("friendOnlyAPNS")  Boolean friendOnlyAPNS,@ApiParam(value = "latitude used to update the user's current location") @QueryParam("latitude")  Double latitude,@ApiParam(value = "longitude used to update the user's current location") @QueryParam("longitude")  Double longitude,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.sendCustomNotifications(version, deviceId, accountId, receiverAccountIds, includeFriendGroup, appKey, gameType, conduit, contentId, contentName, contentType, parentId, parentType, actionCategory, subject, customMessage, friendOnlyAPNS, latitude, longitude, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/thirdparty/credential/mfa/send")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Send MFA Challenge", notes = "Sends an MFA challenge (SMS or Email) for networks with MFA enabled.", response = SirqulResponse.class, tags={ "ThirdParty Credentials", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response sendMFAChallenge(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the third party network provider that has MFA enabled", required = true) @QueryParam("networkUID") @NotNull  String networkUID,@ApiParam(value = "the application key", required = true) @QueryParam("appKey") @NotNull  String appKey,@ApiParam(value = "the access token to authenticate with") @QueryParam("thirdPartyToken")  String thirdPartyToken,@ApiParam(value = "optional id of the existing third party credential") @QueryParam("thirdPartyCredentialId")  Long thirdPartyCredentialId,@ApiParam(value = "the unique id of the device making the request") @QueryParam("deviceId")  String deviceId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.sendMFAChallenge(version, networkUID, appKey, thirdPartyToken, thirdPartyCredentialId, deviceId, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/vatom/b/campaigns/send")
    
    
    @io.swagger.annotations.ApiOperation(value = "Send NFT", notes = "Send an NFT.", response = Void.class, tags={ "Vatom", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = Void.class)
    })
    public Response sendNFT(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "Sirqul Account Id", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "Sirqul Application Key", required = true) @QueryParam("appKey") @NotNull  String appKey,@ApiParam(value = "Vatom Campaign Id", required = true) @QueryParam("vatomCampaignId") @NotNull  String vatomCampaignId,@ApiParam(value = "Vatom Parameters", required = true) @QueryParam("vatomParameters") @NotNull  String vatomParameters,@ApiParam(value = "Return raw response") @QueryParam("returnRawResponse")  Boolean returnRawResponse,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.sendNFT(version, accountId, appKey, vatomCampaignId, vatomParameters, returnRawResponse, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/route/{id}/driver/{driverId}")
    
    
    @io.swagger.annotations.ApiOperation(value = "Set Driver", notes = "Update the driver of the route.", response = Void.class, tags={ "Route", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = Void.class)
    })
    public Response setDriver(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the id of the route", required = true) @PathParam("id") @NotNull  Long id,@ApiParam(value = "the id of the driver", required = true) @PathParam("driverId") @NotNull  Long driverId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.setDriver(version, id, driverId, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/consumer/profile/matchToken")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Save Match Token", notes = "Save user's match token to be used for profile match making", response = SirqulResponse.class, tags={ "Account", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response setMatchToken(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The device id (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "The account id of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "A string of numbers") @QueryParam("matchToken")  String matchToken,@ApiParam(value = "Game Type (deprecated)", defaultValue = "BOOPY") @DefaultValue("BOOPY") @QueryParam("gameType")  String gameType,@ApiParam(value = "The application key") @QueryParam("appKey")  String appKey,@ApiParam(value = "The current latitude of the user") @QueryParam("latitude")  Double latitude,@ApiParam(value = "The current longitude of the user") @QueryParam("longitude")  Double longitude,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.setMatchToken(version, deviceId, accountId, matchToken, gameType, appKey, latitude, longitude, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/vatom/b/campaign/u/points/update")
    
    
    @io.swagger.annotations.ApiOperation(value = "Set Points Balance as Business", notes = "Sets the points balance of a Vatom user.", response = Void.class, tags={ "Vatom", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = Void.class)
    })
    public Response setPointsBalanceAsBusiness(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "Sirqul Account Id", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "Sirqul Application Key", required = true) @QueryParam("appKey") @NotNull  String appKey,@ApiParam(value = "Vatom User Id", required = true) @QueryParam("vatomUserId") @NotNull  String vatomUserId,@ApiParam(value = "Vatom Campaign Id", required = true) @QueryParam("vatomCampaignId") @NotNull  String vatomCampaignId,@ApiParam(value = "Vatom Parameters", required = true) @QueryParam("vatomParameters") @NotNull  String vatomParameters,@ApiParam(value = "Return raw response") @QueryParam("returnRawResponse")  Boolean returnRawResponse,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.setPointsBalanceAsBusiness(version, accountId, appKey, vatomUserId, vatomCampaignId, vatomParameters, returnRawResponse, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/simulation/routing")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Routing Simulation", notes = "Simulates routing requests.", response = SirqulResponse.class, tags={ "Simulation", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response simulation(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "JSON string in the following format: ```json {   \"startDate\": 1474268400000,   \"endDate\": 1474268700000,   \"checkoutStops\": [     {       \"latitude\": 25.060453943481615,       \"longitude\": 121.57487118216957     }   ],   \"requests\": [     {       \"vehicles\": [         {           \"id\": \"customer1\",           \"name\": \"Customer 1\",           \"depot\": {             \"latitude\": 25.060453943481615,             \"longitude\": 121.57487118216957           },           \"startWindow\": 1474268464537         }       ],       \"items\": [         {           \"id\": 152712,           \"name\": \"Appliance Product\",           \"pickup\": {             \"latitude\": 25.060306635544144,             \"longitude\": 121.5750770690688           }         },         {           \"id\": 152711,           \"name\": \"TV product\",           \"pickup\": {             \"latitude\": 25.060126352576326,             \"longitude\": 121.57505023621624           }         }       ]     }   ],   \"featuredItems\": [],   \"floorPlan\": {     \"metersPerX\": 0.81493109028875,     \"metersPerY\": 1.8525267552262,     \"width\": 75,     \"height\": 50,     \"exclusions\": [       { \"x\": 14, \"y\": 49 }     ],     \"southwest\": {       \"x\": 0,       \"y\": 0,       \"latitude\": 25.05961539530497,       \"longitude\": 121.57487591737885     }   } } ``` ", required = true) @QueryParam("data") @NotNull  String data,@ApiParam(value = "determines whether to run the simulation and return the results in the same request", required = true) @QueryParam("realTime") @NotNull  Boolean realTime,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.simulation(version, data, realTime, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/sms/buyoffer/{appKey}")
    
    @Produces({ "application/xml" })
    @io.swagger.annotations.ApiOperation(value = "Buy Offer by SMS", notes = "Recieve an SMS payload from Twillio to purchase an offer.", response = TwiMLResponse.class, tags={ "Twilio", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = TwiMLResponse.class)
    })
    public Response smsBuyOffer(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the application key", required = true) @PathParam("appKey") @NotNull  String appKey,@ApiParam(value = "the message of the text", required = true) @QueryParam("Body") @NotNull  String body,@ApiParam(value = "the sender of the sms", required = true) @QueryParam("From") @NotNull  String from,@ApiParam(value = "the type of currency", required = true) @QueryParam("currencyType") @NotNull  String currencyType,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.smsBuyOffer(version, appKey, body, from, currencyType, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/orson/stories/renders")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Starts a StoryStitch video render", notes = "Starts a StoryStitch video render to produce your final video, returning the status details.", response = OrsonRenderResponse.class, tags={ "Orson", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = OrsonRenderResponse.class)
    })
    public Response startVideoRender(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "Sirqul Account Id", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "Request Data String", required = true) @QueryParam("data") @NotNull  String data,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.startVideoRender(version, accountId, data, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/csvimport/batch/status")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Batch Status", notes = "Checks status of batch upload.", response = CsvImportResponse.class, tags={ "CSV Import", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = CsvImportResponse.class)
    })
    public Response statusCSV(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the id of the account", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "the id of the batch to get its status", required = true) @QueryParam("batchId") @NotNull  Long batchId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.statusCSV(version, accountId, batchId, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/orson/ai/stt")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Speach to Text", notes = "Accepts a movie URL or uploaded file and transcribes it. You also have the option to translate it into one of our additional supported languages.", response = OrsonAiSTTResponse.class, tags={ "Orson", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = OrsonAiSTTResponse.class)
    })
    public Response stt(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "Sirqul Account Id", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "A third-party account id that is meaningful to your systems") @QueryParam("thirdPartyAccountId")  String thirdPartyAccountId,@ApiParam(value = "Source Language") @QueryParam("sourceLanguage")  String sourceLanguage,@ApiParam(value = "Target Language") @QueryParam("targetLanguage")  String targetLanguage,@ApiParam(value = "An uploaded recording to analyze (Currently limited to 10MB)") @QueryParam("file")  File _file,@ApiParam(value = "A recording file to download and analyze (Size limit: 1GB)") @QueryParam("url")  String url,@ApiParam(value = "When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open") @QueryParam("callback")  String paramCallback,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.stt(version, accountId, thirdPartyAccountId, sourceLanguage, targetLanguage, _file, url, paramCallback, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/tournament/score")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Submit Tournament Score", notes = "Submit an array of scores for a tournament match. ", response = SirqulResponse.class, tags={ "Tournament", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response submitTournamentScore(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The logged in user account ID.", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "The application key.", required = true) @QueryParam("appKey") @NotNull  String appKey,@ApiParam(value = "The missionId to score for", required = true) @QueryParam("missionId") @NotNull  Long missionId,@ApiParam(value = "The gameId to score for", required = true) @QueryParam("gameId") @NotNull  Long gameId,@ApiParam(value = "The packId to score for", required = true) @QueryParam("packId") @NotNull  Long packId,@ApiParam(value = "a JSON Array of scores to submit for a tournament match ```json [   {     \"accountId\": 2,     \"points\": 3   },   {     \"accountId\": 1777662,     \"points\": 7   } ] ``` ", required = true) @QueryParam("scores") @NotNull  String scores,@ApiParam(value = "The gameLevelId to score for") @QueryParam("gameLevelId")  Long gameLevelId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.submitTournamentScore(version, accountId, appKey, missionId, gameId, packId, scores, gameLevelId, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/tournament/vote")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Submit a vote for a multi-stage album tournament.", notes = "Submit a vote for a multi-stage album tournament.", response = SirqulResponse.class, tags={ "Tournament", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response submitTournamentVote(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The logged in user.", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "The application to target", required = true) @QueryParam("appKey") @NotNull  String appKey,@ApiParam(value = "The tournament's primary id", required = true) @QueryParam("missionId") @NotNull  Long missionId,@ApiParam(value = "The tournament game object the user wants to vote on", required = true) @QueryParam("gameObjectId") @NotNull  Long gameObjectId,@ApiParam(value = "The unique id of the device making the request (optional)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "When true, check if the device already voted to prevent duplicate votes from the same device", defaultValue = "false") @DefaultValue("false") @QueryParam("checkIfDeviceAlreadyVoted")  Boolean checkIfDeviceAlreadyVoted,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.submitTournamentVote(version, accountId, appKey, missionId, gameObjectId, deviceId, checkIfDeviceAlreadyVoted, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/tournament/substitute")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Substitute Tournament Player", notes = "Service to replace the user's opponent in the current level - pack - mission with an AI account.", response = SirqulResponse.class, tags={ "Tournament", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response substituteTournamentPlayer(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the id of the logged in user", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "the id of the mission", required = true) @QueryParam("missionId") @NotNull  Long missionId,@ApiParam(value = "the id of the pack", required = true) @QueryParam("packId") @NotNull  Long packId,@ApiParam(value = "the id of the game level", required = true) @QueryParam("gameLevelId") @NotNull  Long gameLevelId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.substituteTournamentPlayer(version, accountId, missionId, packId, gameLevelId, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/orson/ai/topics")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Summarize Topics", notes = "Takes in a string of text sentences (also known as a document) and returns a list of associated topics and their proximity score.", response = OrsonAiTopicsResponse.class, tags={ "Orson", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = OrsonAiTopicsResponse.class)
    })
    public Response summarizeTopics(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "Sirqul Account Id", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "A third-party account id that is meaningful to your systems") @QueryParam("thirdPartyAccountId")  String thirdPartyAccountId,@ApiParam(value = "The text to get topics for.") @QueryParam("doc")  String doc,@ApiParam(value = "An uploaded recording to analyze (Currently limited to 10MB)") @QueryParam("file")  File _file,@ApiParam(value = "A recording file to download and analyze (Size limit: 1GB)") @QueryParam("url")  String url,@ApiParam(value = "The number of results to return") @QueryParam("limit")  Integer limit,@ApiParam(value = "The starting offset into the total result set to start from") @QueryParam("offset")  Integer offset,@ApiParam(value = "When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open") @QueryParam("callback")  String paramCallback,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.summarizeTopics(version, accountId, thirdPartyAccountId, doc, _file, url, limit, offset, paramCallback, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/listing/summary")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Summary Listing", notes = "Search for a list of summary listings from the start time up to 8 days out.", response = ListingGroupResponse.class, responseContainer = "List", tags={ "Listing", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = ListingGroupResponse.class, responseContainer = "List")
    })
    public Response summaryListing(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the account id of the user") @QueryParam("accountId")  Long accountId,@ApiParam(value = "the start date to search from") @QueryParam("startDate")  Long startDate,@ApiParam(value = "the list of categories to search on") @QueryParam("categoryIds")  String categoryIds,@ApiParam(value = "how far out to search, in days", defaultValue = "15") @DefaultValue("15") @QueryParam("daysToInclude")  Integer daysToInclude,@ApiParam(value = "determines whether to use configured listing order ids", defaultValue = "true") @DefaultValue("true") @QueryParam("useListingOrderIds")  Boolean useListingOrderIds,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.summaryListing(version, accountId, startDate, categoryIds, daysToInclude, useListingOrderIds, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/orson/ai/techTune")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Detect Technical Issues", notes = "Analyses a movie file to detect technical issues, such as too few people in frame.", response = OrsonAiTechTuneResponse.class, tags={ "Orson", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = OrsonAiTechTuneResponse.class)
    })
    public Response techTune(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "Sirqul Account Id", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "Number of expected faces", required = true) @QueryParam("numFacesExpected") @NotNull  Integer numFacesExpected,@ApiParam(value = "A third-party account id that is meaningful to your systems") @QueryParam("thirdPartyAccountId")  String thirdPartyAccountId,@ApiParam(value = "An uploaded recording to analyze (Currently limited to 10MB)") @QueryParam("file")  File _file,@ApiParam(value = "A recording file to download and analyze (Size limit: 1GB)") @QueryParam("url")  String url,@ApiParam(value = "When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open") @QueryParam("callback")  String paramCallback,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.techTune(version, accountId, numFacesExpected, thirdPartyAccountId, _file, url, paramCallback, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/ticket/ticketoffers")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Get Ticket Offers", notes = "Get a list offers for tickets owned by sirqul.  Purchasing these will add the number of tickets to the account specified by the offer.", response = TicketOfferResponse.class, tags={ "Ticket", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = TicketOfferResponse.class)
    })
    public Response ticketOffers(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.ticketOffers(version, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/offer/top")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Get Offers (Top)", notes = "Gets the top active offers.", response = OfferListResponse.class, tags={ "Offer", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = OfferListResponse.class)
    })
    public Response topOfferTransactions(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The index into the record set to start with. Default is 0.", defaultValue = "0") @DefaultValue("0") @QueryParam("start")  Integer start,@ApiParam(value = "The total number of record to return. Default id 20.", defaultValue = "20") @DefaultValue("20") @QueryParam("limit")  Integer limit,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.topOfferTransactions(version, start, limit, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/vatom/u/coins/transfer")
    
    
    @io.swagger.annotations.ApiOperation(value = "Transfer coins from Vatom Users", notes = "Transfer coins from Vatom Users.", response = Void.class, tags={ "Vatom", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = Void.class)
    })
    public Response transferUserCoins(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "Sirqul Account Id", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "Vatom User Id", required = true) @QueryParam("vatomUserId") @NotNull  String vatomUserId,@ApiParam(value = "Vatom Parameters", required = true) @QueryParam("vatomParameters") @NotNull  String vatomParameters,@ApiParam(value = "Return raw response") @QueryParam("returnRawResponse")  Boolean returnRawResponse,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.transferUserCoins(version, accountId, vatomUserId, vatomParameters, returnRawResponse, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/orson/ai/tts")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Text to Speach", notes = "Creates an audio file for the given text, with the option of language and voice selection.", response = OrsonAiTTSResponse.class, tags={ "Orson", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = OrsonAiTTSResponse.class)
    })
    public Response tts(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "Sirqul Account Id", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "Text", required = true) @QueryParam("text") @NotNull  String text,@ApiParam(value = "A third-party account id that is meaningful to your systems") @QueryParam("thirdPartyAccountId")  String thirdPartyAccountId,@ApiParam(value = "The language to use for the speaker and incoming text") @QueryParam("language")  String language,@ApiParam(value = "A language-specific voice to use, or picks the language default if not provided") @QueryParam("voice")  String voice,@ApiParam(value = "When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open") @QueryParam("callback")  String paramCallback,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.tts(version, accountId, text, thirdPartyAccountId, language, voice, paramCallback, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/employee/unassign")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Unassign Employee", notes = "Unassign An existing account to be an employee", response = EmployeeResponse.class, tags={ "Employee", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = EmployeeResponse.class)
    })
    public Response unassignEmployee(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The account id of the logged in user", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "The account id of the user to be unassigned", required = true) @QueryParam("employeeAccountId") @NotNull  Long employeeAccountId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.unassignEmployee(version, accountId, employeeAccountId, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/achievement/update")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Update Achievement", notes = "Updates an achievement (for developer/retailer use). User must have permissions to the application the achievement is created for.", response = AchievementResponse.class, tags={ "Achievement", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = AchievementResponse.class)
    })
    public Response updateAchievement(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "a unique id given by the device (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "the account id of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "the achievement ID for updating an existing achievement") @QueryParam("achievementId")  Long achievementId,@ApiParam(value = "the analytics tag that will trigger when a user's achievement count gets updated") @QueryParam("analyticsTag")  String analyticsTag,@ApiParam(value = "the title of the achievement (255 character limit)") @QueryParam("title")  String title,@ApiParam(value = "the description of the achievement") @QueryParam("description")  String description,@ApiParam(value = "the rank type for updating leader boards") @QueryParam("rankType")  String rankType,@ApiParam(value = "determines how much the rank count is incremented") @QueryParam("rankIncrement")  Integer rankIncrement,@ApiParam(value = "restrict scores to be above or equal to this minimum value") @QueryParam("minIncrement")  Integer minIncrement,@ApiParam(value = "enable to ignore usage of minIncrement") @QueryParam("nullMinIncrement")  Boolean nullMinIncrement,@ApiParam(value = "restrict scores to be below or equal to this maximum value") @QueryParam("maxIncrement")  Integer maxIncrement,@ApiParam(value = "enable to ignore usage of maxIncrement") @QueryParam("nullMaxIncrement")  Boolean nullMaxIncrement,@ApiParam(value = "determines whether the customId on analytics are used to validate a user's achievement progress.") @QueryParam("validate")  Boolean validate,@ApiParam(value = "if it's active or inactive") @QueryParam("active")  Boolean active,@ApiParam(value = "if provided will define what triggers to run after a tier is completed") @QueryParam("triggerDefinition")  String triggerDefinition,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.updateAchievement(version, deviceId, accountId, achievementId, analyticsTag, title, description, rankType, rankIncrement, minIncrement, nullMinIncrement, maxIncrement, nullMaxIncrement, validate, active, triggerDefinition, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/achievement/tier/update")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Update Achievement Tier", notes = "Updates a tier of an achievement (for developer/retailer use). User must have permissions to the application the achievement is created for.", response = AchievementTierResponse.class, tags={ "Achievement", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = AchievementTierResponse.class)
    })
    public Response updateAchievementTier(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the achievement tier id for updating", required = true) @QueryParam("achievementTierId") @NotNull  Long achievementTierId,@ApiParam(value = "a unique id given by the device (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "the account id of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "achievement tier icon image file") @QueryParam("icon")  File icon,@ApiParam(value = "the icon assetId, if icon is provided, icon will overrule") @QueryParam("iconAssetId")  Long iconAssetId,@ApiParam(value = "the title of the achievement tier") @QueryParam("title")  String title,@ApiParam(value = "the description of the achievement tier") @QueryParam("description")  String description,@ApiParam(value = "the count requirement for completing the achievement tier") @QueryParam("goalCount")  Long goalCount,@ApiParam(value = "The ID of the mission to associate with the achievement") @QueryParam("missionId")  Long missionId,@ApiParam(value = "The ID of the game to associate with the achievement") @QueryParam("gameId")  Long gameId,@ApiParam(value = "The ID of the pack to associate with the achievement") @QueryParam("packId")  Long packId,@ApiParam(value = "The ID of the game level to associate with the achievement") @QueryParam("gameLevelId")  Long gameLevelId,@ApiParam(value = "The ID of the game object to associate with the achievement") @QueryParam("gameObjectId")  Long gameObjectId,@ApiParam(value = "score all instances") @QueryParam("scoreAllInstances")  Boolean scoreAllInstances,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.updateAchievementTier(version, achievementTierId, deviceId, accountId, icon, iconAssetId, title, description, goalCount, missionId, gameId, packId, gameLevelId, gameObjectId, scoreAllInstances, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/account/active/update")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Update Account Active Status", notes = "Activate or deactivate an account (requires appropriate permissions).", response = SirqulResponse.class, tags={ "Account", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response updateActveStatus(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the account id of the user (deviceId or accountId required)", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "The account id of the user you want to modify (if this is not set, then the accountId parameter will be used instead)", required = true) @QueryParam("connectionAccountId") @NotNull  Long connectionAccountId,@ApiParam(value = "true will activate the user and false will deactivate", required = true) @QueryParam("active") @NotNull  Boolean active,@ApiParam(value = "the device id (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "the application key that the user belongs to") @QueryParam("appKey")  String appKey,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.updateActveStatus(version, accountId, connectionAccountId, active, deviceId, appKey, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/album/update")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Update Album", notes = "Update an Album.", response = AlbumResponse.class, tags={ "Album", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = AlbumResponse.class)
    })
    public Response updateAlbumCollection(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the ID of the album to update", required = true) @QueryParam("albumId") @NotNull  Long albumId,@ApiParam(value = "a unique ID given by the device (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "the account ID of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "Comma separated list of asset IDs to add to the album's asset list (use \"assetId\" for setting the cover of the album)") @QueryParam("assetsToAdd")  String assetsToAdd,@ApiParam(value = "Comma separated list of asset IDs to remove from the album's asset list") @QueryParam("assetsToRemove")  String assetsToRemove,@ApiParam(value = "the cover asset ID") @QueryParam("assetId")  Long assetId,@ApiParam(value = "a MultipartFile containing the cover image of the album (this will only be used if \"assetId\" is empty)") @QueryParam("media")  File media,@ApiParam(value = "this can be used if the \"media\" is a link (this will only be used if \"assetId\" and media are empty)") @QueryParam("mediaURL")  String mediaURL,@ApiParam(value = "determines whether the album is active or inactive") @QueryParam("active")  Boolean active,@ApiParam(value = "the title of the album") @QueryParam("title")  String title,@ApiParam(value = "the start date") @QueryParam("startDate")  Long startDate,@ApiParam(value = "the end date") @QueryParam("endDate")  Long endDate,@ApiParam(value = "the tags") @QueryParam("tags")  String tags,@ApiParam(value = "the description of the album") @QueryParam("description")  String description,@ApiParam(value = "a custom field used for aggregation and searching") @QueryParam("albumType")  String albumType,@ApiParam(value = "a custom indexed number used for aggregation and searching") @QueryParam("albumTypeId")  Long albumTypeId,@ApiParam(value = "a custom string field used for aggregation and searching") @QueryParam("subType")  String subType,@ApiParam(value = "determines whether the album's participants have read permissions") @QueryParam("publicRead")  Boolean publicRead,@ApiParam(value = "determines whether the album's participants have write permissions") @QueryParam("publicWrite")  Boolean publicWrite,@ApiParam(value = "determines whether the album's participants have delete permissions") @QueryParam("publicDelete")  Boolean publicDelete,@ApiParam(value = "determines whether the album's participants have add permissions") @QueryParam("publicAdd")  Boolean publicAdd,@ApiParam(value = "latitude used to update the album's location") @QueryParam("latitude")  Double latitude,@ApiParam(value = "longitude used to update the album's location") @QueryParam("longitude")  Double longitude,@ApiParam(value = "the location description") @QueryParam("locationDescription")  String locationDescription,@ApiParam(value = "the determines the album's participants (PUBLIC - includes everyone in the system as a potential participant, PRIVATE - only considers people who have been invited as participants)", allowableValues="PUBLIC, PRIVATE, FRIENDS") @QueryParam("visibility")  String visibility,@ApiParam(value = "the cell phone number") @QueryParam("cellPhone")  String cellPhone,@ApiParam(value = "The street address of the location") @QueryParam("streetAddress")  String streetAddress,@ApiParam(value = "Additional address information (such as a suite number, floor number, building name, or PO Box)") @QueryParam("streetAddress2")  String streetAddress2,@ApiParam(value = "The city of the location") @QueryParam("city")  String city,@ApiParam(value = "The state of of the location") @QueryParam("state")  String state,@ApiParam(value = "The postal code of the location") @QueryParam("postalCode")  String postalCode,@ApiParam(value = "The full address of the location which should include the street address, city, state, and postal code") @QueryParam("fullAddress")  String fullAddress,@ApiParam(value = "determines whether the album is posted anonymously") @QueryParam("anonymous")  Boolean anonymous,@ApiParam(value = "External custom client defined data") @QueryParam("metaData")  String metaData,@ApiParam(value = "comma separated category ids string associated with the Album") @QueryParam("categoryIds")  String categoryIds,@ApiParam(value = "comma separated filter ids string associated with the Album") @QueryParam("categoryFilterIds")  String categoryFilterIds,@ApiParam(value = "comma separated audience ids string associated with the album") @QueryParam("audienceIds")  String audienceIds,@ApiParam(value = "comma separated audience ids to add to the album") @QueryParam("audienceIdsToAdd")  String audienceIdsToAdd,@ApiParam(value = "comma separated audience ids to remove from the album (overrides audienceIds and audienceIdsToAdd)") @QueryParam("audienceIdsToRemove")  String audienceIdsToRemove,@ApiParam(value = "determines whether to include all app users as members (only admins of the app can do this)") @QueryParam("includeAllAppUsersAsMembers")  Boolean includeAllAppUsersAsMembers,@ApiParam(value = "determines whether to include all users of the audiences as members (only admins of the app can do this)") @QueryParam("includeAudiencesAsMembers")  Boolean includeAudiencesAsMembers,@ApiParam(value = "determines whether to use ands or ors when using the audience list to add users") @QueryParam("audienceOperator")  String audienceOperator,@ApiParam(value = "sets a linked object so that it can be returned as part of the album response") @QueryParam("linkedObjectType")  String linkedObjectType,@ApiParam(value = "sets a linked object id so that it can be returned as part of the album response") @QueryParam("linkedObjectId")  Long linkedObjectId,@ApiParam(value = "determines whether the album should be indexed immediately") @QueryParam("indexNow")  Boolean indexNow,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.updateAlbumCollection(version, albumId, deviceId, accountId, assetsToAdd, assetsToRemove, assetId, media, mediaURL, active, title, startDate, endDate, tags, description, albumType, albumTypeId, subType, publicRead, publicWrite, publicDelete, publicAdd, latitude, longitude, locationDescription, visibility, cellPhone, streetAddress, streetAddress2, city, state, postalCode, fullAddress, anonymous, metaData, categoryIds, categoryFilterIds, audienceIds, audienceIdsToAdd, audienceIdsToRemove, includeAllAppUsersAsMembers, includeAudiencesAsMembers, audienceOperator, linkedObjectType, linkedObjectId, indexNow, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/application/update")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Update Application", notes = "Update an application record", response = ApplicationResponse.class, tags={ "Application", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = ApplicationResponse.class)
    })
    public Response updateApplication(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The application key for updating an existing application", required = true) @QueryParam("appKey") @NotNull  String appKey,@ApiParam(value = "The name of the application", required = true) @QueryParam("appName") @NotNull  String appName,@ApiParam(value = "The unique id of the device making the request (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "The account id of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "The description of the application") @QueryParam("about")  String about,@ApiParam(value = "The application bundle identifier (format - com.company.appName)") @QueryParam("bundleId")  String bundleId,@ApiParam(value = "The application icon asset id") @QueryParam("appIconAssetId")  Long appIconAssetId,@ApiParam(value = "The application logo asset id") @QueryParam("appLogoAssetId")  Long appLogoAssetId,@ApiParam(value = "The Facebook application id") @QueryParam("facebookAppId")  String facebookAppId,@ApiParam(value = "The Facebook application secret") @QueryParam("facebookAppSecret")  String facebookAppSecret,@ApiParam(value = "This is the either the 'server key' or 'browser key' generated from google to enable Google Cloud Messaging") @QueryParam("googleApiKey")  String googleApiKey,@ApiParam(value = "Determines whether to update the EULA date") @QueryParam("updateEULADate")  Boolean updateEULADate,@ApiParam(value = "The EULA version") @QueryParam("eulaVersion")  String eulaVersion,@ApiParam(value = "The landing page URL") @QueryParam("landingPageUrl")  String landingPageUrl,@ApiParam(value = "Determines whether to show the application in the activity feed") @QueryParam("showInActivities")  Boolean showInActivities,@ApiParam(value = "The description of the application in the activity feed") @QueryParam("activityDescription")  String activityDescription,@ApiParam(value = "The text to display on the invite page") @QueryParam("inviteWelcomeText")  String inviteWelcomeText,@ApiParam(value = "The url to the application invite page") @QueryParam("invitePageUrl")  String invitePageUrl,@ApiParam(value = "The protocal the app uses to load the app via a browser") @QueryParam("urlScheme")  String urlScheme,@ApiParam(value = "A json object with a list of supported platforms.  ```json {   \"platforms\": [     {       \"deviceId\": 1,       \"minimum\": 230,       \"maximum\": 421,       \"downloadUrl\": \"http://app.store.com/download\",       \"description\": \"description and version info\"     }   ] } ``` ") @QueryParam("platforms")  String platforms,@ApiParam(value = "Json formatted downloadUrls.  ```json {   \"ios\": \"the-url-to-app-store\",    \"android\": \"the-url-to-google-play\" } ```  ") @QueryParam("downloadUrls")  String downloadUrls,@ApiParam(value = "List of categories to apply") @QueryParam("categoryIds")  String categoryIds,@ApiParam(value = "The type of scoring this application will use {GAME_LEVEL, GAME_OBJECT", allowableValues="GAME_LEVEL, GAME_OBJECT", defaultValue = "GAME_LEVEL") @DefaultValue("GAME_LEVEL") @QueryParam("scoringType")  String scoringType,@ApiParam(value = "The cost of hints", defaultValue = "11") @DefaultValue("11") @QueryParam("hintCost")  Integer hintCost,@ApiParam(value = "The maximum score that will be possible", defaultValue = "125") @DefaultValue("125") @QueryParam("maxScore")  Integer maxScore,@ApiParam(value = "The point-to-ticket conversion ratio", defaultValue = "0.037") @DefaultValue("0.037") @QueryParam("ticketsPerPoint")  Float ticketsPerPoint,@ApiParam(value = "Determines whether the application uses services to save custom game objects", defaultValue = "true") @DefaultValue("true") @QueryParam("hasGameData")  Boolean hasGameData,@ApiParam(value = "Public Notifications") @QueryParam("publicNotifications")  Boolean publicNotifications,@ApiParam(value = "Use Matching Algorithm") @QueryParam("useMatchingAlgorithm")  Boolean useMatchingAlgorithm,@ApiParam(value = "Determines whether earned tickets are applied across all applications", defaultValue = "false") @DefaultValue("false") @QueryParam("globalTickets")  Boolean globalTickets,@ApiParam(value = "The current build version of the application", defaultValue = "1") @DefaultValue("1") @QueryParam("buildVersion")  Float buildVersion,@ApiParam(value = "The current API version the application uses") @QueryParam("apiVersion")  Float apiVersion,@ApiParam(value = "The name of the placement") @QueryParam("placementName")  String placementName,@ApiParam(value = "The description of the placement") @QueryParam("placementDescription")  String placementDescription,@ApiParam(value = "The ad placement size {BANNER, LEADERBOARD, SKYSCRAPER, INTERSTITIAL, CUSTOM (this is required if a placements is to be created)", allowableValues="CONFIG, BANNER, LEADERBOARD, SKYSCRAPER, VIDEO, ZIP, INTERSTITIAL, CUSTOM1, CUSTOM2, CUSTOM3, CUSTOM4, CUSTOM5, CUSTOM6, CUSTOM7, CUSTOM8, CUSTOM9, CUSTOM10") @QueryParam("placementSize")  String placementSize,@ApiParam(value = "The height of a custom ad size") @QueryParam("placementHeight")  Integer placementHeight,@ApiParam(value = "The width of a custom ad size") @QueryParam("placementWidth")  Integer placementWidth,@ApiParam(value = "The refresh interval in seconds") @QueryParam("placementRefreshInterval")  Integer placementRefreshInterval,@ApiParam(value = "Generate a custom object store to use", defaultValue = "true") @DefaultValue("true") @QueryParam("createObjectStore")  Boolean createObjectStore,@ApiParam(value = "Determine whether or not public content requires admin approval before it becomes public", defaultValue = "false") @DefaultValue("false") @QueryParam("publicContentApproval")  Boolean publicContentApproval,@ApiParam(value = "Determines whether the application uses production or sandbox services", defaultValue = "false") @DefaultValue("false") @QueryParam("productionMode")  Boolean productionMode,@ApiParam(value = "Minimum Session Length") @QueryParam("minimumSessionLength")  Integer minimumSessionLength,@ApiParam(value = "Session Gap Length") @QueryParam("sessionGapLength")  Integer sessionGapLength,@ApiParam(value = "Local Ads Enabled", defaultValue = "false") @DefaultValue("false") @QueryParam("localAdsEnabled")  Boolean localAdsEnabled,@ApiParam(value = "Sqoot Api Key") @QueryParam("sqootApiKey")  String sqootApiKey,@ApiParam(value = "Determines how to process trilateration data. Possible values include: DEFAULT, FINGERPRINT", allowableValues="DEFAULT, FINGERPRINT, FINGERPRINT_V2", defaultValue = "FINGERPRINT") @DefaultValue("FINGERPRINT") @QueryParam("trilatProcessingType")  String trilatProcessingType,@ApiParam(value = "Determines what the maximum sample size during trilateration") @QueryParam("maxSampleSize")  Integer maxSampleSize,@ApiParam(value = "Determines what the minimum acceptable RSSI value") @QueryParam("minRSSI")  Double minRSSI,@ApiParam(value = "List modules allowed to be served by the server, possible values include: COMMON, MEDIA, OFFER, GAME, SOCIAL, CONSUMER_WEBSITE, ALL", defaultValue = "ALL") @DefaultValue("ALL") @QueryParam("modules")  String modules,@ApiParam(value = "How many servers the license will support", defaultValue = "1") @DefaultValue("1") @QueryParam("authorizedCount")  Integer authorizedCount,@ApiParam(value = "The list of ip addresses of servers the license will support, leave null for any server") @QueryParam("authorizedServers")  String authorizedServers,@ApiParam(value = "Sets the default timezone for the app (used for leaderboards and other time specific content)") @QueryParam("defaultTimezone")  String defaultTimezone,@ApiParam(value = "SMTP Pass") @QueryParam("smtpPass")  String smtpPass,@ApiParam(value = "The application meta data. Defined by the client") @QueryParam("metaData")  String metaData,@ApiParam(value = "The ad placement meta data. Defined by the client") @QueryParam("placementMetaData")  String placementMetaData,@ApiParam(value = "Create floor tables for Ips", defaultValue = "false") @DefaultValue("false") @QueryParam("ipsFloor")  Boolean ipsFloor,@ApiParam(value = "Enables setting the APNS badge value in the payload", defaultValue = "true") @DefaultValue("true") @QueryParam("enableAPNSBadge")  Boolean enableAPNSBadge,@ApiParam(value = "Enables using the application in session reports", defaultValue = "true") @DefaultValue("true") @QueryParam("includeInReport")  Boolean includeInReport,@ApiParam(value = "Sets the default filter to use (if none is passed in) for certain search APIs including Album Search.") @QueryParam("defaultAppFilterId")  Long defaultAppFilterId,@ApiParam(value = "Enables whether the default welcome email will be sent for new app users") @QueryParam("enableWelcomeEmail")  Boolean enableWelcomeEmail,@ApiParam(value = "The Apple Application ID") @QueryParam("appleAppId")  String appleAppId,@ApiParam(value = "The Apple Team ID") @QueryParam("appleTeamId")  String appleTeamId,@ApiParam(value = "The Apple Auth Key ID") @QueryParam("appleAuthKeyId")  String appleAuthKeyId,@ApiParam(value = "The Apple Auth Signin Key (p8) File") @QueryParam("appleAuthKey")  File appleAuthKey,@ApiParam(value = "The Apple Issuer ID") @QueryParam("appleIssuerId")  String appleIssuerId,@ApiParam(value = "The Apple App Store Key ID") @QueryParam("appStoreKeyId")  String appStoreKeyId,@ApiParam(value = "The Apple App Store Key (p8) File") @QueryParam("appStoreKey")  File appStoreKey,@ApiParam(value = "This is the private key file for your Google service account.") @QueryParam("googlePrivateKeyFile")  File googlePrivateKeyFile,@ApiParam(value = "Authorize Net Api Key") @QueryParam("authorizeNetApiKey")  String authorizeNetApiKey,@ApiParam(value = "Authorize Net Transaction Key") @QueryParam("authorizeNetTransactionKey")  String authorizeNetTransactionKey,@ApiParam(value = "Email Sender") @QueryParam("emailSender")  String emailSender,@ApiParam(value = "SMTP User") @QueryParam("smtpUser")  String smtpUser,@ApiParam(value = "SMTP Host") @QueryParam("smtpHost")  String smtpHost,@ApiParam(value = "Vatom Business Id") @QueryParam("vatomBusinessId")  String vatomBusinessId,@ApiParam(value = "Vatom REST Client Id") @QueryParam("vatomRestClientId")  String vatomRestClientId,@ApiParam(value = "Vatom Secret Key") @QueryParam("vatomRestSecretKey")  String vatomRestSecretKey,@ApiParam(value = "Twilio Account SID") @QueryParam("twilioAccountSID")  String twilioAccountSID,@ApiParam(value = "Twilio Auth Token") @QueryParam("twilioAuthToken")  String twilioAuthToken,@ApiParam(value = "Twilio Sender Phone Number") @QueryParam("twilioSenderPhoneNumber")  String twilioSenderPhoneNumber,@ApiParam(value = "OpenAI Secret API Key") @QueryParam("openAISecretKey")  String openAISecretKey,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.updateApplication(version, appKey, appName, deviceId, accountId, about, bundleId, appIconAssetId, appLogoAssetId, facebookAppId, facebookAppSecret, googleApiKey, updateEULADate, eulaVersion, landingPageUrl, showInActivities, activityDescription, inviteWelcomeText, invitePageUrl, urlScheme, platforms, downloadUrls, categoryIds, scoringType, hintCost, maxScore, ticketsPerPoint, hasGameData, publicNotifications, useMatchingAlgorithm, globalTickets, buildVersion, apiVersion, placementName, placementDescription, placementSize, placementHeight, placementWidth, placementRefreshInterval, createObjectStore, publicContentApproval, productionMode, minimumSessionLength, sessionGapLength, localAdsEnabled, sqootApiKey, trilatProcessingType, maxSampleSize, minRSSI, modules, authorizedCount, authorizedServers, defaultTimezone, smtpPass, metaData, placementMetaData, ipsFloor, enableAPNSBadge, includeInReport, defaultAppFilterId, enableWelcomeEmail, appleAppId, appleTeamId, appleAuthKeyId, appleAuthKey, appleIssuerId, appStoreKeyId, appStoreKey, googlePrivateKeyFile, authorizeNetApiKey, authorizeNetTransactionKey, emailSender, smtpUser, smtpHost, vatomBusinessId, vatomRestClientId, vatomRestSecretKey, twilioAccountSID, twilioAuthToken, twilioSenderPhoneNumber, openAISecretKey, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/application/active")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Change Appliation Status", notes = "Set the application's active flag to true/false. This effectively activates or deactivates the application.", response = SirqulResponse.class, tags={ "Application", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response updateApplicationActive(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The account used to perform the delete, must have rights to edit the application.", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "The key of the application to be deleted", required = true) @QueryParam("appKey") @NotNull  String appKey,@ApiParam(value = "If true then set to active, false otherwise", required = true) @QueryParam("active") @NotNull  Boolean active,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.updateApplicationActive(version, accountId, appKey, active, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/appconfig/update")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Update AppConfig", notes = "pdates an existing application configuration. If the configVersion provided already exists for the given app the application configuration won't be updated.", response = ApplicationConfigResponse.class, tags={ "Application Config", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = ApplicationConfigResponse.class)
    })
    public Response updateApplicationConfig(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The account ID of the user", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "The config ID of the application configuration to update", required = true) @QueryParam("configId") @NotNull  Long configId,@ApiParam(value = "The application key that the updated applicationConfig will be associated to") @QueryParam("appKey")  String appKey,@ApiParam(value = "The application configuration, has to be unique within the application") @QueryParam("configVersion")  String configVersion,@ApiParam(value = "The json assetId that stores the configuration detail.") @QueryParam("assetId")  Long assetId,@ApiParam(value = "The retailer id for retailer specific configurations") @QueryParam("retailerId")  Long retailerId,@ApiParam(value = "The retailer location id for retailer location specific configurations") @QueryParam("retailerLocationId")  Long retailerLocationId,@ApiParam(value = "The device udid for device specific configurations") @QueryParam("udid")  String udid,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.updateApplicationConfig(version, accountId, configId, appKey, configVersion, assetId, retailerId, retailerLocationId, udid, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/application/placement/update")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Update Ad Placement", notes = "Updates an ad placement for an application.", response = PlacementResponse.class, tags={ "Application", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = PlacementResponse.class)
    })
    public Response updateApplicationPlacement(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The id of the placement to update, the user must have rights to the application the ad placement is for", required = true) @QueryParam("placementId") @NotNull  Long placementId,@ApiParam(value = "The unique id of the device making the request (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "The account id of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "The name of the placement") @QueryParam("name")  String name,@ApiParam(value = "The description of the placement") @QueryParam("description")  String description,@ApiParam(value = "The ad placement size {BANNER, LEADERBOARD, SKYSCRAPER, INTERSTITIAL, CUSTOM", allowableValues="CONFIG, BANNER, LEADERBOARD, SKYSCRAPER, VIDEO, ZIP, INTERSTITIAL, CUSTOM1, CUSTOM2, CUSTOM3, CUSTOM4, CUSTOM5, CUSTOM6, CUSTOM7, CUSTOM8, CUSTOM9, CUSTOM10") @QueryParam("size")  String size,@ApiParam(value = "The height of a custom ad size") @QueryParam("height")  Integer height,@ApiParam(value = "The width of a custom ad size") @QueryParam("width")  Integer width,@ApiParam(value = "The refresh interval in seconds") @QueryParam("refreshInterval")  Integer refreshInterval,@ApiParam(value = "Default Image Id") @QueryParam("defaultImageId")  Long defaultImageId,@ApiParam(value = "Active") @QueryParam("active")  Boolean active,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.updateApplicationPlacement(version, placementId, deviceId, accountId, name, description, size, height, width, refreshInterval, defaultImageId, active, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/asset/update")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Update Asset", notes = "Updates an asset's meta data. If an album reference is passed in, the participants with write permissions are allowed to edit the asset. Otherwise, only the asset up-loader has permission to edit the data.", response = SirqulResponse.class, tags={ "Asset", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response updateAsset(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the ID of the asset to update", required = true) @QueryParam("assetId") @NotNull  Long assetId,@ApiParam(value = "a unique ID given by the device (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "the account ID of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "the ID of the album to check user permissions") @QueryParam("albumId")  Long albumId,@ApiParam(value = "the ID of the attached asset") @QueryParam("attachedAssetId")  Long attachedAssetId,@ApiParam(value = "the version code") @QueryParam("versionCode")  Integer versionCode,@ApiParam(value = "the version name") @QueryParam("versionName")  String versionName,@ApiParam(value = "External custom client defined data") @QueryParam("metaData")  String metaData,@ApiParam(value = "the caption") @QueryParam("caption")  String caption,@ApiParam(value = "the asset type") @QueryParam("assetType")  String assetType,@ApiParam(value = "approval status for the asset") @QueryParam("approvalStatus")  String approvalStatus,@ApiParam(value = "account id assigned to the asset") @QueryParam("assignedAccountId")  Long assignedAccountId,@ApiParam(value = "a MultipartFile containing the mimetype, etc") @QueryParam("media")  File media,@ApiParam(value = "this can be used if the \"media\" is a link (optional)") @QueryParam("mediaUrl")  String mediaUrl,@ApiParam(value = "the media content as a string (optional)") @QueryParam("mediaString")  String mediaString,@ApiParam(value = "file name for mediaString (optional)") @QueryParam("mediaStringFileName")  String mediaStringFileName,@ApiParam(value = "content type for mediaString (optional)") @QueryParam("mediaStringContentType")  String mediaStringContentType,@ApiParam(value = "the media height (optional)") @QueryParam("mediaHeight")  Integer mediaHeight,@ApiParam(value = "the media width (optional)") @QueryParam("mediaWidth")  Integer mediaWidth,@ApiParam(value = "a MultipartFile containing an asset that the \"media\" file references (optional). Example: to upload a video the \"media\" file should contain a screen capture and the \"attachedMedia\" should be the actual video.") @QueryParam("attachedMedia")  File attachedMedia,@ApiParam(value = "this can be used if the \"attachedMedia\" is a link (i.e. a Youtube video, etc) (optional)") @QueryParam("attachedMediaUrl")  String attachedMediaUrl,@ApiParam(value = "attached media content as a string (optional)") @QueryParam("attachedMediaString")  String attachedMediaString,@ApiParam(value = "file name for attachedMediaString (optional)") @QueryParam("attachedMediaStringFileName")  String attachedMediaStringFileName,@ApiParam(value = "content type for attachedMediaString (optional)") @QueryParam("attachedMediaStringContentType")  String attachedMediaStringContentType,@ApiParam(value = "the attached media height (optional)") @QueryParam("attachedMediaHeight")  Integer attachedMediaHeight,@ApiParam(value = "the attached media width (optional)") @QueryParam("attachedMediaWidth")  Integer attachedMediaWidth,@ApiParam(value = "the location description") @QueryParam("locationDescription")  String locationDescription,@ApiParam(value = "search tags") @QueryParam("searchTags")  String searchTags,@ApiParam(value = "the application key") @QueryParam("appKey")  String appKey,@ApiParam(value = "latitude used to update the asset's location") @QueryParam("latitude")  Double latitude,@ApiParam(value = "longitude used to update the asset's location") @QueryParam("longitude")  Double longitude,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.updateAsset(version, assetId, deviceId, accountId, albumId, attachedAssetId, versionCode, versionName, metaData, caption, assetType, approvalStatus, assignedAccountId, media, mediaUrl, mediaString, mediaStringFileName, mediaStringContentType, mediaHeight, mediaWidth, attachedMedia, attachedMediaUrl, attachedMediaString, attachedMediaStringFileName, attachedMediaStringContentType, attachedMediaHeight, attachedMediaWidth, locationDescription, searchTags, appKey, latitude, longitude, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/audience/update")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Update Audience", notes = "Update a user defined audience.", response = AudienceResponse.class, tags={ "Audience", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = AudienceResponse.class)
    })
    public Response updateAudience(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The logged in user.", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "The id of the audience to update.", required = true) @QueryParam("audienceId") @NotNull  Long audienceId,@ApiParam(value = "The name of the audience") @QueryParam("name")  String name,@ApiParam(value = "The description of the audience") @QueryParam("description")  String description,@ApiParam(value = "The search tags") @QueryParam("searchTags")  String searchTags,@ApiParam(value = "The gender; possible values are: MALE, FEMALE, ANY") @QueryParam("gender")  String gender,@ApiParam(value = "The list of age groups, comma separated; possible values are AGE_0_13, AGE_14_17, AGE_18_22, AGE_23_30, AGE_31_54, AGE_55_PLUS, AGE_ANY (to reset to none)") @QueryParam("ageGroups")  String ageGroups,@ApiParam(value = "The list of category ids, comma separated; possible values are retrieved via /api/{version}/category/search (pass in id values)") @QueryParam("categoryIds")  String categoryIds,@ApiParam(value = "The list of application ids, comma separated; possible values are retrieved via /api/{version}/application/list (pass in id values)") @QueryParam("applicationIds")  String applicationIds,@ApiParam(value = "The experience level of the player; possible values are: ANY, NEW, BEGINNER, INTERMEDIATE, EXPERT") @QueryParam("gameExperienceLevel")  String gameExperienceLevel,@ApiParam(value = "(Deprecated) Use deviceIds. The list of targeted device names, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in name values)") @QueryParam("devices")  String devices,@ApiParam(value = "The list of targeted device ids, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in id values)") @QueryParam("deviceIds")  String deviceIds,@ApiParam(value = "The list of targeted device version ranges that are aligned with the provided devices list, comma separated (examples: 2.3-X, 0-5.1.4, 4.3.1-6.1.4)") @QueryParam("deviceVersions")  String deviceVersions,@ApiParam(value = "The list of locations to build the center around; comma separated list of latitude/longitude pairs (example: lat1,long1,lat2,long2)") @QueryParam("locations")  String locations,@ApiParam(value = "The list of radius of influence for the audience, in miles; comma separated list. Either provide 1 to be applied to all location pairs or a matching list to each lat/long pair.") @QueryParam("radius")  String radius,@ApiParam(value = "if audience is active") @QueryParam("active")  Boolean active,@ApiParam(value = "If true, then notify matching users when they are inside the radius") @QueryParam("sendSuggestion")  Boolean sendSuggestion,@ApiParam(value = "Seconds from the start time of an event") @QueryParam("startTimeOffset")  Integer startTimeOffset,@ApiParam(value = "Seconds from the end time of an event") @QueryParam("endTimeOffset")  Integer endTimeOffset,@ApiParam(value = "the associate description") @QueryParam("associateDescription")  String associateDescription,@ApiParam(value = "The type of the object to center the audience geofence") @QueryParam("associateType")  String associateType,@ApiParam(value = "The ID of the object to center the audience geofence") @QueryParam("associateId")  Long associateId,@ApiParam(value = "Optional grouping id for the audience") @QueryParam("groupingId")  String groupingId,@ApiParam(value = "External custom client defined data") @QueryParam("metaData")  String metaData,@ApiParam(value = "Visibility of the audience") @QueryParam("visibility")  String visibility,@ApiParam(value = "Type of audience") @QueryParam("audienceType")  String audienceType,@ApiParam(value = "Use order for cohort") @QueryParam("useOrder")  Boolean useOrder,@ApiParam(value = "Cohort data for \"cohort\" audience type") @QueryParam("cohortRegionsData")  String cohortRegionsData,@ApiParam(value = "Filter results by application key") @QueryParam("appKey")  String appKey,@ApiParam(value = "Trilateration types") @QueryParam("trilaterationTypes")  String trilaterationTypes,@ApiParam(value = "If true, makes sure the audience name is unique") @QueryParam("uniqueName")  Boolean uniqueName,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.updateAudience(version, accountId, audienceId, name, description, searchTags, gender, ageGroups, categoryIds, applicationIds, gameExperienceLevel, devices, deviceIds, deviceVersions, locations, radius, active, sendSuggestion, startTimeOffset, endTimeOffset, associateDescription, associateType, associateId, groupingId, metaData, visibility, audienceType, useOrder, cohortRegionsData, appKey, trilaterationTypes, uniqueName, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/bid/update")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Update Bid", notes = "Updates a bid on a biddable object", response = BidResponse.class, tags={ "Bid", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = BidResponse.class)
    })
    public Response updateBid(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The bid id", required = true) @QueryParam("bidId") @NotNull  Long bidId,@ApiParam(value = "The device id (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "The account id of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "The bid amount for views. For ads, this is the amount that will be taken for each impression.") @QueryParam("amountPerView")  Double amountPerView,@ApiParam(value = "The bid amount for actions. For ads, this is the amount that will be taken for each click.") @QueryParam("amountPerAction")  Double amountPerAction,@ApiParam(value = "The allocated budget amount that will be used") @QueryParam("budgetAmount")  Double budgetAmount,@ApiParam(value = "The schedule for when the allocated budget amount is reset") @QueryParam("budgetSchedule")  String budgetSchedule,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.updateBid(version, bidId, deviceId, accountId, amountPerView, amountPerAction, budgetAmount, budgetSchedule, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/billable/update")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Update Billable", notes = "Updates the billable record for an account", response = BillableEntityResponse.class, tags={ "Billable Entity", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = BillableEntityResponse.class)
    })
    public Response updateBillableEntity(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The unique device identifier that made the request (either deviceId or accountId must be used)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "The unique accountId that made the request (either deviceId or accountId must be used). The account must have rights to edit the billable entity.") @QueryParam("accountId")  Long accountId,@ApiParam(value = "The name of the entity responsible for billing ") @QueryParam("name")  String name,@ApiParam(value = "The street address of the billable entity") @QueryParam("streetAddress")  String streetAddress,@ApiParam(value = "Additional address information (such as a suite number, floor number, building name, or PO Box) ") @QueryParam("streetAddress2")  String streetAddress2,@ApiParam(value = "The city of the billable entity") @QueryParam("city")  String city,@ApiParam(value = "The state of the billable entity") @QueryParam("state")  String state,@ApiParam(value = "The postal code of the billable entity") @QueryParam("postalCode")  String postalCode,@ApiParam(value = "The business phone of the billable entity") @QueryParam("businessPhone")  String businessPhone,@ApiParam(value = "The business phone extension of the billable entity") @QueryParam("businessPhoneExt")  String businessPhoneExt,@ApiParam(value = "Authorize Net Api Key of the billable entity") @QueryParam("authorizeNetApiKey")  String authorizeNetApiKey,@ApiParam(value = "Authorize Net Transaction Key of the billable entity") @QueryParam("authorizeNetTransactionKey")  String authorizeNetTransactionKey,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.updateBillableEntity(version, deviceId, accountId, name, streetAddress, streetAddress2, city, state, postalCode, businessPhone, businessPhoneExt, authorizeNetApiKey, authorizeNetTransactionKey, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/vatom/b/coins/update")
    
    
    @io.swagger.annotations.ApiOperation(value = "Fund coins for a Business", notes = "Fund/update coins for a Businesss.", response = Void.class, tags={ "Vatom", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = Void.class)
    })
    public Response updateBusinessCoins(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "Sirqul Account Id", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "Sirqul Application Key", required = true) @QueryParam("appKey") @NotNull  String appKey,@ApiParam(value = "Vatom Parameters", required = true) @QueryParam("vatomParameters") @NotNull  String vatomParameters,@ApiParam(value = "Return raw response") @QueryParam("returnRawResponse")  Boolean returnRawResponse,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.updateBusinessCoins(version, accountId, appKey, vatomParameters, returnRawResponse, securityContext);
    }
    @javax.ws.rs.PUT
    @Path("/cargo/type/{cargoTypeId}")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Update Cargo Type", notes = "Update an existing cargo type", response = CargoType.class, tags={ "Cargo Type", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = CargoType.class)
    })
    public Response updateCargoType(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the ID of the cargo type", required = true) @PathParam("cargoTypeId") @NotNull  Long cargoTypeId,@ApiParam(value = "") @Valid  CargoType body,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.updateCargoType(version, cargoTypeId, body, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/category/update")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Update Category", notes = "Update a category.", response = CategoryTreeResponse.class, tags={ "Category", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = CategoryTreeResponse.class)
    })
    public Response updateCategory(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The account id of the user", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "The ID of the category to edit", required = true) @QueryParam("categoryId") @NotNull  Long categoryId,@ApiParam(value = "The ID of the parent category, if not provided then the parent category will be null") @QueryParam("parentCategoryId")  Long parentCategoryId,@ApiParam(value = "The name of the category") @QueryParam("name")  String name,@ApiParam(value = "The description of the category") @QueryParam("description")  String description,@ApiParam(value = "The type of the category") @QueryParam("type")  String type,@ApiParam(value = "The ID of the image asset previously uploaded using the media service") @QueryParam("assetId")  Long assetId,@ApiParam(value = "A string identifier used by client applications to store external information") @QueryParam("externalId")  String externalId,@ApiParam(value = "A string type used by client applications to store external information") @QueryParam("externalType")  String externalType,@ApiParam(value = "external category slug") @QueryParam("externalCategorySlug")  String externalCategorySlug,@ApiParam(value = "sqoot slug") @QueryParam("sqootSlug")  String sqootSlug,@ApiParam(value = "Sets whether the category is active or inactive (hidden from consumers)") @QueryParam("active")  Boolean active,@ApiParam(value = "external custom client defined data") @QueryParam("metaData")  String metaData,@ApiParam(value = "user defined strings for searching") @QueryParam("searchTags")  String searchTags,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.updateCategory(version, accountId, categoryId, parentCategoryId, name, description, type, assetId, externalId, externalType, externalCategorySlug, sqootSlug, active, metaData, searchTags, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/creative/update")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Update Creative", notes = "Update a creative", response = CreativeResponse.class, tags={ "Creative", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = CreativeResponse.class)
    })
    public Response updateCreative(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The logged in user.", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "the creative Id to upate.", required = true) @QueryParam("creativeId") @NotNull  Long creativeId,@ApiParam(value = "The name of the level.") @QueryParam("name")  String name,@ApiParam(value = "The description of the level.") @QueryParam("description")  String description,@ApiParam(value = "The asset Id of the level image.") @QueryParam("assetImageId")  Long assetImageId,@ApiParam(value = "This parameter is deprecated. deprecated use data field") @QueryParam("action")  String action,@ApiParam(value = "The creative data, json based format depending on type") @QueryParam("data")  String data,@ApiParam(value = "This parameter is deprecated. deprecated use type field") @QueryParam("suffix")  String suffix,@ApiParam(value = "The type of creative.") @QueryParam("type")  String type,@ApiParam(value = "Set the amount of money available to spend, once 0 deactivate level. Set to a negative value for unlimited.") @QueryParam("balance")  Double balance,@ApiParam(value = "If true set the game level as active. Default is false.") @QueryParam("active")  Boolean active,@ApiParam(value = "if creative related so some other content provided the id") @QueryParam("referenceId")  Long referenceId,@ApiParam(value = "The version of the application, will not return creatives newer than the appVersion. Only used when requesting application configuration creatives.") @QueryParam("appVersion")  String appVersion,@ApiParam(value = "Assign the creative to a campaign for timing and audience matching.") @QueryParam("missionId")  Long missionId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.updateCreative(version, accountId, creativeId, name, description, assetImageId, action, data, suffix, type, balance, active, referenceId, appVersion, missionId, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/thirdparty/credential/update")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Update Credential", notes = "Updates a third-party login for an account.", response = ProfileResponse.class, tags={ "ThirdParty Credentials", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = ProfileResponse.class)
    })
    public Response updateCredential(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the access provider to authenticate against", required = true) @QueryParam("networkUID") @NotNull  String networkUID,@ApiParam(value = "the third party user account id", required = true) @QueryParam("thirdPartyId") @NotNull  String thirdPartyId,@ApiParam(value = "the application key", required = true) @QueryParam("appKey") @NotNull  String appKey,@ApiParam(value = "the unique id of the device making the request") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "the third party user name") @QueryParam("thirdPartyName")  String thirdPartyName,@ApiParam(value = "the access token to authenticate with (ex: username or fb token)") @QueryParam("thirdPartyToken")  String thirdPartyToken,@ApiParam(value = "this determines how much of the profile should be returned, see ProfileFilters") @QueryParam("responseFilters")  String responseFilters,@ApiParam(value = "External custom client defined data") @QueryParam("metaData")  String metaData,@ApiParam(value = "optional refresh token for the third party") @QueryParam("thirdPartyRefreshToken")  String thirdPartyRefreshToken,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.updateCredential(version, networkUID, thirdPartyId, appKey, deviceId, thirdPartyName, thirdPartyToken, responseFilters, metaData, thirdPartyRefreshToken, securityContext);
    }
    @javax.ws.rs.PUT
    @Path("/object/data/{objectName}/{objectId}")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Update Data", notes = "Update a record for the specified object.  If the object does not exist the request will be rejected, use the data create service for the first entry. If any of the fields included does not exist for the object then they are added to the object.", response = ObjectStoreResponse.class, tags={ "Object Store", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = ObjectStoreResponse.class)
    })
    public Response updateData(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The name of the object to search upon", required = true) @PathParam("objectName") @NotNull  String objectName,@ApiParam(value = "objectId The id of the record to return", required = true) @PathParam("objectId") @NotNull  String objectId,@ApiParam(value = "The account id of the logged in user") @QueryParam("accountId")  Long accountId,@ApiParam(value = "")  String body,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.updateData(version, objectName, objectId, accountId, body, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/disbursement/update")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Update Disbursement", notes = "Update Disbursement", response = DisbursementResponse.class, tags={ "Disbursement", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = DisbursementResponse.class)
    })
    public Response updateDisbursement(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the id of the logged in user", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "the id of the disbursement being updated", required = true) @QueryParam("disbursementId") @NotNull  Long disbursementId,@ApiParam(value = "the disbursement dollar amount being updated") @QueryParam("amount")  BigDecimal amount,@ApiParam(value = "the payments and/or billing provider (e.g. Authorize.net, Bill.com, etc.)", allowableValues="AUTHORIZE_NET, AMAZON_FPS, BILL_COM") @QueryParam("provider")  String provider,@ApiParam(value = "the date that the disbursement is scheduled to go out to the payment provider") @QueryParam("scheduledDate")  Long scheduledDate,@ApiParam(value = "the title given to the disbursement") @QueryParam("title")  String title,@ApiParam(value = "a comment that can be made on a disbursement") @QueryParam("comment")  String comment,@ApiParam(value = "an external ID that can be used to reference the disbursement") @QueryParam("externalId")  String externalId,@ApiParam(value = "determines whether to try sending the disbursement again in the case of a previous failure") @QueryParam("retry")  Boolean retry,@ApiParam(value = "for specifying parameters to make an http callback request for validating that the disbursement is valid") @QueryParam("introspectionParams")  String introspectionParams,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.updateDisbursement(version, accountId, disbursementId, amount, provider, scheduledDate, title, comment, externalId, retry, introspectionParams, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/employee/update")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Update Employee", notes = "Update the account record with the provided information.", response = EmployeeResponse.class, tags={ "Employee", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = EmployeeResponse.class)
    })
    public Response updateEmployee(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The account id of the logged in user", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "the id of the employee account", required = true) @QueryParam("employeeAccountId") @NotNull  Long employeeAccountId,@ApiParam(value = "The account id of the manager to assign under") @QueryParam("managerAccountId")  Long managerAccountId,@ApiParam(value = "a name field") @QueryParam("name")  String name,@ApiParam(value = "The name prefix; Mr, Mrs, etc") @QueryParam("prefixName")  String prefixName,@ApiParam(value = "The first name") @QueryParam("firstName")  String firstName,@ApiParam(value = "The middle name") @QueryParam("middleName")  String middleName,@ApiParam(value = "The last name") @QueryParam("lastName")  String lastName,@ApiParam(value = "The name suffix; Jr, Sr, III, etc") @QueryParam("suffixName")  String suffixName,@ApiParam(value = "The title of the user") @QueryParam("title")  String title,@ApiParam(value = "the asset id to set the user's profile image") @QueryParam("assetId")  Long assetId,@ApiParam(value = "The gender {MALE, FEMALE, ANY}", allowableValues="MALE, FEMALE, ANY") @QueryParam("gender")  String gender,@ApiParam(value = "The home phone number") @QueryParam("homePhone")  String homePhone,@ApiParam(value = "The cellular phone number") @QueryParam("cellPhone")  String cellPhone,@ApiParam(value = "The cellular service provider. This is required for sending SMS. Leave this empty if the provider is not on the list of supported carriers. Supported Carriers: {ATT, QWEST, T_MOBILE, VERIZON, SPRINT, VIRIGIN_MOBILE, NEXTEL, ALLTEL, METRO_PCS, POWERTEL, BOOST_MOBILE, SUNCOM, TRACFONE, US_CELLULAR}") @QueryParam("cellPhoneCarrier")  String cellPhoneCarrier,@ApiParam(value = "The business phone number") @QueryParam("businessPhone")  String businessPhone,@ApiParam(value = "The user's contact email address (NOT the username)") @QueryParam("emailAddress")  String emailAddress,@ApiParam(value = "The street address of the user's contact location") @QueryParam("streetAddress")  String streetAddress,@ApiParam(value = "Additional address information (such as a suite number, floor number, building name, or PO Box)") @QueryParam("streetAddress2")  String streetAddress2,@ApiParam(value = "The city of the user's contact location") @QueryParam("city")  String city,@ApiParam(value = "The state of the user's contact location") @QueryParam("state")  String state,@ApiParam(value = "The zipcode of the user's contact location") @QueryParam("zipcode")  String zipcode,@ApiParam(value = "The country of the user's contact location") @QueryParam("country")  String country,@ApiParam(value = "The role; RETAILER or RETAILER_LIMITED, defaulted to RETAILER_LIMITED") @QueryParam("role")  String role,@ApiParam(value = "Sets whether the employee is active or inactive") @QueryParam("active")  Boolean active,@ApiParam(value = "Sets the password for the employee") @QueryParam("password")  String password,@ApiParam(value = "Sets which retailer locations the employee is assigned to") @QueryParam("retailerLocationIds")  String retailerLocationIds,@ApiParam(value = "Determines whether to return the application settings for the employee for a particular application") @QueryParam("settingsAppKey")  String settingsAppKey,@ApiParam(value = "external custom client defined data (per Application)") @QueryParam("appBlob")  String appBlob,@ApiParam(value = "The device id to assign to the user (used for IPS beacon tracking)") @QueryParam("assignedDeviceId")  String assignedDeviceId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.updateEmployee(version, accountId, employeeAccountId, managerAccountId, name, prefixName, firstName, middleName, lastName, suffixName, title, assetId, gender, homePhone, cellPhone, cellPhoneCarrier, businessPhone, emailAddress, streetAddress, streetAddress2, city, state, zipcode, country, role, active, password, retailerLocationIds, settingsAppKey, appBlob, assignedDeviceId, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/event/update")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Update Event", notes = "Update a private event to share with associates.", response = OfferResponse.class, tags={ "Event", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = OfferResponse.class)
    })
    public Response updateEvent(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The logged in user.", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "The id of the event to update", required = true) @QueryParam("eventId") @NotNull  Long eventId,@ApiParam(value = "The retailer location to have the event at") @QueryParam("retailerLocationIds")  String retailerLocationIds,@ApiParam(value = "The event title") @QueryParam("title")  String title,@ApiParam(value = "The event sub title") @QueryParam("subTitle")  String subTitle,@ApiParam(value = "The event details") @QueryParam("details")  String details,@ApiParam(value = "The categories the associate the event with") @QueryParam("categoryIds")  String categoryIds,@ApiParam(value = "The filters the associate the event with") @QueryParam("filterIds")  String filterIds,@ApiParam(value = "Is this event active") @QueryParam("active")  Boolean active,@ApiParam(value = "The image to show for the event") @QueryParam("imageAssetId")  Long imageAssetId,@ApiParam(value = "The event start date/time") @QueryParam("redeemableStart")  Long redeemableStart,@ApiParam(value = "The event end date/time") @QueryParam("redeemableEnd")  Long redeemableEnd,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.updateEvent(version, accountId, eventId, retailerLocationIds, title, subTitle, details, categoryIds, filterIds, active, imageAssetId, redeemableStart, redeemableEnd, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/vatom/b/events/guests/update")
    
    
    @io.swagger.annotations.ApiOperation(value = "Update Vatom Event Guest List", notes = "Update the guest list of an event.", response = Void.class, tags={ "Vatom", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = Void.class)
    })
    public Response updateEventGuestList(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "Sirqul Account Id", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "Sirqul Application Key", required = true) @QueryParam("appKey") @NotNull  String appKey,@ApiParam(value = "Vatom Event Id", required = true) @QueryParam("vatomEventId") @NotNull  String vatomEventId,@ApiParam(value = "Vatom Parameters", required = true) @QueryParam("vatomParameters") @NotNull  String vatomParameters,@ApiParam(value = "Return raw response") @QueryParam("returnRawResponse")  Boolean returnRawResponse,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.updateEventGuestList(version, accountId, appKey, vatomEventId, vatomParameters, returnRawResponse, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/filter/update")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Update Filter", notes = "Update a filter.", response = FilterTreeResponse.class, tags={ "Filter", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = FilterTreeResponse.class)
    })
    public Response updateFilter(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The account id of the user", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "The ID of the filter to edit", required = true) @QueryParam("filterId") @NotNull  Long filterId,@ApiParam(value = "The ID of the parent filter, if not provided then the parent filter will be null") @QueryParam("parentFilterId")  Long parentFilterId,@ApiParam(value = "The name of the filter") @QueryParam("name")  String name,@ApiParam(value = "The description of the filter") @QueryParam("description")  String description,@ApiParam(value = "A string identifier used by client applications to store external information") @QueryParam("externalId")  String externalId,@ApiParam(value = "A string type used by client applications to store external information") @QueryParam("externalType")  String externalType,@ApiParam(value = "Sets whether the filter is active or inactive (hidden from consumers)") @QueryParam("active")  Boolean active,@ApiParam(value = "external custom client defined data") @QueryParam("metaData")  String metaData,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.updateFilter(version, accountId, filterId, parentFilterId, name, description, externalId, externalType, active, metaData, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/flag/threshold/update")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Update Flag Threshold", notes = "Update the flag threshold on an object type for a particular application.", response = CountResponse.class, tags={ "Flag", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = CountResponse.class)
    })
    public Response updateFlagThreshold(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The flagable object type {ACCOUNT, ALBUM, ALBUM_CONTEST, ASSET, GAME_LEVEL, THEME_DESCRIPTOR, OFFER, NOTE}", required = true) @QueryParam("itemBeingFlaggedType") @NotNull  String itemBeingFlaggedType,@ApiParam(value = "The threshold value", required = true) @QueryParam("threshold") @NotNull  Long threshold,@ApiParam(value = "The application key", required = true) @QueryParam("appKey") @NotNull  String appKey,@ApiParam(value = "The unique device identifier that made the request (either deviceId or accountId must be used)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "The unique accountId that made the request (either deviceId or accountId must be used)") @QueryParam("accountId")  Long accountId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.updateFlagThreshold(version, itemBeingFlaggedType, threshold, appKey, deviceId, accountId, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/game/update")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Update a Game", notes = "Update a Game", response = GameResponse.class, tags={ "Game", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = GameResponse.class)
    })
    public Response updateGame(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The logged in user.") @QueryParam("accountId")  Long accountId,@ApiParam(value = "the updating game's id") @QueryParam("gameId")  Long gameId,@ApiParam(value = "The game application key to save the level for.") @QueryParam("appKey")  String appKey,@ApiParam(value = "Title of the Game.") @QueryParam("title")  String title,@ApiParam(value = "Description of the Game.") @QueryParam("description")  String description,@ApiParam(value = "metaData of the Game.") @QueryParam("metaData")  String metaData,@ApiParam(value = "comma separated String of pack Ids that will associate with the game.") @QueryParam("packIds")  String packIds,@ApiParam(value = "show more details in response.") @QueryParam("includeGameData")  Boolean includeGameData,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.updateGame(version, accountId, gameId, appKey, title, description, metaData, packIds, includeGameData, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/level/update")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Update Game Level", notes = "Update a game level. Currently does NOT support game objects.", response = GameLevelResponse.class, tags={ "Game Level", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = GameLevelResponse.class)
    })
    public Response updateGameLevel(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The logged in user.", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "If update then include the level Id.", required = true) @QueryParam("levelId") @NotNull  Long levelId,@ApiParam(value = "The game application key to save the level for.") @QueryParam("appKey")  String appKey,@ApiParam(value = "The name of the level.") @QueryParam("name")  String name,@ApiParam(value = "The description of the level.") @QueryParam("description")  String description,@ApiParam(value = "The difficulty, possible values are: VERY_EASY, EASY, MEDIUM, HARD, VERY_HARD.") @QueryParam("difficulty")  String difficulty,@ApiParam(value = "The version number of the applicatuion required to correctly load/play the level.") @QueryParam("appVersion")  String appVersion,@ApiParam(value = "The asset Id of the level image.") @QueryParam("assetImageId")  Long assetImageId,@ApiParam(value = "The asset Id of the level icon.") @QueryParam("assetIconId")  Long assetIconId,@ApiParam(value = "The game level data: xml, json, or other texted based format.") @QueryParam("gameData")  String gameData,@ApiParam(value = "The game level data format type.") @QueryParam("gameDataSuffix")  String gameDataSuffix,@ApiParam(value = "Is the level visible to others, possible values are: PUBLIC, PRIVATE.") @QueryParam("visibility")  String visibility,@ApiParam(value = "Make the level be readable by all friends.") @QueryParam("friendGroup")  Boolean friendGroup,@ApiParam(value = "Make the level be readable by connections in this list.") @QueryParam("connectionIds")  String connectionIds,@ApiParam(value = "Make the level be readable by connection groups in this list.") @QueryParam("connectionGroupIds")  String connectionGroupIds,@ApiParam(value = "Set the amount of money available to spend, once 0 deactivate level. Set to a negative value for unlimited.") @QueryParam("balance")  Double balance,@ApiParam(value = "If true set the game level as active.") @QueryParam("active")  Boolean active,@ApiParam(value = "If true then scoring will give tickets.") @QueryParam("allocateTickets")  Boolean allocateTickets,@ApiParam(value = "The number of tickets to reward") @QueryParam("ticketCount")  Long ticketCount,@ApiParam(value = "The type of ticket to reward, null means default type") @QueryParam("ticketType")  String ticketType,@ApiParam(value = "The number of points to award for completing a level") @QueryParam("points")  Long points,@ApiParam(value = "Title of the tutorial.") @QueryParam("tutorialTitle")  String tutorialTitle,@ApiParam(value = "Message of the tutorial.") @QueryParam("tutorialMessage")  String tutorialMessage,@ApiParam(value = "Alignment of the tutorial image, possible values are: NONE, IMAGE_ABOVE, IMAGE_BELOW, IMAGE_LEFT, IMAGE_RIGHT, IMAGE_ONLY, TEXT_ONLY") @QueryParam("tutorialAlignment")  String tutorialAlignment,@ApiParam(value = "Asset id of the tutorial image.") @QueryParam("tutorialImageAssetId")  Long tutorialImageAssetId,@ApiParam(value = "") @QueryParam("offerId")  Long offerId,@ApiParam(value = "external custom client defined data") @QueryParam("metaData")  String metaData,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.updateGameLevel(version, accountId, levelId, appKey, name, description, difficulty, appVersion, assetImageId, assetIconId, gameData, gameDataSuffix, visibility, friendGroup, connectionIds, connectionGroupIds, balance, active, allocateTickets, ticketCount, ticketType, points, tutorialTitle, tutorialMessage, tutorialAlignment, tutorialImageAssetId, offerId, metaData, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/leaderboard/update")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Update a leaderboard based on the rankingType, rankMode(leaderboardMode), sortField and limitation", notes = "Update a leaderboard based on the rankingType, rankMode(leaderboardMode), sortField and limitation", response = LeaderboardResponse.class, tags={ "Leaderboard", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = LeaderboardResponse.class)
    })
    public Response updateLeaderboard(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The leaderboard id to update.", required = true) @QueryParam("leaderboardId") @NotNull  Long leaderboardId,@ApiParam(value = "The account id of the user updating the leaderboard.") @QueryParam("accountId")  Long accountId,@ApiParam(value = "The application key") @QueryParam("appKey")  String appKey,@ApiParam(value = "a unique label for identifying the ranking. This can be any alphanumeric string with a maximum length of 64 characters.") @QueryParam("rankType")  String rankType,@ApiParam(value = "the type of search to perform. Possible values include: GLOBAL, LOCAL, SEARCH, CUSTOM") @QueryParam("leaderboardMode")  String leaderboardMode,@ApiParam(value = "determines how to order and rank the results. Possible values include: TOTAL, WEEKLY, DAILY, TOP, LOWEST") @QueryParam("sortField")  String sortField,@ApiParam(value = "a MultipartFile containing the icon image of the leaderboard (this will only be used if \"iconAssetId\" is empty)") @QueryParam("iconMedia")  File iconMedia,@ApiParam(value = "The asset ID to set the leaderboard icon") @QueryParam("iconAssetId")  Long iconAssetId,@ApiParam(value = "a MultipartFile containing the icon banner of the leaderboard (this will only be used if \"bannerAssetId\" is empty)") @QueryParam("bannerMedia")  File bannerMedia,@ApiParam(value = "The asset ID to set the leaderboard banner") @QueryParam("bannerAssetId")  Long bannerAssetId,@ApiParam(value = "limit number of rankings for each leaderboard") @QueryParam("limitation")  Integer limitation,@ApiParam(value = "Whether the leaderboard is active") @QueryParam("active")  Boolean active,@ApiParam(value = "leaderboard's title") @QueryParam("title")  String title,@ApiParam(value = "leaderboard's description") @QueryParam("description")  String description,@ApiParam(value = "custom meta data for the leaderboard") @QueryParam("metaData")  String metaData,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.updateLeaderboard(version, leaderboardId, accountId, appKey, rankType, leaderboardMode, sortField, iconMedia, iconAssetId, bannerMedia, bannerAssetId, limitation, active, title, description, metaData, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/listing/update")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Update Listing", notes = "Updates a listing.", response = ListingFullResponse.class, tags={ "Listing", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = ListingFullResponse.class)
    })
    public Response updateListing(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the user's account ID", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "the listing to update", required = true) @QueryParam("listingId") @NotNull  Long listingId,@ApiParam(value = "comma separated list of filter IDs") @QueryParam("filterIds")  String filterIds,@ApiParam(value = "the name of the listing") @QueryParam("name")  String name,@ApiParam(value = "the description of the listing") @QueryParam("description")  String description,@ApiParam(value = "the start date of the listing") @QueryParam("start")  Long start,@ApiParam(value = "the end date of the listing") @QueryParam("end")  Long end,@ApiParam(value = "the name of the location the listing will be held at") @QueryParam("locationName")  String locationName,@ApiParam(value = "the description of the location the listing will be held at") @QueryParam("locationDescription")  String locationDescription,@ApiParam(value = "determines whether the listing is public or private") @QueryParam("isPrivate")  Boolean isPrivate,@ApiParam(value = "external identifier used by a third party") @QueryParam("externalId")  String externalId,@ApiParam(value = "secondary external identifier used by a third party") @QueryParam("externalId2")  String externalId2,@ApiParam(value = "external group identifier used by a third party") @QueryParam("externalGroupId")  String externalGroupId,@ApiParam(value = "Sets the active flag") @QueryParam("active")  Boolean active,@ApiParam(value = "external custom client defined data") @QueryParam("metaData")  String metaData,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.updateListing(version, accountId, listingId, filterIds, name, description, start, end, locationName, locationDescription, isPrivate, externalId, externalId2, externalGroupId, active, metaData, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/account/location/update")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Update Location", notes = "Update the account location", response = SirqulResponse.class, tags={ "Account", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response updateLocation(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The device id (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "The account id of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "The current latitude of the user") @QueryParam("latitude")  Double latitude,@ApiParam(value = "The current longitude of the user") @QueryParam("longitude")  Double longitude,@ApiParam(value = "The time of the update") @QueryParam("clientTime")  Long clientTime,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.updateLocation(version, deviceId, accountId, latitude, longitude, clientTime, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/location/{id}")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Update an existing location", notes = "Update an existing location", response = SirqulResponse.class, tags={ "LocationApiV2", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response updateLocationV2(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the id of the location to update", required = true) @PathParam("id") @NotNull  Long id,@ApiParam(value = "") @Valid  Location body,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.updateLocationV2(version, id, body, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/trip/{id}/locations")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Update Trip Locations", notes = "", response = Trip.class, tags={ "Trip", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = Trip.class)
    })
    public Response updateLocations(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the id of the trip to update locations for", required = true) @PathParam("id") @NotNull  Long id,@ApiParam(value = "") @Valid  Trip body,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.updateLocations(version, id, body, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/media/update")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Update Media", notes = "Update a media offering.", response = MediaOfferResponse.class, tags={ "Media", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = MediaOfferResponse.class)
    })
    public Response updateMedia(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The account used to perform the update, must have rights to edit the offer (deviceId or accountId required)", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "", required = true) @QueryParam("mediaId") @NotNull  Long mediaId,@ApiParam(value = "Comma separated list of retailer location ids. This will assign the offer to these retailer locations.") @QueryParam("retailerLocationIds")  String retailerLocationIds,@ApiParam(value = "A list of json data that has offer location specific values.") @QueryParam("offerLocations")  String offerLocations,@ApiParam(value = "The title (255 char limit)") @QueryParam("title")  String title,@ApiParam(value = "The sub title (255 char limit)") @QueryParam("subTitle")  String subTitle,@ApiParam(value = "The details") @QueryParam("details")  String details,@ApiParam(value = "A string for custom details (255 char limit)") @QueryParam("subDetails")  String subDetails,@ApiParam(value = "The fine print") @QueryParam("finePrint")  String finePrint,@ApiParam(value = "The bar code type {NONE, UPC, CODE_128, QR, CUSTOM_MEDIA}", allowableValues="NONE, UPC, CODE_128, QR, CUSTOM_MEDIA") @QueryParam("barcodeType")  String barcodeType,@ApiParam(value = "The bar code entry string") @QueryParam("barcodeEntry")  String barcodeEntry,@ApiParam(value = "An external identifier. What the identifier will be used for and how it is formatted is up to the frontend developer.") @QueryParam("externalRedeemOptions")  String externalRedeemOptions,@ApiParam(value = "The clickUrl of the offer") @QueryParam("externalUrl")  String externalUrl,@ApiParam(value = "The type of ticket to reward, null means default type") @QueryParam("ticketsRewardType")  String ticketsRewardType,@ApiParam(value = "Determines how many tickets are awarded") @QueryParam("ticketsReward")  Long ticketsReward,@ApiParam(value = "The date of when the offer will be visible to consumers") @QueryParam("activated")  Long activated,@ApiParam(value = "The date of when the offer expires") @QueryParam("expires")  Long expires,@ApiParam(value = "Overrides the expiration date so that the offer does not expire") @QueryParam("noExpiration")  Boolean noExpiration,@ApiParam(value = "The limit of how many times the offer can be used by consumers") @QueryParam("availableLimit")  Integer availableLimit,@ApiParam(value = "The limit of how many times a user can used the same offer") @QueryParam("availableLimitPerUser")  Integer availableLimitPerUser,@ApiParam(value = "The limit of how many times the offer can be added to consumer wallets") @QueryParam("addedLimit")  Integer addedLimit,@ApiParam(value = "") @QueryParam("viewLimit")  Integer viewLimit,@ApiParam(value = "The maximum number of times the offer can be printed") @QueryParam("maxPrints")  Integer maxPrints,@ApiParam(value = "the type of ticket needed to buy the offer") @QueryParam("ticketPriceType")  String ticketPriceType,@ApiParam(value = "The cost of the offer in tickets") @QueryParam("ticketPrice")  Long ticketPrice,@ApiParam(value = "The retail/full price cost of the offer in real currency") @QueryParam("fullPrice")  Double fullPrice,@ApiParam(value = "The cost of the offer at a discounted price (what the consumer pays)") @QueryParam("discountPrice")  Double discountPrice,@ApiParam(value = "The show remaining") @QueryParam("showRemaining")  Boolean showRemaining,@ApiParam(value = "The show redeemed") @QueryParam("showRedeemed")  Boolean showRedeemed,@ApiParam(value = "The replaced") @QueryParam("replaced")  Boolean replaced,@ApiParam(value = "The featured") @QueryParam("featured")  Boolean featured,@ApiParam(value = "The special offer type {ALL, REGULAR_OFFER, ACT_NOW, GET_THERE_NOW}", allowableValues="ALL, RESERVABLE, REGULAR_OFFER, ACT_NOW, GET_THERE_NOW, SQOOT, TICKETS, YIPIT") @QueryParam("specialOfferType")  String specialOfferType,@ApiParam(value = "The offer visibility {PUBLIC, REWARDABLE, TRIGGERABLE}", allowableValues="PUBLIC, LISTABLE, REWARDABLE, TRIGGERABLE, PRIVATE") @QueryParam("offerVisibility")  String offerVisibility,@ApiParam(value = "Comma separated list of category ids") @QueryParam("categoryIds")  String categoryIds,@ApiParam(value = "Comma separated list of filter ids") @QueryParam("filterIds")  String filterIds,@ApiParam(value = "Sets the active flag") @QueryParam("active")  Boolean active,@ApiParam(value = "The id of the barcode asset") @QueryParam("barcodeAssetId")  Long barcodeAssetId,@ApiParam(value = "The id of the an offer asset") @QueryParam("imageAssetId")  Long imageAssetId,@ApiParam(value = "The id of the an offer asset") @QueryParam("imageAssetId1")  Long imageAssetId1,@ApiParam(value = "The id of the an offer asset") @QueryParam("imageAssetId2")  Long imageAssetId2,@ApiParam(value = "The id of the an offer asset") @QueryParam("imageAssetId3")  Long imageAssetId3,@ApiParam(value = "The id of the an offer asset") @QueryParam("imageAssetId4")  Long imageAssetId4,@ApiParam(value = "The id of the an offer asset") @QueryParam("imageAssetId5")  Long imageAssetId5,@ApiParam(value = "The maker of the item.") @QueryParam("publisher")  String publisher,@ApiParam(value = "The redeemable start date/time of the offer.") @QueryParam("redeemableStart")  Long redeemableStart,@ApiParam(value = "The redeemable start date/time of the offer.") @QueryParam("redeemableEnd")  Long redeemableEnd,@ApiParam(value = "The condition. OfferType PRODUCT only.", allowableValues="NEW, USED, REFURBISHED, OTHER") @QueryParam("conditionType")  String conditionType,@ApiParam(value = "The ISBN id. OfferType PRODUCT only.") @QueryParam("isbn")  String isbn,@ApiParam(value = "The ASIN id. OfferType PRODUCT only.") @QueryParam("asin")  String asin,@ApiParam(value = "The list of catelog numbers, comma seperated. OfferType PRODUCT only.") @QueryParam("catalogNumbers")  String catalogNumbers,@ApiParam(value = "The date available. OfferType PRODUCT only.") @QueryParam("availabilityDate")  Long availabilityDate,@ApiParam(value = "The parental control rating. OfferType PRODUCT only.") @QueryParam("parentalRating")  String parentalRating,@ApiParam(value = "", allowableValues="APK, APPLICATION, IMAGE, AUDIO, VIDEO, MULTIPART, BAR_CODE, TEXT, OTHER") @QueryParam("mediaType")  String mediaType,@ApiParam(value = "The total playing time of the media item. OfferType MEDIA only.") @QueryParam("duration")  Integer duration,@ApiParam(value = "The created/author of the media item. OfferType MEDIA only.") @QueryParam("author")  String author,@ApiParam(value = "The date/time of when the media item was originally released. OfferType MEDIA only.") @QueryParam("releaseDate")  Long releaseDate,@ApiParam(value = "") @QueryParam("collectionIds")  String collectionIds,@ApiParam(value = "") @QueryParam("availability")  String availability,@ApiParam(value = "") @QueryParam("availabilitySummary")  String availabilitySummary,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.updateMedia(version, accountId, mediaId, retailerLocationIds, offerLocations, title, subTitle, details, subDetails, finePrint, barcodeType, barcodeEntry, externalRedeemOptions, externalUrl, ticketsRewardType, ticketsReward, activated, expires, noExpiration, availableLimit, availableLimitPerUser, addedLimit, viewLimit, maxPrints, ticketPriceType, ticketPrice, fullPrice, discountPrice, showRemaining, showRedeemed, replaced, featured, specialOfferType, offerVisibility, categoryIds, filterIds, active, barcodeAssetId, imageAssetId, imageAssetId1, imageAssetId2, imageAssetId3, imageAssetId4, imageAssetId5, publisher, redeemableStart, redeemableEnd, conditionType, isbn, asin, catalogNumbers, availabilityDate, parentalRating, mediaType, duration, author, releaseDate, collectionIds, availability, availabilitySummary, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/mission/update")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Update Mission", notes = "Update a mission.", response = MissionResponse.class, tags={ "Mission", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = MissionResponse.class)
    })
    public Response updateMission(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The logged in user.", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "The id of the mission to update.", required = true) @QueryParam("missionId") @NotNull  Long missionId,@ApiParam(value = "The title of the mission") @QueryParam("title")  String title,@ApiParam(value = "The description of the mission") @QueryParam("description")  String description,@ApiParam(value = "Custom string client apps can use for searching/filtering missions") @QueryParam("subType")  String subType,@ApiParam(value = "external custom client defined data") @QueryParam("metaData")  String metaData,@ApiParam(value = "The date/time to start the mission, send 0 to unset") @QueryParam("startDate")  Long startDate,@ApiParam(value = "The date/time to end the mission, send 0 to unset") @QueryParam("endDate")  Long endDate,@ApiParam(value = "Activate/deactivate the mission") @QueryParam("active")  Boolean active,@ApiParam(value = "the game level ids to include in the mission, comma separated") @QueryParam("gameLevelIds")  String gameLevelIds,@ApiParam(value = "") @QueryParam("creativeIds")  String creativeIds,@ApiParam(value = "") @QueryParam("audienceIds")  String audienceIds,@ApiParam(value = "The offerId to give as a reward") @QueryParam("offerId")  Long offerId,@ApiParam(value = "Replace the amount of money available to spend, once 0 deactivate mission. Set to a negative value for unlimited.") @QueryParam("balance")  Double balance,@ApiParam(value = "Flag to mark the mission as eligible for advanced reporting") @QueryParam("advancedReporting")  Boolean advancedReporting,@ApiParam(value = "Flag to indicate owner should receive tickets for completed missions") @QueryParam("allocateTickets")  Boolean allocateTickets,@ApiParam(value = "The number of tickets to reward") @QueryParam("ticketCount")  Long ticketCount,@ApiParam(value = "The type of ticket to reward, null means default type") @QueryParam("ticketType")  String ticketType,@ApiParam(value = "The number of points to award for completing a mission") @QueryParam("points")  Long points,@ApiParam(value = "Comma separated list of application ids") @QueryParam("applicationIds")  String applicationIds,@ApiParam(value = "Deprecated parameter for device names") @QueryParam("devices")  String devices,@ApiParam(value = "Comma separated list of device ids") @QueryParam("deviceIds")  String deviceIds,@ApiParam(value = "Comma separated list of device version ranges") @QueryParam("deviceVersions")  String deviceVersions,@ApiParam(value = "List of lat/long pairs for mission locations") @QueryParam("locations")  String locations,@ApiParam(value = "Comma separated list of radii for locations") @QueryParam("radius")  String radius,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.updateMission(version, accountId, missionId, title, description, subType, metaData, startDate, endDate, active, gameLevelIds, creativeIds, audienceIds, offerId, balance, advancedReporting, allocateTickets, ticketCount, ticketType, points, applicationIds, devices, deviceIds, deviceVersions, locations, radius, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/mission/invite/update")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Update Mission Invite", notes = "Update the mission invite status. An account can only be invited to a mission one time. For missions that require user submission and reviewing the permissionableType and permissionableId need to be provided.", response = MissionResponse.class, tags={ "Mission Invite", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = MissionResponse.class)
    })
    public Response updateMissionInvite(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the device id (deviceId or accountId required).") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "the account id of the user (deviceId or accountId required).") @QueryParam("accountId")  Long accountId,@ApiParam(value = "the application key") @QueryParam("appKey")  String appKey,@ApiParam(value = "The mission to find the invite for (missionId or missionInviteId requried).") @QueryParam("missionId")  Long missionId,@ApiParam(value = "The mission invite id. This checks on the user's billable for permission (missionId or missionInviteId requried).") @QueryParam("missionInviteId")  Long missionInviteId,@ApiParam(value = "the pack id to find the invite for") @QueryParam("packId")  Long packId,@ApiParam(value = "the game level id to find the invite for") @QueryParam("gameLevelId")  Long gameLevelId,@ApiParam(value = "The invite status to filter for, comma separated list {AVAILABLE, PENDING, UPDATED, ACCEPTED, ACTIVE, QUIT, COMPLETED, PENDING_REVIEW, REJECTED}") @QueryParam("status")  String status,@ApiParam(value = "This is the content type for missions that require user submission. Note that user submitted content must require a status of PENDING_REVIEW to be accpeted. {ACCOUNT, GAMELEVEL, COLLECTION, ALBUM_CONTEST, THEME_DESCRIPTOR, ALBUM}") @QueryParam("permissionableType")  String permissionableType,@ApiParam(value = "The id of the content being submitted.") @QueryParam("permissionableId")  Long permissionableId,@ApiParam(value = "Include the game level data with the mission.") @QueryParam("includeGameData")  Boolean includeGameData,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.updateMissionInvite(version, deviceId, accountId, appKey, missionId, missionInviteId, packId, gameLevelId, status, permissionableType, permissionableId, includeGameData, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/thirdparty/network/update")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Update Network", notes = "Updates a custom third party network. Only the network owners and managers have access to this.", response = ThirdPartyNetworkResponse.class, tags={ "ThirdParty Credentials", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = ThirdPartyNetworkResponse.class)
    })
    public Response updateNetwork(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The account id making the request", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "The unique identifier for the third party network defined by Sirqul", required = true) @QueryParam("networkUID") @NotNull  String networkUID,@ApiParam(value = "The name of the network") @QueryParam("name")  String name,@ApiParam(value = "The description of the network") @QueryParam("description")  String description,@ApiParam(value = "Whether the network uses introspection calls") @QueryParam("enableIntrospection")  Boolean enableIntrospection,@ApiParam(value = "HTTP method to use for introspection calls (e.g., GET, POST)") @QueryParam("introspectionMethod")  String introspectionMethod,@ApiParam(value = "The HTTP URL of the introspection call") @QueryParam("introspectionURL")  String introspectionURL,@ApiParam(value = "The parameters of the introspection call") @QueryParam("introspectionParams")  String introspectionParams,@ApiParam(value = "Required response params") @QueryParam("requiredRootField")  String requiredRootField,@ApiParam(value = "Whether this network uses MFA") @QueryParam("enableMFA")  Boolean enableMFA,@ApiParam(value = "Size of the MFA token") @QueryParam("sizeMFA")  Integer sizeMFA,@ApiParam(value = "Shelf life (seconds) of the MFA token") @QueryParam("shelfLifeMFA")  Integer shelfLifeMFA,@ApiParam(value = "OAuth token endpoint URL") @QueryParam("oauthTokenURL")  String oauthTokenURL,@ApiParam(value = "OAuth private key file (multipart)") @QueryParam("oauthPrivateKey")  File oauthPrivateKey,@ApiParam(value = "OAuth public key file (multipart)") @QueryParam("oauthPublicKey")  File oauthPublicKey,@ApiParam(value = "OAuth client id") @QueryParam("oauthClientId")  String oauthClientId,@ApiParam(value = "OAuth secret key") @QueryParam("oauthSecretKey")  String oauthSecretKey,@ApiParam(value = "")  String body,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.updateNetwork(version, accountId, networkUID, name, description, enableIntrospection, introspectionMethod, introspectionURL, introspectionParams, requiredRootField, enableMFA, sizeMFA, shelfLifeMFA, oauthTokenURL, oauthPrivateKey, oauthPublicKey, oauthClientId, oauthSecretKey, body, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/note/update")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Update Note", notes = "Update an existing comment (note). Only the creator of the note have permission to update.", response = NoteResponse.class, tags={ "Note", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = NoteResponse.class)
    })
    public Response updateNote(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The id of the note, used when editing a comment", required = true) @QueryParam("noteId") @NotNull  Long noteId,@ApiParam(value = "The unique device identifier that made the request (either deviceId or accountId must be used)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "The unique accountId that made the request (either deviceId or accountId must be used)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "The message the user wishes to leave a comment on") @QueryParam("comment")  String comment,@ApiParam(value = "The custom string defined by the client (used for differentiating on various note types)") @QueryParam("noteType")  String noteType,@ApiParam(value = "A comma separated list of asset IDs to add with the note") @QueryParam("assetIds")  String assetIds,@ApiParam(value = "search tags") @QueryParam("tags")  String tags,@ApiParam(value = "This is used for sending out group notifications. For example, when someone adds a note to an asset which is also a part of an album, everyone in the album will receive a notification. This is achieved by passing in the permissionable type (in this case \"album\"), and the permissionable id (the album id). Possible types: {ALBUM, ALBUM_CONTEST, GAME_LEVEL, THEME_DESCRIPTOR}") @QueryParam("permissionableType")  String permissionableType,@ApiParam(value = "The id of the permissionable object (for sending group notifications)") @QueryParam("permissionableId")  Long permissionableId,@ApiParam(value = "The application key used to identify the application") @QueryParam("appKey")  String appKey,@ApiParam(value = "The description of the location") @QueryParam("locationDescription")  String locationDescription,@ApiParam(value = "The current location of the user") @QueryParam("latitude")  Double latitude,@ApiParam(value = "The current location of the user") @QueryParam("longitude")  Double longitude,@ApiParam(value = "meta data to update with the note") @QueryParam("metaData")  String metaData,@ApiParam(value = "whether to return the full response or not") @QueryParam("returnFullResponse")  Boolean returnFullResponse,@ApiParam(value = "Sets the active flag for the note") @QueryParam("active")  Boolean active,@ApiParam(value = "main flag for updating asset in note, must set to true if you want to update the note's asset") @QueryParam("updateAsset")  Boolean updateAsset,@ApiParam(value = "Return null fields for asset response when updating an asset") @QueryParam("assetReturnNulls")  Boolean assetReturnNulls,@ApiParam(value = "the album the asset will be added to (optional)") @QueryParam("assetAlbumId")  Long assetAlbumId,@ApiParam(value = "the collection ID that the asset is associated with") @QueryParam("assetCollectionId")  Long assetCollectionId,@ApiParam(value = "the default album to add the asset to") @QueryParam("assetAddToDefaultAlbum")  String assetAddToDefaultAlbum,@ApiParam(value = "the media library to add the asset to") @QueryParam("assetAddToMediaLibrary")  Boolean assetAddToMediaLibrary,@ApiParam(value = "the version code of the asset") @QueryParam("assetVersionCode")  Integer assetVersionCode,@ApiParam(value = "the version name of the asset") @QueryParam("assetVersionName")  String assetVersionName,@ApiParam(value = "the meta data of the asset") @QueryParam("assetMetaData")  String assetMetaData,@ApiParam(value = "the caption of the asset") @QueryParam("assetCaption")  String assetCaption,@ApiParam(value = "the media of the asset") @QueryParam("assetMedia")  File assetMedia,@ApiParam(value = "the media URL of the asset") @QueryParam("assetMediaUrl")  String assetMediaUrl,@ApiParam(value = "the media string of the asset") @QueryParam("assetMediaString")  String assetMediaString,@ApiParam(value = "the media string file name of the asset") @QueryParam("assetMediaStringFileName")  String assetMediaStringFileName,@ApiParam(value = "the media string content type of the asset") @QueryParam("assetMediaStringContentType")  String assetMediaStringContentType,@ApiParam(value = "the attached media of the asset") @QueryParam("assetAttachedMedia")  File assetAttachedMedia,@ApiParam(value = "the attached media URL of the asset") @QueryParam("assetAttachedMediaUrl")  String assetAttachedMediaUrl,@ApiParam(value = "the attached media string of the asset") @QueryParam("assetAttachedMediaString")  String assetAttachedMediaString,@ApiParam(value = "the attached media string file name of the asset") @QueryParam("assetAttachedMediaStringFileName")  String assetAttachedMediaStringFileName,@ApiParam(value = "the attached media string content type of the asset") @QueryParam("assetAttachedMediaStringContentType")  String assetAttachedMediaStringContentType,@ApiParam(value = "the location description for the asset") @QueryParam("assetLocationDescription")  String assetLocationDescription,@ApiParam(value = "the application for the asset") @QueryParam("assetApp")  String assetApp,@ApiParam(value = "the search tags used for the asset") @QueryParam("assetSearchTags")  String assetSearchTags,@ApiParam(value = "the latitude of the asset") @QueryParam("assetLatitude")  Double assetLatitude,@ApiParam(value = "the longitude of the asset") @QueryParam("assetLongitude")  Double assetLongitude,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.updateNote(version, noteId, deviceId, accountId, comment, noteType, assetIds, tags, permissionableType, permissionableId, appKey, locationDescription, latitude, longitude, metaData, returnFullResponse, active, updateAsset, assetReturnNulls, assetAlbumId, assetCollectionId, assetAddToDefaultAlbum, assetAddToMediaLibrary, assetVersionCode, assetVersionName, assetMetaData, assetCaption, assetMedia, assetMediaUrl, assetMediaString, assetMediaStringFileName, assetMediaStringContentType, assetAttachedMedia, assetAttachedMediaUrl, assetAttachedMediaString, assetAttachedMediaStringFileName, assetAttachedMediaStringContentType, assetLocationDescription, assetApp, assetSearchTags, assetLatitude, assetLongitude, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/notification/template/update")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Update Notification Template", notes = "Update a notification template. Developers will only be able to update notification templates for their own applications.", response = NotificationTemplateResponse.class, tags={ "Notification", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = NotificationTemplateResponse.class)
    })
    public Response updateNotificationTemplate(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The account ID of the user.", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "The notification template ID to update.", required = true) @QueryParam("notificationTemplateId") @NotNull  Long notificationTemplateId,@ApiParam(value = "The title of the message (this would become the subject title for emails). There is a 191 character limit.") @QueryParam("title")  String title,@ApiParam(value = "The body of the message.") @QueryParam("body")  String body,@ApiParam(value = "The search tags on the template used during search queries.") @QueryParam("tags")  String tags,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.updateNotificationTemplate(version, accountId, notificationTemplateId, title, body, tags, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/retailer/offer/update")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Update Offer", notes = "Update an offer, must provide a current list of retailer locations or the current offer locations will be marked as deleted.", response = RetailerOfferResponse.class, tags={ "Offer", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = RetailerOfferResponse.class)
    })
    public Response updateOffer(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The offer to update", required = true) @QueryParam("offerId") @NotNull  Long offerId,@ApiParam(value = "If true return all the offer locations associated with the offer", required = true) @QueryParam("includeOfferLocations") @NotNull  Boolean includeOfferLocations,@ApiParam(value = "The device id (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "The account used to perform the update, must have rights to edit the offer (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "") @QueryParam("parentOfferId")  Long parentOfferId,@ApiParam(value = "Comma separated list of retailer location ids. This will assign the offer to these retailer locations.") @QueryParam("retailerLocationIds")  String retailerLocationIds,@ApiParam(value = "A list of json data that has offer location specific values.") @QueryParam("offerLocations")  String offerLocations,@ApiParam(value = "Custom string field for doing full-text searches") @QueryParam("tags")  String tags,@ApiParam(value = "The title (255 char limit)") @QueryParam("title")  String title,@ApiParam(value = "The sub title (255 char limit)") @QueryParam("subTitle")  String subTitle,@ApiParam(value = "The details") @QueryParam("details")  String details,@ApiParam(value = "A string for custom details (255 char limit)") @QueryParam("subDetails")  String subDetails,@ApiParam(value = "The fine print") @QueryParam("finePrint")  String finePrint,@ApiParam(value = "The bar code type {NONE, UPC, CODE_128, QR, CUSTOM_MEDIA}", allowableValues="NONE, UPC, CODE_128, QR, CUSTOM_MEDIA") @QueryParam("barcodeType")  String barcodeType,@ApiParam(value = "The bar code entry string") @QueryParam("barcodeEntry")  String barcodeEntry,@ApiParam(value = "An external identifier. What the identifier will be used for and how it is formatted is up to the frontend developer.") @QueryParam("externalRedeemOptions")  String externalRedeemOptions,@ApiParam(value = "The clickUrl of the offer") @QueryParam("externalUrl")  String externalUrl,@ApiParam(value = "") @QueryParam("externalId")  String externalId,@ApiParam(value = "The type of ticket to reward, null means default type") @QueryParam("ticketsRewardType")  String ticketsRewardType,@ApiParam(value = "Determines how many tickets are awarded") @QueryParam("ticketsReward")  Long ticketsReward,@ApiParam(value = "The date of when the offer will be visible to consumers") @QueryParam("activated")  Long activated,@ApiParam(value = "The date of when the offer expires") @QueryParam("expires")  Long expires,@ApiParam(value = "Overrides the expiration date so that the offer does not expire") @QueryParam("noExpiration")  Boolean noExpiration,@ApiParam(value = "The limit of how many times the offer can be used by consumers") @QueryParam("availableLimit")  Integer availableLimit,@ApiParam(value = "The limit of how many times a user can used the same offer") @QueryParam("availableLimitPerUser")  Integer availableLimitPerUser,@ApiParam(value = "The limit of how many times the offer can be added to consumer wallets") @QueryParam("addedLimit")  Integer addedLimit,@ApiParam(value = "") @QueryParam("viewLimit")  Integer viewLimit,@ApiParam(value = "The maximum number of times the offer can be printed") @QueryParam("maxPrints")  Integer maxPrints,@ApiParam(value = "the type of ticket needed to buy the offer") @QueryParam("ticketPriceType")  String ticketPriceType,@ApiParam(value = "The cost of the offer in tickets") @QueryParam("ticketPrice")  Long ticketPrice,@ApiParam(value = "The retail/full price cost of the offer in real currency") @QueryParam("fullPrice")  Double fullPrice,@ApiParam(value = "The cost of the offer at a discounted price (what the consumer pays)") @QueryParam("discountPrice")  Double discountPrice,@ApiParam(value = "show remaining offers available") @QueryParam("showRemaining")  Boolean showRemaining,@ApiParam(value = "show how many offers have been redeemed") @QueryParam("showRedeemed")  Boolean showRedeemed,@ApiParam(value = "") @QueryParam("replaced")  Boolean replaced,@ApiParam(value = "whether the offer is featured or not") @QueryParam("featured")  Boolean featured,@ApiParam(value = "The offer type {VOUCHER, COUPON, PRODUCT, MEDIA, EVENT}", allowableValues="VOUCHER, COUPON, PRODUCT, MEDIA, EVENT, DEVICE") @QueryParam("offerType")  String offerType,@ApiParam(value = "The special offer type {ALL, REGULAR_OFFER, ACT_NOW, GET_THERE_NOW}", allowableValues="ALL, RESERVABLE, REGULAR_OFFER, ACT_NOW, GET_THERE_NOW, SQOOT, TICKETS, YIPIT") @QueryParam("specialOfferType")  String specialOfferType,@ApiParam(value = "The offer visibility {PUBLIC, REWARDABLE, TRIGGERABLE}", allowableValues="PUBLIC, LISTABLE, REWARDABLE, TRIGGERABLE, PRIVATE") @QueryParam("offerVisibility")  String offerVisibility,@ApiParam(value = "Comma separated list of category ids") @QueryParam("categoryIds")  String categoryIds,@ApiParam(value = "Comma separated list of filter ids") @QueryParam("filterIds")  String filterIds,@ApiParam(value = "Sets the active flag") @QueryParam("active")  Boolean active,@ApiParam(value = "The id of the barcode asset") @QueryParam("barcodeAssetId")  Long barcodeAssetId,@ApiParam(value = "The id of the an offer asset") @QueryParam("imageAssetId")  Long imageAssetId,@ApiParam(value = "The id of the an offer asset") @QueryParam("imageAssetId1")  Long imageAssetId1,@ApiParam(value = "The id of the an offer asset") @QueryParam("imageAssetId2")  Long imageAssetId2,@ApiParam(value = "The id of the an offer asset") @QueryParam("imageAssetId3")  Long imageAssetId3,@ApiParam(value = "The id of the an offer asset") @QueryParam("imageAssetId4")  Long imageAssetId4,@ApiParam(value = "The id of the an offer asset") @QueryParam("imageAssetId5")  Long imageAssetId5,@ApiParam(value = "The maker of the item.") @QueryParam("publisher")  String publisher,@ApiParam(value = "The redeemable start date/time of the offer.") @QueryParam("redeemableStart")  Long redeemableStart,@ApiParam(value = "The redeemable start date/time of the offer.") @QueryParam("redeemableEnd")  Long redeemableEnd,@ApiParam(value = "The brand. OfferType PRODUCT only.") @QueryParam("brand")  String brand,@ApiParam(value = "The product type. OfferType PRODUCT only.", allowableValues="APPAREL, APPLIANCES, APPS, ARTS_CRAFTS, AUTOMOTIVE, BABY, BEAUTY, BOOKS, CLASSICAL, COLLECTIBLES, DVD, ELECTRONICS, GIFT_CARDS, GOURMET_FOOD, GROCERY, HEALTH_PERSONAL_CARE, HOME_GARDEN, INDUSTRIAL, JEWELRY, KITCHEN, LAWN_GARDEN, MAGAZINES, MISCELLANEOUS, MUSICAL_INSTRUMENTS, OFFICE_PRODUCTS, OTHER, OUTDOOR_LIVING, PC_HARDWARE, PET_SUPPLIES, SHOES, SOFTWARE, SPORTING_GOODS, TOOLS, TOYS, VIDEO_GAMES, WATCHES, WIRELESS, WIRELESS_ACCESSORIES") @QueryParam("productType")  String productType,@ApiParam(value = "The condition. OfferType PRODUCT only.", allowableValues="NEW, USED, REFURBISHED, OTHER") @QueryParam("conditionType")  String conditionType,@ApiParam(value = "The ISBN id. OfferType PRODUCT only.") @QueryParam("isbn")  String isbn,@ApiParam(value = "The ASIN id. OfferType PRODUCT only.") @QueryParam("asin")  String asin,@ApiParam(value = "The list of catelog numbers, comma seperated. OfferType PRODUCT only.") @QueryParam("catalogNumbers")  String catalogNumbers,@ApiParam(value = "The department name. The OfferType PRODUCT only.") @QueryParam("department")  String department,@ApiParam(value = "The list of features, comma seperated. OfferType PRODUCT only.") @QueryParam("features")  String features,@ApiParam(value = "The MAP price. OfferType PRODUCT only.") @QueryParam("minimumPrice")  Double minimumPrice,@ApiParam(value = "The width of the item. OfferType PRODUCT only.") @QueryParam("width")  Double width,@ApiParam(value = "The height of the item. OfferType PRODUCT only.") @QueryParam("height")  Double height,@ApiParam(value = "The depth of the item. OfferType PRODUCT only.") @QueryParam("depth")  Double depth,@ApiParam(value = "The weight of the item. OfferType PRODUCT only.") @QueryParam("weight")  Double weight,@ApiParam(value = "The unit of measurement. OfferType PRODUCT only.", allowableValues="MILIMETER, CENTIMETER, METER, INCH, FOOT, YARD") @QueryParam("unit")  String unit,@ApiParam(value = "The studio name. OfferType PRODUCT only.") @QueryParam("studio")  String studio,@ApiParam(value = "The parental control rating. OfferType PRODUCT only.") @QueryParam("parentalRating")  String parentalRating,@ApiParam(value = "The date published. OfferType PRODUCT only.") @QueryParam("publishDate")  Long publishDate,@ApiParam(value = "The date available. OfferType PRODUCT only.") @QueryParam("availabilityDate")  Long availabilityDate,@ApiParam(value = "The size Id. OfferType PRODUCT only.") @QueryParam("sizeId")  Long sizeId,@ApiParam(value = "The ID of the event listing") @QueryParam("listingId")  Long listingId,@ApiParam(value = "", allowableValues="APK, APPLICATION, IMAGE, AUDIO, VIDEO, MULTIPART, BAR_CODE, TEXT, OTHER") @QueryParam("mediaType")  String mediaType,@ApiParam(value = "The total playing time of the media item. OfferType MEDIA only.") @QueryParam("duration")  Integer duration,@ApiParam(value = "The created/author of the media item. OfferType MEDIA only.") @QueryParam("author")  String author,@ApiParam(value = "The date/time of when the media item was originally released. OfferType MEDIA only.") @QueryParam("releaseDate")  Long releaseDate,@ApiParam(value = "") @QueryParam("collectionIds")  String collectionIds,@ApiParam(value = "The reboot hour time ranging from 0 to 23") @QueryParam("rebootTimeHour")  Integer rebootTimeHour,@ApiParam(value = "The reboot minute time ranging from 0 to 59") @QueryParam("rebootTimeMinute")  Integer rebootTimeMinute,@ApiParam(value = "If the device is idle for idleTimeoutInSecond then the device should timeout") @QueryParam("idleTimeoutInSecond")  Integer idleTimeoutInSecond,@ApiParam(value = "The serial number on the device") @QueryParam("serialNumber")  String serialNumber,@ApiParam(value = "The unique device id for the device") @QueryParam("udid")  String udid,@ApiParam(value = "The type of the device, for example: \"Kiosk\", \"Beacon\".") @QueryParam("deviceType")  String deviceType,@ApiParam(value = "RSSI reading at 1 meter from device (-10 to -140)") @QueryParam("devicePower")  Double devicePower,@ApiParam(value = "") @QueryParam("deviceInterference")  Double deviceInterference,@ApiParam(value = "") @QueryParam("availability")  String availability,@ApiParam(value = "") @QueryParam("availabilitySummary")  String availabilitySummary,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.updateOffer(version, offerId, includeOfferLocations, deviceId, accountId, parentOfferId, retailerLocationIds, offerLocations, tags, title, subTitle, details, subDetails, finePrint, barcodeType, barcodeEntry, externalRedeemOptions, externalUrl, externalId, ticketsRewardType, ticketsReward, activated, expires, noExpiration, availableLimit, availableLimitPerUser, addedLimit, viewLimit, maxPrints, ticketPriceType, ticketPrice, fullPrice, discountPrice, showRemaining, showRedeemed, replaced, featured, offerType, specialOfferType, offerVisibility, categoryIds, filterIds, active, barcodeAssetId, imageAssetId, imageAssetId1, imageAssetId2, imageAssetId3, imageAssetId4, imageAssetId5, publisher, redeemableStart, redeemableEnd, brand, productType, conditionType, isbn, asin, catalogNumbers, department, features, minimumPrice, width, height, depth, weight, unit, studio, parentalRating, publishDate, availabilityDate, sizeId, listingId, mediaType, duration, author, releaseDate, collectionIds, rebootTimeHour, rebootTimeMinute, idleTimeoutInSecond, serialNumber, udid, deviceType, devicePower, deviceInterference, availability, availabilitySummary, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/retailer/offer/status")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Activate Offer", notes = "Sets the activated date on offers. This will make offers visible for consumers.", response = SirqulResponse.class, tags={ "Offer", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response updateOfferStatus(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "Comma separated list of offer ids", required = true) @QueryParam("offerIds") @NotNull  String offerIds,@ApiParam(value = "Determines whether to make the offer active as well", required = true) @QueryParam("active") @NotNull  Boolean active,@ApiParam(value = "The device id (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "The account used to perform the activation, must have rights to edit the offer.") @QueryParam("accountId")  Long accountId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.updateOfferStatus(version, offerIds, active, deviceId, accountId, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/wallet/update")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Update Wallet Offer", notes = "Update offer status. The status values are: 0 - not redeemable, 1 - redeemable.  Not redeemable means the customer has received the offer but has not decided to use (or print) it yet.  Until they choose to do this the merchant cannot redeem the offer (has not been given permission yet).   Redeemable means the customer has chosen to use the offer and wishes to redeem it.  Redeemed means the merchant has accepted the offer and the given the customer its value, then marked it a used in the system.  This status change is handled by a merchant end point.", response = OfferTransactionResponse.class, tags={ "Wallet", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = OfferTransactionResponse.class)
    })
    public Response updateOfferTransaction(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The offer transaction id to remove", required = true) @QueryParam("transactionId") @NotNull  Long transactionId,@ApiParam(value = "The status value to change to (0 or 1)", required = true) @QueryParam("status") @NotNull  Integer status,@ApiParam(value = "The device id (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "The account id of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "Offer Location Id") @QueryParam("offerLocationId")  Long offerLocationId,@ApiParam(value = "Currency Type", defaultValue = "CASH") @DefaultValue("CASH") @QueryParam("currencyType")  String currencyType,@ApiParam(value = "Use Points") @QueryParam("usePoints")  Boolean usePoints,@ApiParam(value = "App Key") @QueryParam("appKey")  String appKey,@ApiParam(value = "The latitude location of the user") @QueryParam("latitude")  Double latitude,@ApiParam(value = "The latitude location of the user") @QueryParam("longitude")  Double longitude,@ApiParam(value = "External custom client defined data") @QueryParam("metaData")  String metaData,@ApiParam(value = "Determines whether to return a detailed version of the response", defaultValue = "false") @DefaultValue("false") @QueryParam("returnFullResponse")  Boolean returnFullResponse,@ApiParam(value = "Exception Offers, transaction audiences of these offers won't be removed out of the account when up") @QueryParam("exceptionMembershipOfferIds")  String exceptionMembershipOfferIds,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.updateOfferTransaction(version, transactionId, status, deviceId, accountId, offerLocationId, currencyType, usePoints, appKey, latitude, longitude, metaData, returnFullResponse, exceptionMembershipOfferIds, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/offer/status/update")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Update Offer Status", notes = "Update an offer status record", response = OfferTransactionStatusResponse.class, tags={ "Offer Status", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = OfferTransactionStatusResponse.class)
    })
    public Response updateOfferTransactionStatus(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The device id (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "The account id of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "Used to update the user's current location") @QueryParam("latitude")  Double latitude,@ApiParam(value = "Used to update the user's current location") @QueryParam("longitude")  Double longitude,@ApiParam(value = "The id of the record to update ") @QueryParam("statusId")  Long statusId,@ApiParam(value = "The name of th status") @QueryParam("name")  String name,@ApiParam(value = "The description of the status") @QueryParam("description")  String description,@ApiParam(value = "The status code, must be unique ") @QueryParam("code")  Integer code,@ApiParam(value = "The actor that uses the status") @QueryParam("role")  String role,@ApiParam(value = "The active status") @QueryParam("active")  Boolean active,@ApiParam(value = "The applications to associate the status with, if null then for all.") @QueryParam("applicationIds")  String applicationIds,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.updateOfferTransactionStatus(version, deviceId, accountId, latitude, longitude, statusId, name, description, code, role, active, applicationIds, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/order/update")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Update Order", notes = "Updates new purchase with some number of items associated with it. The orderId provided is used to retrieve the record and the payment is added to it.", response = OrderResponse.class, tags={ "Purchase Order", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = OrderResponse.class)
    })
    public Response updateOrder(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The order to add the purchase to, leave null for new order.", required = true) @QueryParam("orderId") @NotNull  Long orderId,@ApiParam(value = "The application requesting the purchase", required = true) @QueryParam("appKey") @NotNull  String appKey,@ApiParam(value = "```json [   { \"orderItemType\": \"OFFER\", \"orderItemId\": 234, \"orderCustomType\": \"OfferLocation\", \"orderCustomId\": 123, \"retailerLocationId\": 1234, \"quantity\": 2 },   { \"orderItemType\": \"OFFER\", \"orderItemId\": 235, \"quantity\": 2 },   { \"orderItemType\": \"CUSTOM\", \"amount\": 10.50, \"orderCustomType\": \"ServiceFee\" },   { \"orderItemType\": \"CUSTOM\", \"amount\": 25.10, \"quantity\": 2, \"orderCustomType\": \"Hat\", \"orderCustomId\": 123 } ] ``` ", required = true) @QueryParam("cart") @NotNull  String cart,@ApiParam(value = "The device id (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "The account id of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "The payment transaction to apply the refund to") @QueryParam("paymentTransactionId")  Long paymentTransactionId,@ApiParam(value = "A description of the purchase") @QueryParam("description")  String description,@ApiParam(value = "Determines the method of purchasing offer.  * VOID: used for when there is no payment involved (ie. for updating the status of a purchase order)  * CASH: use card on file  * POINTS: use account balance  * TICKETS: use tickets  * REFUND: not allowed for a create, requires a paymentTransactionId.  * CREDIT: add to the account balance  * RELOAD: charge a credit card then add to the account balance  ", allowableValues="VOID, CASH, POINTS, TICKETS, REFUND, CREDIT, RELOAD", defaultValue = "CASH") @DefaultValue("CASH") @QueryParam("currencyType")  String currencyType,@ApiParam(value = "Use a specific payment method (CASH), if not provided use default") @QueryParam("paymentMethodId")  Long paymentMethodId,@ApiParam(value = "Store identifier from external system") @QueryParam("externalPaymentId")  String externalPaymentId,@ApiParam(value = "External Date") @QueryParam("externalDate")  Long externalDate,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.updateOrder(version, orderId, appKey, cart, deviceId, accountId, paymentTransactionId, description, currencyType, paymentMethodId, externalPaymentId, externalDate, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/pack/update")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Update Pack", notes = "Update a pack.", response = PackResponse.class, tags={ "Pack", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = PackResponse.class)
    })
    public Response updatePack(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The logged in user.", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "The id of the pack to update.", required = true) @QueryParam("packId") @NotNull  Long packId,@ApiParam(value = "Flag to indicate owner should receive tickets for completed packs", required = true) @QueryParam("allocateTickets") @NotNull  Boolean allocateTickets,@ApiParam(value = "The number of tickets to reward", required = true) @QueryParam("ticketCount") @NotNull  Long ticketCount,@ApiParam(value = "The title of the pack") @QueryParam("title")  String title,@ApiParam(value = "The description of the pack") @QueryParam("description")  String description,@ApiParam(value = "The tags for searching the pack, comma separated") @QueryParam("searchTags")  String searchTags,@ApiParam(value = "Activate/deactivate the pack") @QueryParam("active")  Boolean active,@ApiParam(value = "This parameter is deprecated.") @QueryParam("gameType")  String gameType,@ApiParam(value = "The application key used to identify the application") @QueryParam("appKey")  String appKey,@ApiParam(value = "The type of the pack", allowableValues="TUTORIAL, BUILTIN, DOWNLOAD, THRESHOLD, THEME, TOURNAMENT") @QueryParam("packType")  String packType,@ApiParam(value = "The order of the pack") @QueryParam("packOrder")  Long packOrder,@ApiParam(value = "The type of game sequence of the pack", allowableValues="FIRST_AVAILABLE, ALL_AVAILABLE") @QueryParam("sequenceType")  String sequenceType,@ApiParam(value = "The background asset id of the pack") @QueryParam("backgroundId")  Long backgroundId,@ApiParam(value = "The image asset id of the pack") @QueryParam("imageId")  Long imageId,@ApiParam(value = "The date/time to start the pack, send 0 to unset") @QueryParam("startDate")  Long startDate,@ApiParam(value = "The date/time to end the pack, send 0 to unset") @QueryParam("endDate")  Long endDate,@ApiParam(value = "") @QueryParam("authorOverride")  String authorOverride,@ApiParam(value = "The price in tickets to purchase this pack") @QueryParam("price")  Integer price,@ApiParam(value = "the type of ticket required to purchase this pack") @QueryParam("priceType")  String priceType,@ApiParam(value = "the game level ids to include in the pack, comma separated") @QueryParam("gameLevelIds")  String gameLevelIds,@ApiParam(value = "") @QueryParam("inGame")  Boolean inGame,@ApiParam(value = "The scoring is highest is best") @QueryParam("highest")  Boolean highest,@ApiParam(value = "The type of ticket to reward, null means default type") @QueryParam("ticketType")  String ticketType,@ApiParam(value = "The number of points to award for completing a pack") @QueryParam("points")  Long points,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.updatePack(version, accountId, packId, allocateTickets, ticketCount, title, description, searchTags, active, gameType, appKey, packType, packOrder, sequenceType, backgroundId, imageId, startDate, endDate, authorOverride, price, priceType, gameLevelIds, inGame, highest, ticketType, points, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/persona/update")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Update Persona", notes = "Update the persona by the given personaId. If the given params are null those attributes will be override by null. If active is assigned, all other params will be ignored.", response = PreviewPersonaResponse.class, tags={ "Preview Persona", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = PreviewPersonaResponse.class)
    })
    public Response updatePersona(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the account ID of the user", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "the persona ID of the persona to update", required = true) @QueryParam("personaId") @NotNull  Long personaId,@ApiParam(value = "the title of the persona") @QueryParam("title")  String title,@ApiParam(value = "the accounts that are able to preview from this persona") @QueryParam("previewAccounts")  String previewAccounts,@ApiParam(value = "the status of the persona, there can only be one active persona per account") @QueryParam("active")  Boolean active,@ApiParam(value = "the sepcified date that this persona is viewing the app") @QueryParam("date")  Long date,@ApiParam(value = "the specified age of this persona") @QueryParam("age")  Integer age,@ApiParam(value = "the specified gender of this persona") @QueryParam("gender")  String gender,@ApiParam(value = "the specified experience level of the persona") @QueryParam("gameExperienceLevel")  String gameExperienceLevel,@ApiParam(value = "the specified latitude of the persona") @QueryParam("latitude")  Double latitude,@ApiParam(value = "the specified longitude of the persona") @QueryParam("longitude")  Double longitude,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.updatePersona(version, accountId, personaId, title, previewAccounts, active, date, age, gender, gameExperienceLevel, latitude, longitude, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/postalCode/update")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Update Postal Code", notes = "Update a Postal Code", response = PostalCodeResponse.class, tags={ "Postal Code", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = PostalCodeResponse.class)
    })
    public Response updatePostalCode(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the id of the logged in user", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "the id of the postal code to update", required = true) @QueryParam("postalCodeId") @NotNull  Long postalCodeId,@ApiParam(value = "the postal code to update") @QueryParam("code")  String code,@ApiParam(value = "the latitude of the postal code") @QueryParam("latitude")  Double latitude,@ApiParam(value = "the longitude of the postal code") @QueryParam("longitude")  Double longitude,@ApiParam(value = "the state code (e.g. WA, WI, WY) where the postal code is located") @QueryParam("stateCode")  String stateCode,@ApiParam(value = "the city where the postal code is located") @QueryParam("city")  String city,@ApiParam(value = "whether the postal code is active or inactive") @QueryParam("active")  Boolean active,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.updatePostalCode(version, accountId, postalCodeId, code, latitude, longitude, stateCode, city, active, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/purchase/update")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Update Purchase", notes = "Updates a purchase item for in app purchases", response = PurchaseItemFullResponse.class, tags={ "Purchase Item", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = PurchaseItemFullResponse.class)
    })
    public Response updatePurchaseItem(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The purchase item id", required = true) @QueryParam("purchaseItemId") @NotNull  Long purchaseItemId,@ApiParam(value = "The device id (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "The account id of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "The name of the purchase item") @QueryParam("name")  String name,@ApiParam(value = "The description of the purchase item") @QueryParam("description")  String description,@ApiParam(value = "How much the purchase item is worth in tickets") @QueryParam("tickets")  Integer tickets,@ApiParam(value = "How much the purchase item will cost in real money") @QueryParam("price")  Float price,@ApiParam(value = "The purchase provider <ul> <li>SIRQUL - the Sirqul store to make purchases using tickets</li> <li>IOS - the iTunes store for iPhone, iPod, iPod Touch</li> <li>GOOGLE - the Google Play store</li> <li>AMAZON - the Amazon Android store</li> <li>MAC - the iTunes store for OSX</li> <li>WP8 - the Windows Phone 8 store</li> <li>FREE - used for purchase items that are free (can be used for development/testing purposes)</li> </ul>", allowableValues="SIRQUL, IOS, GOOGLE, AMAZON, MAC, WP8, FREE") @QueryParam("purchaseType")  String purchaseType,@ApiParam(value = "The unique identifier used by purchase providers to identify in-app-purchases") @QueryParam("purchaseCode")  String purchaseCode,@ApiParam(value = "A secret key from purchase providers that would be used for validation") @QueryParam("secretKey")  String secretKey,@ApiParam(value = "How many times a user acquire the same purchase item") @QueryParam("purchaseLimit")  Integer purchaseLimit,@ApiParam(value = "Determines whether the purchase item will enable certain features <ul> <li>DAY_PREMIUM - subscribes a user for a day of membership</li> <li>WEEK_PREMIUM - subscribes a user for a week of membership</li> <li>MONTH_PREMIUM - subscribes a user for a month of membership</li> <li>ADD_TICKET - allows a user to add more tickets to their account</li> <li>ADD_GIFT - allows a user to send/recieve the purchase item as a gift</li> </ul>", allowableValues="DAY_PREMIUM, WEEK_PREMIUM, MONTH_PREMIUM, YEAR_PREMIUM, LIFETIME_PREMIUM, ADD_TICKET, ADD_GIFT, ADD_POINTS") @QueryParam("serviceAction")  String serviceAction,@ApiParam(value = "The cover image of the purchase item") @QueryParam("coverAssetId")  Long coverAssetId,@ApiParam(value = "An application specific asset that can be used to store/provide additional data") @QueryParam("promoAssetId")  Long promoAssetId,@ApiParam(value = "Determines whether the purchase item can be gifted to other users") @QueryParam("giftable")  Boolean giftable,@ApiParam(value = "Determines whether users can attach their own media/asset to the purchase item") @QueryParam("assetable")  Boolean assetable,@ApiParam(value = "Sets whether the purchase item is active or inactive (hidden from consumers)") @QueryParam("active")  Boolean active,@ApiParam(value = "Flag to indicate owner should receive tickets for completed missions", defaultValue = "false") @DefaultValue("false") @QueryParam("allocateTickets")  Boolean allocateTickets,@ApiParam(value = "The type of ticket to reward, null means default type") @QueryParam("ticketType")  String ticketType,@ApiParam(value = "The number of points to award for completing a mission") @QueryParam("points")  Long points,@ApiParam(value = "The offer location that will get added to the user's wallet after purchase.") @QueryParam("offerLocationId")  Long offerLocationId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.updatePurchaseItem(version, purchaseItemId, deviceId, accountId, name, description, tickets, price, purchaseType, purchaseCode, secretKey, purchaseLimit, serviceAction, coverAssetId, promoAssetId, giftable, assetable, active, allocateTickets, ticketType, points, offerLocationId, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/game/question/update")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Update Question", notes = "Update a question and related answers.", response = QuestionResponse.class, tags={ "Question", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = QuestionResponse.class)
    })
    public Response updateQuestion(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The id of the question to update.", required = true) @QueryParam("questionId") @NotNull  Long questionId,@ApiParam(value = "The logged in user.", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "The number of tickets to reward", required = true) @QueryParam("ticketCount") @NotNull  Long ticketCount,@ApiParam(value = "The text of the question.") @QueryParam("question")  String question,@ApiParam(value = "The json representations of answers for the question.") @QueryParam("answers")  String answers,@ApiParam(value = "The tags of the question for search.") @QueryParam("tags")  String tags,@ApiParam(value = "The video link for the question.") @QueryParam("videoURL")  String videoURL,@ApiParam(value = "The asset id of the question.") @QueryParam("assetId")  Long assetId,@ApiParam(value = "If true set the question to active.") @QueryParam("active")  Boolean active,@ApiParam(value = "If true then scoring will give tickets.") @QueryParam("allocateTickets")  Boolean allocateTickets,@ApiParam(value = "The type of ticket to reward, null means default type") @QueryParam("ticketType")  String ticketType,@ApiParam(value = "The number of points to award for completing a mission") @QueryParam("points")  Long points,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.updateQuestion(version, questionId, accountId, ticketCount, question, answers, tags, videoURL, assetId, active, allocateTickets, ticketType, points, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/level/questions/update")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Update Level Questions", notes = "Updates a level with question game objects.", response = SirqulResponse.class, tags={ "Game Level", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response updateQuestionsInLevel(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the id of the level to update questions on", required = true) @QueryParam("levelId") @NotNull  Long levelId,@ApiParam(value = "the id of the logged in user", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "the IDs of the questions to update", required = true) @QueryParam("questionIds") @NotNull  String questionIds,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.updateQuestionsInLevel(version, levelId, accountId, questionIds, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/ranking/update")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Update Ranking", notes = "Update the rank value ", response = SirqulResponse.class, tags={ "Ranking", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response updateRankings(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the account id of the user", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "the application key for filtering results by application", required = true) @QueryParam("appKey") @NotNull  String appKey,@ApiParam(value = "a unique label for identifying the ranking. This can be any alphanumeric string (no spaces or special characters) with a maximum length of 64 characters. There are also default rank types to use which include: POINTS, DOWNLOADS, INVITATIONS, CREATIONS, VOTES, REDEEMED, ACTIONS", required = true) @QueryParam("rankType") @NotNull  String rankType,@ApiParam(value = "the value to increment", defaultValue = "1") @DefaultValue("1") @QueryParam("increment")  Long increment,@ApiParam(value = "the time value to increment") @QueryParam("timeIncrement")  Long timeIncrement,@ApiParam(value = "the analytic tag for this achievement (used to validate scores)") @QueryParam("tag")  String tag,@ApiParam(value = "custom date you can save along with the score for the user") @QueryParam("startDate")  Long startDate,@ApiParam(value = "custom date you can save along with the score for the user") @QueryParam("endDate")  Long endDate,@ApiParam(value = "update the global rankings if true, default is false") @QueryParam("updateGlobal")  Boolean updateGlobal,@ApiParam(value = "create the leaderboard if it does not exist (default false)", defaultValue = "false") @DefaultValue("false") @QueryParam("createLeaderboard")  Boolean createLeaderboard,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.updateRankings(version, accountId, appKey, rankType, increment, timeIncrement, tag, startDate, endDate, updateGlobal, createLeaderboard, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/rating/update")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Update Rating", notes = "Update an existing rating. Only the creator of the rating have permission to update.", response = RatingResponse.class, tags={ "Rating", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = RatingResponse.class)
    })
    public Response updateRating(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The id of the rating (Note: this is not the ratable object id)", required = true) @QueryParam("ratingId") @NotNull  Long ratingId,@ApiParam(value = "The unique device identifier that made the request (either deviceId or accountId must be used)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "The unique accountId that made the request (either deviceId or accountId must be used)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "The rating value to update") @QueryParam("ratingValue")  Integer ratingValue,@ApiParam(value = "") @QueryParam("categoryId")  Long categoryId,@ApiParam(value = "A subject title for the user rating (limited to 255 characters)") @QueryParam("display")  String display,@ApiParam(value = "The description of the rating") @QueryParam("description")  String description,@ApiParam(value = "The description of the location") @QueryParam("locationDescription")  String locationDescription,@ApiParam(value = "The current location of the user") @QueryParam("latitude")  Double latitude,@ApiParam(value = "The current location of the user") @QueryParam("longitude")  Double longitude,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.updateRating(version, ratingId, deviceId, accountId, ratingValue, categoryId, display, description, locationDescription, latitude, longitude, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/trip/{id}/locations/recurrence")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Update Recurrence Locations", notes = "", response = Trip.class, responseContainer = "List", tags={ "Trip", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = Trip.class, responseContainer = "List")
    })
    public Response updateRecurrenceLocations(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the id of the trip", required = true) @PathParam("id") @NotNull  Long id,@ApiParam(value = "") @Valid  Trip body,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.updateRecurrenceLocations(version, id, body, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/trip/{id}/shipments/recurrence")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Update Recurrence Shipments", notes = "", response = Trip.class, responseContainer = "List", tags={ "Trip", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = Trip.class, responseContainer = "List")
    })
    public Response updateRecurrenceShipments(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the id of the trip", required = true) @PathParam("id") @NotNull  Long id,@ApiParam(value = "") @Valid  Trip body,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.updateRecurrenceShipments(version, id, body, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/region/update")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Update Region", notes = "Update a region.", response = RegionResponse.class, tags={ "Region", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = RegionResponse.class)
    })
    public Response updateRegion(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The id of the account sending the request", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "The id of the region to be updated", required = true) @QueryParam("regionId") @NotNull  Long regionId,@ApiParam(value = "RegionClass of this region") @QueryParam("regionClass")  String regionClass,@ApiParam(value = "Short name of the region. This is optimized for search") @QueryParam("shortName")  String shortName,@ApiParam(value = "Full name of the region") @QueryParam("fullName")  String fullName,@ApiParam(value = "Comma separated region ids that are parents of this region") @QueryParam("parentIds")  String parentIds,@ApiParam(value = "Comma separated region ids that are children of this region") @QueryParam("childrenIds")  String childrenIds,@ApiParam(value = "Comma separated postal code ids the region will include") @QueryParam("postalCodeIds")  String postalCodeIds,@ApiParam(value = "Sets of name,lat,long used to create new postal codes assigned to the region") @QueryParam("locations")  String locations,@ApiParam(value = "the retailer location ID that the region is associated with") @QueryParam("retailerLocationId")  Long retailerLocationId,@ApiParam(value = "The Visibility of the region", allowableValues="PUBLIC, PRIVATE, FRIENDS") @QueryParam("visibility")  String visibility,@ApiParam(value = "the categories that the region is assigned to") @QueryParam("categoryIds")  String categoryIds,@ApiParam(value = "the filters that the region is assigned to") @QueryParam("filterIds")  String filterIds,@ApiParam(value = "") @QueryParam("start")  Long start,@ApiParam(value = "") @QueryParam("end")  Long end,@ApiParam(value = "the polygon of the region") @QueryParam("polygon")  String polygon,@ApiParam(value = "the meta data of the region") @QueryParam("metaData")  String metaData,@ApiParam(value = "the latitude of the region") @QueryParam("latitude")  Double latitude,@ApiParam(value = "the longitude of the region") @QueryParam("longitude")  Double longitude,@ApiParam(value = "the version code") @QueryParam("versionCode")  Integer versionCode,@ApiParam(value = "If this is a root region or not. If true means this region has no parent regions") @QueryParam("root")  Boolean root,@ApiParam(value = "Active or inactive status of the region") @QueryParam("active")  Boolean active,@ApiParam(value = "If true clear the children and postal code lists before add new ones, otherwise just append.") @QueryParam("clearLists")  Boolean clearLists,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.updateRegion(version, accountId, regionId, regionClass, shortName, fullName, parentIds, childrenIds, postalCodeIds, locations, retailerLocationId, visibility, categoryIds, filterIds, start, end, polygon, metaData, latitude, longitude, versionCode, root, active, clearLists, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/retailer/update")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Update Retailer", notes = "Update a retailer record. Only the owner and the employees of the retailer have access to update its information.", response = RetailerFullResponse.class, tags={ "Retailer", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = RetailerFullResponse.class)
    })
    public Response updateRetailer(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The ID of the retailer to update", required = true) @QueryParam("retailerId") @NotNull  Long retailerId,@ApiParam(value = "The device id (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "The account id of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "The name of the retailer") @QueryParam("name")  String name,@ApiParam(value = "The street address of the retailer") @QueryParam("streetAddress")  String streetAddress,@ApiParam(value = "Additional address information (such as a suite number, floor number, building name, or PO Box)") @QueryParam("streetAddress2")  String streetAddress2,@ApiParam(value = "The city of the retailer") @QueryParam("city")  String city,@ApiParam(value = "The state of the retailer") @QueryParam("state")  String state,@ApiParam(value = "The postal code of the retailer") @QueryParam("postalCode")  String postalCode,@ApiParam(value = "the country of the retailer") @QueryParam("country")  String country,@ApiParam(value = "The business phone of the retailer") @QueryParam("businessPhone")  String businessPhone,@ApiParam(value = "The business phone extension of the retailer") @QueryParam("businessPhoneExt")  String businessPhoneExt,@ApiParam(value = "The website of the retailer") @QueryParam("website")  String website,@ApiParam(value = "The email of the retailer") @QueryParam("email")  String email,@ApiParam(value = "The facebook URL of the retailer") @QueryParam("facebookUrl")  String facebookUrl,@ApiParam(value = "The twitter URL of the retailer") @QueryParam("twitterUrl")  String twitterUrl,@ApiParam(value = "The retailer logo sent as a multipart binary file (you can optionally use logoAssetId if the asset has already been uploaded before)") @QueryParam("logo")  File logo,@ApiParam(value = "The retailer logo asset id") @QueryParam("logoAssetId")  Long logoAssetId,@ApiParam(value = "Optional store-front pictures or product pictures or etc. A multipart binary file (you can optionally use picture1AssetId if the asset has already been uploaded before)") @QueryParam("picture1")  File picture1,@ApiParam(value = "An asset id") @QueryParam("picture1AssetId")  Long picture1AssetId,@ApiParam(value = "Optional store-front pictures or product pictures or etc. A multipart binary file (you can optionally use picture2AssetId if the asset has already been uploaded before)") @QueryParam("picture2")  File picture2,@ApiParam(value = "An asset id") @QueryParam("picture2AssetId")  Long picture2AssetId,@ApiParam(value = "Comma separated list of category IDs used to filter retailers by categories") @QueryParam("categoryIds")  String categoryIds,@ApiParam(value = "Comma separated list of filter IDs used to filter retailers") @QueryParam("filterIds")  String filterIds,@ApiParam(value = "the latitude of the retailer") @QueryParam("latitude")  Double latitude,@ApiParam(value = "the longitude of the retailer") @QueryParam("longitude")  Double longitude,@ApiParam(value = "External custom client defined data") @QueryParam("metaData")  String metaData,@ApiParam(value = "External custom search keywords") @QueryParam("searchTags")  String searchTags,@ApiParam(value = "External custom type identifier") @QueryParam("retailerType")  String retailerType,@ApiParam(value = "", allowableValues="PUBLIC, PRIVATE, FRIENDS") @QueryParam("visibility")  String visibility,@ApiParam(value = "Sets whether the retailer is active or inactive (hidden from consumers)") @QueryParam("active")  Boolean active,@ApiParam(value = "The format of the returned response {JSON // default , HTML // for Dojo support when uploading assets}", allowableValues="HTML, XML, JSON, CSV") @QueryParam("responseFormat")  String responseFormat,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.updateRetailer(version, retailerId, deviceId, accountId, name, streetAddress, streetAddress2, city, state, postalCode, country, businessPhone, businessPhoneExt, website, email, facebookUrl, twitterUrl, logo, logoAssetId, picture1, picture1AssetId, picture2, picture2AssetId, categoryIds, filterIds, latitude, longitude, metaData, searchTags, retailerType, visibility, active, responseFormat, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/retailer/location/update")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Update Retailer Location", notes = "Updates a location record for a retailer. Only the owner and the employees of the retailer have access to do this.", response = RetailerLocationResponse.class, tags={ "Retailer Location", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = RetailerLocationResponse.class)
    })
    public Response updateRetailerLocations(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The ID of the retailer location", required = true) @QueryParam("retailerLocationId") @NotNull  Long retailerLocationId,@ApiParam(value = "The device id (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "The account id of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "The name of the retailer location") @QueryParam("name")  String name,@ApiParam(value = "The street address of the retailer location") @QueryParam("streetAddress")  String streetAddress,@ApiParam(value = "Additional address information (such as a suite number, floor number, building name, or PO Box)") @QueryParam("streetAddress2")  String streetAddress2,@ApiParam(value = "The city of the retailer location") @QueryParam("city")  String city,@ApiParam(value = "The state of the retailer location") @QueryParam("state")  String state,@ApiParam(value = "The postal code of the retailer location") @QueryParam("postalCode")  String postalCode,@ApiParam(value = "the country of the retailer location") @QueryParam("country")  String country,@ApiParam(value = "The business phone number of the retailer location") @QueryParam("businessPhone")  String businessPhone,@ApiParam(value = "The business phone extension of the retailer location") @QueryParam("businessPhoneExt")  String businessPhoneExt,@ApiParam(value = "The website of the retailer location") @QueryParam("website")  String website,@ApiParam(value = "The email of the retailer location") @QueryParam("email")  String email,@ApiParam(value = "An internal identifier used by the retailer") @QueryParam("internalId")  String internalId,@ApiParam(value = "A brief description about the retailer location (255 character limit)") @QueryParam("detailsHeader")  String detailsHeader,@ApiParam(value = "A detailed description about the retailer location") @QueryParam("detailsBody")  String detailsBody,@ApiParam(value = "The hours of operation") @QueryParam("hours")  String hours,@ApiParam(value = "The retailer location logo sent as a multipart binary file (you can optionally use logoAssetId if the asset has already been uploaded before)") @QueryParam("logo")  File logo,@ApiParam(value = "The retailer location logo asset id") @QueryParam("logoAssetId")  Long logoAssetId,@ApiParam(value = "Optional store-front pictures or product pictures or etc. A multipart binary file (you can optionally use picture1AssetId if the asset has already been uploaded before)") @QueryParam("picture1")  File picture1,@ApiParam(value = "An asset id") @QueryParam("picture1AssetId")  Long picture1AssetId,@ApiParam(value = "Optional store-front pictures or product pictures or etc. A multipart binary file (you can optionally use picture2AssetId if the asset has already been uploaded before)") @QueryParam("picture2")  File picture2,@ApiParam(value = "An asset id") @QueryParam("picture2AssetId")  Long picture2AssetId,@ApiParam(value = "Comma separated list of category IDs used to filter retailer locations by categories") @QueryParam("categoryIds")  String categoryIds,@ApiParam(value = "Comma separated list of filter IDs used to filter retailer locations") @QueryParam("filterIds")  String filterIds,@ApiParam(value = "the latituede of the retailer location") @QueryParam("latitude")  Double latitude,@ApiParam(value = "the longitude of the retailer location") @QueryParam("longitude")  Double longitude,@ApiParam(value = "") @QueryParam("building")  String building,@ApiParam(value = "the Google Place ID that the retailer location is associated with") @QueryParam("googlePlaceId")  String googlePlaceId,@ApiParam(value = "the Yelp ID that the retailer location is associated with") @QueryParam("yelpId")  String yelpId,@ApiParam(value = "External custom client defined data") @QueryParam("metaData")  String metaData,@ApiParam(value = "Specifies which payment provider Sirqul will use when making payments") @QueryParam("paymentProvider")  String paymentProvider,@ApiParam(value = "Sets whether the retailer is active or inactive (hidden from consumers)") @QueryParam("active")  Boolean active,@ApiParam(value = "Sets whether the location is public or not") @QueryParam("publicLocation")  Boolean publicLocation,@ApiParam(value = "External custom type identifier") @QueryParam("locationType")  String locationType,@ApiParam(value = "Comma separated list of audience IDs used to assign audiences to the retailer location") @QueryParam("audienceIds")  String audienceIds,@ApiParam(value = "Comma separated list of audience IDs to add to the retailer location") @QueryParam("audienceIdsToAdd")  String audienceIdsToAdd,@ApiParam(value = "Comma separated list of audience IDs to remove from the retailer location") @QueryParam("audienceIdsToRemove")  String audienceIdsToRemove,@ApiParam(value = "The format of the returned response {JSON // default , HTML // for Dojo support when uploading assets}", allowableValues="HTML, XML, JSON, CSV") @QueryParam("responseFormat")  String responseFormat,@ApiParam(value = "Custom string field for doing full-text searches") @QueryParam("tags")  String tags,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.updateRetailerLocations(version, retailerLocationId, deviceId, accountId, name, streetAddress, streetAddress2, city, state, postalCode, country, businessPhone, businessPhoneExt, website, email, internalId, detailsHeader, detailsBody, hours, logo, logoAssetId, picture1, picture1AssetId, picture2, picture2AssetId, categoryIds, filterIds, latitude, longitude, building, googlePlaceId, yelpId, metaData, paymentProvider, active, publicLocation, locationType, audienceIds, audienceIdsToAdd, audienceIdsToRemove, responseFormat, tags, securityContext);
    }
    @javax.ws.rs.PUT
    @Path("/route/{routeId}")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Update Route", notes = "Update an existing route", response = Route.class, tags={ "Route", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = Route.class)
    })
    public Response updateRoute(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the id of the route", required = true) @PathParam("routeId") @NotNull  Long routeId,@ApiParam(value = "") @Valid  Route body,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.updateRoute(version, routeId, body, securityContext);
    }
    @javax.ws.rs.PUT
    @Path("/route/setting/{routeSettingsId}")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Update Route Setting", notes = "Update an existing route setting", response = RouteSettings.class, tags={ "Route Setting", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = RouteSettings.class)
    })
    public Response updateRouteSettings(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the id of the route settings to update", required = true) @PathParam("routeSettingsId") @NotNull  Long routeSettingsId,@ApiParam(value = "") @Valid  RouteSettings body,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.updateRouteSettings(version, routeSettingsId, body, securityContext);
    }
    @javax.ws.rs.PUT
    @Path("/route/{routeId}/stop/{stopId}")
    
    
    @io.swagger.annotations.ApiOperation(value = "Update Route Stop", notes = "Update a stop on a specified route", response = Void.class, tags={ "Route", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = Void.class)
    })
    public Response updateRouteStop(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the id of the route to update stops for", required = true) @PathParam("routeId") @NotNull  Long routeId,@ApiParam(value = "the id of the specific stop to update on the route", required = true) @PathParam("stopId") @NotNull  Long stopId,@ApiParam(value = "") @Valid  Stop body,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.updateRouteStop(version, routeId, stopId, body, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/notification/schedule/update")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Update Scheduled Notification", notes = "This endpoint updates a Scheduled Notification message that can be configured to process and send periodically at set time periods. Please see createScheduledNotification for more details.  Only the original owner of the Scheduled Notification or someone with write permissions can use this endpoint. Permissions can be granted to other users by using theUserPermissionsApi.", response = ScheduledNotificationFullResponse.class, tags={ "Scheduled Notification", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = ScheduledNotificationFullResponse.class)
    })
    public Response updateScheduledNotification(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The id of scheduled notification to update", required = true) @QueryParam("scheduledNotificationId") @NotNull  Long scheduledNotificationId,@ApiParam(value = "The logged in user.", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "The name of the scheduled notification") @QueryParam("name")  String name,@ApiParam(value = "The type of scheduled notification. Supported values include: MOBILE_NOTIFICATION - sends push notifications via APNS and GCM EMAIL - sends email messages SMS - sends text messages") @QueryParam("type")  String type,@ApiParam(value = "The message to send") @QueryParam("message")  String message,@ApiParam(value = "The parameters for making an HTTP call") @QueryParam("payload")  String payload,@ApiParam(value = "The payload content ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.") @QueryParam("contentId")  Long contentId,@ApiParam(value = "The payload content name that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.") @QueryParam("contentName")  String contentName,@ApiParam(value = "The payload content type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.") @QueryParam("contentType")  String contentType,@ApiParam(value = "The payload parent ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.") @QueryParam("parentId")  Long parentId,@ApiParam(value = "The payload parent type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.") @QueryParam("parentType")  String parentType,@ApiParam(value = "The application that the notifications will send to. If connectionGroupIds, connectionAccountIds, and audienceIds is not set, this will send to all users who have used the application. This parameter is also required when sending push notifications via the MOBILE_NOTIFICATION type.") @QueryParam("appKey")  String appKey,@ApiParam(value = "Client defined identifier for grouping multiple scheduled notifications. This can be used with the search endpoint to return scheduled notifications with the same groupingId for display purposes. Only results that have been created by the user will be returned when using this feature.") @QueryParam("groupingId")  String groupingId,@ApiParam(value = "The connection groups to use to generate the list of recipients (comma separated list of connection group IDs)") @QueryParam("connectionGroupIds")  String connectionGroupIds,@ApiParam(value = "The connection accounts to use to generate the list of recipients (comma separated list of user account ids)") @QueryParam("connectionAccountIds")  String connectionAccountIds,@ApiParam(value = "This parameter is deprecated. The audience used to generate the list of recipients") @QueryParam("audienceId")  Long audienceId,@ApiParam(value = "The audiences used to generate the list of recipients (comma separated list of audience IDs)") @QueryParam("audienceIds")  String audienceIds,@ApiParam(value = "The album ids to associate with the scheduled notification (comma separated list of album IDs)") @QueryParam("albumIds")  String albumIds,@ApiParam(value = "The report used to generate the the list of recipients") @QueryParam("reportId")  Long reportId,@ApiParam(value = "The parameters to supply to the report used to generate the the list of recipients") @QueryParam("reportParams")  String reportParams,@ApiParam(value = "The URL for making an HTTP call") @QueryParam("endpointURL")  String endpointURL,@ApiParam(value = "The next time when the scheduled notification should begin processing (time in milliseconds). If this is left empty, then the startDate will be used.") @QueryParam("scheduledDate")  Long scheduledDate,@ApiParam(value = "The start time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to be available now.") @QueryParam("startDate")  Long startDate,@ApiParam(value = "The end time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to not have an expiration date.") @QueryParam("endDate")  Long endDate,@ApiParam(value = "The cron expression that represents the processing schedule. This uses the unix cron expression format. For example: 0 0 * * * will run once a day at midnight UTC.") @QueryParam("cronExpression")  String cronExpression,@ApiParam(value = "The cron expression type: UNIX, CRON4J, QUARTZ") @QueryParam("cronType")  String cronType,@ApiParam(value = "Additional metadata for the scheduled notification") @QueryParam("metaData")  String metaData,@ApiParam(value = "Json input representing conditional logic that has to be met before running the scheduled notification") @QueryParam("conditionalInput")  String conditionalInput,@ApiParam(value = "This determines if the Scheduled Notification is a template which is used as a basis for dynamically generating re-occurring Scheduled Notifications. The available types include: REPORTING - saves an adhoc report to be able to run again at another time GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business owner) GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business employee, retailer location, etc) GEOFENCE_TRIGGER - template for sending notifications to the account that triggered the geofence/audience (i.e. the customer) GEOFENCE_HTTP_CALL - template for making http calls when the geofences are triggered") @QueryParam("templateType")  String templateType,@ApiParam(value = "Determines the scope of who is able to find and view the scheduled notification (PUBLIC - openly available to all Sirqul users, PRIVATE - only available to users that have been invited)", allowableValues="PUBLIC, PRIVATE, FRIENDS") @QueryParam("visibility")  String visibility,@ApiParam(value = "Sets whether the Scheduled Notification is active or not (inactive Scheduled Notifications are not processed). This is a quick way to toggle on or off without altering its schedule.") @QueryParam("active")  Boolean active,@ApiParam(value = "the error message associated with the scheduled notification") @QueryParam("errorMessage")  String errorMessage,@ApiParam(value = "the status of the scheduled notification") @QueryParam("status")  String status,@ApiParam(value = "also updates ScheduledNotifications with the same groupingId and account") @QueryParam("updateByGroupingId")  Boolean updateByGroupingId,@ApiParam(value = "whether to send the scheduled notification now or not") @QueryParam("sendNow")  Boolean sendNow,@ApiParam(value = "Sets the event type for the notification", defaultValue = "CUSTOM") @DefaultValue("CUSTOM") @QueryParam("eventType")  String eventType,@ApiParam(value = "The payload deep link URI that can be used by the client app to direct users to a screen in the app") @QueryParam("deepLinkURI")  String deepLinkURI,@ApiParam(value = "Determines whether to send to all users of the app if set to true for push notifications (appKey is required)") @QueryParam("sendToAll")  Boolean sendToAll,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.updateScheduledNotification(version, scheduledNotificationId, accountId, name, type, message, payload, contentId, contentName, contentType, parentId, parentType, appKey, groupingId, connectionGroupIds, connectionAccountIds, audienceId, audienceIds, albumIds, reportId, reportParams, endpointURL, scheduledDate, startDate, endDate, cronExpression, cronType, metaData, conditionalInput, templateType, visibility, active, errorMessage, status, updateByGroupingId, sendNow, eventType, deepLinkURI, sendToAll, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/secure/application/update")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Update Secure Application", notes = "Update a secure application record.", response = SirqulResponse.class, tags={ "SecureApp", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response updateSecureApplication(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The unique id of the user making the request", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "The application to secure", required = true) @QueryParam("appKey") @NotNull  String appKey,@ApiParam(value = "") @QueryParam("active")  Boolean active,@ApiParam(value = "") @QueryParam("keyCert")  File keyCert,@ApiParam(value = "") @QueryParam("trustStore")  File trustStore,@ApiParam(value = "") @QueryParam("username")  String username,@ApiParam(value = "") @QueryParam("password")  String password,@ApiParam(value = "The type of biometric, options are: - FINGERPRINT - IRIS - FACIAL", allowableValues="FINGERPRINT, IRIS, FACIAL") @QueryParam("biometricType")  String biometricType,@ApiParam(value = "The position for the biometric file uploaded", allowableValues="UNKNOWN, LEFT_INDEX, LEFT_MIDDLE, LEFT_RING, LEFT_LITTLE, LEFT_THUMB, RIGHT_INDEX, RIGHT_MIDDLE, RIGHT_RING, RIGHT_LITTLE, RIGHT_THUMB, LEFT, RIGHT") @QueryParam("biometricPosition")  String biometricPosition,@ApiParam(value = "The position for each the biometric2 file uploaded", allowableValues="UNKNOWN, LEFT_INDEX, LEFT_MIDDLE, LEFT_RING, LEFT_LITTLE, LEFT_THUMB, RIGHT_INDEX, RIGHT_MIDDLE, RIGHT_RING, RIGHT_LITTLE, RIGHT_THUMB, LEFT, RIGHT") @QueryParam("biometricPosition2")  String biometricPosition2,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.updateSecureApplication(version, accountId, appKey, active, keyCert, trustStore, username, password, biometricType, biometricPosition, biometricPosition2, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/account/settings/update")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Update Account Settings", notes = "Update the account settings for a user", response = UserSettingsResponse.class, tags={ "Account", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = UserSettingsResponse.class)
    })
    public Response updateSettings(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The device id (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "The account id of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "The notifications to be blocked") @QueryParam("blockedNotifications")  String blockedNotifications,@ApiParam(value = "How suggestions are to be sent (APNS, MOBILE_NOTIFICATION, SMS)") @QueryParam("suggestionMethod")  String suggestionMethod,@ApiParam(value = "How many suggestions to receive per time frame") @QueryParam("suggestionCount")  Integer suggestionCount,@ApiParam(value = "The time frame in seconds, 3600 would be a 1 hour time frame") @QueryParam("suggestionTimeFrame")  Integer suggestionTimeFrame,@ApiParam(value = "Show Others Exact Location") @QueryParam("showOthersExactLocation")  Boolean showOthersExactLocation,@ApiParam(value = "Show As Zipcode") @QueryParam("showAsZipcode")  Boolean showAsZipcode,@ApiParam(value = "Show Exact Location") @QueryParam("showExactLocation")  Boolean showExactLocation,@ApiParam(value = "Show favorites") @QueryParam("favoriteVisibility")  String favoriteVisibility,@ApiParam(value = "The current latitude of the user") @QueryParam("latitude")  Double latitude,@ApiParam(value = "The current longitude of the user") @QueryParam("longitude")  Double longitude,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.updateSettings(version, deviceId, accountId, blockedNotifications, suggestionMethod, suggestionCount, suggestionTimeFrame, showOthersExactLocation, showAsZipcode, showExactLocation, favoriteVisibility, latitude, longitude, securityContext);
    }
    @javax.ws.rs.PUT
    @Path("/shipment/{id}")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Update Shipment", notes = "Update an existing shipment", response = Shipment.class, tags={ "Shipment", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = Shipment.class)
    })
    public Response updateShipment(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the id of the shipment to update", required = true) @PathParam("id") @NotNull  Long id,@ApiParam(value = "") @Valid  Shipment body,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.updateShipment(version, id, body, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/shipment/{id}/status")
    
    
    @io.swagger.annotations.ApiOperation(value = "Uupdate Shipment Status", notes = "Update status of an existing shipment", response = Void.class, tags={ "Shipment", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = Void.class)
    })
    public Response updateShipmentStatus(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the id of the shipment to update status", required = true) @PathParam("id") @NotNull  Long id,@ApiParam(value = "")  Map<String, Boolean> body,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.updateShipmentStatus(version, id, body, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/trip/{id}/shipments")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Update Trip Shipments", notes = "", response = Trip.class, tags={ "Trip", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = Trip.class)
    })
    public Response updateShipments(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the id of the trip shipments to update", required = true) @PathParam("id") @NotNull  Long id,@ApiParam(value = "") @Valid  Trip body,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.updateShipments(version, id, body, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/vatom/b/spaces/update")
    
    
    @io.swagger.annotations.ApiOperation(value = "Update Vatom Space", notes = "Update a Vatom space.", response = Void.class, tags={ "Vatom", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = Void.class)
    })
    public Response updateSpace(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "Sirqul Account Id", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "Sirqul Application Key", required = true) @QueryParam("appKey") @NotNull  String appKey,@ApiParam(value = "Vatom Space Id", required = true) @QueryParam("vatomSpaceId") @NotNull  String vatomSpaceId,@ApiParam(value = "Vatom Parameters", required = true) @QueryParam("vatomParameters") @NotNull  String vatomParameters,@ApiParam(value = "Return raw response") @QueryParam("returnRawResponse")  Boolean returnRawResponse,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.updateSpace(version, accountId, appKey, vatomSpaceId, vatomParameters, returnRawResponse, securityContext);
    }
    @javax.ws.rs.PUT
    @Path("/stop/{id}")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Update Stop", notes = "Update an existing stop", response = Stop.class, tags={ "Stop", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = Stop.class)
    })
    public Response updateStop(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the id of the stop to update", required = true) @PathParam("id") @NotNull  Long id,@ApiParam(value = "") @Valid  Stop body,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.updateStop(version, id, body, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/subscription/update")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Update Subscription", notes = "Updates the subscription for the billable entity for an account", response = SubscriptionResponse.class, tags={ "Subscription", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SubscriptionResponse.class)
    })
    public Response updateSubscription(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The account used to perform the update, must be the responsible manager", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "The plan to subscribe to") @QueryParam("planId")  Long planId,@ApiParam(value = "Set a promo code for a discount.") @QueryParam("promoCode")  String promoCode,@ApiParam(value = "Set active status") @QueryParam("active")  Boolean active,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.updateSubscription(version, accountId, planId, promoCode, active, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/task/update")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Update Task", notes = "Update a Task", response = TaskResponse.class, tags={ "Task", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = TaskResponse.class)
    })
    public Response updateTask(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "Task Id", required = true) @QueryParam("taskId") @NotNull  Long taskId,@ApiParam(value = "The logged in user.", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "The name of the task") @QueryParam("name")  String name,@ApiParam(value = "The application to target") @QueryParam("appKey")  String appKey,@ApiParam(value = "Client defined identifier for grouping tasks") @QueryParam("groupingId")  String groupingId,@ApiParam(value = "The URL for making an HTTP call") @QueryParam("endpointURL")  String endpointURL,@ApiParam(value = "The parameters for making an HTTP call") @QueryParam("payload")  String payload,@ApiParam(value = "The date and time of the task") @QueryParam("scheduledDate")  Long scheduledDate,@ApiParam(value = "The starting date of the task") @QueryParam("startDate")  Long startDate,@ApiParam(value = "The ending date of the task") @QueryParam("endDate")  Long endDate,@ApiParam(value = "The cron expression that represents the task's schedule") @QueryParam("cronExpression")  String cronExpression,@ApiParam(value = "The determines the scope of who is able to find and view the scheduled notification (PUBLIC - openly available to all Sirqul users, PRIVATE - only available to users that have been invited)", allowableValues="PUBLIC, PRIVATE, FRIENDS") @QueryParam("visibility")  String visibility,@ApiParam(value = "Sets whether the Task is active or not (inactive Tasks are not processed)") @QueryParam("active")  Boolean active,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.updateTask(version, taskId, accountId, name, appKey, groupingId, endpointURL, payload, scheduledDate, startDate, endDate, cronExpression, visibility, active, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/territory/update")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Update Territory", notes = "Updates a territory.", response = TerritoryResponse.class, tags={ "Territory", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = TerritoryResponse.class)
    })
    public Response updateTerritory(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The logged in user.", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "the id of the territory to update", required = true) @QueryParam("territoryId") @NotNull  Long territoryId,@ApiParam(value = "The name of the territory") @QueryParam("name")  String name,@ApiParam(value = "If true set the game level as active.") @QueryParam("active")  Boolean active,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.updateTerritory(version, accountId, territoryId, name, active, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/tournament/update")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Update Tournament", notes = "Update a tournament.", response = TournamentResponse.class, tags={ "Tournament", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = TournamentResponse.class)
    })
    public Response updateTournament(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The logged in user.", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "The mission/tournament to update", required = true) @QueryParam("missionId") @NotNull  Long missionId,@ApiParam(value = "The title of the tournament") @QueryParam("title")  String title,@ApiParam(value = "Custom string client apps can use for searching/filtering missions") @QueryParam("subType")  String subType,@ApiParam(value = "The asset ID to attach to the tournament") @QueryParam("imageAssetId")  Long imageAssetId,@ApiParam(value = "The number of seconds in between the start of each tournament game") @QueryParam("secondsBetweenLevels")  Integer secondsBetweenLevels,@ApiParam(value = "The number of seconds to extend the round end time in the case of a tie breaker") @QueryParam("secondsForTieBreaker")  Integer secondsForTieBreaker,@ApiParam(value = "The number of seconds in between the start of each tournament round") @QueryParam("secondsBetweenPacks")  Integer secondsBetweenPacks,@ApiParam(value = "The maximum number of seconds the match is expected to end at, which gets used to determine when a match should end when there is no activity") @QueryParam("maximumLevelLength")  Integer maximumLevelLength,@ApiParam(value = "The number of tickets required to pay to enter the tournament") @QueryParam("costToPlay")  Integer costToPlay,@ApiParam(value = "The type of ticket required to pay") @QueryParam("costToPlayType")  String costToPlayType,@ApiParam(value = "The minimum number of players required to sign up for the tournament to be played") @QueryParam("minimumToPlay")  Integer minimumToPlay,@ApiParam(value = "The starting number of players for a tournament (filled with AI's)") @QueryParam("startingLimit")  Integer startingLimit,@ApiParam(value = "The maximum number of players for a tournament (currently 128 but not enforced)") @QueryParam("availableLimit")  Integer availableLimit,@ApiParam(value = "The description of the tournament") @QueryParam("description")  String description,@ApiParam(value = "External custom client defined data") @QueryParam("metaData")  String metaData,@ApiParam(value = "The date/time to start the tournament") @QueryParam("startDate")  Long startDate,@ApiParam(value = "The audiences associated with the tournament") @QueryParam("audienceIds")  String audienceIds,@ApiParam(value = "Activate/deactivate the mission") @QueryParam("active")  Boolean active,@ApiParam(value = "Determines whether to allow players to buy back into a tournament") @QueryParam("enableBuyBack")  Boolean enableBuyBack,@ApiParam(value = "The list of offers to give as a reward beyond the tickets") @QueryParam("offerIds")  String offerIds,@ApiParam(value = "The artwork ID to attach to the reward offer") @QueryParam("offerAssetId")  Long offerAssetId,@ApiParam(value = "If set then do not update the ticket reward, auto set to true if offerIds provided") @QueryParam("fixedReward")  Boolean fixedReward,@ApiParam(value = "Set the rules for handling the reward in case of a tie, values: EVEN split the reward evenly ALL everyone gets the full reward value FIRST first score submitted RANDOM random player who scored", allowableValues="EVEN, ALL, FIRST, RANDOM") @QueryParam("splitReward")  String splitReward,@ApiParam(value = "Flag to indicate owner should receive tickets for completed missions") @QueryParam("allocateTickets")  Boolean allocateTickets,@ApiParam(value = "A text based string that will be passed into each tournament setup to populate the content") @QueryParam("tournamentData")  String tournamentData,@ApiParam(value = "Sets the visibility flag for the tournament", allowableValues="PUBLIC, LISTABLE, REWARDABLE, TRIGGERABLE, PRIVATE") @QueryParam("visibility")  String visibility,@ApiParam(value = "The number of initial preliminary groups in a multi-stage tournament (this is expected to be a power of two number)") @QueryParam("preliminaryGroups")  Integer preliminaryGroups,@ApiParam(value = "This determines how many people can advance per round in a preliminary group (this is a comma separated list of integers)") @QueryParam("preliminaryGroupAdvancements")  String preliminaryGroupAdvancements,@ApiParam(value = "This determines if multiple submissions/entries are allowed in a multi-stage album tournament") @QueryParam("enableMultipleEntries")  Boolean enableMultipleEntries,@ApiParam(value = "This determines if users are allowed to vote multiple times per group in a multi-stage album tournament") @QueryParam("enableMultipleVotes")  Boolean enableMultipleVotes,@ApiParam(value = "This determines whether the tournament is \"featured\" or not") @QueryParam("featured")  Boolean featured,@ApiParam(value = "This sets what analytic tag is used when a winner is determined") @QueryParam("winnerTag")  String winnerTag,@ApiParam(value = "This sets what analytic tag is used when a winner is determined") @QueryParam("tieTag")  String tieTag,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.updateTournament(version, accountId, missionId, title, subType, imageAssetId, secondsBetweenLevels, secondsForTieBreaker, secondsBetweenPacks, maximumLevelLength, costToPlay, costToPlayType, minimumToPlay, startingLimit, availableLimit, description, metaData, startDate, audienceIds, active, enableBuyBack, offerIds, offerAssetId, fixedReward, splitReward, allocateTickets, tournamentData, visibility, preliminaryGroups, preliminaryGroupAdvancements, enableMultipleEntries, enableMultipleVotes, featured, winnerTag, tieTag, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/trigger/update")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Update Trigger", notes = "Update a trigger", response = TriggerResponse.class, tags={ "Trigger", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = TriggerResponse.class)
    })
    public Response updateTrigger(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The trigger to update", required = true) @QueryParam("triggerId") @NotNull  Long triggerId,@ApiParam(value = "The logged in user", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "The name of the trigger") @QueryParam("name")  String name,@ApiParam(value = "The application to target") @QueryParam("appKey")  String appKey,@ApiParam(value = "Client defined identifier for grouping triggers") @QueryParam("groupingId")  String groupingId,@ApiParam(value = "The URL for making an HTTP call") @QueryParam("endpointURL")  String endpointURL,@ApiParam(value = "The parameters for making an HTTP call") @QueryParam("payload")  String payload,@ApiParam(value = "The date and time of the next trigger") @QueryParam("scheduledDate")  Long scheduledDate,@ApiParam(value = "The starting date of the trigger") @QueryParam("startDate")  Long startDate,@ApiParam(value = "The ending date of the trigger") @QueryParam("endDate")  Long endDate,@ApiParam(value = "The cron expression that represents the trigger's schedule") @QueryParam("cronExpression")  String cronExpression,@ApiParam(value = "Json input representing conditional logic that has to be met before running the trigger") @QueryParam("conditionalInput")  String conditionalInput,@ApiParam(value = "The determines the scope of who is able to find and view the scheduled notification (PUBLIC - openly available to all Sirqul users, PRIVATE - only available to users that have been invited)", allowableValues="PUBLIC, PRIVATE, FRIENDS") @QueryParam("visibility")  String visibility,@ApiParam(value = "Sets whether the Trigger is active or not (inactive Triggers are not processed)") @QueryParam("active")  Boolean active,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.updateTrigger(version, triggerId, accountId, name, appKey, groupingId, endpointURL, payload, scheduledDate, startDate, endDate, cronExpression, conditionalInput, visibility, active, securityContext);
    }
    @javax.ws.rs.PUT
    @Path("/trip/{id}")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Update Trip", notes = "Update an existing trip. Does not support recurring trip update.", response = Trip.class, tags={ "Trip", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = Trip.class)
    })
    public Response updateTrip(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the id of the trip to update", required = true) @PathParam("id") @NotNull  Long id,@ApiParam(value = "") @Valid  Trip body,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.updateTrip(version, id, body, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/trip/notifications")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Trip Notifications", notes = "Update the trip notifications", response = Trip.class, tags={ "Trip", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = Trip.class)
    })
    public Response updateTripNotifications(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the id of the trip", required = true) @QueryParam("id") @NotNull  Long id,@ApiParam(value = "the notifications to update on the trip") @QueryParam("notifications")  String notifications,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.updateTripNotifications(version, id, notifications, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/achievement/progress/update")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Update Achievement Progress", notes = "Update user achievement progress.", response = SirqulResponse.class, tags={ "Achievement", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response updateUserAchievement(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the account id of the user", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "the achievement id (achievementId or tag required)") @QueryParam("achievementId")  Long achievementId,@ApiParam(value = "the analytic tag to identify an achievement (achievementId or tag required)") @QueryParam("tag")  String tag,@ApiParam(value = "a custom identifier used for validation") @QueryParam("customId")  Long customId,@ApiParam(value = "the amount to increment an achievement progress by (if no increment is sent in, the server defaults to using the achievement's rankIncrement value)") @QueryParam("increment")  Long increment,@ApiParam(value = "a custom start date that the client can set (not yet used in server logic)") @QueryParam("startDate")  Long startDate,@ApiParam(value = "a custom end date that the client can set (not yet used in server logic)") @QueryParam("endDate")  Long endDate,@ApiParam(value = "determines whether to return the achievement progress response") @QueryParam("returnProgress")  Boolean returnProgress,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.updateUserAchievement(version, accountId, achievementId, tag, customId, increment, startDate, endDate, returnProgress, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/vatom/b/users/coins/update")
    
    
    @io.swagger.annotations.ApiOperation(value = "Update the coins for a user (as a Business)", notes = "Update the coins for a user (as a Business).", response = Void.class, tags={ "Vatom", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = Void.class)
    })
    public Response updateUserCoinsAsBusiness(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "Sirqul Account Id", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "Vatom User Id", required = true) @QueryParam("vatomUserId") @NotNull  String vatomUserId,@ApiParam(value = "Sirqul Application Key", required = true) @QueryParam("appKey") @NotNull  String appKey,@ApiParam(value = "Vatom Parameters", required = true) @QueryParam("vatomParameters") @NotNull  String vatomParameters,@ApiParam(value = "Return raw response") @QueryParam("returnRawResponse")  Boolean returnRawResponse,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.updateUserCoinsAsBusiness(version, accountId, vatomUserId, appKey, vatomParameters, returnRawResponse, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/vatom/me/update")
    
    
    @io.swagger.annotations.ApiOperation(value = "Update Vatom User Profile", notes = "Gets the logged in user's profile in Vatom.", response = Void.class, tags={ "Vatom", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = Void.class)
    })
    public Response updateUserProfile(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "Sirqul Account Id", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "Vatom Parameters", required = true) @QueryParam("vatomParameters") @NotNull  String vatomParameters,@ApiParam(value = "Return raw response") @QueryParam("returnRawResponse")  Boolean returnRawResponse,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.updateUserProfile(version, accountId, vatomParameters, returnRawResponse, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/vatom/b/events/update")
    
    
    @io.swagger.annotations.ApiOperation(value = "Update Vatom Event", notes = "Update a Vatom event.", response = Void.class, tags={ "Vatom", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = Void.class)
    })
    public Response updateVatomEvent(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "Sirqul Account Id", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "Sirqul Application Key", required = true) @QueryParam("appKey") @NotNull  String appKey,@ApiParam(value = "Vatom Event Id", required = true) @QueryParam("vatomEventId") @NotNull  String vatomEventId,@ApiParam(value = "Vatom Parameters", required = true) @QueryParam("vatomParameters") @NotNull  String vatomParameters,@ApiParam(value = "Return raw response") @QueryParam("returnRawResponse")  Boolean returnRawResponse,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.updateVatomEvent(version, accountId, appKey, vatomEventId, vatomParameters, returnRawResponse, securityContext);
    }
    @javax.ws.rs.PUT
    @Path("/vehicle/{id}")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Update Vehicle", notes = "Update an existing vehicle", response = Vehicle.class, tags={ "Vehicle", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = Vehicle.class)
    })
    public Response updateVehicle(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The id of the vehicle to update", required = true) @PathParam("id") @NotNull  Long id,@ApiParam(value = "A JSON representation of cargo type, for example: ```json {   \"name\": \"Truck\",   \"vehicleType\": { \"id\": 1 },   \"hub\": { \"id\": 1 } } ``` ", required = true) @QueryParam("vehicle") @NotNull  String vehicle,@ApiParam(value = "") @Valid  Vehicle body,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.updateVehicle(version, id, vehicle, body, securityContext);
    }
    @javax.ws.rs.PUT
    @Path("/vehicle/type/{vehicleTypeId}")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Update Vehicle Type", notes = "Update a vehicle type", response = VehicleType.class, tags={ "Vehicle Type", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = VehicleType.class)
    })
    public Response updateVehicleType(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The id of the vehicle type to update", required = true) @PathParam("vehicleTypeId") @NotNull  Long vehicleTypeId,@ApiParam(value = "The new data for the vehicle type to update to. A JSON representation of cargo type, for example: ```json {   \"name\": \"Truck\",   \"width\": 100,   \"height\": 200,   \"depth\": 200,   \"maxWeight\": 5000,   \"hub\": { \"id\": 1 } } ``` ", required = true) @QueryParam("vehicleType") @NotNull  String vehicleType,@ApiParam(value = "") @Valid  VehicleType body,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.updateVehicleType(version, vehicleTypeId, vehicleType, body, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/game/word/update")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Update Word", notes = "Update a word by the given params.", response = WordzWordResponse.class, tags={ "Word", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = WordzWordResponse.class)
    })
    public Response updateWord(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The id of the word to update.", required = true) @QueryParam("wordId") @NotNull  Long wordId,@ApiParam(value = "The logged in user.", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "The number of tickets to reward", required = true, defaultValue = "0") @DefaultValue("0") @QueryParam("ticketCount") @NotNull  Long ticketCount,@ApiParam(value = "The text for the word") @QueryParam("wordText")  String wordText,@ApiParam(value = "The definition of the word.") @QueryParam("definition")  String definition,@ApiParam(value = "The asset id of the word.") @QueryParam("assetId")  Long assetId,@ApiParam(value = "If true set the word to active.") @QueryParam("active")  Boolean active,@ApiParam(value = "If true then scoring will give tickets.") @QueryParam("allocateTickets")  Boolean allocateTickets,@ApiParam(value = "The type of ticket to reward, null means default type") @QueryParam("ticketType")  String ticketType,@ApiParam(value = "The number of points to award for completing a mission") @QueryParam("points")  Long points,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.updateWord(version, wordId, accountId, ticketCount, wordText, definition, assetId, active, allocateTickets, ticketType, points, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/level/words/update")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Update Level Words", notes = "Updates a level with word game objects.", response = SirqulResponse.class, tags={ "Game Level", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response updateWordsInLevel(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the id of the level to update words for", required = true) @QueryParam("levelId") @NotNull  Long levelId,@ApiParam(value = "the id of the logged in user", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "the ids of the words to update for the level", required = true) @QueryParam("wordIds") @NotNull  String wordIds,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.updateWordsInLevel(version, levelId, accountId, wordIds, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/application/certificate/create")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Create Application Certificate", notes = "Uploads a certificate for an application that the user has access to.", response = SirqulResponse.class, tags={ "Application", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response uploadApplicationCertificate(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The key of the application", required = true) @QueryParam("appKey") @NotNull  String appKey,@ApiParam(value = "Device Id") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "The account used to perform the delete, must have rights to edit the application.") @QueryParam("accountId")  Long accountId,@ApiParam(value = "Certificate") @QueryParam("certificate")  File certificate,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.uploadApplicationCertificate(version, appKey, deviceId, accountId, certificate, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/csvimport/upload")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Upload CSV", notes = "Uploads a CSV import file.", response = CsvImportResponse.class, tags={ "CSV Import", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = CsvImportResponse.class)
    })
    public Response uploadCSV(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the id of the account", required = true) @QueryParam("accountId") @NotNull  Long accountId,@ApiParam(value = "the upload type: OFFERS, RETAILERS, RETAILERLOCATIONS, CATEGORIES, OR FILTERS", required = true, allowableValues="OFFERS, RETAILERS, RETAILERLOCATIONS, CATEGORIES, FILTERS") @QueryParam("uploadType") @NotNull  String uploadType,@ApiParam(value = "the import file to reference", required = true) @QueryParam("importFile") @NotNull  File importFile,@ApiParam(value = "the format of the file", required = true, allowableValues="EXCEL, MYSQL, RFC4180, TDF") @QueryParam("fileFormat") @NotNull  String fileFormat,@ApiParam(value = "the application key") @QueryParam("appKey")  String appKey,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.uploadCSV(version, accountId, uploadType, importFile, fileFormat, appKey, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/analytics/usage")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Create Usage Record", notes = "Record an analytic record for a known state within the application.", response = SirqulResponse.class, tags={ "Analytics", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response usage(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The tag to apply: the name of the action or thing being logged.", required = true) @QueryParam("tag") @NotNull  String tag,@ApiParam(value = "The client deviceID") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "The logged in user ID") @QueryParam("accountId")  Long accountId,@ApiParam(value = "This parameter is deprecated. This is deprecated, use appKey.") @QueryParam("applicationId")  Long applicationId,@ApiParam(value = "The application key unique to each application.") @QueryParam("appKey")  String appKey,@ApiParam(value = "The current build version of the application") @QueryParam("appVersion")  String appVersion,@ApiParam(value = "The name of the device being used (iPhone5,1 , HTC Nexus One, x86_64, etc.)") @QueryParam("device")  String device,@ApiParam(value = "The type of device (Handheld or Desktop)") @QueryParam("deviceType")  String deviceType,@ApiParam(value = "The operating system that the device is using (iPhone OS 5.0, Android OS 2.3.6, Windows 7 Service Pack 1, etc)") @QueryParam("deviceOS")  String deviceOS,@ApiParam(value = "The model of the device (iPhone5,1 , Nexus One, etc.)") @QueryParam("model")  String model,@ApiParam(value = "The current position of the user") @QueryParam("latitude")  Double latitude,@ApiParam(value = "The current position of the user") @QueryParam("longitude")  Double longitude,@ApiParam(value = "A customId used to associate the usage record with some other record in the system") @QueryParam("customId")  Long customId,@ApiParam(value = "The type of record the customId is recorded for") @QueryParam("customType")  String customType,@ApiParam(value = "This parameter is deprecated. This is deprecated, use \"customValue\". Determines how many achievement points and/or ranking points the user gets if this analytic is associated with an achievement") @QueryParam("achievementIncrement")  Long achievementIncrement,@ApiParam(value = "The current city of the user") @QueryParam("city")  String city,@ApiParam(value = "The current state of the user") @QueryParam("state")  String state,@ApiParam(value = "The current country of the user") @QueryParam("country")  String country,@ApiParam(value = "The current zip of the user") @QueryParam("zip")  String zip,@ApiParam(value = "The general description of the user's location") @QueryParam("locationDescription")  String locationDescription,@ApiParam(value = "Timestamp sent from device") @QueryParam("clientTime")  Long clientTime,@ApiParam(value = "This parameter is deprecated.") @QueryParam("errorMessage")  String errorMessage,@ApiParam(value = "the ip address of the client device") @QueryParam("ip")  String ip,@ApiParam(value = "this is a description of the client (might contain the device's OS, browser version etc - its a common term)") @QueryParam("userAgent")  String userAgent,@ApiParam(value = "This is deprecated.") @QueryParam("backgroundEvent")  Boolean backgroundEvent,@ApiParam(value = "a custom message for the usage record") @QueryParam("customMessage")  String customMessage,@ApiParam(value = "a custom message for the usage record") @QueryParam("customMessage2")  String customMessage2,@ApiParam(value = "a custom value for the usage record") @QueryParam("customValue")  Double customValue,@ApiParam(value = "a custom value for the usage record") @QueryParam("customValue2")  Double customValue2,@ApiParam(value = "a custom long value for the usage record") @QueryParam("customLong")  Long customLong,@ApiParam(value = "a custom long value for the usage record") @QueryParam("customLong2")  Long customLong2,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.usage(version, tag, deviceId, accountId, applicationId, appKey, appVersion, device, deviceType, deviceOS, model, latitude, longitude, customId, customType, achievementIncrement, city, state, country, zip, locationDescription, clientTime, errorMessage, ip, userAgent, backgroundEvent, customMessage, customMessage2, customValue, customValue2, customLong, customLong2, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/analytics/usage/batch")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Create Multiple Usage Records", notes = "Sends multiple analytics. Can be used to send in the user's stored usage when they did not have internet access. Should not include more than 100 items per batch.", response = SirqulResponse.class, tags={ "Analytics", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response usageBatch(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The application key unique to each application.", required = true) @QueryParam("appKey") @NotNull  String appKey,@ApiParam(value = "The name of the device being used (iPhone5,1 , HTC Nexus One, x86_64, etc.)", required = true) @QueryParam("device") @NotNull  String device,@ApiParam(value = "The analytic data AnalyticListResponse", required = true) @QueryParam("data") @NotNull  String data,@ApiParam(value = "The unique id of the device making the request") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "The account ID of the logged in user making the request") @QueryParam("accountId")  Long accountId,@ApiParam(value = "The current build version of the application") @QueryParam("appVersion")  String appVersion,@ApiParam(value = "The type of device (Handheld or Desktop)") @QueryParam("deviceType")  String deviceType,@ApiParam(value = "The operating system that the device is using (iPhone OS 5.0, Android OS 2.3.6, Windows 7 Service Pack 1, etc.)") @QueryParam("deviceOS")  String deviceOS,@ApiParam(value = "The model of the device (iPhone5,1 , Nexus One, etc.)") @QueryParam("model")  String model,@ApiParam(value = "Will create a leaderboard if one does not exist for the \"tag\" yet") @QueryParam("updateRanking")  Boolean updateRanking,@ApiParam(value = "Returns a summary response of the achievements that have been completed due to the analytics") @QueryParam("returnSummaryResponse")  Boolean returnSummaryResponse,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.usageBatch(version, appKey, device, data, deviceId, accountId, appVersion, deviceType, deviceOS, model, updateRanking, returnSummaryResponse, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/account/validateAccountSignup")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Save Validation Status", notes = "Validate the account's email address. The token must be valid and not expired. Use the RequestValidateAccount end point to request a new token.", response = AccountLoginResponse.class, tags={ "Account", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = AccountLoginResponse.class)
    })
    public Response validateAccountSignup(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The token associated with the account to update, good for 24 hours", required = true) @QueryParam("token") @NotNull  String token,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.validateAccountSignup(version, token, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/account/validatepasswordreset")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Validate Password Reset Token", notes = "Validate the password reset token. The token must be valid and not expired. Use the RequestPasswordReset end point to request a token. The user receives and email with the reset page, therefore it should be validated before bwing used to reset the password.", response = SirqulResponse.class, tags={ "Account", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response validatePasswordReset(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The token associated with the account to update, good for 24 hours", required = true) @QueryParam("token") @NotNull  String token,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.validatePasswordReset(version, token, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/consumer/album/contest/vote")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Vote on Contest", notes = "Vote on a collection in a contest.", response = AlbumContestResponse.class, tags={ "Contest", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = AlbumContestResponse.class)
    })
    public Response voteOnAlbumContest(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "the album contest ID", required = true) @QueryParam("albumContestId") @NotNull  Long albumContestId,@ApiParam(value = "the ID of the album to vote on", required = true) @QueryParam("albumId") @NotNull  Long albumId,@ApiParam(value = "a unique ID given by the device (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "the account ID of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "a custom field used for aggregation and searching") @QueryParam("contestType")  String contestType,@ApiParam(value = "latitude used to update the user's current location") @QueryParam("latitude")  Double latitude,@ApiParam(value = "longitude used to update the user's current location") @QueryParam("longitude")  Double longitude,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.voteOnAlbumContest(version, albumContestId, albumId, deviceId, accountId, contestType, latitude, longitude, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/favorite/whois")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Who has Favorited", notes = "Searches for everyone that has favorited an item", response = AccountResponse.class, responseContainer = "List", tags={ "Favorite", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = AccountResponse.class, responseContainer = "List")
    })
    public Response whoHasFavorited(@ApiParam(value = "", required = true) @PathParam("version") @NotNull  BigDecimal version,@ApiParam(value = "The ID of the favoritableType to search on", required = true) @QueryParam("favoritableId") @NotNull  Long favoritableId,@ApiParam(value = "The type of the object to favorite {OFFER, OFFER_LOCATION, RETAILER_LOCATION, CATEGORY}", required = true) @QueryParam("favoritableType") @NotNull  String favoritableType,@ApiParam(value = "The start index for pagination", required = true) @QueryParam("start") @NotNull  Integer start,@ApiParam(value = "The limit for pagination", required = true) @QueryParam("limit") @NotNull  Integer limit,@ApiParam(value = "The unique ID given by the device (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "The account ID of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "The current latitude of the user") @QueryParam("latitude")  Double latitude,@ApiParam(value = "The current longitude of the user") @QueryParam("longitude")  Double longitude,@ApiParam(value = "The keyword to limit that account list") @QueryParam("keyword")  String keyword,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.whoHasFavorited(version, favoritableId, favoritableType, start, limit, deviceId, accountId, latitude, longitude, keyword, securityContext);
    }
}
