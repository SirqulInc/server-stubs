package org.openapitools.api;

import org.openapitools.api.AlbumApiService;
import org.openapitools.api.factories.AlbumApiServiceFactory;

import io.swagger.annotations.ApiParam;
import io.swagger.jaxrs.*;

import org.openapitools.model.AlbumFullResponse;
import org.openapitools.model.AlbumResponse;
import java.io.File;
import org.openapitools.model.SearchResponse;
import org.openapitools.model.SirqulResponse;

import java.util.Map;
import java.util.List;
import org.openapitools.api.NotFoundException;

import java.io.InputStream;

import org.glassfish.jersey.media.multipart.FormDataParam;
import org.glassfish.jersey.media.multipart.FormDataBodyPart;

import javax.servlet.ServletConfig;
import javax.ws.rs.core.Context;
import javax.ws.rs.core.Response;
import javax.ws.rs.core.SecurityContext;
import javax.ws.rs.*;
import javax.validation.constraints.*;
import javax.validation.Valid;

@Path("/album")


@io.swagger.annotations.Api(description = "the album API")
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaJerseyServerCodegen", date = "2026-02-11T19:26:26.286774429Z[Etc/UTC]", comments = "Generator version: 7.20.0-SNAPSHOT")
public class AlbumApi  {
   private final AlbumApiService delegate;

   public AlbumApi(@Context ServletConfig servletContext) {
      AlbumApiService delegate = null;

      if (servletContext != null) {
         String implClass = servletContext.getInitParameter("AlbumApi.implementation");
         if (implClass != null && !"".equals(implClass.trim())) {
            try {
               delegate = (AlbumApiService) Class.forName(implClass).getDeclaredConstructor().newInstance();
            } catch (Exception e) {
               throw new RuntimeException(e);
            }
         }
      }

      if (delegate == null) {
         delegate = AlbumApiServiceFactory.getAlbumApi();
      }

      this.delegate = delegate;
   }

    @javax.ws.rs.POST
    @Path("/create")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Create Album", notes = "Create an Album.", response = SearchResponse.class, tags={ "Album", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SearchResponse.class)
    })
    public Response addAlbumCollection(@ApiParam(value = "the title of the album", required = true) @QueryParam("title") @NotNull  String title,@ApiParam(value = "determines whether the cover image of the album can be empty, else will use the user's profile picture as the cover image", required = true) @QueryParam("coverAssetNullable") @NotNull  Boolean coverAssetNullable,@ApiParam(value = "determines whether the cover image should be added to the album asset list", required = true) @QueryParam("includeCoverInAssetList") @NotNull  Boolean includeCoverInAssetList,@ApiParam(value = "determines whether the album's participants has read permissions", required = true) @QueryParam("publicRead") @NotNull  Boolean publicRead,@ApiParam(value = "determines whether the album's participants has write permissions", required = true) @QueryParam("publicWrite") @NotNull  Boolean publicWrite,@ApiParam(value = "determines whether the album's participants has delete permissions", required = true) @QueryParam("publicDelete") @NotNull  Boolean publicDelete,@ApiParam(value = "determines whether the album's participants has add permissions", required = true) @QueryParam("publicAdd") @NotNull  Boolean publicAdd,@ApiParam(value = "determines whether the album is posted anonymously", required = true) @QueryParam("anonymous") @NotNull  Boolean anonymous,@ApiParam(value = "a unique ID given by the device (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "the account ID of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "Comma separated list of asset IDs to add to the album's asset list (use \"assetId\" for setting the cover of the album)") @QueryParam("assetsToAdd")  String assetsToAdd,@ApiParam(value = "a MultipartFile containing the cover image of the album (this will only be used if \"assetId\" is empty)") @QueryParam("media")  File media,@ApiParam(value = "this can be used if the \"media\" is a link (this will only be used if \"assetId\" and media are empty)") @QueryParam("mediaURL")  String mediaURL,@ApiParam(value = "The asset ID to set the album cover image") @QueryParam("assetId")  Long assetId,@ApiParam(value = "a MultipartFile containing an asset that the \"media\" file references. Example to upload a video: the \"media\" file should contain a screen capture of the video, and the \"attachedMedia\" should be the actual video.") @QueryParam("attachedMedia")  File attachedMedia,@ApiParam(value = "this can be used if the \"attachedMedia\" is a link (i.e. a Youtube video, etc)") @QueryParam("attachedMediaURL")  String attachedMediaURL,@ApiParam(value = "the start date") @QueryParam("startDate")  Long startDate,@ApiParam(value = "the end date") @QueryParam("endDate")  Long endDate,@ApiParam(value = "the tags") @QueryParam("tags")  String tags,@ApiParam(value = "the description of the album") @QueryParam("description")  String description,@ApiParam(value = "a custom field used for aggregation and searching") @QueryParam("albumType")  String albumType,@ApiParam(value = "a custom indexed number used for aggregation and searching") @QueryParam("albumTypeId")  Long albumTypeId,@ApiParam(value = "a custom string field used for aggregation and searching") @QueryParam("subType")  String subType,@ApiParam(value = "latitude used to update the album's location") @QueryParam("latitude")  Double latitude,@ApiParam(value = "longitude used to update the album's location") @QueryParam("longitude")  Double longitude,@ApiParam(value = "the location description") @QueryParam("locationDescription")  String locationDescription,@ApiParam(value = "the determines the album's participants (PUBLIC - includes everyone in the system as a potential participant, PRIVATE - only considers people who have been invited as participants)", allowableValues="PUBLIC, PRIVATE, FRIENDS") @QueryParam("visibility")  String visibility,@ApiParam(value = "@deprecated, use the appKey") @QueryParam("gameType")  String gameType,@ApiParam(value = "the application key") @QueryParam("appKey")  String appKey,@ApiParam(value = "the cell phone number") @QueryParam("cellPhone")  String cellPhone,@ApiParam(value = "The street address of the location") @QueryParam("streetAddress")  String streetAddress,@ApiParam(value = "Additional address information (such as a suite number, floor number, building name, or PO Box)") @QueryParam("streetAddress2")  String streetAddress2,@ApiParam(value = "The city of the location") @QueryParam("city")  String city,@ApiParam(value = "The state of of the location") @QueryParam("state")  String state,@ApiParam(value = "The postal code of the location") @QueryParam("postalCode")  String postalCode,@ApiParam(value = "The full address of the location which should include the street address, city, state, and postal code") @QueryParam("fullAddress")  String fullAddress,@ApiParam(value = "External custom client defined data") @QueryParam("metaData")  String metaData,@ApiParam(value = "comma separated category ids string associated with the Album") @QueryParam("categoryIds")  String categoryIds,@ApiParam(value = "comma separated filter ids string associated with the Album") @QueryParam("categoryFilterIds")  String categoryFilterIds,@ApiParam(value = "comma separated audience ids string associated with the album") @QueryParam("audienceIds")  String audienceIds,@ApiParam(value = "determines whether to include all app users as members (only admins of the app can do this)") @QueryParam("includeAllAppUsersAsMembers")  Boolean includeAllAppUsersAsMembers,@ApiParam(value = "determines whether to include all users of the audiences as members (only admins of the app can do this)") @QueryParam("includeAudiencesAsMembers")  Boolean includeAudiencesAsMembers,@ApiParam(value = "determines whether to use ands or ors when using the audience list to add users") @QueryParam("audienceOperator")  String audienceOperator,@ApiParam(value = "The approval status to set {PENDING, REJECTED, APPROVED, FEATURED}", allowableValues="PENDING, REJECTED, APPROVED, FEATURED") @QueryParam("approvalStatus")  String approvalStatus,@ApiParam(value = "sets a linked object so that it can be returned as part of the album response") @QueryParam("linkedObjectType")  String linkedObjectType,@ApiParam(value = "sets a linked object id so that it can be returned as part of the album response") @QueryParam("linkedObjectId")  Long linkedObjectId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.addAlbumCollection(title, coverAssetNullable, includeCoverInAssetList, publicRead, publicWrite, publicDelete, publicAdd, anonymous, deviceId, accountId, assetsToAdd, media, mediaURL, assetId, attachedMedia, attachedMediaURL, startDate, endDate, tags, description, albumType, albumTypeId, subType, latitude, longitude, locationDescription, visibility, gameType, appKey, cellPhone, streetAddress, streetAddress2, city, state, postalCode, fullAddress, metaData, categoryIds, categoryFilterIds, audienceIds, includeAllAppUsersAsMembers, includeAudiencesAsMembers, audienceOperator, approvalStatus, linkedObjectType, linkedObjectId, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/user/add")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Add Album Users", notes = "Add users to an album as participants.", response = SirqulResponse.class, tags={ "Album", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response addAlbumUsers(@ApiParam(value = "the album ID", required = true) @QueryParam("albumId") @NotNull  Long albumId,@ApiParam(value = "determines whether to include all friends as participants", required = true) @QueryParam("includeFriendGroup") @NotNull  Boolean includeFriendGroup,@ApiParam(value = "a unique ID given by the device (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "the account ID of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "determines whether the users being added have read permissions") @QueryParam("read")  Boolean read,@ApiParam(value = "determines whether the users being added have write permissions") @QueryParam("write")  Boolean write,@ApiParam(value = "determines whether the users being added have delete permissions") @QueryParam("delete")  Boolean delete,@ApiParam(value = "determines whether the users being added have add permissions") @QueryParam("add")  Boolean add,@ApiParam(value = "comma separated list of connection IDs") @QueryParam("connections")  String connections,@ApiParam(value = "comma separated list of connection group IDs") @QueryParam("connectionGroups")  String connectionGroups,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.addAlbumUsers(albumId, includeFriendGroup, deviceId, accountId, read, write, delete, add, connections, connectionGroups, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/approve")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Approve Album", notes = "Sets the approval status of an Album.", response = SirqulResponse.class, tags={ "Album", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response approveAlbum(@ApiParam(value = "The ID of the album", required = true) @QueryParam("albumId") @NotNull  Long albumId,@ApiParam(value = "A unique ID given by the device (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "The account ID of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "The approval status to set {PENDING, REJECTED, APPROVED, FEATURED}", allowableValues="PENDING, REJECTED, APPROVED, FEATURED") @QueryParam("approvalStatus")  String approvalStatus,@ApiParam(value = "Sets whether the album should be marked as \"verified\"") @QueryParam("verified")  Boolean verified,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.approveAlbum(albumId, deviceId, accountId, approvalStatus, verified, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/get")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = " Get Album", notes = "Get an Album.", response = AlbumFullResponse.class, tags={ "Album", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = AlbumFullResponse.class)
    })
    public Response getAlbumCollection(@ApiParam(value = "This parameter is deprecated.", required = true) @QueryParam("returnNulls") @NotNull  Boolean returnNulls,@ApiParam(value = "the album to look up", required = true) @QueryParam("albumId") @NotNull  Long albumId,@ApiParam(value = "a unique ID given by the device (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "the account ID of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "returns the last X likes. To search on and paginate the remaining likes - please use the \"/like/search\"Â endpoint.") @QueryParam("likePreviewSize")  Integer likePreviewSize,@ApiParam(value = "returns the first X assets. To search on and paginate the remaining assets - please use the \"/assets/search\"Â endpoint.") @QueryParam("assetPreviewSize")  Integer assetPreviewSize,@ApiParam(value = "returns the last X notes. To search on and paginate the remaining notes - please use the \"/note/search\" endpoint.") @QueryParam("notePreviewSize")  Integer notePreviewSize,@ApiParam(value = "returns the first X users/connections. To search on and paginate the remaining connections - please use the \"/permissions/search\" endpoint.") @QueryParam("connectionPreviewSize")  Integer connectionPreviewSize,@ApiParam(value = "returns the first X audiences. To search on and paginate the remaining audiences - please use the \"/audience/search\" endpoint.") @QueryParam("audiencePreviewSize")  Integer audiencePreviewSize,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.getAlbumCollection(returnNulls, albumId, deviceId, accountId, likePreviewSize, assetPreviewSize, notePreviewSize, connectionPreviewSize, audiencePreviewSize, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/user/leave")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Leave Album", notes = " Allows a user to leave an album (they are no longer considered a participant). The album creator cannot leave their own albums.", response = SirqulResponse.class, tags={ "Album", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response leaveAlbum(@ApiParam(value = "the album ID", required = true) @QueryParam("albumId") @NotNull  Long albumId,@ApiParam(value = "a unique ID given by the device (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "the account ID of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.leaveAlbum(albumId, deviceId, accountId, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/delete")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Delete Album", notes = "Deletes an Album", response = SirqulResponse.class, tags={ "Album", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response removeAlbum(@ApiParam(value = "the album ID to delete", required = true) @QueryParam("albumId") @NotNull  Long albumId,@ApiParam(value = "a unique ID given by the device (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "the account ID of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.removeAlbum(albumId, deviceId, accountId, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/user/delete")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Remove Album Users", notes = "Remove participants of an album.", response = SirqulResponse.class, tags={ "Album", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = SirqulResponse.class)
    })
    public Response removeAlbumUsers(@ApiParam(value = "the album ID", required = true) @QueryParam("albumId") @NotNull  Long albumId,@ApiParam(value = "remove friend group", required = true) @QueryParam("removeFriendGroup") @NotNull  Boolean removeFriendGroup,@ApiParam(value = "a unique ID given by the device (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "the account ID of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "comma separated list of connection IDs") @QueryParam("connections")  String connections,@ApiParam(value = "comma separated list of connection group IDs") @QueryParam("connectionGroups")  String connectionGroups,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.removeAlbumUsers(albumId, removeFriendGroup, deviceId, accountId, connections, connectionGroups, securityContext);
    }
    @javax.ws.rs.GET
    @Path("/search")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Search Albums", notes = "Searches on Albums.", response = AlbumFullResponse.class, responseContainer = "List", tags={ "Album", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = AlbumFullResponse.class, responseContainer = "List")
    })
    public Response searchAlbums(@ApiParam(value = "a comma separated list of filters: * MINE - Return albums that the user has created. * SHARED - Return albums that have been shared to the user via addAlbumUsers, or addUsersToPermissionable . * FOLLOWER - Return albums that have been created by the user's followers (the content needs to have been APPROVED or FEATURED). * FOLLOWING - Return albums that have been created by people who the user is following (the content needs to have been APPROVED or FEATURED). * PUBLIC - Return all PUBLIC albums that have been APPROVED or FEATURED. * ALL_PUBLIC - Return all PUBLIC albums regardless of whether they are approved or not (ignores the approval status). * LIKED - Return all albums that the user has liked. * FEATURED - Return all albums that have been featured. * PENDING - Return all pending albums. ", required = true) @QueryParam("filter") @NotNull  String filter,@ApiParam(value = "id of custom albumType", required = true) @QueryParam("albumTypeId") @NotNull  Long albumTypeId,@ApiParam(value = "filter albums with this album sub type", required = true) @QueryParam("subType") @NotNull  String subType,@ApiParam(value = "determines whether to return inactive albums", required = true) @QueryParam("includeInactive") @NotNull  Boolean includeInactive,@ApiParam(value = "the field to sort by. See AlbumApiMap", required = true) @QueryParam("sortField") @NotNull  String sortField,@ApiParam(value = "determines whether the sorted list is in descending or ascending order", required = true) @QueryParam("descending") @NotNull  Boolean descending,@ApiParam(value = "the start index for pagination", required = true) @QueryParam("start") @NotNull  Integer start,@ApiParam(value = "the limit for pagination (There is a hard limit of 100)", required = true) @QueryParam("limit") @NotNull  Integer limit,@ApiParam(value = "the maximum range the album can be from the center (used when sortField=ALBUM_DISTANCE)", required = true) @QueryParam("range") @NotNull  Double range,@ApiParam(value = "returns whether or not the current logged in user has liked the album", required = true) @QueryParam("includeLiked") @NotNull  Boolean includeLiked,@ApiParam(value = "returns whether or not the current logged in user has favorited the album", required = true) @QueryParam("includeFavorited") @NotNull  Boolean includeFavorited,@ApiParam(value = "returns permission details on whether they have read/write/delete permissions etc (client app probably doesn't need this)", required = true) @QueryParam("includePermissions") @NotNull  Boolean includePermissions,@ApiParam(value = "returns the last X likes", required = true) @QueryParam("likePreviewSize") @NotNull  Integer likePreviewSize,@ApiParam(value = "returns the first X assets", required = true) @QueryParam("assetPreviewSize") @NotNull  Integer assetPreviewSize,@ApiParam(value = "returns the last X notes", required = true) @QueryParam("notePreviewSize") @NotNull  Integer notePreviewSize,@ApiParam(value = "returns the first X users/connections", required = true) @QueryParam("connectionPreviewSize") @NotNull  Integer connectionPreviewSize,@ApiParam(value = "returns the first X audiences. To search on and paginate the remaining audiences, please use the \"/audience/search\" endpoint.", required = true) @QueryParam("audiencePreviewSize") @NotNull  Integer audiencePreviewSize,@ApiParam(value = "a unique ID given by the device (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "the account ID of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "the account ID of the user that the results will be based on. This is used to return albums that this account has liked/favorited.") @QueryParam("connectionAccountId")  Long connectionAccountId,@ApiParam(value = "search on albums that have been created by this account (that the user has permissions to)") @QueryParam("ownerId")  Long ownerId,@ApiParam(value = "search on album within a comma separated list of album IDs (this does not work with sortField=ALBUM_DISTANCE, or when stackSearch=true)") @QueryParam("albumIds")  String albumIds,@ApiParam(value = "Only for CLOUDINDEX mode, exclude albums with ids matching this list") @QueryParam("excludeAlbumIds")  String excludeAlbumIds,@ApiParam(value = "search on albums that are in a particular media offering") @QueryParam("mediaId")  Long mediaId,@ApiParam(value = "keyword search string") @QueryParam("keyword")  String keyword,@ApiParam(value = "filter albums with this album type") @QueryParam("albumType")  String albumType,@ApiParam(value = "When using multiple album types this sets a per-album-type limit (used with cloud index mode)") @QueryParam("limitPerAlbumType")  Integer limitPerAlbumType,@ApiParam(value = "return items that have been created before this date (time-stamp in milliseconds)") @QueryParam("dateCreated")  Long dateCreated,@ApiParam(value = "return items that have been updated since this date (time-stamp in milliseconds)") @QueryParam("updatedSince")  Long updatedSince,@ApiParam(value = "return items that have been updated before this date (time-stamp in milliseconds)") @QueryParam("updatedBefore")  Long updatedBefore,@ApiParam(value = "return items that have been created since this date (time-stamp in milliseconds)") @QueryParam("createdSince")  Long createdSince,@ApiParam(value = "return items that have been created before this date (time-stamp in milliseconds)") @QueryParam("createdBefore")  Long createdBefore,@ApiParam(value = "return items that have been started since this date (time-stamp in milliseconds)") @QueryParam("startedSince")  Long startedSince,@ApiParam(value = "return items that have been started before this date (time-stamp in milliseconds)") @QueryParam("startedBefore")  Long startedBefore,@ApiParam(value = "return items that have been ended since this date (time-stamp in milliseconds)") @QueryParam("endedSince")  Long endedSince,@ApiParam(value = "return items that have been ended before this date (time-stamp in milliseconds)") @QueryParam("endedBefore")  Long endedBefore,@ApiParam(value = "the latitude of where the search is centered on (used when sortField=ALBUM_DISTANCE)") @QueryParam("latitude")  Double latitude,@ApiParam(value = "the longitude of where the search is centered on (used when sortField=ALBUM_DISTANCE)") @QueryParam("longitude")  Double longitude,@ApiParam(value = "the application key to filter results by application. This is required for consumer searches. Leaving this empty will return albums for the applications that the logged in user owns or has access to.") @QueryParam("appKey")  String appKey,@ApiParam(value = "return results with categories matching this list") @QueryParam("categoryIds")  String categoryIds,@ApiParam(value = "return results with filters matching this list") @QueryParam("categoryFilterIds")  String categoryFilterIds,@ApiParam(value = "return results with audiences matching this list") @QueryParam("audienceIds")  String audienceIds,@ApiParam(value = "exclude audiences with ids matching this list") @QueryParam("excludeAudienceIds")  String excludeAudienceIds,@ApiParam(value = "returns the user's completable object for the album if it exists") @QueryParam("includeCompletable")  Boolean includeCompletable,@ApiParam(value = "returns the user's rating for the album if it exists") @QueryParam("includeRating")  Boolean includeRating,@ApiParam(value = "The search index mode to use (RDS, LUCENE, or CLOUDINDEX). If not provided will use server default.") @QueryParam("searchMode")  String searchMode,@ApiParam(value = "groups similar albums together that have the same albumTypeId, within a time window defined in stackWindowSize") @QueryParam("stackSearch")  Boolean stackSearch,@ApiParam(value = "size of each window for each stack") @QueryParam("stackWindowSize")  Integer stackWindowSize,@ApiParam(value = "The minimum number of stacks returned in a response. For example,  first call, minStackPerPage = 20, the API will return at least 20 results") @QueryParam("minStackPerPage")  Integer minStackPerPage,@ApiParam(value = "this is used to tell the system where it left off on the previous previous page, since we can't use start/limit for stackSearch") @QueryParam("stackPaginationIdentifier")  String stackPaginationIdentifier,@ApiParam(value = "set this to true when making the call to view the albums in the stack") @QueryParam("stackDetails")  Boolean stackDetails,@ApiParam(value = "Return any results that have a minimum of the specified flag count (even ones that have met the flag threshold)") @QueryParam("flagCountMinimum")  Long flagCountMinimum,@ApiParam(value = "return items that have flagCount >= flagThreshold (controls removal of flagged content)", defaultValue = "true") @DefaultValue("true") @QueryParam("removeFlaggedContent")  Boolean removeFlaggedContent,@ApiParam(value = "setting to true will return only verified albums only, setting to false will return non-verified albums only (leave empty to return both)") @QueryParam("verifiedFilter")  Boolean verifiedFilter,@ApiParam(value = "filter results by the linkedObjectType") @QueryParam("linkedObjectType")  String linkedObjectType,@ApiParam(value = "filter results by the linkedObjectId") @QueryParam("linkedObjectId")  Long linkedObjectId,@ApiParam(value = "determines whether to use the order assigned via the /album/order/_* api (which is tied to an audience)") @QueryParam("orderAudienceId")  Long orderAudienceId,@ApiParam(value = "if true, ignore the application's default app filter when searching") @QueryParam("ignoreDefaultAppFilter")  Boolean ignoreDefaultAppFilter,@ApiParam(value = "Advanced search expression to be used by the server") @QueryParam("searchExpression")  String searchExpression,@ApiParam(value = "If true and results are empty, attempt to generate albums via templates") @QueryParam("generateAlbums")  Boolean generateAlbums,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.searchAlbums(filter, albumTypeId, subType, includeInactive, sortField, descending, start, limit, range, includeLiked, includeFavorited, includePermissions, likePreviewSize, assetPreviewSize, notePreviewSize, connectionPreviewSize, audiencePreviewSize, deviceId, accountId, connectionAccountId, ownerId, albumIds, excludeAlbumIds, mediaId, keyword, albumType, limitPerAlbumType, dateCreated, updatedSince, updatedBefore, createdSince, createdBefore, startedSince, startedBefore, endedSince, endedBefore, latitude, longitude, appKey, categoryIds, categoryFilterIds, audienceIds, excludeAudienceIds, includeCompletable, includeRating, searchMode, stackSearch, stackWindowSize, minStackPerPage, stackPaginationIdentifier, stackDetails, flagCountMinimum, removeFlaggedContent, verifiedFilter, linkedObjectType, linkedObjectId, orderAudienceId, ignoreDefaultAppFilter, searchExpression, generateAlbums, securityContext);
    }
    @javax.ws.rs.POST
    @Path("/update")
    
    @Produces({ "*/*" })
    @io.swagger.annotations.ApiOperation(value = "Update Album", notes = "Update an Album.", response = AlbumResponse.class, tags={ "Album", })
    @io.swagger.annotations.ApiResponses(value = {
        @io.swagger.annotations.ApiResponse(code = 200, message = "successful operation", response = AlbumResponse.class)
    })
    public Response updateAlbumCollection(@ApiParam(value = "the ID of the album to update", required = true) @QueryParam("albumId") @NotNull  Long albumId,@ApiParam(value = "a unique ID given by the device (deviceId or accountId required)") @QueryParam("deviceId")  String deviceId,@ApiParam(value = "the account ID of the user (deviceId or accountId required)") @QueryParam("accountId")  Long accountId,@ApiParam(value = "Comma separated list of asset IDs to add to the album's asset list (use \"assetId\" for setting the cover of the album)") @QueryParam("assetsToAdd")  String assetsToAdd,@ApiParam(value = "Comma separated list of asset IDs to remove from the album's asset list") @QueryParam("assetsToRemove")  String assetsToRemove,@ApiParam(value = "the cover asset ID") @QueryParam("assetId")  Long assetId,@ApiParam(value = "a MultipartFile containing the cover image of the album (this will only be used if \"assetId\" is empty)") @QueryParam("media")  File media,@ApiParam(value = "this can be used if the \"media\" is a link (this will only be used if \"assetId\" and media are empty)") @QueryParam("mediaURL")  String mediaURL,@ApiParam(value = "determines whether the album is active or inactive") @QueryParam("active")  Boolean active,@ApiParam(value = "the title of the album") @QueryParam("title")  String title,@ApiParam(value = "the start date") @QueryParam("startDate")  Long startDate,@ApiParam(value = "the end date") @QueryParam("endDate")  Long endDate,@ApiParam(value = "the tags") @QueryParam("tags")  String tags,@ApiParam(value = "the description of the album") @QueryParam("description")  String description,@ApiParam(value = "a custom field used for aggregation and searching") @QueryParam("albumType")  String albumType,@ApiParam(value = "a custom indexed number used for aggregation and searching") @QueryParam("albumTypeId")  Long albumTypeId,@ApiParam(value = "a custom string field used for aggregation and searching") @QueryParam("subType")  String subType,@ApiParam(value = "determines whether the album's participants have read permissions") @QueryParam("publicRead")  Boolean publicRead,@ApiParam(value = "determines whether the album's participants have write permissions") @QueryParam("publicWrite")  Boolean publicWrite,@ApiParam(value = "determines whether the album's participants have delete permissions") @QueryParam("publicDelete")  Boolean publicDelete,@ApiParam(value = "determines whether the album's participants have add permissions") @QueryParam("publicAdd")  Boolean publicAdd,@ApiParam(value = "latitude used to update the album's location") @QueryParam("latitude")  Double latitude,@ApiParam(value = "longitude used to update the album's location") @QueryParam("longitude")  Double longitude,@ApiParam(value = "the location description") @QueryParam("locationDescription")  String locationDescription,@ApiParam(value = "the determines the album's participants (PUBLIC - includes everyone in the system as a potential participant, PRIVATE - only considers people who have been invited as participants)", allowableValues="PUBLIC, PRIVATE, FRIENDS") @QueryParam("visibility")  String visibility,@ApiParam(value = "the cell phone number") @QueryParam("cellPhone")  String cellPhone,@ApiParam(value = "The street address of the location") @QueryParam("streetAddress")  String streetAddress,@ApiParam(value = "Additional address information (such as a suite number, floor number, building name, or PO Box)") @QueryParam("streetAddress2")  String streetAddress2,@ApiParam(value = "The city of the location") @QueryParam("city")  String city,@ApiParam(value = "The state of of the location") @QueryParam("state")  String state,@ApiParam(value = "The postal code of the location") @QueryParam("postalCode")  String postalCode,@ApiParam(value = "The full address of the location which should include the street address, city, state, and postal code") @QueryParam("fullAddress")  String fullAddress,@ApiParam(value = "determines whether the album is posted anonymously") @QueryParam("anonymous")  Boolean anonymous,@ApiParam(value = "External custom client defined data") @QueryParam("metaData")  String metaData,@ApiParam(value = "comma separated category ids string associated with the Album") @QueryParam("categoryIds")  String categoryIds,@ApiParam(value = "comma separated filter ids string associated with the Album") @QueryParam("categoryFilterIds")  String categoryFilterIds,@ApiParam(value = "comma separated audience ids string associated with the album") @QueryParam("audienceIds")  String audienceIds,@ApiParam(value = "comma separated audience ids to add to the album") @QueryParam("audienceIdsToAdd")  String audienceIdsToAdd,@ApiParam(value = "comma separated audience ids to remove from the album (overrides audienceIds and audienceIdsToAdd)") @QueryParam("audienceIdsToRemove")  String audienceIdsToRemove,@ApiParam(value = "determines whether to include all app users as members (only admins of the app can do this)") @QueryParam("includeAllAppUsersAsMembers")  Boolean includeAllAppUsersAsMembers,@ApiParam(value = "determines whether to include all users of the audiences as members (only admins of the app can do this)") @QueryParam("includeAudiencesAsMembers")  Boolean includeAudiencesAsMembers,@ApiParam(value = "determines whether to use ands or ors when using the audience list to add users") @QueryParam("audienceOperator")  String audienceOperator,@ApiParam(value = "sets a linked object so that it can be returned as part of the album response") @QueryParam("linkedObjectType")  String linkedObjectType,@ApiParam(value = "sets a linked object id so that it can be returned as part of the album response") @QueryParam("linkedObjectId")  Long linkedObjectId,@ApiParam(value = "determines whether the album should be indexed immediately") @QueryParam("indexNow")  Boolean indexNow,@Context SecurityContext securityContext)
    throws NotFoundException {
        return delegate.updateAlbumCollection(albumId, deviceId, accountId, assetsToAdd, assetsToRemove, assetId, media, mediaURL, active, title, startDate, endDate, tags, description, albumType, albumTypeId, subType, publicRead, publicWrite, publicDelete, publicAdd, latitude, longitude, locationDescription, visibility, cellPhone, streetAddress, streetAddress2, city, state, postalCode, fullAddress, anonymous, metaData, categoryIds, categoryFilterIds, audienceIds, audienceIdsToAdd, audienceIdsToRemove, includeAllAppUsersAsMembers, includeAudiencesAsMembers, audienceOperator, linkedObjectType, linkedObjectId, indexNow, securityContext);
    }
}
