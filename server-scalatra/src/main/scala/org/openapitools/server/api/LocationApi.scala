/**
 * Sirqul IoT Platform
 * Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>
 *
 * The version of the OpenAPI document: 3.16
 * Contact: info@sirqul.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 */


package org.openapitools.server.api

import org.openapitools.server.model.CoordsResponse
import java.io.File
import org.openapitools.server.model.GeoPointResponse
import org.openapitools.server.model.LocationSearchResponse
import org.openapitools.server.model.SirqulResponse
import org.openapitools.server.model.TrilatCacheRequest

import java.io.File

import org.scalatra.ScalatraServlet
import org.scalatra.swagger._
import org.json4s._
import org.json4s.JsonDSL._
import org.scalatra.json.{ JValueResult, JacksonJsonSupport }
import org.scalatra.servlet.{ FileUploadSupport, MultipartConfig, SizeConstraintExceededException }

import scala.collection.JavaConverters._

class LocationApi(implicit val swagger: Swagger) extends ScalatraServlet
  with FileUploadSupport
  with JacksonJsonSupport
  with SwaggerSupport {
  protected implicit val jsonFormats: Formats = DefaultFormats

  protected val applicationDescription: String = "LocationApi"

  before() {
    contentType = formats("json")
    response.headers += ("Access-Control-Allow-Origin" -> "*")
  }
  

  val cacheTrilaterationDataOperation = (apiOperation[SirqulResponse]("cacheTrilaterationData")
    summary "Create Trilateration Data with File"
    parameters(queryParam[String]("udid").description(""), queryParam[Long]("sourceTime").description("").optional, queryParam[Int]("minimumSampleSize").description("").optional, queryParam[String]("data").description("").optional, queryParam[File]("dataFile").description("").optional)
  )

  post("/location/trilaterate/cache", operation(cacheTrilaterationDataOperation)) {
            val udid = params.getAs[String]("udid")

    //println("udid: " + udid)
            val sourceTime = params.getAs[Long]("sourceTime")

    //println("sourceTime: " + sourceTime)
            val minimumSampleSize = params.getAs[Int]("minimumSampleSize")

    //println("minimumSampleSize: " + minimumSampleSize)
            val data = params.getAs[String]("data")

    //println("data: " + data)
    val dataFile = fileParams("dataFile")
    //println("dataFile: " + dataFile)
  }

  

  val cacheTrilaterationDataGzipOperation = (apiOperation[SirqulResponse]("cacheTrilaterationDataGzip")
    summary "Create Trilateration Data with Rest"
    parameters(bodyParam[TrilatCacheRequest]("body").description("").optional)
  )

  post("/location/trilaterate/cache/submit", operation(cacheTrilaterationDataGzipOperation)) {
    //println("body: " + body)
  }

  

  val getLocationByIpOperation = (apiOperation[CoordsResponse]("getLocationByIp")
    summary "Get Location by IP"
    parameters(queryParam[String]("ip").description("").optional)
  )

  get("/location/ip", operation(getLocationByIpOperation)) {
            val ip = params.getAs[String]("ip")

    //println("ip: " + ip)
  }

  

  val getLocationByTrilaterationOperation = (apiOperation[GeoPointResponse]("getLocationByTrilateration")
    summary "Get Location by Trilateration"
    parameters(queryParam[Long]("accountId").description("").optional, queryParam[Double]("latitude").description("").optional, queryParam[Double]("longitude").description("").optional, queryParam[String]("data").description("").optional, queryParam[String]("responseFilters").description("").optional)
  )

  get("/account/location/trilaterate", operation(getLocationByTrilaterationOperation)) {
            val accountId = params.getAs[Long]("accountId")

    //println("accountId: " + accountId)
            val latitude = params.getAs[Double]("latitude")

    //println("latitude: " + latitude)
            val longitude = params.getAs[Double]("longitude")

    //println("longitude: " + longitude)
            val data = params.getAs[String]("data")

    //println("data: " + data)
            val responseFilters = params.getAs[String]("responseFilters")

    //println("responseFilters: " + responseFilters)
  }

  

  val getLocationsOperation = (apiOperation[LocationSearchResponse]("getLocations")
    summary "Search Regions or Postal Codes"
    parameters(queryParam[String]("deviceId").description("").optional, queryParam[Long]("accountId").description("").optional, queryParam[Double]("currentlatitude").description("").optional, queryParam[Double]("currentlongitude").description("").optional, queryParam[Double]("currentLatitude").description("").optional, queryParam[Double]("currentLongitude").description("").optional, queryParam[String]("query").description("").optional, queryParam[String]("zipcode").description("").optional, queryParam[String]("zipCode").description("").optional, queryParam[Double]("selectedMaplatitude").description("").optional, queryParam[Double]("selectedMaplongitude").description("").optional, queryParam[Double]("selectedMapLatitude").description("").optional, queryParam[Double]("selectedMapLongitude").description("").optional, queryParam[Double]("searchRange").description("").optional.defaultValue(5), queryParam[Boolean]("useGeocode").description("").optional.defaultValue(false), queryParam[Int]("i").description("").optional, queryParam[Int]("start").description("").optional.defaultValue(0), queryParam[Int]("l").description("").optional, queryParam[Int]("limit").description("").optional.defaultValue(20))
  )

  get("/location/search", operation(getLocationsOperation)) {
            val deviceId = params.getAs[String]("deviceId")

    //println("deviceId: " + deviceId)
            val accountId = params.getAs[Long]("accountId")

    //println("accountId: " + accountId)
            val currentlatitude = params.getAs[Double]("currentlatitude")

    //println("currentlatitude: " + currentlatitude)
            val currentlongitude = params.getAs[Double]("currentlongitude")

    //println("currentlongitude: " + currentlongitude)
            val currentLatitude = params.getAs[Double]("currentLatitude")

    //println("currentLatitude: " + currentLatitude)
            val currentLongitude = params.getAs[Double]("currentLongitude")

    //println("currentLongitude: " + currentLongitude)
            val query = params.getAs[String]("query")

    //println("query: " + query)
            val zipcode = params.getAs[String]("zipcode")

    //println("zipcode: " + zipcode)
            val zipCode = params.getAs[String]("zipCode")

    //println("zipCode: " + zipCode)
            val selectedMaplatitude = params.getAs[Double]("selectedMaplatitude")

    //println("selectedMaplatitude: " + selectedMaplatitude)
            val selectedMaplongitude = params.getAs[Double]("selectedMaplongitude")

    //println("selectedMaplongitude: " + selectedMaplongitude)
            val selectedMapLatitude = params.getAs[Double]("selectedMapLatitude")

    //println("selectedMapLatitude: " + selectedMapLatitude)
            val selectedMapLongitude = params.getAs[Double]("selectedMapLongitude")

    //println("selectedMapLongitude: " + selectedMapLongitude)
            val searchRange = params.getAs[Double]("searchRange")

    //println("searchRange: " + searchRange)
            val useGeocode = params.getAs[Boolean]("useGeocode")

    //println("useGeocode: " + useGeocode)
            val i = params.getAs[Int]("i")

    //println("i: " + i)
            val start = params.getAs[Int]("start")

    //println("start: " + start)
            val l = params.getAs[Int]("l")

    //println("l: " + l)
            val limit = params.getAs[Int]("limit")

    //println("limit: " + limit)
  }

}
