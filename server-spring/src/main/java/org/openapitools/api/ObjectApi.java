/*
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech) (7.20.0-SNAPSHOT).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
package org.openapitools.api;

import org.springframework.lang.Nullable;
import org.openapitools.model.ObjectStoreResponse;
import io.swagger.v3.oas.annotations.ExternalDocumentation;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.Parameters;
import io.swagger.v3.oas.annotations.media.ArraySchema;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import io.swagger.v3.oas.annotations.enums.ParameterIn;
import io.swagger.v3.oas.annotations.media.ExampleObject;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.context.request.NativeWebRequest;
import org.springframework.web.multipart.MultipartFile;

import javax.validation.Valid;
import javax.validation.constraints.*;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import javax.annotation.Generated;

@Generated(value = "org.openapitools.codegen.languages.SpringCodegen", date = "2026-02-11T19:32:41.765375324Z[Etc/UTC]", comments = "Generator version: 7.20.0-SNAPSHOT")
@Validated
@Tag(name = "Object Store", description = "the Object Store API")
public interface ObjectApi {

    default Optional<NativeWebRequest> getRequest() {
        return Optional.empty();
    }

    String PATH_ADD_FIELD = "/object/field/add";
    /**
     * POST /object/field/add : Create Field
     * Add a field to a specific object.  The field name should be camel   case with the first letter lower case, for example: myFieldName.  Duplicate   field names are not allowed.   The field name cannot be any of the following   reserved words: ACCESSIBLE, ADD, ALL, ALTER, ANALYZE, AND, AS, ASC, ASENSITIVE,   BEFORE, BETWEEN, BIGINT, BINARY, BLOB, BOTH, BY, CALL, CASCADE, CASE, CHANGE,   CHAR, CHARACTER, CHECK, COLLATE, COLUMN, CONDITION, CONSTRAINT, CONTINUE,   CONVERT, CREATE, CROSS, CURRENT_, ATE, CURRENT_TIME, CURRENT_TIMESTAMP,   CURRENT_USER, CURSOR, DATABASE, DATABASES, DAY_HOUR, DAY_MICROSECOND, DAY_MINUTE,   DAY_SECOND, DEC, DECIMAL, DECLARE, DEFAULT, DELAYED, DELETE, DESC, DESCRIBE,   DETERMINISTIC, DISTINCT, DISTINCTROW, DIV, DOUBLE, DROP, DUAL, EACH, ELSE,   ELSEIF, ENCLOSED, ESCAPED, EXISTS, EXIT, EXPLAIN, FALSE, FETCH, FLOAT, FLOAT4,   FLOAT8, FOR, FORCE, FOREIGN, FROM, FULLTEXT, GRANT, GROUP, HAVING, HIGH_PRIORITY,   HOUR_MICROSECOND, HOUR_MINUTE, HOUR_SECOND, IF, IGNORE, IN, INDEX, INFILE,   INNER, INOUT, INSENSITIVE, INSERT, INT, INT1, INT2, INT3, INT4, INT8, INTEGER,   INTERVAL, INTO, IS, ITERATE, JOIN, KEY, KEYS, KILL, LEADING, LEAVE, LEFT,   LIKE, LIMIT, LINEAR, LINES, LOAD, LOCALTIME, LOCALTIMESTAMP, LOCK, LONG,   LONGBLOB, LONGT, XT, LOOP, LOW_PRIORITY, MASTER_SSL_VERIFY_SERVER_CERT,   MATCH, MAXVALUE, MEDIUMBLOB, MEDIUMINT, MEDIUMTEXT, MIDDLEINT, MINUTE_MICROSECOND,   MINUTE_SECOND, MOD, MODIFIES, NATURAL, NOT, NO_WRITE_TO_BINLOG, NULL, NUMERIC,   ON, OPTIMIZE, OPTION, OPTIONALLY, OR, ORDER, OUT, OUTER, OUTFILE, PRECISION,   PRIMARY, PROCEDURE, PURGE, RANGE, READ, READS, READ_WRITE, REAL, REFERENCES,   REGEXP, RELEASE, RENAME, REPEAT, REPLACE, REQUIRE, RESIGNAL, RESTRICT, RETURN,   REVOKE, RIGHT, RLIKE, SCHEMA, SCHEMAS, SECOND_MICROSECOND, SELECT, SENSITIVE,   SEPARATOR, SET, SHOW, SIGNAL, SMALLINT, SPATIAL, SPECIFIC, SQL, SQLEXCEPTION,   SQLSTATE, SQLWARNING, SQL_BIG_RESULT, SQL_CALC_FOUND_ROWS, SQL_SMALL_RESULT,   SSL, STARTING, STRAIGHT_JOIN, TABLE, TERMINATED, THEN, TINYBLOB, TINYINT,   TINYTEXT, TO, TRAILING, TRIGGER, TRUE, NDO, UNION, UNIQUE, UNLOCK, UNSIGNED,   UPDATE, USAGE, USE, USING, UTC_DATE, UTC_TIME, UTC_TIMESTAMP, VALUES, VARBINARY,   VARCHAR, VARCHARACTER, VARYING, WHEN, WHERE, WHILE, WITH, WRITE, XOR, YEAR_MONTH,   ZEROFILL, GENERAL, IGNORE_SERVER_IDS, MASTER_HEARTBEAT_PERIOD, SLOW.     The following field names are reserved (cannot be used directly) and are automatically   included during object creation: ID, OBJECTID, CREATED, UPDATED, DELETED.   Additionally the field names must start with a letter or number.
     *
     * @param accountId The account id of the logged in user (required)
     * @param appKey The application key for updating an existing application (required)
     * @param objectName The name of the object to add the field to (required)
     * @param fieldName field name The name of the field to add. (required)
     * @param fieldType field type The field type to create, supported types are: STRING, DATE, NUMBER, BOOLEAN, IDENTITY (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "addField",
        summary = "Create Field",
        description = "Add a field to a specific object.  The field name should be camel   case with the first letter lower case, for example: myFieldName.  Duplicate   field names are not allowed.   The field name cannot be any of the following   reserved words: ACCESSIBLE, ADD, ALL, ALTER, ANALYZE, AND, AS, ASC, ASENSITIVE,   BEFORE, BETWEEN, BIGINT, BINARY, BLOB, BOTH, BY, CALL, CASCADE, CASE, CHANGE,   CHAR, CHARACTER, CHECK, COLLATE, COLUMN, CONDITION, CONSTRAINT, CONTINUE,   CONVERT, CREATE, CROSS, CURRENT_, ATE, CURRENT_TIME, CURRENT_TIMESTAMP,   CURRENT_USER, CURSOR, DATABASE, DATABASES, DAY_HOUR, DAY_MICROSECOND, DAY_MINUTE,   DAY_SECOND, DEC, DECIMAL, DECLARE, DEFAULT, DELAYED, DELETE, DESC, DESCRIBE,   DETERMINISTIC, DISTINCT, DISTINCTROW, DIV, DOUBLE, DROP, DUAL, EACH, ELSE,   ELSEIF, ENCLOSED, ESCAPED, EXISTS, EXIT, EXPLAIN, FALSE, FETCH, FLOAT, FLOAT4,   FLOAT8, FOR, FORCE, FOREIGN, FROM, FULLTEXT, GRANT, GROUP, HAVING, HIGH_PRIORITY,   HOUR_MICROSECOND, HOUR_MINUTE, HOUR_SECOND, IF, IGNORE, IN, INDEX, INFILE,   INNER, INOUT, INSENSITIVE, INSERT, INT, INT1, INT2, INT3, INT4, INT8, INTEGER,   INTERVAL, INTO, IS, ITERATE, JOIN, KEY, KEYS, KILL, LEADING, LEAVE, LEFT,   LIKE, LIMIT, LINEAR, LINES, LOAD, LOCALTIME, LOCALTIMESTAMP, LOCK, LONG,   LONGBLOB, LONGT, XT, LOOP, LOW_PRIORITY, MASTER_SSL_VERIFY_SERVER_CERT,   MATCH, MAXVALUE, MEDIUMBLOB, MEDIUMINT, MEDIUMTEXT, MIDDLEINT, MINUTE_MICROSECOND,   MINUTE_SECOND, MOD, MODIFIES, NATURAL, NOT, NO_WRITE_TO_BINLOG, NULL, NUMERIC,   ON, OPTIMIZE, OPTION, OPTIONALLY, OR, ORDER, OUT, OUTER, OUTFILE, PRECISION,   PRIMARY, PROCEDURE, PURGE, RANGE, READ, READS, READ_WRITE, REAL, REFERENCES,   REGEXP, RELEASE, RENAME, REPEAT, REPLACE, REQUIRE, RESIGNAL, RESTRICT, RETURN,   REVOKE, RIGHT, RLIKE, SCHEMA, SCHEMAS, SECOND_MICROSECOND, SELECT, SENSITIVE,   SEPARATOR, SET, SHOW, SIGNAL, SMALLINT, SPATIAL, SPECIFIC, SQL, SQLEXCEPTION,   SQLSTATE, SQLWARNING, SQL_BIG_RESULT, SQL_CALC_FOUND_ROWS, SQL_SMALL_RESULT,   SSL, STARTING, STRAIGHT_JOIN, TABLE, TERMINATED, THEN, TINYBLOB, TINYINT,   TINYTEXT, TO, TRAILING, TRIGGER, TRUE, NDO, UNION, UNIQUE, UNLOCK, UNSIGNED,   UPDATE, USAGE, USE, USING, UTC_DATE, UTC_TIME, UTC_TIMESTAMP, VALUES, VARBINARY,   VARCHAR, VARCHARACTER, VARYING, WHEN, WHERE, WHILE, WITH, WRITE, XOR, YEAR_MONTH,   ZEROFILL, GENERAL, IGNORE_SERVER_IDS, MASTER_HEARTBEAT_PERIOD, SLOW.     The following field names are reserved (cannot be used directly) and are automatically   included during object creation: ID, OBJECTID, CREATED, UPDATED, DELETED.   Additionally the field names must start with a letter or number.",
        tags = { "Object Store" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = ObjectStoreResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ObjectApi.PATH_ADD_FIELD,
        produces = { "*/*" }
    )
    default ResponseEntity<ObjectStoreResponse> addField(
        @NotNull @Parameter(name = "accountId", description = "The account id of the logged in user", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "appKey", description = "The application key for updating an existing application", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = true) String appKey,
        @NotNull @Parameter(name = "objectName", description = "The name of the object to add the field to", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "objectName", required = true) String objectName,
        @NotNull @Parameter(name = "fieldName", description = "field name The name of the field to add.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "fieldName", required = true) String fieldName,
        @NotNull @Parameter(name = "fieldType", description = "field type The field type to create, supported types are: STRING, DATE, NUMBER, BOOLEAN, IDENTITY", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "fieldType", required = true) String fieldType
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_CREATE_DATA = "/object/data/{objectName}";
    /**
     * POST /object/data/{objectName} : Create Data
     * Create a record for the specified object.  If the object does not exist then a new one will be created prior to inserting the record.  If any of the fields included does not exist for the object then they are added to the object. 
     *
     * @param objectName the name of the object to create data for (required)
     * @param accountId the account id (optional)
     * @param body  (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "createData",
        summary = "Create Data",
        description = "Create a record for the specified object.  If the object does not exist then a new one will be created prior to inserting the record.  If any of the fields included does not exist for the object then they are added to the object. ",
        tags = { "Object Store" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = ObjectStoreResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ObjectApi.PATH_CREATE_DATA,
        produces = { "*/*" }
    )
    default ResponseEntity<ObjectStoreResponse> createData(
        @NotNull @Parameter(name = "objectName", description = "the name of the object to create data for", required = true, in = ParameterIn.PATH) @PathVariable("objectName") String objectName,
        @Parameter(name = "accountId", description = "the account id", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "body", description = "") @Valid @RequestBody(required = false) @Nullable String body
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_CREATE_OBJECT = "/object/create";
    /**
     * POST /object/create : Create Object
     * Create an Object Store table.  By default tables will have the columns: id, created, updated, deleted.  Names og objects should be camel case with the first letter capitalized, for example: MyTableName.   Duplicate object names are not allowed.   The object name cannot be any of the following reserved words: ACCESSIBLE, ADD, ALL, ALTER, ANALYZE, AND, AS, ASC, ASENSITIVE, BEFORE, BETWEEN, BIGINT, BINARY, BLOB, BOTH, BY, CALL, CASCADE, CASE, CHANGE, CHAR, CHARACTER, CHECK, COLLATE, COLUMN, CONDITION, CONSTRAINT, CONTINUE, CONVERT, CREATE, CROSS, CURRENT_, ATE, CURRENT_TIME, CURRENT_TIMESTAMP, CURRENT_USER, CURSOR, DATABASE, DATABASES, DAY_HOUR, DAY_MICROSECOND, DAY_MINUTE, DAY_SECOND, DEC, DECIMAL, DECLARE, DEFAULT, DELAYED, DELETE, DESC, DESCRIBE, DETERMINISTIC, DISTINCT, DISTINCTROW, DIV, DOUBLE, DROP, DUAL, EACH, ELSE, ELSEIF, ENCLOSED, ESCAPED, EXISTS, EXIT, EXPLAIN, FALSE, FETCH, FLOAT, FLOAT4, FLOAT8, FOR, FORCE, FOREIGN, FROM, FULLTEXT, GRANT, GROUP, HAVING, HIGH_PRIORITY, HOUR_MICROSECOND, HOUR_MINUTE, HOUR_SECOND, IF, IGNORE, IN, INDEX, INFILE, INNER, INOUT, INSENSITIVE, INSERT, INT, INT1, INT2, INT3, INT4, INT8, INTEGER, INTERVAL, INTO, IS, ITERATE, JOIN, KEY, KEYS, KILL, LEADING, LEAVE, LEFT, LIKE, LIMIT, LINEAR, LINES, LOAD, LOCALTIME, LOCALTIMESTAMP, LOCK, LONG, LONGBLOB, LONGT, XT, LOOP, LOW_PRIORITY, MASTER_SSL_VERIFY_SERVER_CERT, MATCH, MAXVALUE, MEDIUMBLOB, MEDIUMINT, MEDIUMTEXT, MIDDLEINT, MINUTE_MICROSECOND, MINUTE_SECOND, MOD, MODIFIES, NATURAL, NOT, NO_WRITE_TO_BINLOG, NULL, NUMERIC, ON, OPTIMIZE, OPTION, OPTIONALLY, OR, ORDER, OUT, OUTER, OUTFILE, PRECISION, PRIMARY, PROCEDURE, PURGE, RANGE, READ, READS, READ_WRITE, REAL, REFERENCES, REGEXP, RELEASE, RENAME, REPEAT, REPLACE, REQUIRE, RESIGNAL, RESTRICT, RETURN, REVOKE, RIGHT, RLIKE, SCHEMA, SCHEMAS, SECOND_MICROSECOND, SELECT, SENSITIVE, SEPARATOR, SET, SHOW, SIGNAL, SMALLINT, SPATIAL, SPECIFIC, SQL, SQLEXCEPTION, SQLSTATE, SQLWARNING, SQL_BIG_RESULT, SQL_CALC_FOUND_ROWS, SQL_SMALL_RESULT, SSL, STARTING, STRAIGHT_JOIN, TABLE, TERMINATED, THEN, TINYBLOB, TINYINT, TINYTEXT, TO, TRAILING, TRIGGER, TRUE, NDO, UNION, UNIQUE, UNLOCK, UNSIGNED, UPDATE, USAGE, USE, USING, UTC_DATE, UTC_TIME, UTC_TIMESTAMP, VALUES, VARBINARY, VARCHAR, VARCHARACTER, VARYING, WHEN, WHERE, WHILE, WITH, WRITE, XOR, YEAR_MONTH, ZEROFILL, GENERAL, IGNORE_SERVER_IDS, MASTER_HEARTBEAT_PERIOD, SLOW. 
     *
     * @param accountId The account id of the logged in user (required)
     * @param appKey The application key for updating an existing application (required)
     * @param objectName The name of the object to create (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "createObject",
        summary = "Create Object",
        description = "Create an Object Store table.  By default tables will have the columns: id, created, updated, deleted.  Names og objects should be camel case with the first letter capitalized, for example: MyTableName.   Duplicate object names are not allowed.   The object name cannot be any of the following reserved words: ACCESSIBLE, ADD, ALL, ALTER, ANALYZE, AND, AS, ASC, ASENSITIVE, BEFORE, BETWEEN, BIGINT, BINARY, BLOB, BOTH, BY, CALL, CASCADE, CASE, CHANGE, CHAR, CHARACTER, CHECK, COLLATE, COLUMN, CONDITION, CONSTRAINT, CONTINUE, CONVERT, CREATE, CROSS, CURRENT_, ATE, CURRENT_TIME, CURRENT_TIMESTAMP, CURRENT_USER, CURSOR, DATABASE, DATABASES, DAY_HOUR, DAY_MICROSECOND, DAY_MINUTE, DAY_SECOND, DEC, DECIMAL, DECLARE, DEFAULT, DELAYED, DELETE, DESC, DESCRIBE, DETERMINISTIC, DISTINCT, DISTINCTROW, DIV, DOUBLE, DROP, DUAL, EACH, ELSE, ELSEIF, ENCLOSED, ESCAPED, EXISTS, EXIT, EXPLAIN, FALSE, FETCH, FLOAT, FLOAT4, FLOAT8, FOR, FORCE, FOREIGN, FROM, FULLTEXT, GRANT, GROUP, HAVING, HIGH_PRIORITY, HOUR_MICROSECOND, HOUR_MINUTE, HOUR_SECOND, IF, IGNORE, IN, INDEX, INFILE, INNER, INOUT, INSENSITIVE, INSERT, INT, INT1, INT2, INT3, INT4, INT8, INTEGER, INTERVAL, INTO, IS, ITERATE, JOIN, KEY, KEYS, KILL, LEADING, LEAVE, LEFT, LIKE, LIMIT, LINEAR, LINES, LOAD, LOCALTIME, LOCALTIMESTAMP, LOCK, LONG, LONGBLOB, LONGT, XT, LOOP, LOW_PRIORITY, MASTER_SSL_VERIFY_SERVER_CERT, MATCH, MAXVALUE, MEDIUMBLOB, MEDIUMINT, MEDIUMTEXT, MIDDLEINT, MINUTE_MICROSECOND, MINUTE_SECOND, MOD, MODIFIES, NATURAL, NOT, NO_WRITE_TO_BINLOG, NULL, NUMERIC, ON, OPTIMIZE, OPTION, OPTIONALLY, OR, ORDER, OUT, OUTER, OUTFILE, PRECISION, PRIMARY, PROCEDURE, PURGE, RANGE, READ, READS, READ_WRITE, REAL, REFERENCES, REGEXP, RELEASE, RENAME, REPEAT, REPLACE, REQUIRE, RESIGNAL, RESTRICT, RETURN, REVOKE, RIGHT, RLIKE, SCHEMA, SCHEMAS, SECOND_MICROSECOND, SELECT, SENSITIVE, SEPARATOR, SET, SHOW, SIGNAL, SMALLINT, SPATIAL, SPECIFIC, SQL, SQLEXCEPTION, SQLSTATE, SQLWARNING, SQL_BIG_RESULT, SQL_CALC_FOUND_ROWS, SQL_SMALL_RESULT, SSL, STARTING, STRAIGHT_JOIN, TABLE, TERMINATED, THEN, TINYBLOB, TINYINT, TINYTEXT, TO, TRAILING, TRIGGER, TRUE, NDO, UNION, UNIQUE, UNLOCK, UNSIGNED, UPDATE, USAGE, USE, USING, UTC_DATE, UTC_TIME, UTC_TIMESTAMP, VALUES, VARBINARY, VARCHAR, VARCHARACTER, VARYING, WHEN, WHERE, WHILE, WITH, WRITE, XOR, YEAR_MONTH, ZEROFILL, GENERAL, IGNORE_SERVER_IDS, MASTER_HEARTBEAT_PERIOD, SLOW. ",
        tags = { "Object Store" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = ObjectStoreResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ObjectApi.PATH_CREATE_OBJECT,
        produces = { "*/*" }
    )
    default ResponseEntity<ObjectStoreResponse> createObject(
        @NotNull @Parameter(name = "accountId", description = "The account id of the logged in user", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "appKey", description = "The application key for updating an existing application", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = true) String appKey,
        @NotNull @Parameter(name = "objectName", description = "The name of the object to create", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "objectName", required = true) String objectName
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_DELETE_DATA = "/object/data/{objectName}/{objectId}";
    /**
     * DELETE /object/data/{objectName}/{objectId} : Delete Data
     * Delete a record for the specified object. Cannot be undone so use only when abolutely sure.
     *
     * @param objectName The name of the object to search upon (required)
     * @param objectId objectId The id of the record to return (required)
     * @param accountId The account id of the logged in user (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "deleteData",
        summary = "Delete Data",
        description = "Delete a record for the specified object. Cannot be undone so use only when abolutely sure.",
        tags = { "Object Store" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = ObjectStoreResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.DELETE,
        value = ObjectApi.PATH_DELETE_DATA,
        produces = { "*/*" }
    )
    default ResponseEntity<ObjectStoreResponse> deleteData(
        @NotNull @Parameter(name = "objectName", description = "The name of the object to search upon", required = true, in = ParameterIn.PATH) @PathVariable("objectName") String objectName,
        @NotNull @Parameter(name = "objectId", description = "objectId The id of the record to return", required = true, in = ParameterIn.PATH) @PathVariable("objectId") String objectId,
        @Parameter(name = "accountId", description = "The account id of the logged in user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_DELETE_FIELD = "/object/field/delete";
    /**
     * POST /object/field/delete : Delete Field
     * Delete a field from an object.  This will remove the field, indexes,   and foreign keys associated with the field.   The following field names   are reserved and cannot be removed from the object: ID, OBJECTID, CREATED,   UPDATED, DELETED
     *
     * @param accountId The account id of the logged in user (required)
     * @param appKey The application key for updating an existing application (required)
     * @param objectName The name of the object to remove the field from (required)
     * @param fieldName field name The name of the field to remove. (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "deleteField",
        summary = "Delete Field",
        description = "Delete a field from an object.  This will remove the field, indexes,   and foreign keys associated with the field.   The following field names   are reserved and cannot be removed from the object: ID, OBJECTID, CREATED,   UPDATED, DELETED",
        tags = { "Object Store" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = ObjectStoreResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ObjectApi.PATH_DELETE_FIELD,
        produces = { "*/*" }
    )
    default ResponseEntity<ObjectStoreResponse> deleteField(
        @NotNull @Parameter(name = "accountId", description = "The account id of the logged in user", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "appKey", description = "The application key for updating an existing application", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = true) String appKey,
        @NotNull @Parameter(name = "objectName", description = "The name of the object to remove the field from", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "objectName", required = true) String objectName,
        @NotNull @Parameter(name = "fieldName", description = "field name The name of the field to remove.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "fieldName", required = true) String fieldName
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_DELETE_OBJECT = "/object/delete";
    /**
     * POST /object/delete : Delete Object
     * Delete and Object in the store.  This will delete the table and clean up and foreign keys referencing it. Cannot be undone so use only when abolutely sure.
     *
     * @param accountId the id of the logged in user (required)
     * @param appKey the application key (required)
     * @param objectName the name of the object to delete (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "deleteObject",
        summary = "Delete Object",
        description = "Delete and Object in the store.  This will delete the table and clean up and foreign keys referencing it. Cannot be undone so use only when abolutely sure.",
        tags = { "Object Store" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = ObjectStoreResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = ObjectApi.PATH_DELETE_OBJECT,
        produces = { "*/*" }
    )
    default ResponseEntity<ObjectStoreResponse> deleteObject(
        @NotNull @Parameter(name = "accountId", description = "the id of the logged in user", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "appKey", description = "the application key", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = true) String appKey,
        @NotNull @Parameter(name = "objectName", description = "the name of the object to delete", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "objectName", required = true) String objectName
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_DATA = "/object/data/{objectName}/{objectId}";
    /**
     * GET /object/data/{objectName}/{objectId} : Get Data
     * Get a specific record from a specified object.
     *
     * @param objectName The name of the object to search upon (required)
     * @param objectId objectId The id of the record to return (required)
     * @param accountId The account id of the logged in user (optional)
     * @param include  (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getData",
        summary = "Get Data",
        description = "Get a specific record from a specified object.",
        tags = { "Object Store" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = ObjectStoreResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ObjectApi.PATH_GET_DATA,
        produces = { "*/*" }
    )
    default ResponseEntity<ObjectStoreResponse> getData(
        @NotNull @Parameter(name = "objectName", description = "The name of the object to search upon", required = true, in = ParameterIn.PATH) @PathVariable("objectName") String objectName,
        @NotNull @Parameter(name = "objectId", description = "objectId The id of the record to return", required = true, in = ParameterIn.PATH) @PathVariable("objectId") String objectId,
        @Parameter(name = "accountId", description = "The account id of the logged in user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "include", description = "", in = ParameterIn.QUERY) @Valid @RequestParam(value = "include", required = false) @Nullable String include
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_OBJECT = "/object/get";
    /**
     * GET /object/get : Get Object
     * Get the definition of an Object. Returns all field names, types, and current size. The types supported are: STRING, DATE, NUMBER, BOOLEAN, IDENTITY.
     *
     * @param accountId The account id of the logged in user (required)
     * @param appKey The application key for updating an existing application (required)
     * @param objectName The name of the object to get the definition for (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getObject",
        summary = "Get Object",
        description = "Get the definition of an Object. Returns all field names, types, and current size. The types supported are: STRING, DATE, NUMBER, BOOLEAN, IDENTITY.",
        tags = { "Object Store" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = ObjectStoreResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ObjectApi.PATH_GET_OBJECT,
        produces = { "*/*" }
    )
    default ResponseEntity<ObjectStoreResponse> getObject(
        @NotNull @Parameter(name = "accountId", description = "The account id of the logged in user", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "appKey", description = "The application key for updating an existing application", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = true) String appKey,
        @NotNull @Parameter(name = "objectName", description = "The name of the object to get the definition for", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "objectName", required = true) String objectName
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_SEARCH_DATA = "/object/data/{objectName}";
    /**
     * GET /object/data/{objectName} : Search Data
     * Search for records given the specified criteria.  The criteria is a defined set of json values used to build a query
     *
     * @param objectName The name of the object to search upon (required)
     * @param count If true just return the record count of the search. False (default) will return the actual records (required)
     * @param start The start of the pagination (required)
     * @param limit The limit of the pagination (required)
     * @param accountId The account id of the logged in user (optional)
     * @param criteria The search criteria (optional)
     * @param order The order of results; comma seperated list of field names. Illegal field names will be ignored. Direction by defualt is ascending. Prepend a minus to the field name to make that field descending. (optional)
     * @param include  (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "searchData",
        summary = "Search Data",
        description = "Search for records given the specified criteria.  The criteria is a defined set of json values used to build a query",
        tags = { "Object Store" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = ObjectStoreResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ObjectApi.PATH_SEARCH_DATA,
        produces = { "*/*" }
    )
    default ResponseEntity<ObjectStoreResponse> searchData(
        @NotNull @Parameter(name = "objectName", description = "The name of the object to search upon", required = true, in = ParameterIn.PATH) @PathVariable("objectName") String objectName,
        @NotNull @Parameter(name = "count", description = "If true just return the record count of the search. False (default) will return the actual records", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "count", required = true) Boolean count,
        @NotNull @Parameter(name = "start", description = "The start of the pagination", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = true) Long start,
        @NotNull @Parameter(name = "limit", description = "The limit of the pagination", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = true) Long limit,
        @Parameter(name = "accountId", description = "The account id of the logged in user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "criteria", description = "The search criteria", in = ParameterIn.QUERY) @Valid @RequestParam(value = "criteria", required = false) @Nullable String criteria,
        @Parameter(name = "order", description = "The order of results; comma seperated list of field names. Illegal field names will be ignored. Direction by defualt is ascending. Prepend a minus to the field name to make that field descending.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "order", required = false) @Nullable String order,
        @Parameter(name = "include", description = "", in = ParameterIn.QUERY) @Valid @RequestParam(value = "include", required = false) @Nullable String include
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_SEARCH_OBJECT = "/object/search";
    /**
     * GET /object/search : Search Objects
     * Search for Objects and return the list of names found.  Use this in conjunction with the object get service to present the current data model defined.
     *
     * @param accountId The account id of the logged in user (required)
     * @param appKey The application key for updating an existing application (required)
     * @param start The start of the pagination (required)
     * @param limit The limit of the pagination (required)
     * @param keyword The name of the object(s) to search for, can be a partial match (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "searchObject",
        summary = "Search Objects",
        description = "Search for Objects and return the list of names found.  Use this in conjunction with the object get service to present the current data model defined.",
        tags = { "Object Store" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = ObjectStoreResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = ObjectApi.PATH_SEARCH_OBJECT,
        produces = { "*/*" }
    )
    default ResponseEntity<ObjectStoreResponse> searchObject(
        @NotNull @Parameter(name = "accountId", description = "The account id of the logged in user", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "appKey", description = "The application key for updating an existing application", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = true) String appKey,
        @NotNull @Parameter(name = "start", description = "The start of the pagination", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = true) Long start,
        @NotNull @Parameter(name = "limit", description = "The limit of the pagination", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = true) Long limit,
        @Parameter(name = "keyword", description = "The name of the object(s) to search for, can be a partial match", in = ParameterIn.QUERY) @Valid @RequestParam(value = "keyword", required = false) @Nullable String keyword
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_UPDATE_DATA = "/object/data/{objectName}/{objectId}";
    /**
     * PUT /object/data/{objectName}/{objectId} : Update Data
     * Update a record for the specified object.  If the object does not exist the request will be rejected, use the data create service for the first entry. If any of the fields included does not exist for the object then they are added to the object.
     *
     * @param objectName The name of the object to search upon (required)
     * @param objectId objectId The id of the record to return (required)
     * @param accountId The account id of the logged in user (optional)
     * @param body  (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "updateData",
        summary = "Update Data",
        description = "Update a record for the specified object.  If the object does not exist the request will be rejected, use the data create service for the first entry. If any of the fields included does not exist for the object then they are added to the object.",
        tags = { "Object Store" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = ObjectStoreResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.PUT,
        value = ObjectApi.PATH_UPDATE_DATA,
        produces = { "*/*" }
    )
    default ResponseEntity<ObjectStoreResponse> updateData(
        @NotNull @Parameter(name = "objectName", description = "The name of the object to search upon", required = true, in = ParameterIn.PATH) @PathVariable("objectName") String objectName,
        @NotNull @Parameter(name = "objectId", description = "objectId The id of the record to return", required = true, in = ParameterIn.PATH) @PathVariable("objectId") String objectId,
        @Parameter(name = "accountId", description = "The account id of the logged in user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "body", description = "") @Valid @RequestBody(required = false) @Nullable String body
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }

}
