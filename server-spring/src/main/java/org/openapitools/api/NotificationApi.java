/*
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech) (7.20.0-SNAPSHOT).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
package org.openapitools.api;

import org.openapitools.model.BlockedNotificationResponse;
import org.openapitools.model.NotificationMessageListResponse;
import org.openapitools.model.NotificationRecipientResponse;
import org.openapitools.model.NotificationRecipientResponseListResponse;
import org.openapitools.model.NotificationTemplateResponse;
import org.springframework.lang.Nullable;
import org.openapitools.model.ScheduledNotificationFullResponse;
import org.openapitools.model.SirqulResponse;
import io.swagger.v3.oas.annotations.ExternalDocumentation;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.Parameters;
import io.swagger.v3.oas.annotations.media.ArraySchema;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import io.swagger.v3.oas.annotations.enums.ParameterIn;
import io.swagger.v3.oas.annotations.media.ExampleObject;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.context.request.NativeWebRequest;
import org.springframework.web.multipart.MultipartFile;

import javax.validation.Valid;
import javax.validation.constraints.*;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import javax.annotation.Generated;

@Generated(value = "org.openapitools.codegen.languages.SpringCodegen", date = "2026-02-11T19:32:41.765375324Z[Etc/UTC]", comments = "Generator version: 7.20.0-SNAPSHOT")
@Validated
@Tag(name = "Notification", description = "the Notification API")
public interface NotificationApi {

    default Optional<NativeWebRequest> getRequest() {
        return Optional.empty();
    }

    String PATH_CREATE_NOTIFICATION_TEMPLATE = "/notification/template/create";
    /**
     * POST /notification/template/create : Create Notification Template
     * Create a notification template. Developers will only be able to create notification templates for their own applications.
     *
     * @param accountId The account ID of the user. (required)
     * @param conduit Filter results by notification type: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION. (required)
     * @param title title of the notification template (required)
     * @param body body of the notification template (required)
     * @param appKey Filter results by application. (optional)
     * @param event Filter results by event. (optional)
     * @param tags tags associated with the note template (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "createNotificationTemplate",
        summary = "Create Notification Template",
        description = "Create a notification template. Developers will only be able to create notification templates for their own applications.",
        tags = { "Notification" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = NotificationTemplateResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = NotificationApi.PATH_CREATE_NOTIFICATION_TEMPLATE,
        produces = { "*/*" }
    )
    default ResponseEntity<NotificationTemplateResponse> createNotificationTemplate(
        @NotNull @Parameter(name = "accountId", description = "The account ID of the user.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "conduit", description = "Filter results by notification type: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "conduit", required = true) String conduit,
        @NotNull @Parameter(name = "title", description = "title of the notification template", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "title", required = true) String title,
        @NotNull @Parameter(name = "body", description = "body of the notification template", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "body", required = true) String body,
        @Parameter(name = "appKey", description = "Filter results by application.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = false) @Nullable String appKey,
        @Parameter(name = "event", description = "Filter results by event.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "event", required = false) @Nullable String event,
        @Parameter(name = "tags", description = "tags associated with the note template", in = ParameterIn.QUERY) @Valid @RequestParam(value = "tags", required = false) @Nullable String tags
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_CREATE_OR_UPDATE_BLOCKED_NOTIFICATIONS = "/notification/blocked/batch";
    /**
     * POST /notification/blocked/batch : Create or update blocked notification settings
     * Create or update blocked notification settings
     *
     * @param appKey The application key (required)
     * @param data batch data payload (application specific) (required)
     * @param accountId the account id of the user (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "createOrUpdateBlockedNotifications",
        summary = "Create or update blocked notification settings",
        description = "Create or update blocked notification settings",
        tags = { "Notification" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = BlockedNotificationResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = NotificationApi.PATH_CREATE_OR_UPDATE_BLOCKED_NOTIFICATIONS,
        produces = { "*/*" }
    )
    default ResponseEntity<BlockedNotificationResponse> createOrUpdateBlockedNotifications(
        @NotNull @Parameter(name = "appKey", description = "The application key", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = true) String appKey,
        @NotNull @Parameter(name = "data", description = "batch data payload (application specific)", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "data", required = true) String data,
        @Parameter(name = "accountId", description = "the account id of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_CREATE_SCHEDULED_NOTIFICATION = "/notification/schedule/create";
    /**
     * POST /notification/schedule/create : Create Scheduled Notification
     * This endpoint creates a Scheduled Notification message that can be configured to process and send periodically at set time periods
     *
     * @param accountId The logged in user. (required)
     * @param name The name of the scheduled notification (required)
     * @param type The type of scheduled notification. Supported values include: MOBILE_NOTIFICATION - sends push notifications via APNS and GCM EMAIL - sends email messages SMS - sends text messages (required)
     * @param message The message to send (required)
     * @param contentId The payload content ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     * @param contentName The payload content name that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     * @param contentType The payload content type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     * @param parentId The payload parent ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     * @param parentType The payload parent type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     * @param appKey The application that the notifications will send to. If connectionGroupIds, connectionAccountIds, and audienceIds is not set, this will send to all users who have used the application. This parameter is also required when sending push notifications via the MOBILE_NOTIFICATION type. (optional)
     * @param groupingId Client defined identifier for grouping multiple scheduled notifications. This can be used with the search endpoint to return scheduled notifications with the same groupingId for display purposes. Only results that have been created by the user will be returned when using this feature. (optional)
     * @param connectionGroupIds The connection groups to use to generate the list of recipients (comma separated list of connection group IDs) (optional)
     * @param connectionAccountIds The connection accounts to use to generate the list of recipients (comma separated list of user account ids) (optional)
     * @param audienceId This parameter is deprecated. The audience used to generate the list of recipients (optional)
     * @param audienceIds The audiences used to generate the list of recipients (comma separated list of audience IDs) (optional)
     * @param albumIds The album ids to associate with the scheduled notification (comma separated list of album IDs) (optional)
     * @param reportId The report used to generate the the list of recipients (optional)
     * @param reportParams The parameters to supply to the report used to generate the the list of recipients (optional)
     * @param endpointURL The URL for making an HTTP call (optional)
     * @param payload The parameters for making an HTTP call (optional)
     * @param scheduledDate The next time when the scheduled notification should begin processing (time in milliseconds). If this is left empty, then the startDate will be used. (optional)
     * @param startDate The start time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to be available now. (optional)
     * @param endDate The end time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to not have an expiration date. (optional)
     * @param cronExpression The cron expression that represents the processing schedule. This uses the unix cron expression format. For example: 0 0 * * * will run once a day at midnight UTC. (optional)
     * @param cronType The cron expression type: UNIX, CRON4J, QUARTZ (optional)
     * @param metaData Additional metadata for the scheduled notification (optional)
     * @param conditionalInput Json input representing conditional logic that has to be met before running the scheduled notification (optional)
     * @param templateType This determines if the Scheduled Notification is a template which is used as a basis for dynamically generating re-occurring Scheduled Notifications. The available types include: REPORTING - saves an adhoc report to be able to run again at another time GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business owner) GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business employee, retailer location, etc) GEOFENCE_TRIGGER - template for sending notifications to the account that triggered the geofence/audience (i.e. the customer) GEOFENCE_HTTP_CALL - template for making http calls when the geofences are triggered (optional)
     * @param visibility Determines the scope of who is able to find and view the scheduled notification (PUBLIC - openly available to all Sirqul users, PRIVATE - only available to users that have been invited) (optional)
     * @param active Sets whether the Scheduled Notification is active or not (inactive Scheduled Notifications are not processed). This is a quick way to toggle on or off without altering its schedule. The default value is &#39;true&#39;. (optional)
     * @param sendNow  (optional)
     * @param eventType Sets the event type for the notification (optional, default to CUSTOM)
     * @param deepLinkURI The payload deep link URI that can be used by the client app to direct users to a screen in the app (optional)
     * @param sendToAll Determines whether to send to all users of the app if set to true for push notifications (appKey is required) (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "createScheduledNotification",
        summary = "Create Scheduled Notification",
        description = "This endpoint creates a Scheduled Notification message that can be configured to process and send periodically at set time periods",
        tags = { "Scheduled Notification" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = ScheduledNotificationFullResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = NotificationApi.PATH_CREATE_SCHEDULED_NOTIFICATION,
        produces = { "*/*" }
    )
    default ResponseEntity<ScheduledNotificationFullResponse> createScheduledNotification(
        @NotNull @Parameter(name = "accountId", description = "The logged in user.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "name", description = "The name of the scheduled notification", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "name", required = true) String name,
        @NotNull @Parameter(name = "type", description = "The type of scheduled notification. Supported values include: MOBILE_NOTIFICATION - sends push notifications via APNS and GCM EMAIL - sends email messages SMS - sends text messages", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "type", required = true) String type,
        @NotNull @Parameter(name = "message", description = "The message to send", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "message", required = true) String message,
        @Parameter(name = "contentId", description = "The payload content ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "contentId", required = false) @Nullable Long contentId,
        @Parameter(name = "contentName", description = "The payload content name that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "contentName", required = false) @Nullable String contentName,
        @Parameter(name = "contentType", description = "The payload content type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "contentType", required = false) @Nullable String contentType,
        @Parameter(name = "parentId", description = "The payload parent ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "parentId", required = false) @Nullable Long parentId,
        @Parameter(name = "parentType", description = "The payload parent type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "parentType", required = false) @Nullable String parentType,
        @Parameter(name = "appKey", description = "The application that the notifications will send to. If connectionGroupIds, connectionAccountIds, and audienceIds is not set, this will send to all users who have used the application. This parameter is also required when sending push notifications via the MOBILE_NOTIFICATION type.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = false) @Nullable String appKey,
        @Parameter(name = "groupingId", description = "Client defined identifier for grouping multiple scheduled notifications. This can be used with the search endpoint to return scheduled notifications with the same groupingId for display purposes. Only results that have been created by the user will be returned when using this feature.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "groupingId", required = false) @Nullable String groupingId,
        @Parameter(name = "connectionGroupIds", description = "The connection groups to use to generate the list of recipients (comma separated list of connection group IDs)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "connectionGroupIds", required = false) @Nullable String connectionGroupIds,
        @Parameter(name = "connectionAccountIds", description = "The connection accounts to use to generate the list of recipients (comma separated list of user account ids)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "connectionAccountIds", required = false) @Nullable String connectionAccountIds,
        @Parameter(name = "audienceId", description = "This parameter is deprecated. The audience used to generate the list of recipients", in = ParameterIn.QUERY) @Valid @RequestParam(value = "audienceId", required = false) @Nullable Long audienceId,
        @Parameter(name = "audienceIds", description = "The audiences used to generate the list of recipients (comma separated list of audience IDs)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "audienceIds", required = false) @Nullable String audienceIds,
        @Parameter(name = "albumIds", description = "The album ids to associate with the scheduled notification (comma separated list of album IDs)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "albumIds", required = false) @Nullable String albumIds,
        @Parameter(name = "reportId", description = "The report used to generate the the list of recipients", in = ParameterIn.QUERY) @Valid @RequestParam(value = "reportId", required = false) @Nullable Long reportId,
        @Parameter(name = "reportParams", description = "The parameters to supply to the report used to generate the the list of recipients", in = ParameterIn.QUERY) @Valid @RequestParam(value = "reportParams", required = false) @Nullable String reportParams,
        @Parameter(name = "endpointURL", description = "The URL for making an HTTP call", in = ParameterIn.QUERY) @Valid @RequestParam(value = "endpointURL", required = false) @Nullable String endpointURL,
        @Parameter(name = "payload", description = "The parameters for making an HTTP call", in = ParameterIn.QUERY) @Valid @RequestParam(value = "payload", required = false) @Nullable String payload,
        @Parameter(name = "scheduledDate", description = "The next time when the scheduled notification should begin processing (time in milliseconds). If this is left empty, then the startDate will be used.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "scheduledDate", required = false) @Nullable Long scheduledDate,
        @Parameter(name = "startDate", description = "The start time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to be available now.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "startDate", required = false) @Nullable Long startDate,
        @Parameter(name = "endDate", description = "The end time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to not have an expiration date.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "endDate", required = false) @Nullable Long endDate,
        @Parameter(name = "cronExpression", description = "The cron expression that represents the processing schedule. This uses the unix cron expression format. For example: 0 0 * * * will run once a day at midnight UTC.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "cronExpression", required = false) @Nullable String cronExpression,
        @Parameter(name = "cronType", description = "The cron expression type: UNIX, CRON4J, QUARTZ", in = ParameterIn.QUERY) @Valid @RequestParam(value = "cronType", required = false) @Nullable String cronType,
        @Parameter(name = "metaData", description = "Additional metadata for the scheduled notification", in = ParameterIn.QUERY) @Valid @RequestParam(value = "metaData", required = false) @Nullable String metaData,
        @Parameter(name = "conditionalInput", description = "Json input representing conditional logic that has to be met before running the scheduled notification", in = ParameterIn.QUERY) @Valid @RequestParam(value = "conditionalInput", required = false) @Nullable String conditionalInput,
        @Parameter(name = "templateType", description = "This determines if the Scheduled Notification is a template which is used as a basis for dynamically generating re-occurring Scheduled Notifications. The available types include: REPORTING - saves an adhoc report to be able to run again at another time GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business owner) GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business employee, retailer location, etc) GEOFENCE_TRIGGER - template for sending notifications to the account that triggered the geofence/audience (i.e. the customer) GEOFENCE_HTTP_CALL - template for making http calls when the geofences are triggered", in = ParameterIn.QUERY) @Valid @RequestParam(value = "templateType", required = false) @Nullable String templateType,
        @Parameter(name = "visibility", description = "Determines the scope of who is able to find and view the scheduled notification (PUBLIC - openly available to all Sirqul users, PRIVATE - only available to users that have been invited)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "visibility", required = false) @Nullable String visibility,
        @Parameter(name = "active", description = "Sets whether the Scheduled Notification is active or not (inactive Scheduled Notifications are not processed). This is a quick way to toggle on or off without altering its schedule. The default value is 'true'.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "active", required = false) @Nullable Boolean active,
        @Parameter(name = "sendNow", description = "", in = ParameterIn.QUERY) @Valid @RequestParam(value = "sendNow", required = false) @Nullable Boolean sendNow,
        @Parameter(name = "eventType", description = "Sets the event type for the notification", in = ParameterIn.QUERY) @Valid @RequestParam(value = "eventType", required = false, defaultValue = "CUSTOM") String eventType,
        @Parameter(name = "deepLinkURI", description = "The payload deep link URI that can be used by the client app to direct users to a screen in the app", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deepLinkURI", required = false) @Nullable String deepLinkURI,
        @Parameter(name = "sendToAll", description = "Determines whether to send to all users of the app if set to true for push notifications (appKey is required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "sendToAll", required = false) @Nullable Boolean sendToAll
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_DELETE_NOTIFICATION_TEMPLATE = "/notification/template/delete";
    /**
     * POST /notification/template/delete : Delete Notification Template
     * Deletes a notification template. Developers will only be able to delete notification templates for their own applications.
     *
     * @param accountId the account id of the user (required)
     * @param notificationTemplateId the id of the notification template to delete (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "deleteNotificationTemplate",
        summary = "Delete Notification Template",
        description = "Deletes a notification template. Developers will only be able to delete notification templates for their own applications.",
        tags = { "Notification" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = NotificationTemplateResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = NotificationApi.PATH_DELETE_NOTIFICATION_TEMPLATE,
        produces = { "*/*" }
    )
    default ResponseEntity<NotificationTemplateResponse> deleteNotificationTemplate(
        @NotNull @Parameter(name = "accountId", description = "the account id of the user", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "notificationTemplateId", description = "the id of the notification template to delete", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "notificationTemplateId", required = true) Long notificationTemplateId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_DELETE_SCHEDULED_NOTIFICATION = "/notification/schedule/delete";
    /**
     * POST /notification/schedule/delete : Delete Scheduled Notification
     * This endpoint deletes a Scheduled Notification. Only the original owner of the Scheduled Notification or someone with write permissions can use this endpoint. Permissions can be granted to other users by using the UserPermissionsApi.
     *
     * @param accountId the id of the logged in user (required)
     * @param scheduledNotificationId the id of the scheduled notification to delete (required)
     * @param deleteByGroupingId If set to true, also deletes Scheduled Notifications under the same account with the same groupingId. (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "deleteScheduledNotification",
        summary = "Delete Scheduled Notification",
        description = "This endpoint deletes a Scheduled Notification. Only the original owner of the Scheduled Notification or someone with write permissions can use this endpoint. Permissions can be granted to other users by using the UserPermissionsApi.",
        tags = { "Scheduled Notification" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = ScheduledNotificationFullResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = NotificationApi.PATH_DELETE_SCHEDULED_NOTIFICATION,
        produces = { "*/*" }
    )
    default ResponseEntity<ScheduledNotificationFullResponse> deleteScheduledNotification(
        @NotNull @Parameter(name = "accountId", description = "the id of the logged in user", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "scheduledNotificationId", description = "the id of the scheduled notification to delete", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "scheduledNotificationId", required = true) Long scheduledNotificationId,
        @Parameter(name = "deleteByGroupingId", description = "If set to true, also deletes Scheduled Notifications under the same account with the same groupingId.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deleteByGroupingId", required = false) @Nullable Boolean deleteByGroupingId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_NOTIFICATION_TEMPLATE = "/notification/template/get";
    /**
     * GET /notification/template/get : Get Notification Template
     * Get the details of a notification template. Developers will only be able to see notification templates for their own applications.
     *
     * @param accountId the id of the account (required)
     * @param notificationTemplateId the id of the notification template to get (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getNotificationTemplate",
        summary = "Get Notification Template",
        description = "Get the details of a notification template. Developers will only be able to see notification templates for their own applications.",
        tags = { "Notification" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = NotificationTemplateResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = NotificationApi.PATH_GET_NOTIFICATION_TEMPLATE,
        produces = { "*/*" }
    )
    default ResponseEntity<NotificationTemplateResponse> getNotificationTemplate(
        @NotNull @Parameter(name = "accountId", description = "the id of the account", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "notificationTemplateId", description = "the id of the notification template to get", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "notificationTemplateId", required = true) Long notificationTemplateId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_NOTIFICATIONS = "/notification/search";
    /**
     * GET /notification/search : Get Notifications
     * Get a list of notifications for a user. If the \&quot;markAsRead\&quot; parameter is set to true, the returned notifications will be marked as \&quot;read\&quot; after the response has been sent. By default, read messages will not be returned, so to see read messages, set \&quot;returnReadMessages\&quot; to true.
     *
     * @param deviceId the unique id of the device making the request (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param connectionAccountId the account id used to view another person&#39;s notifications (optional)
     * @param appKey the application key to filter messages by application (optional)
     * @param eventType comma separated list of EVENTS. Filters search results to only include these events. Don&#39;t include this parameter or pass in an empty string to return all event types. (optional)
     * @param contentIds comma separated list of content ids to search notifications on (optional)
     * @param contentTypes comma separated list of content types to search notifications on (optional)
     * @param parentIds comma separated list of parent ids to search notifications on (optional)
     * @param parentTypes comma separated list of parent types to search notifications on (optional)
     * @param actionCategory Action category used to filter notifications (optional)
     * @param conduits comma separated list of conduits to search notifications on (optional)
     * @param keyword search notifications via keyword (optional)
     * @param returnReadMessages if set to true, will return notifications that have been marked as read (optional)
     * @param markAsRead if set to true, the returned notifications will be marked as \\\&quot;read\\\&quot; after the response has been sent (optional)
     * @param fromDate filter notifications from this date (optional)
     * @param latitude latitude used to update the user&#39;s current location (optional)
     * @param longitude longitude used to update the user&#39;s current location (optional)
     * @param returnSent whether to include notifications sent by the requester in the response (optional)
     * @param ignoreFlagged whether to ignore flagged notifications (optional)
     * @param start start of the pagination (optional)
     * @param limit limit of the pagination (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getNotifications",
        summary = "Get Notifications",
        description = "Get a list of notifications for a user. If the \"markAsRead\" parameter is set to true, the returned notifications will be marked as \"read\" after the response has been sent. By default, read messages will not be returned, so to see read messages, set \"returnReadMessages\" to true.",
        tags = { "Notification" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = NotificationMessageListResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = NotificationApi.PATH_GET_NOTIFICATIONS,
        produces = { "*/*" }
    )
    default ResponseEntity<NotificationMessageListResponse> getNotifications(
        @Parameter(name = "deviceId", description = "the unique id of the device making the request (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "the account id of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "connectionAccountId", description = "the account id used to view another person's notifications", in = ParameterIn.QUERY) @Valid @RequestParam(value = "connectionAccountId", required = false) @Nullable Long connectionAccountId,
        @Parameter(name = "appKey", description = "the application key to filter messages by application", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = false) @Nullable String appKey,
        @Parameter(name = "eventType", description = "comma separated list of EVENTS. Filters search results to only include these events. Don't include this parameter or pass in an empty string to return all event types.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "eventType", required = false) @Nullable String eventType,
        @Parameter(name = "contentIds", description = "comma separated list of content ids to search notifications on", in = ParameterIn.QUERY) @Valid @RequestParam(value = "contentIds", required = false) @Nullable String contentIds,
        @Parameter(name = "contentTypes", description = "comma separated list of content types to search notifications on", in = ParameterIn.QUERY) @Valid @RequestParam(value = "contentTypes", required = false) @Nullable String contentTypes,
        @Parameter(name = "parentIds", description = "comma separated list of parent ids to search notifications on", in = ParameterIn.QUERY) @Valid @RequestParam(value = "parentIds", required = false) @Nullable String parentIds,
        @Parameter(name = "parentTypes", description = "comma separated list of parent types to search notifications on", in = ParameterIn.QUERY) @Valid @RequestParam(value = "parentTypes", required = false) @Nullable String parentTypes,
        @Parameter(name = "actionCategory", description = "Action category used to filter notifications", in = ParameterIn.QUERY) @Valid @RequestParam(value = "actionCategory", required = false) @Nullable String actionCategory,
        @Parameter(name = "conduits", description = "comma separated list of conduits to search notifications on", in = ParameterIn.QUERY) @Valid @RequestParam(value = "conduits", required = false) @Nullable String conduits,
        @Parameter(name = "keyword", description = "search notifications via keyword", in = ParameterIn.QUERY) @Valid @RequestParam(value = "keyword", required = false) @Nullable String keyword,
        @Parameter(name = "returnReadMessages", description = "if set to true, will return notifications that have been marked as read", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnReadMessages", required = false) @Nullable Boolean returnReadMessages,
        @Parameter(name = "markAsRead", description = "if set to true, the returned notifications will be marked as \\\"read\\\" after the response has been sent", in = ParameterIn.QUERY) @Valid @RequestParam(value = "markAsRead", required = false) @Nullable Boolean markAsRead,
        @Parameter(name = "fromDate", description = "filter notifications from this date", in = ParameterIn.QUERY) @Valid @RequestParam(value = "fromDate", required = false) @Nullable Long fromDate,
        @Parameter(name = "latitude", description = "latitude used to update the user's current location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "latitude", required = false) @Nullable Double latitude,
        @Parameter(name = "longitude", description = "longitude used to update the user's current location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "longitude", required = false) @Nullable Double longitude,
        @Parameter(name = "returnSent", description = "whether to include notifications sent by the requester in the response", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnSent", required = false) @Nullable Boolean returnSent,
        @Parameter(name = "ignoreFlagged", description = "whether to ignore flagged notifications", in = ParameterIn.QUERY) @Valid @RequestParam(value = "ignoreFlagged", required = false) @Nullable Boolean ignoreFlagged,
        @Parameter(name = "start", description = "start of the pagination", in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = false) @Nullable Integer start,
        @Parameter(name = "limit", description = "limit of the pagination", in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = false) @Nullable Integer limit
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_SCHEDULED_NOTIFICATION = "/notification/schedule/get";
    /**
     * GET /notification/schedule/get : Get Scheduled Notification
     * Get a ScheduledNotification
     *
     * @param accountId the id of the account logged in (required)
     * @param scheduledNotificationId the id of the scheduled notification to get (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getScheduledNotification",
        summary = "Get Scheduled Notification",
        description = "Get a ScheduledNotification",
        tags = { "Scheduled Notification" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = ScheduledNotificationFullResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = NotificationApi.PATH_GET_SCHEDULED_NOTIFICATION,
        produces = { "*/*" }
    )
    default ResponseEntity<ScheduledNotificationFullResponse> getScheduledNotification(
        @NotNull @Parameter(name = "accountId", description = "the id of the account logged in", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "scheduledNotificationId", description = "the id of the scheduled notification to get", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "scheduledNotificationId", required = true) Long scheduledNotificationId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_REGISTER_NOTIFICATION_TOKEN = "/notification/token";
    /**
     * POST /notification/token : Register Notification Token
     * Register a token to send application dependent notifications like Google Cloud Messaging, or Apple Push Notifications.
     *
     * @param token A token that is generated by the device to sign requests for the notification service providers (required)
     * @param pushType The type of push notification. Possible values include: APNS, GCM (required)
     * @param deviceId The unique id of the device making the request (deviceId or accountId required) (optional)
     * @param accountId The account id of the user (deviceId or accountId required) (optional)
     * @param environment Determines if the token is a DEVELOPMENT or PRODUCTION token (optional)
     * @param appKey The application key (optional)
     * @param gameType This parameter is deprecated (use appKey instead) (optional)
     * @param active Sets whether the token is active or not (non-active tokens are not used) (optional)
     * @param latitude Latitude used to update the user&#39;s current location (optional)
     * @param longitude Longitude used to update the user&#39;s current location (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "registerNotificationToken",
        summary = "Register Notification Token",
        description = "Register a token to send application dependent notifications like Google Cloud Messaging, or Apple Push Notifications.",
        tags = { "Notification" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = NotificationApi.PATH_REGISTER_NOTIFICATION_TOKEN,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> registerNotificationToken(
        @NotNull @Parameter(name = "token", description = "A token that is generated by the device to sign requests for the notification service providers", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "token", required = true) String token,
        @NotNull @Parameter(name = "pushType", description = "The type of push notification. Possible values include: APNS, GCM", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "pushType", required = true) String pushType,
        @Parameter(name = "deviceId", description = "The unique id of the device making the request (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "The account id of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "environment", description = "Determines if the token is a DEVELOPMENT or PRODUCTION token", in = ParameterIn.QUERY) @Valid @RequestParam(value = "environment", required = false) @Nullable String environment,
        @Parameter(name = "appKey", description = "The application key", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = false) @Nullable String appKey,
        @Parameter(name = "gameType", description = "This parameter is deprecated (use appKey instead)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "gameType", required = false) @Nullable String gameType,
        @Parameter(name = "active", description = "Sets whether the token is active or not (non-active tokens are not used)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "active", required = false) @Nullable Boolean active,
        @Parameter(name = "latitude", description = "Latitude used to update the user's current location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "latitude", required = false) @Nullable Double latitude,
        @Parameter(name = "longitude", description = "Longitude used to update the user's current location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "longitude", required = false) @Nullable Double longitude
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_SCHEDULE_NOTIFICATION_LISTINGS = "/notification/schedule/generate";
    /**
     * POST /notification/schedule/generate : Generate Schedule Notifications
     * Use a report to identify events that are starting soon and then create a scheduled notification to push a message to matching users.
     *
     * @param accountId The logged in user. (required)
     * @param appKey The application to target (required)
     * @param reportName The name of the report used to identify events. The report must return columns named: id, name, date, params, and type otherwise it will fail (required)
     * @param message The message to be sent to the recipients. If you set %name% the report row name value will be swapped in. If you set %time% or %date% the report row start date/time value will be swapped in (required)
     * @param offset Time in munites before the event starts to notify recipients (required)
     * @param recipientReportId The report id used to generate the recipient list (required)
     * @param reportParams The parameters of the report used to identify events in a json structure, example: &#x60;&#x60;&#x60;json {   \&quot;string\&quot;: \&quot;value\&quot;,   \&quot;number\&quot;: 3.345,   \&quot;date\&quot;: \&quot;2014-05-01 00:00:00\&quot; } &#x60;&#x60;&#x60;  (optional)
     * @param type The type of scheduled notification; supported values are: MOBILE_NOTIFICATION (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "scheduleNotificationListings",
        summary = "Generate Schedule Notifications",
        description = "Use a report to identify events that are starting soon and then create a scheduled notification to push a message to matching users.",
        tags = { "Scheduled Notification" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = NotificationApi.PATH_SCHEDULE_NOTIFICATION_LISTINGS,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> scheduleNotificationListings(
        @NotNull @Parameter(name = "accountId", description = "The logged in user.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "appKey", description = "The application to target", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = true) String appKey,
        @NotNull @Parameter(name = "reportName", description = "The name of the report used to identify events. The report must return columns named: id, name, date, params, and type otherwise it will fail", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "reportName", required = true) String reportName,
        @NotNull @Parameter(name = "message", description = "The message to be sent to the recipients. If you set %name% the report row name value will be swapped in. If you set %time% or %date% the report row start date/time value will be swapped in", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "message", required = true) String message,
        @NotNull @Parameter(name = "offset", description = "Time in munites before the event starts to notify recipients", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "offset", required = true) Integer offset,
        @NotNull @Parameter(name = "recipientReportId", description = "The report id used to generate the recipient list", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "recipientReportId", required = true) Long recipientReportId,
        @Parameter(name = "reportParams", description = "The parameters of the report used to identify events in a json structure, example: ```json {   \"string\": \"value\",   \"number\": 3.345,   \"date\": \"2014-05-01 00:00:00\" } ``` ", in = ParameterIn.QUERY) @Valid @RequestParam(value = "reportParams", required = false) @Nullable String reportParams,
        @Parameter(name = "type", description = "The type of scheduled notification; supported values are: MOBILE_NOTIFICATION", in = ParameterIn.QUERY) @Valid @RequestParam(value = "type", required = false) @Nullable String type
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_SEARCH_BLOCKED_NOTIFICATIONS = "/notification/blocked/search";
    /**
     * GET /notification/blocked/search : Search on the user&#39;s blocked notification settings
     * Search on the user&#39;s blocked notification settings
     *
     * @param appKey The application key (required)
     * @param accountId the account id of the user (optional)
     * @param searchTags search tags to filter results (optional)
     * @param events events to filter by (comma separated) (optional)
     * @param conduits conduits to filter by (comma separated) (optional)
     * @param customTypes custom types to filter by (comma separated) (optional)
     * @param contentTypes content types to filter by (comma separated) (optional)
     * @param contentIds content ids to filter by (comma separated) (optional)
     * @param sortField sort field for results (optional)
     * @param descending whether to sort descending (optional)
     * @param start start of the pagination (optional)
     * @param limit limit of the pagination (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "searchBlockedNotifications",
        summary = "Search on the user's blocked notification settings",
        description = "Search on the user's blocked notification settings",
        tags = { "Notification" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = BlockedNotificationResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = NotificationApi.PATH_SEARCH_BLOCKED_NOTIFICATIONS,
        produces = { "*/*" }
    )
    default ResponseEntity<BlockedNotificationResponse> searchBlockedNotifications(
        @NotNull @Parameter(name = "appKey", description = "The application key", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = true) String appKey,
        @Parameter(name = "accountId", description = "the account id of the user", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "searchTags", description = "search tags to filter results", in = ParameterIn.QUERY) @Valid @RequestParam(value = "searchTags", required = false) @Nullable String searchTags,
        @Parameter(name = "events", description = "events to filter by (comma separated)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "events", required = false) @Nullable String events,
        @Parameter(name = "conduits", description = "conduits to filter by (comma separated)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "conduits", required = false) @Nullable String conduits,
        @Parameter(name = "customTypes", description = "custom types to filter by (comma separated)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "customTypes", required = false) @Nullable String customTypes,
        @Parameter(name = "contentTypes", description = "content types to filter by (comma separated)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "contentTypes", required = false) @Nullable String contentTypes,
        @Parameter(name = "contentIds", description = "content ids to filter by (comma separated)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "contentIds", required = false) @Nullable String contentIds,
        @Parameter(name = "sortField", description = "sort field for results", in = ParameterIn.QUERY) @Valid @RequestParam(value = "sortField", required = false) @Nullable String sortField,
        @Parameter(name = "descending", description = "whether to sort descending", in = ParameterIn.QUERY) @Valid @RequestParam(value = "descending", required = false) @Nullable Boolean descending,
        @Parameter(name = "start", description = "start of the pagination", in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = false) @Nullable Integer start,
        @Parameter(name = "limit", description = "limit of the pagination", in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = false) @Nullable Integer limit
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_SEARCH_NOTIFICATION_TEMPLATE = "/notification/template/search";
    /**
     * GET /notification/template/search : Search Notification Templates
     * Search for notification templates on owned applications.
     *
     * @param accountId The account ID of the user. (required)
     * @param sortField Specifies how results are ordered.ID - order results by the notificationTemplateId CREATED - order results by the created date UPDATED - order results by the updated date TITLE - order results by title EVENT - order results by event CONDUIT - order results by conduit APP_NAME - order results by the application name (&#39;global&#39; templates will not have an application and will be returned last if &#39;descending&#39; is set to false. (required)
     * @param descending Specified whether the results are returned in descending or ascending order. (required)
     * @param start The start of the pagination. (required)
     * @param limit The limit of the pagination. (required)
     * @param appKey Filter results by application. (optional)
     * @param event Filter results by event. (optional)
     * @param conduit Filter results by notification type: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION. (optional)
     * @param globalOnly Returns only templates that have been reserved for system use on all applications (only for admin accounts). (optional)
     * @param reservedOnly Returns only templates that use reserved events. (optional)
     * @param keyword Filter results by keyword on the title, tags. (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "searchNotificationTemplate",
        summary = "Search Notification Templates",
        description = "Search for notification templates on owned applications.",
        tags = { "Notification" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = NotificationTemplateResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = NotificationApi.PATH_SEARCH_NOTIFICATION_TEMPLATE,
        produces = { "*/*" }
    )
    default ResponseEntity<NotificationTemplateResponse> searchNotificationTemplate(
        @NotNull @Parameter(name = "accountId", description = "The account ID of the user.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "sortField", description = "Specifies how results are ordered.ID - order results by the notificationTemplateId CREATED - order results by the created date UPDATED - order results by the updated date TITLE - order results by title EVENT - order results by event CONDUIT - order results by conduit APP_NAME - order results by the application name ('global' templates will not have an application and will be returned last if 'descending' is set to false.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "sortField", required = true) String sortField,
        @NotNull @Parameter(name = "descending", description = "Specified whether the results are returned in descending or ascending order.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "descending", required = true) Boolean descending,
        @NotNull @Parameter(name = "start", description = "The start of the pagination.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = true) Integer start,
        @NotNull @Parameter(name = "limit", description = "The limit of the pagination.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = true) Integer limit,
        @Parameter(name = "appKey", description = "Filter results by application.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = false) @Nullable String appKey,
        @Parameter(name = "event", description = "Filter results by event.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "event", required = false) @Nullable String event,
        @Parameter(name = "conduit", description = "Filter results by notification type: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "conduit", required = false) @Nullable String conduit,
        @Parameter(name = "globalOnly", description = "Returns only templates that have been reserved for system use on all applications (only for admin accounts).", in = ParameterIn.QUERY) @Valid @RequestParam(value = "globalOnly", required = false) @Nullable Boolean globalOnly,
        @Parameter(name = "reservedOnly", description = "Returns only templates that use reserved events.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "reservedOnly", required = false) @Nullable Boolean reservedOnly,
        @Parameter(name = "keyword", description = "Filter results by keyword on the title, tags.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "keyword", required = false) @Nullable String keyword
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_SEARCH_RECIPIENTS = "/notification/recipient/search";
    /**
     * GET /notification/recipient/search : Search for Recipients
     * Search for application users to send notifications.
     *
     * @param sortField The field to sort by. Possible values include: {ACCOUNT_DISPLAY, CREATED, UPDATED, ACTIVE, DELETED, LAST_LOGGED_IN, CONTACT_EMAIL, RETAILER_LOCATION_NAME, RETAILER_NAME, APPLICATION_NAME} (required)
     * @param deviceId the unique id of the device making the request (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param appKey filters results by application. If this is empty, will return all recipients for all applications that the user has access to. (optional)
     * @param conduit the type of notification to send: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION. (optional)
     * @param keyword search by keyword on user&#39;s display name and email (optional)
     * @param audienceId This parameter is deprecated. filter results by audience (optional)
     * @param audienceIds filter results by audiences (comma separated list of audience ids) (optional)
     * @param connectionGroupIds filter results by connection groups (comma separated list of connection group ids) (optional)
     * @param recipientAccountIds filter results by accounts (comma separated list of account ids) (optional)
     * @param descending Determines whether the sorted list is in descending or ascending order (optional)
     * @param start start of the pagination (optional)
     * @param limit limit of the pagination (hard limit of 1000) (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "searchRecipients",
        summary = "Search for Recipients",
        description = "Search for application users to send notifications.",
        tags = { "Notification" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", array = @ArraySchema(schema = @Schema(implementation = NotificationRecipientResponse.class)))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = NotificationApi.PATH_SEARCH_RECIPIENTS,
        produces = { "*/*" }
    )
    default ResponseEntity<List<NotificationRecipientResponse>> searchRecipients(
        @NotNull @Parameter(name = "sortField", description = "The field to sort by. Possible values include: {ACCOUNT_DISPLAY, CREATED, UPDATED, ACTIVE, DELETED, LAST_LOGGED_IN, CONTACT_EMAIL, RETAILER_LOCATION_NAME, RETAILER_NAME, APPLICATION_NAME}", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "sortField", required = true) String sortField,
        @Parameter(name = "deviceId", description = "the unique id of the device making the request (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "the account id of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "appKey", description = "filters results by application. If this is empty, will return all recipients for all applications that the user has access to.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = false) @Nullable String appKey,
        @Parameter(name = "conduit", description = "the type of notification to send: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "conduit", required = false) @Nullable String conduit,
        @Parameter(name = "keyword", description = "search by keyword on user's display name and email", in = ParameterIn.QUERY) @Valid @RequestParam(value = "keyword", required = false) @Nullable String keyword,
        @Parameter(name = "audienceId", description = "This parameter is deprecated. filter results by audience", in = ParameterIn.QUERY) @Valid @RequestParam(value = "audienceId", required = false) @Nullable Long audienceId,
        @Parameter(name = "audienceIds", description = "filter results by audiences (comma separated list of audience ids)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "audienceIds", required = false) @Nullable String audienceIds,
        @Parameter(name = "connectionGroupIds", description = "filter results by connection groups (comma separated list of connection group ids)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "connectionGroupIds", required = false) @Nullable String connectionGroupIds,
        @Parameter(name = "recipientAccountIds", description = "filter results by accounts (comma separated list of account ids)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "recipientAccountIds", required = false) @Nullable String recipientAccountIds,
        @Parameter(name = "descending", description = "Determines whether the sorted list is in descending or ascending order", in = ParameterIn.QUERY) @Valid @RequestParam(value = "descending", required = false) @Nullable Boolean descending,
        @Parameter(name = "start", description = "start of the pagination", in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = false) @Nullable Integer start,
        @Parameter(name = "limit", description = "limit of the pagination (hard limit of 1000)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = false) @Nullable Integer limit
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_SEARCH_RECIPIENTS_COUNT = "/notification/recipient/search/count";
    /**
     * GET /notification/recipient/search/count : Search for Recipients (Counts/Grouped)
     * Search for application users to send notifications (count/grouped variant).
     *
     * @param deviceId the unique id of the device making the request (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param appKey filters results by application. If this is empty, will return all recipients for all applications that the user has access to. (optional)
     * @param conduit the type of notification to send: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION. (optional)
     * @param keyword search by keyword on user&#39;s display name and email (optional)
     * @param audienceId This parameter is deprecated. filter results by audience (optional)
     * @param audienceIds filter results by audiences (comma separated list of audience ids) (optional)
     * @param connectionGroupIds filter results by connection groups (comma separated list of connection group ids) (optional)
     * @param sortField The field to sort by (see API docs for allowed values). (optional)
     * @param descending Determines whether the sorted list is in descending or ascending order (optional)
     * @param start start of the pagination (optional)
     * @param limit limit of the pagination (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "searchRecipientsCount",
        summary = "Search for Recipients (Counts/Grouped)",
        description = "Search for application users to send notifications (count/grouped variant).",
        tags = { "Notification" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = NotificationRecipientResponseListResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = NotificationApi.PATH_SEARCH_RECIPIENTS_COUNT,
        produces = { "*/*" }
    )
    default ResponseEntity<NotificationRecipientResponseListResponse> searchRecipientsCount(
        @Parameter(name = "deviceId", description = "the unique id of the device making the request (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "the account id of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "appKey", description = "filters results by application. If this is empty, will return all recipients for all applications that the user has access to.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = false) @Nullable String appKey,
        @Parameter(name = "conduit", description = "the type of notification to send: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "conduit", required = false) @Nullable String conduit,
        @Parameter(name = "keyword", description = "search by keyword on user's display name and email", in = ParameterIn.QUERY) @Valid @RequestParam(value = "keyword", required = false) @Nullable String keyword,
        @Parameter(name = "audienceId", description = "This parameter is deprecated. filter results by audience", in = ParameterIn.QUERY) @Valid @RequestParam(value = "audienceId", required = false) @Nullable Long audienceId,
        @Parameter(name = "audienceIds", description = "filter results by audiences (comma separated list of audience ids)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "audienceIds", required = false) @Nullable String audienceIds,
        @Parameter(name = "connectionGroupIds", description = "filter results by connection groups (comma separated list of connection group ids)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "connectionGroupIds", required = false) @Nullable String connectionGroupIds,
        @Parameter(name = "sortField", description = "The field to sort by (see API docs for allowed values).", in = ParameterIn.QUERY) @Valid @RequestParam(value = "sortField", required = false) @Nullable String sortField,
        @Parameter(name = "descending", description = "Determines whether the sorted list is in descending or ascending order", in = ParameterIn.QUERY) @Valid @RequestParam(value = "descending", required = false) @Nullable Boolean descending,
        @Parameter(name = "start", description = "start of the pagination", in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = false) @Nullable Integer start,
        @Parameter(name = "limit", description = "limit of the pagination", in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = false) @Nullable Integer limit
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_SEARCH_SCHEDULED_NOTIFICATIONS = "/notification/schedule/search";
    /**
     * GET /notification/schedule/search : Search Scheduled Notifications
     * This endpoint searches on Scheduled Notifications. If a scheduled notification was created with the visibility parameter set to PUBLIC, then anyone can search on it if the filter parameter includes the PUBLIC value. PRIVATE visibility means that it can only be searched on by the owner or if it has been shared to the user using the UserPermissionsApi.  In addition, if a PUBLIC Scheduled Notification was created for an application that requires content approval (using the publicContentApproval parameter), then an administrator of the application needs to approve it before it can be search on by other users. Before this happens, it is in a PENDING state, and only the original creator or the owner of the application can search and see it. Also, only the owner of the application can use the UserPermissionsApi to approve or reject it. Scheduled notifications that have been rejected are only visible to the original creators.
     *
     * @param accountId The logged in user. (required)
     * @param groupingId Filter results by a grouping identifier defined by the client (optional)
     * @param audienceId Filter results by audience (optional)
     * @param filter a comma separated list of filters: MINE - Return scheduled notifications that the user has created. SHARED - Return scheduled notifications that have been shared to the user via addUsersToPermissionable. FOLLOWER - Return scheduled notifications that have been created by the users followers (the content needs to have been APPROVED or FEATURED). FOLLOWING - Return scheduled notifications that have been created by people who the user is following (the content needs to have been APPROVED or FEATURED). PUBLIC - Return all PUBLIC scheduled notifications that have been APPROVED or FEATURED. ALL_PUBLIC - Return all PUBLIC scheduled notifications regardless of whether they are approved or not (ignores the approval status). LIKED - Return all scheduled notifications that the user has liked. FEATURED - Return all scheduled notifications that have been featured. PENDING - Return all pending scheduled notifications. (optional)
     * @param types Filter results by notification types (comma separated list). Values include: HTTP, EMAIL, SMS, MOBILE_NOTIFICATION (optional)
     * @param contentIds search using content IDs (optional)
     * @param contentTypes search using content types (optional)
     * @param parentIds search using parent IDs (optional)
     * @param parentTypes search using parent types (optional)
     * @param statuses Filter results by status (comma separated list). Possible values include: NEW - scheduled to run ERROR - encountered an error during processing COMPLETE - processing has completed and it is no longer scheduled to run PROCESSING - currently processing/sending (optional)
     * @param templateTypes  (optional)
     * @param appKey Filter the list by a specific application (optional)
     * @param keyword Keyword search on the scheduled notification names. (optional)
     * @param sortField The field to sort by. Possible values include: ID - order by the scheduledNotificationId CREATED - order by the timestamp it was created UPDATED - order by the timestamp it was last updated ACTIVE - order by whether it is active or inactive NAME - order by the scheduled notification name SCHEDULED_DATE - order by the next scheduled date START_DATE - order by the start date END_DATE - order by the end date (optional)
     * @param descending Determines whether the sorted list is in descending or ascending order (optional)
     * @param start Start the result set at some index. (optional)
     * @param limit Limit the result to some number. (optional)
     * @param activeOnly Determines whether to return only active results (optional)
     * @param groupByGroupingId Determines whether to group results with the same groupingId together. (optional)
     * @param returnAudienceAccountCount If true, include audience account counts in the response (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "searchScheduledNotifications",
        summary = "Search Scheduled Notifications",
        description = "This endpoint searches on Scheduled Notifications. If a scheduled notification was created with the visibility parameter set to PUBLIC, then anyone can search on it if the filter parameter includes the PUBLIC value. PRIVATE visibility means that it can only be searched on by the owner or if it has been shared to the user using the UserPermissionsApi.  In addition, if a PUBLIC Scheduled Notification was created for an application that requires content approval (using the publicContentApproval parameter), then an administrator of the application needs to approve it before it can be search on by other users. Before this happens, it is in a PENDING state, and only the original creator or the owner of the application can search and see it. Also, only the owner of the application can use the UserPermissionsApi to approve or reject it. Scheduled notifications that have been rejected are only visible to the original creators.",
        tags = { "Scheduled Notification" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = ScheduledNotificationFullResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = NotificationApi.PATH_SEARCH_SCHEDULED_NOTIFICATIONS,
        produces = { "*/*" }
    )
    default ResponseEntity<ScheduledNotificationFullResponse> searchScheduledNotifications(
        @NotNull @Parameter(name = "accountId", description = "The logged in user.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @Parameter(name = "groupingId", description = "Filter results by a grouping identifier defined by the client", in = ParameterIn.QUERY) @Valid @RequestParam(value = "groupingId", required = false) @Nullable String groupingId,
        @Parameter(name = "audienceId", description = "Filter results by audience", in = ParameterIn.QUERY) @Valid @RequestParam(value = "audienceId", required = false) @Nullable Long audienceId,
        @Parameter(name = "filter", description = "a comma separated list of filters: MINE - Return scheduled notifications that the user has created. SHARED - Return scheduled notifications that have been shared to the user via addUsersToPermissionable. FOLLOWER - Return scheduled notifications that have been created by the users followers (the content needs to have been APPROVED or FEATURED). FOLLOWING - Return scheduled notifications that have been created by people who the user is following (the content needs to have been APPROVED or FEATURED). PUBLIC - Return all PUBLIC scheduled notifications that have been APPROVED or FEATURED. ALL_PUBLIC - Return all PUBLIC scheduled notifications regardless of whether they are approved or not (ignores the approval status). LIKED - Return all scheduled notifications that the user has liked. FEATURED - Return all scheduled notifications that have been featured. PENDING - Return all pending scheduled notifications.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "filter", required = false) @Nullable String filter,
        @Parameter(name = "types", description = "Filter results by notification types (comma separated list). Values include: HTTP, EMAIL, SMS, MOBILE_NOTIFICATION", in = ParameterIn.QUERY) @Valid @RequestParam(value = "types", required = false) @Nullable String types,
        @Parameter(name = "contentIds", description = "search using content IDs", in = ParameterIn.QUERY) @Valid @RequestParam(value = "contentIds", required = false) @Nullable String contentIds,
        @Parameter(name = "contentTypes", description = "search using content types", in = ParameterIn.QUERY) @Valid @RequestParam(value = "contentTypes", required = false) @Nullable String contentTypes,
        @Parameter(name = "parentIds", description = "search using parent IDs", in = ParameterIn.QUERY) @Valid @RequestParam(value = "parentIds", required = false) @Nullable String parentIds,
        @Parameter(name = "parentTypes", description = "search using parent types", in = ParameterIn.QUERY) @Valid @RequestParam(value = "parentTypes", required = false) @Nullable String parentTypes,
        @Parameter(name = "statuses", description = "Filter results by status (comma separated list). Possible values include: NEW - scheduled to run ERROR - encountered an error during processing COMPLETE - processing has completed and it is no longer scheduled to run PROCESSING - currently processing/sending", in = ParameterIn.QUERY) @Valid @RequestParam(value = "statuses", required = false) @Nullable String statuses,
        @Parameter(name = "templateTypes", description = "", in = ParameterIn.QUERY) @Valid @RequestParam(value = "templateTypes", required = false) @Nullable String templateTypes,
        @Parameter(name = "appKey", description = "Filter the list by a specific application", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = false) @Nullable String appKey,
        @Parameter(name = "keyword", description = "Keyword search on the scheduled notification names.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "keyword", required = false) @Nullable String keyword,
        @Parameter(name = "sortField", description = "The field to sort by. Possible values include: ID - order by the scheduledNotificationId CREATED - order by the timestamp it was created UPDATED - order by the timestamp it was last updated ACTIVE - order by whether it is active or inactive NAME - order by the scheduled notification name SCHEDULED_DATE - order by the next scheduled date START_DATE - order by the start date END_DATE - order by the end date", in = ParameterIn.QUERY) @Valid @RequestParam(value = "sortField", required = false) @Nullable String sortField,
        @Parameter(name = "descending", description = "Determines whether the sorted list is in descending or ascending order", in = ParameterIn.QUERY) @Valid @RequestParam(value = "descending", required = false) @Nullable Boolean descending,
        @Parameter(name = "start", description = "Start the result set at some index.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = false) @Nullable Integer start,
        @Parameter(name = "limit", description = "Limit the result to some number.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = false) @Nullable Integer limit,
        @Parameter(name = "activeOnly", description = "Determines whether to return only active results", in = ParameterIn.QUERY) @Valid @RequestParam(value = "activeOnly", required = false) @Nullable Boolean activeOnly,
        @Parameter(name = "groupByGroupingId", description = "Determines whether to group results with the same groupingId together.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "groupByGroupingId", required = false) @Nullable Boolean groupByGroupingId,
        @Parameter(name = "returnAudienceAccountCount", description = "If true, include audience account counts in the response", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnAudienceAccountCount", required = false) @Nullable Boolean returnAudienceAccountCount
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_SEND_BATCH_NOTIFICATIONS = "/notification/batch";
    /**
     * POST /notification/batch : Send Batch Notifications
     * Send notifications to all users of an application. Only someone with permissions to the application can do this.
     *
     * @param accountId The account id of the application owner/manager (required)
     * @param appKey The application key for updating an existing application (required)
     * @param customMessage Message string that will be displayed in on the notification (required)
     * @param conduit The type of notification to send: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION. (optional)
     * @param contentId Default notification pay-load field (usage is dependent on the app and the type of event) (optional)
     * @param contentName Default notification pay-load field (usage is dependent on the app and the type of event) (optional)
     * @param contentType Default notification pay-load field (usage is dependent on the app and the type of event) (optional)
     * @param parentId Default notification pay-load field (usage is dependent on the app and the type of event) (optional)
     * @param parentType Default notification pay-load field (usage is dependent on the app and the type of event) (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "sendBatchNotifications",
        summary = "Send Batch Notifications",
        description = "Send notifications to all users of an application. Only someone with permissions to the application can do this.",
        tags = { "Notification" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = NotificationApi.PATH_SEND_BATCH_NOTIFICATIONS,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> sendBatchNotifications(
        @NotNull @Parameter(name = "accountId", description = "The account id of the application owner/manager", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "appKey", description = "The application key for updating an existing application", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = true) String appKey,
        @NotNull @Parameter(name = "customMessage", description = "Message string that will be displayed in on the notification", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "customMessage", required = true) String customMessage,
        @Parameter(name = "conduit", description = "The type of notification to send: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "conduit", required = false) @Nullable String conduit,
        @Parameter(name = "contentId", description = "Default notification pay-load field (usage is dependent on the app and the type of event)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "contentId", required = false) @Nullable Long contentId,
        @Parameter(name = "contentName", description = "Default notification pay-load field (usage is dependent on the app and the type of event)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "contentName", required = false) @Nullable String contentName,
        @Parameter(name = "contentType", description = "Default notification pay-load field (usage is dependent on the app and the type of event)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "contentType", required = false) @Nullable String contentType,
        @Parameter(name = "parentId", description = "Default notification pay-load field (usage is dependent on the app and the type of event)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "parentId", required = false) @Nullable Long parentId,
        @Parameter(name = "parentType", description = "Default notification pay-load field (usage is dependent on the app and the type of event)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "parentType", required = false) @Nullable String parentType
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_SEND_CUSTOM_NOTIFICATIONS = "/notification/custom";
    /**
     * POST /notification/custom : Send Custom Notifications
     * Send your own custom notification to a user. NOTE: the EventType of these notifications will be CUSTOM. Notifications sent to yourself will currently be ignored.
     *
     * @param deviceId the unique id of the device making the request (deviceId or accountId required) (optional)
     * @param accountId the account id of the user (deviceId or accountId required) (optional)
     * @param receiverAccountIds comma separated list of account IDs that will receive the notification (optional)
     * @param includeFriendGroup determines whether to send to all of the user&#39;s friends, this flag must be true or receiverAccountIds must not be empty (optional)
     * @param appKey the application key (optional)
     * @param gameType This parameter is deprecated. (optional)
     * @param conduit the type of notification to send: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION. (optional)
     * @param contentId default notification pay-load field (usage is dependent on the app and the type of event) (optional)
     * @param contentName default notification pay-load field (usage is dependent on the app and the type of event) (optional)
     * @param contentType default notification pay-load field (usage is dependent on the app and the type of event) (optional)
     * @param parentId default notification pay-load field (usage is dependent on the app and the type of event) (optional)
     * @param parentType default notification pay-load field (usage is dependent on the app and the type of event) (optional)
     * @param actionCategory  (optional)
     * @param subject the subject line of an email #@param customPayload custom json definition of notification pay-load (usage is dependent on the app and the type of event) (optional)
     * @param customMessage message string that will be displayed in on the notification (optional)
     * @param friendOnlyAPNS only sends APNS to people who are friends of the user (still saves the notification message for feed polling) (optional)
     * @param latitude latitude used to update the user&#39;s current location (optional)
     * @param longitude longitude used to update the user&#39;s current location (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "sendCustomNotifications",
        summary = "Send Custom Notifications",
        description = "Send your own custom notification to a user. NOTE: the EventType of these notifications will be CUSTOM. Notifications sent to yourself will currently be ignored.",
        tags = { "Notification" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = NotificationApi.PATH_SEND_CUSTOM_NOTIFICATIONS,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> sendCustomNotifications(
        @Parameter(name = "deviceId", description = "the unique id of the device making the request (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceId", required = false) @Nullable String deviceId,
        @Parameter(name = "accountId", description = "the account id of the user (deviceId or accountId required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "receiverAccountIds", description = "comma separated list of account IDs that will receive the notification", in = ParameterIn.QUERY) @Valid @RequestParam(value = "receiverAccountIds", required = false) @Nullable String receiverAccountIds,
        @Parameter(name = "includeFriendGroup", description = "determines whether to send to all of the user's friends, this flag must be true or receiverAccountIds must not be empty", in = ParameterIn.QUERY) @Valid @RequestParam(value = "includeFriendGroup", required = false) @Nullable Boolean includeFriendGroup,
        @Parameter(name = "appKey", description = "the application key", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = false) @Nullable String appKey,
        @Parameter(name = "gameType", description = "This parameter is deprecated.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "gameType", required = false) @Nullable String gameType,
        @Parameter(name = "conduit", description = "the type of notification to send: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "conduit", required = false) @Nullable String conduit,
        @Parameter(name = "contentId", description = "default notification pay-load field (usage is dependent on the app and the type of event)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "contentId", required = false) @Nullable Long contentId,
        @Parameter(name = "contentName", description = "default notification pay-load field (usage is dependent on the app and the type of event)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "contentName", required = false) @Nullable String contentName,
        @Parameter(name = "contentType", description = "default notification pay-load field (usage is dependent on the app and the type of event)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "contentType", required = false) @Nullable String contentType,
        @Parameter(name = "parentId", description = "default notification pay-load field (usage is dependent on the app and the type of event)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "parentId", required = false) @Nullable Long parentId,
        @Parameter(name = "parentType", description = "default notification pay-load field (usage is dependent on the app and the type of event)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "parentType", required = false) @Nullable String parentType,
        @Parameter(name = "actionCategory", description = "", in = ParameterIn.QUERY) @Valid @RequestParam(value = "actionCategory", required = false) @Nullable String actionCategory,
        @Parameter(name = "subject", description = "the subject line of an email #@param customPayload custom json definition of notification pay-load (usage is dependent on the app and the type of event)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "subject", required = false) @Nullable String subject,
        @Parameter(name = "customMessage", description = "message string that will be displayed in on the notification", in = ParameterIn.QUERY) @Valid @RequestParam(value = "customMessage", required = false) @Nullable String customMessage,
        @Parameter(name = "friendOnlyAPNS", description = "only sends APNS to people who are friends of the user (still saves the notification message for feed polling)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "friendOnlyAPNS", required = false) @Nullable Boolean friendOnlyAPNS,
        @Parameter(name = "latitude", description = "latitude used to update the user's current location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "latitude", required = false) @Nullable Double latitude,
        @Parameter(name = "longitude", description = "longitude used to update the user's current location", in = ParameterIn.QUERY) @Valid @RequestParam(value = "longitude", required = false) @Nullable Double longitude
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_UPDATE_NOTIFICATION_TEMPLATE = "/notification/template/update";
    /**
     * POST /notification/template/update : Update Notification Template
     * Update a notification template. Developers will only be able to update notification templates for their own applications.
     *
     * @param accountId The account ID of the user. (required)
     * @param notificationTemplateId The notification template ID to update. (required)
     * @param title The title of the message (this would become the subject title for emails). There is a 191 character limit. (optional)
     * @param body The body of the message. (optional)
     * @param tags The search tags on the template used during search queries. (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "updateNotificationTemplate",
        summary = "Update Notification Template",
        description = "Update a notification template. Developers will only be able to update notification templates for their own applications.",
        tags = { "Notification" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = NotificationTemplateResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = NotificationApi.PATH_UPDATE_NOTIFICATION_TEMPLATE,
        produces = { "*/*" }
    )
    default ResponseEntity<NotificationTemplateResponse> updateNotificationTemplate(
        @NotNull @Parameter(name = "accountId", description = "The account ID of the user.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "notificationTemplateId", description = "The notification template ID to update.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "notificationTemplateId", required = true) Long notificationTemplateId,
        @Parameter(name = "title", description = "The title of the message (this would become the subject title for emails). There is a 191 character limit.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "title", required = false) @Nullable String title,
        @Parameter(name = "body", description = "The body of the message.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "body", required = false) @Nullable String body,
        @Parameter(name = "tags", description = "The search tags on the template used during search queries.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "tags", required = false) @Nullable String tags
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_UPDATE_SCHEDULED_NOTIFICATION = "/notification/schedule/update";
    /**
     * POST /notification/schedule/update : Update Scheduled Notification
     * This endpoint updates a Scheduled Notification message that can be configured to process and send periodically at set time periods. Please see createScheduledNotification for more details.  Only the original owner of the Scheduled Notification or someone with write permissions can use this endpoint. Permissions can be granted to other users by using theUserPermissionsApi.
     *
     * @param scheduledNotificationId The id of scheduled notification to update (required)
     * @param accountId The logged in user. (required)
     * @param name The name of the scheduled notification (optional)
     * @param type The type of scheduled notification. Supported values include: MOBILE_NOTIFICATION - sends push notifications via APNS and GCM EMAIL - sends email messages SMS - sends text messages (optional)
     * @param message The message to send (optional)
     * @param payload The parameters for making an HTTP call (optional)
     * @param contentId The payload content ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     * @param contentName The payload content name that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     * @param contentType The payload content type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     * @param parentId The payload parent ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     * @param parentType The payload parent type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (optional)
     * @param appKey The application that the notifications will send to. If connectionGroupIds, connectionAccountIds, and audienceIds is not set, this will send to all users who have used the application. This parameter is also required when sending push notifications via the MOBILE_NOTIFICATION type. (optional)
     * @param groupingId Client defined identifier for grouping multiple scheduled notifications. This can be used with the search endpoint to return scheduled notifications with the same groupingId for display purposes. Only results that have been created by the user will be returned when using this feature. (optional)
     * @param connectionGroupIds The connection groups to use to generate the list of recipients (comma separated list of connection group IDs) (optional)
     * @param connectionAccountIds The connection accounts to use to generate the list of recipients (comma separated list of user account ids) (optional)
     * @param audienceId This parameter is deprecated. The audience used to generate the list of recipients (optional)
     * @param audienceIds The audiences used to generate the list of recipients (comma separated list of audience IDs) (optional)
     * @param albumIds The album ids to associate with the scheduled notification (comma separated list of album IDs) (optional)
     * @param reportId The report used to generate the the list of recipients (optional)
     * @param reportParams The parameters to supply to the report used to generate the the list of recipients (optional)
     * @param endpointURL The URL for making an HTTP call (optional)
     * @param scheduledDate The next time when the scheduled notification should begin processing (time in milliseconds). If this is left empty, then the startDate will be used. (optional)
     * @param startDate The start time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to be available now. (optional)
     * @param endDate The end time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to not have an expiration date. (optional)
     * @param cronExpression The cron expression that represents the processing schedule. This uses the unix cron expression format. For example: 0 0 * * * will run once a day at midnight UTC. (optional)
     * @param cronType The cron expression type: UNIX, CRON4J, QUARTZ (optional)
     * @param metaData Additional metadata for the scheduled notification (optional)
     * @param conditionalInput Json input representing conditional logic that has to be met before running the scheduled notification (optional)
     * @param templateType This determines if the Scheduled Notification is a template which is used as a basis for dynamically generating re-occurring Scheduled Notifications. The available types include: REPORTING - saves an adhoc report to be able to run again at another time GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business owner) GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business employee, retailer location, etc) GEOFENCE_TRIGGER - template for sending notifications to the account that triggered the geofence/audience (i.e. the customer) GEOFENCE_HTTP_CALL - template for making http calls when the geofences are triggered (optional)
     * @param visibility Determines the scope of who is able to find and view the scheduled notification (PUBLIC - openly available to all Sirqul users, PRIVATE - only available to users that have been invited) (optional)
     * @param active Sets whether the Scheduled Notification is active or not (inactive Scheduled Notifications are not processed). This is a quick way to toggle on or off without altering its schedule. (optional)
     * @param errorMessage the error message associated with the scheduled notification (optional)
     * @param status the status of the scheduled notification (optional)
     * @param updateByGroupingId also updates ScheduledNotifications with the same groupingId and account (optional)
     * @param sendNow whether to send the scheduled notification now or not (optional)
     * @param eventType Sets the event type for the notification (optional, default to CUSTOM)
     * @param deepLinkURI The payload deep link URI that can be used by the client app to direct users to a screen in the app (optional)
     * @param sendToAll Determines whether to send to all users of the app if set to true for push notifications (appKey is required) (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "updateScheduledNotification",
        summary = "Update Scheduled Notification",
        description = "This endpoint updates a Scheduled Notification message that can be configured to process and send periodically at set time periods. Please see createScheduledNotification for more details.  Only the original owner of the Scheduled Notification or someone with write permissions can use this endpoint. Permissions can be granted to other users by using theUserPermissionsApi.",
        tags = { "Scheduled Notification" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = ScheduledNotificationFullResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = NotificationApi.PATH_UPDATE_SCHEDULED_NOTIFICATION,
        produces = { "*/*" }
    )
    default ResponseEntity<ScheduledNotificationFullResponse> updateScheduledNotification(
        @NotNull @Parameter(name = "scheduledNotificationId", description = "The id of scheduled notification to update", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "scheduledNotificationId", required = true) Long scheduledNotificationId,
        @NotNull @Parameter(name = "accountId", description = "The logged in user.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @Parameter(name = "name", description = "The name of the scheduled notification", in = ParameterIn.QUERY) @Valid @RequestParam(value = "name", required = false) @Nullable String name,
        @Parameter(name = "type", description = "The type of scheduled notification. Supported values include: MOBILE_NOTIFICATION - sends push notifications via APNS and GCM EMAIL - sends email messages SMS - sends text messages", in = ParameterIn.QUERY) @Valid @RequestParam(value = "type", required = false) @Nullable String type,
        @Parameter(name = "message", description = "The message to send", in = ParameterIn.QUERY) @Valid @RequestParam(value = "message", required = false) @Nullable String message,
        @Parameter(name = "payload", description = "The parameters for making an HTTP call", in = ParameterIn.QUERY) @Valid @RequestParam(value = "payload", required = false) @Nullable String payload,
        @Parameter(name = "contentId", description = "The payload content ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "contentId", required = false) @Nullable Long contentId,
        @Parameter(name = "contentName", description = "The payload content name that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "contentName", required = false) @Nullable String contentName,
        @Parameter(name = "contentType", description = "The payload content type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "contentType", required = false) @Nullable String contentType,
        @Parameter(name = "parentId", description = "The payload parent ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "parentId", required = false) @Nullable Long parentId,
        @Parameter(name = "parentType", description = "The payload parent type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "parentType", required = false) @Nullable String parentType,
        @Parameter(name = "appKey", description = "The application that the notifications will send to. If connectionGroupIds, connectionAccountIds, and audienceIds is not set, this will send to all users who have used the application. This parameter is also required when sending push notifications via the MOBILE_NOTIFICATION type.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = false) @Nullable String appKey,
        @Parameter(name = "groupingId", description = "Client defined identifier for grouping multiple scheduled notifications. This can be used with the search endpoint to return scheduled notifications with the same groupingId for display purposes. Only results that have been created by the user will be returned when using this feature.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "groupingId", required = false) @Nullable String groupingId,
        @Parameter(name = "connectionGroupIds", description = "The connection groups to use to generate the list of recipients (comma separated list of connection group IDs)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "connectionGroupIds", required = false) @Nullable String connectionGroupIds,
        @Parameter(name = "connectionAccountIds", description = "The connection accounts to use to generate the list of recipients (comma separated list of user account ids)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "connectionAccountIds", required = false) @Nullable String connectionAccountIds,
        @Parameter(name = "audienceId", description = "This parameter is deprecated. The audience used to generate the list of recipients", in = ParameterIn.QUERY) @Valid @RequestParam(value = "audienceId", required = false) @Nullable Long audienceId,
        @Parameter(name = "audienceIds", description = "The audiences used to generate the list of recipients (comma separated list of audience IDs)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "audienceIds", required = false) @Nullable String audienceIds,
        @Parameter(name = "albumIds", description = "The album ids to associate with the scheduled notification (comma separated list of album IDs)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "albumIds", required = false) @Nullable String albumIds,
        @Parameter(name = "reportId", description = "The report used to generate the the list of recipients", in = ParameterIn.QUERY) @Valid @RequestParam(value = "reportId", required = false) @Nullable Long reportId,
        @Parameter(name = "reportParams", description = "The parameters to supply to the report used to generate the the list of recipients", in = ParameterIn.QUERY) @Valid @RequestParam(value = "reportParams", required = false) @Nullable String reportParams,
        @Parameter(name = "endpointURL", description = "The URL for making an HTTP call", in = ParameterIn.QUERY) @Valid @RequestParam(value = "endpointURL", required = false) @Nullable String endpointURL,
        @Parameter(name = "scheduledDate", description = "The next time when the scheduled notification should begin processing (time in milliseconds). If this is left empty, then the startDate will be used.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "scheduledDate", required = false) @Nullable Long scheduledDate,
        @Parameter(name = "startDate", description = "The start time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to be available now.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "startDate", required = false) @Nullable Long startDate,
        @Parameter(name = "endDate", description = "The end time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to not have an expiration date.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "endDate", required = false) @Nullable Long endDate,
        @Parameter(name = "cronExpression", description = "The cron expression that represents the processing schedule. This uses the unix cron expression format. For example: 0 0 * * * will run once a day at midnight UTC.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "cronExpression", required = false) @Nullable String cronExpression,
        @Parameter(name = "cronType", description = "The cron expression type: UNIX, CRON4J, QUARTZ", in = ParameterIn.QUERY) @Valid @RequestParam(value = "cronType", required = false) @Nullable String cronType,
        @Parameter(name = "metaData", description = "Additional metadata for the scheduled notification", in = ParameterIn.QUERY) @Valid @RequestParam(value = "metaData", required = false) @Nullable String metaData,
        @Parameter(name = "conditionalInput", description = "Json input representing conditional logic that has to be met before running the scheduled notification", in = ParameterIn.QUERY) @Valid @RequestParam(value = "conditionalInput", required = false) @Nullable String conditionalInput,
        @Parameter(name = "templateType", description = "This determines if the Scheduled Notification is a template which is used as a basis for dynamically generating re-occurring Scheduled Notifications. The available types include: REPORTING - saves an adhoc report to be able to run again at another time GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business owner) GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business employee, retailer location, etc) GEOFENCE_TRIGGER - template for sending notifications to the account that triggered the geofence/audience (i.e. the customer) GEOFENCE_HTTP_CALL - template for making http calls when the geofences are triggered", in = ParameterIn.QUERY) @Valid @RequestParam(value = "templateType", required = false) @Nullable String templateType,
        @Parameter(name = "visibility", description = "Determines the scope of who is able to find and view the scheduled notification (PUBLIC - openly available to all Sirqul users, PRIVATE - only available to users that have been invited)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "visibility", required = false) @Nullable String visibility,
        @Parameter(name = "active", description = "Sets whether the Scheduled Notification is active or not (inactive Scheduled Notifications are not processed). This is a quick way to toggle on or off without altering its schedule.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "active", required = false) @Nullable Boolean active,
        @Parameter(name = "errorMessage", description = "the error message associated with the scheduled notification", in = ParameterIn.QUERY) @Valid @RequestParam(value = "errorMessage", required = false) @Nullable String errorMessage,
        @Parameter(name = "status", description = "the status of the scheduled notification", in = ParameterIn.QUERY) @Valid @RequestParam(value = "status", required = false) @Nullable String status,
        @Parameter(name = "updateByGroupingId", description = "also updates ScheduledNotifications with the same groupingId and account", in = ParameterIn.QUERY) @Valid @RequestParam(value = "updateByGroupingId", required = false) @Nullable Boolean updateByGroupingId,
        @Parameter(name = "sendNow", description = "whether to send the scheduled notification now or not", in = ParameterIn.QUERY) @Valid @RequestParam(value = "sendNow", required = false) @Nullable Boolean sendNow,
        @Parameter(name = "eventType", description = "Sets the event type for the notification", in = ParameterIn.QUERY) @Valid @RequestParam(value = "eventType", required = false, defaultValue = "CUSTOM") String eventType,
        @Parameter(name = "deepLinkURI", description = "The payload deep link URI that can be used by the client app to direct users to a screen in the app", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deepLinkURI", required = false) @Nullable String deepLinkURI,
        @Parameter(name = "sendToAll", description = "Determines whether to send to all users of the app if set to true for push notifications (appKey is required)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "sendToAll", required = false) @Nullable Boolean sendToAll
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }

}
