/*
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech) (7.20.0-SNAPSHOT).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
package org.openapitools.api;

import org.openapitools.model.AgeGroupResponse;
import org.openapitools.model.AudienceDeviceResponse;
import org.openapitools.model.AudienceResponse;
import org.springframework.lang.Nullable;
import org.openapitools.model.OfferListResponse;
import org.openapitools.model.SearchResponse;
import org.openapitools.model.SirqulResponse;
import io.swagger.v3.oas.annotations.ExternalDocumentation;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.Parameters;
import io.swagger.v3.oas.annotations.media.ArraySchema;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import io.swagger.v3.oas.annotations.enums.ParameterIn;
import io.swagger.v3.oas.annotations.media.ExampleObject;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.context.request.NativeWebRequest;
import org.springframework.web.multipart.MultipartFile;

import javax.validation.Valid;
import javax.validation.constraints.*;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import javax.annotation.Generated;

@Generated(value = "org.openapitools.codegen.languages.SpringCodegen", date = "2026-02-11T19:32:41.765375324Z[Etc/UTC]", comments = "Generator version: 7.20.0-SNAPSHOT")
@Validated
@Tag(name = "Audience", description = "the Audience API")
public interface AudienceApi {

    default Optional<NativeWebRequest> getRequest() {
        return Optional.empty();
    }

    String PATH_CREATE_AUDIENCE = "/audience/create";
    /**
     * POST /audience/create : Create Audience
     * Create a user defined audience.
     *
     * @param accountId The logged in user. (required)
     * @param name The name of the audience (required)
     * @param description The description of the audience (optional)
     * @param searchTags The search tags (optional)
     * @param gender The gender; possible values are: MALE, FEMALE, ANY (optional)
     * @param ageGroups The list of age groups, comma separated; possible values are AGE_0_13, AGE_14_17, AGE_18_22, AGE_23_30, AGE_31_54, AGE_55_PLUS, AGE_ANY (to reset to none) (optional)
     * @param categoryIds The list of category ids, comma separated; possible values are retrieved via /api/{version}/category/search (pass in id values) (optional)
     * @param applicationIds The list of application ids, comma separated; possible values are retrieved via /api/{version}/application/list (pass in id values) (optional)
     * @param gameExperienceLevel The experience level of the player; possible values are: ANY, NEW, BEGINNER, INTERMEDIATE, EXPERT (optional)
     * @param devices (Deprecated) Use deviceIds. The list of targeted device names, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in name values) (optional)
     * @param deviceIds The list of targeted device ids, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in id values) (optional)
     * @param deviceVersions The list of targeted device version ranges that are aligned with the provided devices list, comma separated (examples: 2.3-X, 0-5.1.4, 4.3.1-6.1.4) (optional)
     * @param locations The list of locations to build the center around; comma separated list of latitude/longitude pairs (example: lat1,long1,lat2,long2) (optional)
     * @param radius The list of radius of influence for the audience, in miles; comma separated list. Either provide 1 to be applied to all location pairs or a matching list to each lat/long pair. (optional)
     * @param startTimeOffset Seconds from the start time of an event (optional)
     * @param endTimeOffset Seconds from the end time of an event (optional)
     * @param sendSuggestion If true, then notify matching users when they are inside the radius (optional, default to true)
     * @param associateDescription The description of the associated object (optional)
     * @param associateType The type of the object to center the audience geofence (optional)
     * @param associateId The ID of the object to center the audience geofence (optional)
     * @param groupingId Optional grouping id for the audience (optional)
     * @param metaData External custom client defined data (optional)
     * @param visibility Visibility of the audience (optional)
     * @param audienceType Type of audience (optional)
     * @param useOrder Use order for cohort (optional)
     * @param cohortRegionsData Cohort data for \&quot;cohort\&quot; audience type (optional)
     * @param appKey Filter results by application key (optional)
     * @param trilaterationTypes Trilateration types (optional)
     * @param uniqueName If true, makes sure the audience name is unique (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "createAudience",
        summary = "Create Audience",
        description = "Create a user defined audience.",
        tags = { "Audience" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = AudienceResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = AudienceApi.PATH_CREATE_AUDIENCE,
        produces = { "*/*" }
    )
    default ResponseEntity<AudienceResponse> createAudience(
        @NotNull @Parameter(name = "accountId", description = "The logged in user.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "name", description = "The name of the audience", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "name", required = true) String name,
        @Parameter(name = "description", description = "The description of the audience", in = ParameterIn.QUERY) @Valid @RequestParam(value = "description", required = false) @Nullable String description,
        @Parameter(name = "searchTags", description = "The search tags", in = ParameterIn.QUERY) @Valid @RequestParam(value = "searchTags", required = false) @Nullable String searchTags,
        @Parameter(name = "gender", description = "The gender; possible values are: MALE, FEMALE, ANY", in = ParameterIn.QUERY) @Valid @RequestParam(value = "gender", required = false) @Nullable String gender,
        @Parameter(name = "ageGroups", description = "The list of age groups, comma separated; possible values are AGE_0_13, AGE_14_17, AGE_18_22, AGE_23_30, AGE_31_54, AGE_55_PLUS, AGE_ANY (to reset to none)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "ageGroups", required = false) @Nullable String ageGroups,
        @Parameter(name = "categoryIds", description = "The list of category ids, comma separated; possible values are retrieved via /api/{version}/category/search (pass in id values)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "categoryIds", required = false) @Nullable String categoryIds,
        @Parameter(name = "applicationIds", description = "The list of application ids, comma separated; possible values are retrieved via /api/{version}/application/list (pass in id values)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "applicationIds", required = false) @Nullable String applicationIds,
        @Parameter(name = "gameExperienceLevel", description = "The experience level of the player; possible values are: ANY, NEW, BEGINNER, INTERMEDIATE, EXPERT", in = ParameterIn.QUERY) @Valid @RequestParam(value = "gameExperienceLevel", required = false) @Nullable String gameExperienceLevel,
        @Parameter(name = "devices", description = "(Deprecated) Use deviceIds. The list of targeted device names, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in name values)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "devices", required = false) @Nullable String devices,
        @Parameter(name = "deviceIds", description = "The list of targeted device ids, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in id values)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceIds", required = false) @Nullable String deviceIds,
        @Parameter(name = "deviceVersions", description = "The list of targeted device version ranges that are aligned with the provided devices list, comma separated (examples: 2.3-X, 0-5.1.4, 4.3.1-6.1.4)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceVersions", required = false) @Nullable String deviceVersions,
        @Parameter(name = "locations", description = "The list of locations to build the center around; comma separated list of latitude/longitude pairs (example: lat1,long1,lat2,long2)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "locations", required = false) @Nullable String locations,
        @Parameter(name = "radius", description = "The list of radius of influence for the audience, in miles; comma separated list. Either provide 1 to be applied to all location pairs or a matching list to each lat/long pair.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "radius", required = false) @Nullable String radius,
        @Parameter(name = "startTimeOffset", description = "Seconds from the start time of an event", in = ParameterIn.QUERY) @Valid @RequestParam(value = "startTimeOffset", required = false) @Nullable Integer startTimeOffset,
        @Parameter(name = "endTimeOffset", description = "Seconds from the end time of an event", in = ParameterIn.QUERY) @Valid @RequestParam(value = "endTimeOffset", required = false) @Nullable Integer endTimeOffset,
        @Parameter(name = "sendSuggestion", description = "If true, then notify matching users when they are inside the radius", in = ParameterIn.QUERY) @Valid @RequestParam(value = "sendSuggestion", required = false, defaultValue = "true") Boolean sendSuggestion,
        @Parameter(name = "associateDescription", description = "The description of the associated object", in = ParameterIn.QUERY) @Valid @RequestParam(value = "associateDescription", required = false) @Nullable String associateDescription,
        @Parameter(name = "associateType", description = "The type of the object to center the audience geofence", in = ParameterIn.QUERY) @Valid @RequestParam(value = "associateType", required = false) @Nullable String associateType,
        @Parameter(name = "associateId", description = "The ID of the object to center the audience geofence", in = ParameterIn.QUERY) @Valid @RequestParam(value = "associateId", required = false) @Nullable Long associateId,
        @Parameter(name = "groupingId", description = "Optional grouping id for the audience", in = ParameterIn.QUERY) @Valid @RequestParam(value = "groupingId", required = false) @Nullable String groupingId,
        @Parameter(name = "metaData", description = "External custom client defined data", in = ParameterIn.QUERY) @Valid @RequestParam(value = "metaData", required = false) @Nullable String metaData,
        @Parameter(name = "visibility", description = "Visibility of the audience", in = ParameterIn.QUERY) @Valid @RequestParam(value = "visibility", required = false) @Nullable String visibility,
        @Parameter(name = "audienceType", description = "Type of audience", in = ParameterIn.QUERY) @Valid @RequestParam(value = "audienceType", required = false) @Nullable String audienceType,
        @Parameter(name = "useOrder", description = "Use order for cohort", in = ParameterIn.QUERY) @Valid @RequestParam(value = "useOrder", required = false) @Nullable Boolean useOrder,
        @Parameter(name = "cohortRegionsData", description = "Cohort data for \"cohort\" audience type", in = ParameterIn.QUERY) @Valid @RequestParam(value = "cohortRegionsData", required = false) @Nullable String cohortRegionsData,
        @Parameter(name = "appKey", description = "Filter results by application key", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = false) @Nullable String appKey,
        @Parameter(name = "trilaterationTypes", description = "Trilateration types", in = ParameterIn.QUERY) @Valid @RequestParam(value = "trilaterationTypes", required = false) @Nullable String trilaterationTypes,
        @Parameter(name = "uniqueName", description = "If true, makes sure the audience name is unique", in = ParameterIn.QUERY) @Valid @RequestParam(value = "uniqueName", required = false) @Nullable Boolean uniqueName
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_DELETE_AUDIENCE = "/audience/delete";
    /**
     * POST /audience/delete : Delete Audience
     * Delete an audience. The audience and account must be valid and have the appropirate permissions to view the content.
     *
     * @param accountId The logged in user. (required)
     * @param audienceId The id of the audience to delete. (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "deleteAudience",
        summary = "Delete Audience",
        description = "Delete an audience. The audience and account must be valid and have the appropirate permissions to view the content.",
        tags = { "Audience" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = AudienceApi.PATH_DELETE_AUDIENCE,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> deleteAudience(
        @NotNull @Parameter(name = "accountId", description = "The logged in user.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "audienceId", description = "The id of the audience to delete.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "audienceId", required = true) Long audienceId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_AGE_GROUPS = "/audience/ageGroups";
    /**
     * GET /audience/ageGroups : Get Age Groups
     * Gets the list of available age groups that can be selected by consumers and retailers targeting offers.
     *
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getAgeGroups",
        summary = "Get Age Groups",
        description = "Gets the list of available age groups that can be selected by consumers and retailers targeting offers.",
        tags = { "Audience" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", array = @ArraySchema(schema = @Schema(implementation = AgeGroupResponse.class)))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = AudienceApi.PATH_GET_AGE_GROUPS,
        produces = { "*/*" }
    )
    default ResponseEntity<List<AgeGroupResponse>> getAgeGroups(
        
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_AUDIENCE = "/audience/get";
    /**
     * GET /audience/get : Get Audience
     * Get an audience. The audience and account must be valid and have the appropriate permissions to view the content.
     *
     * @param accountId The logged in user. (required)
     * @param audienceId The id of the audience to return. (required)
     * @param appKey The application key (optional). If provided, results may be scoped to this application. (optional)
     * @param returnAccountCount (boolean) set to true to include the accountCount associated with current audience of the current app (optional, default to false)
     * @param returnAlbumCount (boolean) set to true to include the albumCount associated with current audience of the current app (optional, default to false)
     * @param albumTypesForCount (String) comma separated list, return an array with each item is the count of each album type. If not provided, \&quot;all_types\&quot; count is returned. (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getAudience",
        summary = "Get Audience",
        description = "Get an audience. The audience and account must be valid and have the appropriate permissions to view the content.",
        tags = { "Audience" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = AudienceResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = AudienceApi.PATH_GET_AUDIENCE,
        produces = { "*/*" }
    )
    default ResponseEntity<AudienceResponse> getAudience(
        @NotNull @Parameter(name = "accountId", description = "The logged in user.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "audienceId", description = "The id of the audience to return.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "audienceId", required = true) Long audienceId,
        @Parameter(name = "appKey", description = "The application key (optional). If provided, results may be scoped to this application.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = false) @Nullable String appKey,
        @Parameter(name = "returnAccountCount", description = "(boolean) set to true to include the accountCount associated with current audience of the current app", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnAccountCount", required = false, defaultValue = "false") Boolean returnAccountCount,
        @Parameter(name = "returnAlbumCount", description = "(boolean) set to true to include the albumCount associated with current audience of the current app", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnAlbumCount", required = false, defaultValue = "false") Boolean returnAlbumCount,
        @Parameter(name = "albumTypesForCount", description = "(String) comma separated list, return an array with each item is the count of each album type. If not provided, \"all_types\" count is returned.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "albumTypesForCount", required = false) @Nullable String albumTypesForCount
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_AUDIENCE_LIST = "/audience/search";
    /**
     * GET /audience/search : Search Audiences
     * Get the list audiences owned by the account
     *
     * @param accountId The logged in user. (optional)
     * @param albumIds Comma separated list of album IDs to filter results with (optional)
     * @param keyword The keyword used to search (optional)
     * @param keywordFields Comma separated list of fields that the keywords will match against. Possible values include: SEARCH_TAGS, NAME, DESCRIPTION, OWNER_DISPLAY (optional, default to SEARCH_TAGS,NAME,DESCRIPTION)
     * @param sortField The field to sort by, possible values include: {ID, CREATED, UPDATED, DELETED, SEARCH_TAGS, ACTIVE, NAME, DESCRIPTION, OWNER_ID, OWNER_DISPLAY, GENDER} (optional, default to NAME)
     * @param descending The order to return the results. Default is false, which will return the results in ascending order. (optional, default to false)
     * @param start The index into the record set to start with. (optional, default to 0)
     * @param limit The total number of record to return (there is a hard limit of 100). (optional, default to 20)
     * @param sendSuggestion Filter results based on whether or not the audience is set to send suggestions (optional)
     * @param activeOnly Determines whether to return only active results. Default is false. (optional)
     * @param groupByGroupingId Groups results by the audience groupingId (this does not work in conjunction with the following parameters: albumIds, audienceType, appKey, returnGlobal) (optional)
     * @param appKey Filter results by application key (optional)
     * @param returnGlobal If filtering by appKey, determines whether or not audiences that do not have an application set will also be returned as well (optional)
     * @param exactKeyword If true, match keyword exactly (optional)
     * @param audienceType (Deprecated) Filter results by audience type (optional)
     * @param audienceTypes comma separated string with the different audience types you want to filter for (optional)
     * @param returnAccountCount (boolean) set to true to include the accountCount associated with current audience of the current app (optional, default to false)
     * @param returnAlbumCount (boolean) set to true to include the albumCount associated with current audience of the current app (optional, default to false)
     * @param albumTypesForCount (String) comma separated list, return an array with each item is the count of each album type. If not provided, \&quot;all_types\&quot; count is returned. (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getAudienceList",
        summary = "Search Audiences",
        description = "Get the list audiences owned by the account",
        tags = { "Audience" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", array = @ArraySchema(schema = @Schema(implementation = SearchResponse.class)))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = AudienceApi.PATH_GET_AUDIENCE_LIST,
        produces = { "*/*" }
    )
    default ResponseEntity<List<SearchResponse>> getAudienceList(
        @Parameter(name = "accountId", description = "The logged in user.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = false) @Nullable Long accountId,
        @Parameter(name = "albumIds", description = "Comma separated list of album IDs to filter results with", in = ParameterIn.QUERY) @Valid @RequestParam(value = "albumIds", required = false) @Nullable String albumIds,
        @Parameter(name = "keyword", description = "The keyword used to search", in = ParameterIn.QUERY) @Valid @RequestParam(value = "keyword", required = false) @Nullable String keyword,
        @Parameter(name = "keywordFields", description = "Comma separated list of fields that the keywords will match against. Possible values include: SEARCH_TAGS, NAME, DESCRIPTION, OWNER_DISPLAY", in = ParameterIn.QUERY) @Valid @RequestParam(value = "keywordFields", required = false, defaultValue = "SEARCH_TAGS,NAME,DESCRIPTION") String keywordFields,
        @Parameter(name = "sortField", description = "The field to sort by, possible values include: {ID, CREATED, UPDATED, DELETED, SEARCH_TAGS, ACTIVE, NAME, DESCRIPTION, OWNER_ID, OWNER_DISPLAY, GENDER}", in = ParameterIn.QUERY) @Valid @RequestParam(value = "sortField", required = false, defaultValue = "NAME") String sortField,
        @Parameter(name = "descending", description = "The order to return the results. Default is false, which will return the results in ascending order.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "descending", required = false, defaultValue = "false") Boolean descending,
        @Parameter(name = "start", description = "The index into the record set to start with.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "start", required = false, defaultValue = "0") Integer start,
        @Parameter(name = "limit", description = "The total number of record to return (there is a hard limit of 100).", in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = false, defaultValue = "20") Integer limit,
        @Parameter(name = "sendSuggestion", description = "Filter results based on whether or not the audience is set to send suggestions", in = ParameterIn.QUERY) @Valid @RequestParam(value = "sendSuggestion", required = false) @Nullable Boolean sendSuggestion,
        @Parameter(name = "activeOnly", description = "Determines whether to return only active results. Default is false.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "activeOnly", required = false) @Nullable Boolean activeOnly,
        @Parameter(name = "groupByGroupingId", description = "Groups results by the audience groupingId (this does not work in conjunction with the following parameters: albumIds, audienceType, appKey, returnGlobal)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "groupByGroupingId", required = false) @Nullable Boolean groupByGroupingId,
        @Parameter(name = "appKey", description = "Filter results by application key", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = false) @Nullable String appKey,
        @Parameter(name = "returnGlobal", description = "If filtering by appKey, determines whether or not audiences that do not have an application set will also be returned as well", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnGlobal", required = false) @Nullable Boolean returnGlobal,
        @Parameter(name = "exactKeyword", description = "If true, match keyword exactly", in = ParameterIn.QUERY) @Valid @RequestParam(value = "exactKeyword", required = false) @Nullable Boolean exactKeyword,
        @Parameter(name = "audienceType", description = "(Deprecated) Filter results by audience type", in = ParameterIn.QUERY) @Valid @RequestParam(value = "audienceType", required = false) @Nullable String audienceType,
        @Parameter(name = "audienceTypes", description = "comma separated string with the different audience types you want to filter for", in = ParameterIn.QUERY) @Valid @RequestParam(value = "audienceTypes", required = false) @Nullable String audienceTypes,
        @Parameter(name = "returnAccountCount", description = "(boolean) set to true to include the accountCount associated with current audience of the current app", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnAccountCount", required = false, defaultValue = "false") Boolean returnAccountCount,
        @Parameter(name = "returnAlbumCount", description = "(boolean) set to true to include the albumCount associated with current audience of the current app", in = ParameterIn.QUERY) @Valid @RequestParam(value = "returnAlbumCount", required = false, defaultValue = "false") Boolean returnAlbumCount,
        @Parameter(name = "albumTypesForCount", description = "(String) comma separated list, return an array with each item is the count of each album type. If not provided, \"all_types\" count is returned.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "albumTypesForCount", required = false) @Nullable String albumTypesForCount
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_DEVICES = "/audience/devices";
    /**
     * GET /audience/devices : Get Devices
     * Gets the list of available devices that can be selected by consumers and retailers.
     *
     * @param includeInactive If true return inactive record as well. default is false. (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getDevices",
        summary = "Get Devices",
        description = "Gets the list of available devices that can be selected by consumers and retailers.",
        tags = { "Audience" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", array = @ArraySchema(schema = @Schema(implementation = AudienceDeviceResponse.class)))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = AudienceApi.PATH_GET_DEVICES,
        produces = { "*/*" }
    )
    default ResponseEntity<List<AudienceDeviceResponse>> getDevices(
        @NotNull @Parameter(name = "includeInactive", description = "If true return inactive record as well. default is false.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "includeInactive", required = true) Boolean includeInactive
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_EXPERIENCES = "/audience/experiences";
    /**
     * GET /audience/experiences : Get Experiences
     * Gets the list of available experiences that can be selected by consumers and retailers.
     *
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getExperiences",
        summary = "Get Experiences",
        description = "Gets the list of available experiences that can be selected by consumers and retailers.",
        tags = { "Audience" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = AudienceApi.PATH_GET_EXPERIENCES,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> getExperiences(
        
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_GET_GROUPED_AUDIENCES = "/audience/grouped/get";
    /**
     * GET /audience/grouped/get : Get GroupedAudiences
     * Get a group of audiences. The audience and account must be valid and have the appropriate permissions to view the content.
     *
     * @param accountId The logged in user. (required)
     * @param audienceGroupingId The audience grouping id to return. (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "getGroupedAudiences",
        summary = "Get GroupedAudiences",
        description = "Get a group of audiences. The audience and account must be valid and have the appropriate permissions to view the content.",
        tags = { "Audience" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = AudienceResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = AudienceApi.PATH_GET_GROUPED_AUDIENCES,
        produces = { "*/*" }
    )
    default ResponseEntity<AudienceResponse> getGroupedAudiences(
        @NotNull @Parameter(name = "accountId", description = "The logged in user.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "audienceGroupingId", description = "The audience grouping id to return.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "audienceGroupingId", required = true) String audienceGroupingId
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_LIST_BY_ACCOUNT = "/audience/suggestion/list";
    /**
     * POST /audience/suggestion/list : List Suggestions by Audience
     * List either Missions or Offers that the user matches the assigned audience.
     *
     * @param accountId The account to match offers for. (required)
     * @param limit the limit of the index (required)
     * @param suggestionType the type of suggestion (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "listByAccount",
        summary = "List Suggestions by Audience",
        description = "List either Missions or Offers that the user matches the assigned audience.",
        tags = { "Audience" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = OfferListResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = AudienceApi.PATH_LIST_BY_ACCOUNT,
        produces = { "*/*" }
    )
    default ResponseEntity<OfferListResponse> listByAccount(
        @NotNull @Parameter(name = "accountId", description = "The account to match offers for.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "limit", description = "the limit of the index", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = true) Integer limit,
        @NotNull @Parameter(name = "suggestionType", description = "the type of suggestion", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "suggestionType", required = true) String suggestionType
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_LIST_BY_AUDIENCE = "/audience/suggestion/offersByAudience";
    /**
     * GET /audience/suggestion/offersByAudience : List Offers by Audience
     * Get a list of offer locations based on audience information provided.
     *
     * @param limit this is the limit of the index (required)
     * @param gender this is the gender to list offers by (optional)
     * @param age this is the age to list offers by (optional)
     * @param categoryIds this is the category IDs to list offers by (optional)
     * @param latitude this is the latitude to list offers by (optional)
     * @param longitude this is the longitude to list offers by (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "listByAudience",
        summary = "List Offers by Audience",
        description = "Get a list of offer locations based on audience information provided.",
        tags = { "Audience" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = OfferListResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = AudienceApi.PATH_LIST_BY_AUDIENCE,
        produces = { "*/*" }
    )
    default ResponseEntity<OfferListResponse> listByAudience(
        @NotNull @Parameter(name = "limit", description = "this is the limit of the index", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "limit", required = true) Integer limit,
        @Parameter(name = "gender", description = "this is the gender to list offers by", in = ParameterIn.QUERY) @Valid @RequestParam(value = "gender", required = false) @Nullable String gender,
        @Parameter(name = "age", description = "this is the age to list offers by", in = ParameterIn.QUERY) @Valid @RequestParam(value = "age", required = false) @Nullable Integer age,
        @Parameter(name = "categoryIds", description = "this is the category IDs to list offers by", in = ParameterIn.QUERY) @Valid @RequestParam(value = "categoryIds", required = false) @Nullable String categoryIds,
        @Parameter(name = "latitude", description = "this is the latitude to list offers by", in = ParameterIn.QUERY) @Valid @RequestParam(value = "latitude", required = false) @Nullable Double latitude,
        @Parameter(name = "longitude", description = "this is the longitude to list offers by", in = ParameterIn.QUERY) @Valid @RequestParam(value = "longitude", required = false) @Nullable Double longitude
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_LIST_LASTEST_BY_ACCOUNT = "/audience/suggestion/latest";
    /**
     * GET /audience/suggestion/latest : List Sent Suggestions 
     * Return list of recent trigger suggestions that have been sent to the user.
     *
     * @param accountId The account to match offers for. (required)
     * @param timeframe The timeframe in seconds of the latest suggestions (required)
     * @param suggestionType The type of trigger suggestions to return (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "listLastestByAccount",
        summary = "List Sent Suggestions ",
        description = "Return list of recent trigger suggestions that have been sent to the user.",
        tags = { "Audience" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = OfferListResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = AudienceApi.PATH_LIST_LASTEST_BY_ACCOUNT,
        produces = { "*/*" }
    )
    default ResponseEntity<OfferListResponse> listLastestByAccount(
        @NotNull @Parameter(name = "accountId", description = "The account to match offers for.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "timeframe", description = "The timeframe in seconds of the latest suggestions", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "timeframe", required = true) Integer timeframe,
        @NotNull @Parameter(name = "suggestionType", description = "The type of trigger suggestions to return", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "suggestionType", required = true) String suggestionType
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_SEND_BY_ACCOUNT = "/audience/suggestion/send";
    /**
     * POST /audience/suggestion/send : Send Suggestions
     * Use the accountId to determine the associated BillableEntity. From there get a list of all triggers associated with the BillableEntity.
     *
     * @param accountId The account to match offers for. (required)
     * @param latitude the latitude (required)
     * @param longitude the longitude (required)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "sendByAccount",
        summary = "Send Suggestions",
        description = "Use the accountId to determine the associated BillableEntity. From there get a list of all triggers associated with the BillableEntity.",
        tags = { "Audience" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = SirqulResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = AudienceApi.PATH_SEND_BY_ACCOUNT,
        produces = { "*/*" }
    )
    default ResponseEntity<SirqulResponse> sendByAccount(
        @NotNull @Parameter(name = "accountId", description = "The account to match offers for.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "latitude", description = "the latitude", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "latitude", required = true) Double latitude,
        @NotNull @Parameter(name = "longitude", description = "the longitude", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "longitude", required = true) Double longitude
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    String PATH_UPDATE_AUDIENCE = "/audience/update";
    /**
     * POST /audience/update : Update Audience
     * Update a user defined audience.
     *
     * @param accountId The logged in user. (required)
     * @param audienceId The id of the audience to update. (required)
     * @param name The name of the audience (optional)
     * @param description The description of the audience (optional)
     * @param searchTags The search tags (optional)
     * @param gender The gender; possible values are: MALE, FEMALE, ANY (optional)
     * @param ageGroups The list of age groups, comma separated; possible values are AGE_0_13, AGE_14_17, AGE_18_22, AGE_23_30, AGE_31_54, AGE_55_PLUS, AGE_ANY (to reset to none) (optional)
     * @param categoryIds The list of category ids, comma separated; possible values are retrieved via /api/{version}/category/search (pass in id values) (optional)
     * @param applicationIds The list of application ids, comma separated; possible values are retrieved via /api/{version}/application/list (pass in id values) (optional)
     * @param gameExperienceLevel The experience level of the player; possible values are: ANY, NEW, BEGINNER, INTERMEDIATE, EXPERT (optional)
     * @param devices (Deprecated) Use deviceIds. The list of targeted device names, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in name values) (optional)
     * @param deviceIds The list of targeted device ids, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in id values) (optional)
     * @param deviceVersions The list of targeted device version ranges that are aligned with the provided devices list, comma separated (examples: 2.3-X, 0-5.1.4, 4.3.1-6.1.4) (optional)
     * @param locations The list of locations to build the center around; comma separated list of latitude/longitude pairs (example: lat1,long1,lat2,long2) (optional)
     * @param radius The list of radius of influence for the audience, in miles; comma separated list. Either provide 1 to be applied to all location pairs or a matching list to each lat/long pair. (optional)
     * @param active if audience is active (optional)
     * @param sendSuggestion If true, then notify matching users when they are inside the radius (optional)
     * @param startTimeOffset Seconds from the start time of an event (optional)
     * @param endTimeOffset Seconds from the end time of an event (optional)
     * @param associateDescription the associate description (optional)
     * @param associateType The type of the object to center the audience geofence (optional)
     * @param associateId The ID of the object to center the audience geofence (optional)
     * @param groupingId Optional grouping id for the audience (optional)
     * @param metaData External custom client defined data (optional)
     * @param visibility Visibility of the audience (optional)
     * @param audienceType Type of audience (optional)
     * @param useOrder Use order for cohort (optional)
     * @param cohortRegionsData Cohort data for \&quot;cohort\&quot; audience type (optional)
     * @param appKey Filter results by application key (optional)
     * @param trilaterationTypes Trilateration types (optional)
     * @param uniqueName If true, makes sure the audience name is unique (optional)
     * @return successful operation (status code 200)
     */
    @Operation(
        operationId = "updateAudience",
        summary = "Update Audience",
        description = "Update a user defined audience.",
        tags = { "Audience" },
        responses = {
            @ApiResponse(responseCode = "200", description = "successful operation", content = {
                @Content(mediaType = "*/*", schema = @Schema(implementation = AudienceResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = AudienceApi.PATH_UPDATE_AUDIENCE,
        produces = { "*/*" }
    )
    default ResponseEntity<AudienceResponse> updateAudience(
        @NotNull @Parameter(name = "accountId", description = "The logged in user.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "accountId", required = true) Long accountId,
        @NotNull @Parameter(name = "audienceId", description = "The id of the audience to update.", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "audienceId", required = true) Long audienceId,
        @Parameter(name = "name", description = "The name of the audience", in = ParameterIn.QUERY) @Valid @RequestParam(value = "name", required = false) @Nullable String name,
        @Parameter(name = "description", description = "The description of the audience", in = ParameterIn.QUERY) @Valid @RequestParam(value = "description", required = false) @Nullable String description,
        @Parameter(name = "searchTags", description = "The search tags", in = ParameterIn.QUERY) @Valid @RequestParam(value = "searchTags", required = false) @Nullable String searchTags,
        @Parameter(name = "gender", description = "The gender; possible values are: MALE, FEMALE, ANY", in = ParameterIn.QUERY) @Valid @RequestParam(value = "gender", required = false) @Nullable String gender,
        @Parameter(name = "ageGroups", description = "The list of age groups, comma separated; possible values are AGE_0_13, AGE_14_17, AGE_18_22, AGE_23_30, AGE_31_54, AGE_55_PLUS, AGE_ANY (to reset to none)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "ageGroups", required = false) @Nullable String ageGroups,
        @Parameter(name = "categoryIds", description = "The list of category ids, comma separated; possible values are retrieved via /api/{version}/category/search (pass in id values)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "categoryIds", required = false) @Nullable String categoryIds,
        @Parameter(name = "applicationIds", description = "The list of application ids, comma separated; possible values are retrieved via /api/{version}/application/list (pass in id values)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "applicationIds", required = false) @Nullable String applicationIds,
        @Parameter(name = "gameExperienceLevel", description = "The experience level of the player; possible values are: ANY, NEW, BEGINNER, INTERMEDIATE, EXPERT", in = ParameterIn.QUERY) @Valid @RequestParam(value = "gameExperienceLevel", required = false) @Nullable String gameExperienceLevel,
        @Parameter(name = "devices", description = "(Deprecated) Use deviceIds. The list of targeted device names, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in name values)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "devices", required = false) @Nullable String devices,
        @Parameter(name = "deviceIds", description = "The list of targeted device ids, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in id values)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceIds", required = false) @Nullable String deviceIds,
        @Parameter(name = "deviceVersions", description = "The list of targeted device version ranges that are aligned with the provided devices list, comma separated (examples: 2.3-X, 0-5.1.4, 4.3.1-6.1.4)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "deviceVersions", required = false) @Nullable String deviceVersions,
        @Parameter(name = "locations", description = "The list of locations to build the center around; comma separated list of latitude/longitude pairs (example: lat1,long1,lat2,long2)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "locations", required = false) @Nullable String locations,
        @Parameter(name = "radius", description = "The list of radius of influence for the audience, in miles; comma separated list. Either provide 1 to be applied to all location pairs or a matching list to each lat/long pair.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "radius", required = false) @Nullable String radius,
        @Parameter(name = "active", description = "if audience is active", in = ParameterIn.QUERY) @Valid @RequestParam(value = "active", required = false) @Nullable Boolean active,
        @Parameter(name = "sendSuggestion", description = "If true, then notify matching users when they are inside the radius", in = ParameterIn.QUERY) @Valid @RequestParam(value = "sendSuggestion", required = false) @Nullable Boolean sendSuggestion,
        @Parameter(name = "startTimeOffset", description = "Seconds from the start time of an event", in = ParameterIn.QUERY) @Valid @RequestParam(value = "startTimeOffset", required = false) @Nullable Integer startTimeOffset,
        @Parameter(name = "endTimeOffset", description = "Seconds from the end time of an event", in = ParameterIn.QUERY) @Valid @RequestParam(value = "endTimeOffset", required = false) @Nullable Integer endTimeOffset,
        @Parameter(name = "associateDescription", description = "the associate description", in = ParameterIn.QUERY) @Valid @RequestParam(value = "associateDescription", required = false) @Nullable String associateDescription,
        @Parameter(name = "associateType", description = "The type of the object to center the audience geofence", in = ParameterIn.QUERY) @Valid @RequestParam(value = "associateType", required = false) @Nullable String associateType,
        @Parameter(name = "associateId", description = "The ID of the object to center the audience geofence", in = ParameterIn.QUERY) @Valid @RequestParam(value = "associateId", required = false) @Nullable Long associateId,
        @Parameter(name = "groupingId", description = "Optional grouping id for the audience", in = ParameterIn.QUERY) @Valid @RequestParam(value = "groupingId", required = false) @Nullable String groupingId,
        @Parameter(name = "metaData", description = "External custom client defined data", in = ParameterIn.QUERY) @Valid @RequestParam(value = "metaData", required = false) @Nullable String metaData,
        @Parameter(name = "visibility", description = "Visibility of the audience", in = ParameterIn.QUERY) @Valid @RequestParam(value = "visibility", required = false) @Nullable String visibility,
        @Parameter(name = "audienceType", description = "Type of audience", in = ParameterIn.QUERY) @Valid @RequestParam(value = "audienceType", required = false) @Nullable String audienceType,
        @Parameter(name = "useOrder", description = "Use order for cohort", in = ParameterIn.QUERY) @Valid @RequestParam(value = "useOrder", required = false) @Nullable Boolean useOrder,
        @Parameter(name = "cohortRegionsData", description = "Cohort data for \"cohort\" audience type", in = ParameterIn.QUERY) @Valid @RequestParam(value = "cohortRegionsData", required = false) @Nullable String cohortRegionsData,
        @Parameter(name = "appKey", description = "Filter results by application key", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appKey", required = false) @Nullable String appKey,
        @Parameter(name = "trilaterationTypes", description = "Trilateration types", in = ParameterIn.QUERY) @Valid @RequestParam(value = "trilaterationTypes", required = false) @Nullable String trilaterationTypes,
        @Parameter(name = "uniqueName", description = "If true, makes sure the audience name is unique", in = ParameterIn.QUERY) @Valid @RequestParam(value = "uniqueName", required = false) @Nullable Boolean uniqueName
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }

}
